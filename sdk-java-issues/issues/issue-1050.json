{
  "assignees": [],
  "author": {
    "id": "MDQ6VXNlcjI2MDI5Nzg=",
    "is_bot": false,
    "login": "natalie-zamani",
    "name": "Natalie Zamani"
  },
  "body": "## Expected Behavior\r\nI would expect that an activity interface that extends some other interface with generic types and a method that uses those generic types would have that inherited method be executable as an activity method within a workflow.\r\n\r\n## Actual Behavior\r\nA method that's inherited and uses generics in an activity interface always throws a `ClassCastException` when called within a workflow.\r\n\r\nAn example of the exception (using the repro code included in this issue) is. as follows:\r\n```kotlin\r\njava.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class issue.repro.Foo (java.util.LinkedHashMap is in module java.base of loader 'bootstrap'; issue.repro.Foo is in unnamed module of loader 'app')\r\n\tat issue.repro.MyActivityImpl.run(ActivityIssueReproTest.kt:38)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\r\n\tat io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:214)\r\n\tat io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityImplementation.execute(POJOActivityTaskHandler.java:180)\r\n\tat io.temporal.internal.activity.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:120)\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:235)\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:207)\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:196)\r\n\tat io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat java.base/java.lang.Thread.run(Thread.java:829)\r\n```\r\n\r\n## Steps to Reproduce the Problem\r\nThe repro Kotlin code below uses the Temporal Java SDK (with the Kotlin library), and [mockk](https://mockk.io) and [Kotest](https://kotest.io).\r\n\r\n```kotlin\r\nimport com.fasterxml.jackson.databind.ObjectMapper\r\nimport com.fasterxml.jackson.module.kotlin.registerKotlinModule\r\nimport io.kotest.core.spec.style.ShouldSpec\r\nimport io.kotest.matchers.shouldBe\r\nimport io.mockk.every\r\nimport io.mockk.mockk\r\nimport io.mockk.verify\r\nimport io.temporal.activity.ActivityInterface\r\nimport io.temporal.activity.LocalActivityOptions\r\nimport io.temporal.client.WorkflowClientOptions\r\nimport io.temporal.client.WorkflowOptions\r\nimport io.temporal.common.converter.DefaultDataConverter\r\nimport io.temporal.common.converter.JacksonJsonPayloadConverter\r\nimport io.temporal.internal.logging.LoggerTag\r\nimport io.temporal.testing.TestEnvironmentOptions\r\nimport io.temporal.testing.TestWorkflowEnvironment\r\nimport io.temporal.worker.Worker\r\nimport io.temporal.worker.WorkerOptions\r\nimport io.temporal.worker.WorkflowImplementationOptions\r\nimport io.temporal.workflow.Workflow\r\nimport io.temporal.workflow.WorkflowInterface\r\nimport io.temporal.workflow.WorkflowMethod\r\nimport java.time.Duration\r\n\r\nclass Foo\r\n\r\nclass Bar\r\n\r\ninterface InterfaceWithGenerics<InputT : Any, OutputT : Any> {\r\n    fun run(input: InputT): OutputT\r\n}\r\n\r\n@ActivityInterface\r\ninterface MyActivity : InterfaceWithGenerics<Foo, Bar>\r\n\r\nclass MyActivityImpl : MyActivity {\r\n    override fun run(input: Foo): Bar {\r\n        return Bar()\r\n    }\r\n}\r\n\r\n@WorkflowInterface\r\ninterface MyWorkflow {\r\n    @WorkflowMethod\r\n    fun run(input: Foo): Bar\r\n}\r\n\r\nclass MyWorkflowImpl : MyWorkflow {\r\n    private val myActivity = Workflow.newLocalActivityStub(\r\n        MyActivity::class.java,\r\n        LocalActivityOptions { setStartToCloseTimeout(Duration.ofSeconds(10)) }\r\n    )\r\n\r\n    override fun run(input: Foo): Bar {\r\n        return myActivity.run(input)\r\n    }\r\n}\r\n\r\nclass ActivityIssueReproTest : ShouldSpec({\r\n    val myActivity = mockk<MyActivityImpl>()\r\n\r\n    val testEnv: TestWorkflowEnvironment = run {\r\n        val objectMapper: ObjectMapper = ObjectMapper().also { mapper ->\r\n            mapper.registerKotlinModule()\r\n        }\r\n        val dataConverter = DefaultDataConverter(JacksonJsonPayloadConverter(objectMapper))\r\n        val workflowClientOptions = WorkflowClientOptions.newBuilder()\r\n            .setDataConverter(dataConverter)\r\n            .build()\r\n        val workflowTestEnvironmentOptions = TestEnvironmentOptions.newBuilder()\r\n            .setWorkflowClientOptions(workflowClientOptions)\r\n            .build()\r\n\r\n        TestWorkflowEnvironment.newInstance(workflowTestEnvironmentOptions)\r\n    }\r\n\r\n    val worker: Worker = run {\r\n        val workerOptions: WorkerOptions = WorkerOptions.newBuilder()\r\n            .setDefaultDeadlockDetectionTimeout(5_000L)\r\n            .validateAndBuildWithDefaults()\r\n\r\n        testEnv.newWorker(LoggerTag.TASK_QUEUE, workerOptions).also { worker ->\r\n            // Register the workflow implementation(s)\r\n            worker.registerWorkflowImplementationTypes(\r\n                WorkflowImplementationOptions { setFailWorkflowExceptionTypes(Throwable::class.java) },\r\n                MyWorkflowImpl::class.java\r\n            )\r\n            // Register the activity implementation(s)\r\n            worker.registerActivitiesImplementations(myActivity)\r\n        }\r\n    }\r\n\r\n    val defaultWorkflowOptions = WorkflowOptions\r\n        .newBuilder()\r\n        .setTaskQueue(LoggerTag.TASK_QUEUE)\r\n        .build()\r\n\r\n    beforeTest {\r\n        testEnv.start()\r\n    }\r\n\r\n    should(\"repro the Temporal issue we're seeing\") {\r\n        val response = Bar()\r\n        every { myActivity.run(any()) } returns response\r\n\r\n        val myWorkflow = testEnv.workflowClient.newWorkflowStub(\r\n            MyWorkflow::class.java,\r\n            defaultWorkflowOptions\r\n        )\r\n\r\n        val foo = Foo()\r\n        val result = myWorkflow.run(foo)\r\n\r\n        result shouldBe response\r\n        verify {\r\n            myActivity.run(foo)\r\n        }\r\n    }\r\n\r\n    afterTest {\r\n        testEnv.close()\r\n    }\r\n})\r\n```\r\n\r\n## Specifications\r\n\r\n  - Version: 1.8.0\r\n  - Platform: macOS\r\n",
  "closedAt": null,
  "comments": [],
  "createdAt": "2022-02-21T23:13:33Z",
  "labels": [
    {
      "id": "MDU6TGFiZWwxNjIyNzE5ODQx",
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    }
  ],
  "milestone": null,
  "number": 1050,
  "reactionGroups": [
    {
      "content": "EYES",
      "users": {
        "totalCount": 1
      }
    }
  ],
  "state": "OPEN",
  "title": "Activity interface which extends an interface with some method using generic types always throws a ClassCastException when said method is called in a Workflow",
  "updatedAt": "2023-04-20T17:39:22Z",
  "url": "https://github.com/temporalio/sdk-java/issues/1050"
}
