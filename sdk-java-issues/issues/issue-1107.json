{
  "assignees": [],
  "author": {
    "id": "MDQ6VXNlcjUzMjEwOA==",
    "is_bot": false,
    "login": "Spikhalskiy",
    "name": "Dmitry Spikhalsky"
  },
  "body": "## Expected Behavior\r\n\r\nSuch a workflow interfaces hierarchy:\r\n\r\n```\r\n@WorkflowInterface\r\npublic interface ReportingWorkflow extends TemporalWorkflow<ReportQueriesResponse> {\r\n  @WorkflowMethod\r\n  ReportQueriesResponse runReport(ReportQueries reportQueries);\r\n\r\n  @QueryMethod\r\n  @Override\r\n  ReportQueriesResponse getResults();\r\n}\r\n\r\npublic interface TemporalWorkflow<T> extends TemporalRunnable {\r\n  T getResults();\r\n}\r\n```\r\n\r\nshould be fine.\r\n\r\n## Actual Behavior\r\n\r\nTriggers `java.lang.IllegalArgumentException: Duplicated name of QUERY: \"getResults\" declared at \"public abstract xxx.ReportingProto$ReportQueriesResponse xxx.ReportingWorkflow.getResults()\" and \"public default java.lang.Object xxx.ReportingWorkflow.getResults()\"`\r\n\r\n## Specifications\r\n\r\n  - Version: 1.8.x\r\n",
  "closedAt": null,
  "comments": [
    {
      "id": "IC_kwDODN12PM5MK5AT",
      "author": {
        "login": "shabalin"
      },
      "authorAssociation": "NONE",
      "body": "The same happened if you override with @WorkflowMethod\r\n```\r\npublic interface TemporalWorkflow<T> {\r\n    void execute(T params);\r\n}\r\n```\r\nand then define the actual workflow interface:\r\n```\r\n@WorkflowInterface\r\npublic interface SearchTaskWorkflow extends TemporalWorkflow<SearchWorkflowParams> {\r\n    @WorkflowMethod\r\n    @Override\r\n    void execute(SearchWorkflowParams params);\r\n}\r\n```\r\nWorkflow registration fails with the error:\r\n```\r\njava.lang.IllegalArgumentException: Duplicated @WorkflowMethod: public default void io.dev.analytics.temporal.SearchTaskWorkflow.execute(java.lang.Object) and public abstract void io.dev.analytics.temporal.SearchTaskWorkflow.execute(io.dev.analytics.service.search.async.SearchWorkflowParams)\r\n\tat io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods(POJOWorkflowInterfaceMetadata.java:296) ~[temporal-sdk-1.16.0.jar:na]\r\n\tat io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.<init>(POJOWorkflowInterfaceMetadata.java:205) ~[temporal-sdk-1.16.0.jar:na]\r\n\tat io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newInstanceInternal(POJOWorkflowInterfaceMetadata.java:184) ~[temporal-sdk-1.16.0.jar:na]\r\n\tat io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newImplementationInstance(POJOWorkflowInterfaceMetadata.java:153) ~[temporal-sdk-1.16.0.jar:na]\r\n\tat io.temporal.common.metadata.POJOWorkflowImplMetadata.<init>(POJOWorkflowImplMetadata.java:107) ~[temporal-sdk-1.16.0.jar:na]\r\n\tat io.temporal.common.metadata.POJOWorkflowImplMetadata.newInstance(POJOWorkflowImplMetadata.java:75) ~[temporal-sdk-1.16.0.jar:na]\r\n```\r\n\r\nIn documentation it's said \r\n> Note that this approach does not apply to @WorkflowMethod annotations, meaning that when using a base interface, it should not include any @WorkflowMethod methods\r\n\r\nbut we don't mark the parent interface method with a @WorkflowMethod\r\n\r\n\r\nI think the reason it's happening is in:\r\n`POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods`\r\n\r\n```\r\n    Method[] declaredMethods = current.getDeclaredMethods();\r\n    for (Method declaredMethod : declaredMethods) {\r\n      POJOWorkflowMethod methodMetadata = new POJOWorkflowMethod(declaredMethod);\r\n      if (validateAndQualifiedForWorkflowMethod(methodMetadata)) {\r\n        result.add(methodMetadata);\r\n      }\r\n    }\r\n\r\n```\r\n\r\nthe  `current.getDeclaredMethods()` returns both methods and then in POJOWorkflowMethod constructor there is this\r\n```\r\n WorkflowMethod workflowMethod = method.getAnnotation(WorkflowMethod.class);\r\n```\r\nwhich returns not null result for both methods and that causes an error\r\n\r\n============== Update ===========================\r\nLooks like the fix could be quite simple for my case:\r\n1. In `POJOWorkflowInterfaceMetadata.validateAndQualifiedForWorkflowMethod` there is a check whether the method is **synthetic**, if positive case it would reject the method. Parent interface method is `synthetic`, _but_  the check happens after another condition (`isAnnotatedWorkflowMethod`) that is true so the execution doesn't reach the synthetic flag checking.\r\n```\r\n    if (isAnnotatedWorkflowMethod) {\r\n      // all methods explicitly marked with one of workflow method qualifiers\r\n      return true;\r\n    }\r\n\r\n    if (method.isSynthetic()) {\r\n      // if method is synthetic and not explicitly marked as a workflow method,\r\n      // it's not qualified as a workflow method.\r\n      // https://github.com/temporalio/sdk-java/issues/977\r\n      // https://github.com/temporalio/sdk-java/issues/1331\r\n      return false;\r\n    }\r\n```\r\n\r\nCan we do `isAnnotatedWorkflowMethod && !method.isSynthetic()` here ?\r\n",
      "createdAt": "2022-10-13T17:06:29Z",
      "includesCreatedEdit": true,
      "isMinimized": false,
      "minimizedReason": "",
      "reactionGroups": [],
      "url": "https://github.com/temporalio/sdk-java/issues/1107#issuecomment-1277923347",
      "viewerDidAuthor": false
    }
  ],
  "createdAt": "2022-03-31T00:38:44Z",
  "labels": [
    {
      "id": "MDU6TGFiZWwxNjIyNzE5ODQx",
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    }
  ],
  "milestone": null,
  "number": 1107,
  "reactionGroups": [],
  "state": "OPEN",
  "title": "Workflow metadata resolution code registers an overridden method from parent class as a second query",
  "updatedAt": "2022-10-13T17:27:04Z",
  "url": "https://github.com/temporalio/sdk-java/issues/1107"
}
