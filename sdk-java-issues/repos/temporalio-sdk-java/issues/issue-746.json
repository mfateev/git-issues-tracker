{
  "assignees": [],
  "author": {
    "id": "MDQ6VXNlcjUzMjEwOA==",
    "is_bot": false,
    "login": "Spikhalskiy",
    "name": "Dmitry Spikhalsky"
  },
  "body": "## Expected Behavior\r\nActivityStubs should be created for each workflow instance / execution separately.\r\n\r\nBut if somebody uses Dependency Injection frameworks with Temporal it's very easy to misconfigure the wiring (for example, by making them lazily initialized on first usage singletons) in a way that activity stubs will be leaking between workflow instances.\r\nWe should detect or provide better protection or diagnostic if this happens that actually helps to understand the problem.\r\n\r\n## Actual Behavior\r\n\r\nCryptic Event Loop error that makes to look in a completely wrong direction.\r\n\r\n```\r\n        Caused by:\r\n        io.temporal.failure.ApplicationFailure: message='Operation allowed only while eventLoop is running', type='java.lang.IllegalStateException', nonRetryable=false\r\n            at io.temporal.internal.statemachines.WorkflowStateMachines.checkEventLoopExecuting(WorkflowStateMachines.java:915)\r\n            at io.temporal.internal.statemachines.WorkflowStateMachines.randomUUID(WorkflowStateMachines.java:611)\r\n            at io.temporal.internal.replay.ReplayWorkflowContextImpl.randomUUID(ReplayWorkflowContextImpl.java:93)\r\n            at io.temporal.internal.sync.SyncWorkflowContext.constructExecuteLocalActivityParameters(SyncWorkflowContext.java:351)\r\n            at io.temporal.internal.sync.SyncWorkflowContext.executeLocalActivityOnce(SyncWorkflowContext.java:292)\r\n            at io.temporal.internal.sync.SyncWorkflowContext.executeLocalActivityOnce(SyncWorkflowContext.java:275)\r\n            at io.temporal.internal.sync.SyncWorkflowContext.lambda$executeLocalActivity$a6925f48$1(SyncWorkflowContext.java:269)\r\n            at io.temporal.internal.sync.WorkflowRetryerInternal.retryAsync(WorkflowRetryerInternal.java:232)\r\n            at io.temporal.internal.sync.SyncWorkflowContext.executeLocalActivity(SyncWorkflowContext.java:268)\r\n            at io.temporal.common.interceptors.WorkflowOutboundCallsInterceptorBase.executeLocalActivity(WorkflowOutboundCallsInterceptorBase.java:48)\r\n            at io.temporal.opentracing.internal.OpenTracingWorkflowOutboundCallsInterceptor.executeLocalActivity(OpenTracingWorkflowOutboundCallsInterceptor.java:70)\r\n            at io.temporal.internal.sync.LocalActivityStubImpl.executeAsync(LocalActivityStubImpl.java:50)\r\n            at io.temporal.internal.sync.ActivityStubBase.execute(ActivityStubBase.java:38)\r\n            at io.temporal.internal.sync.LocalActivityStubImpl.execute(LocalActivityStubImpl.java:29)\r\n            at io.temporal.internal.sync.LocalActivityInvocationHandler.lambda$getActivityFunc$0(LocalActivityInvocationHandler.java:72)\r\n            at io.temporal.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:70)\r\n            at com.sun.proxy.$Proxy158.execute(Unknown Source:0)\r\n            <!-- a project specific workflow code -->\r\n            at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method:0)\r\n            at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n            at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n            at java.base/java.lang.reflect.Method.invoke(Method.java:566)\r\n            at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.execute(POJOWorkflowImplementationFactory.java:321)\r\n            at io.temporal.common.interceptors.WorkflowInboundCallsInterceptorBase.execute(WorkflowInboundCallsInterceptorBase.java:37)\r\n            at io.temporal.opentracing.internal.OpenTracingWorkflowInboundCallsInterceptor.execute(OpenTracingWorkflowInboundCallsInterceptor.java:72)\r\n            at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:295)\r\n            at io.temporal.internal.sync.WorkflowExecuteRunnable.run(WorkflowExecuteRunnable.java:53)\r\n            at io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:131)\r\n            at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:101)\r\n            at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:110)\r\n            at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)\r\n            at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\r\n            at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n            at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n            at java.base/java.lang.Thread.run(Thread.java:829)\r\n```\r\n\r\nThis specific issue happened with DI wiring using Dagger\r\n\r\n# Alternative\r\n\r\nThere is no reason for ActivityStub that is a pair of ActivityType, ActivityOptions to don't be workflow context-independent. We can make internal changes to make them safely shareable, which is probably a better user experience.",
  "closedAt": null,
  "comments": [],
  "createdAt": "2021-09-21T17:45:07Z",
  "labels": [
    {
      "id": "MDU6TGFiZWwxNjIyNzE5ODQ0",
      "name": "enhancement",
      "description": "User experience",
      "color": "a2eeef"
    }
  ],
  "milestone": null,
  "number": 746,
  "reactionGroups": [],
  "state": "OPEN",
  "title": "Reuse of ActivityStubs from another workflow should produce a usable diagnostic or be allowed",
  "updatedAt": "2024-12-17T21:20:33Z",
  "url": "https://github.com/temporalio/sdk-java/issues/746"
}
