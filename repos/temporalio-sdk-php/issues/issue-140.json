{"assignees":[{"id":"MDQ6VXNlcjk5NTk3NjE=","login":"seregazhuk","name":"Sergey Zhuk","databaseId":0}],"author":{"id":"MDQ6VXNlcjMzMjExNzU=","is_bot":false,"login":"benalf","name":"Alfred Bendrup"},"body":"### Describe the bug\r\nStill not sure if it a bug or an intended feature.\r\n\r\nIf there are any unfinished async closures and workflow somehow reaches a finishing condition like a regular `return` statement or a non-retryable `Exception`, the workflow will be kept in a running state until all async closures are finished even after evaluating the return/exception.\r\n\r\nIn case it's an intended feature and the user is supposed to manually cleanup all open resources, it becomes difficult to do so cleanly in certain cases.\r\nThe most annoying example is running a long activity with an async completion in a coroutine. Since there's no heartbeat (and it wouldn't make sense to heartbeat for days either), there's doesn't seem to be an easy way to cancel it without sending a manual completion through the client itself.\r\n\r\n### Minimal Reproduction\r\nFull project with a docker-compose in the attached `repro.zip`. `docker-compose up` to run the env, `docker-compose exec app php app.php execute` to run the workflow.\r\n\r\nEven if the workflow evaluates an `Exception` or does a `return`, it still is stuck in a `Running` state until all coroutines are closed. Bug or a feature?\r\n\r\n#### Relevant bits:\r\nWorkflow\r\n```php\r\nclass BlockedWorkflow implements BlockedWorkflowInterface\r\n{\r\n    private $regularActivity;\r\n    private bool $timerFired = false;\r\n    private $someDataFromCoroutineActivity = null;\r\n\r\n    public function __construct(\r\n        private LoggerInterface $logger = new Logger(),\r\n    ) {\r\n        $this->regularActivity = Workflow::newActivityStub(\r\n            RegularActivityInterface::class,\r\n            ActivityOptions::new()\r\n                ->withScheduleToCloseTimeout(CarbonInterval::minutes(10))\r\n                ->withHeartbeatTimeout(3)\r\n                ->withCancellationType(ActivityCancellationType::WAIT_CANCELLATION_COMPLETED)\r\n        );\r\n    }\r\n\r\n    public function run()\r\n    {\r\n        $timerScope = Workflow::async(\r\n            fn () => yield Workflow::timer(3)->then(fn() => $this->timerFired = true) // if timer value exceeds time to wf return, that return is also blocked\r\n        );\r\n\r\n        $activityScope = Workflow::async(\r\n            fn () => $this->someDataFromCoroutineActivity = yield $this->regularActivity->runActivity()\r\n        );\r\n\r\n        yield Workflow::await(fn () => $this->timerFired || $this->someDataFromCoroutineActivity);\r\n\r\n        if ($this->timerFired) {\r\n            $this->logger->info('Workflow Terminating with Exception');\r\n            // $scope->cancel(); // unless cancelled, the wf doesn't terminate until activity finishes\r\n            throw new \\Exception();\r\n        }\r\n\r\n        $this->logger->info('Workflow Terminating with normal return');\r\n        // $timerScope->cancel(); // unless cancelled, the wf doesn't terminate until timer finishes\r\n\r\n        return $this->someDataFromCoroutineActivity;\r\n    }\r\n}\r\n```\r\n\r\nActivity\r\n```php\r\n<?php\r\n\r\n#[ActivityInterface]\r\nclass RegularActivity implements RegularActivityInterface\r\n{\r\n    public function __construct(\r\n        private LoggerInterface $logger = new Logger(),\r\n    ) {\r\n    }\r\n\r\n    #[ActivityMethod]\r\n    public function runActivity(): string\r\n    {\r\n        $this->logger->info('Starting regular activity with a 1s sleep loop');\r\n\r\n        for ($i = 0; $i < 5; $i++) {\r\n            $this->logger->info('Activity tick');\r\n            sleep(1);\r\n            Activity::heartbeat($i);\r\n        }\r\n\r\n        $this->logger->info('Activity terminating');\r\n\r\n        return 'Activity result';\r\n    }\r\n}\r\n```\r\n\r\n### Environment/Versions\r\n\r\n- OS and processor: Linux\r\n- Temporal Version: `temporalio/auto-setup:1.14.4` with 1.1.0 sdk-php on `php:8.1-cli-alpine`\r\n- Running in Docker\r\n\r\n[repro.zip](https://github.com/temporalio/sdk-php/files/7980666/repro.zip)\r\n","closedAt":"2022-02-19T16:17:47Z","comments":[{"id":"IC_kwDOEY5HBM49VlIA","author":{"login":"benalf"},"authorAssociation":"NONE","body":"Just noticed the current minor version php81 alpine cli base image breaks sockets extension install in the attached reproduction project.\r\n\r\nIn case you need it, gotta add `CFLAGS=\"$CFLAGS -D_GNU_SOURCE\"` to the Dockerfile:\r\n```\r\n    && CFLAGS=\"$CFLAGS -D_GNU_SOURCE\" docker-php-ext-install sockets && docker-php-ext-enable sockets  \\\r\n```\r\n","createdAt":"2022-02-03T14:50:32Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-php/issues/140#issuecomment-1029067264","viewerDidAuthor":false},{"id":"IC_kwDOEY5HBM497Qmu","author":{"login":"wolfy-j"},"authorAssociation":"COLLABORATOR","body":"Just to confirm, all the activities are canceled correctly when you send the cancel command to the workflow? Workflows are not expected to die on exception unless you clearly marked it as application exception. Temporal will attempt to restart and replay it until it's fixed.","createdAt":"2022-02-14T10:59:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-php/issues/140#issuecomment-1038944686","viewerDidAuthor":false},{"id":"IC_kwDOEY5HBM498Ev1","author":{"login":"benalf"},"authorAssociation":"NONE","body":"Sorry, detouring a bit from your question (we haven't tried cancelling the workflow itself, we tried cancelling all running scopes/activities to let it gracefully terminate itself).\r\n\r\nI think the \"issue\" can actually be reduced to async closure scopes blocking workflow completion. The activity termination I was initially focused on was more of a red herring.\r\n\r\n```php\r\n    #[WorkflowMethod(\"run\")]\r\n    public function run() {\r\n        $scope = Workflow::async(fn () => yield Workflow::timer(15)->then(fn () => $this->timedOut = true));\r\n\r\n        return 'ok'; // will wait for scope to close or needs to be manually cancelled before the workflow will be marked as Completed\r\n    }\r\n```\r\nIt totally makes sense. ~~However, it becomes difficult to cancel a scope if it spawns an activity with async completion since there's no heartbeat.~~\r\n\r\nWhile playing with a minimal repro code, I tried cancelling a scope with async completion activity in it without adding any hearbeat/cancellationtype ...and it just cancels it (solving the issue of me going through the client).\r\n\r\n```php\r\n    #[WorkflowMethod(\"run\")]\r\n    public function run() {\r\n        $activity = Workflow::newActivityStub(\r\n            SomeAsyncCompletionActivity::class,\r\n            ActivityOptions::new()\r\n                ->withScheduleToCloseTimeout(1000)\r\n                // ->withCancellationType(ActivityCancellationType::WAIT_CANCELLATION_COMPLETED) // can't be used\r\n                ->withRetryOptions(\r\n                    RetryOptions::new()->withMaximumAttempts(1)\r\n                )\r\n        );\r\n\r\n        $scope = Workflow::async(fn () => yield $activity->process());\r\n        yield Workflow::timer(1); // breathing room\r\n\r\n\r\n        $scope->cancel(); // works fine without a heartbeat\r\n\r\n        return 'ok';\r\n    }\r\n```\r\nThat works fine and I see a pretty `ActivityTaskCancelRequested` in the activity history. Somehow from the docs I tunneled on\r\n> Cancellation is only delivered to Activities that record heartbeats\r\n\r\nand thought it's not really an option with async completion. Am I misunderstanding something fundamental with cancellations and can you confirm async coroutines should be blocking workflow returns?","createdAt":"2022-02-14T14:35:00Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-php/issues/140#issuecomment-1039158261","viewerDidAuthor":false},{"id":"IC_kwDOEY5HBM4-WYAm","author":{"login":"wolfy-j"},"authorAssociation":"COLLABORATOR","body":"I think we just have to update our docs in this particular use case, we are currently working on new tutorials. Cancellation can and ideally should be triggered from inside the workflow. Every scheduled activity will be cancelled at the moment of the command. However, if activity alteredy started it is only possible to cancel it via the response returned by the activity heartbeat (communication channel between activity and temporal). ","createdAt":"2022-02-19T16:17:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-php/issues/140#issuecomment-1046052902","viewerDidAuthor":false},{"id":"IC_kwDOEY5HBM4-WYG6","author":{"login":"wolfy-j"},"authorAssociation":"COLLABORATOR","body":"Async coroutines will block the return from the workflow until they are complete or canceled. It's intended behavior.","createdAt":"2022-02-19T16:19:46Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-php/issues/140#issuecomment-1046053306","viewerDidAuthor":false}],"createdAt":"2022-02-01T17:31:57Z","labels":[{"id":"MDU6TGFiZWwyMzM5NDMzMTc0","name":"Bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":140,"reactionGroups":[],"state":"CLOSED","title":"[Bug?] Workflow not completing unless all async coroutines finish or are cancelled manually","updatedAt":"2022-02-19T16:19:46Z","url":"https://github.com/temporalio/sdk-php/issues/140"}
