{"assignees":[],"author":{"id":"MDQ6VXNlcjU3MDc1NQ==","is_bot":false,"login":"NielsKSchjoedt","name":"Niels Kristian SchjÃ¸dt"},"body":"## Bug Report: Fiber state corruption after `Workflow.timeout` expires on x86_64\n\n### What are you really trying to do?\n\nWe're building a long-running opportunity nurturing workflow that waits for customer replies. The workflow uses `Workflow.timeout` to wait up to 48 hours for a signal (customer reply), then calls an activity to update database state when the timeout expires.\n\n```ruby\n# Simplified workflow pattern\nloop do\n  received = false\n  Temporalio::Workflow.timeout(48.hours) do\n    Temporalio::Workflow.wait_condition { @customer_replied }\n    received = true\n  end\n  \n  unless received\n    # Timeout expired - transition to paused state\n    Temporalio::Workflow.execute_activity(\n      UpdateStateActivity,\n      { \"state\" => \"paused\" },\n      start_to_close_timeout: 30\n    )\n    break\n  end\nend\n```\n\n### Describe the bug\n\nWhen `Workflow.timeout` expires (not cancelled by condition becoming true), calling `Workflow.execute_activity` immediately afterward crashes with:\n\n```\nNoMethodError: undefined method 'status' for true\n```\n\nThe crash occurs inside the SDK at `outbound_implementation.rb:177`:\n\n```ruby\n# temporalio-1.1.0/lib/temporalio/internal/worker/workflow_instance/outbound_implementation.rb:177\ncase resolution.status  # <-- resolution is `true` instead of a Resolution object\n```\n\nThis suggests `Fiber.yield` is returning `true` instead of the expected `Resolution` object after the timeout path executes.\n\n**Key observations:**\n- Only happens on **x86_64-linux** architecture\n- Does **NOT** happen on **aarch64** (M1/M2 Mac)\n- Only occurs when timeout **expires** (not when cancelled by condition becoming true)\n- Activity code never executes - crash is before activity dispatch\n- Workflow replays and retries continuously fail with same error\n\n**Workaround:** Adding `Workflow.sleep(0)` before `execute_activity` forces a clean fiber yield/resume cycle and fixes the issue:\n\n```ruby\nunless received\n  Temporalio::Workflow.sleep(0)  # <-- Workaround\n  Temporalio::Workflow.execute_activity(...)\nend\n```\n\n### Minimal Reproduction\n\nUnfortunately we don't have a minimal reproduction yet, but here's the pattern that triggers it:\n\n```ruby\nrequire 'temporalio'\n\nclass UpdateStateActivity < Temporalio::Activity::Definition\n  def execute(params)\n    puts \"Activity executed with: #{params.inspect}\"\n    { \"success\" => true }\n  end\nend\n\nclass TimeoutBugWorkflow < Temporalio::Workflow::Definition\n  def execute\n    @signal_received = false\n    \n    received = false\n    Temporalio::Workflow.timeout(5.seconds) do\n      Temporalio::Workflow.wait_condition { @signal_received }\n      received = true\n    end\n    \n    unless received\n      # This crashes on x86_64 when timeout expires\n      Temporalio::Workflow.execute_activity(\n        UpdateStateActivity,\n        { \"state\" => \"paused\" },\n        start_to_close_timeout: 30\n      )\n    end\n    \n    { \"completed\" => true }\n  end\n  \n  workflow_signal\n  def signal_received\n    @signal_received = true\n  end\nend\n```\n\n**To reproduce:**\n1. Start workflow on x86_64 Linux\n2. Do NOT send the signal (let timeout expire)\n3. After 5 seconds, workflow crashes with `undefined method 'status' for true`\n\n### Environment/Versions\n\n- **OS and processor:** x86_64 Linux (Hetzner cloud server, Debian-based Docker container)\n- **Ruby version:** 3.4.0\n- **Temporal SDK version:** `temporalio` gem 1.1.0 (x86_64-linux platform)\n- **Temporal Server:** Self-hosted via Docker Compose (version from temporalio/server image)\n- **Works on:** aarch64 (Apple M1/M2 Mac) with same Ruby and gem versions\n- **Fails on:** x86_64-linux only\n\n### Additional context\n\n**Full stack trace:**\n```\n/usr/local/bundle/ruby/3.4.0/gems/temporalio-1.1.0-x86_64-linux/lib/temporalio/internal/worker/workflow_instance/outbound_implementation.rb:177:in 'execute_activity_once'\n/usr/local/bundle/ruby/3.4.0/gems/temporalio-1.1.0-x86_64-linux/lib/temporalio/internal/worker/workflow_instance/outbound_implementation.rb:134:in 'block in execute_activity_with_local_backoffs'\n<internal:kernel>:168:in 'Kernel#loop'\n/usr/local/bundle/ruby/3.4.0/gems/temporalio-1.1.0-x86_64-linux/lib/temporalio/internal/worker/workflow_instance/outbound_implementation.rb:133:in 'execute_activity_with_local_backoffs'\n/usr/local/bundle/ruby/3.4.0/gems/temporalio-1.1.0-x86_64-linux/lib/temporalio/internal/worker/workflow_instance/outbound_implementation.rb:59:in 'execute_activity'\n/usr/local/bundle/ruby/3.4.0/gems/temporalio-1.1.0-x86_64-linux/lib/temporalio/internal/worker/workflow_instance/context.rb:107:in 'execute_activity'\n/usr/local/bundle/ruby/3.4.0/gems/temporalio-1.1.0-x86_64-linux/lib/temporalio/workflow.rb:163:in 'execute_activity'\n```\n\n**Hypothesis:** The fiber scheduler's handling of timeout expiration leaves some internal state in an inconsistent state on x86_64, causing the next `Fiber.yield` to return a boolean instead of the expected `Resolution` object. The `sleep(0)` workaround likely resets this state by forcing a clean yield/resume cycle.\n\n**We're happy to provide more debugging information or test patches if helpful!**","closedAt":"2026-01-07T17:23:21Z","comments":[{"id":"IC_kwDOHI0NyM7dbIom","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Thanks! Interesting, I think what may be happening is that we are recording the \"current fiber\" for both the wait condition and the execute activity, and then yielding in both spots for that to be resumed with a value. But when the wait timeout occurs, that wait condition is left around. So at some point, we resolve that fiber with the result of the wait condition but it's the execute activity that is currently yielded. My guess is we are not properly removing the wait condition when an exception is raised from yield (which is what timeout does).\n\n> Unfortunately we don't have a minimal reproduction yet\n\nI suspect it's because you need to send the signal after the timeout but while the activity is executing (e.g. could have the activity send the signal back to the workflow).\n\nThis definitely appears to be a bug and we are looking into it now.","createdAt":"2026-01-06T14:19:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-ruby/issues/373#issuecomment-3714877990","viewerDidAuthor":false}],"createdAt":"2026-01-05T23:10:37Z","labels":[{"id":"LA_kwDOHI0NyM7vFHIE","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":373,"reactionGroups":[],"state":"CLOSED","title":"## Bug Report: Fiber state corruption after `Workflow.timeout` expires on x86_64","updatedAt":"2026-01-07T17:23:21Z","url":"https://github.com/temporalio/sdk-ruby/issues/373"}
