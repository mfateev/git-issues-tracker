{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"### Describe the bug\n\nMany common uses of ActiveModel use `ConcurrentMap` under the hood which uses `Thread::Mutex` which is forbidden in workflows. \n\nWe believe this can be replicated simply by accessing an attribute that doesn't exist. We also believe this can be replicated using a model set like:\n\n```ruby\nmodule MyCompany\n  module Messages\n    class Foo\n      include Message\n\n      attribute :some_field_1, :string\n      attribute :some_field_2, :string\n      attribute :some_field_3, ObjectType.for(Array), :default => []\n      attribute :some_field_4, :boolean, :default => false\n      attribute :some_field_5, :boolean, :default => false\n    end\n  end\n\n  module Message\n    extend ActiveSupport::Concern\n    include ActiveModel::Model\n    include ActiveModel::Attributes\n    include ActiveModel::Serializers::JSON\n\n    included do\n      def as_json(options = {})\n        super(options).merge(::JSON.create_id => self.class.name)\n      end\n    end\n\n    class_methods do\n      def json_create(data)\n        new(**data.except(JSON.create_id))\n      end\n    end\n  end\nend\n```\n\nThis can give stack traces like:\n```\nW, [2025-10-24T12:22:16.291089 #70269]  WARN -- : Cannot access Thread::Mutex synchronize from inside a workflow, reason: disallowed. If this is known to be safe, the code can be run in a Temporalio::Workflow::Unsafe.illegal_call_tracing_disabled block. {:attempt=>1, :namespace=>\"default\", :run_id=>\"019a1773-c113-74ff-924d-7c51d86cd682\", :task_queue=>\"deliverable-orchestration\", :workflow_id=>\"59824eb54dc4fa489c15c372\", :workflow_type=>\"OrchestrationWorkflowV2\"} (Temporalio::Workflow::NondeterminismError)\n/path/to/gems/temporalio-0.6.0-arm64-darwin/lib/temporalio/internal/worker/workflow_instance/illegal_call_tracer.rb:112:in `block in initialize'\n/path/to/gems/concurrent-ruby-1.3.4/lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb:25:in `compute_if_absent'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_methods.rb:400:in `attribute_method_matchers_matching'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_methods.rb:506:in `matched_attribute_method'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_methods.rb:494:in `respond_to?'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_assignment.rb:48:in `_assign_attribute'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_assignment.rb:42:in `block in _assign_attributes'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_assignment.rb:41:in `each'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_assignment.rb:41:in `_assign_attributes'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attribute_assignment.rb:34:in `assign_attributes'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/model.rb:81:in `initialize'\n/path/to/gems/activemodel-6.1.7.10/lib/active_model/attributes.rb:77:in `initialize'\n/path/to/models/my_models.rb:99:in `new'\n```\n\nAnd for cases where it's an invalid attribute access via `method_missing`, it can give traces like:\n\n```\n/path/to/gems/temporalio-1.0.0-arm64-darwin/lib/temporalio/internal/worker/workflow_instance/illegal_call_tracer.rb:112:in `block in initialize'\n/path/to/gems/concurrent-ruby-1.3.4/lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb:25:in `compute_if_absent'\n/path/to/gems/activemodel-6.1.7.3/lib/active_model/attribute_methods.rb:400:in `attribute_method_matchers_matching'\n/path/to/gems/activemodel-6.1.7.3/lib/active_model/attribute_methods.rb:506:in `matched_attribute_method'\n/path/to/gems/activemodel-6.1.7.3/lib/active_model/attribute_methods.rb:468:in `method_missing'\nmy_workflow_class.rb:52:in `block in execute'\nmy_workflow_class.rb:39:in `loop'\n```\n\n`ConcurrentMap` use is so pervasive in ActiveModel, it is unreasonable for us to ask users not to use anything relying on it. Also, it may be unreasonable to just alter our illegal trace detector to check backtrace for the active model because the use of mutexes can cause an issue like we hit with loggers (see https://temporal.io/blog/temporal-ruby-crash-proof-fibers#implicitly-used-sync-constructs).\n\nThe best solution may be a `WorkflowSafeObject` type of mixin that surrounds every call with `Workflow::Unsafe::durable_scheduler_disabled`.","closedAt":null,"comments":[],"createdAt":"2025-10-28T15:32:46Z","labels":[{"id":"LA_kwDOHI0NyM7vFHIE","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":355,"reactionGroups":[],"state":"OPEN","title":"[Bug] Some common uses of ActiveModel fail in workflows due to sync construct use","updatedAt":"2025-10-28T15:32:46Z","url":"https://github.com/temporalio/sdk-ruby/issues/355"}
