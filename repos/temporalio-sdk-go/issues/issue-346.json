{"assignees":[],"author":{"id":"MDQ6VXNlcjM2NTYxMQ==","is_bot":false,"login":"shaunco","name":"Shaun"},"body":"## Expected Behavior\r\n`RequestCancelExternalWorkflow(...).Get(ctx, nil)` should block until the workflow exits, regardless of what workflow returns.\r\n\r\n## Actual Behavior\r\nIf the workflow being canceled returns `nil`, `RequestCancelExternalWorkflow(...).Get(ctx, nil)` properly blocks until the canceled workflow has exited, but if the canceled workflow returns `ErrCanceled` then `Get()` never returns. Weirdly, if the `Get(ctx, nil)` is changed to:\r\n```go\r\nvar wfErr error\r\nRequestCancelExternalWorkflow(...).Get(ctx, &wfErr)\r\n```\r\nthen `Get()` properly returns once the canceled workflow exits, but `wfErr` is always nil.\r\n\r\nSample:\r\n```go\r\nconst TestWorkflowId = \"MyTestWorkflow\"\r\n\r\nfunc StartTestWorkflow(ctx workflow.Context) error {\r\n\tcwo := workflow.ChildWorkflowOptions{\r\n\t\tWorkflowIDReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE,\r\n\t\tParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\r\n\t\tWorkflowID: TestWorkflowId,\r\n\t\tTaskQueue: \"MY_TASK_QUEUE\",\r\n\t}\r\n\r\n\tctx = workflow.WithChildOptions(ctx, cwo)\r\n\r\n\t// Start this receiver's workflow\r\n\tfuture := workflow.ExecuteChildWorkflow(ctx, TestWorkflow)\r\n\r\n\tvar childWE tworkflow.Execution\r\n\terr := future.GetChildWorkflowExecution().Get(ctx, &childWE)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\nfunc CancelTestWorkflow(ctx workflow.Context) error {\r\n\t// This will block forever, unless TestWorkflow returns nil\r\n\terr := workflow.RequestCancelExternalWorkflow(ctx, TestWorkflowId, \"\").Get(ctx, nil)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\nfunc TestWorkflow(ctx workflow.Context) error {\r\n\t// Wait until canceled\r\n\tcanceled := false\r\n\ts := workflow.NewSelector(ctx)\r\n\ts.AddReceive(ctx.Done(), func(c workflow.ReceiveChannel, more bool) {\r\n\t\tc.Receive(ctx, nil)\r\n\t\tcanceled = true\r\n\t})\r\n\r\n\t// Block until an event signal is received\r\n\ts.Select(ctx)\r\n\r\n\t// If we were canceled, immediately exit\r\n\tif canceled {\r\n\t\t// Switch to return nil\r\n\t\treturn workflow.ErrCanceled\r\n\t}\r\n\r\n\t// Loop foever\r\n\treturn workflow.NewContinueAsNewError(ctx, TestWorkflow, nil)\r\n}\r\n```\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n  1. Use the above code by executing the `StartTestWorkflow` and `CancelTestWorkflow` workflows\r\n\r\n## Specifications\r\n\r\n  - Version: sdk-gov1.3.0, server v1.5.1\r\n  - Platform: Ubuntu\r\n","closedAt":null,"comments":[],"createdAt":"2021-01-21T11:25:25Z","labels":[{"id":"MDU6TGFiZWwyMDUzODEzNTY0","name":"potential-bug","description":"","color":"90c109"}],"milestone":null,"number":346,"reactionGroups":[],"state":"OPEN","title":"RequestCancelExternalWorkflow(...).Get(ctx, nil) blocks forever with workflow exits with ErrCanceled","updatedAt":"2021-01-21T11:25:25Z","url":"https://github.com/temporalio/sdk-go/issues/346"}
