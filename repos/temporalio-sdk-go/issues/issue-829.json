{"assignees":[],"author":{"id":"MDQ6VXNlcjY3NTIzODI=","is_bot":false,"login":"jlegrone","name":"Jacob LeGrone"},"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nInterceptors are already able to modify log fields emitted by workflow and activity code. But any lower-level logs emitted by the Go SDK don't respect the logger returned by the interceptor chain. These include debug level logs like \"ExecuteActivity\" as well as warning or error level logs like \"Task processing failed with error\".\r\n\r\nUsing the logger returned by the interceptor chain would allow users to filter _all_ logs related to their workflow executions by domain-specific fields, create more sophisticated monitors or metric generation pipelines, and correlate logs to traces on observability platforms where that is supported.\r\n\r\n**Describe the solution you'd like**\r\n\r\nEvaluate the worker's interceptor chain to get a workflow or activity logger whenever a low-level log needs to be emitted by the Go SDK.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nIt might be possible to at least handle all debug level logs like \"ExecuteActivity\" via a regular interceptor that is registered by default.\r\n\r\nIt would be interesting to look into implementing low level logs like \"Task processing failed with error\" via an interceptor as well, perhaps by extending the workflow/activity interceptor interfaces to include a method for recording SDK errors. This would bring some additional benefits since interceptors would not only be able to log those errors, but emit custom metrics or error trace spans as well.\r\n\r\n**Additional context**\r\n\r\nI wrote an e2e test to demonstrate. After running the test, observe that the `trace_id` log field is not included in the \"ExecuteActivity\" log line.\r\n\r\n```go\r\npackage sdklogtest\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"testing\"\r\n\t\"time\"\r\n\r\n\t\"github.com/DataDog/temporalite/temporaltest\"\r\n\t\"go.temporal.io/sdk/activity\"\r\n\t\"go.temporal.io/sdk/client\"\r\n\t\"go.temporal.io/sdk/contrib/opentracing\"\r\n\t\"go.temporal.io/sdk/interceptor\"\r\n\t\"go.temporal.io/sdk/log\"\r\n\t\"go.temporal.io/sdk/worker\"\r\n\t\"go.temporal.io/sdk/workflow\"\r\n)\r\n\r\nfunc LogWorkflow(ctx workflow.Context) error {\r\n\tworkflow.GetLogger(ctx).Info(\"hello workflow\")\r\n\treturn workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, workflow.ActivityOptions{\r\n\t\tScheduleToCloseTimeout: time.Minute,\r\n\t}), LogActivity).Get(ctx, nil)\r\n}\r\n\r\nfunc LogActivity(ctx context.Context) error {\r\n\tactivity.GetLogger(ctx).Info(\"hello activity\")\r\n\treturn nil\r\n}\r\n\r\ntype loggingTracer struct {\r\n\tinterceptor.Tracer\r\n}\r\n\r\nfunc (loggingTracer) GetLogger(logger log.Logger, ref interceptor.TracerSpanRef) log.Logger {\r\n\treturn log.With(logger, \"trace_id\", \"0112358\")\r\n}\r\n\r\nfunc TestLogOutput(t *testing.T) {\r\n\t// Which tracer we use here isn't important to the test; pulling in the opentracing\r\n\t// implementation just meant I didn't have to mock a full interceptor.\r\n\topenTracer, err := opentracing.NewTracer(opentracing.TracerOptions{})\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\t// Create test Temporal server and client\r\n\tts := temporaltest.NewServer(temporaltest.WithT(t))\r\n\tc := ts.NewClientWithOptions(client.Options{\r\n\t\tInterceptors: []interceptor.ClientInterceptor{\r\n\t\t\tinterceptor.NewTracingInterceptor(loggingTracer{openTracer}),\r\n\t\t},\r\n\t})\r\n\r\n\t// Register a new worker\r\n\tw := worker.New(c, \"test\", worker.Options{})\r\n\tdefer w.Stop()\r\n\tw.RegisterWorkflow(LogWorkflow)\r\n\tw.RegisterActivity(LogActivity)\r\n\tif err := w.Start(); err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\t// Start a workflow that emits some logs\r\n\twfr, err := c.ExecuteWorkflow(context.Background(), client.StartWorkflowOptions{\r\n\t\tTaskQueue:                \"test\",\r\n\t\tWorkflowExecutionTimeout: time.Second * 10,\r\n\t}, LogWorkflow)\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\t// Wait for workflow to complete and fail test if workflow errors.\r\n\tif err := wfr.Get(context.Background(), nil); err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\t// There's not a way to write a test against worker log output at the moment,\r\n\t// so just fail the test so logs can be inspected by a human.\r\n\tt.Errorf(\"Please inspect test log output for tag `trace_id:0112358` in workflow execution logs\")\r\n}\r\n```","closedAt":null,"comments":[{"id":"IC_kwDODN1w685Er9_H","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"The problem here is that the interceptor is for intercepting literal calls to `activity.GetLogger` and `workflow.GetLogger`, not just all loggers. You can provide your own logger at the client level to intercept logs originating _outside_ those explicit user calls.\r\n\r\nBut you may need the context. We can do what we did with data converters. Any data converter that implements the following interface:\r\n\r\n```go\r\ntype ContextAware interface {\r\n\tWithWorkflowContext(ctx Context) converter.DataConverter\r\n\tWithContext(ctx context.Context) converter.DataConverter\r\n}\r\n```\r\n\r\nWill have those functions called before the converter is used. So maybe we can make a:\r\n\r\n```go\r\ntype ContextAwareLogger interface {\r\n\tWithWorkflowContext(ctx Context) log.Logger\r\n\tWithContext(ctx context.Context) log.Logger\r\n}\r\n```\r\n\r\nAnd invoke those when impl'd by the logger everywhere we have a context. The overhead should be negligible. Thoughts?","createdAt":"2022-06-10T13:42:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/829#issuecomment-1152376775","viewerDidAuthor":false},{"id":"IC_kwDODN1w685FRf6g","author":{"login":"jlegrone"},"authorAssociation":"CONTRIBUTOR","body":"A `ContextAwareLogger` interface sounds like it could be useful... but when the SDK already has a workflow or activity context available to pass into the client's default logger, why not call `workflow.GetLogger` or `activity.GetLogger` instead so that the interceptor chain is invoked as well?","createdAt":"2022-06-21T19:12:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/829#issuecomment-1162215072","viewerDidAuthor":false},{"id":"IC_kwDODN1w685FSAk1","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"My assumption was that `GetLogger` was as a result of a literal `GetLogger` call, and not just before every logger use to make sure it has the latest context info. However, it might make sense to just do this and we need to just be clear that unlike other outbound interceptors, this is not 1:1 with user calls, it is more frequent and therefore needs to be careful to remain performant.","createdAt":"2022-06-21T20:56:02Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/829#issuecomment-1162348853","viewerDidAuthor":false},{"id":"IC_kwDODN1w685FabrW","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"After some thought, I am afraid of repeatedly calling `GetLogger` internally instead of its original purpose of only being invoked when the user invokes it. I am worried about going from people understanding that it's only called per user call, to now dozens of internal calls since the context can change many times throughout the life of a workflow/activity and one may want such context updates before each log statement.\r\n\r\nI am back to considering the `ContextAwareLogger` approach.","createdAt":"2022-06-23T15:28:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/829#issuecomment-1164557014","viewerDidAuthor":false},{"id":"IC_kwDODN1w685UTn6k","author":{"login":"jlegrone"},"authorAssociation":"CONTRIBUTOR","body":"I'd love to revisit this issue. We're looking for ways to assess the scope of impact for incidents caused by workflow code panics and other non-versioned/deterministic changes.\r\n\r\nA common failure mode we've observed is that a small number of top level requests will generate a large number of Go SDK generated error logs across a broad set of child workflows. We're looking for a way to quickly identify how many root/top level parent workflows are impacted by aggregating across this set of logs, but are limited by the fact that we have no way of injecting custom request-scoped attributes in Go SDK logs.\r\n\r\nFor example, aggregating workflow error logs by [dd.trace_id](https://github.com/temporalio/sdk-go/blob/a9a4baa54c97bcb2ea229f99e673156b31452fad/contrib/datadog/tracing/interceptor.go#L180-L187) would allow us to identify how many top requests are impacted and help operators make more informed decisions about whether these top level workflows should be terminated vs. rolling out a new worker version.","createdAt":"2023-02-02T21:58:33Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/829#issuecomment-1414430372","viewerDidAuthor":false}],"createdAt":"2022-06-10T12:59:45Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":829,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":6}}],"state":"OPEN","title":"Use interceptor logger for all logs related to a workflow or activity execution","updatedAt":"2023-02-02T21:59:51Z","url":"https://github.com/temporalio/sdk-go/issues/829"}
