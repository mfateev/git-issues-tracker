{"assignees":[],"author":{"id":"MDQ6VXNlcjMyNzI1NjM=","is_bot":false,"login":"giuliohome","name":"Giulio"},"body":"The Python SDK for Temporal allows running activities in separate processes via ProcessPoolExecutor. \r\n\r\n**This architecture ensures that each activity runs in isolation, including environment variables.**\r\n\r\n[Here is the reference sample](https://github.com/temporalio/samples-python/blob/main/hello/hello_activity_multiprocess.py#L48C1-L67C7).\r\n\r\n\r\n```py\r\n    # Run a worker for the workflow\r\n    async with Worker(\r\n        client,\r\n        task_queue=\"hello-activity-multiprocess-task-queue\",\r\n        workflows=[GreetingWorkflow],\r\n        activities=[compose_greeting],\r\n        # Synchronous activities are not allowed unless we provide some kind of\r\n        # executor. Here we are giving a process pool executor which means the\r\n        # activity will actually run in a separate process. This same executor\r\n        # could be passed to multiple workers if desired.\r\n        activity_executor=ProcessPoolExecutor(5),\r\n        # Since we are using an executor that is not a thread pool executor,\r\n        # Temporal needs some kind of manager to share state such as\r\n        # cancellation info and heartbeat info between the host and the\r\n        # activity. Therefore, we must provide a shared_state_manager here. A\r\n        # helper is provided to create it from a multiprocessing manager.\r\n        shared_state_manager=SharedStateManager.create_from_multiprocessing(\r\n            multiprocessing.Manager()\r\n        ),\r\n    ):\r\n```\r\n\r\n\r\nWhich is the equivalent way to do this in Go SDK?\r\n\r\n","closedAt":"2024-09-26T17:37:48Z","comments":[{"id":"IC_kwDODN1w686NsYMa","author":{"login":"giuliohome"},"authorAssociation":"NONE","body":"Or maybe - as a **practical workaround** - could we leverage Cross-Language Execution for this as well?\r\n\r\nTemporal supports running activities in a different language from the worker, so could we write the activity in Go while keeping the worker in Python, using the Python worker’s `ProcessPoolExecutor` to guarantee process-level isolation for each activity?\r\n\r\nWill the Python worker’s architecture ensure process isolation, even for activities written in a different language like Go?\r\n\r\nWill each Go activity execution have its own environment, **ensuring the isolation we’re seeking for environment variables**, or what am I missing?\r\n","createdAt":"2024-09-26T14:58:46Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1651#issuecomment-2377220890","viewerDidAuthor":false},{"id":"IC_kwDODN1w686NskBQ","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Activities are any code you want, so you can use `exec.Command` in your Go activity. It is not comparable to Python which has a built-in concept of remote function invocation and serialization (pickling). There is no concept of multiprocess functions/code in Go, so it is up to the user to implement multiprocessing as they see fit.\r\n\r\nSetup your Go activities to be multiprocess (or even multisystem with RPC or whatever), and make sure you heartbeat while waiting for their results and can provide cancellation to them.\r\n\r\nFeel free to join us on the community Slack or forums for general questions about Go activities.","createdAt":"2024-09-26T15:18:22Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1651#issuecomment-2377269328","viewerDidAuthor":false},{"id":"IC_kwDODN1w686Nsqbe","author":{"login":"giuliohome"},"authorAssociation":"NONE","body":"\r\nIsn't the Golang activity already running in a separate process when the worker is written in Python?\r\n\r\nThank you.","createdAt":"2024-09-26T15:29:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1651#issuecomment-2377295582","viewerDidAuthor":false},{"id":"IC_kwDODN1w686NtWFR","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Yes, but not one process per activity like Python multiprocessing","createdAt":"2024-09-26T16:54:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1651#issuecomment-2377474385","viewerDidAuthor":false},{"id":"IC_kwDODN1w686Ntaau","author":{"login":"giuliohome"},"authorAssociation":"NONE","body":"Understood. If there is no possibility for an enhancement, we can proceed to close this issue.\r\n\r\nPlease consider also that, while each language has its own strengths, consistency in SDK behavior should be a goal for better usability across different languages.","createdAt":"2024-09-26T17:04:50Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1651#issuecomment-2377492142","viewerDidAuthor":false},{"id":"IC_kwDODN1w686NtryN","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":":+1: There is no native Go multiprocessing for functions and we do try to be native to the language without adding dependencies. But this is why we give the freedom to users in activities. So they can choose to do which approach they prefer in situations where there is no standard.","createdAt":"2024-09-26T17:37:48Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-go/issues/1651#issuecomment-2377563277","viewerDidAuthor":false},{"id":"IC_kwDODN1w686NzJ7m","author":{"login":"giuliohome"},"authorAssociation":"NONE","body":"For my reference, I see that in [Python SDK](https://github.com/temporalio/sdk-python/blob/main/temporalio/worker/_activity.py#L705) you use `loop.run_in_executor`. I have translated this concept from Python to Go based on the [example in the asyncio event loop library](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor). This includes handling environment variables and nested JSON data, which are the basic elements we actually need.\r\n\r\nAs far as I can see, I can use Go's standard `Marshal`/`Unmarshal` from `encoding/json`.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"crypto/rand\"\r\n\t\"os\"\r\n\t\"os/exec\"\r\n\t\"sync\"\r\n\t\"encoding/json\"\r\n)\r\n\r\nfunc blockingIO() ([]byte, error) {\r\n\tdata := make([]byte, 100)\r\n\t_, err := rand.Read(data)  // This fills the data with random bytes\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn data, nil\r\n}\r\n\r\n// cpuBound performs a CPU-intensive task\r\nfunc cpuBound() int {\r\n\tsum := 0\r\n\tfor i := 0; i < int(math.Pow(10, 7)); i++ {\r\n\t\tsum += i * i\r\n\t}\r\n\treturn sum\r\n}\r\n\r\n// runCpuBoundInSubprocess runs the cpuBound function in a separate subprocess with isolated environment variables\r\nfunc runCpuBoundInSubprocess() error {\r\n\t// Create a nested map (equivalent to a complex JSON structure)\r\n\tdata := map[string]interface{}{\r\n\t\t\"task\": \"example\",\r\n\t\t\"details\": map[string]interface{}{\r\n\t\t\t\"user\":  \"Giulio\",\r\n\t\t\t\"items\": []string{\"item1\", \"item2\", \"item3\"},\r\n\t\t},\r\n\t}\r\n\r\n\t// Serialize the data to JSON\r\n\tjsonData, err := json.Marshal(data)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"Serialization error: %v\", err)\r\n\t}\r\n\r\n\tcmd := exec.Command(os.Args[0], string(jsonData)) // Run the same program and pass the JSON data as an argument\r\n\tcmd.Env = append(os.Environ(), \"CUSTOM_ENV_VAR=custom_value\") // Set custom environment variables\r\n\r\n\toutput, err := cmd.CombinedOutput() // Capture output from the subprocess\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"subprocess error: %v, output: %s\", err, string(output))\r\n\t}\r\n\tfmt.Println(\"Subprocess output:\", string(output))\r\n\treturn nil\r\n}\r\n\r\nfunc main() {\r\n\tvar wg sync.WaitGroup\r\n\r\n\t// 1. Run blockingIO in a goroutine (default thread pool equivalent)\r\n\twg.Add(1)\r\n\tgo func() {\r\n\t\tdefer wg.Done()\r\n\t\tresult, err := blockingIO()\r\n\t\tif err != nil {\r\n\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfmt.Println(\"Default thread pool:\", result)\r\n\t}()\r\n\r\n\t// 2. Run blockingIO in a custom thread pool (simulated using goroutines and sync.WaitGroup)\r\n\twg.Add(1)\r\n\tgo func() {\r\n\t\tdefer wg.Done()\r\n\t\tresult, err := blockingIO()\r\n\t\tif err != nil {\r\n\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfmt.Println(\"Custom thread pool:\", result)\r\n\t}()\r\n\r\n\t// 3. Run cpuBound in a separate subprocess with isolated environment\r\n\twg.Add(1)\r\n\tgo func() {\r\n\t\tdefer wg.Done()\r\n\t\terr := runCpuBoundInSubprocess()\r\n\t\tif err != nil {\r\n\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t}\r\n\t}()\r\n\r\n\t// Wait for all goroutines to finish\r\n\twg.Wait()\r\n\t// Get the value of the environment variable\r\n\tcustomEnvVar := os.Getenv(\"CUSTOM_ENV_VAR\")\r\n\r\n\t// Check if the environment variable is set\r\n\tif customEnvVar == \"\" {\r\n\t\tfmt.Println(\"In Main => CUSTOM_ENV_VAR is not set\")\r\n\t} else {\r\n\t\tfmt.Println(\"In Main => CUSTOM_ENV_VAR:\", customEnvVar)\r\n\t}\r\n}\r\n\r\n// cpu function is executed when the subprocess runs the \"cpu\" argument\r\nfunc cpu() {\r\n\tresult := cpuBound()\r\n\tfmt.Printf(\"CPU-bound result: %d\\n\", result)\r\n\r\n\t// Get the value of the environment variable\r\n\tcustomEnvVar := os.Getenv(\"CUSTOM_ENV_VAR\")\r\n\r\n\t// Check if the environment variable is set\r\n\tif customEnvVar == \"\" {\r\n\t\tfmt.Println(\"In Subprocess => CUSTOM_ENV_VAR is not set\")\r\n\t} else {\r\n\t\tfmt.Println(\"In Subprocess => CUSTOM_ENV_VAR:\", customEnvVar)\r\n\t}\r\n\r\n\t// Deserialize the JSON passed as an argument\r\n\tvar receivedData map[string]interface{}\r\n\terr := json.Unmarshal([]byte(os.Args[1]), &receivedData)\r\n\tif err != nil {\r\n\t\tfmt.Println(\"Error parsing JSON:\", err)\r\n\t\treturn\r\n\t}\r\n\r\n\t// Process the data\r\n\tfmt.Println(\"Received data in child process:\", receivedData)\r\n\r\n\tfmt.Println(\"User: \", receivedData[\"details\"].(map[string]interface{})[\"user\"].(string))\r\n\r\n\t// Perform some operation and print a result\r\n\tfmt.Println(\"Processing complete\")\r\n\r\n}\r\n\r\n// Entry point - checks if we are in subprocess mode\r\nfunc init() {\r\n\tif len(os.Args) > 1  { //&& os.Args[1] == \"cpu\" {\r\n\t\tcpu() // Execute CPU-bound task in subprocess\r\n\t\tos.Exit(0) // Ensure the subprocess exits after completing its work\r\n\t}\r\n}\r\n\r\n```\r\n","createdAt":"2024-09-27T10:50:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1651#issuecomment-2378997478","viewerDidAuthor":false}],"createdAt":"2024-09-26T14:09:51Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1651,"reactionGroups":[],"state":"CLOSED","title":"Running activities in separate processes ","updatedAt":"2024-09-27T10:50:30Z","url":"https://github.com/temporalio/sdk-go/issues/1651"}
