{"assignees":[],"author":{"id":"MDQ6VXNlcjE3NjY1MTU=","is_bot":false,"login":"samarabbas","name":"Samar Abbas"},"body":"**Is your feature request related to a problem? Please describe.**\r\nIf a developer fails to drain signal channel before calling ContinueAsNew then it might result in\r\nloosing important signals without processing them.\r\n\r\n**Describe the solution you'd like**\r\nAdd ability to transfer all unprocessed Signals to new run after ContinueAsNew\r\n","closedAt":null,"comments":[{"id":"IC_kwDODN1w6847lMGf","author":{"login":"mytototo"},"authorAssociation":"NONE","body":"Currently, what is the best approach to _transfer_ signals from a workflow to a continue as new?\r\n\r\nWhat's the best way to deal with:\r\n```go\r\nfor signalChan.ReceiveAsync(&val) {\r\n  // ...\r\n}\r\n```","createdAt":"2021-12-22T14:09:37Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/533#issuecomment-999604639","viewerDidAuthor":false},{"id":"IC_kwDODN1w6847vIfu","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"There is no transferring of signals today. You have to wait until all signals are drained. So that loop will exit when `signalChan` is drained and you can return continue-as-new after that.","createdAt":"2021-12-28T17:33:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/533#issuecomment-1002211310","viewerDidAuthor":false},{"id":"IC_kwDODN1w6847vPlb","author":{"login":"mytototo"},"authorAssociation":"NONE","body":"I understand. As of today, what is the best workaround to achieve something like this? How can we ensure to process all signals in a new workflow so none are lost? In other words, what would be the idiomatic way to transfer signals or execute a new workflow within the loop?","createdAt":"2021-12-28T18:57:49Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/533#issuecomment-1002240347","viewerDidAuthor":false},{"id":"IC_kwDODN1w6847yxMD","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"If you are using a selector for receiving signals, the best way is to continually `selector.Select` until `selector.HasPending()` is false. If you are just operating on that signal directly, you can continually `ReceiveAsync` until its return value is false.","createdAt":"2021-12-30T20:01:32Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/533#issuecomment-1003164419","viewerDidAuthor":false}],"createdAt":"2021-09-14T18:52:03Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":533,"reactionGroups":[],"state":"OPEN","title":"ContinueAsNew which transfers all unprocessed signals to new run","updatedAt":"2021-12-30T20:01:32Z","url":"https://github.com/temporalio/sdk-go/issues/533"}
