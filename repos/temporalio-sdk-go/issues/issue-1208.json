{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNTA0MDQ5","is_bot":false,"login":"Quinn-With-Two-Ns","name":"Quinn Klassen"},"body":"## Expected Behavior\nChild context cancellation propagates in a deterministic order \n\n## Actual Behavior\nChild context cancellation does not propagates in a deterministic order.\n\nWhen a parent context cancels its' children it loops [through a map](https://github.com/temporalio/sdk-go/blob/b9e5e241869fdb39b03ef8b6ef043ce75c78344e/internal/context.go#L338). Map order in Go is not deterministic so the order child contexts are canceled is not deterministic.\n\n## Steps to Reproduce the Problem\n```\nfunc TestContextCancellationOrderDeterminism(t *testing.T) {\n\t/*\n\t\tPreviously, child-contexts were stored in a map, preventing deterministic order when propagating cancellation.\n\t\tThe order of branches being selected in this test was random, both for the first event and in following ones.\n\n\t\tIn principle this should be fine, but it's possible for the effects of cancellation to trigger a selector's\n\t\tfuture-done callback, which currently records the *real-time*-first event as the branch to unblock, rather than\n\t\tdoing something more safe by design (e.g. choosing based on state when the selector's goroutine is unblocked).\n\n\t\tUnfortunately, we cannot change the selector's behavior without introducing non-backwards-compatible changes to\n\t\tcurrently-working workflows.\n\n\t\tSo the workaround for now is to maintain child-context order, so they are canceled in a consistent order.\n\t\tAs this order was not controlled before, and Go does a pretty good job at randomizing map iteration order,\n\t\tconverting non-determinism to determinism should be strictly no worse for backwards compatibility, and it\n\t\tfixes the issue for future executions.\n\t*/\n\tcheck := func(t *testing.T, separateStart, separateSelect bool) {\n\t\tenv := newTestWorkflowEnv(t)\n\t\tact := func(ctx context.Context) error {\n\t\t\treturn nil // will be mocked\n\t\t}\n\t\twf := func(ctx Context) ([]int, error) {\n\t\t\tctx, cancel := WithCancel(ctx)\n\t\t\tGo(ctx, func(ctx Context) {\n\t\t\t\t_ = Sleep(ctx, time.Minute)\n\t\t\t\tcancel()\n\t\t\t})\n\n\t\t\t// start some activities, which will not complete before the timeout cancels them\n\t\t\tctx = WithActivityOptions(ctx, ActivityOptions{\n\t\t\t\tTaskQueue:              \"\",\n\t\t\t\tScheduleToCloseTimeout: time.Hour,\n\t\t\t\tScheduleToStartTimeout: time.Hour,\n\t\t\t\tStartToCloseTimeout:    time.Hour,\n\t\t\t})\n\t\t\ts := NewSelector(ctx)\n\t\t\tvar result []int\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\ti := i\n\t\t\t\t// need a child context, a future alone is not enough as it does not become a child\n\t\t\t\tcctx, ccancel := WithCancel(ctx)\n\n\t\t\t\ts.AddFuture(ExecuteActivity(cctx, act), func(f Future) {\n\t\t\t\t\tccancel() // TODO: is this necessary to prevent leaks?  if it is, how can we make it not?\n\t\t\t\t\terr := f.Get(ctx, nil)\n\t\t\t\t\tif err == nil || !IsCanceledError(err) {\n\t\t\t\t\t\t// fail the test, this should not happen - activities must be canceled or it's not valid.\n\t\t\t\t\t\tt.Errorf(\"activity completion or failure for some reason other than cancel: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tresult = append(result, i)\n\t\t\t\t})\n\n\t\t\t\tif separateStart {\n\t\t\t\t\t// yield so they are submitted one at a time, in case that matters\n\t\t\t\t\t_ = Sleep(ctx, time.Second)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tif separateSelect {\n\t\t\t\t\t// yield so they are selected one at a time, in case that matters\n\t\t\t\t\t_ = Sleep(ctx, time.Second)\n\t\t\t\t}\n\t\t\t\ts.Select(ctx)\n\t\t\t}\n\n\t\t\treturn result, nil\n\t\t}\n\t\tenv.RegisterWorkflow(wf)\n\t\tenv.RegisterActivity(act)\n\n\t\t// activities must not complete in time\n\t\tenv.OnActivity(act, mock.Anything).After(5 * time.Minute).Return(nil)\n\n\t\tenv.ExecuteWorkflow(wf)\n\t\trequire.NoError(t, env.GetWorkflowError())\n\t\tvar result []int\n\t\trequire.NoError(t, env.GetWorkflowResult(&result))\n\t\trequire.NotEmpty(t, result)\n\t\tassert.Equal(t, 0, result[0], \"first activity to be created should be the first one canceled\")\n\t\tassert.Equal(t, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}, result[1:], \"other activities should finish in a consistent (but undefined) order\")\n\t}\n\n\ttype variant struct {\n\t\tname           string\n\t\tseparateStart  bool\n\t\tseparateSelect bool\n\t}\n\t// all variants expose this behavior, but being a bit more exhaustive in the face\n\t// of decision-scheduling differences seems good.\n\tfor _, test := range []variant{\n\t\t{\"many in one decision\", false, false},\n\t\t{\"many started at once, selected slowly\", false, true},\n\t\t{\"started slowly, selected quickly\", true, false},\n\t\t{\"started and selected slowly\", true, true},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcheck(t, test.separateStart, test.separateSelect)\n\t\t})\n\t}\n}\n\n```\n\nNote: this test came from [cadence go client ](https://github.com/uber-go/cadence-client) where I noticed they had fixed this bug.\n\n","closedAt":null,"comments":[{"id":"IC_kwDODN1w68511pb8","author":{"login":"throwaway58383958484"},"authorAssociation":"NONE","body":"Could this be fixed now using the new helper? https://github.com/temporalio/sdk-go/pull/1340","createdAt":"2024-03-04T16:33:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1208#issuecomment-1976997628","viewerDidAuthor":false},{"id":"IC_kwDODN1w68512nOl","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"No since the keys of the map cannot be sorted. Likely we would just copy what `Cadence` did to resolve this problem https://github.com/uber-go/cadence-client/commit/dcaec7737070ebe0889f1c9bb57c2552c8bd7d86","createdAt":"2024-03-04T18:55:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1208#issuecomment-1977250725","viewerDidAuthor":false}],"createdAt":"2023-08-24T15:41:36Z","labels":[{"id":"MDU6TGFiZWwyMDUzODEzNTY0","name":"potential-bug","description":"","color":"90c109"}],"milestone":null,"number":1208,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"state":"OPEN","title":"Canceling a context with multiple child contexts can be non deterministic","updatedAt":"2024-03-04T18:55:53Z","url":"https://github.com/temporalio/sdk-go/issues/1208"}
