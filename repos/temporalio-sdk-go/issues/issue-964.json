{"assignees":[],"author":{"id":"MDQ6VXNlcjE3NDYxNzQ1","is_bot":false,"login":"nitesh237","name":"Nitesh Gupta"},"body":"**Is your feature request related to a problem? Please describe.**\r\nWe have a use-case to add some validation on the request and response getting passed in the activity. The validations can be like the response must be a proto message. The response must have a specific header field, etc.\r\n\r\nThe preferred way to solve this is using a future wrapper that has validation added before invoking the original methods. Basically, using the composition as shown below:\r\n\r\n```\r\ntype wfProtoFuture struct {\r\n\tworkflowFuture workflow.Future\r\n}\r\n\r\nvar _ workflow.Future = &wfProtoFuture{}\r\n\r\nfunc WrapProtoFuture(future workflow.Future) workflow.Future {\r\n\treturn &wfProtoFuture{workflowFuture: future}\r\n}\r\n\r\nfunc (p *wfProtoFuture) Get(ctx workflow.Context, valuePtr interface{}) error {\r\n\tif res, ok := valuePtr.(proto.Message); !ok {\r\n\t\treturn fmt.Errorf(\"value ptr passed must be a proto.Message\")\r\n\t} else if !isValidActivityResponse(res) {\r\n\t\treturn fmt.Errorf(\"missing response headers in activity response\")\r\n\t}\r\n\r\n\treturn p.workflowFuture.Get(ctx, valuePtr)\r\n}\r\n\r\nfunc (p *wfProtoFuture) IsReady() bool {\r\n\treturn p.workflowFuture.IsReady()\r\n}\r\n```\r\nThis way we would be able to fail fast in the workflow code itself while blocking the workflow on the future objects. However, the SDK right now doesn't expose `asyncFuture` interface. This restricts wrapper usage. When we pass the wrapped future to a selector we get an error because of this line [here](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow.go#L1192).\r\n\r\n\r\n```\r\nasyncF, ok := future.(asyncFuture)\r\nif !ok {\r\npanic(\"cannot chain Future that wasn't created with workflow.NewFuture\")\r\n}\r\n```\r\n\r\n**Describe the solution you'd like**\r\n* Make `asyncFuture` interface exported.\r\n\r\n**Describe alternatives you've considered**\r\nThe other alternative is to add the validation workflow and activity interceptor. \r\n\r\n","closedAt":"2022-11-29T18:24:09Z","comments":[{"id":"IC_kwDODN1w685PAgLm","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Futures passed back into helpers like selector are meant to be the unwrapped future that was created by Temporal. This is because some internal aspects of the future are relied on. If you must wrap the future, you should unwrap it when calling select instead of trying to reuse the Temporal future interface. Since you're already wrapping, there's no reason to reuse the Temporal interface, use your own type (you can be even stricter on your `Get` type, use generics, etc).\r\n\r\nWhy not have just your `wfProtoFuture` just have the future in it and unwrap at selector time? There's no reason to match the Temporal interface. Can make your own helper, e.g.\r\n\r\n```go\r\nfunc (p *wfProtoFuture) AddToSelector(sel workflow.Selector, fn func(*wfProtoFuture)) workflow.Selector {\r\n  return sel.AddFuture(p.future, func(workflow.Future) { fn(p) })\r\n}\r\n```","createdAt":"2022-11-23T19:01:08Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-go/issues/964#issuecomment-1325531878","viewerDidAuthor":false},{"id":"IC_kwDODN1w685PVxD4","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Closing, but if there is more to add here, feel free to comment.","createdAt":"2022-11-29T18:24:09Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/964#issuecomment-1331106040","viewerDidAuthor":false},{"id":"IC_kwDODN1w685Wf7-e","author":{"login":"nitesh-epifi"},"authorAssociation":"NONE","body":"> Futures passed back into helpers like selector are meant to be the unwrapped future that was created by Temporal. This is because some internal aspects of the future are relied on. If you must wrap the future, you should unwrap it when calling select instead of trying to reuse the Temporal future interface. Since you're already wrapping, there's no reason to reuse the Temporal interface, use your own type (you can be even stricter on your `Get` type, use generics, etc).\r\n> \r\n> Why not have just your `wfProtoFuture` just have the future in it and unwrap at selector time? There's no reason to match the Temporal interface. Can make your own helper, e.g.\r\n> \r\n> ```go\r\n> func (p *wfProtoFuture) AddToSelector(sel workflow.Selector, fn func(*wfProtoFuture)) workflow.Selector {\r\n>   return sel.AddFuture(p.future, func(workflow.Future) { fn(p) })\r\n> }\r\n> ```\r\n\r\n@cretz sorry for the delayed response. Thanks for your suggestion. We went ahead with your suggestion here.","createdAt":"2023-03-02T03:03:43Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/964#issuecomment-1451212702","viewerDidAuthor":false}],"createdAt":"2022-11-23T08:05:52Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":964,"reactionGroups":[],"state":"CLOSED","title":"Export asyncFuture interface ","updatedAt":"2023-03-02T03:03:44Z","url":"https://github.com/temporalio/sdk-go/issues/964"}
