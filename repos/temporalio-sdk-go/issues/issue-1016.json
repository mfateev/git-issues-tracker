{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNTA0MDQ5","is_bot":false,"login":"Quinn-With-Two-Ns","name":"Quinn Klassen"},"body":"**Is your feature request related to a problem? Please describe.**\r\nProvide a mechanism to update workflow code running in a long running loop such that new iterations of the loop will use the new workflow logic, while still being deterministic on replay. A current[ proposed workaround](https://stackoverflow.com/questions/74143884/how-to-use-cadence-temporal-versioning-api-workflow-getversion-in-a-loop) does not work well as it is unintuitive and for long running loops can actually fail as the search attribute appended for each version grows to large.\r\n\r\nTaken from slack: https://temporalio.slack.com/archives/CTRCR8RBP/p1674236715491629\r\n```\r\n// use to upgrade old long running workflows and introduce new code\r\nfunc getGlobalVersionExample(ctx workflow.Context, iteration int) workflow.Version {\r\n\t// if max version then just use g since we are already running latest code\r\n\tinitialVersion := workflow.GetVersion(ctx, \"g\", workflow.DefaultVersion, MaxVersion)\r\n\tif initialVersion == MaxVersion {\r\n\t\treturn initialVersion\r\n\t}\r\n\r\n\t// if workflow version is not max version then we are running old code and we need to version on each iteration\r\n\tv := workflow.GetVersion(ctx, fmt.Sprintf(\"g%d\", iteration), initialVersion, MaxVersion)\r\n\treturn v\r\n}\r\n\r\nfunc LongRunningWorkflow(ctx workflow.Context) {\r\n\titeration := 0\r\n\tfor {\r\n\t\tselector := workflow.NewSelector(ctx)\r\n\t\tsignalName := \"mysignal\"\r\n\t\tsignalChannel := workflow.GetSignalChannel(ctx, signalName)\r\n\t\tselector.AddReceive(signalChannel, func(c workflow.ReceiveChannel, _ bool) {\r\n\t\t\tdispatchCommand(ctx, iteration)\r\n\t\t})\r\n\r\n\t\tselector.Select(ctx)\r\n\r\n\t\titeration++\r\n\t}\r\n}\r\n\r\nfunc dispatchCommand(ctx workflow.Context, iteration int) {\r\n\tif getGlobalVersionExample(ctx, iteration) != workflow.DefaultVersion {\r\n\t\t// do something new\r\n\t}\r\n\t// do something old\r\n}\r\n```\r\n\r\n**Describe the solution you'd like**\r\nProvide a  non memorized version of the `GetVersion` API that can be used in a loop like the typescipt [patched API](https://legacy-documentation-sdks.temporal.io/typescript/patching#typescript-sdk-patching-api)\r\n\r\n**Describe alternatives you've considered**\r\nA clear and concise description of any alternative solutions or features you've considered.\r\n\r\n**Additional context**\r\nAdd any other context or screenshots about the feature request here.\r\n","closedAt":"2025-01-21T18:40:17Z","comments":[{"id":"IC_kwDODN1w686bTHeF","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Marking as a duplicate of https://github.com/temporalio/features/issues/518","createdAt":"2025-01-21T18:39:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1016#issuecomment-2605479813","viewerDidAuthor":false},{"id":"IC_kwDODN1w686cWlBg","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"This is now tracked as temporalio/features#591.","createdAt":"2025-01-29T23:30:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1016#issuecomment-2623164512","viewerDidAuthor":false}],"createdAt":"2023-01-30T04:56:06Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1016,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"CLOSED","title":"Provide a mechanism to version in a long running loop","updatedAt":"2025-01-29T23:30:16Z","url":"https://github.com/temporalio/sdk-go/issues/1016"}
