{"assignees":[],"author":{"id":"MDQ6VXNlcjcyMDg5Nzgz","is_bot":false,"login":"Patrick-McKeever","name":"Patrick McKeever"},"body":"## Expected Behavior\nWhen mocking a parent and child workflow, signal handlers registered with `selector.AddReceive` inside the mocked child workflow should be triggered when the corresponding signal is sent by the parent workflow.\n\n## Actual Behavior\nOnly the first signal is delivered to the child workflow, and subsequent calls to `selector.Select()` simply block without invoking the callback for the sent signal.\n\n\n## Steps to Reproduce the Problem\n\nA minimal example is shown below. (As far as I know, it’s not possible to use env.OnSignalExternalWorkflow here, because “TestWorkflowEnvironment handles sending signals between the workflows that are started from the root workflow. For example, sending signals between parent and child workflows. Or sending signals between 2 child workflows”, [per the docs](https://pkg.go.dev/go.temporal.io/sdk/internal#TestWorkflowEnvironment.OnSignalExternalWorkflow).)\n\n```golang\nfunc TestParentChildSignalExchange(t *testing.T) {\n    var ts testsuite.WorkflowTestSuite\n    env := ts.NewTestWorkflowEnvironment()\n    var childReceivedC bool\n\n    mockChildWorkflow := func(ctx workflow.Context, parentWfId string) error {\n        s := workflow.NewSelector(ctx)\n        s.AddReceive(workflow.GetSignalChannel(ctx, SignalA), func(c workflow.ReceiveChannel, _ bool) {\n            var val string\n            c.Receive(ctx, &val)\n            fmt.Println(\"Child received signal A\")\n            _ = workflow.SignalExternalWorkflow(ctx, parentWfId, \"\", SignalB, \"payload-B\").Get(ctx, nil)\n            fmt.Println(\"Child sent signal B\")\n        })\n\n        s.AddReceive(workflow.GetSignalChannel(ctx, SignalC), func(c workflow.ReceiveChannel, _ bool) {\n            var val string\n            c.Receive(ctx, &val)\n            fmt.Println(\"Child received signal C\")\n            childReceivedC = true\n        })\n\n        // Selects for signal A and signal C\n        s.Select(ctx)\n        s.Select(ctx)\n        return nil\n    }\n    parentWorkflow := func(ctx workflow.Context) error {\n        cwo := workflow.ChildWorkflowOptions{\n            WorkflowID: \"child-workflow-id\",\n        }\n        var childWE workflow.Execution\n        workflowId := workflow.GetInfo(ctx).WorkflowExecution.ID\n        ctx = workflow.WithChildOptions(ctx, cwo)\n        err := workflow.ExecuteChildWorkflow(ctx, \"MockChildWorkflow\", workflowId).GetChildWorkflowExecution().Get(ctx, &childWE)\n        if err != nil {\n            return err\n        }\n\n        workflow.SignalExternalWorkflow(ctx, childWE.ID, childWE.RunID, SignalA, \"payload-A\")\n        fmt.Println(\"Parent sent signal A\")\n        var bVal string\n        s := workflow.NewSelector(ctx)\n        s.AddReceive(workflow.GetSignalChannel(ctx, SignalB), func(c workflow.ReceiveChannel, _ bool) {\n            c.Receive(ctx, &bVal)\n            fmt.Println(\"Parent received signal B\")\n            _ = workflow.SignalExternalWorkflow(ctx, childWE.ID, childWE.RunID, SignalC, \"payload-C\").Get(ctx, nil)\n            fmt.Println(\"Parent sent signal C\")\n        })\n        s.Select(ctx)\n        return nil\n    }\n    env.RegisterWorkflow(parentWorkflow)\n    env.RegisterWorkflowWithOptions(mockChildWorkflow, workflow.RegisterOptions{Name: \"MockChildWorkflow\"})\n\n    env.ExecuteWorkflow(parentWorkflow)\n    require.True(t, env.IsWorkflowCompleted())\n    require.True(t, childReceivedC, \"child workflow should have received signal C\")\n}\n```\n\nThis gives the following output, showing that the child workflow successfully receives the first signal but not the second.\n\n```\n=== RUN   TestParentChildSignalExchange\n2025/08/27 17:34:10 INFO  ExecuteChildWorkflow WorkflowType MockChildWorkflow\nParent sent signal A\nChild received signal A\nChild sent signal B\nParent received signal B\nParent sent signal C\n    /home/patrick/go-scheduler/workflow/temporal_executor_test.go:158:\n                Error Trace:    /home/patrick/go-scheduler/workflow/temporal_executor_test.go:158\n                Error:          Should be true\n                Test:           TestParentChildSignalExchange\n                Messages:       child workflow should have received signal C\n--- FAIL: TestParentChildSignalExchange (0.00s)\nFAIL\n```\n\n## Specifications\n\n  - Version: 1.35.0\n  - Platform: Debian GNU/Linux 11 (bullseye), go 1.24.4","closedAt":"2025-09-02T14:32:25Z","comments":[{"id":"IC_kwDODN1w687BdCGS","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"This is expected behaviour, if you parent workflow finished by default your child workflow is terminated and will no longer receive signals. See `ChildWorkflowOptions.ParentClosePolicy` for more details. If you want your child workflow to live after you parent workflow finishes,  use `PARENT_CLOSE_POLICY_ABANDON`","createdAt":"2025-09-02T14:32:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/2040#issuecomment-3245613458","viewerDidAuthor":false}],"createdAt":"2025-08-28T18:14:17Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDg2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":2040,"reactionGroups":[],"state":"CLOSED","title":"Test environment does not deliver signals to mocked child workflow","updatedAt":"2025-09-02T14:32:25Z","url":"https://github.com/temporalio/sdk-go/issues/2040"}
