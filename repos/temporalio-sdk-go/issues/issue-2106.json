{"assignees":[],"author":{"id":"MDQ6VXNlcjc3MTgwNjc3","is_bot":false,"login":"jjaegerman","name":"Jonathan Jaegerman"},"body":"## Expected Behavior\nGiven sufficient computational capacity, worker slots, and task queue backlog, an autoscaling poller should increase number of pollers to a number greater than `InitialNumberOfPollers` to pick up more work (up to `MaxinumNumberOfPollers` pollers).\n\n## Actual Behavior\nAn autoscaling poller is incapable of running more than `InitialNumberOfPollers` concurrent pollers.\n\n## Steps to Reproduce the Problem\n  1. Enable Poller Autoscaling\n\ne.g.\n```\nworkerOpts := worker.Options{\n  ActivityTaskPollerBehavior = worker.NewPollerBehaviorAutoscaling(worker.PollerBehaviorAutoscalingOptions{InitialNumberOfPollers: 1})\n  WorkflowTaskPollerBehavior = worker.NewPollerBehaviorAutoscaling(worker.PollerBehaviorAutoscalingOptions{InitialNumberOfPollers: 1})\n}\n[...]\n```\n  2. Run a high volume of resource-light tasks\n\nI specifically ran 2048 workflows at the same time, each of which execute one no-op (`time.Sleep(1 second)`) activity every second on a loop for 15 minutes. The worker was configured with the poller behavior above (1 initial poller for activities and workflows).\n\nI observed `temporal_num_pollers` stay at 1 for each worker type despite minimal cpu/memory utilization, ample free worker slots, and significant workflow task schedule to start latency (~30s average).\n\n## Specifications\n\n  - Version: `v1.37.0`\n  - Platform: n/a\n","closedAt":"2025-11-17T17:26:54Z","comments":[],"createdAt":"2025-11-07T23:19:47Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDg2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":2106,"reactionGroups":[],"state":"CLOSED","title":"Poller Autoscaling can't scale past InitialNumberOfPollers","updatedAt":"2025-11-17T17:26:54Z","url":"https://github.com/temporalio/sdk-go/issues/2106"}
