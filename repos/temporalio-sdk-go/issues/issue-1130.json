{"assignees":[],"author":{"id":"MDQ6VXNlcjEwNDMxNg==","is_bot":false,"login":"zboralski","name":"Anthony Zboralski"},"body":"**Is your feature request related to a problem? Please describe.**\r\nIn the existing design, the `taskLimiter` of an activity, responsible for the worker's rate limit, remains inaccessible. This restricts our capability to adjust the worker's rate dynamically in line with shifting workloads or requirements.\r\n\r\n**Describe the solution you'd like**\r\nI suggest making the `taskLimiter` accessible, thereby enabling developers to modify the worker's rate directly. Upon examining the SDK and `rate.Limiter` code, it seems that using this approach is safe. The `rate.Limiter` uses a mutex to ensure thread safety when adjusting limits.\r\n\r\n**Describe alternatives you've considered**\r\nMaintaining rate limits using the external methods or restarting workers is an option. However, these methods lacks flexibility and might not be the best fit for managing varying workloads.\r\n\r\n**Additional context**\r\nBy granting access to `taskLimiter`, we offer granular control over the worker's rate limit. This is notably beneficial for applications with fluctuating workloads. I recommend trying the function highlighted below and examining `rate.Limiter`'s implementation to verify the safety and efficiency of this proposed change. The internals of `rate.Limiter` are well-guarded by a mutex, ensuring secure adjustments to the rate limit.\r\n\r\nIncluded is a function, GetLimiter(), which can retrieve the taskLimiter from a worker.Worker instance. This function uses reflection to access the internal taskLimiter field of the worker.Worker instance. It's designed to safely navigate various scenarios, including nil workers, non-struct workers, and non-addressable fields. Please note that this function serves as a workaround to demonstrate the importance and potential usage of making taskLimiter accessible, and isn't a recommended long-term solution.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"reflect\"\r\n\t\"unsafe\"\r\n\r\n\t\"go.temporal.io/sdk/worker\"\r\n\t\"golang.org/x/time/rate\"\r\n)\r\n\r\nfunc GetLimiter(w worker.Worker) (*rate.Limiter, error) {\r\n\tif w == nil {\r\n\t\treturn nil, fmt.Errorf(\"Worker is nil\")\r\n\t}\r\n\r\n\t// Extract the value from the interface\r\n\tvalue := reflect.ValueOf(w)\r\n\tif value.Kind() == reflect.Interface && !value.IsNil() {\r\n\t\tvalue = value.Elem()\r\n\t}\r\n\r\n\t// If the value is a pointer, dereference it\r\n\tif value.Kind() == reflect.Ptr && !value.IsNil() {\r\n\t\tvalue = value.Elem()\r\n\t}\r\n\r\n\t// If the value is now a struct, attempt to get the activityWorker field\r\n\tif value.Kind() != reflect.Struct {\r\n\t\treturn nil, fmt.Errorf(\"Expected a struct, but got: %s\", value.Kind())\r\n\t}\r\n\r\n\tactivityWorkerField := value.FieldByName(\"activityWorker\")\r\n\tif !(activityWorkerField.IsValid() && activityWorkerField.CanAddr()) {\r\n\t\treturn nil, fmt.Errorf(\"Field 'activityWorker' is not valid or can't be addressed\")\r\n\t}\r\n\r\n\t// Create a new Value that treats activityWorker as if it were exported\r\n\tactivityWorkerField = reflect.NewAt(activityWorkerField.Type(), unsafe.Pointer(activityWorkerField.UnsafeAddr())).Elem()\r\n\r\n\t// Check if activityWorker is valid and then access baseWorker\r\n\tif activityWorkerField.Kind() == reflect.Ptr && !activityWorkerField.IsNil() {\r\n\t\tactivityWorkerField = activityWorkerField.Elem()\r\n\t}\r\n\r\n\tif activityWorkerField.Kind() != reflect.Struct {\r\n\t\treturn nil, fmt.Errorf(\"Expected a struct, but got: %s\", activityWorkerField.Kind())\r\n\t}\r\n\r\n\tbaseWorkerField := activityWorkerField.FieldByName(\"worker\")\r\n\tif !(baseWorkerField.IsValid() && baseWorkerField.CanAddr()) {\r\n\t\treturn nil, fmt.Errorf(\"Field 'worker' in 'activityWorker' is not valid or can't be addressed\")\r\n\t}\r\n\r\n\t// Create a new Value that treats worker (baseWorker) as if it were exported\r\n\tbaseWorkerField = reflect.NewAt(baseWorkerField.Type(), unsafe.Pointer(baseWorkerField.UnsafeAddr())).Elem()\r\n\r\n\t// Check if baseWorker is valid and then access taskLimiter\r\n\tif baseWorkerField.Kind() == reflect.Ptr && !baseWorkerField.IsNil() {\r\n\t\tbaseWorkerField = baseWorkerField.Elem()\r\n\t}\r\n\r\n\tif baseWorkerField.Kind() != reflect.Struct {\r\n\t\treturn nil, fmt.Errorf(\"Expected a struct, but got: %s\", baseWorkerField.Kind())\r\n\t}\r\n\r\n\ttaskLimiterField := baseWorkerField.FieldByName(\"taskLimiter\")\r\n\tif !(taskLimiterField.IsValid() && taskLimiterField.CanAddr()) {\r\n\t\treturn nil, fmt.Errorf(\"Field 'taskLimiter' in 'baseWorker' is not valid or can't be addressed\")\r\n\t}\r\n\r\n\t// Finally return the taskLimiter as *rate.Limiter\r\n\treturn (*rate.Limiter)(unsafe.Pointer(taskLimiterField.Pointer())), nil\r\n}\r\n```\r\n","closedAt":"2023-07-18T22:44:55Z","comments":[{"id":"IC_kwDODN1w685eN29E","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"This limiter doesn't do what you may think. This doesn't dynamically limit available slots, it just affects time processing after slots are used. The poll has already completed and the timeouts will have already started. Looking at code, this limiter (default governed by `WorkerActivitiesPerSecond` option) pauses the dequeued poll and the next poll from being internally handled, so it leaves two tasks paused even though they were already polled and their timeouts started.\r\n\r\nWhat you need is #569 which is admittedly useful, yes, but challenging to implement.","createdAt":"2023-06-07T12:17:43Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1130#issuecomment-1580691268","viewerDidAuthor":false},{"id":"IC_kwDODN1w685h0Peu","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Closing, but feel free to  reopen if the above explanation wasn't enough","createdAt":"2023-07-18T22:44:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1130#issuecomment-1641084846","viewerDidAuthor":false}],"createdAt":"2023-06-07T12:01:35Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1130,"reactionGroups":[],"state":"CLOSED","title":"Proposal for Accessible `taskLimiter` for Worker Rate Modification","updatedAt":"2023-07-18T22:48:50Z","url":"https://github.com/temporalio/sdk-go/issues/1130"}
