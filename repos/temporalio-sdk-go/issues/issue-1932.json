{"assignees":[],"author":{"id":"MDQ6VXNlcjYwOTQwOTA=","is_bot":false,"login":"iwittkau","name":""},"body":"**Is your feature request related to a problem? Please describe.**\n\nWe're often defining activities like this:\n\n```go\ntype ActivityArguments struct {\n\tName string\n}\n\ntype ActivityResults struct {\n\tGreeting string\n}\n\nfunc Activity(ctx context.Context, args ActivityArguments) (ActivityResults, error) {\n\treturn ActivityResults{Greeting: \"Hello \" + args.Name + \"!\"}, nil\n}\n```\n\nExecuting this activity from a workflow usually looks like this:\n\n```go\nargs := ActivityArguments{Name: name}\nvar result ActivityResults\nif err := workflow.ExecuteActivity(ctx, Activity, args).Get(ctx, &result); err != nil {\n    return \"\", err\n}\n```\n\nThis has some problems:\n\n- Boilerplate code is required to create a result variable.\n- No compile-time check if the arguments passed match the activity definition.\n- No compile-time check if the results returned match the activity definition.\n\nAlso, the readability of this block of code will deteriorate as the names get longer.\n\n**Describe the solution you'd like**\n\nWriting generic, type-safe wrappers is already possible:\n\n```go\nfunc ExecuteActivityAndGetResult[A any, R any](ctx workflow.Context, activity func(context.Context, A) (R, error), args A) (R, error) {\n\tvar result R\n\terr := workflow.ExecuteActivity(ctx, activity, args).Get(ctx, &result)\n\treturn result, err\n}\n\nfunc ExecuteActivity[A any, R any](ctx workflow.Context, activity func(context.Context, A) (R, error), args A) Future[R] {\n\tf := workflow.ExecuteActivity(ctx, activity, args)\n\treturn &futureWrapper[R]{Future: f}\n}\n\ntype Future[T any] interface {\n\tGet(ctx workflow.Context, valuePtr *T) error\n\tIsReady() bool\n}\n\ntype futureWrapper[T any] struct {\n\tworkflow.Future\n}\n\nfunc (f *futureWrapper[T]) Get(ctx workflow.Context, valuePtr *T) error {\n\treturn f.Future.Get(ctx, valuePtr)\n}\n```\n\nThis doesn't work with variadic parameters, but using a single struct [is recommended anyway](https://docs.temporal.io/develop/go/core-application#activity-parameters).\n\nHowever, it fixes the problems mentioned above:\n\n- Less boilerplate code.\n- Type checks at compile-time.\n\nIt's a simple function call now: \n\n```go\nargs := ActivityArguments{Name: name}\nresult, err := ExecuteActivityAndGetResult(ctx, Activity, args)\nif err != nil {\n    return \"\", err\n}\n```\n\nOr with a separate future:\n\n```go\nvar result ActivityResults\nf := ExecuteActivity(ctx, Activity, args)\nif err := f.Get(ctx, &result); err != nil {\n    return \"\", err\n}\n```\n\nNow it fails to compile if the wrong types are used:\n\n```go\nresult, err := ExecuteActivityAndGetResult(ctx, Activity, \"Temporal\")\nif err != nil {\n    return \"\", err\n}\n```\n\n```\ncannot use \"Temporal\" (untyped string constant) as ActivityArguments\n```\n\nSame here:\n\n```go\nvar result string\nf := ExecuteActivity(ctx, Activity, args)\nif err := f.Get(ctx, &result); err != nil {\n    return \"\", err\n}\n```\n\n```\ncannot use &result (value of type *string) as *ActivityResults\n```\n\n**Describe alternatives you've considered**\n\nDoesn't apply.\n\n**Additional context**\n\nDoesn't apply.\n","closedAt":"2025-04-24T15:59:26Z","comments":[{"id":"IC_kwDODN1w686okfij","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Hi, Yes generic support is something we are interested in exploring at some point in the future. It likely wouldn't look exactly like what is proposed here, but I fully agree with you on the benefits it would provide. There is still a lot of design and thought that needs to go into how we create a fully type safe API, including things like type safe workflows, activities, signals, updates and queries.\n\nWe already have an issue for this so I am going to close this issue to avoid having duplicate issues for the same the same feature request.","createdAt":"2025-04-24T15:59:26Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-go/issues/1932#issuecomment-2828138659","viewerDidAuthor":false},{"id":"IC_kwDODN1w686opyZS","author":{"login":"iwittkau"},"authorAssociation":"NONE","body":"@Quinn-With-Two-Ns I tried searching for similar issues but couldn't find one. Having only one makes sense. I didn't expect my solution, which I came up with in an afternoon, to be implemented exactly like this anyway.\nBut since it seems like there are no concrete plans to implement this, I think I'll just add these helpers to my projects.","createdAt":"2025-04-25T06:51:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1932#issuecomment-2829526610","viewerDidAuthor":false}],"createdAt":"2025-04-24T15:35:20Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1932,"reactionGroups":[],"state":"CLOSED","title":"Provide a type-safe implementation of workflow.ExecuteActivity","updatedAt":"2025-04-25T06:51:39Z","url":"https://github.com/temporalio/sdk-go/issues/1932"}
