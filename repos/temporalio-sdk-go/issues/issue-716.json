{"assignees":[],"author":{"id":"MDQ6VXNlcjYzMDU5NTk=","is_bot":false,"login":"aouji","name":""},"body":"## Expected Behavior\r\nTerminating a workflow should not leave behind coroutines\r\n\r\n## Actual Behavior\r\nIf a workflow is terminated while processing, it can leak coroutines.\r\n\r\nWe have a fairly complex workflow following the dsl pattern in https://github.com/temporalio/samples-go/blob/main/dsl/workflow.go . It seems like if a dsl workflow is terminated before all activities are processed, any pending coroutines handling them will be stuck forever. We can see this using pprof:\r\n\r\n```\r\n-----------+-------------------------------------------------------\r\n      1231   runtime.gopark\r\n             runtime.chanrecv\r\n             runtime.chanrecv1\r\n             go.temporal.io/sdk/internal.(*coroutineState).initialYield\r\n             go.temporal.io/sdk/internal.(*coroutineState).yield (inline)\r\n             go.temporal.io/sdk/internal.(*channelImpl).Receive\r\n             go.temporal.io/sdk/internal.(*decodeFutureImpl).Get\r\n             pkg/workflows.ActivityInvocation.execute\r\n             pkg/workflows.(*Statement).execute\r\n             pkg/workflows.executeAsync.func1\r\n             go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1\r\n-----------+-------------------------------------------------------\r\n        17   runtime.gopark\r\n             runtime.chanrecv\r\n             runtime.chanrecv1\r\n             go.temporal.io/sdk/internal.(*coroutineState).initialYield\r\n             go.temporal.io/sdk/internal.(*coroutineState).yield (inline)\r\n             go.temporal.io/sdk/internal.(*selectorImpl).Select\r\n             pkg/workflows.Parallel.execute\r\n             pkg/workflows.(*Statement).execute\r\n             pkg/workflows.Sequence.execute\r\n             pkg/workflows.(*Statement).execute\r\n             pkg/workflows.DSLWorkflow\r\n             reflect.Value.call\r\n             reflect.Value.Call\r\n             go.temporal.io/sdk/internal.executeFunction\r\n             go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow\r\n             go.temporal.io/sdk/internal.(*workflowExecutor).Execute\r\n             go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1\r\n             go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1\r\n```\r\n\r\nThis is specially affecting us as due to another issue our workflows can get stuck during cancellation ( https://community.temporal.io/t/invalid-history-builder-state-for-action-add-activitytask-cancel-requested-event/3459 ) and we have worked around that by trying to detect and automatically terminate such workflows... \r\n\r\nIt will be great if the sdk can ensure all channels are closed and nothing is leaked when a workflow is terminated\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n  1. Try running the dsl workflow at https://github.com/temporalio/samples-go/blob/main/dsl/workflow.go with a large number of parallel activities \r\n  1. Terminate the workflow before activities finish\r\n  1. check number of goroutines in the worker process that handled the workflow\r\n\r\n## Specifications\r\n\r\n  - Version:  1.12.0\r\n  - Platform: MacOS\r\n","closedAt":null,"comments":[{"id":"IC_kwDODN1w685B4CbE","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"This may be fixed by #779, but we will have to test after that is merged.","createdAt":"2022-04-21T13:30:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/716#issuecomment-1105209028","viewerDidAuthor":false}],"createdAt":"2022-02-04T02:02:38Z","labels":[{"id":"MDU6TGFiZWwyMDUzODEzNTY0","name":"potential-bug","description":"","color":"90c109"}],"milestone":null,"number":716,"reactionGroups":[],"state":"OPEN","title":"If a workflow is terminated while processing, it can leak coroutines","updatedAt":"2022-04-21T13:32:32Z","url":"https://github.com/temporalio/sdk-go/issues/716"}
