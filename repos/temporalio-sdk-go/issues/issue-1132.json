{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"**Describe the solution you'd like**\r\n\r\nThis is for the https://github.com/temporalio/api-go project but it doesn't accept issues.\r\n\r\nToday the payload visitor in https://pkg.go.dev/go.temporal.io/api/proxy visits sets of payloads as they are seen one set at a time. Users want to collect these and then visit them together all at once. Here's how they collect them all in user-land:\r\n\r\n```go\r\nfunc CollectAllPayloads(msg proto.Message) (payloads []*common.Payload, err error) {\r\n\terr = proxy.VisitPayloads(context.Background(), msg, proxy.VisitPayloadsOptions{\r\n\t\tVisitor: func(ctx *proxy.VisitPayloadsContext, p []*common.Payload) ([]*common.Payload, error) {\r\n\t\t\tpayloads = append(payloads, p...)\r\n\t\t\treturn p, nil\r\n\t\t},\r\n\t\tSkipSearchAttributes: true,\r\n\t})\r\n\treturn\r\n}\r\n```\r\n\r\nAnd a utility to apply something to all payloads:\r\n\r\n```go\r\nfunc ApplyToAllPayloads(msg proto.Message, apply ApplyFunc) error {\r\n\tpayloads, err := CollectAllPayloads(msg)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tnewPayloads, err := apply(payloads)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tif len(newPayloads) != len(payloads) {\r\n\t\treturn fmt.Errorf(\"expected %v payload(s), got %v\", len(payloads), len(newPayloads))\r\n\t}\r\n\t// Clear and merge new payloads onto old ones\r\n\t// this mutates the payloads var\r\n\tfor i, payload := range payloads {\r\n\t\tpayload.Reset()\r\n\t\tproto.Merge(payload, newPayloads[i])\r\n\t}\r\n\treturn nil\r\n}\r\n```\r\n\r\nThen how they may invoke them all at once in the interceptor:\r\n\r\n```go\r\ntype AllPayloadVisitorInterceptorOptions struct {\r\n\tOutboundApplyAll func([]*common.Payload) ([]*common.Payload, error)\r\n\tInboundApplyAll  func([]*common.Payload) ([]*common.Payload, error)\r\n}\r\n\r\nfunc NewAllPayloadVisitorInterceptor(options AllPayloadVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {\r\n\treturn func(ctx context.Context, method string, req, response interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {\r\n\t\tif reqMsg, ok := req.(proto.Message); ok && options.OutboundApplyAll != nil {\r\n\t\t\terr := ApplyToAllPayloads(reqMsg, options.OutboundApplyAll)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn err\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\terr := invoker(ctx, method, req, response, cc, opts...)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\tif resMsg, ok := response.(proto.Message); ok && options.InboundApplyAll != nil {\r\n\t\t\treturn ApplyToAllPayloads(resMsg, options.InboundApplyAll)\r\n\t\t}\r\n\r\n\t\treturn nil\r\n\t}, nil\r\n}\r\n```\r\n\r\nBasically we need this functionality opt-in. The best solution is probably some kind of `AllAtOnce bool` option on `VisitPayloadsOptions`, with documentation saying that every output payload must be 1:1 with input, and that the payloads still need to be able to be handled individually on in/out (i.e. you can't encrypt them together as one blob, because they need to be isolated), and that `VisitPayloadsContext.Parent` will be nil for the single visit call we will make.","closedAt":null,"comments":[],"createdAt":"2023-06-08T22:34:39Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1132,"reactionGroups":[],"state":"OPEN","title":"Add support for visiting all payloads at once in proxy visitor interceptor","updatedAt":"2023-06-08T22:34:39Z","url":"https://github.com/temporalio/sdk-go/issues/1132"}
