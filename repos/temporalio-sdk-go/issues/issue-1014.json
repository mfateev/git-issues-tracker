{"assignees":[{"id":"MDQ6VXNlcjIwNTA0MDQ5","login":"Quinn-With-Two-Ns","name":"Quinn Klassen","databaseId":0}],"author":{"id":"MDQ6VXNlcjIwNTA0MDQ5","is_bot":false,"login":"Quinn-With-Two-Ns","name":"Quinn Klassen"},"body":"\r\nThis workflow\r\n```\r\nfunc MutableSideEffectWorkflow(ctx workflow.Context) error {\r\n\ti := 0\r\n\tencodedValue := workflow.MutableSideEffect(ctx, \"id\",\r\n\t\tfunc(ctx workflow.Context) interface{} { return i },\r\n\t\tfunc(a interface{}, b interface{}) bool {\r\n\t\t\treturn a == b\r\n\t\t},\r\n\t)\r\n\tvar sideEffectValue int\r\n\terr := encodedValue.Get(&sideEffectValue)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tvar future workflow.Future\r\n\tif sideEffectValue == 0 {\r\n\t\tao := workflow.ActivityOptions{\r\n\t\t\tScheduleToStartTimeout: time.Minute,\r\n\t\t\tStartToCloseTimeout:    time.Minute,\r\n\t\t\tHeartbeatTimeout:       time.Second * 20,\r\n\t\t}\r\n\t\tctx = workflow.WithActivityOptions(ctx, ao)\r\n\t\tinput := \"hello\"\r\n\t\tfuture = workflow.ExecuteActivity(ctx, helloworldActivity, input)\r\n\t}\r\n\ti += 1\r\n\r\n\tencodedValue = workflow.MutableSideEffect(ctx, \"id\",\r\n\t\tfunc(ctx workflow.Context) interface{} { return i },\r\n\t\tfunc(a interface{}, b interface{}) bool {\r\n\t\t\treturn a == b\r\n\t\t},\r\n\t)\r\n\terr = encodedValue.Get(&sideEffectValue)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\tvar output string\r\n\terr = future.Get(ctx, &output)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n```\r\nIs not deterministic because on the fist run `sideEffectValue` is equal to one 0 after the first `MutableSideEffect` and the activity starts. On replay `sideEffectValue` is equal to 1 and the activity is not launched. We don't document this [limitation](https://pkg.go.dev/go.temporal.io/sdk/workflow#MutableSideEffect) of mutable side effects and I believe it is a bug.\r\n\r\nThe problem is the Go SDK always uses the lastest value of a MutableSideEffect up to the current WFT for each ID so if `MutableSideEffect` returns a different value in the same WFT the last will be used on replay.\r\n\r\nI found this while trying to fix workflow versioning in a loop, but @cretz also brought up this issue in his PR https://github.com/temporalio/sdk-go/pull/809\r\n\r\n>Question: What if two mutable side effects of the same ID are run during the same WFT? We don't differentiate by command, only by user-defined marker ID.\r\n\r\n  - Version: 1.20.0\r\n  - Platform: Mac M1\r\n","closedAt":"2023-03-01T21:06:28Z","comments":[{"id":"IC_kwDODN1w685T7ElK","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Looking at it more I don't believe this can be fixed without writing new information to the history. There is not enough information to distinguish when the MSE changed value on replay because only the nextCommandID is recorded and that if almost useless to tell them apart. \r\n\r\nnote: the fix in https://github.com/temporalio/sdk-go/pull/809 does not actually generate the commands on the correct MSE so it does not apply. It only makes the history work because we do not check payload. ","createdAt":"2023-01-30T04:47:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1014#issuecomment-1407994186","viewerDidAuthor":false}],"createdAt":"2023-01-28T00:16:17Z","labels":[{"id":"MDU6TGFiZWwyMDUzODEzNTY0","name":"potential-bug","description":"","color":"90c109"}],"milestone":null,"number":1014,"reactionGroups":[],"state":"CLOSED","title":"workflow.MutableSideEffect not deterministic if called multiple times with the same ID in the same WFT","updatedAt":"2023-03-01T21:06:28Z","url":"https://github.com/temporalio/sdk-go/issues/1014"}
