{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"## Expected Behavior\r\n\r\nShould not have internal state errors\r\n\r\n## Actual Behavior\r\n\r\nHas internal state errors, specifically something like:\r\n\r\n    BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event, ScheduledID: 99\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n<details>\r\n<summary>main.go</summary>\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"os/exec\"\r\n\t\"runtime/debug\"\r\n\t\"strings\"\r\n\t\"time\"\r\n\r\n\t\"github.com/google/uuid\"\r\n\t\"go.temporal.io/sdk/client\"\r\n\t\"go.temporal.io/sdk/temporal\"\r\n\t\"go.temporal.io/sdk/worker\"\r\n\t\"go.temporal.io/sdk/workflow\"\r\n)\r\n\r\nfunc main() {\r\n\tif err := run(); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n}\r\n\r\nconst useTemporalite = true\r\nconst taskQueue = \"my-task-queue\"\r\n\r\nfunc run() error {\r\n\tvar clientOpts client.Options\r\n\r\n\t// Create a logger that will break on the error we've been waiting for\r\n\terrSeenCh := make(chan struct{})\r\n\tclientOpts.Logger = &logger{\r\n\t\texcludeLevels: map[string]bool{\"DEBUG\": true},\r\n\t\tonMessageContains: map[string]func(level, msg string){\r\n\t\t\t\"BadRequestCancelActivityAttributes\": func(level, msg string) {\r\n\t\t\t\tdebug.PrintStack()\r\n\t\t\t\tclose(errSeenCh)\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\t// Use temporalite if desired\r\n\tif useTemporalite {\r\n\t\tclientOpts.Namespace = \"namespace-\" + uuid.NewString()\r\n\t\tclientOpts.HostPort = \"localhost:9233\"\r\n\t\tcmd := exec.Command(\"temporalite\", \"start\", \"--ephemeral\", \"--namespace\", clientOpts.Namespace, \"--port\", \"9233\")\r\n\t\t// cmd.Stdout, cmd.Stderr = os.Stdout, os.Stderr\r\n\t\tif err := cmd.Start(); err != nil {\r\n\t\t\treturn fmt.Errorf(\"failed starting temporalite: %w\", err)\r\n\t\t}\r\n\t\tdefer cmd.Process.Kill()\r\n\t\ttime.Sleep(200 * time.Millisecond)\r\n\t}\r\n\r\n\t// Create client\r\n\tc, err := client.NewClient(clientOpts)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed creating client: %w\", err)\r\n\t}\r\n\tdefer c.Close()\r\n\r\n\t// Start workers\r\n\tconst workerCount = 10\r\n\tlog.Printf(\"Starting %v workers\", workerCount)\r\n\tfor i := 0; i < workerCount; i++ {\r\n\t\tw, err := startWorker(c)\r\n\t\tif err != nil {\r\n\t\t\treturn fmt.Errorf(\"failed starting worker: %w\", err)\r\n\t\t}\r\n\t\tdefer w.Stop()\r\n\t}\r\n\tlog.Printf(\"Started %v workers\", workerCount)\r\n\r\n\t// Run \"breakers\"\r\n\tconst breakerCount = 10\r\n\tlog.Printf(\"Running %v breakers\", breakerCount)\r\n\tbreakerDoneCh := make(chan error, breakerCount)\r\n\tfor i := 0; i < breakerCount; i++ {\r\n\t\tgo func() { breakerDoneCh <- runBreaker(c) }()\r\n\t}\r\n\r\n\t// Wait for them all to finish or error\r\n\tfor i := 0; i < breakerCount; i++ {\r\n\t\tselect {\r\n\t\tcase <-errSeenCh:\r\n\t\t\treturn fmt.Errorf(\"saw BadRequestCancelActivityAttributes\")\r\n\t\tcase err := <-breakerDoneCh:\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn fmt.Errorf(\"breaker failed: %w\", err)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tlog.Printf(\"Breakers done\")\r\n\treturn nil\r\n}\r\n\r\nfunc startWorker(c client.Client) (worker.Worker, error) {\r\n\tw := worker.New(c, taskQueue, worker.Options{\r\n\t\tMaxConcurrentActivityExecutionSize: 2,\r\n\t})\r\n\tw.RegisterWorkflow(SomeWorkflow)\r\n\tw.RegisterWorkflow(DoABunchOfActivitiesWorkflow)\r\n\tw.RegisterActivity(NoopActivity)\r\n\treturn w, w.Start()\r\n}\r\n\r\nfunc runBreaker(c client.Client) error {\r\n\tfor i := 0; i < 20; i++ {\r\n\t\t_, err := c.ExecuteWorkflow(context.Background(), client.StartWorkflowOptions{TaskQueue: taskQueue}, SomeWorkflow)\r\n\t\tif err != nil {\r\n\t\t\treturn fmt.Errorf(\"failed starting workflow: %w\", err)\r\n\t\t}\r\n\t\ttime.Sleep(2 * time.Second)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc SomeWorkflow(ctx workflow.Context) error {\r\n\tchildCtx, childCancel := workflow.WithCancel(ctx)\r\n\tchildCtx = workflow.WithChildOptions(childCtx, workflow.ChildWorkflowOptions{\r\n\t\tWorkflowTaskTimeout: time.Minute,\r\n\t\tWaitForCancellation: true,\r\n\t})\r\n\tchildFut := workflow.ExecuteChildWorkflow(childCtx, DoABunchOfActivitiesWorkflow)\r\n\r\n\t// Wait for start\r\n\tif err := childFut.GetChildWorkflowExecution().Get(ctx, nil); err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\t// Cancel and wait for child done\r\n\tchildCancel()\r\n\treturn childFut.Get(ctx, nil)\r\n}\r\n\r\nfunc DoABunchOfActivitiesWorkflow(ctx workflow.Context) error {\r\n\tctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{\r\n\t\tStartToCloseTimeout: 5 * time.Hour,\r\n\t\tHeartbeatTimeout:    20 * time.Second,\r\n\t\tRetryPolicy: &temporal.RetryPolicy{\r\n\t\t\tInitialInterval:    time.Second,\r\n\t\t\tBackoffCoefficient: 2,\r\n\t\t\tMaximumInterval:    time.Minute * 10,\r\n\t\t\tMaximumAttempts:    5,\r\n\t\t},\r\n\t\tWaitForCancellation: true,\r\n\t})\r\n\r\n\tchildCtx, cancelHandler := workflow.WithCancel(ctx)\r\n\tsel := workflow.NewSelector(ctx)\r\n\r\n\tconst activityCount = 100\r\n\r\n\tfor i := 0; i < activityCount; i++ {\r\n\t\tsel.AddFuture(workflow.ExecuteActivity(childCtx, NoopActivity), func(f workflow.Future) {\r\n\t\t\tif err := f.Get(ctx, nil); err != nil {\r\n\t\t\t\t// Cancel all activities\r\n\t\t\t\tcancelHandler()\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfor i := 0; i < activityCount; i++ {\r\n\t\tsel.Select(ctx)\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\nfunc NoopActivity(aCtx context.Context) error { return nil }\r\n\r\ntype logger struct {\r\n\t// Called _after_ logged\r\n\tonMessageContains map[string]func(level, msg string)\r\n\texcludeLevels     map[string]bool\r\n}\r\n\r\nfunc (l *logger) log(level, msg string, keyvals ...interface{}) {\r\n\tif l.excludeLevels[level] {\r\n\t\treturn\r\n\t}\r\n\tmsg = fmt.Sprint(append([]interface{}{msg}, keyvals...))\r\n\tlog.Print([]interface{}{level, msg})\r\n\tfor str, callback := range l.onMessageContains {\r\n\t\tif strings.Contains(msg, str) {\r\n\t\t\tcallback(level, msg)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc (l *logger) Debug(msg string, keyvals ...interface{}) { l.log(\"DEBUG\", msg, keyvals...) }\r\nfunc (l *logger) Info(msg string, keyvals ...interface{})  { l.log(\"INFO\", msg, keyvals...) }\r\nfunc (l *logger) Warn(msg string, keyvals ...interface{})  { l.log(\"WARN\", msg, keyvals...) }\r\nfunc (l *logger) Error(msg string, keyvals ...interface{}) { l.log(\"ERROR\", msg, keyvals...) }\r\n```\r\n\r\n</details>\r\n\r\nRun the `main.go` code above with https://github.com/DataDog/temporalite on the `PATH`. It should break fairly quickly.","closedAt":"2022-02-18T14:10:18Z","comments":[],"createdAt":"2022-02-10T22:05:29Z","labels":[{"id":"MDU6TGFiZWwyMDUzODEzNTY0","name":"potential-bug","description":"","color":"90c109"}],"milestone":null,"number":724,"reactionGroups":[],"state":"CLOSED","title":"Activity cancellation causes history error","updatedAt":"2022-02-18T14:10:18Z","url":"https://github.com/temporalio/sdk-go/issues/724"}
