{"assignees":[],"author":{"id":"MDQ6VXNlcjIyNzg5ODUx","is_bot":false,"login":"ndtretyak","name":"Nikolay Tretyak"},"body":"**Is your feature request related to a problem? Please describe.**\r\nIn the following example I use `time.Now()`, but `workflowcheck` does not report this problem because `RegisterWorflow` is called with `Handler.BadWorkflow` rather than `handlerImpl.BadWorkflow`.\r\n\r\n```go\r\ntype HandlerInterface interface {\r\n\tBadWorkflow(ctx workflow.Context) (int64, error)\r\n}\r\n\r\ntype handlerImpl struct{}\r\n\r\nfunc (w handlerImpl) BadWorkflow(ctx workflow.Context) (int64, error) {\r\n\treturn time.Now().Unix(), nil\r\n}\r\n\r\nfunc CreateWorker(c client.Client, h HandlerInterface) worker.Worker {\r\n\tw := worker.New(c, \"example\", worker.Options{})\r\n\tw.RegisterWorkflow(h.BadWorkflow)\r\n\treturn w\r\n}\r\n\r\nfunc main() {\r\n\t....\r\n\tw := CreateWorker(c, handlerImpl{})\r\n}\r\n```\r\n\r\n**Describe the solution you'd like**\r\nI'd like `workflowcheck` to match the interface passed to `RegisterWorkflow` with its implementations.","closedAt":"2023-08-30T16:14:51Z","comments":[{"id":"IC_kwDODN1w685k0u1y","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"A static analyzer is not going to be able to follow implementations of interfaces because Go does not have a way to define which types are meant to implement an interface at compile time. It would be non-trivial to walk the control graph backwards from `RegisterWorkflow` to fine what was really used. If at all possible, consider registering functions on concrete types. If you must use an interface, maybe have a `Register(worker.WorkflowRegistry)` method on it that each implementation implements and you call generally.\r\n\r\nWe may be able to, for every `SomeInterface`, look for `var _ SomeInterface = (*SomeType)(nil)` to find all `SomeType`s that implement it. We may also be able to have a way for you to mark workflow entry points when they couldn't otherwise be discovered at compile time. But both options are more brittle than registering functions/methods on the type that implements them.","createdAt":"2023-08-24T12:00:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1207#issuecomment-1691544946","viewerDidAuthor":false},{"id":"IC_kwDODN1w685k1RYj","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"@cretz Do we need users to mark workflow entry points? Can't we assume any function that takes a `ctx workflow.Context` as the first parameter is a workflow and analyze it?","createdAt":"2023-08-24T13:33:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1207#issuecomment-1691686435","viewerDidAuthor":false},{"id":"IC_kwDODN1w685k1Y69","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> Can't we assume any function that takes a ctx workflow.Context as the first parameter is a workflow and analyze it?\r\n\r\nWe can probably do this, though the existing behavior of bubbling up to top-level workflow call would be lost. But maybe that is preferred?","createdAt":"2023-08-24T13:48:36Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1207#issuecomment-1691717309","viewerDidAuthor":false}],"createdAt":"2023-08-24T11:47:04Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1207,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"CLOSED","title":"Handle interfaces in workflowcheck","updatedAt":"2023-08-30T16:14:51Z","url":"https://github.com/temporalio/sdk-go/issues/1207"}
