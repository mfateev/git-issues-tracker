{"assignees":[{"id":"MDQ6VXNlcjI3NTk0Nw==","login":"mmcshane","name":"Matt McShane","databaseId":0},{"id":"MDQ6VXNlcjIyMzI1MjQ=","login":"alexshtin","name":"Alex Shtin","databaseId":0}],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"## Steps to Reproduce the Problem\r\n\r\nHere are two standalone examples that cause context deadline results for update.\r\n\r\nGets some proper events:\r\n<details><summary>Replication 1</summary><p>\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"time\"\r\n\r\n\t\"github.com/google/uuid\"\r\n\t\"go.temporal.io/sdk/client\"\r\n\t\"go.temporal.io/sdk/worker\"\r\n\t\"go.temporal.io/sdk/workflow\"\r\n)\r\n\r\n// Scenario:\r\n// * Workflow waits for activity inside update\r\n// * Workflow worker stops after activity started\r\n// * Update sent\r\n// * Activity completed\r\n// * Workflow worker started back up\r\n\r\nfunc main() {\r\n\tif err := run(); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n}\r\n\r\nfunc run() error {\r\n\tctx, cancel := context.WithCancel(context.Background())\r\n\tdefer cancel()\r\n\r\n\tlog.Printf(\"Creating client\")\r\n\tc, err := client.Dial(client.Options{})\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed creating client: %w\", err)\r\n\t}\r\n\tdefer c.Close()\r\n\r\n\tlog.Printf(\"Starting workflow worker\")\r\n\ttaskQueue := uuid.NewString()\r\n\tworkflowWorker := worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})\r\n\tworkflowWorker.RegisterWorkflow(MyWorkflow)\r\n\tif err := workflowWorker.Start(); err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting worker: %w\", err)\r\n\t}\r\n\r\n\tlog.Printf(\"Starting activity worker\")\r\n\tactivityWorker := worker.New(c, taskQueue, worker.Options{DisableWorkflowWorker: true})\r\n\tactivityWorker.RegisterActivity(MyActivity)\r\n\tif err := activityWorker.Start(); err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting worker: %w\", err)\r\n\t}\r\n\tdefer activityWorker.Stop()\r\n\r\n\tlog.Printf(\"Starting workflow\")\r\n\trun, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, MyWorkflow)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting workflow: %w\", err)\r\n\t}\r\n\r\n\tlog.Printf(\"Waiting for activity to show as started\")\r\n\t<-activityWaiting\r\n\r\n\tlog.Printf(\"Starting update\")\r\n\t// Send update in background\r\n\tupdateResultCh := make(chan string, 1)\r\n\tupdateErrCh := make(chan error, 1)\r\n\tgo func() {\r\n\t\tvar updateResult string\r\n\t\thandle, err := c.UpdateWorkflow(ctx, run.GetID(), run.GetRunID(), \"MyUpdate\")\r\n\t\tif err != nil {\r\n\t\t\tupdateErrCh <- err\r\n\t\t} else if err := handle.Get(ctx, &updateResult); err != nil {\r\n\t\t\tupdateErrCh <- err\r\n\t\t} else {\r\n\t\t\tupdateResultCh <- updateResult\r\n\t\t}\r\n\t}()\r\n\r\n\tlog.Printf(\"Waiting two seconds then shutting down workflow worker\")\r\n\ttime.Sleep(2 * time.Second)\r\n\tworkflowWorker.Stop()\r\n\r\n\tlog.Printf(\"Completing activity\")\r\n\tclose(activityShouldComplete)\r\n\r\n\tlog.Printf(\"Waiting two seconds and starting up workflow worker again\")\r\n\ttime.Sleep(2 * time.Second)\r\n\tworkflowWorker = worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})\r\n\tworkflowWorker.RegisterWorkflow(MyWorkflow)\r\n\tif err := workflowWorker.Start(); err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting worker: %w\", err)\r\n\t}\r\n\tdefer workflowWorker.Stop()\r\n\r\n\tselect {\r\n\tcase res := <-updateResultCh:\r\n\t\tlog.Printf(\"Got update result: %v\", res)\r\n\t\treturn nil\r\n\tcase err := <-updateErrCh:\r\n\t\treturn fmt.Errorf(\"got update error: %w\", err)\r\n\t}\r\n}\r\n\r\nvar activityWaiting = make(chan struct{})\r\nvar activityShouldComplete = make(chan struct{})\r\n\r\nfunc MyActivity(ctx context.Context) (string, error) {\r\n\tselect {\r\n\tcase <-activityWaiting:\r\n\tdefault:\r\n\t\tclose(activityWaiting)\r\n\t}\r\n\t<-activityShouldComplete\r\n\treturn \"some string\", nil\r\n}\r\n\r\nfunc MyWorkflow(ctx workflow.Context) error {\r\n\t// Start activity\r\n\tfut := workflow.ExecuteActivity(\r\n\t\tworkflow.WithActivityOptions(ctx, workflow.ActivityOptions{ScheduleToCloseTimeout: 30 * time.Hour}),\r\n\t\tMyActivity,\r\n\t)\r\n\r\n\t// Set update handler that only completes after activity completes\r\n\terr := workflow.SetUpdateHandler(\r\n\t\tctx,\r\n\t\t\"MyUpdate\",\r\n\t\tfunc(ctx workflow.Context) (s string, err error) {\r\n\t\t\terr = fut.Get(ctx, &s)\r\n\t\t\treturn\r\n\t\t},\r\n\t)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed setting update handler: %w\", err)\r\n\t}\r\n\r\n\t// Wait around\r\n\treturn workflow.Sleep(ctx, 30*time.Hour)\r\n}\r\n\r\n```\r\n\r\n</p></details>\r\n\r\nHistory doesn't even acknowledge update accepted:\r\n\r\n<details><summary>Replication 2</summary><p>\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"time\"\r\n\r\n\t\"github.com/google/uuid\"\r\n\t\"go.temporal.io/sdk/client\"\r\n\t\"go.temporal.io/sdk/worker\"\r\n\t\"go.temporal.io/sdk/workflow\"\r\n)\r\n\r\n// Scenario:\r\n// * Workflow has simple update handler and starts activity\r\n// * Workflow worker stops after activity started\r\n// * Update sent, activity completed, another update sent\r\n// * Workflow worker started back up\r\n\r\nfunc main() {\r\n\tif err := run(); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n}\r\n\r\nfunc run() error {\r\n\tctx, cancel := context.WithCancel(context.Background())\r\n\tdefer cancel()\r\n\r\n\tlog.Printf(\"Creating client\")\r\n\tc, err := client.Dial(client.Options{})\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed creating client: %w\", err)\r\n\t}\r\n\tdefer c.Close()\r\n\r\n\tlog.Printf(\"Starting workflow worker\")\r\n\ttaskQueue := uuid.NewString()\r\n\tworkflowWorker := worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})\r\n\tworkflowWorker.RegisterWorkflow(MyWorkflow)\r\n\tif err := workflowWorker.Start(); err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting worker: %w\", err)\r\n\t}\r\n\r\n\tlog.Printf(\"Starting activity worker\")\r\n\tactivityWorker := worker.New(c, taskQueue, worker.Options{DisableWorkflowWorker: true})\r\n\tactivityWorker.RegisterActivity(MyActivity)\r\n\tif err := activityWorker.Start(); err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting worker: %w\", err)\r\n\t}\r\n\tdefer activityWorker.Stop()\r\n\r\n\tlog.Printf(\"Starting workflow\")\r\n\trun, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, MyWorkflow)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting workflow: %w\", err)\r\n\t}\r\n\r\n\tlog.Printf(\"Waiting for activity to show as started\")\r\n\t<-activityWaiting\r\n\r\n\tlog.Printf(\"Shutting down workflow worker\")\r\n\ttime.Sleep(2 * time.Second)\r\n\tworkflowWorker.Stop()\r\n\r\n\t// Updater\r\n\tupdateResultCh := make(chan string, 2)\r\n\tupdateErrCh := make(chan error, 2)\r\n\tdoUpdate := func() {\r\n\t\tvar updateResult string\r\n\t\tif handle, err := c.UpdateWorkflow(ctx, run.GetID(), run.GetRunID(), \"MyUpdate\"); err != nil {\r\n\t\t\tupdateErrCh <- err\r\n\t\t} else if err := handle.Get(ctx, &updateResult); err != nil {\r\n\t\t\tupdateErrCh <- err\r\n\t\t} else {\r\n\t\t\tupdateResultCh <- updateResult\r\n\t\t}\r\n\t}\r\n\r\n\tlog.Printf(\"Sending first update\")\r\n\tgo doUpdate()\r\n\r\n\tlog.Printf(\"Waiting two seconds then completing activity\")\r\n\ttime.Sleep(2 * time.Second)\r\n\tclose(activityShouldComplete)\r\n\r\n\tlog.Printf(\"Waiting two seconds and sending second update\")\r\n\ttime.Sleep(2 * time.Second)\r\n\tgo doUpdate()\r\n\r\n\tlog.Printf(\"Waiting two seconds and starting up workflow worker again\")\r\n\ttime.Sleep(2 * time.Second)\r\n\tworkflowWorker = worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})\r\n\tworkflowWorker.RegisterWorkflow(MyWorkflow)\r\n\tif err := workflowWorker.Start(); err != nil {\r\n\t\treturn fmt.Errorf(\"failed starting worker: %w\", err)\r\n\t}\r\n\tdefer workflowWorker.Stop()\r\n\r\n\tfor i := 0; i < 2; i++ {\r\n\t\tselect {\r\n\t\tcase res := <-updateResultCh:\r\n\t\t\tlog.Printf(\"Got update result: %v\", res)\r\n\t\tcase err := <-updateErrCh:\r\n\t\t\treturn fmt.Errorf(\"got update error: %w\", err)\r\n\t\t}\r\n\t}\r\n\r\n\tlog.Printf(\"Replaying workflow\")\r\n\treplayer := worker.NewWorkflowReplayer()\r\n\treplayer.RegisterWorkflow(MyWorkflow)\r\n\terr = replayer.ReplayWorkflowExecution(ctx, c.WorkflowService(), nil, \"default\", workflow.Execution{\r\n\t\tID:    run.GetID(),\r\n\t\tRunID: run.GetRunID(),\r\n\t})\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"replay failed: %w\", err)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nvar activityWaiting = make(chan struct{})\r\nvar activityShouldComplete = make(chan struct{})\r\n\r\nfunc MyActivity(ctx context.Context) (string, error) {\r\n\tselect {\r\n\tcase <-activityWaiting:\r\n\tdefault:\r\n\t\tclose(activityWaiting)\r\n\t}\r\n\t<-activityShouldComplete\r\n\treturn \"some string\", nil\r\n}\r\n\r\nfunc MyWorkflow(ctx workflow.Context) error {\r\n\tvar updateResponse string\r\n\r\n\t// Set update handler that only completes after activity completes\r\n\terr := workflow.SetUpdateHandlerWithOptions(\r\n\t\tctx,\r\n\t\t\"MyUpdate\",\r\n\t\tfunc(ctx workflow.Context) (string, error) {\r\n\t\t\treturn updateResponse, nil\r\n\t\t},\r\n\t\tworkflow.UpdateHandlerOptions{\r\n\t\t\tValidator: func() error {\r\n\t\t\t\tif updateResponse == \"\" {\r\n\t\t\t\t\treturn fmt.Errorf(\"update response unset\")\r\n\t\t\t\t}\r\n\t\t\t\treturn nil\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed setting update handler: %w\", err)\r\n\t}\r\n\r\n\tctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{\r\n\t\tScheduleToCloseTimeout: 30 * time.Hour,\r\n\t})\r\n\tif err = workflow.ExecuteActivity(ctx, MyActivity).Get(ctx, &updateResponse); err != nil {\r\n\t\treturn fmt.Errorf(\"failed executing activity: %w\", err)\r\n\t}\r\n\r\n\t// Wait around\r\n\treturn workflow.Sleep(ctx, 30*time.Hour)\r\n}\r\n```\r\n</p></details>\r\n\r\nCan run with Temporal CLI upgraded to latest server `master` using:\r\n\r\n> temporal server start-dev --dynamic-config-value frontend.enableUpdateWorkflowExecution=true","closedAt":"2023-03-09T21:53:43Z","comments":[{"id":"IC_kwDODN1w685Wqqap","author":{"login":"mmcshane"},"authorAssociation":"CONTRIBUTOR","body":"First one is a bug. Didn't realize that when we replay history to catch a WF context up after a crash (or as here, an intentional worker exit), we don't actually use the replayer. The same inferMessages call that is used by the replayer can be used in this additional code path to suss out messages via readahead.\r\n\r\nMoving on to investigating the second.","createdAt":"2023-03-03T19:28:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-go/issues/1044#issuecomment-1454024361","viewerDidAuthor":false},{"id":"IC_kwDODN1w685W060I","author":{"login":"mmcshane"},"authorAssociation":"CONTRIBUTOR","body":"Second one is a consequence of not yet having retry for speculative tasks. The first update goes into the sticky queue for the first incarnation of the workflow worker. Once the worker starts with a different sticky queue, there is no upstream retry on the WFT to re-send it. Disabling sticky queues yields the expected execution*.\r\n\r\n\\* Actually it triggers a different bug, but with _that_ bug fixed we see the expected execution","createdAt":"2023-03-06T18:22:48Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-go/issues/1044#issuecomment-1456712968","viewerDidAuthor":false},{"id":"IC_kwDODN1w685XMbfi","author":{"login":"mmcshane"},"authorAssociation":"CONTRIBUTOR","body":"Closed with #1055 \r\n\r\nRelated is #1057 and https://github.com/temporalio/temporal/issues/4018 ","createdAt":"2023-03-09T21:53:36Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-go/issues/1044#issuecomment-1462876130","viewerDidAuthor":false}],"createdAt":"2023-02-16T22:41:13Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDg2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1044,"reactionGroups":[],"state":"CLOSED","title":"SDK updates not being properly run","updatedAt":"2023-03-09T21:53:44Z","url":"https://github.com/temporalio/sdk-go/issues/1044"}
