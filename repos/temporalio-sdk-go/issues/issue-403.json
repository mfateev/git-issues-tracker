{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNTc0Mg==","is_bot":false,"login":"esdrasbeleza","name":"Esdras Beleza"},"body":"(Moving https://github.com/temporalio/temporal/issues/1453 here, as I think I created it in the wrong place)\r\n\r\n## Expected Behavior\r\n\r\nIf an activity returns an error from some custom error from my system, it's wrapped and I can check it using `errors.Is`.\r\n\r\n## Actual Behavior\r\n\r\nMy error message is wrapped there, but I can't compare/check it.\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n```golang\r\nvar ErrNotFound = errors.New(\"not found!\")\r\n\r\nfunc TestWorkflowTestSuite(t *testing.T) {\r\n\tsuite.Run(t, new(WorkflowTestSuite))\r\n}\r\n\r\ntype WorkflowTestSuite struct {\r\n\tsuite.Suite\r\n\ttestsuite.WorkflowTestSuite\r\n\tenv *testsuite.TestWorkflowEnvironment\r\n}\r\n\r\nfunc (s *WorkflowTestSuite) SetupTest() {\r\n\ts.env = s.NewTestWorkflowEnvironment()\r\n}\r\n\r\nfunc (s *WorkflowTestSuite) TearDownTestSuite() {\r\n\ts.env.AssertExpectations(s.T())\r\n}\r\n\r\nfunc (s *WorkflowTestSuite) Test_WorkflowErrorHandling() {\r\n\tactivity := func(number int) error {\r\n\t\treturn fmt.Errorf(\"error: %w\", ErrNotFound)\r\n\t}\r\n\ts.env.RegisterActivity(activity)\r\n\r\n\tworkflow := func(ctx workflow.Context, number int) error {\r\n\t\tctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{\r\n\t\t\tStartToCloseTimeout: time.Minute,\r\n\t\t\tRetryPolicy: &temporal.RetryPolicy{\r\n\t\t\t\tMaximumAttempts:    3,\r\n\t\t\t\tBackoffCoefficient: 2,\r\n\t\t\t},\r\n\t\t})\r\n\r\n\t\tif err := workflow.ExecuteActivity(ctx, activity, number).Get(ctx, nil); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\treturn nil\r\n\t}\r\n\ts.env.RegisterWorkflow(workflow)\r\n\ts.env.ExecuteWorkflow(workflow, 123)\r\n\r\n\ts.True(s.env.IsWorkflowCompleted())\r\n\terr := s.env.GetWorkflowError()\r\n\ts.ErrorIs(err, ErrNotFound)\r\n}\r\n```\r\n\r\nThe result will be:\r\n\r\n```\r\nError:      \tTarget error should be in err chain:\r\n                    expected: \"not found!\"\r\n                    in chain: \"workflow execution error (type: func2, workflowID: default-test-workflow-id, runID: default-test-run-id): activity error (type: func1, scheduledEventID: 0, startedEventID: 0, identity: ): error: not found! (type: wrapError, retryable: true): not found!\"\r\n                        \"activity error (type: func1, scheduledEventID: 0, startedEventID: 0, identity: ): error: not found! (type: wrapError, retryable: true): not found!\"\r\n                        \"error: not found! (type: wrapError, retryable: true): not found!\"\r\n                        \"not found!\"\r\n```\r\n\r\n## Specifications\r\n\r\n  - Version: v1.5.0; 1.6.0\r\n  - Platform: macOS\r\n","closedAt":"2021-09-08T21:46:22Z","comments":[{"id":"MDEyOklzc3VlQ29tbWVudDgyOTYyMzM3NQ==","author":{"login":"mfateev"},"authorAssociation":"MEMBER","body":"TLDR; This is by design. \r\n\r\nThe reason is that the process that called an activity and the process that implements the activity are frequently not the same. The workflow process, the activity implementation, and the process that initiated workflow can be even in different languages. For example in Go, Java, PHP, Typescript. \r\n\r\nSo it not really possible to return a Go error across process boundaries. That's why any error which is not explicitly created as ApplicationError is converted to an ApplicationError. The error message becomes the `ApplicationError` message and the type of the original error becomes the `ApplicationError` type.\r\n\r\nThe following unit test passes:\r\n```go\r\nvar ErrNotFound = errors.New(\"not found!\")\r\n\r\nfunc TestWorkflowTestSuite(t *testing.T) {\r\n\tsuite.Run(t, new(WorkflowTestSuite))\r\n}\r\n\r\ntype WorkflowTestSuite struct {\r\n\tsuite.Suite\r\n\ttestsuite.WorkflowTestSuite\r\n\tenv *testsuite.TestWorkflowEnvironment\r\n}\r\n\r\nfunc (s *WorkflowTestSuite) SetupTest() {\r\n\ts.env = s.NewTestWorkflowEnvironment()\r\n}\r\n\r\nfunc (s *WorkflowTestSuite) TearDownTestSuite() {\r\n\ts.env.AssertExpectations(s.T())\r\n}\r\n\r\nfunc (s *WorkflowTestSuite) Test_WorkflowErrorHandling() {\r\n\tactivity := func(number int) error {\r\n\t\treturn fmt.Errorf(\"error: %w\", ErrNotFound)\r\n\t}\r\n\ts.env.RegisterActivity(activity)\r\n\r\n\tworkflow := func(ctx workflow.Context, number int) error {\r\n\t\tctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{\r\n\t\t\tStartToCloseTimeout: time.Minute,\r\n\t\t\tRetryPolicy: &temporal.RetryPolicy{\r\n\t\t\t\tMaximumAttempts:    3,\r\n\t\t\t\tBackoffCoefficient: 2,\r\n\t\t\t},\r\n\t\t})\r\n\r\n\t\tif err := workflow.ExecuteActivity(ctx, activity, number).Get(ctx, nil); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\treturn nil\r\n\t}\r\n\ts.env.RegisterWorkflow(workflow)\r\n\ts.env.ExecuteWorkflow(workflow, 123)\r\n\r\n\ts.True(s.env.IsWorkflowCompleted())\r\n\terr := s.env.GetWorkflowError()\r\n\tvar appErr *temporal.ApplicationError\r\n\ts.ErrorAs(err, &appErr)\r\n\ts.Equal(ErrNotFound.Error(), appErr.Unwrap().Error())\r\n}\r\n```\r\nIf you really want full control over error return ApplicationError from an activity. It also allows adding any serializable structure as details to it. Use [NewApplicationError](https://github.com/temporalio/sdk-go/blob/a39bbe82b2bab1281d24d7f18a93a9813e0e622b/temporal/error.go#L157) to create one.","createdAt":"2021-04-29T21:59:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/403#issuecomment-829623375","viewerDidAuthor":true},{"id":"MDEyOklzc3VlQ29tbWVudDg1MzkxNDczMg==","author":{"login":"daveworth"},"authorAssociation":"NONE","body":"Adding a note here after a conversation in the [Temporal Slack #go-sdk channel](https://temporalio.slack.com/archives/CTDTU3J4T/p1622670551047200).  In addition to the issue raised here, though by design, the documentation both on the website and in the code imply three different methods for getting the original error, none of which are implemented:\r\n\r\n1. The documentation on [Go Error Handling](https://docs.temporal.io/docs/go/error-handling/) states that there is an `err.OriginalType()` method which can be used to get the original error either as a string or as an actual error type.\r\n2. The code comments in `internal/error.go` also have two different documented methods in the same block:  [here](https://github.com/temporalio/sdk-go/blob/master/internal/error.go#L50) it states that there is `err.GetOriginalType()` while [here](https://github.com/temporalio/sdk-go/blob/master/internal/error.go#L78) it states that there is `err.Type()`. The latter _does_ exist and returns a string.\r\n\r\nIn general I wonder if a documentation improvement may be in order to capture the contents of this issue and make the calls more consistent in their usage in those three places?\r\n\r\nThank you!","createdAt":"2021-06-03T14:30:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":3}}],"url":"https://github.com/temporalio/sdk-go/issues/403#issuecomment-853914732","viewerDidAuthor":false},{"id":"IC_kwDODN1w6842Gh6a","author":{"login":"mfateev"},"authorAssociation":"MEMBER","body":"We certainly need to add `Is` method to all Temporal returned errors. For example, the following code doesn't work:\r\n```\r\n\ts.True(errors.Is(workflowErr, &temporal.CanceledError{})\r\n```\r\nas `CanceledError` doesn't implement the `Is` method.","createdAt":"2021-08-28T19:53:30Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/403#issuecomment-907681434","viewerDidAuthor":true},{"id":"IC_kwDODN1w6842nXQ0","author":{"login":"alexshtin"},"authorAssociation":"CONTRIBUTOR","body":"It doesn't work and it shouldn't. `errors.Is` is equality function, i.e. it checks if returned error chain contains exactly the same error object. And by default it compares pointers which doesn't work in our case at all, because we reconstruct errors every time they cross process boundaries. We can override `Is` method for our errors, but it should do deep compare of every field, not only type assertion because empty `CanceledError` and `CanceledError` with details are not equal. And `ApplicationError` with different message or `errType` are also not the same and checking them with `errors.Is` should return false.\r\n\r\nThere is `errors.As` also which works as type assertion. So if you want to check if `workflowErr` contains any`CanceledError` in error chain you should do:\r\n```go\r\nvar canceledErr *temporal.CanceledError\r\ns.True(errors.As(workflowErr, &canceledErr))\r\n```\r\nI agree, this is little bit cumbersome but it is what it is in the Go world. And this perfectly works with all Temporal errors because they all has `Unwrap` method.\r\n","createdAt":"2021-09-09T17:19:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/temporalio/sdk-go/issues/403#issuecomment-916288564","viewerDidAuthor":false}],"createdAt":"2021-04-12T15:05:50Z","labels":[{"id":"MDU6TGFiZWwyMDUzODEzNTY0","name":"potential-bug","description":"","color":"90c109"}],"milestone":null,"number":403,"reactionGroups":[],"state":"CLOSED","title":"Can't use `errors.Is` to check a returned error","updatedAt":"2021-09-09T17:21:35Z","url":"https://github.com/temporalio/sdk-go/issues/403"}
