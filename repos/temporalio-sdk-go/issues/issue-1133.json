{"assignees":[],"author":{"id":"MDQ6VXNlcjUyODU4NDk=","is_bot":false,"login":"maxtwardowski","name":"Max Twardowski"},"body":"A workflow with two timers: one in its root scope and one inside of a coroutine (`workflow.Go(...)`) makes the workflow fail with a `WorkflowTaskFailed` event and a `Potential deadlock detected: workflow goroutine \"2\" didn't yield for over a second` error message.\r\n\r\n## Expected Behavior\r\nI expect the workflow to behave just like its \"plain Go code\" equivalent in the snippet below:\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tgo func() {\r\n\t\tt := time.NewTicker(time.Second * 3) // coroutine ticker\r\n\t\tfor {\r\n\t\t\tselect {\r\n\t\t\tcase <-t.C:\r\n\t\t\t\tlog.Println(\"gofunc tick\")\r\n\t\t\t}\r\n\t\t}\r\n\t}()\r\n\r\n\tt := time.NewTicker(time.Second * 10) // main scope ticker\r\n\tfor i := 0; i < 1000; i++ {\r\n\t\tselect {\r\n\t\tcase <-t.C:\r\n\t\t\tlog.Println(\"main tick\")\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## Actual Behavior\r\nThe workflow execution fails with a deadlock error\r\n\r\n## Steps to Reproduce the Problem\r\n1. Execute the workflow implemented in the snippet below:\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\t\"sync\"\r\n\t\"time\"\r\n\r\n\t\"go.temporal.io/sdk/workflow\"\r\n)\r\n\r\nfunc TestWorkflow(ctx workflow.Context) error {\r\n\tworkflow.Go(ctx, func(ctx workflow.Context) {\r\n\t\tfor {\r\n\t\t\tsel := workflow.NewSelector(ctx)\r\n\t\t\tt := workflow.NewTimer(ctx, 10*time.Second) // coroutine ticker\r\n\t\t\tsel.AddFuture(t, func(f workflow.Future) {\r\n\t\t\t\tlog.Println(\"coroutine tick\")\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\r\n\tfor i := 0; i < 1000; i++ {\r\n\t\tt := workflow.NewTimer(ctx, 30*time.Second) // main scope ticker\r\n\t\tif err := t.Get(ctx, nil); err != nil {\r\n\t\t\tlog.Println(\"ERROR\", err.Error())\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tlog.Println(\"main scope tick\")\r\n\t}\r\n\r\n\treturn workflow.NewContinueAsNewError(ctx, ExecuteScheduledOperations)\r\n}\r\n```\r\n2. Wait a bit, note that none of the `log.Println(...)` logs are present in the output and observe the following error (I used [temporalio/ui](https://github.com/temporalio/ui)):\r\n```json\r\n{\r\n  \"message\": \"Potential deadlock detected: workflow goroutine \\\"2\\\" didn't yield for over a second\",\r\n  \"source\": \"GoSDK\",\r\n  \"stackTrace\": \"process event for wf-interactive [panic]:\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*coroutineState).call(0xc0007f8ff0, 0x3b9aca00)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:925 +0x19e\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked(0xc0007f8af0, 0x1e7c580?)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:1014 +0x1a5\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.executeDispatcher({0x2762ce8, 0xc0004fc300}, {0x27660c0, 0xc0007f8af0}, 0x0?)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:602 +0x9f\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted(0xc000142400?, 0xc000142100?)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:575 +0x32\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc0004f7008, 0xc000735600, 0xd8?, 0x0)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_event_handlers.go:815 +0x203\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0006143f0, 0xc0005e6420)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:878 +0xca8\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc0004b0630, 0xc0005e6420, 0xc0004f2c00)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:727 +0x485\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc0003488f0, 0xc0005e6420)\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:284 +0x2cd\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc0003488f0, {0x1e31ec0?, 0xc0005e6420?})\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:255 +0x6c\\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc00060c3c0, {0x1e31a80?, 0xc000429600})\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:398 +0x167\\ncreated by github.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher\\n\\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:302 +0xb5\",\r\n  \"encodedAttributes\": null,\r\n  \"cause\": null,\r\n  \"applicationFailureInfo\": {\r\n    \"type\": \"PanicError\",\r\n    \"nonRetryable\": true,\r\n    \"details\": null\r\n  }\r\n}\r\n```\r\n\r\n![image](https://github.com/temporalio/temporal/assets/5285849/0e77bb12-d556-41d9-8252-edfbf42321f8)\r\n\r\n\r\n## Specifications\r\n\r\n  - Version: 1.20.3.2 (also tested on 1.19.0)\r\n  - Platform: Ubuntu 22.04.2 LTS (x86-64)\r\n","closedAt":"2023-06-11T18:00:50Z","comments":[{"id":"IC_kwDODN1w685egJjA","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Looking at your workflow code I would expect this to deadlock. \r\n\r\nYour  workflow code is not equivalent to the Go code above because in your workflow code you never actually block on the selector. You just keep adding futures into the selector and never actually wait on any.\r\n\r\nI'd recommend you have a look at  our [documentation ](https://legacy-documentation-sdks.temporal.io/go/selectors#full-api-example) on  the `selector`. I'll note there also isn't a benefit to using a selector on only one future.\r\n\r\n\r\n","createdAt":"2023-06-10T05:01:47Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1133#issuecomment-1585486016","viewerDidAuthor":false},{"id":"IC_kwDODN1w685egJoH","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"To wait until a future is ready you need to call `Select`, See this take from the documentation I linked above.\r\n```\r\n    // API Example: block until the next Future is ready to run\r\n    // important! none of the deferred code runs until you call selector.Select\r\n    selector.Select(ctx)\r\n```","createdAt":"2023-06-10T05:03:31Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1133#issuecomment-1585486343","viewerDidAuthor":false},{"id":"IC_kwDODN1w685ejHqg","author":{"login":"maxtwardowski"},"authorAssociation":"NONE","body":"@Quinn-With-Two-Ns Right, I forgot about the `.Select(...)` call... Closing the issue, the workflow behaves as expected.","createdAt":"2023-06-11T18:00:50Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-go/issues/1133#issuecomment-1586264736","viewerDidAuthor":false}],"createdAt":"2023-06-09T14:01:29Z","labels":[{"id":"MDU6TGFiZWwyMDUzODEzNTY0","name":"potential-bug","description":"","color":"90c109"}],"milestone":null,"number":1133,"reactionGroups":[],"state":"CLOSED","title":"Workflow deadlock when having a timer in the root scope and a timer in a coroutine","updatedAt":"2023-06-11T18:00:50Z","url":"https://github.com/temporalio/sdk-go/issues/1133"}
