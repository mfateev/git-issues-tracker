{"assignees":[],"author":{"id":"MDQ6VXNlcjE0NjM2MjI=","is_bot":false,"login":"mfateev","name":"Maxim Fateev"},"body":"**Is your feature request related to a problem? Please describe.**\r\nCurrently to guarantee that every signal is delivered all channels have to be drained using ReadAsync before completing a workflow. This leads to code that looks like:\r\n```go\r\ntype channelConfig struct {\r\n  channel workflow.ReceiveChannel\r\n  val interface{}\r\n  handler func()  // do something with val\r\n}\r\n\r\nchannels := []*channelConfig{\r\n  {\r\n    channel: workflow.GetSignalChannel(...)\r\n    val: \"\",\r\n    handler func() {\r\n      // do something with val\r\n    },\r\n  },\r\n  // etc\r\n}\r\n\r\ns := workflow.NewSelector(ctx)\r\nfor _, cc := range channels {\r\n  s.AddReceive(cc.channel, func (c workflow.ReceiveChannel, _ bool) {\r\n    c.Receive(ctx, &cc.val)\r\n    cc.handler()\r\n  })\r\n}\r\n\r\nfor keepGoing {\r\n  s.Select(ctx)\r\n  // not safe to return here\r\n}\r\n\r\n// Now I want to return but first I need to make sure that no signals are pending\r\ncanReturn := false\r\nfor !canReturn {\r\n  canReturn = true\r\n  for _, cc := range channels {\r\n    if ok := c.ReceiveAsync(&cc.val); ok {\r\n      canReturn = false\r\n      cc.handler()\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Describe the solution you'd like**\r\nAdd Selector.HasPending method that returns true if Selector.Select is not going to block if called. This would simplify the above code to:\r\n```go\r\ntype channelConfig struct {\r\n  channel workflow.ReceiveChannel\r\n  val interface{}\r\n  handler func()  // do something with val\r\n}\r\n\r\nchannels := []*channelConfig{\r\n  {\r\n    channel: workflow.GetSignalChannel(...)\r\n    val: \"\",\r\n    handler func() {\r\n      // do something with val\r\n    },\r\n  },\r\n  // etc\r\n}\r\n\r\ns := workflow.NewSelector(ctx)\r\nfor _, cc := range channels {\r\n  s.AddReceive(cc.channel, func (c workflow.ReceiveChannel, _ bool) {\r\n    c.Receive(ctx, &cc.val)\r\n    cc.handler()\r\n  })\r\n}\r\n\r\nfor keepGoing || s.HasPending {\r\n  s.Select(ctx)\r\n}\r\n\r\n// safe complete workflow here\r\n```\r\n\r\n\r\n**Describe alternatives you've considered**\r\nAdd Channel.HasPending or ReceiveChannel.Peek. But it wouldn't help with Select and still require code complications.\r\n\r\n**Additional context**\r\nhttps://community.temporal.io/t/continueasnew-signals/1008/25","closedAt":"2020-12-29T00:15:50Z","comments":[],"createdAt":"2020-11-29T18:18:39Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzA3NDky","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":301,"reactionGroups":[],"state":"CLOSED","title":"Add Selector.HasPending","updatedAt":"2020-12-29T00:15:50Z","url":"https://github.com/temporalio/sdk-go/issues/301"}
