{
  "generatedAt": "2026-01-13T00:09:16.494Z",
  "totalCards": 824,
  "cards": [
    {
      "summary": "Anonymous functions used in activity registration cause alias collisions in the test environment, where multiple packages register activities with the same short function name (e.g., 'func1'), resulting in local activities being incorrectly routed to unrelated registered activity mocks and causing panics.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteLocalActivity",
        "RegisterActivityWithOptions"
      ],
      "components": [
        "test-workflow-environment",
        "activity-registry",
        "activity-alias-map",
        "mock-wrapper"
      ],
      "concepts": [
        "activity-aliasing",
        "function-naming",
        "anonymous-functions",
        "collision-detection",
        "test-mocking",
        "function-resolution"
      ],
      "severity": "high",
      "userImpact": "Tests using anonymous functions for activities fail with panics or incorrect mock invocations when multiple activities with the same short function name are registered.",
      "rootCause": "The activity alias registry uses short function names (e.g., 'func1') as keys instead of full function names, causing collisions when multiple packages define anonymous functions with identical short names.",
      "proposedFix": "Option 1: Use full function names as alias keys instead of short names. Option 2: Skip alias lookup for anonymous functions in test environment by detecting them via runtime inspection.",
      "workaround": "Use named functions instead of anonymous functions when registering activities in tests, as named functions have unique full names that won't collide.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1341
      ],
      "keyQuote": "We strongly discourage usage of anonymous functions for local activities... their name is generated by the Go runtime and is not deterministic.",
      "number": 2141,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:29:07.792Z"
    },
    {
      "summary": "OpenTelemetry metrics handler incorrectly implements Counter metrics as UpDownCounter instead of Counter, causing them to be exposed as Gauge instead of Counter with _total suffix in Prometheus, violating the OpenMetrics specification.",
      "category": "bug",
      "subcategory": "opentelemetry-metrics",
      "apis": [],
      "components": [
        "opentelemetry-handler",
        "metrics-handler",
        "prometheus-exporter"
      ],
      "concepts": [
        "metrics",
        "counter",
        "opentelemetry",
        "prometheus",
        "monotonic",
        "gauge"
      ],
      "severity": "medium",
      "userImpact": "Users exporting metrics via OpenTelemetry get incorrect metric types that don't comply with Prometheus specifications, breaking metric collection and monitoring pipelines.",
      "rootCause": "OpenTelemetry handler uses Int64UpDownCounter for Counter metrics instead of Int64Counter, and the non-monotonic UpDownCounter is converted to Gauge by the Prometheus exporter.",
      "proposedFix": "Change the Counter method in handler to use m.meter.Int64Counter(name) instead of m.meter.Int64UpDownCounter(name).",
      "workaround": "Apply a local patch changing UpDownCounter to Counter in the OpenTelemetry handler.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1137
      ],
      "keyQuote": "OpenTelemetry handler implements Counter as m.meter.Int64UpDownCounter(name). In opentelemetry-go prometheus exporter, it explicitly checks whether the type Sum is monotonic or not. If it is not - then it is Gauge value.",
      "number": 2140,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:29:05.740Z"
    },
    {
      "summary": "User seeks clarification on understanding and interpreting the Worker slots gauge in DataDog metrics, specifically what the gauge value represents and how MaxConcurrentWorkflowTaskExecutionSize affects workflow throughput.",
      "category": "question",
      "subcategory": "worker-performance",
      "apis": [],
      "components": [
        "worker",
        "metrics",
        "workflow-executor"
      ],
      "concepts": [
        "worker-slots",
        "concurrent-execution",
        "throughput",
        "performance-tuning",
        "metrics-dashboard"
      ],
      "severity": "low",
      "userImpact": "Users are confused about interpreting worker metrics and optimizing workflow concurrency, leading to uncertainty about proper configuration.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue closed as support question; user directed to documentation and Slack support channel per project policy.",
      "related": [],
      "keyQuote": "Worker slots is the number of concurrently running workflow tasks at that point in time. The max value it can be is `MaxConcurrentWorkflowTaskExecutionSize`.",
      "number": 2136,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:49.872Z"
    },
    {
      "summary": "Activity worker uses MaxHeartbeatThrottleInterval to control both heartbeat throttling and RPC timeout, but these concerns should be independent. Users need configurable minRPCTimeout and the ability to manually retry heartbeats on network errors without triggering activity cancellation.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "RecordHeartbeat"
      ],
      "components": [
        "activity-worker",
        "heartbeat-handler",
        "task-handlers",
        "rpc-timeout"
      ],
      "concepts": [
        "heartbeat",
        "timeout",
        "retry",
        "network-error",
        "activity-cancellation",
        "context-deadline"
      ],
      "severity": "medium",
      "userImpact": "Activity workers cannot properly handle slow networks or long RPC timeouts for heartbeats without either disabling throttling globally or having activities incorrectly canceled on transient failures.",
      "rootCause": "MaxHeartbeatThrottleInterval is conflated with RPC timeout; context deadline exceeded from RPC timeouts immediately marks activity as canceled without retry opportunity.",
      "proposedFix": "Add configurable minRPCTimeout parameter for activity worker separate from throttling controls; allow manual retry of heartbeats on network errors without triggering activity cancellation.",
      "workaround": "Set MaxHeartbeatThrottleInterval to a longer duration than expected network latency, though this reduces intended throttling benefits.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        660,
        859,
        863
      ],
      "keyQuote": "Configurable minRPCTimeout for activity worker. Allow retry heartbeat on network error.",
      "number": 2131,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:54.858Z"
    },
    {
      "summary": "User requests an environment variable `TEMPORAL_LOG_LEVEL` to control SDK log level without modifying code. SDK maintainer clarified that the SDK cannot control user-provided loggers and users should implement their own environment variable handling.",
      "category": "feature",
      "subcategory": "logging-configuration",
      "apis": [],
      "components": [
        "logger",
        "worker-configuration"
      ],
      "concepts": [
        "logging",
        "environment-variables",
        "log-level",
        "configuration",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Users must manually code log level configuration instead of using a simple environment variable.",
      "rootCause": "The SDK design delegates logger management to users and cannot control log levels of external logger implementations.",
      "proposedFix": "Add support for a TEMPORAL_LOG_LEVEL environment variable to configure SDK logging.",
      "workaround": "Users can implement their own environment variable to control their logger's log level as shown in the SDK README example.",
      "resolution": "wontfix",
      "resolutionDetails": "SDK maintainers determined this is not a change they will make, as logger configuration is the user's responsibility.",
      "related": [],
      "keyQuote": "The SDK is not able to set the log level of the logger that users provide.",
      "number": 2130,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:52.367Z"
    },
    {
      "summary": "Request to support executing activities outside of workflow context. Workers and clients need new capabilities to start, manage, and retrieve activity results without requiring a workflow, pending new server APIs.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "client",
        "activity-manager"
      ],
      "concepts": [
        "activity-execution",
        "context-independence",
        "server-apis",
        "activity-lifecycle",
        "result-retrieval"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to execute activities directly without workflow context, enabling new use cases and simplified activity management.",
      "rootCause": null,
      "proposedFix": "Implement worker support for running activities outside workflow context and client support for new server APIs for activity lifecycle management.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        640
      ],
      "keyQuote": "Allow executing activities without a workflow. The clients must support the new (upcoming) server APIs for starting, managing and getting results of activities.",
      "number": 2124,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:35.231Z"
    },
    {
      "summary": "Feature request to enable parallel execution of payload visitors in the api-go proxy with configurable concurrency control, while maintaining backward compatibility with sequential processing as the default.",
      "category": "feature",
      "subcategory": "proxy-payload-visitor",
      "apis": [],
      "components": [
        "proxy",
        "payload-visitor",
        "concurrency-control"
      ],
      "concepts": [
        "parallelization",
        "concurrency",
        "performance",
        "payload-processing",
        "visitor-pattern",
        "throughput"
      ],
      "severity": "medium",
      "userImpact": "Users with slow payload visitors can improve performance by enabling parallel execution with configurable concurrency limits.",
      "rootCause": null,
      "proposedFix": "Add an option to the proxy visitor configuration to enable parallelization with a user-configurable max concurrency factor parameter.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When visiting payloads in the proxy my visitor is slow and would benefit from being run in parellel",
      "number": 2123,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:38.868Z"
    },
    {
      "summary": "Request to set GrpcMessageTooLarge as a failure_reason for workflow task failed metric in the Go SDK, referenced from a features issue.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "grpc",
        "workflow-task"
      ],
      "concepts": [
        "grpc",
        "message-size",
        "failure-reason",
        "observability",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users lack visibility into when workflow tasks fail due to message size limits in their metrics and monitoring systems.",
      "rootCause": null,
      "proposedFix": "Add GrpcMessageTooLarge as a supported failure_reason for the workflow task failed metric",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed to support GrpcMessageTooLarge failure reason in metrics",
      "related": [
        695
      ],
      "keyQuote": "Set GrpcMessageTooLarge as failure_reason for workflow task failed metric",
      "number": 2114,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:36.929Z"
    },
    {
      "summary": "Workflow completion and continue-as-new counters should be incremented only after successful reporting to the server, not before. This ensures accurate metrics and consistency with server state.",
      "category": "other",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "workflow-executor",
        "metrics",
        "reporting"
      ],
      "concepts": [
        "counters",
        "metrics",
        "server-reporting",
        "workflow-lifecycle",
        "accuracy",
        "state-synchronization"
      ],
      "severity": "medium",
      "userImpact": "Users may see inaccurate workflow completion metrics if server reporting fails, leading to misleading observability data.",
      "rootCause": "Counters are being logged before confirming successful server reporting, causing potential inconsistency between local metrics and actual workflow state.",
      "proposedFix": "Move counter logging to occur after successful server reporting in the workflow completion and continue-as-new paths.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation updated to log counters after successful server reporting for both workflow_completed and workflow_continue_as_new events.",
      "related": [
        222
      ],
      "keyQuote": "workflow_completed and workflow_continue_as_new counters should be logged after a successful reporting to the server",
      "number": 2111,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:23.524Z"
    },
    {
      "summary": "The MutableSideEffect function in the Go SDK's test framework ignores the custom comparison function (cmp), always updating the value instead of respecting the comparison logic. This causes test workflows to behave differently than production.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "MutableSideEffect"
      ],
      "components": [
        "test-suite",
        "workflow-testsuite",
        "side-effect"
      ],
      "concepts": [
        "mutable-side-effect",
        "comparison-function",
        "value-update",
        "test-behavior",
        "consistency"
      ],
      "severity": "medium",
      "userImpact": "Tests using MutableSideEffect with custom comparison functions produce incorrect results, failing to detect when values should remain unchanged.",
      "rootCause": "The cmp parameter is ignored in the test framework implementation at internal_workflow_testsuite.go#L2875",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "In test framework MutableSideEffect with cmp `func(a, b any) bool { return true }` should not update value, even if value is different",
      "number": 2109,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:22.056Z"
    },
    {
      "summary": "Users request the ability to override the Worker Deployment Version when invoking a Child Workflow, similar to the functionality available when creating a Workflow from a client. This feature is needed for pre-deployment testing scenarios.",
      "category": "feature",
      "subcategory": "child-workflow",
      "apis": [
        "ChildWorkflowOptions",
        "StartChildWorkflowExecution"
      ],
      "components": [
        "child-workflow",
        "worker",
        "deployment-version"
      ],
      "concepts": [
        "version-override",
        "pre-deployment-testing",
        "workflow-invocation",
        "deployment-strategy",
        "child-workflow-options"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test pre-deployment scenarios with child workflows without being able to override the deployment version.",
      "rootCause": null,
      "proposedFix": "Add version override capability to child workflow invocation options, matching the behavior available in client-side workflow creation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to allow version override on child workflow invocation",
      "related": [
        694
      ],
      "keyQuote": "Users want to override the target version on a workflow, especially when doing pre-deployment testing.",
      "number": 2108,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:24.466Z"
    },
    {
      "summary": "Test framework panics intermittently when executing workflows with 500 child workflow executions in a unit test, causing flaky test failures. The panic occurs in the internal workflow test suite callback processing.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "ExecuteWorkflow",
        "WithChildOptions"
      ],
      "components": [
        "test-suite",
        "workflow-executor",
        "callback-handler",
        "test-environment"
      ],
      "concepts": [
        "concurrency",
        "child-workflows",
        "test-flakiness",
        "panic-recovery",
        "callback-processing",
        "unit-testing"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably run unit tests for workflows that execute multiple child workflows, causing intermittent test failures and blocking CI/CD pipelines.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "related": [],
      "keyQuote": "Test panics when executing env.ExecuteWorkflow() - Tried with v1.36.0 SDK version as well but still the test is flaky and fails intermittently.",
      "resolution": null,
      "resolutionDetails": null,
      "number": 2107,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:05.656Z"
    },
    {
      "summary": "Poller autoscaling fails to increase the number of concurrent pollers beyond InitialNumberOfPollers even when computational resources, worker slots, and task queue backlog are available. This prevents workers from scaling up to handle increased load.",
      "category": "bug",
      "subcategory": "poller-autoscaling",
      "apis": [
        "NewPollerBehaviorAutoscaling",
        "PollerBehaviorAutoscalingOptions"
      ],
      "components": [
        "worker",
        "poller",
        "autoscaling",
        "task-queue"
      ],
      "concepts": [
        "autoscaling",
        "concurrency",
        "resource-utilization",
        "backlog",
        "throughput",
        "worker-slots"
      ],
      "severity": "high",
      "userImpact": "Workers cannot automatically scale up their poller count to match high task volumes, resulting in poor latency and throughput despite available resources.",
      "rootCause": "The autoscaling poller implementation has a bug preventing it from increasing the number of pollers beyond the initial count, despite having sufficient resources and backlog.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "An autoscaling poller is incapable of running more than InitialNumberOfPollers concurrent pollers.",
      "number": 2106,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:06.754Z"
    },
    {
      "summary": "TraceID and SpanID fields in OpenTelemetry logs are printed as byte arrays instead of human-readable strings due to missing String() conversion in the logger.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "opentelemetry-tracing",
        "logger",
        "tracing-interceptor"
      ],
      "concepts": [
        "logging",
        "opentelemetry",
        "tracing",
        "slog",
        "string-conversion",
        "cosmetic-formatting"
      ],
      "severity": "low",
      "userImpact": "Logs display unreadable byte arrays for TraceID and SpanID instead of formatted trace identifiers, making log inspection difficult.",
      "rootCause": "TraceID and SpanID values are not converted to string using String() method before logging, which is expected by Go loggers including slog and the default log package.",
      "proposedFix": "Convert TraceID and SpanID to strings using their String() methods in the logger at lines 225-228 of tracing_interceptor.go.",
      "workaround": "Use the otelslog bridge from opentelemetry-go-contrib which properly handles OTEL types with slog.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "the logger in lines 225-228 has a bug where the TraceID and SpanID are not converted to string which is causing a cosmetic bug when log gets printed, we see the byte array instead",
      "number": 2103,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:28:10.268Z"
    },
    {
      "summary": "Feature request to add a method on the WorkflowRun interface to retrieve the input that started a workflow execution. Currently, WorkflowRun only supports getting the result, not the input parameters.",
      "category": "feature",
      "subcategory": "workflow-api",
      "apis": [
        "WorkflowRun",
        "Describe"
      ],
      "components": [
        "workflow-client",
        "workflow-run-interface"
      ],
      "concepts": [
        "workflow-input",
        "workflow-execution",
        "history",
        "metadata-retrieval"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily retrieve workflow input through the WorkflowRun interface and must manually parse history events as a workaround.",
      "rootCause": "The WorkflowRun interface lacks a method to access input parameters; this information is available in the history but not exposed through the public API.",
      "proposedFix": "Add a method to WorkflowRun interface to get input, with server-side support tracked in temporalio/temporal#8608 and planned for the Describe RPC.",
      "workaround": "Fetch the workflow history and examine the first event to extract the input parameters.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by adding input retrieval capability through the Describe RPC on the server side (temporalio/temporal#8608), making it available on the WorkflowRun interface.",
      "related": [
        8608
      ],
      "keyQuote": "When the server issue is resolved it will be available on `Describe`. For now the only solution is to look at history.",
      "number": 2102,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:53.917Z"
    },
    {
      "summary": "User requests an option for WorkflowRun.GetWithOptions() to populate the result value even when the workflow fails with an error, rather than having to choose between getting the error or the result.",
      "category": "feature",
      "subcategory": "workflow-client",
      "apis": [
        "WorkflowRun.Get",
        "WorkflowRun.GetWithOptions"
      ],
      "components": [
        "workflow-client",
        "error-handling"
      ],
      "concepts": [
        "error-handling",
        "result-retrieval",
        "failed-workflows",
        "error-details"
      ],
      "severity": "low",
      "userImpact": "Users cannot access workflow result values when a workflow fails, forcing them to choose between error details or result data.",
      "rootCause": "Current API design returns either error or result, not both; the SDK design choice of 'Error always wins' prevents accessing result data on failure.",
      "proposedFix": null,
      "workaround": "Add details to Application failure errors, create a custom Result type that encapsulates all needed info, or return both from workflow function (though only error is recorded).",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer explained current design where 'Error always wins' and suggested workarounds using error details or custom result types instead.",
      "related": [],
      "keyQuote": "Even though you're technically able to return both from your Go Workflow function, we don't record both, Error always wins.",
      "number": 2101,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:52.318Z"
    },
    {
      "summary": "Documentation request to add inline comments in ChildWorkflowOptions clarifying the default values for WorkflowIDReusePolicy and WorkflowIdConflictPolicy, as these defaults are not currently clear from reading the SDK code.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "ChildWorkflowOptions",
        "WorkflowIDReusePolicy",
        "WorkflowIdConflictPolicy"
      ],
      "components": [
        "workflow",
        "options",
        "documentation"
      ],
      "concepts": [
        "default-behavior",
        "code-comments",
        "api-clarity",
        "child-workflows",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Developers working with child workflows cannot easily determine default behavior without consulting external documentation or source code exploration.",
      "rootCause": null,
      "proposedFix": "Add inline comments to ChildWorkflowOptions in internal/workflow.go explaining the default WorkflowIDReusePolicy and WorkflowIdConflictPolicy values",
      "workaround": "Refer to external Temporal developer guide documentation",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add inline comments to make the default behavior clear",
      "number": 2098,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:50.556Z"
    },
    {
      "summary": "Feature request to add context parameter to MetricsHandler interface to enable OpenTelemetry exemplar support, allowing metrics to link directly to traces for improved observability and debugging.",
      "category": "feature",
      "subcategory": "observability-metrics",
      "apis": [],
      "components": [
        "metrics-handler",
        "opentelemetry-bridge",
        "task-handler",
        "worker"
      ],
      "concepts": [
        "exemplar",
        "opentelemetry",
        "context-propagation",
        "tracing",
        "observability",
        "prometheus",
        "grafana"
      ],
      "severity": "medium",
      "userImpact": "Users cannot link SDK metrics to traces via exemplars, requiring manual trace hunting instead of direct click-through from Grafana metric spikes.",
      "rootCause": "MetricsHandler interface lacks context parameter, forcing OpenTelemetry bridge to use context.Background() which cannot extract trace information for exemplar creation.",
      "proposedFix": "Add context parameter to CounterIface and other metric interfaces (e.g., Inc(ctx context.Context, value int64)), update all SDK metric calls to pass available context, ensuring backward compatibility via new method or type assertion.",
      "workaround": "Users can implement custom metrics in activity code with context passed explicitly to OpenTelemetry metric calls.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Without the context containing trace information, OpenTelemetry can't extract the trace_id and span_id needed to create the exemplar that links the metric to the trace.",
      "number": 2097,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:38.971Z"
    },
    {
      "summary": "Implement worker heartbeating functionality in the Go SDK by creating a background nexus worker to send periodic heartbeats, following the design patterns established in sdk-core.",
      "category": "feature",
      "subcategory": "worker-heartbeat",
      "apis": [],
      "components": [
        "worker",
        "nexus",
        "background-worker"
      ],
      "concepts": [
        "heartbeat",
        "worker-lifecycle",
        "background-task",
        "nexus",
        "health-monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to implement proper worker heartbeating to maintain activity connections and improve reliability of long-running workflows.",
      "rootCause": null,
      "proposedFix": "Design and implement a Go version of the sdk-core worker heartbeating implementation (PR #953 and #1038), likely involving a background nexus worker for sending periodic heartbeats.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Implement worker heartbeating, which is sent via a new background nexus worker.",
      "number": 2094,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:35.257Z"
    },
    {
      "summary": "Documentation for the envconfig package incorrectly references `[os.UserConfigDir]/temporal/temporal.toml` when it should be `[os.UserConfigDir]/temporalio/temporal.toml`. This path discrepancy in multiple places could mislead users on where to place configuration files.",
      "category": "docs",
      "subcategory": "documentation-accuracy",
      "apis": [],
      "components": [
        "envconfig",
        "documentation"
      ],
      "concepts": [
        "configuration",
        "file-path",
        "documentation-accuracy",
        "user-guidance"
      ],
      "severity": "low",
      "userImpact": "Users following the documentation may place configuration files in the wrong directory, causing the SDK to fail to locate the configuration.",
      "rootCause": "Documentation copy-paste error using 'temporal' instead of 'temporalio' in the directory path",
      "proposedFix": "Update all occurrences in envconfig package documentation to use `[os.UserConfigDir]/temporalio/temporal.toml`",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was corrected to use the proper directory path",
      "related": [],
      "keyQuote": "In multiple places in `envconfig` package, `[os.UserConfigDir]/temporal/temporal.toml` is mentioned, but it should be `[os.UserConfigDir]/temporalio/temporal.toml`.",
      "number": 2092,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:36.520Z"
    },
    {
      "summary": "Child workflows started in tests leak goroutines that don't terminate after the workflow completes, causing test frameworks like goleak to fail when verifying no goroutines are left running.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "NewTestWorkflowEnvironment"
      ],
      "components": [
        "test-environment",
        "child-workflow-executor",
        "goroutine-management"
      ],
      "concepts": [
        "goroutine-leak",
        "child-workflow",
        "test-cleanup",
        "resource-cleanup",
        "workflow-termination"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot write clean tests with goroutine leak detection enabled because child workflows leave lingering goroutines after completion.",
      "rootCause": "The `executeChildWorkflowWithDelay` function leaves a goroutine running that doesn't terminate when the child workflow completes.",
      "proposedFix": null,
      "workaround": null,
      "related": [],
      "keyQuote": "A go routine is left running from `executeChildWorkflowWithDelay` which doesn't seem to terminate.",
      "resolution": null,
      "resolutionDetails": null,
      "number": 2090,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:21.856Z"
    },
    {
      "summary": "Add resource tuner metrics for CPU and memory usage tracking in the Go SDK, matching the metrics available in Core and Java SDKs. These metrics help monitor resource slot usage and allocation during workflow execution.",
      "category": "feature",
      "subcategory": "metrics-observability",
      "apis": [],
      "components": [
        "metrics",
        "resource-tuner",
        "worker"
      ],
      "concepts": [
        "resource-management",
        "cpu-usage",
        "memory-usage",
        "observability",
        "metrics",
        "resource-slots",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently monitor CPU and memory resource slot usage in the Go SDK, limiting visibility into resource allocation and performance tuning.",
      "rootCause": null,
      "proposedFix": "Add CPU/memory usage metrics following the existing pattern from Core/Java implementations as documented in the Temporal SDK metrics reference.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resource tuner metrics were implemented to provide CPU and memory usage visibility matching Core and Java SDKs.",
      "related": [],
      "keyQuote": "The CPU/mem usage metrics that are present in Core/Java are absent here.",
      "number": 2089,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:23.144Z"
    },
    {
      "summary": "Implement a Plugin system for the Go SDK to enable users to self-serve creating integrations with Temporal Workflows, similar to the existing Python implementation.",
      "category": "feature",
      "subcategory": "plugin-system",
      "apis": [],
      "components": [
        "plugin-system",
        "sdk-core",
        "integration-framework"
      ],
      "concepts": [
        "extensibility",
        "integration",
        "self-service",
        "plugins",
        "customization"
      ],
      "severity": "medium",
      "userImpact": "Users can create custom integrations with Temporal Workflows without waiting for official SDK implementations.",
      "rootCause": null,
      "proposedFix": "Copy implementation approach from Python SDK plugin system",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Plugin system was implemented for the Go SDK based on the Python implementation",
      "related": [],
      "keyQuote": "Implement Plugins so that users can self-serve creating integrations with Temporal Workflows.",
      "number": 2086,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:19.756Z"
    },
    {
      "summary": "Add support for firstExecutionRunId parameter to cancel and terminate methods in the Go SDK, allowing users to target specific workflow execution chains.",
      "category": "feature",
      "subcategory": "workflow-lifecycle",
      "apis": [
        "CancelWorkflow",
        "TerminateWorkflow"
      ],
      "components": [
        "client",
        "workflow-service",
        "cancel-terminate"
      ],
      "concepts": [
        "workflow-execution",
        "execution-chain",
        "idempotency",
        "workflow-targeting",
        "lifecycle-management"
      ],
      "severity": "medium",
      "userImpact": "Users can now precisely target specific executions within a workflow chain when canceling or terminating, improving control over workflow execution lifecycle management.",
      "rootCause": null,
      "proposedFix": "Add cancelWithOptions and terminateWithOptions methods that accept an options struct containing firstExecutionRunId parameter.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "add methods like `cancelWithOptions` and `terminateWithOptions` that take an options struct to pass `firstExecutionRunId`",
      "number": 2085,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:02.740Z"
    },
    {
      "summary": "Side Effect markers in the UI lack identifiable information when multiple appear in quick succession. Users need static summary support for side effects and mutable side effects, similar to activities and local activities, to distinguish them without clicking.",
      "category": "feature",
      "subcategory": "ui-display",
      "apis": [],
      "components": [
        "side-effects",
        "ui",
        "workflow-history"
      ],
      "concepts": [
        "ui-display",
        "summary",
        "identifiability",
        "workflow-visualization",
        "side-effects"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily identify and distinguish between multiple side effects in the UI, requiring additional clicks to differentiate them.",
      "rootCause": null,
      "proposedFix": "Add support for static summary for side effect markers so the UI can display their summaries similar to activities and local activities.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented via PR #2129",
      "related": [
        2076,
        2129
      ],
      "keyQuote": "Support static summary for these items, then UI can be changed to display their summaries, similar to activities and local activities.",
      "number": 2084,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:06.831Z"
    },
    {
      "summary": "Port metrics enhancement from sdk-core to use normal task queue names for sticky task queue client metrics, improving metric consistency across Temporal SDKs.",
      "category": "other",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "task-queue",
        "client"
      ],
      "concepts": [
        "sticky-task-queue",
        "metrics-naming",
        "consistency",
        "monitoring"
      ],
      "severity": "low",
      "userImpact": "Users will see more consistent and meaningful task queue names in sticky task queue client metrics.",
      "rootCause": null,
      "proposedFix": "Port the metrics enhancement from sdk-core PR #1039 to improve sticky task queue metric naming",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Enhancement was ported from sdk-core/pull/1039",
      "related": [
        1039
      ],
      "keyQuote": "Port https://github.com/temporalio/sdk-core/pull/1039",
      "number": 2083,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:27:04.456Z"
    },
    {
      "summary": "SideEffect markers in workflow timelines are difficult to navigate when there are many in sequence, as users can only identify them by examining payloads. The request is to add naming capabilities to SideEffects for better timeline visibility, though the maintainer proposed using marker summaries instead.",
      "category": "feature",
      "subcategory": "workflow-timeline-visualization",
      "apis": [
        "SideEffect",
        "MutableSideEffect"
      ],
      "components": [
        "markers",
        "timeline-ui",
        "side-effect-executor"
      ],
      "concepts": [
        "workflow-debugging",
        "timeline-navigation",
        "marker-identification",
        "observability",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users with many sequential SideEffects struggle to identify which side effect performed which operation when reviewing workflow timelines.",
      "rootCause": "SideEffect markers lack identifying information (names or summaries) in the timeline, forcing users to decode functionality from serialized payloads.",
      "proposedFix": "Add SideEffectOptions with Name parameter to allow custom marker names, or alternatively add Summaries to markers for UI display similar to Activities/LocalActivities.",
      "workaround": "Manually inspect SideEffect payloads to determine which method was called; alternative approach using MutableSideEffect IDs but IDs are not shown in timeline.",
      "resolution": "fixed",
      "resolutionDetails": "Closed in favor of #2084, which proposes adding marker summaries rather than renaming capability.",
      "related": [
        2074,
        2084
      ],
      "keyQuote": "Add SideEffectOptions with Name parameter... overriding marker names in SDK is the cleanest solution.",
      "number": 2076,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:50.970Z"
    },
    {
      "summary": "Messages are being lost from workflow.NewChannel(ctx) when using selectors with the unblockSelectorSignal flag enabled. This regression was introduced in version 1.35.0 and affects the channel worker pattern.",
      "category": "bug",
      "subcategory": "channels-selectors",
      "apis": [
        "NewChannel",
        "NewSelector",
        "Send",
        "Receive",
        "Select"
      ],
      "components": [
        "channels",
        "selector",
        "workflow-runtime",
        "test-framework"
      ],
      "concepts": [
        "message-loss",
        "concurrency",
        "worker-pattern",
        "signal-handling",
        "synchronization"
      ],
      "severity": "high",
      "userImpact": "Users relying on workflow channels with selectors may experience lost messages, breaking concurrent processing patterns in their workflows.",
      "rootCause": "Bug introduced in PR #1762 in version 1.35.0 related to unblockSelectorSignal flag implementation",
      "proposedFix": null,
      "workaround": "Set unblockSelectorSignal to false to avoid the issue",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1762
      ],
      "keyQuote": "Messages are getting lost. This bug was introduced in 1.35.0, from #1762",
      "number": 2066,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:47.188Z"
    },
    {
      "summary": "NewTestActivityEnvironment no longer implements the worker.ActivityRegistry interface as of v1.35.0, breaking code that relied on this interface implementation. The root cause is adding a new method (RegisterDynamicActivity) to the public interface, which is a breaking change in Go.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "RegisterActivity",
        "RegisterDynamicActivity"
      ],
      "components": [
        "testsuite",
        "worker",
        "activity-registry"
      ],
      "concepts": [
        "breaking-change",
        "interface-compatibility",
        "test-environment",
        "activity-registration",
        "versioning"
      ],
      "severity": "high",
      "userImpact": "Users with abstractions depending on TestActivityEnvironment implementing ActivityRegistry experience compile errors when upgrading to v1.35.0+.",
      "rootCause": "Adding RegisterDynamicActivity method to the public ActivityRegistry interface violates Go compatibility rules for interfaces, causing implementations to break.",
      "proposedFix": "Consider switching to concrete types instead of returning interfaces, or use the gorelease tool in CI to detect incompatible changes before release.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2006,
        1610
      ],
      "keyQuote": "it is considered a breaking change to add a method to a public interface",
      "number": 2065,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:47.696Z"
    },
    {
      "summary": "Allow activities in the Go SDK to send heartbeats after server-initiated cancellation, similar to workflows' disconnected context behavior. Currently, activities cannot ignore cancellation requests, unlike other SDKs.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat",
        "cancellation"
      ],
      "concepts": [
        "heartbeat",
        "cancellation",
        "activity-execution",
        "disconnected-context",
        "server-request"
      ],
      "severity": "medium",
      "userImpact": "Users cannot keep activities alive to send final heartbeats after server cancellation, limiting graceful shutdown patterns available in other SDKs.",
      "rootCause": null,
      "proposedFix": "Implement heartbeat support after cancellation similar to workflow disconnected context behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to allow heartbeats after server-requested cancellation in activities.",
      "related": [
        1574
      ],
      "keyQuote": "Allow heartbeats after cancellation. This is a desire to be able to heartbeat even if server has requested cancellation, which we should support.",
      "number": 2064,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:29.573Z"
    },
    {
      "summary": "SDK logs (e.g., activity failure logs) do not include trace-id and span-id tags when using the OpenTelemetry tracing interceptor, even when traces are sampled. User logs correctly include these tags, but SDK logs are missing them.",
      "category": "feature",
      "subcategory": "opentelemetry-tracing",
      "apis": [
        "GetLogger"
      ],
      "components": [
        "opentelemetry-interceptor",
        "logging",
        "tracing"
      ],
      "concepts": [
        "distributed-tracing",
        "observability",
        "trace-correlation",
        "span-context",
        "log-tags",
        "otel-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily correlate SDK failure logs with distributed traces, making debugging of temporal SDK issues more difficult.",
      "rootCause": "The OpenTelemetry interceptor attaches trace and span IDs to user-created loggers but does not apply the same interceptor to SDK's internal logging.",
      "proposedFix": "Use the intercepted logger for all SDK logs, similar to how it's done for user-created loggers.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "A separate issue (#829) was identified for using the intercepted logger for all SDK logs, indicating this was addressed as a broader initiative.",
      "related": [
        829,
        1273
      ],
      "keyQuote": "if traces are sampled, user logs contain trace-id and span-id as log tags, but sdk logs do not contain either",
      "number": 2061,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:27.944Z"
    },
    {
      "summary": "Request for a new panic policy option to reset workflows from the start when encountering panics or non-deterministic behavior, allowing automatic recovery without requiring workflow retry with its associated limitations.",
      "category": "feature",
      "subcategory": "panic-policy",
      "apis": [
        "WorkflowPanicPolicy"
      ],
      "components": [
        "worker",
        "workflow-execution",
        "panic-handling"
      ],
      "concepts": [
        "panic",
        "non-determinism",
        "workflow-reset",
        "retry-policy",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users encountering non-deterministic panics need a better way to automatically reset workflows without the limitations of retry policies or risk of infinite loops.",
      "rootCause": "Non-deterministic exceptions in workflow execution lack a clean reset mechanism; existing alternatives (FailWorkflow + RetryPolicy or manual error wrapping) have significant limitations.",
      "proposedFix": "Add a new `ResetWorkflow` panic policy option that automatically resets the workflow from the start on panic, with a maximum limit to prevent infinite loops.",
      "workaround": "Use `WorkflowPanicPolicy` set to `FailWorkflow` combined with `RetryPolicy` when starting the workflow, though this doesn't replay signals and requires wrapping errors with `temporal.NewNonRetryableError`.",
      "resolution": "duplicate",
      "resolutionDetails": "Issue was marked as a duplicate of temporalio/features#417, consolidating the discussion in the features repository.",
      "related": [
        417
      ],
      "keyQuote": "New panic policy to reset the workflow from the start in case of panic/non-determinism.",
      "number": 2058,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:32.902Z"
    },
    {
      "summary": "Request to expose Temporal Nexus operation information to Nexus operation authors, allowing them to access context about the operations they're implementing. This is tracked as a feature enhancement in the Go SDK.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [],
      "components": [
        "nexus",
        "operation-handler"
      ],
      "concepts": [
        "context",
        "operation-metadata",
        "developer-experience",
        "api-exposure"
      ],
      "severity": "medium",
      "userImpact": "Nexus operation authors lack visibility into operation context and metadata, limiting their ability to implement sophisticated operation logic.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to expose operation info to Nexus operation authors in the Go SDK.",
      "related": [
        674
      ],
      "keyQuote": "Expose Temporal Nexus operation info to Temporal Nexus operation authors",
      "number": 2053,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:13.854Z"
    },
    {
      "summary": "Request to support `fmt.Stringer` interface in `ExecuteActivity` for activity name resolution. Currently only raw strings and function pointers are supported, causing unclear error messages when custom types implementing `Stringer` are passed.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "workflow-execution",
        "activity-scheduler",
        "function-resolution"
      ],
      "concepts": [
        "type-safety",
        "string-interface",
        "activity-naming",
        "dynamic-invocation",
        "error-clarity"
      ],
      "severity": "low",
      "userImpact": "Users cannot pass custom types implementing `fmt.Stringer` to `ExecuteActivity`, limiting type-safe ways to specify activity names dynamically.",
      "rootCause": "`getFunctionName` function does not check for or support the `fmt.Stringer` interface when resolving activity names.",
      "proposedFix": "Extend `getFunctionName` to detect and handle types implementing `fmt.Stringer` by calling their `String()` method.",
      "workaround": "Use plain string constants or function pointers instead of custom `Stringer` types for activity names.",
      "resolution": "fixed",
      "resolutionDetails": "PR #2050 was created to add support for `fmt.Stringer` interface in activity name resolution.",
      "related": [
        2050
      ],
      "keyQuote": "If a caller passes a custom type that implements `fmt.Stringer` (e.g. a named type alias), it is treated as a function and causes error",
      "number": 2049,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:16.387Z"
    },
    {
      "summary": "User requests the ability to manually pause a work queue to control whether workers accept new tasks based on resource usage monitoring, but learns that Temporal task queues don't have a pause concept and workers can only be stopped once.",
      "category": "question",
      "subcategory": "worker-lifecycle",
      "apis": [
        "worker.Stop"
      ],
      "components": [
        "worker",
        "task-queue"
      ],
      "concepts": [
        "worker-pause",
        "resource-monitoring",
        "task-acceptance",
        "worker-lifecycle",
        "backpressure"
      ],
      "severity": "low",
      "userImpact": "Users cannot dynamically control task acceptance based on resource usage without stopping the entire worker.",
      "rootCause": "Temporal architecture treats task queues as always-accepting buffers; workers don't have a pause mechanism separate from stop.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Issue closed due to no response; task queues and workers in Temporal have no pause concept by design.",
      "related": [],
      "keyQuote": "Temporal has not concept called a work queue, there are task queues, but task queues always accept new tasks and buffer them until a worker can pick them up.",
      "number": 2047,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:26:12.426Z"
    },
    {
      "summary": "User requests making the Go SDK's deadlock detector configurable to emit warnings instead of failing workflows when long-running operations don't yield for over 1 second. They want to add callback hooks for warnings and make the timeout thresholds adjustable.",
      "category": "feature",
      "subcategory": "deadlock-detection",
      "apis": [],
      "components": [
        "deadlock-converter",
        "workflow-runtime",
        "data-converter"
      ],
      "concepts": [
        "deadlock-detection",
        "workflow-timeout",
        "configurability",
        "metrics",
        "observability",
        "long-running-operations"
      ],
      "severity": "medium",
      "userImpact": "Users with long-running JSON processing in workflows face destructive failures and customer-facing outages due to strict deadlock detection with no visibility or configuration options.",
      "rootCause": "Large JSON payloads processed in workflow code trigger deadlock detection timeout (>1 second without yield), but this is not always an actual deadlock and lacks configurability for different use cases.",
      "proposedFix": "Make the deadlock converter configurable by: 1) adding a callback for warnings to emit metrics, 2) making warning and error thresholds adjustable",
      "workaround": "Use DataConverterWithoutDeadlockDetection to disable the deadlock detector, or move long-running operations to activities/local activities",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer clarified that long-running operations cannot be done in workflow code due to strict workflow task timeouts, and recommended using activities or DataConverterWithoutDeadlockDetection as existing solutions",
      "related": [],
      "keyQuote": "Long running actions cannot be done in workflow code, workflow tasks have a strict timeout so long running actions need to be done in either and activity or local activity",
      "number": 2046,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:59.160Z"
    },
    {
      "summary": "Add tests to verify that custom slot supplier implementations properly set all required slot information fields. This relates to the features repository work on slot suppliers.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "worker",
        "slot-supplier",
        "test-suite"
      ],
      "concepts": [
        "testing",
        "slot-management",
        "custom-implementation",
        "validation",
        "test-coverage"
      ],
      "severity": "medium",
      "userImpact": "Users implementing custom slot suppliers need assurance that their implementations are correct and complete through comprehensive test coverage.",
      "rootCause": null,
      "proposedFix": "Create tests that validate custom slot supplier implementations include all necessary slot info fields",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        672
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/672",
      "number": 2045,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:55.494Z"
    },
    {
      "summary": "AssertActivityCalled does not verify that mocked activities were called with specific arguments unless the activity is explicitly mocked. The method captures activity execution but the assertion fails to match it, despite the activity actually being called with correct arguments.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "AssertActivityCalled"
      ],
      "components": [
        "test-suite",
        "activity-mock",
        "assertion-framework"
      ],
      "concepts": [
        "mocking",
        "test-assertion",
        "activity-execution",
        "argument-verification",
        "mock-expectations"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot reliably test that activities are called with specific arguments without manually mocking them, reducing test clarity and making the assertion feature unreliable.",
      "rootCause": "AssertActivityCalled is designed only for asserting mocked activities (via OnActivity), but the documentation and behavior don't make this clear, leading users to expect it works with registered activities.",
      "proposedFix": null,
      "workaround": "Explicitly mock the activity using s.env.OnActivity(Act, mock.Anything).Return(...) to enable assertion tracking.",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainers clarified that AssertActivityCalled is intended only for asserting activity mocks, not registered activities. This is expected behavior.",
      "related": [],
      "keyQuote": "This is expected `AssertActivityCalled` is for asserting activity mocks are called",
      "number": 2044,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:59.990Z"
    },
    {
      "summary": "Signals sent to mocked child workflows in the test environment only deliver the first signal; subsequent signals block indefinitely instead of triggering their registered handlers.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "SignalExternalWorkflow",
        "GetSignalChannel"
      ],
      "components": [
        "test-workflow-environment",
        "signal-handling",
        "selector"
      ],
      "concepts": [
        "signal-delivery",
        "child-workflows",
        "test-mocking",
        "signal-channels",
        "async-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot reliably test signal exchanges between parent and child workflows in test environments, limiting test coverage for signal-based workflows.",
      "rootCause": "The test environment's signal delivery mechanism does not properly handle multiple signal deliveries to child workflows; only the first signal is processed before subsequent selects block.",
      "proposedFix": null,
      "workaround": "Use ParentClosePolicy.ABANDON to prevent child workflow termination when parent completes, but this is a workaround rather than a fix for the underlying signal delivery issue.",
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed as invalid. The reporter was informed that the expected behavior is that child workflows are terminated when the parent workflow finishes by default, and they should use ParentClosePolicy.ABANDON if they want different behavior.",
      "related": [],
      "keyQuote": "This is expected behaviour, if you parent workflow finished by default your child workflow is terminated and will no longer receive signals.",
      "number": 2040,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:44.272Z"
    },
    {
      "summary": "TestWorkflowEnvironment doesn't properly propagate errors wrapped with errors.Join or fmt.Errorf, causing tests to pass when they should fail with unregistered activity errors.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "error-handling",
        "activity-executor"
      ],
      "concepts": [
        "error-wrapping",
        "error-propagation",
        "test-failure-detection",
        "error-joining",
        "activity-registration"
      ],
      "severity": "medium",
      "userImpact": "Users writing tests may have falsely passing tests when workflows with unregistered activities return wrapped errors, masking bugs in production.",
      "rootCause": "TestWorkflowEnvironment does not properly unwrap or detect errors when they are wrapped using errors.Join or fmt.Errorf, preventing test failures from being caught.",
      "proposedFix": null,
      "workaround": "Use temporal.NewApplicationErrorWithCause instead of errors.Join or fmt.Errorf for proper error handling and errors.As/errors.Is matching.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The correct way to return a joined error is `temporal.NewApplicationErrorWithCause`. Otherwise it breaks `errors.As` / `errors.Is` matching.",
      "number": 2039,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:39.562Z"
    },
    {
      "summary": "Feature request to reclassify benign application errors in OpenTelemetry spans, improving error categorization and observability. This is a cross-SDK effort also being tracked in the Python SDK.",
      "category": "feature",
      "subcategory": "observability",
      "apis": [],
      "components": [
        "instrumentation",
        "opentelemetry",
        "error-handling"
      ],
      "concepts": [
        "error-classification",
        "observability",
        "spans",
        "telemetry",
        "application-errors"
      ],
      "severity": "low",
      "userImpact": "Users will have better visibility into error types in OpenTelemetry traces, with clearer distinction between benign application errors and critical failures.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "This issue references a related Python SDK issue (#1041) and is being tracked as part of cross-SDK observability improvements.",
      "related": [
        1041
      ],
      "keyQuote": null,
      "number": 2034,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:42.323Z"
    },
    {
      "summary": "A newly added gRPC message size test (TestGrpcMessageTooLarge) is flaky in CI with unknown cause, potentially due to timing-dependent error behavior. The test needs to be rewritten to not rely on error timing.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "grpc",
        "integration-tests"
      ],
      "concepts": [
        "flaky-tests",
        "timeout",
        "error-handling",
        "test-reliability",
        "timing-dependency"
      ],
      "severity": "medium",
      "userImpact": "Flaky CI tests reduce developer confidence and cause unpredictable test failures in the SDK development workflow.",
      "rootCause": "Test relies on timing of error delivery, which can be unreliable in CI environments",
      "proposedFix": "Rewrite test to not depend on timing of errors",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test was rewritten to eliminate timing dependencies",
      "related": [
        2026
      ],
      "keyQuote": "The test should be rewritten so that it does not rely on timing of errors.",
      "number": 2033,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:27.545Z"
    },
    {
      "summary": "Add a Go method to the workflow-safe Waitgroup to match Go 1.25's sync.WaitGroup.Go() for API consistency across the SDK.",
      "category": "feature",
      "subcategory": "workflow-utilities",
      "apis": [],
      "components": [
        "waitgroup",
        "workflow-api"
      ],
      "concepts": [
        "synchronization",
        "concurrency",
        "api-consistency",
        "stdlib-compatibility"
      ],
      "severity": "low",
      "userImpact": "Developers using the SDK's workflow-safe Waitgroup will have a more consistent API matching Go's standard library.",
      "rootCause": null,
      "proposedFix": "Add a Go method to the SDK's workflow-safe Waitgroup implementation matching sync.WaitGroup.Go()",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was implemented to provide consistency with Go 1.25's WaitGroup.Go() method",
      "related": [],
      "keyQuote": "The SDK has a workflow safe version of `Waitgroup`, recently Go 1.25 added `Waitgroup.Go`. The SDK should also have a similar method for consistency.",
      "number": 2031,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:23.756Z"
    },
    {
      "summary": "Move the RESOURCE_EXHAUSTED_CAUSE_EXT_GRPC_MESSAGE_TOO_LARGE constant from the SDK extension to the upstream API definition. This constant was added for better handling of gRPC message too large errors and should be standardized in the official API to avoid compatibility issues.",
      "category": "feature",
      "subcategory": "api-compatibility",
      "apis": [],
      "components": [
        "api-definition",
        "resource-exhausted-cause",
        "grpc-error-handling"
      ],
      "concepts": [
        "api-standardization",
        "enum-extension",
        "grpc-messages",
        "compatibility",
        "upstream-alignment"
      ],
      "severity": "medium",
      "userImpact": "Moving this constant to the upstream API ensures consistent error handling across all Temporal SDKs without compatibility issues.",
      "rootCause": "The constant was added as an SDK extension rather than being part of the official upstream API definition, creating potential compatibility concerns.",
      "proposedFix": "Add RESOURCE_EXHAUSTED_CAUSE_GRPC_MESSAGE_TOO_LARGE (without EXT) to the upstream API enum with the next ordinal value, then update SDK code to remove the extension constant and use the upstream version.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The constant was moved to the upstream API and the SDK was updated to use the official API definition instead of the extension.",
      "related": [
        2026
      ],
      "keyQuote": "To avoid compatibility issues, the upstream API definition of the enum should have this constant added",
      "number": 2030,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:25.795Z"
    },
    {
      "summary": "workflowcheck tool fails to compile with Go 1.25.0 due to a breaking change in golang.org/x/tools dependency. The issue was resolved by updating the x/tools version in the master branch and releasing workflowcheck v0.4.0.",
      "category": "bug",
      "subcategory": "tooling-compilation",
      "apis": [],
      "components": [
        "workflowcheck",
        "golang.org/x/tools"
      ],
      "concepts": [
        "compilation",
        "dependency-management",
        "version-compatibility",
        "go-modules",
        "build-tools"
      ],
      "severity": "medium",
      "userImpact": "Users attempting to install workflowcheck with Go 1.25.0 encounter a compilation failure due to an incompatible x/tools dependency.",
      "rootCause": "golang.org/x/tools version 0.25.0 has a breaking change (golang/go#74462) that causes invalid array length calculation in tokeninternal.go, incompatible with Go 1.25.0.",
      "proposedFix": "Bump golang.org/x/tools to a version that resolves the compatibility issue and release a new version of workflowcheck.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "workflowcheck v0.4.0 was released with an updated version of x/tools that resolves the Go 1.25.0 compatibility issue.",
      "related": [],
      "keyQuote": "Pushed a new version of `workflowcheck` that uses an updated version of `x/tools` https://github.com/temporalio/sdk-go/releases/tag/contrib%2Ftools%2Fworkflowcheck%2Fv0.4.0",
      "number": 2027,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:12.251Z"
    },
    {
      "summary": "The DescribeTaskQueueEnhanced API call is using deprecated fields for retrieving task queue statistics. This needs to be updated to use the current non-deprecated APIs, with corresponding test uncommentations in TestTaskQueueStats.",
      "category": "bug",
      "subcategory": "task-queue-api",
      "apis": [
        "DescribeTaskQueueEnhanced"
      ],
      "components": [
        "task-queue",
        "api-client",
        "stats"
      ],
      "concepts": [
        "deprecation",
        "api-migration",
        "task-queue-stats",
        "backwards-compatibility",
        "testing"
      ],
      "severity": "medium",
      "userImpact": "Users relying on DescribeTaskQueueEnhanced may encounter deprecated API warnings or future breakage when APIs are removed.",
      "rootCause": "The DescribeTaskQueueEnhanced implementation continues to reference deprecated API fields instead of migrating to current equivalents.",
      "proposedFix": "Replace deprecated API field references with their non-deprecated equivalents in DescribeTaskQueueEnhanced and uncomment related test lines in TestTaskQueueStats.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Fix it to use the non-deprecated fields.",
      "number": 2025,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:10.055Z"
    },
    {
      "summary": "Go SDK's OTel tracer interceptors should set span kinds (client for outbound, server for inbound) to match the behavior already implemented in Python, .NET, and Ruby SDKs.",
      "category": "feature",
      "subcategory": "otel-tracing",
      "apis": [],
      "components": [
        "otel-tracer",
        "interceptors",
        "tracing"
      ],
      "concepts": [
        "span-kinds",
        "observability",
        "opentelemetry",
        "instrumentation",
        "otel-compliance"
      ],
      "severity": "medium",
      "userImpact": "Users lose observability context from properly categorized spans, making it harder to distinguish between client and server operations in distributed traces.",
      "rootCause": null,
      "proposedFix": "Set span kinds in OTel tracer interceptors: use 'client' for outbound spans and 'server' for inbound spans",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented span kind configuration in OTel tracer interceptors matching other SDK implementations",
      "related": [],
      "keyQuote": "Go should also set their span kinds. `client` as the outbound span kind, and `server` as the inbound span kind",
      "number": 2024,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:25:08.407Z"
    },
    {
      "summary": "Feature request for graceful worker shutdown that waits for all open sessions to close before shutting down. Currently, workers don't wait for sessions to complete during deployment, causing heartbeat timeouts and workflow failures.",
      "category": "feature",
      "subcategory": "worker-shutdown",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "worker",
        "session-manager",
        "shutdown"
      ],
      "concepts": [
        "graceful-shutdown",
        "session-lifecycle",
        "heartbeat-timeout",
        "deployment",
        "worker-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Deployments fail with heartbeat timeouts when sessions are still active, requiring manual session closure or custom counting logic.",
      "rootCause": "Worker shutdown doesn't wait for active sessions to complete, unlike how it waits for activities.",
      "proposedFix": "Add configuration option to worker for waiting until all open sessions are closed before shutting down.",
      "workaround": "Manually track open sessions and delay shutdown until count reaches zero, though this requires blocking new session scheduling.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The option to configure for a worker to wait until all open sessions are closed before shutting down.",
      "number": 2021,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:56.708Z"
    },
    {
      "summary": "Request for plugin support in the Go SDK, referenced from the features repository issue tracker. This is an enhancement request to enable extensibility through a plugin architecture.",
      "category": "feature",
      "subcategory": "plugin-architecture",
      "apis": [],
      "components": [
        "sdk",
        "plugin-system",
        "extensibility"
      ],
      "concepts": [
        "plugin",
        "architecture",
        "extensibility",
        "modularity",
        "integration"
      ],
      "severity": "medium",
      "userImpact": "Users would be able to extend SDK functionality through plugins instead of forking or modifying core code.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, likely addressed through implementation of plugin support or redirection to features tracking.",
      "related": [
        652
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/652",
      "number": 2020,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:53.182Z"
    },
    {
      "summary": "Request to expose the first execution run ID in workflow info. The feature was already implemented and is available in the SDK.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow",
        "info"
      ],
      "concepts": [
        "execution-tracking",
        "run-id",
        "workflow-metadata"
      ],
      "severity": "low",
      "userImpact": "Users can access the first execution run ID to track workflow execution history.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was already implemented and exposed in the SDK's workflow.go file.",
      "related": [
        29
      ],
      "keyQuote": "This is already exposed https://github.com/temporalio/sdk-go/blame/573d6de997240ce75c8fc9795c4b161d6e836005/internal/workflow.go#L1301",
      "number": 2017,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:53.886Z"
    },
    {
      "summary": "Remove deprecated `control` field usage from Go SDK that may be removed from server in the future. The field is currently set to event number, which should be used directly instead.",
      "category": "other",
      "subcategory": "deprecated-api-cleanup",
      "apis": [],
      "components": [
        "internal_event_handlers",
        "event-processing"
      ],
      "concepts": [
        "deprecation",
        "api-cleanup",
        "technical-debt",
        "server-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Ensures SDK remains compatible with future server versions that may remove the deprecated control field.",
      "rootCause": "Deprecated control field still being used in internal_event_handlers.go instead of event number directly.",
      "proposedFix": "Replace usage of control field with event number and add test coverage.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This needs to be removed since it may be yeeted from server at some point in the future (and no other SDKs use it)",
      "number": 2015,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:40.401Z"
    },
    {
      "summary": "WorkerDeploymentVersion struct uses BuildId instead of BuildID, violating Go naming conventions and creating inconsistency with other SDK structs that use BuildID.",
      "category": "bug",
      "subcategory": "api-naming",
      "apis": [
        "WorkerDeploymentVersion"
      ],
      "components": [
        "api",
        "type-definitions"
      ],
      "concepts": [
        "naming-convention",
        "consistency",
        "golang-style",
        "backwards-compatibility"
      ],
      "severity": "low",
      "userImpact": "Users encounter inconsistent naming conventions in the SDK API, reducing code clarity and violating Go style guidelines.",
      "rootCause": "Oversight during initial implementation of WorkerDeploymentVersion struct that failed to follow Go naming conventions for initialisms.",
      "proposedFix": "Rename BuildId field to BuildID in WorkerDeploymentVersion struct to match other SDK structs and Go conventions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Field renamed from BuildId to BuildID to maintain consistency with other SDK structs and follow Go naming conventions.",
      "related": [],
      "keyQuote": "Most (re-exported) structs have `BuildID`, but `WorkerDeploymentVersion` has `BuildId` (which also violates golang conventions)",
      "number": 2011,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:38.354Z"
    },
    {
      "summary": "Mock activities set to Never() don't always panic as expected when called in workflows. Tests that should fail are passing because the panic from the mock framework isn't being properly propagated through the internal task handler's recover mechanism.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "test-suite",
        "mock-activity",
        "internal-task-handlers"
      ],
      "concepts": [
        "mock-enforcement",
        "test-failure",
        "panic-handling",
        "activity-validation",
        "error-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test that activities are not called, as the Never() assertion may be silently ignored when activity errors aren't checked in workflows.",
      "rootCause": "The recover() mechanism in internal/internal_task_handlers suppresses panics from mock framework assertion failures, preventing proper test failure.",
      "proposedFix": null,
      "workaround": "Explicitly fail the test if the activity is called, since testify mock failures don't automatically fail the test.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        608
      ],
      "keyQuote": "We believe it's happening due to the recover in internal/internal_task_handlers which handles the execution of both regular and mock activities",
      "number": 2010,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:38.488Z"
    },
    {
      "summary": "WorkflowReplayer interface broke compatibility with WorkflowRegistry interface after dynamic workflows were added. A compiler check is needed to ensure WorkflowReplayer implements WorkflowRegistry, requiring the addition of RegisterDynamicWorkflow method.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "RegisterDynamicWorkflow",
        "WorkflowRegistry",
        "WorkflowReplayer"
      ],
      "components": [
        "workflow-replayer",
        "workflow-registry",
        "dynamic-workflows"
      ],
      "concepts": [
        "interface-compatibility",
        "compiler-check",
        "method-registration",
        "dynamic-workflows",
        "type-safety"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use WorkflowReplayer as a drop-in replacement for WorkflowRegistry, breaking code that depends on interface compatibility.",
      "rootCause": "Adding dynamic workflows feature changed WorkflowReplayer to no longer implement WorkflowRegistry interface, specifically missing RegisterDynamicWorkflow method.",
      "proposedFix": "Add RegisterDynamicWorkflow to WorkflowReplayer to implement the full WorkflowRegistry interface, or embed WorkflowRegistry interface and implement RegisterDynamicWorkflow.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "WorkflowReplayer was updated to implement the complete WorkflowRegistry interface including RegisterDynamicWorkflow.",
      "related": [],
      "keyQuote": "Add a compiler check to ensure the WorkflowReplayer interface implements the WorkflowRegistry interface.",
      "number": 2006,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:21.091Z"
    },
    {
      "summary": "The OnWorkflow test mocker in the Go SDK doesn't propagate context headers that are passed from parent workflows to child workflows. While the actual child workflow can access these headers, the test mocking framework cannot see them.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "OnWorkflow"
      ],
      "components": [
        "test-mocker",
        "workflow-context",
        "child-workflow"
      ],
      "concepts": [
        "context-propagation",
        "headers",
        "mocking",
        "testing",
        "child-workflows"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test and verify context header propagation from parent to child workflows using the OnWorkflow mocker.",
      "rootCause": "OnWorkflow mocker implementation does not capture or propagate context headers from the parent workflow context to the mocked child workflow.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "OnWorkflow mocker was not able to see the headers passed through the workflow context from the parent workflow",
      "number": 2005,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:19.743Z"
    },
    {
      "summary": "Feature request for a shutdownGraceTime option in the Go SDK to allow a grace period before worker shutdown, preventing activity aborts during deployments. The user referenced the TypeScript SDK implementation and was directed to the existing WorkerStopTimeout configuration.",
      "category": "feature",
      "subcategory": "worker-shutdown",
      "apis": [
        "WorkerStopTimeout"
      ],
      "components": [
        "worker",
        "activity-executor",
        "shutdown"
      ],
      "concepts": [
        "graceful-shutdown",
        "deployment",
        "activity-abort",
        "retry",
        "latency"
      ],
      "severity": "medium",
      "userImpact": "Users deploying new service versions experience increased errors and latency due to activities being aborted instead of allowed to complete gracefully.",
      "rootCause": null,
      "proposedFix": "Implement shutdownGraceTime option similar to TypeScript SDK to allow activities time to complete before worker shutdown.",
      "workaround": "Use existing WorkerStopTimeout configuration to achieve similar behavior.",
      "resolution": "fixed",
      "resolutionDetails": "User was directed to existing WorkerStopTimeout API which provides the requested functionality.",
      "related": [],
      "keyQuote": "set up `shutdownGraceTime` just like in the Typescript SDK to something like 10 seconds",
      "number": 2003,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:23.861Z"
    },
    {
      "summary": "Exploration of whether Go 1.24/1.25's new synctest feature could simplify temporal SDK testing by providing built-in time control instead of the current manual fake clock implementation.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "time-control",
        "workflow-environment"
      ],
      "concepts": [
        "time-skipping",
        "fake-clock",
        "test-synchronization",
        "testing-integration",
        "workflow-testing"
      ],
      "severity": "low",
      "userImpact": "No direct user impact; this is an internal investigation into potential SDK testing simplification.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Determined that synctest is not suitable for Temporal SDK due to workflow environment complexity (random control, task scheduling, activities, child workflows) and incompatibility with SDK's custom timer implementation.",
      "related": [],
      "keyQuote": "A workflow environment is a lot more then just skipping time, it also requires control of other things like random, task scheduling activities, child workflows etc.",
      "number": 2001,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:07.969Z"
    },
    {
      "summary": "DataConverter silently returns unencrypted payloads when the Encode method raises an error, instead of propagating the error to the caller. This creates a security issue where encryption failures are hidden and plaintext data is used without warning.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "PayloadCodec",
        "Encode"
      ],
      "components": [
        "converter",
        "data-converter",
        "codec"
      ],
      "concepts": [
        "error-handling",
        "encryption",
        "payload-encoding",
        "silent-failure",
        "security"
      ],
      "severity": "high",
      "userImpact": "Encryption errors in custom codecs are silently ignored, causing sensitive data to be stored unencrypted while users believe it's encrypted, creating a critical security vulnerability.",
      "rootCause": "The DataConverter's encode method catches errors from the codec's Encode method and returns the original unencrypted payload instead of propagating the error.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This code silent the error an return the parent payload",
      "number": 1999,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:04.026Z"
    },
    {
      "summary": "The workflowRunOperationToken should skip encoding the version field when its value is 0, reducing unnecessary data in the token.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow",
        "token-encoding",
        "operation-token"
      ],
      "concepts": [
        "encoding",
        "versioning",
        "token-optimization",
        "serialization",
        "data-reduction"
      ],
      "severity": "low",
      "userImpact": "Reduces the size of workflow operation tokens when version is 0, improving efficiency.",
      "rootCause": "The version field is being encoded even when its value is 0, which is unnecessary and wasteful.",
      "proposedFix": "Conditionally skip encoding the version field when it equals 0.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the fix was implemented.",
      "related": [],
      "keyQuote": "workflowRunOperationToken should not encode version if 0",
      "number": 1997,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:24:05.338Z"
    },
    {
      "summary": "User inquired about availability of service health status metrics in the Go SDK and whether service health is checked internally. The issue was immediately marked as ignore by the author.",
      "category": "question",
      "subcategory": "monitoring-health-checks",
      "apis": [],
      "components": [
        "metrics",
        "service-client"
      ],
      "concepts": [
        "health-checks",
        "service-monitoring",
        "metrics",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Users seeking visibility into Temporal service health status through SDK metrics.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Author immediately requested to ignore the issue in follow-up comment, indicating it was not a genuine request.",
      "related": [],
      "keyQuote": "igonore this",
      "number": 1993,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:53.230Z"
    },
    {
      "summary": "Add a Summary field to LocalActivityOptions in the Go SDK to align with the features specification. This enhancement allows developers to provide a description of local activities, matching the functionality available in other SDKs.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity",
        "options",
        "activity-executor"
      ],
      "concepts": [
        "local-activities",
        "options",
        "sdk-feature-parity",
        "activity-configuration"
      ],
      "severity": "low",
      "userImpact": "Users will be able to add descriptive summaries to local activity options for better documentation and consistency with other Temporal SDKs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to add Summary field to LocalActivityOptions",
      "related": [
        637
      ],
      "keyQuote": "See parent features issue for details",
      "number": 1988,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:51.210Z"
    },
    {
      "summary": "Users implementing workflows as struct methods with pointer receivers can inadvertently create non-deterministic code. The team decided to add documentation warnings rather than expand the workflowcheck tool to detect this pattern.",
      "category": "docs",
      "subcategory": "workflow-patterns",
      "apis": [],
      "components": [
        "workflowcheck",
        "workflow-registration",
        "documentation"
      ],
      "concepts": [
        "non-determinism",
        "struct-methods",
        "pointer-receiver",
        "static-analysis",
        "code-patterns"
      ],
      "severity": "medium",
      "userImpact": "Users may unknowingly implement workflows with struct methods, leading to non-deterministic behavior that causes runtime errors.",
      "rootCause": "Workflows implemented as struct methods with pointer receivers can violate determinism guarantees; this pattern is difficult to prevent at compile-time.",
      "proposedFix": "Add documentation warnings against using struct methods for workflow definitions.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Team decided against expanding workflowcheck scope. Instead, documentation will be updated to warn against this pattern, though test suite changes would require significant refactoring.",
      "related": [],
      "keyQuote": "Decided internally that since this spams our test logs...for now we'll add something in the documentation warning against this.",
      "number": 1986,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:51.188Z"
    },
    {
      "summary": "User reports that testsuite.StartDevServer fails with Cloudflare Error 1101 when attempting to download Temporal CLI v1.27.2, but the issue is resolved when they realize v1.27.2 refers to the server version, not the CLI version.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [
        "StartDevServer"
      ],
      "components": [
        "test-suite",
        "dev-server",
        "cli-download"
      ],
      "concepts": [
        "version-mismatch",
        "dependency-resolution",
        "testing-infrastructure",
        "cli-management"
      ],
      "severity": "low",
      "userImpact": "Users may encounter confusion when specifying version numbers for dev server configuration, mistaking server versions for CLI versions.",
      "rootCause": "User confusion between CLI versions and server versions - v1.27.2 refers to the Temporal server version, not a valid CLI version",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was user error - v1.27.2 is not a valid CLI version, it's a server version. The user was confusing CLI and server versioning schemes.",
      "related": [],
      "keyQuote": "v1.27.2 is not a valid CLI version per https://github.com/temporalio/cli. You may be confusing CLI versions with server versions.",
      "number": 1985,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:39.023Z"
    },
    {
      "summary": "Request to expose StartToCloseTimeout in the Go SDK's ActivityInfo struct, similar to the Java SDK implementation. This would allow activities to access their timeout configuration at runtime.",
      "category": "feature",
      "subcategory": "activity-info",
      "apis": [
        "ActivityInfo"
      ],
      "components": [
        "activity",
        "activity-info",
        "sdk"
      ],
      "concepts": [
        "timeout",
        "activity-configuration",
        "runtime-access",
        "api-parity",
        "java-sdk",
        "sdk-alignment"
      ],
      "severity": "low",
      "userImpact": "Activities in Go SDK will be able to access their StartToCloseTimeout configuration at runtime, matching Java SDK functionality and improving API completeness.",
      "rootCause": null,
      "proposedFix": "Add StartToCloseTimeout field to ActivityInfo struct in the Go SDK, similar to the Java implementation",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and the issue closed",
      "related": [],
      "keyQuote": "Similarly to what Java sdk exposes in ActivityInfo",
      "number": 1983,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:35.856Z"
    },
    {
      "summary": "The workflowcheck binary doesn't embed version information and currently shows 'version devel' when queried with -V=full flag. Users want the actual version used during installation to be displayed.",
      "category": "feature",
      "subcategory": "build-tooling",
      "apis": [],
      "components": [
        "workflowcheck",
        "build-system"
      ],
      "concepts": [
        "version-embedding",
        "semver",
        "build-metadata",
        "binary-information",
        "tool-versioning"
      ],
      "severity": "low",
      "userImpact": "Users cannot determine which version of workflowcheck they have installed, making it harder to troubleshoot compatibility issues.",
      "rootCause": null,
      "proposedFix": "Embed version information (semver, buildID, git hash) into the workflowcheck binary at build time so -V=full displays the actual installation version.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "workflowcheck binary to include the version that was used during its installation",
      "number": 1980,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:33.997Z"
    },
    {
      "summary": "ContinueAsNew creates overly large traces by attaching new workflows to existing spans, potentially overwhelming tracing backends. The request is to create new disconnected root spans for ContinueAsNew and child workflows, linked to the original trace.",
      "category": "feature",
      "subcategory": "tracing-opentelemetry",
      "apis": [
        "ContinueAsNew",
        "ExecuteChildWorkflow"
      ],
      "components": [
        "tracing",
        "opentelemetry-interceptor",
        "workflow-context",
        "span-management"
      ],
      "concepts": [
        "distributed-tracing",
        "span-lifecycle",
        "context-propagation",
        "trace-overhead",
        "observability",
        "workflow-continuation"
      ],
      "severity": "medium",
      "userImpact": "Users with long-running workflows using ContinueAsNew experience trace backend overwhelm due to unbounded span growth.",
      "rootCause": "ContinueAsNew workflows are attached to the parent trace context, causing all spans from the new workflow invocation to be added to the same trace, creating exponentially large traces on repeated continuations.",
      "proposedFix": "Expose the ability to get the OpenTelemetry span from workflow context, allowing users to create custom interceptors that disconnect spans for ContinueAsNew and child workflows using trace.WithNewRoot() and trace.WithLinks().",
      "workaround": "Implement custom SpanStarter in tracing interceptor that checks for RunWorkflow spans and applies trace.WithNewRoot() with trace.WithLinks() to create disconnected but linked traces.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "For the most flexibility...expose the ability to get the otel span from the workflow context, then users can interact with the span like they do outside of workflow code.",
      "number": 1976,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:21.718Z"
    },
    {
      "summary": "Request to add `WorkflowTaskFailedCause` field to `RespondQueryTaskCompletedRequest` API, mirroring the existing functionality available for workflow task failures.",
      "category": "feature",
      "subcategory": "query-task-completion",
      "apis": [
        "RespondQueryTaskCompletedRequest"
      ],
      "components": [
        "query-handler",
        "workflow-task",
        "api-request"
      ],
      "concepts": [
        "query-completion",
        "failure-cause",
        "error-handling",
        "workflow-task-failure",
        "api-consistency"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot currently specify failure causes when completing query tasks, limiting error reporting consistency with workflow task failures.",
      "rootCause": null,
      "proposedFix": "Add `WorkflowTaskFailedCause` field to `RespondQueryTaskCompletedRequest` with parity to workflow task failure handling",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to add WorkflowTaskFailedCause support to RespondQueryTaskCompletedRequest",
      "related": [],
      "keyQuote": "Should work the same as for workflow task failures",
      "number": 1971,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:18.389Z"
    },
    {
      "summary": "Users receive unhelpful generic 'context deadline exceeded' errors when activity results exceed the 2MB size limit. The request is for more specific error messages that clearly indicate the actual cause (e.g., 'context size limit exceeded') rather than generic timeout errors.",
      "category": "other",
      "subcategory": "error-messages",
      "apis": [],
      "components": [
        "activity-executor",
        "error-handling"
      ],
      "concepts": [
        "error-messages",
        "debugging",
        "size-limits",
        "context-deadline",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users waste significant time debugging mysterious 'context deadline exceeded' errors instead of immediately identifying the actual issue (size limit) and finding solutions.",
      "rootCause": "Activity result size exceeds 2MB limit, but error message doesn't specify this constraint, leading users to mistakenly increase timeout values.",
      "proposedFix": "Implement specific error messages for different failure cases (e.g., 'context size limit exceeded' for payload size violations, distinct from actual timeout errors).",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Issue was marked as duplicate of #995, which is being actively worked on across all SDKs to provide better error messages for this case.",
      "related": [
        995
      ],
      "keyQuote": "It's insanely frustrating when it gives generic error like 'context deadline exceeded' in case the data we are returning back is more than 2MB, with pretty much no info",
      "number": 1966,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:23.414Z"
    },
    {
      "summary": "GetWorkerStopChannel() is not properly indicating worker shutdown for local activities after a recent change. The worker stop channel should be preserved in the Local Activity poller to correctly signal worker shutdown, while ensuring the LA-specific stop channel is closed at the right time.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "GetWorkerStopChannel"
      ],
      "components": [
        "worker",
        "local-activity-poller",
        "shutdown"
      ],
      "concepts": [
        "shutdown-signal",
        "stop-channel",
        "worker-lifecycle",
        "activity-polling",
        "synchronization"
      ],
      "severity": "high",
      "userImpact": "Users relying on GetWorkerStopChannel() to detect worker shutdown for local activities will not receive proper shutdown signals.",
      "rootCause": "PR #1875 changed local activity polling to use LA-specific stop channel instead of worker stop channel, breaking the shutdown detection semantics.",
      "proposedFix": "Keep the worker stop channel in the Local Activity poller and return it from GetWorkerStopChannel() while ensuring LA-specific stop channel is closed at the appropriate time during shutdown.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker stop channel was preserved in the Local Activity poller to properly indicate worker shutdown while maintaining LA-specific shutdown behavior.",
      "related": [
        1875
      ],
      "keyQuote": "GetWorkerStopChannel() for local activities now indicates when the local activity specific stop channel has closed. This is due to https://github.com/temporalio/sdk-go/pull/1875.",
      "number": 1963,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:05.020Z"
    },
    {
      "summary": "Test suite encounters an \"illegal access from outside of workflow context\" error when calling activities within child workflows during testing, despite the same code working correctly in production Temporal deployments. The error suggests context is not properly propagated in the test environment when using selector.AddReceive.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "ExecuteActivity"
      ],
      "components": [
        "test-workflow-environment",
        "workflow-context",
        "selector",
        "activity-executor"
      ],
      "concepts": [
        "workflow-context",
        "test-isolation",
        "context-propagation",
        "child-workflows",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Developers cannot test workflows that execute child workflows with activities, blocking test suite validation of production-ready code.",
      "rootCause": "Context propagation issue in test environment where ctx is not properly passed from inside selector.AddReceive calls, causing workflow context to be lost when executing activities in child workflows.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Looks like there's an issue with the test environment propagating `ctx` from inside the `selector.AddReceive`",
      "number": 1961,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:07.698Z"
    },
    {
      "summary": "User requests the ability to retrieve the original logger instance from activity.GetLogger(ctx) or workflow.GetLogger(ctx) instead of receiving a wrapped ReplayLogger. The issue is that injected context fields from custom loggers and trace interceptors are lost when the logger is wrapped.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [
        "GetLogger"
      ],
      "components": [
        "logger",
        "activity-context",
        "workflow-context",
        "replay-logger"
      ],
      "concepts": [
        "logger-wrapping",
        "context-fields",
        "trace-integration",
        "logger-adapter",
        "decorator-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users with custom logger implementations cannot reliably access their original logger instance with all injected context fields from interceptors and configurations.",
      "rootCause": "The SDK wraps the original logger in a ReplayLogger for activity/workflow execution, and the wrapped instance is not accessible to retrieve the original logger with its accumulated context fields.",
      "proposedFix": "Either provide a method to retrieve the original configured logger while preserving injected fields, or avoid wrapping the original logger and maintain the same logger type throughout execution.",
      "workaround": "Fall back to using a global logger, though this may result in loss of important context fields injected by interceptors.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I want to have opportunity to get the original logger structure without losing all the fields injected previously.",
      "number": 1954,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:23:03.157Z"
    },
    {
      "summary": "UpdateWorkflow does not use the context-aware data converter that was provided to the client, causing payloads to be encrypted with the wrong key when a tenant-specific encryption context is set.",
      "category": "bug",
      "subcategory": "workflow-update",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "client",
        "data-converter",
        "workflow-update"
      ],
      "concepts": [
        "context-awareness",
        "encryption",
        "data-serialization",
        "tenant-isolation",
        "payload-encoding"
      ],
      "severity": "high",
      "userImpact": "Users with context-aware data converters (e.g., for tenant-specific encryption) find their update payloads are unencrypted, breaking security guarantees.",
      "rootCause": "UpdateWorkflow implementation does not pass or respect the context parameter when invoking the data converter, unlike other client methods.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "UpdateWorkflow was updated to use the context-aware data converter instead of a non-context aware variant.",
      "related": [],
      "keyQuote": "UpdateWorkflow should use a context aware data converter",
      "number": 1951,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:49.737Z"
    },
    {
      "summary": "Remove license headers from all files in the api-go repository following the pattern established in the temporal server repository, including both source and generated files.",
      "category": "other",
      "subcategory": "tooling",
      "apis": [],
      "components": [
        "api-go",
        "code-generation",
        "build-tools"
      ],
      "concepts": [
        "license-headers",
        "code-generation",
        "maintenance",
        "cleanup",
        "build-configuration"
      ],
      "severity": "low",
      "userImpact": "Users benefit from reduced boilerplate and maintenance burden in the api-go codebase.",
      "rootCause": null,
      "proposedFix": "Remove license headers from all files in api-go repository and remove any tooling that generates or requires them",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by removing license headers and associated tooling from api-go repository",
      "related": [
        7689
      ],
      "keyQuote": "Following server in temporal/temporal#7689, license headers are no longer required on files. Remove from all files in the `api-go` repository",
      "number": 1948,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:50.871Z"
    },
    {
      "summary": "Remove license headers from all files in the SDK following the server's decision to no longer require them. This includes removing any tooling that generates or enforces license headers.",
      "category": "feature",
      "subcategory": "build-process",
      "apis": [],
      "components": [
        "build-tooling",
        "file-generation",
        "license-enforcement"
      ],
      "concepts": [
        "code-cleanup",
        "build-requirements",
        "maintainability",
        "process-simplification"
      ],
      "severity": "low",
      "userImpact": "Simplifies SDK development and build processes by removing unnecessary license header requirements and tooling.",
      "rootCause": null,
      "proposedFix": "Remove license headers from all files and delete tooling that generates or enforces them.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "License headers were removed from the SDK and associated tooling was deleted or updated.",
      "related": [],
      "keyQuote": "Following server in https://github.com/temporalio/temporal/pull/7689, license headers are no longer required on files.",
      "number": 1947,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:47.030Z"
    },
    {
      "summary": "SearchAttributes.Copy method is being incorrectly flagged by workflowcheck linter and needs to be marked as ignored to prevent false positives.",
      "category": "other",
      "subcategory": "workflow-linting",
      "apis": [
        "SearchAttributes.Copy"
      ],
      "components": [
        "workflowcheck",
        "search-attributes"
      ],
      "concepts": [
        "linting",
        "code-analysis",
        "workflow-validation",
        "api-usage"
      ],
      "severity": "medium",
      "userImpact": "Users encounter false positive linting errors when using SearchAttributes.Copy in workflows, requiring unnecessary code modifications or suppression.",
      "rootCause": "SearchAttributes.Copy is not registered in the workflowcheck linter's allowed function list.",
      "proposedFix": "Mark SearchAttributes.Copy as ignored by workflowcheck configuration.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "SearchAttributes.Copy was added to the workflowcheck ignore list.",
      "related": [],
      "keyQuote": "Need to mark `SearchAttributes.Copy` as ignored by `workflowcheck`",
      "number": 1943,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:30.944Z"
    },
    {
      "summary": "User requests CLI support for redriving workflows stuck in task queue and batch rerunning them using saved payloads, as the reset button is unavailable for workflows not yet dispatched to workers.",
      "category": "feature",
      "subcategory": "cli-workflow-management",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "cli",
        "workflow-execution",
        "task-queue"
      ],
      "concepts": [
        "batch-operations",
        "workflow-restart",
        "payload-reuse",
        "task-queue",
        "reset"
      ],
      "severity": "medium",
      "userImpact": "Users cannot efficiently batch redrive or restart workflows that are stuck in task queues without manual intervention for each workflow.",
      "rootCause": "CLI lacks support for batch workflow redriving and payload retrieval from workflow history for reuse in new executions.",
      "proposedFix": "Extend CLI with commands to batch start workflows by reusing input payloads, with support for query parameters and payload retrieval from workflow show output.",
      "workaround": "Use the UI's 'Start a workflow like this one' feature for individual workflows, or manually list workflows with --query and describe each one individually.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers indicated this is a feature request for the Temporal CLI project (not SDK-Go) and recommended using existing UI/CLI features. No plans to implement batch workflow redriving in SDK-Go.",
      "related": [],
      "keyQuote": "have a solution (like CLI) to redrive workflows in task queue and rerun them",
      "number": 1942,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:36.547Z"
    },
    {
      "summary": "scheduleHandle.Describe() fails with a proto decoding error when using a remote data converter, because the schedule metadata contains a null payload that the codec cannot process.",
      "category": "bug",
      "subcategory": "schedule-api",
      "apis": [
        "scheduleHandle.Describe"
      ],
      "components": [
        "codec",
        "dataconverter",
        "schedule-handler"
      ],
      "concepts": [
        "data-serialization",
        "proto-unmarshaling",
        "null-payload",
        "remote-dataconverter",
        "schedule-metadata"
      ],
      "severity": "high",
      "userImpact": "Users cannot describe schedules when using custom remote data converters for encryption, blocking automation workflows.",
      "rootCause": "The codec HTTP endpoint calls protojson.Unmarshal on a null payload value without null-checking, causing a 'unexpected token null' proto syntax error.",
      "proposedFix": "Avoid calling the data converter with null payloads. Additionally, gracefully handle null payloads during deserialization by using zero values.",
      "workaround": "Downgrade to SDK version 1.30.0 before the user metadata summary feature was added.",
      "resolution": "fixed",
      "resolutionDetails": "The maintainers acknowledged the bug and committed to fixing both the null payload handling in the codec and graceful zero-value deserialization.",
      "related": [],
      "keyQuote": "we should not be calling the data converter with a null payload. We will fix.",
      "number": 1940,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:33.952Z"
    },
    {
      "summary": "The `workflowcheck` tool incorrectly flags `reflect.New` as non-deterministic due to sync.Map operations, even though it should be deterministic like `reflect.Value.Interface`.",
      "category": "bug",
      "subcategory": "workflow-validation",
      "apis": [],
      "components": [
        "workflowcheck",
        "determinism-checker",
        "reflect-operations"
      ],
      "concepts": [
        "determinism",
        "reflection",
        "sync.Map",
        "workflow-constraints",
        "static-analysis"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use `reflect.New` in workflows when using workflowcheck validation, limiting legitimate use of reflection in workflows.",
      "rootCause": "sync.Map operation inside reflect.New is causing the determinism checker to incorrectly mark it as non-deterministic",
      "proposedFix": "Exempt `reflect.New` from non-determinism checks in the same way `reflect.Value.Interface` is exempted in ident_refs.go",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Could not be reproduced; reopening requested if issue occurs again",
      "related": [],
      "keyQuote": "It seems there is a `sync.Map` operation in Go that is causing this to appear non-deterministic. We should exempt `reflect.New` the same way we do `reflect.Value.Interface`",
      "number": 1936,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:15.772Z"
    },
    {
      "summary": "client.Dial fails to resolve Docker container DNS names, requiring users to manually resolve the hostname to an IP address. The issue stems from gRPC's name resolution behavior in Docker environments where the standard DNS resolver doesn't handle Docker's service discovery properly.",
      "category": "bug",
      "subcategory": "dns-resolution",
      "apis": [
        "client.Dial"
      ],
      "components": [
        "client",
        "grpc-configuration",
        "dns-resolver"
      ],
      "concepts": [
        "dns-resolution",
        "docker-networking",
        "service-discovery",
        "grpc-address-resolver",
        "container-networking",
        "hostname-resolution"
      ],
      "severity": "medium",
      "userImpact": "Users running Go SDK clients in Docker containers cannot connect to Temporal servers using service names and must resort to manual DNS lookups or IP addresses.",
      "rootCause": "gRPC-go's default DNS resolver doesn't properly handle Docker's internal service discovery; the `passthrough:///` resolver is required for Docker container DNS names.",
      "proposedFix": "Use `passthrough:///temporal:7233` format for the HostPort option to bypass gRPC's DNS resolution logic.",
      "workaround": "Manually resolve the hostname using `net.LookupHost()` before passing the IP to client.Dial(), or use the `passthrough:///` resolver prefix.",
      "resolution": "wontfix",
      "resolutionDetails": "Determined to be a documentation/configuration issue rather than a bug. The gRPC-go library is working as designed; users need to understand gRPC's name resolution rules and Docker's networking model.",
      "related": [],
      "keyQuote": "Is there ANYWHERE in the docs or API docs that says 'resolved using grpc-go'?",
      "number": 1935,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:20.419Z"
    },
    {
      "summary": "Request for type-safe generic wrappers around workflow.ExecuteActivity to eliminate boilerplate and provide compile-time type checking for activity arguments and results.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "workflow-context",
        "type-system"
      ],
      "concepts": [
        "type-safety",
        "generics",
        "boilerplate-reduction",
        "compile-time-checking",
        "api-design"
      ],
      "severity": "low",
      "userImpact": "Developers must write boilerplate code and cannot catch type mismatches between activities and workflow execution until runtime.",
      "rootCause": null,
      "proposedFix": "Implement generic type-safe wrappers around ExecuteActivity that accept a function and arguments, returning a typed Future or result directly.",
      "workaround": "Users can implement their own generic wrapper functions as demonstrated in the issue.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of an existing issue for generic/type-safe API support across workflows, activities, signals, updates, and queries.",
      "related": [],
      "keyQuote": "There is still a lot of design and thought that needs to go into how we create a fully type safe API, including things like type safe workflows, activities, signals, updates and queries.",
      "number": 1932,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:17.503Z"
    },
    {
      "summary": "Request for SDK support for activity reset functionality in the Go SDK, mirroring feature work tracked in the features repository.",
      "category": "feature",
      "subcategory": "activity-reset",
      "apis": [],
      "components": [
        "activity-executor",
        "worker"
      ],
      "concepts": [
        "activity-reset",
        "workflow-execution",
        "state-management",
        "recovery"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reset activities in workflows, limiting recovery and state management capabilities in the Go SDK.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Activity reset support has been implemented in the Go SDK",
      "related": [
        620
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/620",
      "number": 1931,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:02.786Z"
    },
    {
      "summary": "Activity start-to-close timeout is currently calculated from server-provided start time, making it subject to system clock skew. The request is to base it on local system time (time.Now()) instead to be more resilient to time differences.",
      "category": "bug",
      "subcategory": "activity-timeout",
      "apis": [],
      "components": [
        "activity",
        "activity-executor",
        "timeout-handler"
      ],
      "concepts": [
        "timeout",
        "start-to-close",
        "system-time",
        "clock-skew",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Activities may timeout incorrectly when there is clock skew between the worker and server, causing unexpected execution failures.",
      "rootCause": "Start-to-close timeout is calculated from server-provided start time rather than local system time, making it vulnerable to clock skew between worker and server.",
      "proposedFix": "Calculate start-to-close timeout based on time.Now() instead of server-provided start time.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation changed to use local system time (time.Now()) for start-to-close calculation instead of server time.",
      "related": [
        1912
      ],
      "keyQuote": "Have it based on `time.Now()` instead. Note, nothing can be done about schedule-to-start equivalent because there is no local-time equivalent for \"scheduled\".",
      "number": 1930,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:00.183Z"
    },
    {
      "summary": "OTel metrics in the Go SDK use UpDownCounter but the documentation and other SDK implementations describe metrics as monotonically increasing. The current implementation allows negative values which doesn't match expected counter behavior across other Temporal SDKs and OTel standards.",
      "category": "bug",
      "subcategory": "observability-metrics",
      "apis": [],
      "components": [
        "opentelemetry-handler",
        "metrics-handler",
        "otel-contrib"
      ],
      "concepts": [
        "monitoring",
        "metrics",
        "counter",
        "observability",
        "otel",
        "monotonic-increase"
      ],
      "severity": "low",
      "userImpact": "Users integrating OTel metrics see unexpected behavior with UpDownCounter supporting negative values, creating inconsistency with documentation and other SDK implementations.",
      "rootCause": "OTel handler was implemented to support general usage with UpDownCounter type, allowing negative values, while documentation describes metrics as monotonically increasing like standard Prometheus counters.",
      "proposedFix": "Either update documentation to clarify UpDownCounter behavior, or change OTel implementation to use Counter type instead to match Prometheus patterns and other SDK implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1336
      ],
      "keyQuote": "The UpDownCounter type doesn't make contextual sense for the metrics emitted by the Temporal SDK.",
      "number": 1929,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:22:03.149Z"
    },
    {
      "summary": "Race condition in local activity execution during worker shutdown causes inconsistent error messages. The activity context may complete before worker shutdown is processed, resulting in 'context canceled' instead of 'ErrWorkerShutdown'.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "worker",
        "local-activity-executor",
        "task-pollers"
      ],
      "concepts": [
        "race-condition",
        "context-cancellation",
        "graceful-shutdown",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users may receive inconsistent error messages when shutting down workers that have local activities listening to context cancellation.",
      "rootCause": "The local activity execution goroutine completes before worker shutdown inspection, causing the context cancellation to be processed instead of the worker shutdown signal.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #1910 which resolved the race condition in local activity context handling.",
      "related": [
        1910
      ],
      "keyQuote": "If a local activity has logic to complete on `ctx.Done()`, sometimes the local activity completes first, other times the worker shuts down first.",
      "number": 1928,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:45.626Z"
    },
    {
      "summary": "Request to add a warning when the server-provided task start time differs significantly from when the SDK begins processing the task. This feature was proposed to help detect timing issues between server and client.",
      "category": "feature",
      "subcategory": "task-processing",
      "apis": [],
      "components": [
        "worker",
        "task-processor",
        "time-sync"
      ],
      "concepts": [
        "task-timing",
        "server-client-synchronization",
        "time-drift",
        "diagnostics"
      ],
      "severity": "low",
      "userImpact": "Users would receive warnings to help diagnose timing discrepancies between server and SDK task processing.",
      "rootCause": null,
      "proposedFix": "Add warning logic to detect and alert when server task start time differs significantly from SDK processing start time.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed as too niche - the use case was deemed not significant enough to warrant implementation.",
      "related": [
        616
      ],
      "keyQuote": "We're not gonna do this. Too niche.",
      "number": 1926,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:47.175Z"
    },
    {
      "summary": "Remove the cloud submodule and cloud protos from api-go now that cloud-sdk-go repository exists as the dedicated home for cloud-related functionality.",
      "category": "feature",
      "subcategory": "api-organization",
      "apis": [],
      "components": [
        "api-go",
        "cloud-submodule",
        "cloud-protos"
      ],
      "concepts": [
        "modularization",
        "repository-organization",
        "cloud-sdk",
        "code-consolidation",
        "api-separation"
      ],
      "severity": "medium",
      "userImpact": "Users will need to migrate from the cloud submodule in api-go to the dedicated cloud-sdk-go repository for cloud functionality.",
      "rootCause": null,
      "proposedFix": "Remove the cloud submodule and cloud protos from the api-go repository and direct users to cloud-sdk-go as the new home.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Cloud submodule and protos were removed from api-go with users directed to cloud-sdk-go repository.",
      "related": [
        1831
      ],
      "keyQuote": "we should remove the cloud submodule and cloud protos from https://github.com/temporalio/api-go, mentioning in the PR that https://github.com/temporalio/cloud-sdk-go is the home for them now.",
      "number": 1921,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:49.088Z"
    },
    {
      "summary": "Feature request to expose the retry policy associated with an activity in the ActivityInfo object, allowing developers to inspect retry configuration at runtime.",
      "category": "feature",
      "subcategory": "activity-info",
      "apis": [
        "ActivityInfo"
      ],
      "components": [
        "activity-executor",
        "worker",
        "activity-info"
      ],
      "concepts": [
        "retry-policy",
        "activity-configuration",
        "runtime-inspection",
        "activity-metadata"
      ],
      "severity": "low",
      "userImpact": "Developers would be able to inspect retry policy details for an activity during execution, improving debugging and runtime visibility.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to expose retry policy in ActivityInfo",
      "related": [
        615
      ],
      "keyQuote": "Show retry policy on activity info",
      "number": 1919,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:35.214Z"
    },
    {
      "summary": "User requested an option to prevent local activity results from being logged to workflow history to handle large data (2-5MB+) that exceeds size limits. The maintainer clarified this is unsafe and recommended restructuring data to only return the subset needed.",
      "category": "feature",
      "subcategory": "local-activity",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity",
        "history",
        "marker-recording"
      ],
      "concepts": [
        "history-size-limit",
        "large-data-handling",
        "replay-safety",
        "marker-attributes"
      ],
      "severity": "medium",
      "userImpact": "Users need workarounds for handling large cached data in workflows when local activity results exceed history size limits.",
      "rootCause": "Local activity results are recorded as markers in workflow history; large results exceed RecordMarkerCommandAttributes size limits.",
      "proposedFix": "Restructure workflow to load and process only the subset of data needed as local activity return value, rather than loading all 2-5MB.",
      "workaround": "Use a side effect instead of local activity for handling large data, while monitoring the deadlock detector.",
      "resolution": "invalid",
      "resolutionDetails": "The maintainer clarified this is not a safe pattern and recommended architectural changes instead of adding an option to skip history logging.",
      "related": [],
      "keyQuote": "We don't store what you load in the local activity, we store what you return in the local activity.",
      "number": 1916,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:32.473Z"
    },
    {
      "summary": "Activity fails with \"Activity complete after timeout\" error when Temporal cluster nodes have unsynchronized clocks and the schedule-to-close timeout is exceeded on the worker's local time. The issue occurs because the deadline is calculated based on server time, not worker local time.",
      "category": "bug",
      "subcategory": "activity-timeout",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "timeout-handling"
      ],
      "concepts": [
        "clock-skew",
        "timeout",
        "deadline",
        "distributed-systems",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Workflows fail prematurely when cluster nodes have significant time differences, requiring operators to maintain strict clock synchronization.",
      "rootCause": "Schedule-to-close timeout deadline is calculated based on server time at task start, not worker local time. When worker clocks are ahead of server clock, the deadline is already exceeded when task execution begins.",
      "proposedFix": "Make schedule-to-close timeout relative to local time instead of server time (though this is technically challenging since there's no local-time equivalent of when the task was first scheduled).",
      "workaround": "Ensure all cluster nodes maintain synchronized clocks and set timeouts high enough to account for any potential clock skew.",
      "resolution": "wontfix",
      "resolutionDetails": "Team determined that schedule-to-close timeout cannot be made relative to local time because there is no local-time equivalent of when the task was first scheduled. Instead, opened related issues #1926 (warn on clock skew) and #1930 (make start-to-close relative to local time).",
      "related": [
        1926,
        1930
      ],
      "keyQuote": "We cannot do this with schedule to close, because there is no local-time equivalent of when first scheduled to base the timeout off of so we have to use the server time.",
      "number": 1912,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:33.918Z"
    },
    {
      "summary": "Implement application failure logging and metrics behavior for the Go SDK according to ApplicationErrorCategory specifications defined in the features repository. This involves standardizing how application errors are logged and metrically tracked across different error categories.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "error-handling",
        "logging",
        "metrics"
      ],
      "concepts": [
        "application-errors",
        "error-categories",
        "logging-behavior",
        "metrics",
        "observability",
        "error-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users will have consistent and standardized logging and metrics for application failures across different error categories.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed to align application error logging and metrics with ApplicationErrorCategory specifications",
      "related": [
        614
      ],
      "keyQuote": "Apply application failure logging and metrics behaviour according to ApplicationErrorCategory",
      "number": 1908,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:17.236Z"
    },
    {
      "summary": "The workflowcheck tool crashes with an 'index out of range' panic when analyzing packages without source files (like the 'unsafe' package). The crash occurs in the analysis framework when it tries to access Files[0] without checking if the Files slice is empty.",
      "category": "bug",
      "subcategory": "workflowcheck-determinism",
      "apis": [],
      "components": [
        "workflowcheck",
        "determinism-checker",
        "analysis-framework"
      ],
      "concepts": [
        "panic-recovery",
        "edge-cases",
        "analysis-pass",
        "empty-slice",
        "package-analysis"
      ],
      "severity": "high",
      "userImpact": "Users cannot run workflowcheck through golangci-lint or standalone with certain codebases because the tool crashes on packages without source files.",
      "rootCause": "The code assumes pass.Files slice is non-empty when it can be empty for certain packages (like 'unsafe'). The golang/tools analysis framework still has this assumption in its debug logging code at checker.go:591.",
      "proposedFix": "Add a check to verify pass.Files is not empty before accessing Files[0], or handle the case where Files is empty.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Somehow the `act.pass.Files` is empty slice. In this case the key is `package unsafe (\"unsafe\")`.",
      "number": 1906,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:19.959Z"
    },
    {
      "summary": "Activities that are paused should have their heartbeats interrupted rather than continuing to send heartbeat signals. This is a behavior correction to ensure paused activities don't maintain background activity.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-manager",
        "pause-handler"
      ],
      "concepts": [
        "heartbeat",
        "pause",
        "activity-lifecycle",
        "interrupt",
        "background-execution"
      ],
      "severity": "medium",
      "userImpact": "Users may experience unexpected heartbeat signals from paused activities, causing confusion and potential downstream issues in activity lifecycle management.",
      "rootCause": "The activity heartbeat mechanism does not respect the paused state and continues sending heartbeats regardless of pause status.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Heartbeat interruption logic was implemented to stop heartbeats when activities transition to paused state.",
      "related": [
        602
      ],
      "keyQuote": "Heartbeating activities should be interrupted when the activities are paused.",
      "number": 1899,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:20.718Z"
    },
    {
      "summary": "Request to support simulating race conditions during signal draining in Go SDK tests to improve test coverage. The challenge is that signal draining occurs in a narrow time window that's difficult to trigger reliably in tests.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "signal-draining",
        "test-environment",
        "workflow-execution"
      ],
      "concepts": [
        "race-condition",
        "test-coverage",
        "signal-handling",
        "timing",
        "workflow-completion"
      ],
      "severity": "low",
      "userImpact": "Users struggle to achieve complete test coverage for signal draining logic in their workflows due to timing difficulties.",
      "rootCause": "Signal draining occurs in a tight time window during workflow completion, making it difficult to reliably trigger in tests without explicit test framework support.",
      "proposedFix": "One suggestion is for the SDK to warn users if they don't check any signal channel in the last workflow task, as this risks dropping signals that arrive during draining.",
      "workaround": "Skipping testing this race condition for now.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "it's a tight time window that the signal drain needs to run, and hard at least for me to get signals in to trigger the draining in a test",
      "number": 1895,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:06.559Z"
    },
    {
      "summary": "Context is mutated between interceptors and activity by stripping headers using context.WithValue(), preventing users from passing custom context types through interceptors to activities.",
      "category": "question",
      "subcategory": "interceptors-context",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "interceptors",
        "activity-executor",
        "context-handling"
      ],
      "concepts": [
        "context-mutation",
        "interceptor-chain",
        "custom-context",
        "context-passing",
        "header-stripping"
      ],
      "severity": "low",
      "userImpact": "Users cannot reliably pass custom context types through activity interceptors to activities due to context mutations in the SDK.",
      "rootCause": "Header removal using context.WithValue() in internal/workflow.go#L793 mutates the context between interceptor and activity execution.",
      "proposedFix": "Strip headers before the interceptor rather than after it to avoid context mutation.",
      "workaround": "Use context.WithValue() with a custom key to smuggle the context through, though this exposes stripped headers.",
      "resolution": "wontfix",
      "resolutionDetails": "SDK does not make guarantee that context is not mutated between interceptors and activity. Users should implement custom contexts following Go's standard context patterns.",
      "related": [],
      "keyQuote": "The SDK does not make any guarantee that the context is not mutated between interceptors and activity.",
      "number": 1890,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:04.740Z"
    },
    {
      "summary": "Proxy interceptors should be able to return both a valid response and an error simultaneously. Currently, when an error occurs, the system immediately returns the error without processing the payload/failure information.",
      "category": "bug",
      "subcategory": "interceptor",
      "apis": [],
      "components": [
        "interceptor",
        "proxy",
        "response-handler"
      ],
      "concepts": [
        "error-handling",
        "response-processing",
        "payload",
        "interceptor-chain"
      ],
      "severity": "medium",
      "userImpact": "Interceptor implementations cannot properly handle scenarios where both a response and error need to be returned together.",
      "rootCause": "The interceptor error handling path immediately returns the error without visiting the payload/failure processing logic.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the bug was resolved to allow interceptors to return both valid response and error.",
      "related": [],
      "keyQuote": "An interceptor can return an error with valid response",
      "number": 1889,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:21:02.663Z"
    },
    {
      "summary": "Go SDK v1.33.0 panics with MD5 crypto error when FIPS 140-only mode is enabled in Go 1.24.1. The panic occurs during worker initialization when computing binary checksums, and setting BuildID workaround fails with timeouts in strict FIPS mode.",
      "category": "bug",
      "subcategory": "fips-compatibility",
      "apis": [],
      "components": [
        "worker",
        "internal-worker",
        "build-id"
      ],
      "concepts": [
        "fips-140",
        "cryptography",
        "md5",
        "compliance",
        "initialization",
        "goroutine"
      ],
      "severity": "high",
      "userImpact": "Users requiring FIPS 140 compliance cannot use the Go SDK with Go 1.24.1 in strict FIPS-only mode, preventing deployment in regulated environments.",
      "rootCause": "getBinaryChecksum() in internal_worker.go uses MD5 hashing which is not allowed in Go's FIPS 140-only mode (GODEBUG=fips140=only)",
      "proposedFix": null,
      "workaround": "Setting BuildID explicitly works with FIPS warnings (fips140=on) but fails with timeouts in strict mode (fips140=only)",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "panic: crypto/md5: use of MD5 is not allowed in FIPS 140-only mode",
      "number": 1887,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:51.113Z"
    },
    {
      "summary": "Failure converter payloads may bypass the payload visitor interceptor if the failure converter is positioned before the payload visitor in the interceptor chain. Documentation should clarify the required ordering of failure converter and payload codec interceptors.",
      "category": "bug",
      "subcategory": "interceptor-ordering",
      "apis": [
        "NewFailureVisitorInterceptor",
        "NewPayloadVisitorInterceptor",
        "NewFailureGRPCClientInterceptor",
        "NewPayloadCodecGRPCClientInterceptor"
      ],
      "components": [
        "failure-converter",
        "payload-codec",
        "interceptor-chain",
        "go.temporal.io/sdk/converter"
      ],
      "concepts": [
        "interceptor-ordering",
        "payload-encoding",
        "failure-handling",
        "codec-chain",
        "visitor-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users with encoded failures and payload visitor interceptors may miss intercepting payloads created by the failure converter due to incorrect interceptor ordering.",
      "rootCause": "Failure converter payloads are not visited by the payload visitor interceptor when the failure converter is positioned after the payload visitor in the chain.",
      "proposedFix": "Document that failure converter should come before payload codec converter in the interceptor chain for both NewFailureVisitorInterceptor/NewPayloadVisitorInterceptor and NewFailureGRPCClientInterceptor/NewPayloadCodecGRPCClientInterceptor.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "failure converter should come before payload codec converter",
      "number": 1886,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:51.796Z"
    },
    {
      "summary": "Request to add serialization context support for codecs and converters. This issue was identified as a duplicate of an existing feature request.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "codec",
        "converter",
        "serialization"
      ],
      "concepts": [
        "serialization context",
        "codec",
        "converter",
        "data handling"
      ],
      "severity": "medium",
      "userImpact": "Users need better context support when implementing custom codecs and converters for data serialization.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #1352. The feature request is being tracked in the referenced issues.",
      "related": [
        1352,
        434
      ],
      "keyQuote": "this looks like a duplicate of https://github.com/temporalio/sdk-go/issues/1352",
      "number": 1884,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:48.209Z"
    },
    {
      "summary": "When a custom logger implementing both `log.Logger` and `log.WithSkipCallers` interfaces is provided to the SDK client, the caller skip count is incorrectly calculated, resulting in the wrong file and line number being reported in logs.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [
        "GetLogger"
      ],
      "components": [
        "logger",
        "log",
        "client"
      ],
      "concepts": [
        "caller-skip",
        "stack-trace",
        "custom-logger",
        "log-formatting",
        "caller-identification"
      ],
      "severity": "medium",
      "userImpact": "Users with custom loggers implementing WithSkipCallers interface get inaccurate caller information in logs, making debugging more difficult.",
      "rootCause": "The WithSkipCallers interface is not independent and requires the logger to also implement WithLogger interface; when only WithSkipCallers is implemented, the skip depth calculation is incorrect.",
      "proposedFix": "Implement both WithSkipCallers and WithLogger interfaces on the custom logger.",
      "workaround": "Implement the WithLogger interface in addition to WithSkipCallers.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by the reporter implementing both WithLogger and WithSkipCallers interfaces, confirming that WithSkipCallers is not independent.",
      "related": [],
      "keyQuote": "Looks like `WithSkipCallers` interface is not independent.",
      "number": 1882,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:37.547Z"
    },
    {
      "summary": "Internal GetSystemInfo calls in multiple locations ignore the ConnectionOptions.GetSystemInfoTimeout value and use the default timeout instead. This causes timeouts even when users configure a custom timeout for system info requests.",
      "category": "bug",
      "subcategory": "connection-options",
      "apis": [],
      "components": [
        "internal_workflow_client",
        "internal_worker",
        "connection"
      ],
      "concepts": [
        "timeout",
        "connection-options",
        "system-info",
        "configuration",
        "initialization"
      ],
      "severity": "high",
      "userImpact": "Users cannot effectively configure GetSystemInfo timeout, causing connection failures despite providing custom timeout values.",
      "rootCause": "Issue #1416 did not apply the user-provided timeout to all callsites where GetSystemInfo is called internally.",
      "proposedFix": "Apply ConnectionOptions.GetSystemInfoTimeout to all internal GetSystemInfo callsites, not just some of them.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified and acknowledged as needing a fix to apply the timeout consistently across all GetSystemInfo callsites.",
      "related": [
        1416
      ],
      "keyQuote": "It appears #1416 didn't apply the timeout to all places get system info is called. We do need to fix this, thanks!",
      "number": 1880,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:36.202Z"
    },
    {
      "summary": "Documentation needed for local activities to advise against using anonymous functions, as they can result in non-deterministic activity types and pose risks from capturing local variables.",
      "category": "docs",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivity"
      ],
      "components": [
        "local-activity",
        "activity-registration",
        "documentation"
      ],
      "concepts": [
        "determinism",
        "function-naming",
        "variable-capture",
        "best-practices",
        "activity-type"
      ],
      "severity": "medium",
      "userImpact": "Users may unknowingly use anonymous functions for local activities, leading to non-deterministic behavior and potential bugs from variable capture.",
      "rootCause": "Lack of explicit documentation warning against anonymous function usage in local activities, despite technical support for it.",
      "proposedFix": "Add documentation clarifying that local activities should not use anonymous functions due to non-deterministic activity types and variable capture risks.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was added to warn against using anonymous functions for local activities.",
      "related": [],
      "keyQuote": "Document that local activities should not use anonymous functions, even though it is technically allowed",
      "number": 1874,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:34.119Z"
    },
    {
      "summary": "SetOnChildWorkflowCompletedListener is not being invoked when child workflows complete with errors in testing scenarios. The listener should catch async child workflow errors but currently fails to trigger.",
      "category": "bug",
      "subcategory": "child-workflow-listener",
      "apis": [
        "SetOnChildWorkflowCompletedListener"
      ],
      "components": [
        "test-framework",
        "child-workflow",
        "listener"
      ],
      "concepts": [
        "event-listener",
        "child-workflow",
        "error-handling",
        "testing",
        "async-execution"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test error handling for child workflows because the completion listener fails to invoke, breaking test assertions and error validation.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Testing an async child workflow error should be catch by `SetOnChildWorkflowCompletedListener`. That is not the case right now.",
      "number": 1869,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:20.905Z"
    },
    {
      "summary": "Activity slots created with ResourceBasedSlotSupplier are not being released after task completion, causing activities to remain stuck in PENDING_ACTIVITY_STATE_SCHEDULED state. The ReleaseSlot method is not implemented in the SlotSupplier interface.",
      "category": "bug",
      "subcategory": "activity-slot-management",
      "apis": [
        "NewResourceBasedSlotSupplier",
        "NewCompositeTuner"
      ],
      "components": [
        "resourcetuner",
        "slot-supplier",
        "activity-executor",
        "worker"
      ],
      "concepts": [
        "resource-management",
        "slot-allocation",
        "activity-scheduling",
        "concurrency-control",
        "tuner"
      ],
      "severity": "high",
      "userImpact": "Activities hang indefinitely in pending state when using ResourceBasedSlotSupplier, preventing workflows from completing and causing applications to stall.",
      "rootCause": "The ReleaseSlot method in the SlotSupplier interface is not implemented in ResourceBasedSlotSupplier, preventing activity slots from being released after completion.",
      "proposedFix": "Implement the ReleaseSlot method in ResourceBasedSlotSupplier to properly release activity slots when tasks complete.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The ReleaseSlot method was implemented in the ResourceBasedSlotSupplier to properly manage slot lifecycle.",
      "related": [],
      "keyQuote": "Activity slots are not released after task is completed. This causes scheduled activities to forever hand in PENDING_ACTIVITY_STATE_SCHEDULED state.",
      "number": 1868,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:23.129Z"
    },
    {
      "summary": "The VisitPayloads function was not visiting repeated Payload fields nested within protobuf messages, causing visitor callbacks to be skipped for these payloads. This prevented proper traversal and mutation of payloads in structures like CountWorkflowExecutionsResponse_AggregationGroup.",
      "category": "bug",
      "subcategory": "payload-visitor",
      "apis": [
        "VisitPayloads"
      ],
      "components": [
        "payload-visitor",
        "proto-traversal",
        "api-conversion"
      ],
      "concepts": [
        "payload-traversal",
        "visitor-pattern",
        "proto-reflection",
        "nested-messages",
        "message-visitation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly visit and transform repeated Payload fields in workflow service responses, limiting payload transformation capabilities.",
      "rootCause": "The VisitPayloads implementation was not recursively visiting Payload fields when they appeared as repeated fields in protobuf messages.",
      "proposedFix": "Update the VisitPayloads visitor to handle repeated Payload fields in all protobuf message types.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in api-go pull request #216 which implemented proper visitor traversal for repeated Payload fields.",
      "related": [],
      "keyQuote": "Visitor should visit this `repeated temporal.api.common.v1.Payload`",
      "number": 1865,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:20.380Z"
    },
    {
      "summary": "The SDK's Payload visitor doesn't properly handle repeated Any fields in protobuf messages. Currently it visits individual Any fields but fails to parse and visit through arrays/maps of Any values, such as the repeated Any field in MultiOperationExecutionFailure_OperationStatus in the Temporal API.",
      "category": "bug",
      "subcategory": "payload-visitor",
      "apis": [
        "VisitPayloads"
      ],
      "components": [
        "payload-visitor",
        "proxy-generator",
        "interceptor"
      ],
      "concepts": [
        "protobuf-any",
        "field-traversal",
        "payload-handling",
        "message-introspection",
        "type-conversion"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly visit and transform payloads nested within repeated Any fields, limiting payload transformation capabilities in complex error detail messages.",
      "rootCause": "The VisitPayloads visitor and proxy generator interceptor lack support for iterating through repeated/array Any fields, only handling singular Any fields.",
      "proposedFix": "Enhance the case handling in the proxy generator interceptor (around line 262 in interceptor.go) to properly traverse and visit repeated Any field elements.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed indicating the enhancement to support repeated Any fields was implemented in the api-go proxy generator.",
      "related": [],
      "keyQuote": "we don't properly visit and parse through a map of Any's, i.e. [this repeated Any field] in our API",
      "number": 1864,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:04.025Z"
    },
    {
      "summary": "The payload visitor in the Go SDK cannot visit Payload objects that are directly marshaled into an Any type at the top level. This feature request asks for adding a missing case to handle this scenario for future API support.",
      "category": "feature",
      "subcategory": "payload-serialization",
      "apis": [
        "VisitPayloads"
      ],
      "components": [
        "payload-visitor",
        "any-type-handling",
        "marshaling"
      ],
      "concepts": [
        "payload-serialization",
        "visitor-pattern",
        "type-handling",
        "protocol-messages",
        "api-extensibility"
      ],
      "severity": "low",
      "userImpact": "Users will be able to visit and mutate Payload objects nested directly within Any types, enabling future API scenarios.",
      "rootCause": "Missing case statement for *common.Payload in visitPayloads() function",
      "proposedFix": "Implement the base case to handle *common.Payload in the visitPayloads() switch statement",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The missing case for visiting Payload objects directly in Any types was implemented",
      "related": [
        202
      ],
      "keyQuote": "When creating a `common.Payload` and marshaling it into an `Any` type, the visitor is not able to visit this scenario, due to a missing `case *common.Payload` in `visitPayloads()`.",
      "number": 1862,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:09.170Z"
    },
    {
      "summary": "Request to add a summary field to Nexus operations, tracking the related feature request in the main features repository.",
      "category": "feature",
      "subcategory": "nexus-operations",
      "apis": [
        "Nexus"
      ],
      "components": [
        "nexus",
        "operations",
        "sdk-go"
      ],
      "concepts": [
        "summary",
        "metadata",
        "operations",
        "nexus-api"
      ],
      "severity": "low",
      "userImpact": "Users would be able to attach summary information to Nexus operations for better documentation and tracking.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed as the enhancement was implemented or resolved",
      "related": [
        610
      ],
      "keyQuote": "Add summary to Nexus operation",
      "number": 1861,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:20:05.057Z"
    },
    {
      "summary": "TestUpdateCallback in the testsuite doesn't provide no-op implementations for optional callbacks, causing nil pointer panics when callbacks aren't supplied. Users need to implement all callbacks even if they only care about some of them, making tests brittle and error messages unhelpful.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "SetUpdateHandler",
        "UpdateWorkflow"
      ],
      "components": [
        "testsuite",
        "workflow-testing",
        "update-handler"
      ],
      "concepts": [
        "callback",
        "test-utilities",
        "nil-safety",
        "optional-parameters",
        "error-handling",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Users testing UpdateWorkflow functionality must implement all callbacks in TestUpdateCallback even when only using some, resulting in confusing nil pointer exceptions.",
      "rootCause": "TestUpdateCallback callbacks are not initialized with no-op defaults, so uninitialized callbacks cause nil pointer dereferences when invoked downstream.",
      "proposedFix": "Provide no-op stub implementations for unspecified callbacks (e.g., OnAccept: func() {}) in TestUpdateCallback, or catch nil callbacks and provide meaningful error messages.",
      "workaround": "Users can manually define empty callback functions for callbacks they don't need to use.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "provide no-op stubs when a particular callback is not provided (eg `OnAccept: func() {}`)",
      "number": 1860,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:50.383Z"
    },
    {
      "summary": "Documentation for WorkflowIdReusePolicy is misleading because it doesn't mention that WorkflowExecutionAlreadyStartedFailure is only returned when the WorkflowExecutionErrorWhenAlreadyStarted option is explicitly set, not by default.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "WorkflowIdReusePolicy",
        "WorkflowExecutionAlreadyStartedFailure",
        "WorkflowExecutionErrorWhenAlreadyStarted",
        "WorkflowIdConflictPolicy"
      ],
      "components": [
        "documentation",
        "client",
        "workflow-execution"
      ],
      "concepts": [
        "workflow-reuse",
        "id-conflict",
        "error-handling",
        "policy-documentation",
        "default-behavior"
      ],
      "severity": "medium",
      "userImpact": "Users reading the WorkflowIdReusePolicy documentation may incorrectly assume WorkflowExecutionAlreadyStartedFailure is returned by default, leading to misunderstanding of actual behavior.",
      "rootCause": "Documentation omits the condition that WorkflowExecutionErrorWhenAlreadyStarted option must be set for the failure to be returned.",
      "proposedFix": "Update WorkflowIdReusePolicy documentation to explicitly mention that WorkflowExecutionAlreadyStartedFailure is only returned when the WorkflowExecutionErrorWhenAlreadyStarted option is set.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to clarify that WorkflowExecutionAlreadyStartedFailure requires the WorkflowExecutionErrorWhenAlreadyStarted option to be set.",
      "related": [],
      "keyQuote": "The doc on `WorkflowIdReusePolicy` is misleading. It does not mention the default behavior is not return WorkflowExecutionAlreadyStartedFailure.",
      "number": 1857,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:51.077Z"
    },
    {
      "summary": "The ExecuteWorkflow API documentation is missing information about the WorkflowExecutionErrorWhenAlreadyStarted error that can be returned when the corresponding option is set.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "client",
        "workflow-execution",
        "api-docs"
      ],
      "concepts": [
        "error-handling",
        "api-documentation",
        "workflow-options",
        "duplicate-workflow"
      ],
      "severity": "low",
      "userImpact": "Developers are not aware of all possible errors that ExecuteWorkflow can return, making error handling incomplete and potentially causing unexpected failures.",
      "rootCause": "API documentation for ExecuteWorkflow does not include WorkflowExecutionErrorWhenAlreadyStarted in the list of possible return errors.",
      "proposedFix": "Update the ExecuteWorkflow API documentation to include WorkflowExecutionErrorWhenAlreadyStarted in the documented error list.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "API documentation was updated to include the missing error in the return errors list.",
      "related": [],
      "keyQuote": "WorkflowExecutionErrorWhenAlreadyStarted error does not mentioned in the API document.",
      "number": 1856,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:51.460Z"
    },
    {
      "summary": "Request to expose root workflow execution context in the Go SDK. References feature request #605 in the features repository, noting that only the workflow info part may need implementation due to how list and describe operations work in the SDK.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-context",
        "workflow-execution",
        "runtime"
      ],
      "concepts": [
        "workflow-execution",
        "root-workflow",
        "execution-context",
        "workflow-info",
        "parent-child-workflows",
        "visibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access root workflow execution context, limiting their ability to understand and work with parent-child workflow relationships in the Go SDK.",
      "rootCause": null,
      "proposedFix": "Expose workflow info related to root workflow execution, potentially following the pattern established in the features repository issue #605.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed to expose root workflow execution context in the SDK.",
      "related": [
        605
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/605. Due to how list and describe work in this SDK, only need to do the workflow info part probably.",
      "number": 1848,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:37.309Z"
    },
    {
      "summary": "A nil pointer timestamp in protobuf maps to Jan 1st, 1970 UTC with IsZero() returning false, causing CLI filters (cardOmitEmpty, omitEmpty) to not properly exclude uninitialized timestamps. This affects both CLI and raw gRPC API users.",
      "category": "bug",
      "subcategory": "timestamp-handling",
      "apis": [
        "AsTime",
        "IsZero",
        "IsValid"
      ],
      "components": [
        "timestamp-conversion",
        "protobuf-mapping",
        "cli-filtering"
      ],
      "concepts": [
        "nil-pointer",
        "timestamp-initialization",
        "zero-value",
        "protobuf-behavior",
        "filtering"
      ],
      "severity": "medium",
      "userImpact": "Users experience incorrect timestamp filtering in CLI commands and APIs when timestamps haven't been initialized, as nil values incorrectly serialize to epoch time.",
      "rootCause": "Protobuf library maps nil timestamps to Jan 1st, 1970 UTC instead of treating them as uninitialized, and IsZero() returns false for these values.",
      "proposedFix": "Check IsValid() before calling AsTime() on timestamps to properly distinguish between uninitialized and epoch-time values.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "(*timestamppb.Timestamp)(nil).AsTime().IsZero() // FALSE!",
      "number": 1846,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:33.261Z"
    },
    {
      "summary": "Built-in query responses should return raw values instead of encoded values to match the behavior defined in the Temporal features specification.",
      "category": "feature",
      "subcategory": "query-responses",
      "apis": [],
      "components": [
        "query",
        "response-encoding"
      ],
      "concepts": [
        "raw-value",
        "encoding",
        "query-response",
        "built-in-queries"
      ],
      "severity": "medium",
      "userImpact": "Users expect built-in query responses to follow the standard raw value encoding pattern established in the Temporal features spec.",
      "rootCause": null,
      "proposedFix": "When #1231 is completed, update built-in queries to return raw values as specified in features/issues/604",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Built-in queries were updated to use RawValue responses after the completion of issue #1231",
      "related": [
        1231,
        604
      ],
      "keyQuote": "When #1231 is done, make sure built-in queries return a raw value",
      "number": 1843,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:34.386Z"
    },
    {
      "summary": "Request for a simple payload wrapper to prevent converters from applying conversion to values, similar to existing functionality in another issue.",
      "category": "feature",
      "subcategory": "payload-conversion",
      "apis": [],
      "components": [
        "converter",
        "payload-handler"
      ],
      "concepts": [
        "payload-wrapping",
        "conversion-bypass",
        "data-serialization",
        "type-handling"
      ],
      "severity": "low",
      "userImpact": "Users need a way to bypass payload conversion for specific values without modifying converter logic.",
      "rootCause": null,
      "proposedFix": "Implement a simple payload wrapper similar to the solution referenced in features issue #603.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #1231 which already contains the requested functionality.",
      "related": [
        1231,
        603
      ],
      "keyQuote": "need a simple payload wrapper that tells converters not to apply conversion",
      "number": 1842,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:17.105Z"
    },
    {
      "summary": "Activities with identical names from different struct methods are treated as the same activity, causing the wrong activity to be executed. The issue occurs when registering multiple activities with the same method name (e.g., PerformActivity from different packages), and the system executes the first registered activity instead of the correct one.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "RegisterActivity"
      ],
      "components": [
        "worker",
        "activity-registry"
      ],
      "concepts": [
        "activity-naming",
        "name-collision",
        "registration-conflict",
        "activity-dispatch",
        "struct-methods"
      ],
      "severity": "medium",
      "userImpact": "Users registering activities with identical method names from different structs will experience unexpected behavior where the wrong activity executes, causing silent failures that are difficult to debug.",
      "rootCause": "The activity registry uses method name as the default activity name without enforcing uniqueness, causing name collisions when multiple structs have methods with the same name.",
      "proposedFix": "Validate if the activity name has already been registered and raise a panic to alert users at startup, similar to the check for empty string names. Alternatively, add a DisableAlreadyRegisteredCheck option to RegisterActivityOptions.",
      "workaround": "Users can either set the activity name manually via RegisterActivityOptions or rename methods to avoid collisions.",
      "resolution": "wontfix",
      "resolutionDetails": "This is intentional behavior by design. The default activity name is the method name, and duplicate registration is ignored by default. Users can set RegisterActivityOptions.DisableAlreadyRegisteredCheck to customize this behavior.",
      "related": [],
      "keyQuote": "the default name of the activity will be the name of the method and the default behaviour is to ignore duplication",
      "number": 1840,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:21.965Z"
    },
    {
      "summary": "Remove support for the old Nexus workflow run operation token format and treat unparsable tokens as handler errors, aligning with the Java SDK implementation.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [],
      "components": [
        "nexus",
        "workflow-run-operation",
        "token-handling"
      ],
      "concepts": [
        "token-format",
        "backward-compatibility",
        "error-handling",
        "nexus-integration"
      ],
      "severity": "medium",
      "userImpact": "Users will need to ensure their Nexus workflow run operations use the current token format, as old format tokens will be treated as handler errors.",
      "rootCause": null,
      "proposedFix": "Remove old Nexus workflow run operation token format support and treat all unparsable tokens as handler errors, similar to the Java SDK approach.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented removal of old token format support and standardized error handling for unparsable tokens to match Java SDK behavior.",
      "related": [
        2423
      ],
      "keyQuote": "Remove old workflow run operation token format support, treat all un-parsable tokens as a handler error.",
      "number": 1839,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:18.281Z"
    },
    {
      "summary": "Non-deterministic workflow code causes the SDK to incorrectly re-send acceptance and completion messages for a previously handled update on subsequent workflow task executions, resulting in invalid state transitions in the History service.",
      "category": "bug",
      "subcategory": "workflow-determinism-updates",
      "apis": [
        "UpdateWithStart",
        "Update"
      ],
      "components": [
        "workflow-task-handler",
        "update-manager",
        "history-service"
      ],
      "concepts": [
        "determinism",
        "non-deterministic-code",
        "update-handling",
        "workflow-state",
        "task-failure",
        "message-idempotency"
      ],
      "severity": "high",
      "userImpact": "Users with non-deterministic workflow code may experience invalid state transitions and incorrect update completions, potentially corrupting workflow execution history.",
      "rootCause": "When non-deterministic workflow code changes execution flow on subsequent workflow task executions, the SDK re-sends acceptance and completion messages for previously handled updates instead of only handling the current update.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1835
      ],
      "keyQuote": "the SDK re-sends acceptance and completion messages for update A, which is incorrect",
      "number": 1838,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:03.786Z"
    },
    {
      "summary": "SDK client connection times out when using 'localhost:7233' but works with '127.0.0.1:7233'. This is a known issue with gRPC Go's DNS resolver behavior on localhost.",
      "category": "bug",
      "subcategory": "client-connection",
      "apis": [
        "client.Dial"
      ],
      "components": [
        "client",
        "grpc-resolver",
        "connection-manager"
      ],
      "concepts": [
        "connection-timeout",
        "localhost-resolution",
        "dns-resolver",
        "grpc",
        "dial-options"
      ],
      "severity": "medium",
      "userImpact": "Users attempting to connect to localhost using the hostname may experience connection timeouts unless they use the IP address workaround.",
      "rootCause": "Known issue with gRPC Go's DNS resolver when resolving 'localhost' as a hostname",
      "proposedFix": "Use 'passthrough:///localhost:7233' schema format instead of just 'localhost:7233'",
      "workaround": "Use '127.0.0.1:7233' instead of 'localhost:7233' for the HostPort parameter",
      "resolution": "wontfix",
      "resolutionDetails": "Issue is rooted in gRPC Go behavior, not Temporal SDK. Closed as the workaround is sufficient and the root cause is external.",
      "related": [],
      "keyQuote": "It is a known issue with the dns resolver in the gRPC Go client. The solution for NewClient() usage suggested is to use passthrough:// as the schema",
      "number": 1834,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:01.594Z"
    },
    {
      "summary": "The doclink tool incorrectly adds an 'Exposed' requirement to the GetHandle method even though the method itself does not require this documentation directive. The -fix flag was adding unnecessary and incorrect documentation.",
      "category": "bug",
      "subcategory": "documentation-generation",
      "apis": [
        "WorkerDeploymentHandle",
        "WorkerDeploymentClient"
      ],
      "components": [
        "doclink-tool",
        "documentation-generator",
        "worker-deployment-client"
      ],
      "concepts": [
        "documentation-generation",
        "api-exposure",
        "code-annotation",
        "tooling",
        "experimental-api"
      ],
      "severity": "medium",
      "userImpact": "Developers using the doclink tool's -fix flag receive incorrect and unnecessary documentation requirements that don't match the actual API structure.",
      "rootCause": "The -fix flag in the doclink tool automatically adds 'Exposed' requirements to methods without proper validation of whether the method actually needs this directive.",
      "proposedFix": "Update the doclink tool's -fix logic to not add 'Exposed' requirements to methods that don't need them, as demonstrated in the related PR #1814.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by updating doclink tool logic to correctly handle 'Exposed' requirements for methods. See PR #1814 for implementation details.",
      "related": [
        1814
      ],
      "keyQuote": "It should not add/require Exposed in GetHandle",
      "number": 1829,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:19:02.860Z"
    },
    {
      "summary": "TestNumPollersCounter metric test fails on stable macOS ARM CI, showing 1 poller instead of expected 2. Failure is specific to CI environment and cannot be reproduced locally.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-poller",
        "ci-infrastructure"
      ],
      "concepts": [
        "metric-validation",
        "flaky-test",
        "ci-environment",
        "platform-specific",
        "concurrency"
      ],
      "severity": "medium",
      "userImpact": "CI test failures block PR merges and reduce confidence in metric accuracy on ARM-based systems.",
      "rootCause": "Likely race condition or timing issue specific to macOS ARM architecture in CI environment affecting poller count metrics",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed between PR #1816 and PR #1826 based on issue timeline",
      "related": [
        1816,
        1826
      ],
      "keyQuote": "metric is only showing up as 1",
      "number": 1827,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:48.182Z"
    },
    {
      "summary": "The gRPC interceptors in api-go should visit payloads and failures not only in the main payload, but also within the status details of gRPC errors, to ensure comprehensive payload and failure transformation across error responses.",
      "category": "feature",
      "subcategory": "grpc-interceptors",
      "apis": [],
      "components": [
        "api-go",
        "grpc-interceptors",
        "payload-visitor",
        "failure-visitor"
      ],
      "concepts": [
        "payload-transformation",
        "error-handling",
        "grpc-status",
        "visitor-pattern",
        "serialization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably transform payloads and failures in gRPC error responses, limiting the ability to apply consistent data handling policies across error cases.",
      "rootCause": "NewPayloadVisitorInterceptor and NewFailureVisitorInterceptor do not unpack and visit payloads/failures within the status details of gRPC errors.",
      "proposedFix": "Modify NewPayloadVisitorInterceptor to visit payloads in status details and NewFailureVisitorInterceptor to visit failures in status details, unpacking any types, visiting, and repacking them.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "NewPayloadVisitorInterceptor should visit payloads in the status details of gRPC errors as well, and NewFailureVisitorInterceptor should do the same for visiting failures.",
      "number": 1825,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:46.804Z"
    },
    {
      "summary": "Expose workflow cancellation cause/reason to users. The WorkflowExecutionCancelRequestedEventAttributes already contains a cause field that should be exposed when workflows receive cancels, and this information should also be available as input when users issue cancels from clients or commands.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [
        "WorkflowExecutionCancelRequestedEventAttributes"
      ],
      "components": [
        "workflow-execution",
        "client",
        "cancellation-handler"
      ],
      "concepts": [
        "cancellation",
        "cause",
        "reason",
        "event-attributes",
        "workflow-lifecycle",
        "client-api"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently see why a workflow was cancelled or provide a cancellation reason when cancelling workflows, limiting debugging and workflow control capabilities.",
      "rootCause": null,
      "proposedFix": "Expose the cause field from WorkflowExecutionCancelRequestedEventAttributes and add it as a parameter in the cancel API.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "WorkflowExecutionCancelRequestedEventAttributes has a cause field that should be exposed when workflows receive cancels",
      "number": 1817,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:49.056Z"
    },
    {
      "summary": "Implement environment-based configuration for the Go SDK to support external client configuration, aligning with cross-SDK standards defined in proposals and features discussions.",
      "category": "feature",
      "subcategory": "external-client-configuration",
      "apis": [],
      "components": [
        "client",
        "configuration",
        "environment"
      ],
      "concepts": [
        "environment-configuration",
        "external-client",
        "sdk-standardization",
        "configuration-management"
      ],
      "severity": "medium",
      "userImpact": "Users need standardized environment-based configuration for initializing Temporal clients across SDK implementations.",
      "rootCause": null,
      "proposedFix": "Implement environment configuration following the external-client-configuration proposal and features issue 441.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support environment-based configuration for external clients.",
      "related": [
        441
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/441 and https://github.com/temporalio/proposals/blob/master/all-sdk/external-client-configuration.md",
      "number": 1815,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:32.150Z"
    },
    {
      "summary": "The doc tool build command fails when function variable declarations have doc comments without 'Exposed as:' annotations. It should ignore variable declarations inside functions instead of requiring the annotation.",
      "category": "bug",
      "subcategory": "build-tooling",
      "apis": [],
      "components": [
        "build-tool",
        "doc-checker",
        "code-generator"
      ],
      "concepts": [
        "documentation",
        "code-generation",
        "validation",
        "annotations",
        "linting"
      ],
      "severity": "low",
      "userImpact": "Developers cannot run the doc tool build command when function-scoped variables have documentation comments, blocking the build process.",
      "rootCause": "The doc tool validator requires 'Exposed as:' annotations on all variables with doc comments, but it should only apply this rule to package-level variables, not function-local declarations.",
      "proposedFix": "Modify the doc tool validation logic to skip variable declarations that are inside function bodies.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The validation was updated to ignore variable declarations within function scopes.",
      "related": [
        1792
      ],
      "keyQuote": "It should ignore variable declarations in functions.",
      "number": 1812,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:35.385Z"
    },
    {
      "summary": "Code generator for payload visiting should walk all proto file descriptors instead of relying on workflow service reachability to ensure all proto messages are caught, including orphaned ones.",
      "category": "feature",
      "subcategory": "code-generation",
      "apis": [],
      "components": [
        "code-generator",
        "payload-visiting",
        "proto-descriptors"
      ],
      "concepts": [
        "code-generation",
        "proto-messages",
        "reachability-analysis",
        "descriptors",
        "orphaned-messages"
      ],
      "severity": "medium",
      "userImpact": "Ensures all proto messages are included in generated code for payload visiting, preventing missed messages that aren't referenced through workflow service.",
      "rootCause": "Current code generator uses recursive reachability from workflow service which misses orphaned proto messages not in that object graph.",
      "proposedFix": "Change code generator to walk file descriptors of entire proto repository instead of relying on workflow service reachability.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1809
      ],
      "keyQuote": "walk the file descriptors of the entire proto repo so we know we catch them all",
      "number": 1811,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:33.269Z"
    },
    {
      "summary": "Change how application errors are converted to Nexus HandlerError to use non-retryable internal errors instead of the current approach. This is a breaking change required before the Go SDK reaches GA and depends on server version 1.27.0.",
      "category": "feature",
      "subcategory": "nexus-error-handling",
      "apis": [],
      "components": [
        "nexus",
        "error-handling",
        "application-error-conversion"
      ],
      "concepts": [
        "error-conversion",
        "retryability",
        "nexus-integration",
        "handler-error",
        "internal-errors",
        "ga-requirements"
      ],
      "severity": "high",
      "userImpact": "Changes how application errors are handled in Nexus handlers, affecting error propagation and retry behavior for Nexus-integrated workflows.",
      "rootCause": "Current error conversion approach does not properly map application errors to non-retryable internal errors in Nexus context.",
      "proposedFix": "Modify the application error to Nexus HandlerError conversion logic to use non-retryable internal errors.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The conversion logic was updated to use non-retryable internal errors for Nexus HandlerError, completed in relation to server 1.27.0 release and Go SDK GA timeline.",
      "related": [
        1802
      ],
      "keyQuote": "Needs to be done before the Go SDK goes GA and after the server 1.27.0 release.",
      "number": 1810,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:19.306Z"
    },
    {
      "summary": "Add a test to verify that the payload proxy visits all payloads even when they are not reachable by the workflow service. The test should confirm payload encoding across existing integration tests rather than creating a contrived test case.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "proxy",
        "payload-encoder",
        "test-framework"
      ],
      "concepts": [
        "payload-discovery",
        "payload-encoding",
        "test-coverage",
        "reachability"
      ],
      "severity": "low",
      "userImpact": "Ensures comprehensive testing of payload handling in the proxy to prevent missed payloads in edge cases.",
      "rootCause": null,
      "proposedFix": "Add a test that confirms payload encoding in all existing integration tests rather than building a contrived test, using different payload discovery/walking approaches.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Completed in api-go PR #211",
      "related": [],
      "keyQuote": "Add a test that somehow makes sure every payload is visited even if it's not reachable from workflow service.",
      "number": 1809,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:20.356Z"
    },
    {
      "summary": "User requests the ability to configure extra log fields for SDK workflow and activity logs at runtime, since business-related values are only known during workflow/activity creation, not at worker initialization.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [
        "StartWorkflowOptions",
        "ActivityOptions",
        "GetLogger"
      ],
      "components": [
        "logger",
        "interceptor",
        "activity-executor",
        "workflow-executor"
      ],
      "concepts": [
        "logging",
        "context-propagation",
        "interceptor",
        "runtime-configuration",
        "activity-creation",
        "workflow-creation",
        "business-fields"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily attach business-related log fields to SDK-generated logs for workflows and activities without duplicating error logs or querying external systems.",
      "rootCause": "SDK internal logs are generated during task execution without access to runtime values provided during workflow/activity creation; interceptors can only be registered at worker initialization.",
      "proposedFix": "Add support for configuring extra log fields via StartWorkflowOptions and ActivityOptions, or enhance interceptor capabilities to access runtime values during GetLogger calls.",
      "workaround": "Users can implement custom log statements in their own interceptors, but this results in duplicate error logs and requires external system queries for activity contexts.",
      "resolution": "duplicate",
      "resolutionDetails": "Issue was marked as duplicate of #829, which addresses the broader feature of customizing internal logger use on a per-workflow basis.",
      "related": [
        829
      ],
      "keyQuote": "For those two log situations, you should consider using your own log statements in your own interceptor instead of relying on debug logs from the internals of the SDK.",
      "number": 1808,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:18.444Z"
    },
    {
      "summary": "User reported that sdk-go v1.32.1 is incompatible with api-go v1.44.0 due to removed symbols. The issue was clarified to be related to using Temporal Server as a library rather than an SDK compatibility problem, with the actual conflict occurring in server's OIDC codec-server implementation.",
      "category": "question",
      "subcategory": "dependency-compatibility",
      "apis": [],
      "components": [
        "server-api",
        "codec-server",
        "oidc-authentication"
      ],
      "concepts": [
        "dependency-versioning",
        "api-breaking-changes",
        "library-usage",
        "authentication",
        "oidc"
      ],
      "severity": "medium",
      "userImpact": "Users attempting to use Temporal Server as a library alongside their SDK code encounter compilation errors when api-go versions diverge from server's pinned versions.",
      "rootCause": "The user was attempting to use go.temporal.io/server programmatically as a library alongside SDK code, but server requires exact API versions matching its go.mod. The actual incompatibility was in server's OIDC codec-server implementation, not the SDK itself.",
      "proposedFix": "Implement OIDC logic without using Temporal Server as a library, or use a separate OSS solution for OIDC functionality instead of bundling server code.",
      "workaround": "Keep api-go pinned to the version matching the server's go.mod requirements (v1.43.2 in this case), or avoid using server as a library in projects also using the SDK.",
      "resolution": "invalid",
      "resolutionDetails": "Issue was a misunderstanding - the problem was not with sdk-go itself but with attempting to use server as a library with incompatible API versions. Users should not mix server library usage with SDK in the same project.",
      "related": [],
      "keyQuote": "If you are using the server programmatically as a library, you must have the exact versions of SDK and API that are in the server's go.mod.",
      "number": 1805,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:03.348Z"
    },
    {
      "summary": "Add `Patched()` and `DeprecatePatch()` APIs to the Go SDK for better workflow versioning support, with potential deprecation of the `GetVersion` API.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "Patched",
        "DeprecatePatch",
        "GetVersion"
      ],
      "components": [
        "workflow-execution",
        "versioning-system",
        "api-design"
      ],
      "concepts": [
        "versioning",
        "patches",
        "workflow-compatibility",
        "deprecation",
        "memoization"
      ],
      "severity": "medium",
      "userImpact": "Enables developers to manage workflow changes with improved APIs for patching and deprecating versions, aligned with Temporal Core implementation.",
      "rootCause": null,
      "proposedFix": "Implement `Patched(patchId, memoized): boolean` and `DeprecatePatch(patchId, memoized): boolean` APIs following Core's implementation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        591
      ],
      "keyQuote": "Add the `Patched(patchId, memoized): boolean` and `DeprecatePatch(patchId, memoized): boolean` APIs. Refer to Core's implementation (once it is ready).",
      "number": 1796,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:05.894Z"
    },
    {
      "summary": "Request to allow customization of the dev server UI port in the Go SDK. This is a feature enhancement to provide developers with more flexibility when configuring the Temporal development server.",
      "category": "feature",
      "subcategory": "dev-server",
      "apis": [],
      "components": [
        "dev-server",
        "ui",
        "configuration"
      ],
      "concepts": [
        "customization",
        "port-configuration",
        "development-environment",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers cannot customize the dev server UI port, limiting flexibility in local development environments.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented customization of dev server UI port as requested in the feature enhancement.",
      "related": [
        588
      ],
      "keyQuote": "Allow customization of dev server UI port",
      "number": 1788,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:18:03.348Z"
    },
    {
      "summary": "Implement special behavior for Temporal built-in prefixes in the Go SDK to align with features defined in the cross-repository specification.",
      "category": "feature",
      "subcategory": "built-in-prefixes",
      "apis": [],
      "components": [
        "sdk-core",
        "naming-conventions"
      ],
      "concepts": [
        "prefix-handling",
        "built-in-behavior",
        "naming-standards",
        "feature-parity"
      ],
      "severity": "low",
      "userImpact": "Users will have consistent and predictable behavior when working with Temporal's built-in prefixed names across the Go SDK.",
      "rootCause": null,
      "proposedFix": "Align Go SDK implementation with feature specifications defined in temporalio/features#576",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Most built-in prefix behaviors were already implemented in the Go SDK; this issue tracked alignment with cross-repository feature specifications.",
      "related": [
        576
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/576 (note most already solved in Go)",
      "number": 1779,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:50.539Z"
    },
    {
      "summary": "Worker Deployment API interfaces are being renamed and refactored to reflect the embedding of the Rollout API within a Deployment resource.",
      "category": "feature",
      "subcategory": "worker-deployment-api",
      "apis": [
        "WorkerDeployment"
      ],
      "components": [
        "worker",
        "deployment-api",
        "rollout-api"
      ],
      "concepts": [
        "api-design",
        "interface-refactoring",
        "deployment-management",
        "rollout-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users of the Worker Deployment API will need to update their code to use the renamed interfaces.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Some interfaces of the Worker Deployment API are changing to reflect the embedding of the Rollout API within a Deployment.",
      "number": 1778,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:48.363Z"
    },
    {
      "summary": "Add support for the ramp API to Worker Deployments, enabling graceful transitions of Workflows and Activity tasks between two implementations.",
      "category": "feature",
      "subcategory": "worker-deployments",
      "apis": [],
      "components": [
        "worker",
        "deployment"
      ],
      "concepts": [
        "ramp",
        "graceful-transition",
        "workflow-execution",
        "activity-execution",
        "deployment-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users can smoothly transition running workflows and activities between different implementations without disruption.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A ramp gracefully transitions Workflows and Activity tasks between two implementations.",
      "number": 1777,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:50.483Z"
    },
    {
      "summary": "Request to add a flag in the update handler to indicate when handling is from a re-apply operation, addressing feature request from temporalio/features#564.",
      "category": "feature",
      "subcategory": "update-handler",
      "apis": [
        "UpdateHandler"
      ],
      "components": [
        "worker",
        "update-handler",
        "replay"
      ],
      "concepts": [
        "re-apply",
        "update-handling",
        "state-management",
        "handler-context"
      ],
      "severity": "medium",
      "userImpact": "Users need a way to distinguish between initial update handling and re-applied updates, enabling proper state management logic.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        564
      ],
      "keyQuote": "Provide flag to tell the update handler that the handling is from a re-apply",
      "number": 1776,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:37.645Z"
    },
    {
      "summary": "The doclink tool is generating duplicate \"Exposed as\" docstrings when processing aliases. Running the tool with the -fix flag causes these duplicates to appear instead of a single docstring.",
      "category": "bug",
      "subcategory": "code-generation",
      "apis": [],
      "components": [
        "doclink-tool",
        "alias-processing"
      ],
      "concepts": [
        "code-generation",
        "documentation",
        "duplication",
        "build-tools"
      ],
      "severity": "medium",
      "userImpact": "Developers using the doclink tool with aliases get malformed documentation output that requires manual cleanup.",
      "rootCause": "The doclink tool is not deduplicating \"Exposed as\" docstrings when processing aliases.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        1770
      ],
      "keyQuote": "Duplicate docstrings are being generated.",
      "number": 1774,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:34.463Z"
    },
    {
      "summary": "The versioning override API in UpdateWorkflowExecutionOptions incorrectly provides a pointer to an empty Deployment struct instead of a nil pointer to set AutoUpgrade behavior, causing the server to fail the request.",
      "category": "bug",
      "subcategory": "versioning-override",
      "apis": [
        "UpdateWorkflowExecutionOptions"
      ],
      "components": [
        "versioning-override",
        "deployment-proto",
        "api-implementation"
      ],
      "concepts": [
        "versioning",
        "autoupgrade",
        "deployment",
        "proto-handling",
        "nil-pointer"
      ],
      "severity": "high",
      "userImpact": "Users cannot successfully use the versioning override API to set AutoUpgrade behavior as requests fail at the server.",
      "rootCause": "SDK provides a pointer to an empty Deployment struct instead of a nil pointer, which the server interprets differently.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed by the author after confirmation.",
      "related": [],
      "keyQuote": "the SDK provides a pointer to an empty Deployment struct. The result is that the server always fails the request.",
      "number": 1764,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:36.850Z"
    },
    {
      "summary": "Request to provide access to a Temporal client from within activity execution context. This would enable activities to interact with the Temporal system by exposing a function like GetClient(context.Context) or GetClientInActivity(context.Context).",
      "category": "feature",
      "subcategory": "client-access",
      "apis": [
        "GetClient"
      ],
      "components": [
        "activity",
        "client",
        "context"
      ],
      "concepts": [
        "client-access",
        "activity-context",
        "temporal-client",
        "circular-imports",
        "api-design"
      ],
      "severity": "medium",
      "userImpact": "Users currently cannot access a Temporal client from within activity code to perform additional Temporal operations.",
      "rootCause": null,
      "proposedFix": "Implement a GetClient(context.Context) function in the activity package, or alternatively a GetClientInActivity(context.Context) function in the client package to avoid circular import issues.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature request was implemented, allowing activities to access the Temporal client from activity context.",
      "related": [
        203
      ],
      "keyQuote": "Allow users to access Temporal client from within an activity. This is likely a `GetClient(context.Context)` function in the `activity` package",
      "number": 1761,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:21.180Z"
    },
    {
      "summary": "Users need a type-safe, workflow-scoped local variable mechanism to store values that persist only within a specific workflow execution. The proposal suggests a `workflow.LocalVar[T]` API with Get/Set methods that provide sugar over context values.",
      "category": "feature",
      "subcategory": "workflow-context",
      "apis": [],
      "components": [
        "workflow-context",
        "context-values"
      ],
      "concepts": [
        "workflow-scoped-storage",
        "type-safety",
        "context-values",
        "workflow-local-state"
      ],
      "severity": "medium",
      "userImpact": "Provides developers with a cleaner, type-safe way to store and access workflow-local data without manual context value management.",
      "rootCause": null,
      "proposedFix": "Implement a `workflow.LocalVar[T]` generic type with `Get(ctx)` and `Set(ctx, value)` methods as type-safe wrappers around context values.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        571
      ],
      "keyQuote": "A user can have `var myValue workflow.LocalVar[string]` with `Get(ctx)` and `Set(ctx, value)` methods for workflow-specific values",
      "number": 1760,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:24.048Z"
    },
    {
      "summary": "User requests the ability to configure activity error logging level from ERROR to WARN, since many activity errors are retryable and not critical. A comment notes that ApplicationErrorCategoryBenign can already downgrade to DEBUG level.",
      "category": "feature",
      "subcategory": "activity-error-handling",
      "apis": [],
      "components": [
        "activity-executor",
        "logger",
        "error-handler"
      ],
      "concepts": [
        "error-logging",
        "log-level",
        "error-severity",
        "retry",
        "configuration",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Users who monitor errors as critical incidents are unable to differentiate between retryable activity errors and genuinely critical errors, causing alert fatigue.",
      "rootCause": "Activity errors are logged at ERROR level unconditionally, preventing users from treating retryable errors as lower severity.",
      "proposedFix": "Make activity error logging level configurable in the SDK, or continue documenting the ApplicationErrorCategoryBenign approach for downgrading severity.",
      "workaround": "Use ApplicationError with Category set to ApplicationErrorCategoryBenign to downgrade log severity to DEBUG.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "many errors in activity are retryable that are not too critical for us. If you want to keep it error, can we make it configuable on SDK that we can change to other level like \"Warn\"?",
      "number": 1759,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:22.520Z"
    },
    {
      "summary": "Documentation for StartWorkflowOptions on pkg.go.dev still references the deprecated WithStartOperation from the old Update-with-Start API. The docs should be updated to remove this outdated reference and clarify that WorkflowIDConflictPolicy is required.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "StartWorkflowOptions"
      ],
      "components": [
        "documentation",
        "godoc",
        "workflow-options"
      ],
      "concepts": [
        "documentation",
        "api-reference",
        "deprecation",
        "configuration",
        "workflow-creation"
      ],
      "severity": "low",
      "userImpact": "Users consulting the pkg.go.dev documentation may encounter outdated API references that no longer apply to the current SDK.",
      "rootCause": "Documentation was not updated when the Update-with-Start API was changed.",
      "proposedFix": "Remove WithStartOperation reference from StartWorkflowOptions documentation and add clarification that WorkflowIDConflictPolicy is required.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation updated to remove outdated WithStartOperation reference and clarify WorkflowIDConflictPolicy requirement.",
      "related": [],
      "keyQuote": "WithStartOperation from the old Update-with-Start API. Also, mention that WorkflowIDConflictPolicy is required.",
      "number": 1757,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:08.308Z"
    },
    {
      "summary": "API documentation links are malformed in the Go SDK docs, preventing proper link rendering on pkg.go.dev. The documentation should follow Go's documentation link syntax guidelines to create valid references between API elements.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "UpdateWorkerVersioningRules",
        "UpdateWithStartWorkflow",
        "NewWithStartWorkflowOperation"
      ],
      "components": [
        "api-docs",
        "godoc",
        "internal",
        "client"
      ],
      "concepts": [
        "documentation-links",
        "api-reference",
        "link-syntax",
        "godoc-rendering"
      ],
      "severity": "low",
      "userImpact": "Users reading the Go SDK API documentation on pkg.go.dev cannot navigate between related API elements due to broken documentation links.",
      "rootCause": "Documentation strings use incorrect link syntax that is not compatible with Go's documentation link renderer, as outlined in the godoc-tricks guidelines.",
      "proposedFix": "Replace malformed links with correct Go documentation link syntax following https://pkg.go.dev/github.com/fluhus/godoc-tricks#hdr-Documentation_Links-Links",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed after documentation links were corrected to follow Go's proper documentation link syntax",
      "related": [],
      "keyQuote": "We should do a pass replacing malformed links with correct links.",
      "number": 1756,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:06.313Z"
    },
    {
      "summary": "SDK v1.30.1 fails to compile due to missing Failure field on HandlerError and UnsuccessfulOperationError types from the nexus-rpc/sdk-go dependency. The issue was caused by breaking changes in the nexus dependency that weren't properly handled in the SDK.",
      "category": "bug",
      "subcategory": "nexus-operations",
      "apis": [],
      "components": [
        "nexus-task-handler",
        "error-handling"
      ],
      "concepts": [
        "compilation-error",
        "dependency-breaking-change",
        "nexus-rpc",
        "error-types"
      ],
      "severity": "high",
      "userImpact": "Users cannot compile projects using SDK v1.30.1 due to undefined field errors in the nexus task handler.",
      "rootCause": "Breaking changes in the nexus-rpc/sdk-go dependency (specifically the Failure field removal from HandlerError and UnsuccessfulOperationError types) were not accounted for in the SDK code.",
      "proposedFix": "Upgrade to Go SDK v1.31.0 which fixes the compilation issue.",
      "workaround": "Downgrade nexus-rpc/sdk-go to v0.0.12 using 'go get github.com/nexus-rpc/sdk-go@v0.0.12'",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in Go SDK v1.31.0 release",
      "related": [],
      "keyQuote": "Go SDK 1.31.0 was just released which fixes this complication issue.",
      "number": 1752,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:17:09.691Z"
    },
    {
      "summary": "User requests an official release of the workflowcheck tool, which hasn't been tagged for 9 months. A recent commit fixes handling of Go 1.22 alias types that should be included in the next release.",
      "category": "feature",
      "subcategory": "workflowcheck-release",
      "apis": [],
      "components": [
        "workflowcheck",
        "go-tooling"
      ],
      "concepts": [
        "release-management",
        "go-compatibility",
        "tooling",
        "version-tagging"
      ],
      "severity": "low",
      "userImpact": "Users cannot access the latest workflowcheck tool with bug fixes and Go 1.22 compatibility improvements without building from source.",
      "rootCause": null,
      "proposedFix": "Release a new version of workflowcheck including the Go 1.22 alias type handling fix.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "New workflowcheck release v0.3.0 was tagged by the team shortly after the request.",
      "related": [],
      "keyQuote": "Workflowcheck hasn't had a tagged release for ~ 9 months. Is there one planned soon?",
      "number": 1740,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:51.857Z"
    },
    {
      "summary": "Worker Versioning-3 requires workflows to specify versioning behavior (either via default or per-workflow option), but the SDK doesn't validate this at registration time. This proposal adds registration-time validation to fail early when versioning behavior is missing, and removes the programmatic API for setting versioning behavior.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "worker",
        "workflow-registration",
        "versioning"
      ],
      "concepts": [
        "workflow-versioning",
        "build-id-migration",
        "registration-validation",
        "behavior-specification"
      ],
      "severity": "medium",
      "userImpact": "Workflows without specified versioning behavior will fail at registration time rather than failing later at runtime, providing clearer error messages during development.",
      "rootCause": "The SDK lacks validation at workflow registration time to enforce that versioning behavior is specified either via worker default or per-workflow option.",
      "proposedFix": "Add a check at workflow type registration that fails when there is no default versioning behavior and no value provided for that workflow. Remove the programmatic API for setting versioning behavior to simplify the implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented registration-time validation to require versioning behavior specification and removed the programmatic API for setting versioning behavior.",
      "related": [],
      "keyQuote": "Add a check at workflow type registration to fail registration when there is no default, and no value provided.",
      "number": 1739,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:53.493Z"
    },
    {
      "summary": "WorkflowTestSuite.UpdateWorkflow should auto-generate an update ID when none is provided, matching the behavior of WorkflowClient. Currently it treats missing update IDs as empty strings, creating a discrepancy.",
      "category": "other",
      "subcategory": "test-framework",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "WorkflowTestSuite",
        "test-utilities",
        "workflow-update"
      ],
      "concepts": [
        "update-id",
        "test-parity",
        "client-consistency",
        "auto-generation",
        "workflow-updates"
      ],
      "severity": "medium",
      "userImpact": "Developers using WorkflowTestSuite.UpdateWorkflow experience inconsistent behavior compared to production WorkflowClient, leading to confusion and potential test gaps.",
      "rootCause": "WorkflowTestSuite.UpdateWorkflow does not implement the same auto-generation logic for update IDs that WorkflowClient provides.",
      "proposedFix": "Implement update ID auto-generation in WorkflowTestSuite.UpdateWorkflow to match WorkflowClient behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "WorkflowTestSuite.UpdateWorkflow was updated to auto-generate update IDs when none is provided, ensuring parity with WorkflowClient.",
      "related": [],
      "keyQuote": "WorkflowTestSuite.UpdateWorkflow should generate an update ID if none is set like the WorkflowClient",
      "number": 1737,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:54.879Z"
    },
    {
      "summary": "Session workers experience significant delays (~120 seconds) before executing activities when MaxConcurrentActivityExecutionSize is set to 1, introduced after the worker tuner changes in SDK v1.29.0. Every other activity in a session is delayed despite completing quickly.",
      "category": "bug",
      "subcategory": "session-worker",
      "apis": [
        "EnableSessionWorker",
        "MaxConcurrentActivityExecutionSize"
      ],
      "components": [
        "worker",
        "session-worker",
        "activity-executor",
        "tuner"
      ],
      "concepts": [
        "activity-execution",
        "concurrency-limit",
        "session-management",
        "scheduling-delay",
        "tuner-configuration"
      ],
      "severity": "high",
      "userImpact": "Session-based workflows experience ~120 second delays in activity execution when using a single activity concurrency limit, significantly impacting workflow performance.",
      "rootCause": "Worker tuner introduction in commit a1d05a6f990da31143a702806e5915ef5a860e59 (PR #1546) caused improper slot allocation for session worker activities with MaxConcurrentActivityExecutionSize set to 1.",
      "proposedFix": "Increase MaxConcurrentActivityExecutionSize to 3 or configure a fixed-size tuner with 3 slots for activity tasks.",
      "workaround": "Set MaxConcurrentActivityExecutionSize to 3 or use a fixed-size tuner configuration with 3 slots instead of 1.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        1546
      ],
      "keyQuote": "Every other activity in the session takes ~120 seconds to complete... Despite the worker completing the activity quickly (under a second), it delays starting execution.",
      "number": 1732,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:40.643Z"
    },
    {
      "summary": "The update-with-start API required confusing double calls to ExecuteWorkflow with different options. A simplified single API function was requested and subsequently implemented in v1.31.0.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "ExecuteWorkflow",
        "UpdateWithStartWorkflow",
        "NewUpdateWithStartWorkflowOperation"
      ],
      "components": [
        "client",
        "workflow-execution",
        "update-api"
      ],
      "concepts": [
        "api-simplification",
        "workflow-idempotency",
        "conflict-policy",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers can now use a single, intuitive UpdateWithStartWorkflow API instead of calling ExecuteWorkflow twice with specific options.",
      "rootCause": "The original API design required understanding WorkflowIDConflictPolicy and multiple ExecuteWorkflow calls to accomplish a single logical operation.",
      "proposedFix": "Provide a single dedicated function (client.UpdateWithStartWorkflow) that hides the implementation details of update-with-start operations.",
      "workaround": "Call ExecuteWorkflow twice: once with USE_EXISTING conflict policy, then with WithStartOperation set to NewUpdateWithStartWorkflowOperation.",
      "resolution": "fixed",
      "resolutionDetails": "Simplified update-with-start API was released in v1.31.0 with a dedicated UpdateWithStartWorkflow method.",
      "related": [
        1579
      ],
      "keyQuote": "Needing two consecutive calls to ExecuteWorkflow to exercise the update-with-start functionality is confusing and violates the principle of least surprise.",
      "number": 1728,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:39.441Z"
    },
    {
      "summary": "ChildWorkflowExecutionError has private fields that users cannot access. The request is to add public accessor methods to expose these fields.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "ChildWorkflowExecutionError"
      ],
      "components": [
        "error-handling",
        "child-workflow",
        "api-accessors"
      ],
      "concepts": [
        "encapsulation",
        "accessor-methods",
        "error-details",
        "public-api",
        "user-access"
      ],
      "severity": "low",
      "userImpact": "Users cannot inspect details of child workflow execution errors, limiting debugging and error handling capabilities.",
      "rootCause": null,
      "proposedFix": "Add accessor methods to ChildWorkflowExecutionError to expose private fields",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Accessors were added to ChildWorkflowExecutionError to expose previously private fields",
      "related": [
        496
      ],
      "keyQuote": "ChildWorkflowExecutionError has private fields that users have no way to access today",
      "number": 1725,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:35.682Z"
    },
    {
      "summary": "Worker cache discards workflows after query processing, requiring expensive replays on subsequent queries. Request to add a config option to keep queried workflows in the sticky cache for better performance.",
      "category": "feature",
      "subcategory": "workflow-cache",
      "apis": [],
      "components": [
        "worker",
        "cache",
        "query-handler",
        "task-handler"
      ],
      "concepts": [
        "caching",
        "sticky-assignment",
        "query-processing",
        "workflow-replay",
        "performance-optimization"
      ],
      "severity": "medium",
      "userImpact": "Users with encryption/offloading codecs experience expensive replay overhead on each workflow query, degrading query performance.",
      "rootCause": "Query tasks cannot set sticky cache attribute on the server side, preventing workers from keeping queried workflows in cache",
      "proposedFix": "Add a config property to allow workflows that are queried to be inserted into the worker sticky cache",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        4463
      ],
      "keyQuote": "Because replays can get a bit expensive, especially if encryption/offloading codecs are used (which we do), it would be nice if querying a workflow would add it to the worker sticky cache.",
      "number": 1716,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:24.625Z"
    },
    {
      "summary": "Add VersioningOverride to StartWorkflowExecutionRequest to allow specifying target versioning information when creating a workflow, overriding the current default. This is needed for canary tests in the versioning-3 branch.",
      "category": "feature",
      "subcategory": "versioning",
      "apis": [
        "StartWorkflowExecutionRequest"
      ],
      "components": [
        "workflow-client",
        "versioning-system",
        "request-builder"
      ],
      "concepts": [
        "versioning",
        "workflow-execution",
        "canary-testing",
        "compatibility",
        "override",
        "request-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users can now specify versioning overrides when creating workflows, enabling better testing and control over versioning behavior.",
      "rootCause": null,
      "proposedFix": "Add VersioningOverride field to StartWorkflowExecutionRequest as detailed in temporalio/api pull request 477",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Merged in versioning-3 branch",
      "related": [
        477
      ],
      "keyQuote": "For canary tests in versioning-3 we need to specify target versioning information in the options when creating a workflow",
      "number": 1715,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:21.869Z"
    },
    {
      "summary": "Versioning-3 experimental API introduces new versioning_info metadata that needs to be exposed in WorkflowExecutionInfo. The Go SDK exposes raw protobufs for WorkflowExecutionInfo, and this feature would make the new versioning metadata accessible to users and the CLI.",
      "category": "feature",
      "subcategory": "versioning",
      "apis": [
        "WorkflowExecutionInfo"
      ],
      "components": [
        "workflow-execution",
        "protobuf-bindings",
        "cli"
      ],
      "concepts": [
        "versioning",
        "metadata",
        "workflow-info",
        "api-exposure"
      ],
      "severity": "medium",
      "userImpact": "Users and CLI tools need access to versioning metadata for workflow executions to support versioning-3 experimental features.",
      "rootCause": null,
      "proposedFix": "Expose versioning_info metadata through WorkflowExecutionInfo in the Go SDK.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "The Go SDK exposes raw protobufs directly, so users and CLI can access the metadata without additional SDK changes needed.",
      "related": [
        472
      ],
      "keyQuote": "The go sdk just exposes raw protobufs for WorkflowExecutionInfo, and the CLI just uses them directly.",
      "number": 1714,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:20.685Z"
    },
    {
      "summary": "Add support for the Deployment API, a low-level CRUD interface for managing worker deployments and enabling Worker versioning-3. This API allows direct control over deployment targets and workflow routing across worker pools.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "worker",
        "deployment-manager",
        "versioning-system"
      ],
      "concepts": [
        "deployment",
        "versioning",
        "worker-pool",
        "workflow-routing",
        "api-design"
      ],
      "severity": "medium",
      "userImpact": "Enables users to implement advanced worker versioning strategies and manage deployment routing for workflows across multiple worker pools.",
      "rootCause": null,
      "proposedFix": "Implement the Deployment API as defined in https://github.com/temporalio/api/pull/479 to provide CRUD operations for deployments and deployment target control.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Deployment API support was implemented in the Go SDK as part of the worker versioning-3 effort.",
      "related": [],
      "keyQuote": "The Deployment API is a low-level API that enables Worker versioning-3 by providing a CRUD interface to manage deployments.",
      "number": 1713,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:07.041Z"
    },
    {
      "summary": "Add support for the UpdateWorkflowExecutionOptions API in SDK-go to enable external tools to override versioning attributes for existing workflows. This is a prerequisite for CLI support.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "UpdateWorkflowExecutionOptions"
      ],
      "components": [
        "workflow",
        "versioning",
        "sdk-api"
      ],
      "concepts": [
        "versioning",
        "workflow-execution",
        "external-override",
        "attributes",
        "extensibility"
      ],
      "severity": "medium",
      "userImpact": "Enables external tools and CLI to modify workflow versioning attributes after execution has started.",
      "rootCause": null,
      "proposedFix": "Implement UpdateWorkflowExecutionOptions API support in SDK-go following the API definition from https://github.com/temporalio/api/pull/466",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented and merged in versioning-3 branch",
      "related": [
        466
      ],
      "keyQuote": "A new API has been added that enables external tools to override versioning attributes for an existing workflow.",
      "number": 1712,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:05.780Z"
    },
    {
      "summary": "When a worker is stopped during workflow task execution, the ProcessWorkflowTask continues sending heartbeats and blocks further workflow execution instead of being stopped. This causes workflows with local activities to hang when the worker is restarted.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [
        "ExecuteLocalActivity",
        "Worker.Stop()"
      ],
      "components": [
        "worker",
        "workflow-task-processor",
        "local-activity-worker"
      ],
      "concepts": [
        "graceful-shutdown",
        "heartbeat",
        "local-activity",
        "task-lifecycle",
        "worker-stop",
        "blocking"
      ],
      "severity": "high",
      "userImpact": "Users experience workflow execution hangs and blocked local activity processing when restarting workers, particularly affecting long-running workflows with multiple local activities.",
      "rootCause": "ProcessWorkflowTask is not properly stopped when worker.Stop() is called, allowing it to continue sending heartbeats even after the worker is no longer processing tasks.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue #1875 addressed graceful shutdown and WorkerStopTimeout, with additional fixes for the heartbeating issue during worker stop.",
      "related": [
        1875
      ],
      "keyQuote": "ProcessWorkflowTask will remain active, though, and will keep sending heartbeats until either a network timeout occurs or the history size limit is reached.",
      "number": 1706,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:16:10.092Z"
    },
    {
      "summary": "User requests ability to specify custom RequestId for SignalWorkflow to enable server-side deduplication. Currently RequestId is always generated as UUID, but server-side deduplication by RequestId is not a stable feature.",
      "category": "feature",
      "subcategory": "signal-deduplication",
      "apis": [
        "SignalWorkflow"
      ],
      "components": [
        "workflow-client",
        "signal-handler"
      ],
      "concepts": [
        "deduplication",
        "request-id",
        "idempotency",
        "signal-delivery",
        "server-side-deduplication"
      ],
      "severity": "medium",
      "userImpact": "Users cannot implement server-side signal deduplication and must rely on application-level deduplication logic.",
      "rootCause": "RequestId is hardcoded to uuid.New() in SignalWorkflow implementation, with no option for user override.",
      "proposedFix": "Add an option parameter to override RequestId in each method, allowing users to specify their own identifier instead of generated UUID.",
      "workaround": "Put your own ID in the signal input and deduplicate in the workflow",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        4021
      ],
      "keyQuote": "An option to override the RequestId in each method, allowing users to specify their own identifier instead of a generated UUID.",
      "number": 1705,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:52.306Z"
    },
    {
      "summary": "Concurrent map writes cause fatal error when multiple tests with t.Parallel() share a single TestActivityEnvironment. The activities map is not thread-safe and needs synchronization protection.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "testWorkflowEnvironmentImpl",
        "TestActivityEnvironment",
        "test-suite"
      ],
      "concepts": [
        "concurrency",
        "data-race",
        "thread-safety",
        "map-synchronization",
        "parallel-testing",
        "goroutines"
      ],
      "severity": "high",
      "userImpact": "Tests using t.Parallel() crash with fatal error when multiple test cases share the same activity test environment.",
      "rootCause": "The activities map in testWorkflowEnvironmentImpl is accessed without synchronization, causing concurrent map writes when setActivityHandle is called from multiple goroutines.",
      "proposedFix": "Protect map writes with env.locker.Lock()/Unlock() in setActivityHandle method, or use sync.Map instead of map[string]*testActivityHandle.",
      "workaround": "Create separate test environments for each parallel test instead of sharing a single environment across multiple t.Parallel() tests.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by clarifying proper test patterns - each test should create its own test environment rather than sharing one across parallel tests.",
      "related": [],
      "keyQuote": "Each test should have its own environment",
      "number": 1703,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:54.526Z"
    },
    {
      "summary": "Request to provide a way to access DataDog spans from within a workflow context to enable custom tagging and span manipulation. The solution involves adding a `SpanFromWorkflowContext` function to the datadog contrib package, similar to the `tracer.SpanFromContext` API.",
      "category": "feature",
      "subcategory": "datadog-tracing",
      "apis": [
        "workflow.Context"
      ],
      "components": [
        "datadog-tracing",
        "contrib-datadog",
        "workflow-context"
      ],
      "concepts": [
        "tracing",
        "spans",
        "custom-tags",
        "observability",
        "instrumentation"
      ],
      "severity": "low",
      "userImpact": "Enables users to access and modify DataDog spans from within workflow functions for custom tagging and observability enhancements.",
      "rootCause": null,
      "proposedFix": "Add a function `SpanFromWorkflowContext(ctx workflow.Context) (Span, bool)` to the contrib/datadog package to extract the DataDog span from a workflow context, similar to the existing `tracer.SpanFromContext` API.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was accepted and contributor was invited to implement the `SpanFromWorkflowContext` function.",
      "related": [],
      "keyQuote": "add a function like `func SpanFromWorkflowContext(ctx workflow.Context) (Span, bool)` to allow you to get the datadog `Span` from a workflow function",
      "number": 1701,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:53.320Z"
    },
    {
      "summary": "The test environment dispatcher automatically sets SDK flags to true by default, but they should be off by default. This causes test behavior to differ from production defaults.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "dispatcher",
        "test-environment",
        "sdk-flags"
      ],
      "concepts": [
        "default-behavior",
        "testing",
        "configuration",
        "environment-setup",
        "dispatcher-initialization"
      ],
      "severity": "medium",
      "userImpact": "Tests may pass with SDK flags enabled when they should test the default disabled state, leading to false confidence in test results.",
      "rootCause": "createNewDispatcher() automatically sets flags to true instead of respecting the off-by-default requirement",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Test environment assumes they are on by default.",
      "number": 1700,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:39.479Z"
    },
    {
      "summary": "Add a DefaultVersioningBehavior option to workflow.RegisterOptions to provide a default versioning behavior for workflow types, reducing the need for programmatic SetVersioningBehavior() calls during workflow task execution.",
      "category": "feature",
      "subcategory": "versioning",
      "apis": [
        "RegisterOptions",
        "SetVersioningBehavior"
      ],
      "components": [
        "workflow-registration",
        "versioning-engine",
        "build-id-selector"
      ],
      "concepts": [
        "versioning",
        "build-id",
        "workflow-type",
        "default-behavior",
        "type-scoped-configuration"
      ],
      "severity": "medium",
      "userImpact": "Provides a simpler, less error-prone way to configure versioning behavior for workflows without requiring programmatic calls.",
      "rootCause": null,
      "proposedFix": "Add DefaultVersioningBehavior option to workflow.RegisterOptions to associate a default behavior with workflow types",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to allow type-scoped versioning behavior configuration via RegisterOptions",
      "related": [],
      "keyQuote": "Add the option `DefaultVersioningBehavior` to `workflow.RegisterOptions`, providing a default behavior for all workflows of a particular type",
      "number": 1698,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:38.163Z"
    },
    {
      "summary": "Non-Deterministic Error (NDE) messages lack actionable details about what changed in workflow code. Users need clearer error messages that explicitly state what workflow operation was expected versus what was actually encountered during replay.",
      "category": "other",
      "subcategory": "error-handling",
      "apis": [
        "UpsertSearchAttribute",
        "ExecuteActivity"
      ],
      "components": [
        "event-handler",
        "command-state-machine",
        "workflow-execution-context"
      ],
      "concepts": [
        "non-deterministic-error",
        "workflow-replay",
        "history-events",
        "error-messaging",
        "code-mismatch",
        "determinism-violation"
      ],
      "severity": "high",
      "userImpact": "Users encounter cryptic NDE panic messages that don't explain what changed in their code, making it difficult to identify and fix determinism violations.",
      "rootCause": "Error messages only show low-level symptom (e.g., 'lookup failed for scheduledEventID') without context about expected vs actual workflow operations based on history replay.",
      "proposedFix": "Enhanced error messages should explicitly state: 'Workflow code tried to schedule an activity but based on the history events to replay, it should upsert a search attribute instead'",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflow code tried to scheduled an activity but based on the history events to replay, it should upsert a search attribute instead",
      "number": 1693,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:37.566Z"
    },
    {
      "summary": "User requests automatic propagation of Go context.Context values to activities without requiring manual configuration. Currently, context propagation requires manually defining each key and ensuring values are serializable, but the user has dynamic keys based on requests that need to be propagated automatically.",
      "category": "feature",
      "subcategory": "context-propagation",
      "apis": [
        "ExecuteWorkflow",
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "context-propagation",
        "workflow-context"
      ],
      "concepts": [
        "context-values",
        "automatic-propagation",
        "serialization",
        "dynamic-keys",
        "tracing",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Users with dynamic context keys based on requests must manually configure context propagation or abandon context usage, limiting observability and tracing capabilities.",
      "rootCause": "Go's context.Context package does not expose a way to iterate through all values, and workflows use workflow.Context rather than context.Context, preventing automatic propagation.",
      "proposedFix": "Automatically propagate all context.Context values from the client call to activities without requiring manual key definition.",
      "workaround": "Manually define each context key and ensure values are serializable using the existing context propagation mechanism documented in samples.",
      "resolution": "wontfix",
      "resolutionDetails": "SDK maintainers determined this is not feasible due to Go language limitations - context.Context values cannot be iterated, and key definition is a Go requirement that the SDK cannot override.",
      "related": [],
      "keyQuote": "Go's context package chose not to expose a way to iterate through all values. Defining each key is Go language requirement there is nothing the Temporal SDK can do about that.",
      "number": 1691,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:24.297Z"
    },
    {
      "summary": "TestWorkflowEnvironment uses a non-UUID string \"default-test-run-id\" for RunID instead of a valid UUID format, which breaks applications that validate RunID as UUID. Discussion clarified that run ID format is not guaranteed by Temporal and applications shouldn't assume UUID format.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "GetInfo"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-info",
        "test-suite"
      ],
      "concepts": [
        "run-id",
        "uuid-validation",
        "test-environment",
        "workflow-execution",
        "type-safety"
      ],
      "severity": "low",
      "userImpact": "Users writing tests that validate workflow RunID format against UUID standards will encounter failures in TestWorkflowEnvironment that don't match production behavior.",
      "rootCause": "TestWorkflowEnvironment hardcodes RunID to \"default-test-run-id\" string rather than generating a valid UUID, which doesn't match server behavior despite server currently using UUIDs.",
      "proposedFix": "Either set the default RunID to a valid UUID like \"00000000-0000-0000-0000-000000000000\" or expose a SetExecutionRunID function similar to SetContinuedExecutionRunID to allow customization.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer clarified that run ID format is not guaranteed by Temporal and is an implementation detail. Applications should not assume UUID format. Issue was closed as users shouldn't depend on run ID format.",
      "related": [],
      "keyQuote": "Yes, we do not guarantee the format of a run ID",
      "number": 1689,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:22.736Z"
    },
    {
      "summary": "A compilation error occurred in Go SDK v1.29.1 due to undefined nexus.HandlerErrorTypeDownstreamTimeout, which was resolved in v1.30.0. The issue stemmed from a version mismatch between the Go SDK and Go API packages.",
      "category": "bug",
      "subcategory": "nexus-integration",
      "apis": [],
      "components": [
        "nexus-task-handler",
        "api-dependencies",
        "version-compatibility"
      ],
      "concepts": [
        "compilation-error",
        "version-mismatch",
        "dependency-management",
        "api-compatibility",
        "build-failure"
      ],
      "severity": "high",
      "userImpact": "Users were unable to build their Go applications with SDK v1.29.1 due to missing nexus error type definitions.",
      "rootCause": "The Go SDK v1.29.1 could not depend on the latest Go API version due to missing HandlerErrorTypeDownstreamTimeout definition, causing compilation failures.",
      "proposedFix": null,
      "workaround": "Downgrade to v1.29.0 or upgrade to v1.30.0.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in v1.30.0 with improved dependency management to prevent future API version mismatches.",
      "related": [],
      "keyQuote": "this was an unfortunate case where our latest Go SDK version could not depend on our latest Go API version",
      "number": 1687,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:25.978Z"
    },
    {
      "summary": "Update Godoc documentation for internal structs and functions to clarify which public package they are exposed under. Discussion evolved to suggest documenting all exported internal types with their public aliases, potentially via automated tooling with CI validation.",
      "category": "docs",
      "subcategory": "documentation-tooling",
      "apis": [],
      "components": [
        "godoc",
        "internal-exports",
        "build-tooling"
      ],
      "concepts": [
        "documentation",
        "api-clarity",
        "internal-types",
        "aliases",
        "automation",
        "ci-validation"
      ],
      "severity": "low",
      "userImpact": "Developers using the SDK will have clearer documentation about which internal types are publicly exposed and under which package names.",
      "rootCause": null,
      "proposedFix": "Automated command-line tool to parse the project for aliases pointing to internal types and verify their Godoc includes exposure information, with CI check to ensure updates are maintained.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the documentation updates were completed.",
      "related": [],
      "keyQuote": "We should probably just document where every exported `internal` structs/funcs is exposed.",
      "number": 1681,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:10.052Z"
    },
    {
      "summary": "Expose user metadata fields (summary, static summary, static details) on activities and child/scheduled workflows that were previously added internally but marked with TODO statements.",
      "category": "feature",
      "subcategory": "workflow-options",
      "apis": [
        "ExecuteActivityOptions",
        "ChildWorkflowOptions",
        "ScheduleWorkflowOptions"
      ],
      "components": [
        "activity-executor",
        "workflow-options",
        "child-workflow",
        "scheduled-workflow"
      ],
      "concepts": [
        "metadata",
        "user-metadata",
        "activity-options",
        "workflow-options",
        "API-exposure"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently access metadata fields on activities and scheduled workflows despite the infrastructure being partially implemented.",
      "rootCause": "Metadata fields were added internally in PR #1597 but left unexposed with TODO statements pending full implementation.",
      "proposedFix": "Expose the optional \"summary\" field on activities and \"static summary\" + \"static details\" fields on child workflow and scheduled workflow options, marked as experimental.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The metadata fields were exposed on activities and child/scheduled workflow options as requested.",
      "related": [
        1597
      ],
      "keyQuote": "the fields are there but not exposed and have TODO statements. This issue should expose them.",
      "number": 1673,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:08.050Z"
    },
    {
      "summary": "AssertNumberOfCalls incorrectly succeeds when checking if an activity was called a specific number of times, even when the activity was not actually called that many times. The method checks if either workflows OR activities were called N times, rather than checking the specific callable being tested.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "test-suite",
        "mock-assertions",
        "activity-tracking"
      ],
      "concepts": [
        "test-verification",
        "assertion-logic",
        "activity-calls",
        "workflow-calls",
        "mock-framework"
      ],
      "severity": "medium",
      "userImpact": "Users may have failing tests incorrectly pass, leading to false confidence in code that doesn't call activities as intended.",
      "rootCause": "PR #1371 modified AssertNumberOfCalls to check if either the number of workflows OR activities equals N, rather than verifying the specific callable being tested.",
      "proposedFix": "Revert PR #1371 and create separate methods: AssertActivityNumberOfCalls and AssertWorkflowNumberOfCalls for explicit differentiation.",
      "workaround": "Use the new methods AssertActivityNumberOfCalls and AssertWorkflowNumberOfCalls instead of the ambiguous AssertNumberOfCalls.",
      "resolution": "fixed",
      "resolutionDetails": "New specific methods AssertActivityNumberOfCalls and AssertWorkflowNumberOfCalls were added in commit e2bec163bb792071556cedae4d0590a14fc8ee9d to replace the ambiguous AssertNumberOfCalls.",
      "related": [
        887,
        1371
      ],
      "keyQuote": "AssertNumberOfCalls is inherently ambiguous since it doesn't differentiate between workflow, activity or nexus calls.",
      "number": 1672,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:15:07.736Z"
    },
    {
      "summary": "Replaying a downloaded workflow history that ends with a workflow task in 'started' state incorrectly fails with a nondeterministic workflow error. The issue occurs because history matching for non-determinism checks continues after the last task start without an end event.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "task-handlers",
        "replayer",
        "history-matching"
      ],
      "concepts": [
        "workflow-replay",
        "history-matching",
        "nondeterminism-detection",
        "mid-workflow-capture",
        "task-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Users cannot replay workflow histories captured mid-task (ending with started but not completed workflow tasks), blocking replay-based debugging and failure replication.",
      "rootCause": "History matching for non-determinism checks is performed after the last task start event that lacks an end event, causing false positives for 'extra replay command' errors.",
      "proposedFix": "Stop performing history matching for non-determinism checks after the last task start without a corresponding end event. Three approaches discussed: trim history in GetWorkflowHistory, trim before passing to Replayer, or trim in Replayer itself.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The team identified this as a bug and decided to prevent history matching for non-determinism checks after the last incomplete task start.",
      "related": [],
      "keyQuote": "If we are in fact failing a replay with history that should succeed, we need to fix. It is likely we should not be performing history matching for non-determinism checks after the last task start (that doesn't have an end).",
      "number": 1670,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:14:51.282Z"
    },
    {
      "summary": "When deserializing typed search attributes, the SDK panics on invalid values instead of ignoring them. This particularly affects workflows created with untyped attributes (like single-item arrays) when accessing typed search attributes or when using CLI commands like schedule describe.",
      "category": "bug",
      "subcategory": "search-attributes",
      "apis": [],
      "components": [
        "typed-search-attributes",
        "deserialization",
        "schedule",
        "workflow"
      ],
      "concepts": [
        "type-conversion",
        "error-handling",
        "data-validation",
        "compatibility",
        "cross-sdk-interoperability"
      ],
      "severity": "high",
      "userImpact": "Users cannot work with workflows or schedules created by TypeScript SDK or with untyped search attributes without encountering panics when the SDK tries to deserialize them as typed attributes.",
      "rootCause": "The SDK panics when attempting to deserialize invalid typed search attribute values instead of gracefully ignoring them during deserialization.",
      "proposedFix": "Ignore all invalid values during typed search attribute deserialization, matching the behavior already implemented in the Python SDK.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If a user creates a workflow or a schedule using untyped attributes and passes in a single-item array, the typed search attributes should simply not include that value.",
      "number": 1668,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:14:52.615Z"
    },
    {
      "summary": "Add a high-level DescribeWorkflow call on the Go SDK client that returns workflow execution information in a structured WorkflowExecutionDescription, deprecating the existing DescribeWorkflowExecution method. The implementation should be interceptable and follow the design patterns established in TypeScript, Python, and .NET SDKs.",
      "category": "feature",
      "subcategory": "client-api",
      "apis": [
        "DescribeWorkflow",
        "DescribeWorkflowExecution"
      ],
      "components": [
        "client",
        "workflow-execution",
        "interceptor"
      ],
      "concepts": [
        "api-design",
        "workflow-inspection",
        "execution-status",
        "deprecation",
        "abstraction"
      ],
      "severity": "medium",
      "userImpact": "Provides users with a modern, high-level API to inspect workflow execution details with consistent design across SDKs.",
      "rootCause": null,
      "proposedFix": "Implement DescribeWorkflow method on client returning WorkflowExecutionDescription with structured data, support interceptors, and deprecate DescribeWorkflowExecution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented as a enhancement to provide better API ergonomics for workflow inspection.",
      "related": [
        2265
      ],
      "keyQuote": "Add a DescribeWorkflow call on client... Return a WorkflowExecutionDescription that contains some obvious things and access to the raw describe response",
      "number": 1667,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:14:54.808Z"
    },
    {
      "summary": "Add support for workflow annotations to enable the new versioning APIs in the Go SDK. This feature is part of a larger initiative to support advanced versioning patterns.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [],
      "components": [
        "workflow",
        "versioning"
      ],
      "concepts": [
        "annotations",
        "versioning",
        "workflow-definition",
        "api-design",
        "sdk-feature"
      ],
      "severity": "medium",
      "userImpact": "Enables users to implement sophisticated workflow versioning strategies using annotations without workarounds.",
      "rootCause": null,
      "proposedFix": "Implement workflow annotation support to enable the new versioning APIs referenced in the parent feature issue.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support new versioning APIs with workflow annotations",
      "related": [
        548
      ],
      "keyQuote": "The goal is to support the new versioning APIs that rely on workflow annotations.",
      "number": 1663,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:56.984Z"
    },
    {
      "summary": "Feature request to add support for running activities in separate processes in Go SDK, similar to Python's ProcessPoolExecutor. The issue asks for an equivalent pattern to achieve process isolation for activities and environment variable isolation.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [
        "Worker"
      ],
      "components": [
        "worker",
        "activity-executor",
        "process-management"
      ],
      "concepts": [
        "process-isolation",
        "multiprocessing",
        "activity-execution",
        "environment-variables",
        "cross-language-consistency"
      ],
      "severity": "low",
      "userImpact": "Users seeking process-isolated activity execution in Go must implement custom solutions, unlike Python SDK users who have built-in ProcessPoolExecutor support.",
      "rootCause": "Go's native concurrency model uses goroutines rather than OS processes, and the SDK prioritizes language-native patterns without adding external dependencies.",
      "proposedFix": "User provided a Go implementation using exec.Command for subprocess execution with environment variable and JSON serialization support, demonstrating feasibility.",
      "workaround": "Users can manually implement subprocess-based activities using Go's os/exec package with JSON serialization for data passing.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer indicated Go SDK intentionally avoids non-native multiprocessing to stay aligned with Go's idiomatic patterns, though users have flexibility to implement custom solutions.",
      "related": [],
      "keyQuote": "There is no native Go multiprocessing for functions and we do try to be native to the language without adding dependencies.",
      "number": 1651,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:08:00.641Z"
    },
    {
      "summary": "Tracking flaky tests in the Go SDK test suite. Multiple tests are failing intermittently, including TestSideEffectDefer, TestIntegrationSuite variants, and TestMockCallWrapperNotBefore, with some failures appearing as of Go 1.24.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "integration-tests",
        "side-effect",
        "otel-tracing",
        "worker-pollers"
      ],
      "concepts": [
        "test-flakiness",
        "intermittent-failures",
        "test-reliability",
        "ci-instability",
        "race-conditions"
      ],
      "severity": "high",
      "userImpact": "Flaky tests reduce confidence in SDK stability and make it difficult to distinguish legitimate failures from environmental issues.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Hoping to start a list of flaky tests for the Go SDK",
      "number": 1650,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:55.073Z"
    },
    {
      "summary": "Request to enhance logging context in the Go SDK to display update handler information and ID alongside other context data.",
      "category": "feature",
      "subcategory": "logging-context",
      "apis": [],
      "components": [
        "logging",
        "update-handler"
      ],
      "concepts": [
        "logging-context",
        "handler-identification",
        "observability",
        "debugging",
        "context-propagation"
      ],
      "severity": "low",
      "userImpact": "Users will have better visibility into which update handler is executing through enhanced logging output.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Update handler and ID logging context were implemented",
      "related": [
        466
      ],
      "keyQuote": "Show update handler and ID in logging context",
      "number": 1648,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:44.425Z"
    },
    {
      "summary": "TestActivityEnvironment lacks a SetStartTime method that exists in TestWorkflowEnvironment, preventing proper testing of start time related features in activities. This is a feature parity request to enable consistent testing patterns across workflow and activity test environments.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestActivityEnvironment",
        "TestWorkflowEnvironment"
      ],
      "components": [
        "test-activity-environment",
        "activity-testing",
        "test-framework"
      ],
      "concepts": [
        "start-time",
        "activity-testing",
        "test-environment",
        "testing-utilities",
        "time-control"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test start time related features in activities, limiting test coverage and forcing workarounds that may be imprecise.",
      "rootCause": null,
      "proposedFix": "Add SetStartTime method to TestActivityEnvironment similar to the existing implementation in TestWorkflowEnvironment",
      "workaround": "Passing start time as an activity parameter, though this is discouraged due to potential imprecision from worker coordination",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "TestActivityEnvironment to support SetStartTime",
      "number": 1646,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:41.670Z"
    },
    {
      "summary": "GetVersion internally calls UpsertSearchAttributes with non-deterministic changeID values, causing test mocks to fail when developers try to assert UpsertSearchAttributes behavior. The issue was resolved by clarifying documentation and suggesting developers use MatchedBy for flexible assertions.",
      "category": "docs",
      "subcategory": "test-framework",
      "apis": [
        "GetVersion",
        "UpsertSearchAttributes"
      ],
      "components": [
        "test-mocking",
        "versioning",
        "search-attributes"
      ],
      "concepts": [
        "test-mocking",
        "non-determinism",
        "search-attributes",
        "versioning",
        "changeID",
        "map-iteration"
      ],
      "severity": "low",
      "userImpact": "Developers writing tests that assert UpsertSearchAttributes behavior struggle with unexpected calls from GetVersion and non-deterministic ordering.",
      "rootCause": "getChangeVersions iterates over a map (non-deterministic) and uses the result in UpsertSearchAttributes calls, making it hard to mock deterministically.",
      "proposedFix": "Use testify's MatchedBy to create flexible assertions that match keys in the map without asserting exact changeID values.",
      "workaround": "Use mock.MatchedBy to match search attributes by key without requiring exact value matching for changeID fields.",
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by documentation clarification and guidance on using MatchedBy for flexible test assertions.",
      "related": [],
      "keyQuote": "You shouldn't need to assert the exact value of `changeID` if you are not interested in it. You should be able to use something like MatchedBy",
      "number": 1643,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:43.725Z"
    },
    {
      "summary": "Improve UX for testing Workflow Updates by providing SDK helpers for common test scenarios, reducing the need for users to manually implement UpdateCallbacks in the Workflow Test Environment.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "UpdateCallbacks"
      ],
      "components": [
        "workflow-test-environment",
        "update-testing",
        "test-helpers"
      ],
      "concepts": [
        "testing",
        "workflow-updates",
        "test-utilities",
        "user-experience",
        "assertions",
        "callbacks"
      ],
      "severity": "low",
      "userImpact": "Users testing Workflow Updates must currently implement boilerplate UpdateCallbacks code, which this feature would simplify with built-in helpers.",
      "rootCause": null,
      "proposedFix": "Provide helpers in the SDK for common update testing scenarios",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented with helper functions for testing Workflow Updates",
      "related": [],
      "keyQuote": "Provide helpers in the SDK for common update testing scenarios",
      "number": 1639,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:28.531Z"
    },
    {
      "summary": "The test environment for workflow updates does not deduplicate updates by ID, whereas the real server deduplicates update requests with the same UpdateID. This inconsistency means tests may not properly validate deduplication behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "UpdateClientWorkflow",
        "UpdateWorkflowOptions"
      ],
      "components": [
        "test-environment",
        "workflow-update",
        "deduplication"
      ],
      "concepts": [
        "idempotency",
        "deduplication",
        "update-id",
        "test-parity",
        "in-memory-testing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test update deduplication logic since the test environment behaves differently from production, potentially hiding bugs.",
      "rootCause": "Test environment does not implement UpdateID deduplication logic that the real server provides.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The test environment was updated to implement deduplication of updates by ID, matching real server behavior.",
      "related": [],
      "keyQuote": "Test Environment accepts update with duplicate ID",
      "number": 1638,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:26.780Z"
    },
    {
      "summary": "ExecuteMultiOperation (Update-with-Start) is not retrying when an Update fails to reach a durable stage, unlike the expected behavior where the entire call should be retried.",
      "category": "bug",
      "subcategory": "updates-retry-logic",
      "apis": [
        "ExecuteMultiOperation"
      ],
      "components": [
        "update-executor",
        "retry-handler",
        "multi-operation"
      ],
      "concepts": [
        "retry",
        "durable-stage",
        "update-admission",
        "error-handling",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Update operations with StartWorkflow may fail to retry appropriately when updates are not admitted, potentially leaving workflows in an inconsistent state.",
      "rootCause": "ExecuteMultiOperation lacks retry logic for non-durable Update stages, treating them as terminal failures instead of retriable conditions.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing proper retry logic for non-admitted Updates in ExecuteMultiOperation.",
      "related": [],
      "keyQuote": "ExecuteMultiOperation does not retry when encountering a non-durable Update stage.",
      "number": 1635,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:30.657Z"
    },
    {
      "summary": "Proposal to modify the Go SDK test suite to output JUnit XML files, enabling better analysis of test flakiness patterns, timings, and performance across matrix builds and multiple runs.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "ci-cd",
        "test-reporting"
      ],
      "concepts": [
        "test-flakiness",
        "junit-xml",
        "test-metrics",
        "test-timing",
        "matrix-builds",
        "test-analysis"
      ],
      "severity": "low",
      "userImpact": "Enables developers and maintainers to better analyze test reliability patterns and performance characteristics across different environments and runs.",
      "rootCause": null,
      "proposedFix": "Add JUnit XML output to the test suite following the pattern established in sdk-python PR #617 and cli PR #650",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Producing the files now will allow us to test tools for doing this",
      "number": 1633,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:14.059Z"
    },
    {
      "summary": "MockWorkflowServiceServer generated mock does not properly implement WorkflowServiceServer interface because it fails to embed UnimplementedWorkflowServiceServer, which became required after gRPC changes. This causes compile errors when attempting to use the mock.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "MockWorkflowServiceServer",
        "WorkflowServiceServer",
        "code-generation"
      ],
      "concepts": [
        "interface-implementation",
        "mocking",
        "code-generation",
        "gRPC",
        "embedding"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use the generated MockWorkflowServiceServer for testing because it fails to compile against the current WorkflowServiceServer interface.",
      "rootCause": "MockWorkflowServiceServer was generated before WorkflowServiceServer required embedding UnimplementedWorkflowServiceServer; the generated mock was not updated to reflect this requirement.",
      "proposedFix": "Alter the generated mock to embed UnimplementedWorkflowServiceServer and add compile-time checks to ensure conformity to the interface it's mocking.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "MockWorkflowServiceServer is generated via a step created in the gRPC days before WorkflowServiceServer required embedding UnimplementedWorkflowServiceServer.",
      "number": 1628,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:16.198Z"
    },
    {
      "summary": "workflowcheck analyzer built with Go 1.23 fails to detect non-deterministic code issues that were properly detected in Go 1.22.7. The tool stops working after updating the go.mod file to Go 1.23.0, no longer finding issues like time.Now() calls in workflows.",
      "category": "bug",
      "subcategory": "workflowcheck-analyzer",
      "apis": [],
      "components": [
        "workflowcheck",
        "analyzer",
        "go-modules"
      ],
      "concepts": [
        "non-deterministic-detection",
        "go-version-compatibility",
        "static-analysis",
        "tool-maintenance"
      ],
      "severity": "high",
      "userImpact": "Users updating their Go version to 1.23 lose the ability to detect non-deterministic workflow code, potentially allowing bugs to slip through code review.",
      "rootCause": "Go 1.23 introduced breaking changes that impact how the workflowcheck analyzer performs static analysis, causing it to not properly detect violations.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved via PR #1642, which addresses the Go 1.23 compatibility issue.",
      "related": [
        1642
      ],
      "keyQuote": "Seems like quite a breaking change from Go! Link to the PR: https://github.com/temporalio/sdk-go/pull/1642",
      "number": 1627,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:13.683Z"
    },
    {
      "summary": "Signals sent to a Selector can be lost if the Default path is blocking. When AddDefault executes a long-running operation, signals sent during that execution are dropped because the readyFunc is never called. The issue requires storing signal values in the channel's recValue to prevent loss.",
      "category": "bug",
      "subcategory": "selector-signal-handling",
      "apis": [
        "AddDefault",
        "Selector"
      ],
      "components": [
        "selector",
        "signal-handling",
        "channel-management"
      ],
      "concepts": [
        "signal-loss",
        "concurrent-execution",
        "blocking-operations",
        "race-condition",
        "channel-buffering"
      ],
      "severity": "high",
      "userImpact": "Users lose signals when their Selector's Default path contains blocking operations, leading to missed workflow signals and potential deadlocks.",
      "rootCause": "When AddDefault is specified, the readyFunc is never executed, causing signals sent during AddDefault execution to be dropped without being stored or received.",
      "proposedFix": "Store signal values in the channel's recValue beforehand to make them available for future receives without dropping signals.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2070,
        2066
      ],
      "keyQuote": "When a signal is sent to the channel while the AddDefault method (long running) is executing, the signal is lost without being received.",
      "number": 1624,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:02.463Z"
    },
    {
      "summary": "The API Go payload visitor does not visit `Any` fields that may contain payloads, causing some payloads to be missed during traversal. For example, payloads inside `Any` fields within `protobuf.Message` types are not visited.",
      "category": "bug",
      "subcategory": "payload-visitor",
      "apis": [],
      "components": [
        "payload-visitor",
        "api-generator",
        "protobuf-message-handling"
      ],
      "concepts": [
        "payload-traversal",
        "Any-type",
        "code-generation",
        "protobuf-fields"
      ],
      "severity": "medium",
      "userImpact": "Users may encounter issues with payload handling when payloads are nested inside `Any` fields, leading to incomplete payload processing.",
      "rootCause": "The generator only visits objects with a direct path to `common.Payload`, not `Any` fields that might contain payloads.",
      "proposedFix": "Support `Any` in the payload visitor in addition to direct payload references.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The payload visitor was updated to support visiting `Any` fields that may contain payloads.",
      "related": [],
      "keyQuote": "The generator only visits things with a clear path to `common.Payload` so it does not include `Any` that might have an object with a payload inside it.",
      "number": 1622,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:59.060Z"
    },
    {
      "summary": "The VisitPayloadsOptions.Visitor context parent field is not properly reset after visit calls, causing it to leak to subsequent calls. Documentation should be clarified to explicitly state the context is mutated between calls and should not be referenced beyond the current call.",
      "category": "bug",
      "subcategory": "api-design",
      "apis": [
        "VisitPayloadsOptions",
        "Visitor",
        "VisitPayloadsContext"
      ],
      "components": [
        "payload-visitor",
        "context-handling",
        "api-go"
      ],
      "concepts": [
        "context-mutation",
        "state-leakage",
        "parent-field",
        "documentation-clarity"
      ],
      "severity": "medium",
      "userImpact": "Users may experience unexpected behavior if the context parent leaks between payload visit calls, and unclear documentation may lead to misuse of the mutable context.",
      "rootCause": "The parent field is set on the context before visiting but not reset afterward, causing state to leak between calls.",
      "proposedFix": "Pass the parent as a parameter to visitPayloads and set the parent before the type switch, rather than mutating and not resetting the context field.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The parent field reset logic was implemented and documentation was clarified to indicate the context is mutated between calls.",
      "related": [],
      "keyQuote": "Context is the same for every call of a visit and is mutated between calls, callers should not store it or reference it beyond the call.",
      "number": 1614,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:07:00.946Z"
    },
    {
      "summary": "Request to make the queryRejectedError public in the Go SDK to enable proper error handling of query rejection in interceptors when using QueryWorkflowWithOptions with QUERY_REJECT_CONDITION_NOT_OPEN.",
      "category": "feature",
      "subcategory": "query-handling",
      "apis": [
        "QueryWorkflowWithOptions"
      ],
      "components": [
        "interceptor",
        "query-handling",
        "error-handling"
      ],
      "concepts": [
        "error-visibility",
        "interceptor-patterns",
        "query-rejection",
        "type-safety",
        "error-classification"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly catch and handle query rejection errors in interceptors without relying on error message string matching or response inspection.",
      "rootCause": "queryRejectedError type is unexported (private) in the SDK, preventing interceptors from using type assertions to distinguish query rejections from other errors.",
      "proposedFix": "Export the queryRejectedError type as QueryRejectedError to allow explicit type checking in error interceptors.",
      "workaround": "Use QueryWorkflowWithOptionsResponse.QueryRejected field directly or perform error message string matching, neither of which integrates well with interceptor error handling patterns.",
      "resolution": "fixed",
      "resolutionDetails": "The queryRejectedError was likely exported to make it publicly accessible for interceptor error handling.",
      "related": [],
      "keyQuote": "Making queryRejectedError public would allow better handling in error interceptors",
      "number": 1612,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:45.446Z"
    },
    {
      "summary": "Panic occurs when calling GetSystemInfo with a context that has a timeout set on Windows. The issue was resolved by adjusting timeout settings - timeouts must be greater than 10 seconds or using the IP address 127.0.0.1 instead of localhost.",
      "category": "bug",
      "subcategory": "client-connection",
      "apis": [
        "GetSystemInfo",
        "Dial"
      ],
      "components": [
        "client",
        "grpc-connection",
        "context-management"
      ],
      "concepts": [
        "timeout",
        "panic",
        "context",
        "windows",
        "connection-initialization"
      ],
      "severity": "high",
      "userImpact": "Users on Windows experience panics when initializing a Temporal client with timeout contexts, blocking application startup.",
      "rootCause": "Context timeout was too short for Windows platform when resolving localhost:7233, causing the GetSystemInfo call to panic.",
      "proposedFix": "Set timeout greater than 10 seconds or use IP address 127.0.0.1 instead of localhost.",
      "workaround": "Either remove timeout from context, use a timeout greater than 10 seconds, or use 127.0.0.1:7233 instead of localhost:7233.",
      "resolution": "invalid",
      "resolutionDetails": "User identified platform-specific DNS resolution issue on Windows - not a bug in SDK but a configuration issue requiring longer timeouts for localhost resolution.",
      "related": [],
      "keyQuote": "using client.Dial(client.Options{}) to set localhost:7233 by default, timed out under windows. The timeout must be greater than 10 seconds, or use 127.0.0.1:7233",
      "number": 1611,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:43.799Z"
    },
    {
      "summary": "The worker.WorkflowReplayer interface does not expose the GetWorkflowResult method that exists on the underlying concrete type, requiring users to perform manual type assertions. The issue requests adding this method to the public interface to enable testing workflows and verifying results remain consistent across replays.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "WorkflowReplayer",
        "NewWorkflowReplayerWithOptions",
        "GetWorkflowResult"
      ],
      "components": [
        "worker",
        "workflow-replayer",
        "public-api"
      ],
      "concepts": [
        "interface-design",
        "backward-compatibility",
        "testing",
        "type-assertion",
        "workflow-execution"
      ],
      "severity": "low",
      "userImpact": "Users building test helpers that replay workflows to verify results must use type assertions to access the GetWorkflowResult method, which is unintuitive and brittle.",
      "rootCause": "The WorkflowReplayer is returned as an interface rather than a concrete type, preventing new methods from being added without breaking backward compatibility.",
      "proposedFix": "Multiple options discussed: (1) Create a new API returning concrete type (NewWorkflowReplayerWithResults), (2) Expose internal.WorkflowReplayer via type alias, (3) Create a new WorkflowReplayerWithResults interface, or (4) Document additional methods available via type assertion. Author prefers option 1, considers option 2 acceptable.",
      "workaround": "Users can define their own interface that embeds worker.WorkflowReplayer and adds GetWorkflowResult method, then perform type assertion on the returned value.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I am using this to build a test helper to replay workflows and ensure that their results are the same each time",
      "number": 1610,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:47.600Z"
    },
    {
      "summary": "Feature request to add ContextAware interface support for failure converters so they can access workflow/activity context information like headers. This would enable better logging and error handling in custom failure converters.",
      "category": "feature",
      "subcategory": "failure-converter",
      "apis": [
        "ContextAware"
      ],
      "components": [
        "failure-converter",
        "context",
        "error-handling"
      ],
      "concepts": [
        "context-aware",
        "failure-conversion",
        "error-marshalling",
        "logging",
        "custom-errors"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access context information like headers in custom failure converters, limiting their ability to implement advanced error handling and logging.",
      "rootCause": null,
      "proposedFix": "Implement ContextAware interface support for failure converters to provide access to workflow/activity context.",
      "workaround": "Manage custom error marshalling without context access, as mentioned in the use case with cockroachdb/errors.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "lacking context stands in a way of, for example, logging the problems with marshalling/unmarshalling using the right logger",
      "number": 1609,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:30.900Z"
    },
    {
      "summary": "Update internal SDK timers to use NewTimerWithOptions and provide summary information for better observability. Also expose summary parameter on AwaitWithTimeout for both internal and external use.",
      "category": "feature",
      "subcategory": "timers",
      "apis": [
        "NewTimerWithOptions",
        "AwaitWithTimeout"
      ],
      "components": [
        "timer",
        "internal-timers",
        "await-operations"
      ],
      "concepts": [
        "observability",
        "summary",
        "timer-details",
        "internal-sdk-operations"
      ],
      "severity": "low",
      "userImpact": "Provides better visibility into internal timer operations through summary information, improving debugging and observability.",
      "rootCause": null,
      "proposedFix": "Use NewTimerWithOptions for internal timers and expose summary parameter on AwaitWithTimeout",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Internal timers updated to use NewTimerWithOptions with summary information",
      "related": [
        1597
      ],
      "keyQuote": "Since #1597, there is now a way to provide a summary for a timer, so we should do so for internal timers we create inside the SDK",
      "number": 1602,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:27.311Z"
    },
    {
      "summary": "Setting a typed nil value for the optional Ramp field in VersioningAssignmentRule causes a panic with bad memory reference, while untyped nil works correctly.",
      "category": "bug",
      "subcategory": "versioning",
      "apis": [
        "UpdateWorkerVersioningRulesOptions",
        "VersioningAssignmentRule",
        "VersioningRampByPercentage"
      ],
      "components": [
        "versioning",
        "worker-versioning",
        "rule-validation"
      ],
      "concepts": [
        "nil-handling",
        "type-safety",
        "panic",
        "memory-safety",
        "optional-fields",
        "proto-conversion"
      ],
      "severity": "medium",
      "userImpact": "Users cannot set optional Ramp fields to typed nil values without causing a runtime panic.",
      "rootCause": "Proto conversion logic does not properly handle typed nil values for interface fields.",
      "proposedFix": null,
      "workaround": "Use untyped nil instead of typed nil for the Ramp field.",
      "resolution": "wontfix",
      "resolutionDetails": "Assignment rules have been deprecated and scheduled for removal, so the bug was closed without fixing.",
      "related": [],
      "keyQuote": "Assignment rules have been deprecated and soon to be removed. Closing...",
      "number": 1598,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:29.054Z"
    },
    {
      "summary": "Feature request to treat 100% ramp in versioning assignment rules as unramped to reduce customer confusion. This depends on server-side changes and has been closed due to deprecation of assignment rules.",
      "category": "feature",
      "subcategory": "versioning-assignment-rules",
      "apis": [],
      "components": [
        "versioning",
        "assignment-rules"
      ],
      "concepts": [
        "versioning",
        "ramp",
        "assignment-rules",
        "backwards-compatibility",
        "deprecation"
      ],
      "severity": "low",
      "userImpact": "Customers were confused by inability to set 100% ramp in assignment versioning rules, but this is no longer relevant as assignment rules are being removed.",
      "rootCause": null,
      "proposedFix": "Treat a 100% ramp in an assignment versioning rule as un-ramped",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Assignment rules have been deprecated and are soon to be removed, making this feature request obsolete",
      "related": [],
      "keyQuote": "Assignment rules have been deprecated, and soon to be removed, closing",
      "number": 1596,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:12.574Z"
    },
    {
      "summary": "Workflow replay tests fail with a scheduledEventID to activityID lookup error when replaying recent workflow histories from Temporal Cloud, while older histories from earlier 2024 work correctly.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowHistoryFromJSONFile",
        "NewWorkflowReplayer",
        "RegisterWorkflow"
      ],
      "components": [
        "workflow-replayer",
        "command-state-machine",
        "event-handler"
      ],
      "concepts": [
        "replay",
        "history-processing",
        "activity-scheduling",
        "determinism",
        "event-correlation"
      ],
      "severity": "high",
      "userImpact": "Users cannot validate workflow code changes against recent production workflow histories, blocking replay-based testing.",
      "rootCause": "Internal command state machine fails to resolve scheduledEventID to activityID mapping during event processing in recent histories.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue redirected to Temporal Cloud support via Zendesk ticket; not resolved as a public bug.",
      "related": [],
      "keyQuote": "[TMPRL1100] lookup failed for scheduledEventID to activityID: scheduleEventID: 7, activityID: 7",
      "number": 1594,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:16.583Z"
    },
    {
      "summary": "Exploration of implementing range-over-func iterator APIs in the Go SDK to take advantage of Go 1.23's new language feature for workflows, clients, and history events.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [
        "ExecuteWorkflow",
        "ListWorkflows",
        "ListSchedules"
      ],
      "components": [
        "client",
        "workflow",
        "iterator"
      ],
      "concepts": [
        "range-over-func",
        "iterator",
        "deterministic",
        "async-iteration",
        "history-events",
        "workflow-listing",
        "schedule-listing"
      ],
      "severity": "low",
      "userImpact": "Users can leverage Go 1.23's range-over-func syntax for cleaner iteration patterns when working with workflows, schedules, and history events.",
      "rootCause": null,
      "proposedFix": "Add iterator APIs for workflow channels, deterministic map iteration, workflow listings, schedule listings, and history event iteration using Go 1.23 range-over-func patterns.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Consider what APIs we can add to the Go SDK to take advantage of range-over-func",
      "number": 1593,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:13.847Z"
    },
    {
      "summary": "Documentation needs to be updated to clarify that signals do not interrupt workflow delays. This is a documentation fix to align with API behavior discussed in temporalio/api#441.",
      "category": "docs",
      "subcategory": "workflow-signals-delays",
      "apis": [],
      "components": [
        "documentation",
        "signal-handler",
        "workflow-delay"
      ],
      "concepts": [
        "signals",
        "delays",
        "workflow-execution",
        "documentation",
        "interrupt-behavior"
      ],
      "severity": "low",
      "userImpact": "Users may be confused about signal behavior during workflow delays, leading to incorrect expectations about timing and signal handling.",
      "rootCause": "Documentation does not accurately reflect that signals do not interrupt delays, as confirmed by API specification discussions.",
      "proposedFix": "Update workflow start delay documentation to explicitly state that signals do not interrupt delays.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to clarify signal behavior regarding delays.",
      "related": [],
      "keyQuote": "signal does not interrupt delay",
      "number": 1591,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:59.763Z"
    },
    {
      "summary": "Add support for workflow updates in the tracing interceptor by implementing `ClientOutboundInterceptor.UpdateWorkflow` to populate headers and `WorkflowInboundInterceptor.ExecuteUpdate` to put span on context.",
      "category": "feature",
      "subcategory": "tracing-interceptor",
      "apis": [
        "ClientOutboundInterceptor.UpdateWorkflow",
        "WorkflowInboundInterceptor.ExecuteUpdate"
      ],
      "components": [
        "tracing-interceptor",
        "client-interceptor",
        "workflow-interceptor"
      ],
      "concepts": [
        "distributed-tracing",
        "observability",
        "span-propagation",
        "workflow-updates",
        "context-management",
        "header-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot trace workflow update operations end-to-end, limiting observability for this important workflow feature.",
      "rootCause": null,
      "proposedFix": "Implement UpdateWorkflow support in ClientOutboundInterceptor to populate headers and ExecuteUpdate support in WorkflowInboundInterceptor to attach span to context.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Workflow updates support was added to the tracing interceptor.",
      "related": [],
      "keyQuote": "Need to support `ClientOutboundInterceptor.UpdateWorkflow` in the tracing interceptor to populate header and `WorkflowInboundInterceptor.ExecuteUpdate`",
      "number": 1588,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:06:01.334Z"
    },
    {
      "summary": "Activity failure attributes are not encrypted with the context propagator's encryption key, even though workflow and activity payloads are properly encrypted. The failure converter uses a different or missing encryption key compared to the context propagator.",
      "category": "bug",
      "subcategory": "encryption",
      "apis": [
        "NewDefaultFailureConverter"
      ],
      "components": [
        "failure-converter",
        "context-propagator",
        "data-converter"
      ],
      "concepts": [
        "encryption",
        "data-protection",
        "key-management",
        "failure-handling",
        "payload-encoding"
      ],
      "severity": "high",
      "userImpact": "Sensitive failure information may be exposed unencrypted while other payloads remain encrypted, creating a security inconsistency.",
      "rootCause": "Failure converters cannot be context aware, so they cannot access the encryption key set in the context propagator used for encrypting workflow and activity payloads.",
      "proposedFix": "Add support for failure converters to be context aware so they can access the context propagator's encryption key.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Not expected to work by design; failure converters are not context aware. A separate feature was opened to add this capability.",
      "related": [
        1609
      ],
      "keyQuote": "Failure converters cannot be context aware. I opened up an issue to add support to failure converters https://github.com/temporalio/sdk-go/issues/1609",
      "number": 1587,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:57.662Z"
    },
    {
      "summary": "The Go SDK currently carries over the current workflow's search attributes when continuing as new, but should allow explicit specification like other SDKs do. This is a feature parity request.",
      "category": "feature",
      "subcategory": "workflow-continuation",
      "apis": [
        "ContinueAsNew",
        "WorkflowOptions"
      ],
      "components": [
        "workflow-engine",
        "search-attributes",
        "options"
      ],
      "concepts": [
        "search-attributes",
        "workflow-continuation",
        "parity",
        "sdk-feature",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users cannot explicitly set search attributes when continuing a workflow as new, limiting workflow customization options.",
      "rootCause": null,
      "proposedFix": "Add support for explicit search attribute specification in ContinueAsNew or WorkflowOptions, matching behavior in other SDKs.",
      "workaround": "Use WorkflowOptions to specify search attributes (as mentioned in the closing comment).",
      "resolution": "wontfix",
      "resolutionDetails": "Determined to be resolvable through existing WorkflowOptions functionality; explicit implementation deemed unnecessary.",
      "related": [],
      "keyQuote": "You can do this thru the WorkflowOptions; closing.",
      "number": 1586,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:45.909Z"
    },
    {
      "summary": "Request to add `workflow.WithCancelCause(..)` function to the Go SDK to match the updated `context.WithCancelCause(...)` function in the standard library. This would provide consistency between the Go SDK's context API and Go's native context package.",
      "category": "feature",
      "subcategory": "context-api",
      "apis": [
        "WithCancelCause"
      ],
      "components": [
        "context-functions",
        "workflow-context",
        "api-compatibility"
      ],
      "concepts": [
        "cancellation",
        "context",
        "api-consistency",
        "stdlib-alignment"
      ],
      "severity": "low",
      "userImpact": "Users cannot use the modern WithCancelCause pattern in Go SDK workflows, limiting parity with Go's standard library.",
      "rootCause": null,
      "proposedFix": "Add `workflow.WithCancelCause(..)` function to match the Go standard library's `context.WithCancelCause(...)`",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Would be awesome to update the go sdk to have `workflow.WithCancelCause(..)` to match the updated context function `context.WithCancelCause(...)`",
      "number": 1582,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:46.614Z"
    },
    {
      "summary": "The workflow handler warning system should be disabled when the workflow has already failed, to avoid spurious warnings about unfinished handlers on failed workflows.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "workflow-engine",
        "error-handling",
        "handler-lifecycle"
      ],
      "concepts": [
        "workflow-failure",
        "handler-cleanup",
        "warning-suppression",
        "error-state",
        "lifecycle-management"
      ],
      "severity": "medium",
      "userImpact": "Users see unnecessary warnings about unfinished handlers when workflows fail, cluttering logs and causing confusion about actual error conditions.",
      "rootCause": "The handler warning logic does not account for the workflow failure state before emitting warnings about incomplete handlers.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The warning logic was updated to suppress warnings on unfinished handlers when the workflow has already failed.",
      "related": [],
      "keyQuote": "It was decided we would not warn on unfinished handlers if the workflow has failed.",
      "number": 1580,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:44.148Z"
    },
    {
      "summary": "Documentation needed for workflow initialization method that guarantees execution before signals and updates are processed. The issue requests a method to initialize workflow state before handlers receive signals/updates.",
      "category": "docs",
      "subcategory": "workflow-initialization",
      "apis": [],
      "components": [
        "workflow",
        "signal-handler",
        "update-handler"
      ],
      "concepts": [
        "initialization",
        "signal-processing",
        "update-handling",
        "workflow-state",
        "handler-setup"
      ],
      "severity": "low",
      "userImpact": "Users cannot reliably initialize workflow state before signal and update handlers execute, making it unclear how to set up initialized values for handlers to use.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed as documentation-only issue. Team decided docs improvement was sufficient rather than SDK code changes.",
      "related": [],
      "keyQuote": "We should have a method that's guaranteed to initialize before signals and updates come in so handlers can use initialized values.",
      "number": 1576,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:32.911Z"
    },
    {
      "summary": "RecordHeartbeat fails when called with a canceled context from an errgroup that has already finished. Users experience activity timeouts when using goroutine patterns that create derived contexts that are canceled before subsequent heartbeat calls.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [
        "RecordHeartbeat"
      ],
      "components": [
        "activity-executor",
        "heartbeat-handler",
        "context-management"
      ],
      "concepts": [
        "context-cancellation",
        "goroutine-coordination",
        "timeout",
        "batching",
        "context-propagation"
      ],
      "severity": "high",
      "userImpact": "Users experience unexpected activity timeouts when using errgroup or similar patterns that create derived contexts, requiring workarounds to avoid passing canceled contexts to RecordHeartbeat.",
      "rootCause": "RecordHeartbeat's goroutine continues to reference the caller's context even after the caller's errgroup.Wait() cancels that context, causing subsequent heartbeat calls to fail with context canceled errors.",
      "proposedFix": "Use context.Background() instead of the caller's context for the heartbeat goroutine, or implement fallback logic to use the last non-canceled context when multiple contexts are provided.",
      "workaround": "Replace activity.RecordHeartbeat(gctx) with activity.RecordHeartbeat(ctx) to use the parent context instead of the derived context.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Due to the batch heartbeat logic, gctx was used after g.Wait() had finished in my code and caused a context canceled error when making the call to the server",
      "number": 1574,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:32.029Z"
    },
    {
      "summary": "gRPC status code 'Unavailable' (HTTP 503) is being incorrectly reported as 'Unknown' by the Go SDK client, even though other gRPC clients (Python SDK, raw gRPC, Postman) correctly report the 'Unavailable' code.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [
        "Dial",
        "ListNamespaces"
      ],
      "components": [
        "client",
        "error-handling",
        "grpc-wrapper"
      ],
      "concepts": [
        "grpc-status-codes",
        "error-mapping",
        "connection-failure",
        "http-503",
        "status-code-translation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot correctly identify 'Unavailable' gRPC errors returned by the server, making error handling and retry logic incorrect.",
      "rootCause": "The Go SDK is wrapping or translating gRPC errors incorrectly, converting 'Unavailable' status codes to 'Unknown', unlike raw gRPC clients.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was fixed in a recent commit after master branch; tests confirm that DialClient now correctly returns Unavailable status code.",
      "related": [],
      "keyQuote": "We want to make sure we match what Go gRPC does here, so maybe we're wrapping incorrectly compared to pure gRPC use.",
      "number": 1573,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:31.038Z"
    },
    {
      "summary": "User requested support for Temporal Cloud API Keys in the Go SDK client. The SDK was only documented as supporting mTLS connections, though API key support was already implemented via NewAPIKeyStaticCredentials but not well-documented. The issue was resolved by clarifying that API keys are still experimental for cloud and most namespaces require mTLS authentication.",
      "category": "feature",
      "subcategory": "cloud-authentication",
      "apis": [
        "NewAPIKeyStaticCredentials",
        "ClientOptions",
        "client.Dial"
      ],
      "components": [
        "client",
        "credentials",
        "connection-options"
      ],
      "concepts": [
        "api-keys",
        "authentication",
        "temporal-cloud",
        "mtls",
        "grpc-interceptor"
      ],
      "severity": "medium",
      "userImpact": "Users connecting to Temporal Cloud need clear guidance on authentication options, including when and how to use API keys versus mTLS certificates.",
      "rootCause": "API key support existed but was undocumented in the Go SDK, and most Temporal Cloud namespaces were still configured for mTLS-only authentication.",
      "proposedFix": "NewAPIKeyStaticCredentials can be passed to Credentials in ClientOptions with a gRPC unary interceptor to append the temporal-namespace metadata header.",
      "workaround": "Use the NewAPIKeyStaticCredentials approach with proper namespace metadata in gRPC interceptor, or request API key support enablement from Temporal Cloud support.",
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by documenting that API key support is available via NewAPIKeyStaticCredentials but remains experimental for cloud; most namespaces still require mTLS. Solution provided in comments with example code.",
      "related": [],
      "keyQuote": "API keys are still experimental for cloud and most cloud namespaces still use mTLS based authentication. If you want to enable API key support for your cloud account, please open a cloud ticket.",
      "number": 1570,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:19.357Z"
    },
    {
      "summary": "Worker panics with index out of range error when receiving a legacy query task with no history while a destroyed execution exists in cache. The SDK should detect this is a legacy query task and reset the cached execution, but instead crashes.",
      "category": "bug",
      "subcategory": "workflow-task-handling",
      "apis": [],
      "components": [
        "worker",
        "workflow-task-handler",
        "execution-cache"
      ],
      "concepts": [
        "legacy-query-task",
        "cache-management",
        "panic-recovery",
        "history-handling",
        "execution-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Workers crash unexpectedly when processing legacy query tasks, causing service disruption and loss of task processing capacity.",
      "rootCause": "GetOrCreateWorkflowContext attempts to access workflow history at index 0 without checking if history is empty for legacy query tasks with no history.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed in SDK release v1.28.1 or later with proper handling of legacy query tasks with no history",
      "related": [],
      "keyQuote": "runtime error: index out of range [0] with length 0",
      "number": 1567,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:14.726Z"
    },
    {
      "summary": "The VisitPayloads function in go.temporal.io/api/proxy doesn't support the export package, which is an orphan package not referenced by the workflow service. The request is to extend the generated code to handle this package.",
      "category": "other",
      "subcategory": "api-generation",
      "apis": [
        "VisitPayloads"
      ],
      "components": [
        "proxy",
        "export-package",
        "code-generation"
      ],
      "concepts": [
        "payload-visiting",
        "package-coverage",
        "api-generation",
        "code-generation"
      ],
      "severity": "low",
      "userImpact": "Users working with the export package cannot use VisitPayloads for payload processing, limiting functionality for this package.",
      "rootCause": "The export package is not referenced by the workflow service, so the code generation for VisitPayloads doesn't include it as an edge case.",
      "proposedFix": "Extend the generated code that backs VisitPayloads to include support for the export package.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The VisitPayloads function was updated to support the export package in the code generation.",
      "related": [],
      "keyQuote": "Have the generated code that backs the `go.temporal.io/api/proxy.VisitPayloads` work for `export` package too.",
      "number": 1566,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:16.280Z"
    },
    {
      "summary": "Request to implement user metadata and workflow metadata query functionality in the Go SDK. This feature is dependent on server capabilities and references a cross-repository feature request.",
      "category": "feature",
      "subcategory": "metadata-query",
      "apis": [],
      "components": [
        "metadata",
        "query-api",
        "workflow-execution"
      ],
      "concepts": [
        "metadata",
        "workflow-state",
        "query-interface",
        "server-capability",
        "data-retrieval"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to query user and workflow metadata, enabling better visibility into workflow execution state.",
      "rootCause": null,
      "proposedFix": "Implement metadata query functionality following the cross-repository feature specification in temporalio/features#486",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support user and workflow metadata queries in the Go SDK",
      "related": [
        486
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/486. This can only be worked on in Go at this time because CI is testing against unstable server currently.",
      "number": 1565,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:01.661Z"
    },
    {
      "summary": "Add test coverage for Nexus sync and async operations on Temporal Cloud. The challenge involves managing concurrent tests with Nexus endpoints that require advance definition and have registration delays.",
      "category": "feature",
      "subcategory": "nexus-testing",
      "apis": [],
      "components": [
        "nexus",
        "test-framework",
        "cloud-integration"
      ],
      "concepts": [
        "testing",
        "concurrency",
        "endpoint-registration",
        "task-queue",
        "cloud-deployment"
      ],
      "severity": "medium",
      "userImpact": "Users need confidence that Nexus operations work correctly on Cloud, but current testing infrastructure lacks adequate coverage due to concurrency and registration constraints.",
      "rootCause": "The Nexus endpoint registry has inherent registration delay and endpoints must be defined in advance for specific task queues, making it difficult to run tests concurrently.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The tricky part to test this would be to allow tests to run concurrently since a Nexus endpoint has to be defined in advance and it points to a specific task queue.",
      "number": 1564,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:59.982Z"
    },
    {
      "summary": "Request to add support for Search Attributes in Schedules through Query Update functionality in the Go SDK. The issue was flagged as potentially better suited for cross-SDK tracking in the features repository rather than being Go-specific.",
      "category": "feature",
      "subcategory": "schedules",
      "apis": [
        "QueryUpdate"
      ],
      "components": [
        "schedules",
        "search-attributes",
        "query"
      ],
      "concepts": [
        "search-attributes",
        "schedules",
        "query-update",
        "cross-sdk-feature"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently search for workflows in schedules using search attributes, limiting visibility and querying capabilities.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Closed as the issue should be tracked in the features repository as a cross-SDK feature request rather than Go-specific, allowing coordinated implementation across all SDKs.",
      "related": [],
      "keyQuote": "We usually use the https://github.com/temporalio/features repository to make cross-SDK issues like this one so we track it for each SDK.",
      "number": 1561,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:05:03.287Z"
    },
    {
      "number": 1554,
      "summary": "NonDeterministicError occurs intermittently in a workflow with a 48-hour timer and workflow updates, even though replay succeeds without errors. The issue appears related to the activity scheduling state machine in the SDK.",
      "category": "bug",
      "subcategory": "workflow-updates",
      "apis": [
        "SetUpdateHandler",
        "NewTimer",
        "NewChannel",
        "Select"
      ],
      "components": [
        "command-state-machine",
        "event-handlers",
        "workflow-execution-context",
        "activity-scheduling"
      ],
      "concepts": [
        "non-determinism",
        "state-machine",
        "workflow-replay",
        "concurrency",
        "event-ordering",
        "activity-scheduling"
      ],
      "severity": "high",
      "userImpact": "Workflows intermittently fail with NonDeterministicError despite successful replays, causing production reliability issues that are difficult to reproduce and debug.",
      "rootCause": "Likely a race condition or state machine issue in activity scheduling when combined with workflow updates and timers, potentially triggered by timing interactions between concurrent operations.",
      "proposedFix": null,
      "workaround": "User found a workaround at the code level due to difficulty upgrading SDK/Server versions in production.",
      "resolution": "invalid",
      "resolutionDetails": "Issue closed as user identified it was related to using an older SDK version (1.22.1) with experimental Workflow Update feature. Recommendation was to upgrade to latest stable releases (SDK v1.28.1+), which included multiple bug fixes that could resolve this behavior.",
      "related": [],
      "keyQuote": "sometimes a non-determinism error crashes, and the replays go normal on the same workflow on which the non-determinism error occurs",
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:48.924Z"
    },
    {
      "summary": "Typed search attributes defined in workflow options are not propagated when using SignalWithStartWorkflow to create a new execution, though they work correctly with ExecuteWorkflow.",
      "category": "bug",
      "subcategory": "workflow-options",
      "apis": [
        "SignalWithStartWorkflow",
        "ExecuteWorkflow",
        "StartWorkflowOptions"
      ],
      "components": [
        "workflow-client",
        "search-attributes",
        "signal-handling"
      ],
      "concepts": [
        "typed-search-attributes",
        "workflow-creation",
        "signal-with-start",
        "options-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use typed search attributes with SignalWithStartWorkflow when creating new workflow executions, limiting searchability of dynamically created workflows.",
      "rootCause": "The SignalWithStartWorkflow implementation in internal_workflow_client.go line 1713 does not propagate typed search attributes like the ExecuteWorkflow implementation at line 1572 does.",
      "proposedFix": "Update SignalWithStartWorkflow to mirror the typed search attributes propagation logic from ExecuteWorkflow.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bug confirmed by maintainer and fix implemented to propagate typed search attributes in SignalWithStartWorkflow similar to ExecuteWorkflow.",
      "related": [],
      "keyQuote": "are propagated fine via ExecuteWorkflow but are missed to be propagated to new execution via SignalWithStartWorkflow",
      "number": 1551,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:44.653Z"
    },
    {
      "summary": "After upgrading to SDK v1.27.0, users encounter context deadline exceeded errors when connecting to Temporal Server. The issue is resolved by downgrading to v1.26.1, suggesting a regression in the newer version.",
      "category": "bug",
      "subcategory": "client-connection",
      "apis": [
        "client.Dial",
        "client.ExecuteWorkflow",
        "workflow.ExecuteActivity"
      ],
      "components": [
        "client",
        "connection",
        "network",
        "grpc"
      ],
      "concepts": [
        "context deadline",
        "connection timeout",
        "client initialization",
        "network resolution",
        "localhost resolution",
        "version regression"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to v1.27.0 are unable to connect to Temporal Server and cannot run workflows.",
      "rootCause": "Likely a networking issue specific to the user's environment or a regression in v1.27.0 affecting localhost resolution or connection timeout handling.",
      "proposedFix": "Use passthrough:///localhost:7233 format or try using the IP address of the server instead of hostname.",
      "workaround": "Downgrade to v1.26.1 or use IP address instead of localhost for HostPort configuration.",
      "resolution": "invalid",
      "resolutionDetails": "Determined to be a client-side networking issue in the user's environment (resolved when tested from different location), not a product bug.",
      "related": [],
      "keyQuote": "It must have been a networking issue at the client. Closing for now.",
      "number": 1550,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:49.288Z"
    },
    {
      "summary": "User requests the ability to customize histogram buckets on a per-metric basis in the Go SDK. Currently, bucket configuration only applies globally through Tally's Reporter.RegisterTimer, making it impossible to customize buckets for specific metrics like temporal_activity_execution_latency_bucket without affecting all metrics.",
      "category": "feature",
      "subcategory": "metrics-configuration",
      "apis": [],
      "components": [
        "metrics",
        "tally-reporter",
        "histogram-buckets"
      ],
      "concepts": [
        "metrics",
        "histogram",
        "buckets",
        "tally",
        "configuration",
        "monitoring"
      ],
      "severity": "low",
      "userImpact": "Users cannot customize histogram bucket sizes for individual metrics, forcing them to choose between accepting defaults or changing buckets globally for all metrics.",
      "rootCause": "Tally integration only supports global histogram bucket configuration through Reporter.RegisterTimer, with no per-metric granularity.",
      "proposedFix": "Implement per-metric bucket customization support separate from global Tally configuration.",
      "workaround": "Use Tally's Reporter.RegisterTimer to configure buckets globally for all metrics.",
      "resolution": "wontfix",
      "resolutionDetails": "Closing as this configuration is part of Tally's scope of responsibility and not within SDK scope.",
      "related": [],
      "keyQuote": "The only way supported right now is with Tally, which will customize the buckets for all the metrics.",
      "number": 1549,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:32.035Z"
    },
    {
      "summary": "Child workflow update handler was not being registered in test scenarios, causing test failures. The issue was identified and fixed via PR #1548.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "test-framework",
        "workflow-update",
        "child-workflow"
      ],
      "concepts": [
        "workflow-update",
        "handler-registration",
        "child-workflow",
        "testing",
        "test-setup"
      ],
      "severity": "medium",
      "userImpact": "Tests for child workflow update handlers fail due to unregistered handlers, preventing users from properly testing update functionality.",
      "rootCause": "Child workflow update handler was not being properly registered during test setup.",
      "proposedFix": "Ensure update handler is registered before executing child workflow in tests.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #1548 which addressed the handler registration issue in the test framework.",
      "related": [
        1548
      ],
      "keyQuote": "Child workflow update handler not registered in test",
      "number": 1547,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:33.597Z"
    },
    {
      "summary": "Review and add tests for Nexus operation log and metrics labels. The issue requests auditing the labels currently set on metrics handler and logger from temporalnexus.GetMetricsHandler and temporalnexus.GetLogger (currently including Nexus service, Nexus operation, and task queue), identifying any missing useful labels, and updating tests accordingly.",
      "category": "feature",
      "subcategory": "nexus-metrics-observability",
      "apis": [
        "GetMetricsHandler",
        "GetLogger"
      ],
      "components": [
        "nexus",
        "metrics-handler",
        "logger",
        "observability"
      ],
      "concepts": [
        "metrics",
        "labels",
        "logging",
        "observability",
        "testing",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Users need comprehensive metrics and logging labels for Nexus operations to properly monitor and debug Nexus workflows and activities in production.",
      "rootCause": null,
      "proposedFix": "Review current label set (Nexus service, Nexus operation, task queue) and add any other useful labels; update tests to verify they are set appropriately.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed after implementation of metrics and logging labels review and test updates for Nexus operations.",
      "related": [],
      "keyQuote": "Review the labels that are currently set on the metrics handler and logger returned from temporalnexus.GetMetricsHandler and temporalnexus.GetLogger.",
      "number": 1545,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:30.147Z"
    },
    {
      "summary": "Add support for query filtering when listing schedules in the Go SDK, matching the existing functionality available for listing workflows.",
      "category": "feature",
      "subcategory": "schedule-management",
      "apis": [
        "ListSchedules"
      ],
      "components": [
        "schedule-client",
        "list-api",
        "query-filtering"
      ],
      "concepts": [
        "query",
        "filtering",
        "schedules",
        "list-operations",
        "workflow-management"
      ],
      "severity": "medium",
      "userImpact": "Users cannot filter schedules by query when listing them, limiting their ability to efficiently search and manage large numbers of schedules.",
      "rootCause": null,
      "proposedFix": "Implement query option for ListSchedules similar to the existing ListWorkflows implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Query filtering capability was added to the ListSchedules API to match ListWorkflows functionality.",
      "related": [],
      "keyQuote": "Need to support the query option when listing schedules same as we do when listing workflows.",
      "number": 1539,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:18.487Z"
    },
    {
      "summary": "After upgrading to SDK v1.27.0, users encounter connection failures with 'context deadline exceeded' error. The issue was caused by a breaking change in gRPC client initialization that requires the `passthrough:///` prefix in the HostPort configuration.",
      "category": "bug",
      "subcategory": "client-connection",
      "apis": [
        "Dial",
        "CheckHealth"
      ],
      "components": [
        "client",
        "grpc",
        "connection-manager"
      ],
      "concepts": [
        "connection-timeout",
        "grpc-client",
        "host-resolution",
        "breaking-change",
        "configuration",
        "tls"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to v1.27.0 experience connection failures to Temporal clusters and must update their connection configuration to include the passthrough:/// prefix.",
      "rootCause": "SDK v1.27.0 switched from grpc.Dial to grpc.NewClient, which changed how host addresses are resolved and now requires the passthrough:/// scheme prefix for direct host connections.",
      "proposedFix": "Include the passthrough:/// prefix in the HostPort configuration: HostPort: fmt.Sprintf(\"passthrough:///%s\", addr)",
      "workaround": "Add the passthrough:/// prefix to the HostPort configuration when creating a new client connection.",
      "resolution": "fixed",
      "resolutionDetails": "Documented in SDK v1.27.0 release notes under 'Internally call grpc.NewClient instead of grpc.Dial' with reference to gRPC custom name resolution guide.",
      "related": [],
      "keyQuote": "Looks like I need to add the `passthrough:///` only to the `HostPort` config key. When I do that it works.",
      "number": 1537,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:19.286Z"
    },
    {
      "summary": "IdReusePolicy.TERMINATE_IF_RUNNING is not working correctly for duplicate child workflow starts. When a child workflow is started twice with this policy, the second start fails with ChildWorkflowExecutionAlreadyStartedError instead of terminating the first execution.",
      "category": "bug",
      "subcategory": "child-workflows",
      "apis": [
        "StartChildWorkflowExecution",
        "IdReusePolicy"
      ],
      "components": [
        "child-workflow-executor",
        "workflow-execution",
        "id-reuse-policy"
      ],
      "concepts": [
        "idempotency",
        "duplicate-handling",
        "execution-termination",
        "workflow-lifecycle",
        "policy-enforcement"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably restart child workflows with TERMINATE_IF_RUNNING policy, breaking idempotent workflow patterns.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A child workflow with IdReusePolicy set to TERMINATE_IF_RUNNING is started twice from the same parent. Both starts are expected to succeed.",
      "number": 1536,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:15.447Z"
    },
    {
      "summary": "Request to export a Carrier implementation for OpenTelemetry trace context propagation in Temporal headers, allowing custom interceptors to use the same carrier that the temporal interceptor uses for consistent trace propagation.",
      "category": "feature",
      "subcategory": "opentelemetry-integration",
      "apis": [],
      "components": [
        "opentelemetry-contrib",
        "tracing-interceptor",
        "header-carrier"
      ],
      "concepts": [
        "trace-propagation",
        "opentelemetry",
        "context-carrier",
        "interceptor",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Users writing custom interceptors can now use the same OpenTelemetry carrier implementation as Temporal's interceptor, ensuring consistent trace context propagation across mixed interceptor setups.",
      "rootCause": null,
      "proposedFix": "Export a Carrier implementation that parses/loads OpenTelemetry data into temporal headers and refactor the temporal interceptor to use this exported carrier.",
      "workaround": "Define the carrier locally in private code or implement a custom OpenTelemetry interceptor without using the standard carrier.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed based on discussion in PR #1534. Maintainers indicated they encourage users to write their own custom interceptors rather than exporting a shared carrier implementation.",
      "related": [
        1534
      ],
      "keyQuote": "We encourage users to write their own interceptors to do what they need if they need something beyond that.",
      "number": 1535,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:02.044Z"
    },
    {
      "summary": "User requests the ability to return a CanceledError from an activity without it being treated as an unexpected error. Currently, the SDK wraps user-returned CanceledErrors in a generic error, causing them to be retried rather than marked as cancelled.",
      "category": "feature",
      "subcategory": "activity-cancellation",
      "apis": [
        "NewCanceledError"
      ],
      "components": [
        "activity-executor",
        "task-handler",
        "error-handling"
      ],
      "concepts": [
        "activity-cancellation",
        "error-handling",
        "retry-logic",
        "context-cancellation",
        "activity-lifecycle"
      ],
      "severity": "low",
      "userImpact": "Users cannot elegantly represent non-error stop conditions in activities and must use non-retryable errors as a workaround.",
      "rootCause": "The SDK checks whether the context was actually cancelled by the server before accepting a CanceledError; if not cancelled server-side, the error is wrapped as unexpected and treated as a retriable error.",
      "proposedFix": "Stop checking that context is cancelled when handling a CanceledError returned from an activity.",
      "workaround": "Return a non-retryable error instead of CanceledError to represent the stop condition.",
      "resolution": "wontfix",
      "resolutionDetails": "Server-side platform behavior prevents activities from being marked as cancelled unless the server issued the cancellation. The SDK correctly enforces this constraint by converting non-server-initiated cancellations to errors.",
      "related": [],
      "keyQuote": "Activity cancellation can only result from the server issuing a cancellation, an activity cannot appear cancelled just by returning cancelled.",
      "number": 1527,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:04.836Z"
    },
    {
      "summary": "Starting a DevServer with UI enabled can fail when the calculated UI port exceeds the valid port range (1-65535). The SDK adds 1000 to the server port for the UI port, which causes an error when the server port is above 64535.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartDevServer"
      ],
      "components": [
        "dev-server",
        "test-suite",
        "port-allocation"
      ],
      "concepts": [
        "port-allocation",
        "ui-configuration",
        "range-validation",
        "port-conflict",
        "test-server"
      ],
      "severity": "medium",
      "userImpact": "Tests using DevServer with UI enabled randomly fail on Windows and other platforms when the dynamically allocated server port results in an invalid UI port number.",
      "rootCause": "The SDK calculates UI port by adding 1000 to the server port without validating that the result stays within the valid port range (1-65535).",
      "proposedFix": "Add a UIPort option with intelligent defaults: random if server port is random, server port + 1000 if server port is present and valid, or allow explicit configuration.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in the temporal CLI with commit 469e8cf4a2a5743e829a19b209f1fa499665d2cf",
      "related": [],
      "keyQuote": "can't use default UI port 66146 (65146 + 1000): listen tcp: address 66146: invalid port",
      "number": 1526,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:04:04.035Z"
    },
    {
      "summary": "Go SDK 1.26.0+ cannot deserialize proto messages that were originally serialized with gogoproto, breaking deserialization when API protos are upgraded from gogoproto.message to proto.Message types.",
      "category": "bug",
      "subcategory": "serialization",
      "apis": [
        "ListWorkflowExecutionsResponse"
      ],
      "components": [
        "proto-serialization",
        "deserializer",
        "gogoproto-compatibility"
      ],
      "concepts": [
        "serialization",
        "deserialization",
        "proto-message",
        "backwards-compatibility",
        "schema-evolution",
        "type-conversion"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to Go SDK 1.26.0+ will experience deserialization failures when using API protos that were previously serialized with gogoproto.",
      "rootCause": "Changing proto message serializer from gogoproto to proto.Message without a compatible deserializer causes the SDK to use the wrong deserialization method for previously serialized data.",
      "proposedFix": "Alter the converter to use an accept-both-forms proto marshaler that can handle both old-form (gogoproto) and new-form (proto.Message) JSON serialization.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Converter was updated to support both gogoproto and proto.Message serialization formats through a dual-form proto marshaler.",
      "related": [],
      "keyQuote": "if ListWorkflowExecutionsResponse was serialized with gogoproto as it was a gogoproto.message, by updating go.temporal.io ListWorkflowExecutionsResponse would now be a normal proto.Message so it would not use the gogoproto deserializer and fail.",
      "number": 1525,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:50.702Z"
    },
    {
      "summary": "Allow users to set search attributes when starting the dev server through SDK options, which will translate to --search-attribute CLI calls.",
      "category": "feature",
      "subcategory": "dev-server",
      "apis": [],
      "components": [
        "dev-server",
        "configuration"
      ],
      "concepts": [
        "search-attributes",
        "server-initialization",
        "configuration-options"
      ],
      "severity": "medium",
      "userImpact": "Users can now configure search attributes directly in dev server startup options instead of requiring separate CLI arguments.",
      "rootCause": null,
      "proposedFix": "Accept search attributes in dev server startup options that translate to --search-attribute calls",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented feature allowing search attributes to be set via dev server options",
      "related": [
        494
      ],
      "keyQuote": "users should be allowed to set search attributes in dev server option that translate to `--search-attribute` calls",
      "number": 1523,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:45.865Z"
    },
    {
      "summary": "Need a workflow-friendly concurrency control mechanism (mutex/semaphore) that is reentrant and deterministic for use within signal handlers, update handlers, and main workflow coroutines.",
      "category": "feature",
      "subcategory": "concurrency-control",
      "apis": [],
      "components": [
        "workflow-execution",
        "signal-handler",
        "update-handler",
        "coroutine"
      ],
      "concepts": [
        "concurrency",
        "mutex",
        "semaphore",
        "reentrancy",
        "determinism",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "Users lack a proper way to coordinate concurrent operations within workflows, limiting their ability to build complex workflow logic safely.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented via PR #1530",
      "related": [
        1530
      ],
      "keyQuote": "We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.",
      "number": 1521,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:46.694Z"
    },
    {
      "summary": "Request for a workflow-friendly concurrency control mechanism (mutex/semaphore) that is reentrant and deterministic for use within signal handlers, update handlers, and main workflow coroutines in the Go SDK.",
      "category": "feature",
      "subcategory": "concurrency-control",
      "apis": [],
      "components": [
        "workflow-coroutine",
        "signal-handler",
        "update-handler",
        "synchronization"
      ],
      "concepts": [
        "concurrency",
        "mutex",
        "semaphore",
        "determinism",
        "reentrancy",
        "workflow-safety",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "Users need a safe, deterministic way to manage concurrent access within workflow logic without the pitfalls of standard Go concurrency primitives.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "A workflow-friendly concurrency control mechanism was implemented to support reentrant and deterministic operations within workflow coroutines, signals, and updates.",
      "related": [],
      "keyQuote": "We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.",
      "number": 1520,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:31.925Z"
    },
    {
      "summary": "Minimal issue with only the word 'testing' in the body. Likely a placeholder or accidental submission that was closed.",
      "category": "other",
      "subcategory": "unclear",
      "apis": [],
      "components": [],
      "concepts": [
        "testing"
      ],
      "severity": "low",
      "userImpact": "No clear user impact; insufficient information provided.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue closed due to insufficient detail and unclear scope.",
      "related": [],
      "keyQuote": "testing",
      "number": 1519,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:32.732Z"
    },
    {
      "summary": "Placeholder testing issue with minimal content.",
      "category": "other",
      "subcategory": "testing",
      "apis": [],
      "components": [],
      "concepts": [
        "testing",
        "quality-assurance"
      ],
      "severity": "low",
      "userImpact": "No clear user impact from this placeholder issue.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue closed as invalid - contained only placeholder text with no actual testing problem or request.",
      "related": [],
      "keyQuote": "testing",
      "number": 1518,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:34.218Z"
    },
    {
      "summary": "Minimal issue with only the word 'testing' in the body. Appears to be a placeholder or incomplete submission with no clear problem statement or feature request.",
      "category": "other",
      "subcategory": "unclear",
      "apis": [],
      "components": [],
      "concepts": [
        "testing"
      ],
      "severity": "low",
      "userImpact": "Unable to determine impact due to insufficient issue description.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed, likely due to being incomplete or not actionable without proper description.",
      "related": [],
      "keyQuote": "testing",
      "number": 1517,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:18.590Z"
    },
    {
      "summary": "User requested exposing UpdateID in update handlers to enable unique primary keys for samples. The issue was closed as the UpdateID is already exposed through the UpdateInfo API.",
      "category": "question",
      "subcategory": "update-handler",
      "apis": [
        "UpdateInfo"
      ],
      "components": [
        "update-handler",
        "update-info"
      ],
      "concepts": [
        "unique-identifier",
        "primary-key",
        "update-metadata",
        "handler-context"
      ],
      "severity": "low",
      "userImpact": "Users can already access UpdateID through the UpdateInfo API to use as unique identifiers in their update handlers.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Update ID is already exposed through the UpdateInfo API at go.temporal.io/sdk@v1.26.1/internal#UpdateInfo",
      "related": [],
      "keyQuote": "Update ID is already exposed",
      "number": 1501,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:21.575Z"
    },
    {
      "summary": "Users need methods to wait for all remaining handlers to complete when continuing as new or exiting a workflow, allowing them to specify whether to await or ignore these handlers.",
      "category": "feature",
      "subcategory": "workflow-handlers",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "workflow",
        "handler-management",
        "execution-control"
      ],
      "concepts": [
        "async-completion",
        "cleanup",
        "graceful-shutdown",
        "handler-lifecycle",
        "workflow-exit",
        "continuation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily ensure handlers complete execution before workflow continuation or exit, leading to potential data loss or incomplete cleanup.",
      "rootCause": null,
      "proposedFix": "Provide explicit methods allowing users to specify whether to wait for handlers to finish when continuing as new or exiting the workflow.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Methods were implemented to allow waiting for handlers to finish during workflow continuation and exit.",
      "related": [],
      "keyQuote": "Users want to easily await (or ignore) all their remaining handlers when they continue as new or exit the workflow.",
      "number": 1500,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:20.988Z"
    },
    {
      "summary": "Add warnings or errors when update and signal handlers are not completed when a workflow exits due to cancellation, failure, or success. SDK should provide methods to await all handlers and a configurable policy to warn or abandon unfinished handlers.",
      "category": "feature",
      "subcategory": "update-handlers",
      "apis": [
        "all_handlers_finished"
      ],
      "components": [
        "worker",
        "update-handler",
        "signal-handler",
        "workflow-exit"
      ],
      "concepts": [
        "handler-lifecycle",
        "graceful-shutdown",
        "workflow-completion",
        "cancellation",
        "abandonment"
      ],
      "severity": "medium",
      "userImpact": "Users need visibility into unfinished update/signal handlers and methods to properly await or abandon them before workflow exit.",
      "rootCause": "Update and signal handlers can dangle across cancellation or workflow exit without user awareness or control.",
      "proposedFix": "Implement await-all-handlers method, emit UnfinishedUpdateHandlersWarning/UnfinishedSignalHandlersWarning by default, and provide HandlerUnfinishedPolicy configuration (WARN_AND_ABANDON, ABANDON, etc.)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in Python SDK (PR #556) with spec for other SDKs including all_handlers_finished() method, warnings on worker-side exit, and per-handler unfinished_policy configuration.",
      "related": [],
      "keyQuote": "Workflow code can wait on a method named similarly to `workflow.all_handlers_finished()`",
      "number": 1499,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:07.291Z"
    },
    {
      "summary": "Ensure that gRPC metadata headers like client-name and client-version are properly forwarded through the Temporal proxy helpers. Need to write tests to confirm metadata flows correctly and implement forwarding if necessary.",
      "category": "feature",
      "subcategory": "proxy-helpers",
      "apis": [],
      "components": [
        "proxy-helpers",
        "grpc-metadata",
        "code-generation"
      ],
      "concepts": [
        "metadata-forwarding",
        "grpc-headers",
        "client-identification",
        "proxy-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users relying on proxy helpers need to ensure that client identification headers are preserved when routing requests through the proxy layer.",
      "rootCause": "Code generation may not be properly copying gRPC metadata from incoming to outgoing context in the proxy helpers.",
      "proposedFix": "Use google.golang.org/grpc/metadata to populate incoming context to outgoing context, with an option to disable if needed.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "PR opened at api-go#167 to implement metadata forwarding in proxy helpers, pending SDK release.",
      "related": [
        1502
      ],
      "keyQuote": "we need to confirm that when using the proxy library in the default way, that the headers like client-name/client-version flow through the proxy",
      "number": 1497,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:04.252Z"
    },
    {
      "summary": "Workflow cancellation behavior differs between test environment and real server. When canceling a child workflow, the test env propagates the child's cancellation error while the real server only returns a canceled status at the parent level. The proposal is to align test env behavior with the real server.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "WithCancel",
        "Await"
      ],
      "components": [
        "test-workflow-engine",
        "child-workflow-cancellation",
        "error-handling"
      ],
      "concepts": [
        "workflow-cancellation",
        "child-workflow",
        "error-propagation",
        "test-consistency",
        "behavioral-divergence"
      ],
      "severity": "medium",
      "userImpact": "Users experience different workflow outcomes and error messages when testing locally versus running on production servers, making test reliability difficult.",
      "rootCause": "Test environment propagates child workflow cancellation errors through the error chain, while real server returns only the parent workflow cancellation status.",
      "proposedFix": "Change test environment to match real server behavior by not propagating child workflow cancellation errors and instead returning only the parent workflow's canceled status.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The test env is consistent with the behavior of other SDKs, but it's likely too late to change the cancelation behavior with the real server for consistency.",
      "number": 1496,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:03:08.170Z"
    },
    {
      "summary": "Request to add a RawValue payload converter to the Go SDK for testing purposes, allowing raw payloads to be created in workflows without custom data converters. This feature already exists in other SDKs like Python and is useful for internal and user testing.",
      "category": "feature",
      "subcategory": "payload-converter",
      "apis": [],
      "components": [
        "payload-converter",
        "data-converter",
        "testing"
      ],
      "concepts": [
        "raw-payload",
        "testing",
        "data-serialization",
        "workflow-execution"
      ],
      "severity": "low",
      "userImpact": "Users and Temporal developers can create raw payloads in workflows for testing without implementing custom data converters.",
      "rootCause": null,
      "proposedFix": "Implement RawValue payload converter similar to the Python SDK implementation (reference: temporalio/sdk-python common.py L151)",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Duplicate of issue #1231, which already addresses this feature request",
      "related": [
        1231
      ],
      "keyQuote": "It's frequently useful in our own various testing environments to be able to create raw payloads in a workflow without needing to hook up custom data converters.",
      "number": 1493,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:49.234Z"
    },
    {
      "summary": "User requested the ability to configure the logging keys for TraceID and SpanID in the OpenTelemetry tracing interceptor, as the currently hardcoded keys make it difficult to maintain logging consistency with other system components.",
      "category": "feature",
      "subcategory": "logging-configuration",
      "apis": [],
      "components": [
        "tracing-interceptor",
        "opentelemetry-integration",
        "logger"
      ],
      "concepts": [
        "logging",
        "tracing",
        "configuration",
        "key-naming",
        "consistency",
        "interceptor"
      ],
      "severity": "low",
      "userImpact": "Users with custom logging systems cannot easily align the trace ID and span ID keys with their existing conventions without creating wrapper interceptors.",
      "rootCause": null,
      "proposedFix": "Add LoggingTraceIDKey and LoggingSpanIDKey fields to TracerOptions struct with defaults 'TraceID' and 'SpanID', and use these configurable keys in the GetLogger method instead of hardcoded values.",
      "workaround": "Create a custom interceptor that wraps the OpenTelemetry tracing interceptor and maps the default keys to custom keys, though this results in duplicate keys in logs.",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainer indicated that logging keys can be changed by the logger implementation itself, specifically through slog's ReplaceAttr in HandlerOptions, making the requested feature unnecessary.",
      "related": [],
      "keyQuote": "All logging keys can also be changed by the logger implementation. If your using the standard library slog with our integration you can use ReplaceAttr in HandlerOptions to replace any key you want.",
      "number": 1492,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:46.177Z"
    },
    {
      "summary": "Improve testing capabilities for Nexus Operations by adding a TestNexusEnvironment for unit testing operations outside workflow context and integrating OnNexusOperation into the workflow test environment for mocking and time skipping.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "nexus-operations",
        "test-environment",
        "workflow-testing",
        "sync-operations"
      ],
      "concepts": [
        "testing",
        "mocking",
        "nexus",
        "operations",
        "test-environment",
        "time-skipping"
      ],
      "severity": "medium",
      "userImpact": "Users currently cannot effectively test Nexus operations outside of workflow context, limiting their ability to write unit tests for operation handlers.",
      "rootCause": null,
      "proposedFix": "Add TestNexusEnvironment for testing operations outside workflow context and add OnNexusOperation method to workflow test environment to integrate with mocking and time skipping.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed after implementation of testing improvements for Nexus Operations.",
      "related": [],
      "keyQuote": "Add a TestNexusEnvironment for users to test their operations outside of workflow context",
      "number": 1491,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:53.060Z"
    },
    {
      "summary": "workflowcheck tool fails with an error when provided files from different directories (main.go in root, workflow file in subdirectory), showing 'named files must all be in one directory' error message.",
      "category": "bug",
      "subcategory": "workflowcheck-tool",
      "apis": [],
      "components": [
        "workflowcheck",
        "tool",
        "loader"
      ],
      "concepts": [
        "file-organization",
        "multi-directory",
        "determinism-checking",
        "tooling-error"
      ],
      "severity": "medium",
      "userImpact": "Users cannot run workflowcheck on projects with workflows organized in subdirectories, preventing them from using the determinism validation tool on common project structures.",
      "rootCause": "workflowcheck loader requires all provided Go files to be in the same directory, but typical projects have main.go in root and workflows in a subdirectory",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved (closed), likely through a fix to workflowcheck to support multi-directory file loading",
      "related": [],
      "keyQuote": "named files must all be in one directory; have . and workflows",
      "number": 1483,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:32.617Z"
    },
    {
      "summary": "Request to wrap gRPC CANCELED and DEADLINE_EXCEEDED errors in a standardized SDK Timeout exception for Update operations, so users only need to catch one predictable exception type instead of handling multiple gRPC error codes.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "Update"
      ],
      "components": [
        "update-handler",
        "grpc-client",
        "error-handling"
      ],
      "concepts": [
        "timeout",
        "deadline",
        "exception-handling",
        "error-wrapping",
        "gRPC-errors",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users must currently catch multiple gRPC error codes when handling timeouts in Update operations, reducing code clarity and error handling consistency.",
      "rootCause": "gRPC CANCELED and DEADLINE_EXCEEDED errors are not wrapped in an SDK-specific timeout exception, forcing users to handle raw gRPC errors.",
      "proposedFix": "Wrap gRPC CANCELED and DEADLINE_EXCEEDED errors in an SDK Timeout exception for Update operations, as detailed in the referenced features issue.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented by wrapping gRPC error codes in SDK Timeout exception, allowing users to catch a single predictable exception type.",
      "related": [
        483
      ],
      "keyQuote": "So that users only have to catch one predictable exception",
      "number": 1479,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:30.459Z"
    },
    {
      "summary": "The OpenTelemetry metrics handler only reports workflow task slots availability but omits activity and local activity slots, while the Tally handler correctly reports all three. This appears to be a regression in the OpenTelemetry Go SDK between versions 1.21.0 and 1.26.0.",
      "category": "bug",
      "subcategory": "metrics-opentelemetry",
      "apis": [],
      "components": [
        "metrics-handler",
        "opentelemetry-integration",
        "worker-slots"
      ],
      "concepts": [
        "metrics-reporting",
        "task-slots",
        "telemetry",
        "opentelemetry",
        "worker-types",
        "activity-worker",
        "workflow-worker"
      ],
      "severity": "high",
      "userImpact": "Users relying on OpenTelemetry metrics cannot monitor activity and local activity worker slot availability, limiting visibility into worker capacity.",
      "rootCause": "Regression in OpenTelemetry Go SDK between versions 1.21.0 (working) and 1.26.0 (broken) affecting how metrics with different worker_type dimensions are reported.",
      "proposedFix": null,
      "workaround": "Quinn-With-Two-Ns reported having a workaround for their integration; consider reverting to OTEL Go SDK 1.21.0 or earlier.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Using the opentelemetry metrics handler the SDK only reports slots available for worker_type=\"WorkflowWorker\"",
      "number": 1477,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:34.069Z"
    },
    {
      "summary": "The Nexus Go SDK's OperationReference type lacks generic type information, preventing the Go SDK from inferring input types when executing Nexus Operations from workflows. The solution requires changes in the Nexus Go SDK to expose type information.",
      "category": "feature",
      "subcategory": "nexus-operations",
      "apis": [
        "ExecuteNexusOperation"
      ],
      "components": [
        "nexus-operation-executor",
        "workflow-execution",
        "nexus-go-sdk"
      ],
      "concepts": [
        "type-inference",
        "generics",
        "nexus-rpc",
        "operation-input",
        "type-safety"
      ],
      "severity": "medium",
      "userImpact": "Users cannot leverage type safety when executing Nexus Operations from workflows, requiring manual type handling and reducing developer experience.",
      "rootCause": "The OperationReference type in the Nexus Go SDK does not expose generic type parameters needed for inference at runtime.",
      "proposedFix": "Enhance the Nexus Go SDK's OperationReference type to expose or preserve generic type information that the Temporal SDK can access.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Likely resolved through upstream Nexus Go SDK changes to expose type information on OperationReference.",
      "related": [
        1473
      ],
      "keyQuote": "We don't have access to the generics on OperationReference, the solution may need to come from the Nexus Go SDK.",
      "number": 1476,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:17.681Z"
    },
    {
      "summary": "Add tracing interceptor support for Nexus Operations to propagate headers from workflows to Nexus Operation handlers. This requires implementing an NexusOperationInboundInterceptor.",
      "category": "feature",
      "subcategory": "nexus-tracing",
      "apis": [
        "StartOperation"
      ],
      "components": [
        "nexus-interceptor",
        "tracing-interceptor",
        "workflow"
      ],
      "concepts": [
        "header-propagation",
        "tracing",
        "interceptor",
        "nexus-operations",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot propagate tracing headers from workflows to Nexus Operation handlers, limiting observability across Nexus calls.",
      "rootCause": "NexusOperationInboundInterceptor is not implemented to support header propagation in StartOperation requests.",
      "proposedFix": "Add support for the TracingInterceptor to handle Nexus Operations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented NexusOperationInboundInterceptor to support tracing header propagation for Nexus Operations.",
      "related": [],
      "keyQuote": "We need to add support for propagating headers from a Workflow to a Nexus Operation handler to the StartOperation request.",
      "number": 1474,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:18.995Z"
    },
    {
      "summary": "Support retrieving the current build ID from the WFTStarted event instead of WFTCompleted event in new versioning. The stamp in WorkflowTaskCompletedEventAttributes is deprecated and will be removed after old versioning cleanup.",
      "category": "feature",
      "subcategory": "versioning",
      "apis": [
        "WorkflowInfo.GetCurrentBuildID()"
      ],
      "components": [
        "workflow-task",
        "versioning",
        "event-handling"
      ],
      "concepts": [
        "build-id",
        "versioning",
        "workflow-task-started",
        "backwards-compatibility",
        "deprecation"
      ],
      "severity": "medium",
      "userImpact": "Users relying on GetCurrentBuildID() need support for new versioning that retrieves the build ID from the correct event source.",
      "rootCause": "The stamp in WorkflowTaskCompletedEventAttributes is deprecated in new versioning; build ID should come from WFTStarted event instead.",
      "proposedFix": "Retrieve current build ID from WFTStarted event, with fallback to WFTCompleted event for old versioning compatibility when started event lacks a build ID.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "In new versioning, current build ID for tasks being replayed should be retrieved from the WFTStarted event rather than WFTCompleted event.",
      "number": 1471,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:15.706Z"
    },
    {
      "summary": "Feature request to allow users to specify attempt count in TestWorkflowEnvironment for testing workflow and activity logic that varies based on retry attempts.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowEnvironment",
        "test-framework"
      ],
      "concepts": [
        "testing",
        "attempt-count",
        "retry-logic",
        "workflow-testing",
        "activity-testing"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently test conditional logic that depends on attempt counts without running workflows multiple times.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users may have different logic based on the attempt count of a workflow or activity, we should allow them to test those condition",
      "number": 1469,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:02.348Z"
    },
    {
      "summary": "Interceptors are bypassed when mocking non-local activities with return values in workflow tests, unlike local activities or when using function-based mocks. This inconsistency prevents interceptor execution in test scenarios.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "workflow-testsuite",
        "activity-executor",
        "interceptor-chain",
        "mocking"
      ],
      "concepts": [
        "interceptors",
        "mocking",
        "activity-execution",
        "test-consistency",
        "local-vs-nonlocal",
        "execution-paths"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test interceptor behavior with mocked non-local activities in workflow tests, requiring workarounds like function-based mocks for consistent behavior.",
      "rootCause": "In internal_workflow_testsuite.go, non-local activity mocks with return values call getMockValue() directly instead of executing through the activity executor that handles interceptors, unlike local activities or function-based mocks.",
      "proposedFix": "Wrap mocked return values in a function at SDK level to unify execution paths between local and non-local activity mocks, ensuring interceptors are always executed.",
      "workaround": "Use function-based mocks instead of direct return values: OnActivity(...).Return(func(ctx context.Context) (...) { return result, nil })",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If the mock is a function, we execute the activity executor that calls all interceptors internally. On other if we directly specify return values, we don't use the activity executor",
      "number": 1468,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:05.182Z"
    },
    {
      "summary": "The activity_succeed_endtoend_latency metric is incorrectly recorded for all activity completions (success, failure, cancellation) instead of only for successful completions, as it does in the Java SDK.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "completion-handler"
      ],
      "concepts": [
        "metrics",
        "activity-completion",
        "latency-measurement",
        "success-tracking",
        "failure-handling"
      ],
      "severity": "medium",
      "userImpact": "Users get incorrect metrics data for activity success latency, making performance monitoring and analysis misleading.",
      "rootCause": "Pull request #575 did not properly check the activity completion type (success vs failure vs cancellation) before recording the success latency metric.",
      "proposedFix": "Implement proper filtering to only record activity_succeed_endtoend_latency when the activity completes successfully, following the pattern established in the Java SDK PR #800.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Corrected the metric recording logic to check activity completion type and only record success latency on successful completions.",
      "related": [],
      "keyQuote": "activity_succeed_endtoend_latency in https://github.com/temporalio/sdk-go/pull/575 didn't properly take into account what form of activity completion the request was for",
      "number": 1465,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:02:01.875Z"
    },
    {
      "summary": "QueryRejectCondition parameter is not being passed through in QueryWorkflowWithOptions, causing the query reject condition to be ignored when querying workflows.",
      "category": "bug",
      "subcategory": "query-workflow",
      "apis": [
        "QueryWorkflowWithOptions"
      ],
      "components": [
        "workflow-client",
        "query-handler"
      ],
      "concepts": [
        "query-reject-condition",
        "parameter-passing",
        "workflow-query",
        "option-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot specify query reject conditions when querying workflows, limiting control over query behavior.",
      "rootCause": "QueryRejectCondition parameter is not being forwarded from QueryWorkflowWithOptions to the underlying implementation at the specified code location.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Parameter passing was corrected in the QueryWorkflowWithOptions implementation.",
      "related": [],
      "keyQuote": "query reject condition not being passed",
      "number": 1460,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:47.630Z"
    },
    {
      "summary": "Add a separate Cloud Operations API client for the Go SDK using cloud-specific protobuf definitions. The client should be marked as experimental.",
      "category": "feature",
      "subcategory": "cloud-client",
      "apis": [],
      "components": [
        "cloud-client",
        "protos"
      ],
      "concepts": [
        "cloud-operations",
        "api-client",
        "experimental",
        "protobuf"
      ],
      "severity": "medium",
      "userImpact": "Users working with Temporal Cloud will have a dedicated client for cloud operations instead of using the standard SDK client.",
      "rootCause": null,
      "proposedFix": "Implement a separate cloud client using the cloud protos as referenced in the linked feature request and pull request.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Cloud Operations API client was implemented as requested.",
      "related": [
        440,
        1426
      ],
      "keyQuote": "We need a separate cloud client using the cloud protos (they are separate today). The client should be marked experimental.",
      "number": 1459,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:49.041Z"
    },
    {
      "summary": "Add automatic Temporal-Namespace header to namespace-specific gRPC requests using an interceptor that asserts the GetNamespace() interface, eliminating the need for explicit namespace configuration in client code.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [],
      "components": [
        "client",
        "interceptor",
        "grpc",
        "namespace-handling"
      ],
      "concepts": [
        "namespace-header",
        "grpc-interceptor",
        "client-configuration",
        "type-assertion",
        "header-management"
      ],
      "severity": "medium",
      "userImpact": "Users no longer need to manually configure namespace settings in DialOptions when working with namespace-specific gRPC requests.",
      "rootCause": null,
      "proposedFix": "Implement an interceptor that type asserts to `interface { GetNamespace() string }` to automatically set the Temporal-Namespace header on every namespace-specific gRPC request.",
      "workaround": "Explicitly set namespace in DialOptions (required in versions prior to fix).",
      "resolution": "fixed",
      "resolutionDetails": "Implemented interceptor to automatically set Temporal-Namespace header on namespace-specific gRPC requests, eliminating need for explicit DialOptions configuration.",
      "related": [
        475
      ],
      "keyQuote": "This can be done with an interceptor that type asserts to `interface { GetNamespace() string }`",
      "number": 1458,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:50.987Z"
    },
    {
      "summary": "SetUpdateHandler accepts handlers that don't require workflow.Context as first parameter, but at runtime it fails with a cryptic error when the handler tries to use the wrong context. The handler should be required to take workflow.Context as its first parameter.",
      "category": "bug",
      "subcategory": "update-handler",
      "apis": [
        "SetUpdateHandler",
        "SetUpdateHandlerWithOptions",
        "workflow.Context"
      ],
      "components": [
        "update-handler",
        "workflow-context",
        "coroutine-scheduler"
      ],
      "concepts": [
        "context-handling",
        "handler-signature",
        "determinism",
        "coroutine-blocking",
        "type-safety"
      ],
      "severity": "high",
      "userImpact": "Users can write type-correct but semantically incorrect update handlers that fail at runtime with confusing error messages about coroutine scheduling.",
      "rootCause": "SetUpdateHandler does not enforce that handler functions must have workflow.Context as the first parameter, allowing handlers to capture and use the wrong context instance, causing coroutine scheduling conflicts.",
      "proposedFix": "Make workflow.Context a required first parameter for update handler functions and fail at SetUpdateHandler call time with a clear error message if the signature is incorrect.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Update handler signature validation was implemented to require workflow.Context as first parameter and provide clear error messages at handler registration time.",
      "related": [],
      "keyQuote": "SetUpdateHandler should be documented as taking a handler function that must take a workflow.Context as its first parameter.",
      "number": 1455,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:36.816Z"
    },
    {
      "summary": "Add support for next-retry-delay in application failures from local activities, extending functionality previously implemented for remote activities.",
      "category": "feature",
      "subcategory": "local-activity-retry",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity-executor",
        "retry-handler",
        "failure-processing"
      ],
      "concepts": [
        "retry",
        "delay",
        "local-activity",
        "failure-handling",
        "application-error"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure custom retry delays for local activity failures, limiting error handling flexibility.",
      "rootCause": null,
      "proposedFix": "Implement next-retry-delay support in local activity failure handling to match remote activity behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed to support next-retry-delay in application failures from local activities.",
      "related": [
        419
      ],
      "keyQuote": "it was decided we need to support next retry delay in application failures from local activity too",
      "number": 1454,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:33.701Z"
    },
    {
      "summary": "The `workflow_task_execution_failed` metric is registered with inconsistent label sets across different code locations, causing Prometheus descriptor conflicts and registration errors. The metric needs consistent labeling throughout the codebase.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics-handler",
        "task-pollers",
        "event-handlers",
        "prometheus-integration"
      ],
      "concepts": [
        "metric-labeling",
        "prometheus-registration",
        "metric-consistency",
        "descriptor-validation",
        "label-schema"
      ],
      "severity": "high",
      "userImpact": "Users experience Prometheus errors when the workflow_task_execution_failed metric is recorded with different label sets, preventing proper metrics collection and monitoring.",
      "rootCause": "The metric is registered with different label sets in different code locations: internal_task_pollers.go includes additional labels while internal_event_handlers.go does not, violating Prometheus's requirement for consistent metric descriptors.",
      "proposedFix": "Ensure the metric is recorded in only one place with a consistent set of labels, or synchronize all uses to include the same label set across all locations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was addressed in the master branch and included in v1.30.0 release.",
      "related": [
        1295
      ],
      "keyQuote": "We should ideally only be recording this metric in one place and it should always contain the same tag/label set.",
      "number": 1450,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:33.967Z"
    },
    {
      "summary": "Documentation needs clarification on waiting semantics for UpdateWorkflow API, specifically around acceptance/rejection waiting and whether WaitPolicy should be required with explicit opt-in rather than dangerous defaults.",
      "category": "docs",
      "subcategory": "workflow-updates",
      "apis": [
        "UpdateWorkflow",
        "WaitPolicy"
      ],
      "components": [
        "client",
        "workflow-client",
        "update-handler"
      ],
      "concepts": [
        "wait-semantics",
        "acceptance-policy",
        "rejection-handling",
        "api-safety",
        "default-behavior"
      ],
      "severity": "medium",
      "userImpact": "Users lack clear guidance on how to safely wait for workflow update acceptance/rejection, risking dangerous default behavior.",
      "rootCause": "Docstrings in UpdateWorkflow method do not clearly explain waiting semantics and WaitPolicy requirements.",
      "proposedFix": "Make WaitPolicy required and document availability tradeoff clearly, ensuring users explicitly opt into a wait policy.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation and API were clarified to require explicit WaitPolicy configuration.",
      "related": [
        469
      ],
      "keyQuote": "Make sure availability tradeoff is documented clearly and user is opting in to a wait policy.",
      "number": 1449,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:21.659Z"
    },
    {
      "summary": "Request to add support for WorkflowIdConflictPolicy in the Go SDK, a feature for handling conflicts when workflows with the same ID are started.",
      "category": "feature",
      "subcategory": "workflow-management",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-client",
        "workflow-options"
      ],
      "concepts": [
        "workflow-id",
        "conflict-handling",
        "policy",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Users need a way to specify how to handle scenarios where multiple workflows attempt to start with the same workflow ID.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support WorkflowIdConflictPolicy for handling workflow ID conflicts",
      "related": [
        437
      ],
      "keyQuote": "Support for WorkflowIdConflictPolicy",
      "number": 1447,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:17.492Z"
    },
    {
      "summary": "Request for OpenTelemetry metric handler improvements in the Go SDK, including options for integer milliseconds instead of float seconds, metric name suffixing conventions, and preventing gauge values from being reported when never set.",
      "category": "feature",
      "subcategory": "observability",
      "apis": [],
      "components": [
        "metric-handler",
        "otel-integration"
      ],
      "concepts": [
        "metrics",
        "otel",
        "observability",
        "timers",
        "histograms",
        "counters",
        "gauges"
      ],
      "severity": "low",
      "userImpact": "Users gain flexibility in how metrics are formatted and reported, improving compatibility with metric collection systems and reducing noise from unreported gauge values.",
      "rootCause": null,
      "proposedFix": "Implement opt-in options for: (1) integer milliseconds for timers/histograms, (2) metric name suffixing (_total for counters, _milliseconds/_seconds for histograms), (3) skip reporting gauges with no values. Use OTel views for metric renaming where applicable.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Renaming should go through a view we should provide a sample showing how.",
      "number": 1445,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:20.063Z"
    },
    {
      "summary": "The grpc-ecosystem/go-grpc-middleware/retry dependency uses golang.org/x/net/trace which pulls in text/template and reflect.Value.MethodByName, severely hampering Go dead code elimination in compiled binaries.",
      "category": "bug",
      "subcategory": "dependencies",
      "apis": [],
      "components": [
        "grpc-middleware",
        "retry",
        "client"
      ],
      "concepts": [
        "dead-code-elimination",
        "dependencies",
        "reflection",
        "binary-size",
        "build-optimization"
      ],
      "severity": "medium",
      "userImpact": "Users building Temporal SDK applications experience larger binary sizes and reduced dead code elimination due to transitive dependency chain.",
      "rootCause": "grpc-ecosystem/go-grpc-middleware/retry imports golang.org/x/net/trace which uses text/template that calls reflect.Value.MethodByName, preventing linker dead code elimination.",
      "proposedFix": "Wait for upstream grpc-ecosystem/go-grpc-middleware to resolve their issue #704, then update the dependency.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Determined that no reasonable workaround exists for the commonly used dependency. Resolution depends on upstream grpc-ecosystem/go-grpc-middleware addressing the issue.",
      "related": [
        704
      ],
      "keyQuote": "I am not sure it's reasonable to work around this issue with a commonly used dependency like go-grpc-middleware.",
      "number": 1443,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:07.183Z"
    },
    {
      "summary": "Request to expose a defaultConnection() method that automatically switches between localhost and Temporal Cloud based on an environment variable, enabling samples to work across both environments.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [],
      "components": [
        "client",
        "connection",
        "samples"
      ],
      "concepts": [
        "connection-switching",
        "environment-configuration",
        "localhost",
        "cloud-deployment",
        "sample-execution"
      ],
      "severity": "low",
      "userImpact": "Users could more easily run samples against either localhost or Temporal Cloud without code changes.",
      "rootCause": null,
      "proposedFix": "Expose a defaultConnection() method that reads an environment variable to determine whether to connect to localhost or cloud.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide a utility method for environment-based connection configuration.",
      "related": [
        454
      ],
      "keyQuote": "Expose a defaultConnection() method or similar that switches between localhost (default) and cloud based on some environment variable",
      "number": 1442,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:03.235Z"
    },
    {
      "summary": "The temporal_workflow_task_execution_failed metric is not emitted when a closed workflow is replayed, preventing detection of non-deterministic workflow changes. This metric is critical for alerting on potential workflow replay issues.",
      "category": "bug",
      "subcategory": "metrics-replay",
      "apis": [],
      "components": [
        "metrics",
        "workflow-replay",
        "worker"
      ],
      "concepts": [
        "non-determinism",
        "replay",
        "metrics",
        "monitoring",
        "alerting",
        "workflow-execution"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably detect non-deterministic workflow changes during replay, potentially missing critical issues that could cause workflow failures.",
      "rootCause": "The metric emission logic does not account for the replay scenario when querying completed workflows.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved in a later version (post-1.26.0). The maintainer confirmed the metric now emits correctly on the tip of tree.",
      "related": [],
      "keyQuote": "We rely on temporal_workflow_task_execution_failed metric to alert us on potential workflow non-determinism errors. We expect this metric to be emitted when closed workflow is replayed",
      "number": 1441,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:01:05.572Z"
    },
    {
      "summary": "Child workflows that call continue-as-new fail in unit tests with ChildWorkflowExecutionError wrapping ContinueAsNewError, preventing testing of child workflows using continue-as-new pattern.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "test-suite",
        "child-workflow",
        "continue-as-new"
      ],
      "concepts": [
        "unit-testing",
        "child-workflows",
        "continue-as-new",
        "workflow-execution",
        "error-handling",
        "test-environment"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot unit test child workflows that use continue-as-new, blocking a common workflow pattern from being testable.",
      "rootCause": "The test framework does not properly handle continue-as-new in child workflows, treating it as an error instead of as a valid workflow continuation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The test framework was updated to properly handle continue-as-new semantics in child workflows.",
      "related": [],
      "keyQuote": "A child workflow continues as new, and the parent waits for the child to complete.",
      "number": 1435,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:52.738Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not block workflow execution when a cancellation request is received while an activity is executing, unlike the production runtime. The workflow immediately proceeds to deferred functions without waiting for the activity to complete, breaking test parity with production behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-cancellation",
        "activity-executor"
      ],
      "concepts": [
        "cancellation",
        "activity-blocking",
        "test-parity",
        "deferred-execution",
        "WaitForCancellation",
        "runtime-behavior"
      ],
      "severity": "high",
      "userImpact": "Developers cannot reliably test workflow cancellation behavior with activities, as the test environment does not match production runtime semantics.",
      "rootCause": "TestWorkflowEnvironment does not respect activity cancellation blocking semantics that exist in the production runtime.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1
      ],
      "keyQuote": "In the test runtime, the workflow receives a cancelation request and immediately moves on to executing deferred without waiting for the currently executing activity to complete.",
      "number": 1427,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:50.021Z"
    },
    {
      "summary": "User experiences 'context deadline exceeded' errors when using the activity context for database operations. The context appears to have a deadline that expires during activity execution, causing database queries to fail.",
      "category": "bug",
      "subcategory": "context-timeout",
      "apis": [
        "GetLogger"
      ],
      "components": [
        "activity-executor",
        "context-management",
        "deadline-handling"
      ],
      "concepts": [
        "context deadline",
        "timeout",
        "activity execution",
        "database operations",
        "connection management"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably perform database operations within activities because the activity context has a deadline that expires prematurely.",
      "rootCause": "The activity context passed to activities may have a pre-existing deadline from workflow execution or scheduling that is not appropriate for activity duration.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Discussion indicates the issue is likely caused by application-level connection problems or improper context usage rather than an SDK bug. The user was asked to provide a standalone reproduction case showing the SDK canceling the context outside documented cases.",
      "related": [],
      "keyQuote": "To help debug any further what I would need is a stand alone reproduction of the issue showing the SDK canceling the context outside of the documented cases",
      "number": 1424,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:48.247Z"
    },
    {
      "summary": "User requests a contrib/datadog/v0.3.0 release to remove dependency on retracted go.temporal.io/api v1.26.1, which was causing build failures due to transitive dependency issues.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "contrib-datadog",
        "dependency-resolution"
      ],
      "concepts": [
        "dependency",
        "version-compatibility",
        "retracted-version",
        "build-failure"
      ],
      "severity": "high",
      "userImpact": "Users unable to use contrib/datadog module due to broken transitive dependencies preventing successful builds.",
      "rootCause": "contrib/datadog v0.2.0 still depends on retracted go.temporal.io/api v1.26.1, causing build failures for consumers.",
      "proposedFix": "Release contrib/datadog/v0.3.0 with updated dependencies that remove reliance on retracted api version.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "contrib/datadog/v0.3.0 was released with updated dependencies removing the retracted API version dependency.",
      "related": [],
      "keyQuote": "Would it be possible to release a `contrib/datadog/v0.3.0` version which no longer depends on the retracted `go.temporal.io/api v1.26.1`?",
      "number": 1423,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:35.010Z"
    },
    {
      "summary": "The Go SDK needs to support new versioning API abstractions. This is the first issue for the Go SDK implementation, with corresponding issues planned for other SDKs.",
      "category": "feature",
      "subcategory": "versioning-api",
      "apis": [],
      "components": [
        "versioning",
        "sdk-core"
      ],
      "concepts": [
        "versioning",
        "api-abstraction",
        "sdk-compatibility",
        "feature-parity",
        "cross-sdk-alignment"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to use the new versioning API patterns once support is added across all SDKs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed, indicating the versioning API support was implemented for the Go SDK.",
      "related": [],
      "keyQuote": "The versioning API is changing with new abstractions that need to be supported by the Go SDK.",
      "number": 1420,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:32.202Z"
    },
    {
      "summary": "The SDK should not return an update handle if the update has not reached the desired state, addressing a gap in update semantics and API consistency.",
      "category": "feature",
      "subcategory": "workflow-updates",
      "apis": [],
      "components": [
        "update-handler",
        "workflow-execution"
      ],
      "concepts": [
        "update-state",
        "handle-lifecycle",
        "workflow-updates",
        "api-consistency",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users may receive update handles for updates that haven't reached the desired state, leading to potential confusion and incorrect update management.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by implementing logic to not return an update handle if the update has not reached the desired state.",
      "related": [
        432
      ],
      "keyQuote": "SDK should not return an update handle if the update has not reached the desired state",
      "number": 1414,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:30.792Z"
    },
    {
      "summary": "Replace the use of protobuf WaitPolicy struct with a lightweight enum defined in the Go SDK to simplify the API for setting wait policies in UpdateWorkflowWithOptionsRequest.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [
        "UpdateWorkflowWithOptionsRequest"
      ],
      "components": [
        "workflow-client",
        "update-api"
      ],
      "concepts": [
        "api-simplification",
        "wait-policy",
        "enum-definition",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Users can set wait policies more conveniently without needing to declare protobuf structs and enums.",
      "rootCause": null,
      "proposedFix": "Define a Go SDK enum for wait policy instead of using updatepb.WaitPolicy",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented a Go SDK-defined enum to replace protobuf WaitPolicy usage",
      "related": [],
      "keyQuote": "We can replace this with an \"enum\" defined in the Go SDK.",
      "number": 1411,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:16.359Z"
    },
    {
      "summary": "The SDK uses the deprecated golang/mock library for testing. The upstream project has been archived and now recommends migrating to the maintained fork at go.uber.org/mock, which is a straightforward search-and-replace migration.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "internal-worker",
        "mocking"
      ],
      "concepts": [
        "testing",
        "mocking",
        "dependency-management",
        "maintenance",
        "code-generation"
      ],
      "severity": "medium",
      "userImpact": "Users relying on the SDK for testing may face issues if golang/mock is deprecated or drops support, and the codebase should use a maintained alternative.",
      "rootCause": "golang/mock (github.com/golang/mock) has been deprecated and archived upstream since June 2023, with official recommendation to use go.uber.org/mock instead.",
      "proposedFix": "Port all uses of golang/mock to go.uber.org/mock through search-and-replace at the code level. This includes updating the reference in internal/internal_worker.go and test imports throughout the codebase.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The upstream github.com/golang/mock project has been deprecated and archive. As of June 2023, their README recommends using go.uber.org/mock instead.",
      "number": 1410,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:18.556Z"
    },
    {
      "summary": "Calls to workflowService.GetSystemInfo made by loadCapabilities are not included in distributed traces because a new background context is created instead of passing the parent context, causing a new separate trace to be created.",
      "category": "bug",
      "subcategory": "tracing-instrumentation",
      "apis": [
        "GetSystemInfo"
      ],
      "components": [
        "workflow-client",
        "capabilities-loader",
        "tracing-interceptor"
      ],
      "concepts": [
        "distributed-tracing",
        "context-propagation",
        "opentelemetry",
        "span-instrumentation",
        "background-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot see GetSystemInfo calls in their distributed traces, making it difficult to diagnose intermittent network failures in trace logs.",
      "rootCause": "loadCapabilities creates a new background context instead of accepting and using the parent context from callers, breaking trace continuity.",
      "proposedFix": "Plumb the parent context through the capabilities loader function and use it when calling GetSystemInfo, allowing proper cancellation and trace propagation.",
      "workaround": "Use gRPC stats handler or gRPC interceptor from go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc to trace all gRPC calls instead.",
      "resolution": "fixed",
      "resolutionDetails": "loadCapabilities now accepts context as a parameter and it is wired up in all call locations, allowing parent context to be properly propagated.",
      "related": [],
      "keyQuote": "loadCapabilities now takes the context and it is wired up in all possible locations we could.",
      "number": 1406,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:20.191Z"
    },
    {
      "summary": "PR #1404 caused workflowcheck tool to panic with a nil pointer dereference. The issue was traced to PR #1382 and resolved by pulling the latest master version.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "workflowcheck",
        "type-checker"
      ],
      "concepts": [
        "panic",
        "nil-pointer",
        "segmentation-violation",
        "tool-breakage",
        "regression"
      ],
      "severity": "high",
      "userImpact": "Users running workflowcheck tool experience crashes, preventing workflow validation.",
      "rootCause": "PR #1382 introduced a nil pointer dereference in the go/types.Checker that workflowcheck relies on.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by pulling the latest master version which fixed the underlying problem in PR #1382.",
      "related": [
        1403,
        1382,
        1404
      ],
      "keyQuote": "Pulling the latest workflow check... and running in samples gave no error so I suspect it is #1382",
      "number": 1405,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:04.614Z"
    },
    {
      "number": 1401,
      "repository": "temporalio-sdk-go",
      "summary": "Add support for API key as a client option in the Go SDK, enabling secure authentication without exposing credentials in connection strings.",
      "category": "feature",
      "subcategory": "authentication",
      "apis": [],
      "components": [
        "client",
        "credentials",
        "connection"
      ],
      "concepts": [
        "authentication",
        "api-key",
        "security",
        "client-options",
        "credential-management"
      ],
      "severity": "medium",
      "userImpact": "Users need a secure way to provide API keys as a client option rather than embedding them in connection strings.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "API key client option was implemented in the Go SDK",
      "related": [
        426
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/426",
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:05.519Z"
    },
    {
      "summary": "Request to add a ResetReapplyType option to WorkflowPanicPolicy's ResetWorkflow mode, allowing workflows to restart on panic with custom reapply behavior similar to ResetWorkflowExecutionRequest.",
      "category": "feature",
      "subcategory": "workflow-panic-handling",
      "apis": [
        "WorkflowPanicPolicy",
        "ResetWorkflow",
        "RetryPolicy",
        "ResetWorkflowExecutionRequest"
      ],
      "components": [
        "workflow-execution",
        "panic-handling",
        "workflow-reset",
        "retry-policy"
      ],
      "concepts": [
        "panic-handling",
        "workflow-reset",
        "signal-replay",
        "workflow-restart",
        "determinism",
        "retry-policy"
      ],
      "severity": "medium",
      "userImpact": "Users with frequently deployed, non-versionable workflows need panic recovery that replays signals and doesn't require wrapping errors.",
      "rootCause": null,
      "proposedFix": "Add ResetReapplyType option to WorkflowPanicPolicy when set to ResetWorkflow, mirroring the behavior in ResetWorkflowExecutionRequest.",
      "workaround": "Use FailWorkflow with RetryPolicy and wrap non-retryable errors with temporal.NewNonRetryableError, but this doesn't replay signals.",
      "resolution": "duplicate",
      "resolutionDetails": "Duplicate of SDK feature issue #417 in temporalio/features repository.",
      "related": [
        417
      ],
      "keyQuote": "When WorkflowPanicPolicy is set to ResetWorkflow, the workflow will restart when a panic occurs. An additional option called ResetReapplyType...",
      "number": 1399,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T03:00:03.543Z"
    },
    {
      "summary": "Request to add support for `ReplayWorkflowHistoryOptions` to `ReplayWorkflowHistoryFromJSONFile` and `ReplayPartialWorkflowHistoryFromJSONFile` functions, allowing users to specify workflow ID and run ID without requiring manual JSON-to-proto conversion.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowHistoryFromJSONFile",
        "ReplayPartialWorkflowHistoryFromJSONFile",
        "ReplayWorkflowHistoryWithOptions",
        "ReplayWorkflowHistoryOptions"
      ],
      "components": [
        "worker",
        "workflow-replayer",
        "history-loader",
        "internal-worker"
      ],
      "concepts": [
        "workflow-replay",
        "history-loading",
        "json-deserialization",
        "test-utilities",
        "workflow-execution",
        "proto-conversion",
        "logger-interface"
      ],
      "severity": "medium",
      "userImpact": "Users must manually convert JSON history to proto format and cannot specify workflow execution details when using file-based replay functions, creating friction in testing workflows.",
      "rootCause": null,
      "proposedFix": "Create a separate `LoadWorkflowHistoryFromJSONFile` function that returns a proto History object, which can then be used with `ReplayWorkflowHistoryWithOptions`. Also expose internal utility functions and SDK logger for test usage.",
      "workaround": "Users can implement their own JSON-to-proto conversion function and use `ReplayWorkflowHistoryWithOptions` directly with converted history, or implement custom logger interface.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be nice if the sdk exposed a logger that can be used in the unit test setting.",
      "number": 1397,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:50.347Z"
    },
    {
      "summary": "TestWorkflowEnvironment errors lack useful stack traces and context information, making debugging test failures difficult. The request is to implement a Format function on errors to provide more detailed information when formatted with %+v.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowEnvironment",
        "error-handling",
        "test-utils"
      ],
      "concepts": [
        "debugging",
        "error-formatting",
        "stack-traces",
        "test-diagnostics",
        "error-context",
        "verbose-output"
      ],
      "severity": "medium",
      "userImpact": "Developers struggle to debug test failures in the Temporal Go SDK due to insufficient error information and missing stack traces.",
      "rootCause": "TestWorkflowEnvironment errors do not implement Format functions that provide detailed context when printed with %+v formatting.",
      "proposedFix": "Implement a Format function on errors to print more information when formatted using %+v, similar to how require.NoError uses this pattern.",
      "workaround": "Manually unwrap and check errors to extract usable stack trace information.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If a test fails, for example because a context is used wrongly, there's almost no information available to debug",
      "number": 1395,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:51.778Z"
    },
    {
      "summary": "Request to add configurable panic policy at the workflow level in the Go SDK. This feature is being evaluated in the features repository and may be determined unnecessary and closed.",
      "category": "feature",
      "subcategory": "panic-handling",
      "apis": [],
      "components": [
        "workflow-executor",
        "panic-handler"
      ],
      "concepts": [
        "panic-policy",
        "error-handling",
        "workflow-configuration",
        "resilience"
      ],
      "severity": "low",
      "userImpact": "Users would be able to configure how workflows handle panic situations at the workflow level rather than globally.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        322
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/322. May be determined we don't need this and closed.",
      "number": 1387,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:49.599Z"
    },
    {
      "summary": "Activity spans in OpenTelemetry tracing were appearing as root spans instead of being nested under their parent workflow. Investigation revealed this was not a bug but rather that the RunWorkflow span is only emitted upon completion, causing activities to appear orphaned until the workflow finishes.",
      "category": "question",
      "subcategory": "opentelemetry-tracing",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "opentelemetry-interceptor",
        "tracing",
        "workflow-execution",
        "activity-execution"
      ],
      "concepts": [
        "span-hierarchy",
        "distributed-tracing",
        "workflow-lifecycle",
        "asynchronous-execution",
        "span-emission-timing"
      ],
      "severity": "low",
      "userImpact": "Users implementing OpenTelemetry tracing may incorrectly perceive activity spans as orphaned during workflow execution, leading to confusion about trace hierarchy.",
      "rootCause": "The RunWorkflow span is only emitted upon workflow completion, causing activity spans to appear as root spans until the workflow finishes execution.",
      "proposedFix": null,
      "workaround": "Wait for workflow completion to see the proper span hierarchy in the trace visualization.",
      "resolution": "invalid",
      "resolutionDetails": "Determined to be expected behavior, not a bug. The span hierarchy is correct once the workflow completes and the RunWorkflow span is emitted.",
      "related": [],
      "keyQuote": "it turns out this is not a bug, but rather that the \"RunWorkflow:FulfillmentWorkflow\" span is only emitted upon completion",
      "number": 1386,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:35.475Z"
    },
    {
      "summary": "Feature request to extend the workflowcheck tool to detect reads from WorkflowExecution.RunId within workflow code and suggest using WorkflowInfo.OriginalRunId instead, as RunId values are non-deterministic during workflow reset scenarios.",
      "category": "feature",
      "subcategory": "workflow-tooling",
      "apis": [
        "ExecuteChildWorkflow",
        "WorkflowExecution",
        "WorkflowInfo"
      ],
      "components": [
        "workflowcheck",
        "workflow-determinism",
        "child-workflow"
      ],
      "concepts": [
        "determinism",
        "workflow-reset",
        "run-id",
        "non-deterministic-code",
        "child-workflow-execution",
        "workflow-id-generation"
      ],
      "severity": "medium",
      "userImpact": "Users may unknowingly write non-deterministic workflow code by reading RunId, causing workflow failures during reset scenarios without clear guidance.",
      "rootCause": "RunId property changes after workflow reset, making it non-deterministic. Child workflows without explicit IDs use SDK-generated IDs that include RunId, further compounding the issue.",
      "proposedFix": "Extend workflowcheck tool to detect reads of WorkflowExecution.RunId and suggest using WorkflowInfo.OriginalRunId or FirstRunId instead. Consider also detecting child workflow execution without explicit IDs.",
      "workaround": "Always explicitly set workflow IDs for child workflows and use OriginalRunId instead of RunId when determinism is required.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue closed by author after discovering related issue #723 and workaround. The tooling enhancement was not pursued as the underlying server work is not prioritized.",
      "related": [
        723
      ],
      "keyQuote": "using the value of RunId within workflow task code is non-deterministic under workflow reset scenarios",
      "number": 1385,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:37.965Z"
    },
    {
      "summary": "Request to add an option to override retry policy when using NewContinueAsNewError for long-running workflows that restart periodically. Currently retry policy is automatically propagated to the new workflow, requiring full workflow resubmission via StartWorkflowOptions if policy adjustment is needed.",
      "category": "feature",
      "subcategory": "workflow-continuation",
      "apis": [
        "NewContinueAsNewError",
        "StartWorkflowOptions"
      ],
      "components": [
        "workflow-engine",
        "retry-policy",
        "continue-as-new"
      ],
      "concepts": [
        "retry-policy",
        "workflow-continuation",
        "long-running-workflows",
        "policy-override",
        "workflow-restart",
        "temporal-options"
      ],
      "severity": "medium",
      "userImpact": "Users managing long-running workflows with periodic restarts cannot adjust retry policies without resubmitting the entire workflow, requiring workarounds or complete workflow recreation.",
      "rootCause": null,
      "proposedFix": "Add a retry policy override option similar to WithWorkflowRunTimeout and ContinueAsNewOptions in sdk-java to allow policy adjustment during workflow continuation.",
      "workaround": "Re-submit the workflow using StartWorkflowOptions with updated retry policy instead of using NewContinueAsNewError.",
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to allow retry policy override in continue-as-new workflows, bringing Go SDK to parity with existing Java SDK implementation.",
      "related": [],
      "keyQuote": "Similar to WithWorkflowRunTimeout, provide an option to override the retry policy.",
      "number": 1384,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:33.588Z"
    },
    {
      "summary": "workflowcheck v0.1.0 fails with Go 1.22 toolchain due to incompatibility with the go/types API changes in Go 1.22. The tool requires golang.org/x/tools v0.13.0 or newer, but v0.1.0 depends on v0.10.0.",
      "category": "bug",
      "subcategory": "tool-compatibility",
      "apis": [],
      "components": [
        "workflowcheck",
        "golang.org/x/tools",
        "go/types"
      ],
      "concepts": [
        "Go toolchain compatibility",
        "dependency versioning",
        "analyzer API changes",
        "segmentation fault",
        "nil pointer dereference"
      ],
      "severity": "high",
      "userImpact": "Users trying to use workflowcheck with Go 1.22 experience runtime panics and cannot run the tool without manual workarounds.",
      "rootCause": "Go 1.22 introduced changes to the go/types API that require a newer version of golang.org/x/tools (v0.13.0+). workflowcheck v0.1.0 depended on v0.10.0 which is incompatible with these changes.",
      "proposedFix": "Upgrade golang.org/x/tools dependency to v0.13.0 or newer and release a new version of workflowcheck.",
      "workaround": "Users can add workflowcheck to their go.mod/tools.go with x/tools v0.13.0+ and run without the @latest suffix to use the newer x/tools version from their own go.mod.",
      "resolution": "fixed",
      "resolutionDetails": "Fix was merged to HEAD, and workflowcheck v0.2.0 was released with the upgraded x/tools dependency after Go SDK v1.26.0 release.",
      "related": [
        62167,
        3864
      ],
      "keyQuote": "Go analyzers when built with the 1.22 toolchain also require a version of x/tools at least as new as v0.13.0",
      "number": 1382,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:20.692Z"
    },
    {
      "summary": "User reported that activity timeout was triggered approximately twice as early as the configured ScheduleToCloseTimeout value. Investigation revealed this is expected behavior: when an activity fails and retries with exponential backoff, if the next scheduled retry time exceeds the ScheduleToCloseTimeout, the activity fails immediately.",
      "category": "question",
      "subcategory": "activity-timeout",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "retry-logic",
        "timeout-handler"
      ],
      "concepts": [
        "timeout",
        "retry",
        "backoff",
        "schedule-to-close",
        "activity-failure"
      ],
      "severity": "low",
      "userImpact": "Users may misunderstand how ScheduleToCloseTimeout interacts with activity retries, leading to unexpected early timeouts when activities fail and trigger exponential backoff.",
      "rootCause": "When an activity fails and retries with exponential backoff starting at 1 second and doubling each time, if the next scheduled retry time exceeds the ScheduleToCloseTimeout, the activity is failed without attempting the retry.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "The behavior was clarified as expected and working as designed. The issue was caused by a misunderstanding of how ScheduleToCloseTimeout interacts with exponential backoff retry logic.",
      "related": [],
      "keyQuote": "Since your activity always fails the backoff time will grow exponentially from 1s doubling every retry until the next attempt time is after the activity timeout.",
      "number": 1380,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:21.397Z"
    },
    {
      "summary": "Expose the next retry delay field from ApplicationFailureInfo across all Temporal SDKs. This field was recently added to the API to allow activities to specify retry behavior on failure, and needs to be exposed in SDK implementations.",
      "category": "feature",
      "subcategory": "activity-retry",
      "apis": [
        "ApplicationFailureInfo"
      ],
      "components": [
        "activity",
        "failure-handling",
        "retry-logic"
      ],
      "concepts": [
        "retry",
        "delay",
        "failure",
        "activity",
        "api-exposure"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access the next retry delay information on activity failures until all SDKs expose this newly added API field.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by exposing the next retry delay field on ApplicationFailureInfo across SDKs. Go SDK implementation was already completed.",
      "related": [],
      "keyQuote": "We recently added the ability for an activity to specify the next retry delay on failure via a field on ApplicationFailureInfo.",
      "number": 1376,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:22.070Z"
    },
    {
      "summary": "Data race detected in sticky workflow cache size management due to missing synchronization between SetStickyWorkflowCacheSize() write operations and NewWorkerCache() read operations. The setter acquires a lock but the getter does not, causing race conditions when these functions are called concurrently from different goroutines.",
      "category": "bug",
      "subcategory": "worker-cache",
      "apis": [
        "SetStickyWorkflowCacheSize",
        "NewWorkerCache",
        "NewWorker"
      ],
      "components": [
        "worker-cache",
        "internal-worker",
        "synchronization"
      ],
      "concepts": [
        "data-race",
        "concurrency",
        "mutex",
        "cache-management",
        "lock-synchronization",
        "goroutine-safety"
      ],
      "severity": "high",
      "userImpact": "Users experience flaky test failures and potential runtime issues when SetStickyWorkflowCacheSize is called concurrently with worker creation due to unsynchronized access to the sticky cache size variable.",
      "rootCause": "The sticky cache size variable is protected by a lock in SetStickyWorkflowCacheSize() but accessed without acquiring the lock in NewWorkerCache(), creating a classic data race condition between write and read operations.",
      "proposedFix": "Add lock/unlock operations when reading the sticky cache size in NewWorkerCache() to match the synchronization pattern used in SetStickyWorkflowCacheSize().",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Lock synchronization was added to the read operation in NewWorkerCache() to match the lock protection in SetStickyWorkflowCacheSize().",
      "related": [],
      "keyQuote": "The sticky cache size is set with lock here, but it is read without lock here.",
      "number": 1375,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:07.480Z"
    },
    {
      "summary": "Request to document that Client.GetSearchAttributes is not supported in Temporal Cloud and only works in self-hosted deployments. After discussion, it was determined this documentation belongs in the main Temporal docs rather than SDK docs since cloud support can change independently of SDK versions.",
      "category": "docs",
      "subcategory": "client-api-documentation",
      "apis": [
        "GetSearchAttributes"
      ],
      "components": [
        "client",
        "search-attributes"
      ],
      "concepts": [
        "cloud-compatibility",
        "self-hosted-only",
        "api-limitations",
        "documentation"
      ],
      "severity": "low",
      "userImpact": "Users may attempt to use GetSearchAttributes in Cloud environments without knowing it's not supported, leading to confusion and failed operations.",
      "rootCause": "Client.GetSearchAttributes is only implemented for self-hosted Temporal deployments, not for Temporal Cloud.",
      "proposedFix": "Document the Cloud/self-hosted compatibility limitations in the official Temporal documentation at docs.temporal.io rather than in SDK docs.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "The issue was resolved by deciding that Cloud compatibility documentation should live in the main Temporal docs (docs.temporal.io) rather than SDK docs, since Cloud features and SDK features evolve independently.",
      "related": [],
      "keyQuote": "this is the only high level workflow client call in any of our SDKs that doesn't work in cloud and self-hosted",
      "number": 1372,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:04.507Z"
    },
    {
      "summary": "User requested moving SDK errors out of the internal package to make them more accessible for developers. The discussion revealed that commonly-needed errors are already exposed through aliases in public packages like the temporal and activity packages.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "error-handling",
        "internal-package",
        "temporal-package",
        "activity-package"
      ],
      "concepts": [
        "error-handling",
        "package-organization",
        "API-accessibility",
        "developer-experience",
        "internal-packages"
      ],
      "severity": "low",
      "userImpact": "Developers need easier access to SDK errors for proper error handling in their applications.",
      "rootCause": "SDK errors were kept in the internal package, making them harder to access directly for error matching.",
      "proposedFix": "Move SDK errors to a public-facing package or ensure they are properly aliased in public packages.",
      "workaround": "Errors can be accessed through aliases already exposed in public packages like temporal and activity.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by confirming that errors like ErrScheduleAlreadyRunning are already exposed through public package aliases, addressing the user's specific use case.",
      "related": [],
      "keyQuote": "Errors a users is expected to need are aliased in other packages for example ErrActivityResultPending is aliased here",
      "number": 1364,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:59:05.623Z"
    },
    {
      "summary": "DevServer.Stop() occasionally hangs indefinitely instead of gracefully shutting down, causing test timeouts. The issue appears related to membership upsert failures and insufficient hosts during server shutdown.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "DevServer.Stop"
      ],
      "components": [
        "testsuite",
        "DevServer",
        "membership",
        "ringpop"
      ],
      "concepts": [
        "graceful-shutdown",
        "context-cancellation",
        "process-termination",
        "test-isolation",
        "synchronization",
        "deadlock"
      ],
      "severity": "high",
      "userImpact": "Tests using DevServer fail with timeout errors when Stop() hangs, making the test suite unreliable and blocking development workflows.",
      "rootCause": "Membership upsert loop or service handlers may not be properly canceling when context is canceled, preventing graceful shutdown completion.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "DevServer.Stop() hangs and never returns causing test timeouts.",
      "number": 1360,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:52.559Z"
    },
    {
      "summary": "PollWorkflowUpdate does not use a context-aware data converter, preventing proper serialization/deserialization of workflow update data with custom converters.",
      "category": "bug",
      "subcategory": "workflow-updates",
      "apis": [
        "PollWorkflowUpdate"
      ],
      "components": [
        "workflow-client",
        "data-converter",
        "workflow-update-handler"
      ],
      "concepts": [
        "data-converter",
        "context-awareness",
        "serialization",
        "workflow-updates",
        "type-conversion"
      ],
      "severity": "medium",
      "userImpact": "Users with custom data converters cannot properly serialize and deserialize workflow update payloads, breaking custom encoding support.",
      "rootCause": "PollWorkflowUpdate implementation does not pass context to the data converter when processing workflow update data.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The PollWorkflowUpdate method was updated to use a context-aware data converter for proper serialization.",
      "related": [],
      "keyQuote": "PollWorkflowUpdate does not use a context aware data converter.",
      "number": 1359,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:49.776Z"
    },
    {
      "summary": "The Go SDK may fail to evict workflow executions from cache when unable to respond to a workflow task, potentially causing stale cached state to persist and affect subsequent workflow execution.",
      "category": "bug",
      "subcategory": "workflow-caching",
      "apis": [],
      "components": [
        "worker",
        "workflow-cache",
        "task-handler"
      ],
      "concepts": [
        "caching",
        "eviction",
        "workflow-state",
        "task-failure",
        "memory-management"
      ],
      "severity": "high",
      "userImpact": "Users may encounter stale or incorrect workflow execution state if the SDK fails to properly clean up cached workflows after task response failures.",
      "rootCause": "The workflow execution cache eviction logic does not trigger when the SDK fails to respond to a workflow task.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by implementing proper cache eviction on workflow task response failures.",
      "related": [],
      "keyQuote": "SDK should evict workflow execution from cache on failure to respond to a workflow task",
      "number": 1357,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:48.666Z"
    },
    {
      "summary": "Generic functions cannot be registered as activities because the SDK's function name parsing fails on generic type parameters, resulting in invalid activity names. The issue was closed as wontfix with a recommendation to use concrete wrapper functions instead.",
      "category": "feature",
      "subcategory": "activity-registration",
      "apis": [
        "RegisterActivity",
        "RegisterActivityWithOptions"
      ],
      "components": [
        "worker",
        "activity-registration",
        "reflection"
      ],
      "concepts": [
        "generics",
        "function-naming",
        "reflection",
        "type-parameters",
        "registration"
      ],
      "severity": "low",
      "userImpact": "Developers using generic functions as activities must manually specify activity names instead of relying on automatic function name detection.",
      "rootCause": "The `get_function_name` function in `internal/internal_worker.go` uses `runtime.FuncForPC()` which returns generic type parameters as `...`, causing incorrect parsing that results in invalid activity names like `]`.",
      "proposedFix": "Improve the parsing of function names in `get_function_name` to properly handle Go generic type parameters.",
      "workaround": "Use concrete non-generic wrapper functions or manually specify activity names via `RegisterActivityWithOptions` with the `Name` option.",
      "resolution": "wontfix",
      "resolutionDetails": "No SDK supports generics in reflectively-called functions. Workarounds are available with reasonable overhead. Documentation note recommended instead.",
      "related": [],
      "keyQuote": "Improve the parsing of function names to support generics, so generic functions can be registered directly.",
      "number": 1355,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:35.320Z"
    },
    {
      "summary": "Request to regenerate mocks using the latest mockery version to support dynamic mock returns based on runtime argument values. This enables more flexible testing scenarios, particularly for arguments with non-deterministic values like timestamps.",
      "category": "other",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflowOptions",
        "WorkflowRun"
      ],
      "components": [
        "mocks",
        "testing",
        "mockery"
      ],
      "concepts": [
        "mocking",
        "test-doubles",
        "argument-matching",
        "dynamic-returns",
        "timestamps"
      ],
      "severity": "low",
      "userImpact": "Developers can write more flexible and maintainable tests by using function-based mock returns instead of static argument matching.",
      "rootCause": "The existing mockery version has limitations in matching arguments with non-deterministic values like timestamps.",
      "proposedFix": "Regenerate mocks using the latest mockery version that supports function-based return values for dynamic argument matching.",
      "workaround": "Use static argument values in mock setup or work around timestamp issues with other testing strategies.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by regenerating mocks using the latest mockery version, enabling the feature through pull requests #1353 and #1361.",
      "related": [
        1353,
        1361
      ],
      "keyQuote": "With latest mocker, we could do... This is becoming very useful if one argument in `newCustomerMetadata` is `timestamp`",
      "number": 1354,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:36.297Z"
    },
    {
      "summary": "Data converters and codecs need access to serialization context (activity IDs, child workflow IDs) to implement context-aware behavior like encryption that depends on workflow identity. Currently unavailable in Go SDK unlike Java SDK.",
      "category": "feature",
      "subcategory": "data-converters",
      "apis": [
        "WithContext",
        "WithWorkflowContext"
      ],
      "components": [
        "data-converter",
        "codec",
        "activity-executor",
        "workflow-executor"
      ],
      "concepts": [
        "serialization",
        "context",
        "encryption",
        "replay-attack",
        "activity-id",
        "workflow-id",
        "nexus"
      ],
      "severity": "medium",
      "userImpact": "Users cannot implement security-critical features like replay-attack mitigation that require access to workflow/activity IDs during serialization.",
      "rootCause": "Go SDK does not pass activity/child workflow IDs to data converters during serialization, unlike Java SDK.",
      "proposedFix": "Pass serialization context containing activity ID and child workflow ID to WithContext/WithWorkflowContext calls on data converter, requiring minor refactoring of when SDK generates these IDs.",
      "workaround": "Create an interceptor to manually set activity ID/child workflow ID, potentially with SDK-provided deterministic UUID generator.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        434,
        678
      ],
      "keyQuote": "Getting access to the workflow ID in the codec is critical to mitigating replay attacks",
      "number": 1352,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:37.800Z"
    },
    {
      "summary": "Request to support interceptors on WorkflowRun.Get() method to allow context-aware data converters to access workflow-specific information (like workflow ID) when retrieving workflow results. Currently, interceptors work for other client calls but not for result fetching.",
      "category": "feature",
      "subcategory": "interceptor",
      "apis": [
        "WorkflowRun.Get",
        "GetWorkflow"
      ],
      "components": [
        "workflow-client",
        "data-converter",
        "interceptor"
      ],
      "concepts": [
        "interceptor",
        "workflow-id",
        "data-converter",
        "context-aware",
        "result-fetching",
        "client-call"
      ],
      "severity": "medium",
      "userImpact": "Users with context-aware data converters cannot properly decode workflow results when retrieving them via WorkflowRun.Get because interceptors cannot inject workflow-specific context at that point.",
      "rootCause": "The WorkflowRun.Get method does not support interceptors, unlike other client calls to workflow executions, making it impossible for context-aware data converters to access workflow-specific information during result deserialization.",
      "proposedFix": "Add interceptor support to WorkflowRun.Get, similar to the Java SDK's WorkflowClientCallsInterceptor.getResult() method.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1349
      ],
      "keyQuote": "With every other client call to a workflow execution this can be set in the interceptor, except for getting the workflow result because there is no interceptor.",
      "number": 1351,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:19.878Z"
    },
    {
      "summary": "WorkflowRun.Get and WorkflowRun.GetWithOptions do not use context-aware data converters, unlike other client and workflow calls in the SDK. This inconsistency may cause issues when workflows need custom data conversion behavior.",
      "category": "bug",
      "subcategory": "data-conversion",
      "apis": [
        "WorkflowRun.Get",
        "WorkflowRun.GetWithOptions"
      ],
      "components": [
        "workflow-client",
        "data-converter",
        "client-interface"
      ],
      "concepts": [
        "data-conversion",
        "context-awareness",
        "api-consistency",
        "serialization"
      ],
      "severity": "medium",
      "userImpact": "Users with custom data converters may experience unexpected behavior when retrieving workflow results via WorkflowRun.Get, as it doesn't respect the context-aware data converter configuration.",
      "rootCause": "WorkflowRun.Get and WorkflowRun.GetWithOptions methods are not implemented to use context-aware data converters like other client and workflow API methods.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "WorkflowRun.Get and WorkflowRun.GetWithOptions does not use a context aware data converter.",
      "number": 1349,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:22.991Z"
    },
    {
      "summary": "The DataConverterWithoutDeadlockDetection wrapper drops the workflow/activity context when wrapping a ContextAware DataConverter, preventing the underlying converter from accessing context-driven functionality like KeyID population in encryption scenarios.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "DataConverterWithoutDeadlockDetection"
      ],
      "components": [
        "data-converter",
        "context-handling",
        "wrapper"
      ],
      "concepts": [
        "context-propagation",
        "deadlock-detection",
        "data-conversion",
        "encryption",
        "wrapper-pattern"
      ],
      "severity": "high",
      "userImpact": "Users cannot use DataConverterWithoutDeadlockDetection with ContextAware converters because context information required for encryption and other context-driven logic is lost.",
      "rootCause": "The DataConverterWithoutDeadlockDetection wrapper does not propagate the workflow/activity context to the wrapped DataConverter instance.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The wrapper was fixed to properly pass context through to the underlying ContextAware DataConverter.",
      "related": [],
      "keyQuote": "Context is dropped by DataConverterWithoutDeadlockDetection wrapper causing the underlying DataConverter not able to perform context driven logics.",
      "number": 1347,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:21.857Z"
    },
    {
      "summary": "WorkflowChecker should flag anonymous functions in local activities as non-deterministic. Anonymous functions used as local activities can create data races since they run in parallel with the workflow, posing a safety risk.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "workflow-checker",
        "local-activity-executor",
        "determinism-validator"
      ],
      "concepts": [
        "determinism",
        "data-races",
        "anonymous-functions",
        "parallel-execution",
        "local-activities",
        "safety"
      ],
      "severity": "medium",
      "userImpact": "Users can inadvertently write non-deterministic code using anonymous functions in local activities without receiving warnings, leading to potential data race conditions.",
      "rootCause": "WorkflowChecker does not validate or flag anonymous functions used as local activities, which can execute in parallel with the workflow and cause data races.",
      "proposedFix": "Extend WorkflowChecker to detect and flag anonymous functions in local activities as non-deterministic, with warnings about parallel execution risks.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Anonymous functions as local activities are ripe for data races because they can run in parallel with the workflow function",
      "number": 1341,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:07.117Z"
    },
    {
      "summary": "User reported that workflow.CreateSession was creating more sessions than MaxConcurrentSessionExecutionSize allowed, but investigation revealed this was a misunderstanding of how sessions worksessions control activity execution placement, not workflow task scheduling.",
      "category": "question",
      "subcategory": "session-worker",
      "apis": [
        "CreateSession",
        "CompleteSession"
      ],
      "components": [
        "worker",
        "session-manager"
      ],
      "concepts": [
        "session-concurrency",
        "workflow-task-scheduling",
        "activity-execution",
        "worker-isolation"
      ],
      "severity": "low",
      "userImpact": "Users may misunderstand how MaxConcurrentSessionExecutionSize constrains activities versus workflow tasks.",
      "rootCause": "User misunderstanding of session semanticssessions control what workers activities run on, not what workers workflow tasks run on. Multiple workflows can be waiting at the same worker without violating the session concurrency limit.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Determined not to be a bug after discussion clarified how sessions and MaxConcurrentSessionExecutionSize work. Sessions control activity worker affinity, not workflow task distribution.",
      "related": [],
      "keyQuote": "Sessions do not control what workers workflow tasks run on, only what worker activities run on.",
      "number": 1339,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:06.497Z"
    },
    {
      "summary": "Allow users to opt out of automatic tracer span creation when scheduling workflows. Currently the tracing interceptor always creates a span and attaches it to workflow actions on schedule create, but users should have the option to disable this behavior via tracing interceptor options.",
      "category": "feature",
      "subcategory": "tracing-interceptor",
      "apis": [],
      "components": [
        "tracing-interceptor",
        "workflow-actions",
        "scheduler"
      ],
      "concepts": [
        "tracing",
        "span-creation",
        "interceptor-options",
        "observability",
        "opt-out"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently disable automatic span creation for scheduled workflows, limiting control over tracing behavior and potentially generating unnecessary spans.",
      "rootCause": null,
      "proposedFix": "Add configuration option to the tracing interceptor to allow opting out of span creation on schedule create",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        394
      ],
      "keyQuote": "Allow user to opt out of this in tracing interceptor options.",
      "number": 1334,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:58:08.652Z"
    },
    {
      "summary": "Temporal Go SDK v1.25.1 with grpc-gateway v1.16.0 is incompatible with bazel_gazelle 0.32+, causing build failures due to unresolved @go_googleapis repository references. The issue was resolved by upgrading to grpc-gateway v2.",
      "category": "bug",
      "subcategory": "bazel-build",
      "apis": [],
      "components": [
        "bazel-build",
        "grpc-gateway",
        "dependency-management"
      ],
      "concepts": [
        "bazel",
        "gazelle",
        "build-system",
        "dependency-resolution",
        "proto-imports",
        "grpc"
      ],
      "severity": "high",
      "userImpact": "Users cannot build Temporal Go SDK with modern versions of Bazel build tools (bazel_gazelle 0.32+), forcing them to use outdated versions or workarounds.",
      "rootCause": "grpc-gateway v1.16.0 dependency uses proto imports that bazel_gazelle 0.32+ no longer automatically resolves to @go_googleapis, breaking the build dependency chain.",
      "proposedFix": "Upgrade to grpc-gateway v2, which is compatible with newer bazel_gazelle versions.",
      "workaround": "Add `build_naming_convention = \"go_default_library\"` to the `com_github_grpc_ecosystem_grpc_gateway` dependency and use older bazel_gazelle versions (0.31.1 or earlier).",
      "resolution": "fixed",
      "resolutionDetails": "Go SDK now uses grpc-gateway v2, which is compatible with bazel_gazelle 0.32+ and newer versions.",
      "related": [
        1365
      ],
      "keyQuote": "grpc-gateway stopped resolving go and proto imports to @go_googleapis since 0.32 as per https://github.com/bazelbuild/bazel-gazelle/releases",
      "number": 1331,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:53.747Z"
    },
    {
      "summary": "Feature request to add TaskQueue to TracerStartSpanOptions in the tracing interceptor to enable better OpenTelemetry peer service detection. This would allow developers to infer cross-worker interactions by comparing task queue names in span data.",
      "category": "feature",
      "subcategory": "tracing-observability",
      "apis": [
        "StartActivity",
        "StartWorkflow"
      ],
      "components": [
        "tracing-interceptor",
        "span-options",
        "opentelemetry-integration"
      ],
      "concepts": [
        "peer-service-name",
        "distributed-tracing",
        "service-interactions",
        "task-queue",
        "span-context",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Developers cannot easily detect cross-service interactions in their Temporal applications through OpenTelemetry spans without access to task queue information.",
      "rootCause": null,
      "proposedFix": "Add TaskQueue as a field in TracerStartSpanOptions, similar to Name and Operation fields, to provide context about which task queue will handle the request.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This would allow developers to externally infer if a cross-service request is being made based on whether the TaskQueue of the outbound request is different",
      "number": 1330,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:54.403Z"
    },
    {
      "summary": "The Datadog tracing module fails to build because a transitive dependency on the unavailable sourcegraph.com/sourcegraph/appdash-data package causes go get to fail. Upgrading gopkg.in/DataDog/dd-trace-go.v1 to a recent version resolves the issue.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "contrib",
        "datadog",
        "dependencies"
      ],
      "concepts": [
        "dependency-resolution",
        "transitive-dependencies",
        "module-management",
        "go-mod",
        "package-availability"
      ],
      "severity": "high",
      "userImpact": "Users cannot build projects that depend on the Datadog tracing contrib module due to missing transitive dependencies.",
      "rootCause": "gopkg.in/DataDog/dd-trace-go.v1 v1.42.0 has a transitive dependency on the no-longer-reachable sourcegraph.com/sourcegraph/appdash-data package.",
      "proposedFix": "Upgrade gopkg.in/DataDog/dd-trace-go.v1 to the most recent version (v1.58.1 or later) which removes the sourcegraph dependency.",
      "workaround": "Users can explicitly upgrade the dependency using: go mod edit -replace=gopkg.in/DataDog/dd-trace-go.v1@v1.42.0=gopkg.in/DataDog/dd-trace-go.v1@v1.58.1",
      "resolution": "fixed",
      "resolutionDetails": "The Datadog contrib module dependency was upgraded to a version that no longer requires the unavailable appdash-data package.",
      "related": [],
      "keyQuote": "upgrading gopkg.in/DataDog/dd-trace-go.v1 to the most recent version will remove sourcegraph as a dep.",
      "number": 1326,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:51.695Z"
    },
    {
      "summary": "ActivityTestEnvironment crashes with concurrent map read/write errors when executing multiple activities in parallel using t.Parallel(), despite parallel activity execution being supported in real workflows.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "testWorkflowEnvironmentImpl",
        "activityExecutorWrapper",
        "ActivityTestEnvironment"
      ],
      "concepts": [
        "concurrency",
        "thread-safety",
        "map access",
        "race condition",
        "parallel execution",
        "testing"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely execute multiple activities in parallel within ActivityTestEnvironment tests, causing runtime crashes.",
      "rootCause": "Concurrent reads and writes to a map in testWorkflowEnvironmentImpl.getActivityHandle() without synchronization when multiple goroutines execute activities in parallel.",
      "proposedFix": null,
      "workaround": "Avoid using t.Parallel() when executing multiple activities with the same ActivityTestEnvironment instance.",
      "resolution": "wontfix",
      "resolutionDetails": "ActivityTestEnvironment is not designed to be thread-safe; API is not thread-safe unless explicitly documented.",
      "related": [],
      "keyQuote": "The ActivityTestEnvironment is not designed to be thread safe. There is no documentation that says it is OK to use in multiple go routines.",
      "number": 1324,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:37.050Z"
    },
    {
      "summary": "Request for dynamic worker configuration capability that would allow runtime changes to worker settings. The issue is unclear in scope and was closed as implementation approach evolved with the emergence of Nexus as a potential transport mechanism for configuration changes.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "worker",
        "configuration",
        "nexus"
      ],
      "concepts": [
        "dynamic-config",
        "runtime-changes",
        "worker-settings",
        "transport",
        "configuration-management"
      ],
      "severity": "low",
      "userImpact": "Users would be able to modify worker configuration at runtime without restarting, improving operational flexibility.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed due to unclear requirements and architectural changes. Nexus is being considered as a potential transport for config changes, making the original approach obsolete.",
      "related": [
        388
      ],
      "keyQuote": "Unclear what/how we want to do this, and a lot has changed since this was opened (e.g. we are building Nexus now, which could be a transport for config changes).",
      "number": 1323,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:38.311Z"
    },
    {
      "summary": "Implementation of worker autotuning for pollers in the Go SDK. This enhancement aims to optimize resource utilization by automatically adjusting the number of concurrent pollers based on system conditions and workload demands.",
      "category": "feature",
      "subcategory": "worker-autotuning",
      "apis": [],
      "components": [
        "worker",
        "poller",
        "resource-management"
      ],
      "concepts": [
        "autotuning",
        "concurrency",
        "resource-optimization",
        "polling",
        "scalability",
        "performance-tuning",
        "load-adaptation"
      ],
      "severity": "medium",
      "userImpact": "Users will benefit from optimized resource utilization with automatic poller scaling, eliminating manual configuration of concurrent poller counts.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        334
      ],
      "keyQuote": "Worker autotuning - Pollers",
      "number": 1322,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:39.549Z"
    },
    {
      "summary": "Request to add GetUnhandledUpdateNames to allow catch-all handlers for updates in workflows, similar to GetUnhandledSignalNames for signals. Discussion concluded that a more generic dynamic handler approach would be better suited for updates due to their different API and timing requirements compared to signals.",
      "category": "feature",
      "subcategory": "update-handlers",
      "apis": [
        "GetUnhandledSignalNames"
      ],
      "components": [
        "workflow",
        "update-handler",
        "signal-handler"
      ],
      "concepts": [
        "catch-all-handler",
        "dynamic-handler",
        "unhandled-updates",
        "workflow-api",
        "handler-registration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently implement a catch-all handler for workflow updates, limiting flexibility in handling unexpected update types compared to signal handling.",
      "rootCause": "Updates API lacks the equivalent catch-all mechanism that exists for signals (GetUnhandledSignalNames), and directly mimicking signals is not appropriate due to different API behavior and execution timing.",
      "proposedFix": "Implement a dynamic handler registration mechanism for updates that allows a catch-all handler to run before the main workflow function, better suited to updates' API and behavior than mimicking the signals approach.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Merged into issue #997 which implements a more appropriate dynamic handler solution per features#201 requirements.",
      "related": [
        997,
        201
      ],
      "keyQuote": "I don't think we should mimic the signal approach since updates and signal have very different APIs and behavior in the Go SDK.",
      "number": 1316,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:25.092Z"
    },
    {
      "summary": "Deprecate SDK flags SDKFlagProtocolMessageCommand and SDKPriorityUpdateHandling that were introduced for history compatibility with the Update feature, which is not yet GA and doesn't require this compatibility maintenance.",
      "category": "feature",
      "subcategory": "sdk-flags",
      "apis": [],
      "components": [
        "sdk-flags",
        "update-feature"
      ],
      "concepts": [
        "deprecation",
        "backwards-compatibility",
        "feature-maturity",
        "sdk-versioning"
      ],
      "severity": "low",
      "userImpact": "Users will need to update their code to remove these deprecated flags in a future SDK release.",
      "rootCause": null,
      "proposedFix": "Remove SDKFlagProtocolMessageCommand and SDKPriorityUpdateHandling flags in a future SDK version.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we don't need to maintain histroy compatibility",
      "number": 1315,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:21.367Z"
    },
    {
      "summary": "Add support for OpenTelemetry Metrics to the Go SDK by implementing a NewMetricsHandler in the opentelemetry contrib package, now that the OpenTelemetry Go metrics SDK is stable.",
      "category": "feature",
      "subcategory": "observability-metrics",
      "apis": [],
      "components": [
        "opentelemetry-contrib",
        "metrics-handler"
      ],
      "concepts": [
        "observability",
        "metrics",
        "telemetry",
        "instrumentation",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users can now instrument their Temporal Go SDK applications with OpenTelemetry metrics for better observability and monitoring.",
      "rootCause": null,
      "proposedFix": "Add NewMetricsHandler to go.temporal.io/sdk/contrib/opentelemetry",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "NewMetricsHandler was implemented and added to the opentelemetry contrib package",
      "related": [
        113
      ],
      "keyQuote": "Now that it is stable, we should add `NewMetricsHandler` to `go.temporal.io/sdk/contrib/opentelemetry`",
      "number": 1313,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:20.174Z"
    },
    {
      "summary": "The Go SDK should fail a task when encountering an unknown HistoryEvent that the worker is required to handle (when worker_may_ignore is false), rather than silently ignoring it.",
      "category": "feature",
      "subcategory": "history-processing",
      "apis": [],
      "components": [
        "worker",
        "history-processor",
        "event-handler"
      ],
      "concepts": [
        "unknown-events",
        "event-handling",
        "error-resilience",
        "task-failure",
        "history-validation"
      ],
      "severity": "medium",
      "userImpact": "Workers will fail tasks when encountering unknown required events instead of silently continuing, preventing potential data loss or undefined behavior.",
      "rootCause": null,
      "proposedFix": "Implement logic to check the worker_may_ignore flag on HistoryEvent and fail the task when it is false and the event type is unknown.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Task failure logic was implemented to handle unknown required events based on the worker_may_ignore flag.",
      "related": [],
      "keyQuote": "Fail the task when an event is seen that the worker must handle but is not familiar with",
      "number": 1312,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:05.625Z"
    },
    {
      "summary": "Updating go.temporal.io/api to v1.26.1 causes compilation failures in SDK v1.25.1 due to incompatible protobuf type changes, specifically with *anypb.Any vs *types.Any and gRPC status type conflicts.",
      "category": "bug",
      "subcategory": "dependency-compatibility",
      "apis": [],
      "components": [
        "protocol",
        "metrics",
        "grpc",
        "protobuf"
      ],
      "concepts": [
        "dependency-management",
        "version-compatibility",
        "protobuf-types",
        "grpc-gateway",
        "gogoproto"
      ],
      "severity": "high",
      "userImpact": "Users cannot compile their code when updating go.temporal.io/api to v1.26.1 while using SDK v1.25.1, breaking their build process.",
      "rootCause": "go.temporal.io/api v1.26.1 introduced breaking changes by deprecating gogoproto and switching to google.golang.org/protobuf types, which is incompatible with SDK v1.25.1 that still expects gogo types.",
      "proposedFix": "Either release a compatible SDK version with the new API, or prevent incompatible versions from being installed together through versioning constraints.",
      "workaround": "Avoid updating go.temporal.io/api independently; only update it through updating the Go SDK.",
      "resolution": "wontfix",
      "resolutionDetails": "The incompatible API version (v1.26.1) was retracted. The maintainers confirmed SDK versions are only compatible with specific API versions specified in their go.mod, and users should not update API independently.",
      "related": [],
      "keyQuote": "go.temporal.io/api v1.26.1 has been retracted",
      "number": 1310,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:08.775Z"
    },
    {
      "summary": "Feature request to add a GetName() method to the Signal Channel interface to retrieve the human-readable channel name, which would allow callback functions to identify which signal channel triggered them when dynamically creating multiple signal channels.",
      "category": "feature",
      "subcategory": "signal-channels",
      "apis": [
        "SignalChannel"
      ],
      "components": [
        "signal-handler",
        "workflow-context"
      ],
      "concepts": [
        "signal-identification",
        "channel-metadata",
        "dynamic-creation",
        "callback-context"
      ],
      "severity": "low",
      "userImpact": "Users working with dynamically created signal channels cannot programmatically identify which channel triggered a callback function.",
      "rootCause": null,
      "proposedFix": "Add a GetName() string method to the Signal Channel interface that returns the channel's name.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers determined this functionality is not necessary as normal Go channels don't support names, and users can provide channel names when creating callbacks instead.",
      "related": [
        5874
      ],
      "keyQuote": "Why can't you add the name when creating the callback? Normal Go channels don't support a name so I am not sure Temporal channels would need such a functionality",
      "number": 1304,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:57:08.452Z"
    },
    {
      "summary": "When users pass incorrect options types to ExecuteActivity or ExecuteLocalActivity (e.g., ActivityOptions to ExecuteLocalActivity), they get confusing server errors about missing timeouts instead of a clear error message indicating the wrong options type was used.",
      "category": "feature",
      "subcategory": "activity-options",
      "apis": [
        "ExecuteActivity",
        "ExecuteLocalActivity"
      ],
      "components": [
        "activity-executor",
        "context",
        "options-validation"
      ],
      "concepts": [
        "options-validation",
        "error-messages",
        "activity-configuration",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Users debugging activity execution failures receive confusing timeout-related errors when the actual problem is passing the wrong options type, leading to wasted debugging time.",
      "rootCause": "SDK does not validate that the correct options type is set on the context before executing activities; validation only happens server-side resulting in generic timeout error messages.",
      "proposedFix": "Add SDK-side validation to explicitly check that the correct ActivityOptions or LocalActivityOptions type is set on the context, failing early with a clear error message indicating which options type is required.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "if we don't give a clear error message that (local) activity options are not set on the context, we should (and clearly state _which_ ones must be set)",
      "number": 1300,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:52.563Z"
    },
    {
      "summary": "Update handlers registered with SetUpdateHandlerWithOptions may not be invoked before the workflow function returns, preventing proper state handling when updates are pending. This can cause race conditions where workflows exit before processing queued updates.",
      "category": "bug",
      "subcategory": "update-handler",
      "apis": [
        "SetUpdateHandlerWithOptions",
        "Await"
      ],
      "components": [
        "update-handler",
        "workflow-execution",
        "state-management"
      ],
      "concepts": [
        "pending-updates",
        "execution-order",
        "handler-invocation",
        "race-condition",
        "workflow-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Workflows may return before update handlers execute, causing updates to be lost and state management logic to fail unexpectedly.",
      "rootCause": "Update handlers are not invoked immediately upon registration when updates are already pending, allowing the workflow function to return before the handler is called.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by ensuring update handlers are invoked immediately when registered if there are pending updates waiting to be processed.",
      "related": [],
      "keyQuote": "Update handle needs to be invoked immediately when registered with pending updates. If we do not it is possible a workflow function may return before the update handle is called",
      "number": 1297,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:54.135Z"
    },
    {
      "summary": "Context propagators are not applied when running local activities through TestActivityEnvironment.ExecuteLocalActivity(), preventing context values from being injected into the activity execution.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "test-activity-environment",
        "context-propagators",
        "local-activities"
      ],
      "concepts": [
        "context-propagation",
        "testing",
        "local-activities",
        "dependency-injection",
        "test-environment",
        "context-values"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test local activities that depend on context propagators, making it impossible to verify context-dependent behavior in unit tests.",
      "rootCause": "ExecuteLocalActivity method in TestActivityEnvironment does not invoke the configured context propagators before executing the activity.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The ExecuteLocalActivity method was updated to apply configured context propagators during execution.",
      "related": [],
      "keyQuote": "When using the ExecuteLocalActivity method in TestActivityEnvironment struct, any context propagators configured for the test environment should be used.",
      "number": 1290,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:50.474Z"
    },
    {
      "summary": "Request to tag the workflow_task_execution_failed metric with error type information to enable better monitoring and debugging of workflow task execution failures in the Go SDK.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-executor"
      ],
      "concepts": [
        "metrics",
        "observability",
        "error-handling",
        "monitoring",
        "tagging"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily distinguish between different types of workflow task execution failures when monitoring metrics.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing error type tagging for the workflow_task_execution_failed metric.",
      "related": [
        231
      ],
      "keyQuote": null,
      "number": 1289,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:39.655Z"
    },
    {
      "summary": "Workflow panics with 'getState: illegal access from outside of workflow context' error after SDK update from 1.22.1 to 1.25.1 when using selectors with timers and signals in a polling pattern.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "NewSelector",
        "NewTimer",
        "AddFuture",
        "AddReceive"
      ],
      "components": [
        "workflow-context",
        "selector",
        "test-suite",
        "timer-handling"
      ],
      "concepts": [
        "workflow-cancellation",
        "signal-handling",
        "timer-lifecycle",
        "context-safety",
        "selector-pattern"
      ],
      "severity": "medium",
      "userImpact": "Developers using the test suite experience panics when workflows with selectors and timers are cancelled, preventing proper testing of cancellation scenarios.",
      "rootCause": "The test suite calls the cancel callback after workflow execution is finished, which attempts to access workflow context when it's no longer valid.",
      "proposedFix": null,
      "workaround": "This issue only affects the test suite, not actual Temporal cluster or dev server execution.",
      "resolution": "fixed",
      "resolutionDetails": "Identified as test-suite-only issue where cancel callbacks were improperly invoked after workflow execution completion.",
      "related": [],
      "keyQuote": "getState: illegal access from outside of workflow context",
      "number": 1287,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:38.970Z"
    },
    {
      "summary": "Feature request to allow GetCurrentHistoryLength() to return non-zero values during workflow tests, enabling testing of workflows that use history length checks to trigger continue-as-new logic. The author discovered that the functionality already exists in the test suite.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "GetCurrentHistoryLength",
        "GetInfo",
        "NewContinueAsNewError",
        "Sleep"
      ],
      "components": [
        "workflow-testsuite",
        "test-framework",
        "workflow-execution"
      ],
      "concepts": [
        "history-length",
        "continue-as-new",
        "workflow-testing",
        "infinite-loops",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Users cannot effectively test workflows that rely on history length checks to prevent unbounded execution, limiting test coverage for important workflow patterns.",
      "rootCause": "GetCurrentHistoryLength() always returns 0 during test execution, preventing conditional logic that depends on history length from being tested.",
      "proposedFix": "Expose a mechanism in the test suite to configure the current history length returned by workflow.GetInfo(ctx).GetCurrentHistoryLength().",
      "workaround": "The author discovered that the functionality already exists in workflow_testsuite.go at line 309.",
      "resolution": "fixed",
      "resolutionDetails": "The feature already existed in the test suite as evidenced by the author's discovery of the implementation in workflow_testsuite.go.",
      "related": [],
      "keyQuote": "Will never stop running since the history length is always 0 during tests.",
      "number": 1284,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:37.410Z"
    },
    {
      "summary": "Remove ClientOutboundInterceptor.PollWorkflowUpdate as it doesn't need to be interceptable, similar to how workflow results are handled. The author argues this API point is unnecessary for interception.",
      "category": "feature",
      "subcategory": "interceptors",
      "apis": [
        "ClientOutboundInterceptor.PollWorkflowUpdate"
      ],
      "components": [
        "client",
        "interceptor",
        "workflow-updates"
      ],
      "concepts": [
        "interceptor-design",
        "api-simplification",
        "workflow-updates",
        "client-outbound",
        "interceptability"
      ],
      "severity": "low",
      "userImpact": "Removing this interceptor point would simplify the client interceptor API by eliminating an unnecessary interception point.",
      "rootCause": null,
      "proposedFix": "Remove ClientOutboundInterceptor.PollWorkflowUpdate from the SDK",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This does not need to be interceptable any more than getting a workflow result does",
      "number": 1283,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:23.012Z"
    },
    {
      "summary": "Heartbeat timeout is not enforced in the test workflow environment. When testing activities with heartbeat timeouts, the test environment ignores the HeartbeatTimeout setting and hardcodes other timeouts to 10 minutes, making it impossible to test heartbeat timeout behavior without using a real Temporal server.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "ExecuteActivityOptions"
      ],
      "components": [
        "test-workflow-environment",
        "activity-executor",
        "heartbeat-timeout"
      ],
      "concepts": [
        "heartbeat",
        "timeout",
        "testing",
        "activity-lifecycle",
        "test-environment",
        "time-skipping"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot test heartbeat timeout behavior in their workflows using the test environment, forcing them to use real servers for this validation.",
      "rootCause": "HeartbeatTimeout is hardcoded to zero value in testWorkflowEnvironmentImpl.executeActivity, while other timeouts (ScheduleToCloseTimeout, StartToCloseTimeout) are hardcoded to 600 seconds. The test environment uses time-skipping rather than real-time for timeout enforcement.",
      "proposedFix": "Modify the test workflow environment to respect HeartbeatTimeout settings similar to how it handles other timeouts, or implement real-time heartbeat timeout enforcement in the test environment.",
      "workaround": "Use testsuite.StartDevServer() with a real Temporal server for testing heartbeat timeout behavior, or mock activity failures to simulate heartbeat timeout in workflow tests.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1167
      ],
      "keyQuote": "heartbeatTimeouts are straight up ignored",
      "number": 1282,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:26.225Z"
    },
    {
      "summary": "User requested a public API function to extract workflow IDs from gRPC request/response protos for use in client-side tracing. Currently they use a brittle switch statement that's hard to maintain and prone to breaking with API changes.",
      "category": "feature",
      "subcategory": "grpc-client-interceptor",
      "apis": [],
      "components": [
        "grpc-client",
        "workflow-service",
        "interceptor"
      ],
      "concepts": [
        "workflow-identification",
        "grpc-metadata",
        "tracing-attributes",
        "api-brittleness",
        "request-inspection"
      ],
      "severity": "low",
      "userImpact": "Users implementing gRPC client interceptors must maintain fragile type-switching code to extract workflow IDs for distributed tracing.",
      "rootCause": null,
      "proposedFix": "Expose a public function in the SDK to extract workflow IDs from request/response protos",
      "workaround": "Maintain a switch statement over all request types that contain workflow IDs, with unit tests to catch new API additions",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers decided the user's current approach is appropriate and that exposing an extract-workflow-id function in public API doesn't have enough general-purpose value to justify inclusion",
      "related": [],
      "keyQuote": "I do think it is best as opposed to us exposing an extract-workflow-id-from-grpc-request in our public library API",
      "number": 1280,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:22.247Z"
    },
    {
      "summary": "User requests a way to expose OpenTelemetry trace parent information from worker request/response protobuf messages to link gRPC client spans with underlying temporal workflow spans.",
      "category": "feature",
      "subcategory": "observability-tracing",
      "apis": [],
      "components": [
        "worker",
        "grpc-client-interceptor",
        "opentelemetry-integration"
      ],
      "concepts": [
        "opentelemetry",
        "tracing",
        "span-linking",
        "trace-context",
        "distributed-tracing",
        "header-extraction"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently correlate gRPC client spans with workflow execution spans, limiting observability and debugging capabilities.",
      "rootCause": "No public API exists to extract trace parent data (_tracer-data header) from workflow proto request/response payloads.",
      "proposedFix": "Provide a function to extract traceparent data from request/response objects, or expose trace context through existing interceptor mechanisms.",
      "workaround": "Use a ClientInterceptor after the OpenTelemetry interceptor to manually extract span context and add workflow trace IDs as attributes.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer indicated the architecture doesn't support this pattern as spans are deserialized and used by other worker processes. Workaround provided using standard OpenTelemetry interceptor patterns.",
      "related": [],
      "keyQuote": "The spans in the interceptors are deserialized and used by other worker processes to re-parent their spans.",
      "number": 1279,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:10.454Z"
    },
    {
      "summary": "Activity alias mapping returns incorrect alias when an activity from a different task queue is invoked. The getActivityAlias function uses the workflow's registry regardless of task queue context, causing activities registered in other queues to return their aliases instead of None.",
      "category": "bug",
      "subcategory": "activity-alias",
      "apis": [
        "ExecuteActivity",
        "RegisterActivityWithOptions"
      ],
      "components": [
        "worker",
        "activity-registry",
        "alias-resolution"
      ],
      "concepts": [
        "task-queue",
        "alias-mapping",
        "activity-registration",
        "workflow-context",
        "cross-queue-invocation"
      ],
      "severity": "medium",
      "userImpact": "Users invoking activities across different task queues may receive incorrect alias mappings, leading to unexpected behavior or execution errors.",
      "rootCause": "The workflow's activity registry is used to lookup aliases without checking if the activity belongs to the current task queue context.",
      "proposedFix": null,
      "workaround": "Disable aliasing via the DisableRegistrationAliasing option.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of #845. The behavior cannot be changed without breaking existing users. Issue #850 was created to address this situation.",
      "related": [
        845,
        850
      ],
      "keyQuote": "Yes, we use the workflow's registry to lookup activity aliases. We can't really change this behavior without potentially breaking people.",
      "number": 1275,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:07.256Z"
    },
    {
      "summary": "User misconfigured a schedule by combining calendar-based constraints (weekdays 9am-5pm) with an interval-based constraint (every 4 minutes), causing runs to execute immediately and outside business hours. The issue was resolved when the user corrected their configuration to use only the calendar spec with the desired frequency.",
      "category": "question",
      "subcategory": "scheduling",
      "apis": [
        "Create",
        "ScheduleClient"
      ],
      "components": [
        "schedule",
        "calendar-spec",
        "time-zone"
      ],
      "concepts": [
        "scheduling",
        "calendar-constraints",
        "time-zone",
        "weekday-filtering",
        "business-hours",
        "interval-composition"
      ],
      "severity": "low",
      "userImpact": "Users may incorrectly configure schedules by misunderstanding how calendar and interval specs compose, resulting in unintended execution timing.",
      "rootCause": "User combined two independent scheduling mechanisms (Calendars and Intervals) without understanding that they are unioned together, not intersected. The Intervals spec (every 4 minutes) executed independently of the Calendar constraints (weekdays 9am-5pm).",
      "proposedFix": "Move the 4-minute frequency constraint from a separate Intervals spec into the Calendar spec's Minute field with a Step parameter, so all constraints apply together.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was resolved by clarifying the API behavior in documentation and helping the user understand that calendar and interval specs are unioned, not intersected. User applied the corrected configuration.",
      "related": [],
      "keyQuote": "your current spec says it should run every hour on the weekday from 9am to 5pm and every 4 minutes",
      "number": 1274,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:56:09.434Z"
    },
    {
      "summary": "Registering a workflow and activity with the same name causes the test suite to panic when mocking the activity. The test framework incorrectly handles naming collisions between activities and workflows.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow",
        "OnActivity"
      ],
      "components": [
        "testsuite",
        "activity-mock",
        "workflow-mock"
      ],
      "concepts": [
        "naming-collision",
        "test-mocking",
        "activity-registration",
        "workflow-registration",
        "test-framework",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot register activities and workflows with the same name in tests without the test suite panicking when mocking.",
      "rootCause": "The test framework's mocking mechanism does not properly differentiate between activities and workflows when they share the same name, causing unexpected call errors.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #887, which addresses the same naming collision problem in the test suite.",
      "related": [
        887
      ],
      "keyQuote": "Registering an activity and workflow with the same name and trying to mock the activity causes the test suite to error with unexpected calls.",
      "number": 1273,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:52.967Z"
    },
    {
      "summary": "Failed read-only checks in update validators should cause a Workflow Task (WFT) failure rather than failing the update itself. This distinction is important for proper error handling semantics.",
      "category": "bug",
      "subcategory": "update-validator",
      "apis": [],
      "components": [
        "update-validator",
        "workflow-task",
        "read-only-check"
      ],
      "concepts": [
        "validation",
        "error-handling",
        "read-only",
        "update-semantics",
        "workflow-task-failure"
      ],
      "severity": "medium",
      "userImpact": "Users experience incorrect error handling behavior when read-only checks fail during update validation, leading to update failures instead of proper workflow task failures.",
      "rootCause": "Update validator's read-only check failure handling routes errors to update failure path instead of workflow task failure path.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Update validator was modified to properly propagate read-only check failures as workflow task failures rather than update failures.",
      "related": [],
      "keyQuote": "Failed read-Only check should cause a WFT failure in an update validator, not fail the update",
      "number": 1272,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:51.595Z"
    },
    {
      "summary": "Error messages returned when non-determinism is detected in workflows lack clarity about the root cause. Users need better error messaging that explicitly suggests non-deterministic code changes as the likely culprit.",
      "category": "other",
      "subcategory": "error-messages",
      "apis": [],
      "components": [
        "error-handling",
        "workflow-execution",
        "determinism-detection"
      ],
      "concepts": [
        "non-determinism",
        "error-messaging",
        "debugging",
        "user-experience",
        "code-clarity"
      ],
      "severity": "medium",
      "userImpact": "Users debugging non-deterministic workflow code are confused by cryptic error messages that don't indicate the root cause, making troubleshooting significantly harder.",
      "rootCause": "Error messages from non-determinism detection don't explicitly mention non-determinism as the likely cause.",
      "proposedFix": "Add clear suggestions in error messages indicating non-deterministic code changes as the root cause of errors like 'lookup failed for scheduledEventID' and 'No cached result found for side effectID'.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Error messages were improved to be more explicit about non-determinism being the likely cause.",
      "related": [
        864
      ],
      "keyQuote": "All these errors should suggested the error is likely caused by a non deterministic code change so users have a place to start debugging.",
      "number": 1271,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:55.034Z"
    },
    {
      "summary": "Remove tech debt from internal/context.go including commented-out code that should be deleted and incorrect use of goroutines in workflow context that appears to be dead code.",
      "category": "feature",
      "subcategory": "code-cleanup",
      "apis": [],
      "components": [
        "internal/context",
        "workflow-context"
      ],
      "concepts": [
        "tech-debt",
        "code-cleanup",
        "dead-code",
        "goroutine-usage"
      ],
      "severity": "low",
      "userImpact": "No direct user impact; improves code maintainability and reduces confusion for developers working with the SDK.",
      "rootCause": "Commented-out code left in internal/context.go and incorrect goroutine spawning in workflow context that is unreachable due to parentCancelCtx always returning true.",
      "proposedFix": "Remove commented-out code and replace the unreachable else statement with a panic to catch undefined state.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Code cleanup was completed by removing the tech debt from internal/context.go.",
      "related": [],
      "keyQuote": "When I last reviewed the code I conclude that the `else` statement was never satisfied since `parentCancelCtx` should always return true.",
      "number": 1270,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:36.954Z"
    },
    {
      "summary": "The WithCallerSkip method in the logger wrapper does not expand keyvals when wrapping a logger, causing inconsistent behavior when caller skip is applied.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logger",
        "withLogger",
        "WithCallerSkip"
      ],
      "concepts": [
        "logging",
        "caller-skip",
        "keyvals-expansion",
        "logger-wrapping",
        "method-chaining"
      ],
      "severity": "medium",
      "userImpact": "Users who use WithCallerSkip on wrapped loggers lose the key-value pairs that were previously set, breaking logging consistency.",
      "rootCause": "The WithCallerSkip method returns a new withLogger with the original keyvals but does not pass the expanded/merged keyvals to the wrapped logger's WithCallerSkip call.",
      "proposedFix": "The keyvals should be expanded (merged with the underlying logger's state) before being passed to the new withLogger instance returned by WithCallerSkip.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #1219 which ensures keyvals are properly expanded when WithCallerSkip is called.",
      "related": [
        1219
      ],
      "keyQuote": "loggerWith.WithCallerSkip should expand keyvals",
      "number": 1266,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:40.843Z"
    },
    {
      "summary": "Request to add UpdateWorkflowByID method to TestWorkflowEnvironment for testing purposes. This would allow sending updates to child workflows during tests, matching the existing SignalWorkflowByID functionality.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "UpdateWorkflowByID",
        "SignalWorkflowByID"
      ],
      "components": [
        "test-environment",
        "workflow-testing",
        "update-handler"
      ],
      "concepts": [
        "testing",
        "workflow-updates",
        "child-workflows",
        "test-utilities",
        "update-operations"
      ],
      "severity": "medium",
      "userImpact": "Test authors cannot easily send updates to child workflows in test environments, requiring workarounds that complicate tests.",
      "rootCause": null,
      "proposedFix": "Add UpdateWorkflowByID method to TestWorkflowEnvironment to mirror SignalWorkflowByID functionality.",
      "workaround": "Write a workflow in the test environment that sends the updates, though this complicates tests.",
      "resolution": "fixed",
      "resolutionDetails": "UpdateWorkflowByID was added to TestWorkflowEnvironment to provide parity with SignalWorkflowByID.",
      "related": [],
      "keyQuote": "For testing we need UpdateWorkflowByID as the update equivalent of SignalWorkflowByID. This is needed to, for example, send an update to a child workflow of the workflow under test.",
      "number": 1263,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:38.917Z"
    },
    {
      "summary": "The Worker API's Run() method takes a `<-chan interface{}` instead of accepting `context.Context`, making it inconvenient to use with Go contexts. The request seeks to simplify the API by having Run() accept context.Context directly, potentially replacing Start()/Stop() methods.",
      "category": "feature",
      "subcategory": "worker-api",
      "apis": [
        "Worker.Run"
      ],
      "components": [
        "worker",
        "api"
      ],
      "concepts": [
        "context",
        "channel-types",
        "api-simplification",
        "stability",
        "shutdown-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily use context.Context with Worker.Run() due to channel type incompatibility, requiring workarounds or awkward type conversions.",
      "rootCause": "Original API design used `<-chan interface{}` instead of `context.Context`, creating friction with standard Go patterns.",
      "proposedFix": "Change Worker.Run() to accept context.Context directly and remove Start()/Stop() methods as duplicates. Alternatively, at minimum update Run() to take context.Context. Users can use signal.NotifyContext() instead of InterruptCh().",
      "workaround": "Use signal.NotifyContext() for signal handling instead of InterruptCh(). Convert context to channel if needed.",
      "resolution": "wontfix",
      "resolutionDetails": "Stability requirements prevent changing the public API. The maintainers acknowledged the API design issue but cannot change it due to backward compatibility constraints.",
      "related": [],
      "keyQuote": "we have stability requirements that prevent changing any of our public API",
      "number": 1261,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:23.928Z"
    },
    {
      "summary": "A new release of contrib/opentelemetry is needed to incorporate the AllowInvalidParentSpans feature that was added to the tracing interceptor in SDK 1.25.0. The latest contrib/opentelemetry release (0.2.0) does not yet include these changes from PR #1178.",
      "category": "feature",
      "subcategory": "opentelemetry-tracing",
      "apis": [],
      "components": [
        "contrib/opentelemetry",
        "tracing-interceptor"
      ],
      "concepts": [
        "tracing",
        "distributed-tracing",
        "opentelemetry",
        "parent-spans",
        "release"
      ],
      "severity": "low",
      "userImpact": "Users cannot use the new AllowInvalidParentSpans feature in contrib/opentelemetry until a new release is published with the updated tracing interceptor changes.",
      "rootCause": null,
      "proposedFix": "Release a new version of contrib/opentelemetry that includes the changes from PR #1178",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Version 0.3.0 of contrib/opentelemetry was released with the required changes",
      "related": [
        1178
      ],
      "keyQuote": "A latest release has been tagged https://pkg.go.dev/go.temporal.io/sdk/contrib/opentelemetry@v0.3.0",
      "number": 1259,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:26.137Z"
    },
    {
      "summary": "User requests the ability to provide a custom predicate function to RetryPolicy to evaluate whether to retry based on custom logic. Maintainer explains this is not feasible because RetryPolicy is handled server-side and requires serialization.",
      "category": "feature",
      "subcategory": "retry-policy",
      "apis": [
        "RetryPolicy"
      ],
      "components": [
        "retry-policy",
        "worker",
        "service-communication"
      ],
      "concepts": [
        "retry",
        "custom-logic",
        "predicate",
        "serialization",
        "server-side-execution"
      ],
      "severity": "low",
      "userImpact": "Users cannot implement custom retry logic based on predicates within RetryPolicy and must handle retries manually.",
      "rootCause": "RetryPolicy is executed server-side by the Temporal service and requires serialization, making arbitrary function predicates impossible to implement.",
      "proposedFix": "Consider implementing a feature similar to the one described in sdk-java issue #806 as a more feasible alternative.",
      "workaround": "Handle custom retries manually outside of RetryPolicy.",
      "resolution": "wontfix",
      "resolutionDetails": "Rejected because RetryPolicy semantics require server-side execution and serialization, which is incompatible with custom predicates.",
      "related": [
        806
      ],
      "keyQuote": "RetryPolicy are retries that are handled by the Temporal service, and I wouldn't want to change that semantics... We can't serialize an arbitrary function.",
      "number": 1257,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:25.524Z"
    },
    {
      "summary": "Panics occurring in the update state machine are not being handled properly and don't cause workflow task failures, unlike panics in command state machines which are handled correctly.",
      "category": "bug",
      "subcategory": "update-state-machine",
      "apis": [],
      "components": [
        "update-state-machine",
        "command-state-machine",
        "workflow-task-handler"
      ],
      "concepts": [
        "panic-handling",
        "error-recovery",
        "state-machine",
        "workflow-execution",
        "failure-propagation"
      ],
      "severity": "high",
      "userImpact": "Unhandled panics in update state machines can silently fail without properly failing the workflow task, potentially leaving workflows in inconsistent states.",
      "rootCause": "Update state machine panic handling logic is not implemented to match the command state machine panic handling behavior.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Panic handling in update state machine was implemented to match command state machine behavior.",
      "related": [],
      "keyQuote": "Panics in update state machine should be treated like panics in command state machines.",
      "number": 1252,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:11.747Z"
    },
    {
      "summary": "Eager workflow start ignores worker versioning, causing the server to return eager workflow tasks regardless of the local worker's version. This breaks the versioning guarantees when eager start is enabled on a versioned task queue.",
      "category": "bug",
      "subcategory": "workflow-versioning",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "worker",
        "eager-start",
        "versioning",
        "task-queue"
      ],
      "concepts": [
        "versioning",
        "eager-execution",
        "workflow-start",
        "compatibility",
        "task-routing"
      ],
      "severity": "high",
      "userImpact": "Users enabling eager workflow start on versioned task queues may experience incompatible workflow executions when multiple versions of workers are running.",
      "rootCause": "The server returns eager workflow tasks for start workflow requests without validating the local worker version against the versioning configuration.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved, likely through a fix to the eager workflow start logic to respect worker versioning constraints.",
      "related": [],
      "keyQuote": "If a client is used to start a workflow on a task queue with versioning enabled and enables eager workflow start...the server will return an eager workflow task...regardless of what version that local version is.",
      "number": 1250,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:11.509Z"
    },
    {
      "summary": "Request to enable TCP Keep Alive by default in the Go SDK to improve connection reliability and detect broken connections more quickly.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [],
      "components": [
        "client",
        "connection",
        "network"
      ],
      "concepts": [
        "tcp-keepalive",
        "connection-reliability",
        "connection-stability",
        "network-health",
        "dead-connection-detection"
      ],
      "severity": "medium",
      "userImpact": "Users will benefit from more reliable connections and faster detection of broken network connections without manual configuration.",
      "rootCause": null,
      "proposedFix": "Enable TCP Keep Alive as a default setting in the Go SDK client configuration.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "TCP Keep Alive was enabled by default in the Go SDK implementation.",
      "related": [
        123
      ],
      "keyQuote": "Enable TCP Keep alive by default",
      "number": 1248,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:55:07.674Z"
    },
    {
      "summary": "Feature request to add a start delay option to workflow start options in the Go SDK, allowing workflows to be scheduled to start after a specified delay.",
      "category": "feature",
      "subcategory": "workflow-options",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-client",
        "workflow-options"
      ],
      "concepts": [
        "delayed-execution",
        "scheduling",
        "workflow-initialization",
        "temporal-configuration",
        "start-options"
      ],
      "severity": "low",
      "userImpact": "Users would be able to schedule workflows to start at a future time without needing external scheduling logic.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support start delay in workflow options.",
      "related": [
        338
      ],
      "keyQuote": null,
      "number": 1243,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:57.337Z"
    },
    {
      "summary": "A data race condition occurs in the Go SDK after the deadlock detector fires during workflow execution. The race involves concurrent access to a map in the command state machine, with one goroutine reading while another writes, potentially triggered by a recent PR to the deadlock detection code.",
      "category": "bug",
      "subcategory": "concurrency-race-condition",
      "apis": [
        "GetVersion"
      ],
      "components": [
        "command-state-machine",
        "workflow-execution-handler",
        "deadlock-detector"
      ],
      "concepts": [
        "data-race",
        "deadlock-detection",
        "goroutine-safety",
        "concurrent-access",
        "workflow-execution",
        "version-marker"
      ],
      "severity": "high",
      "userImpact": "Workflows may panic and fail unpredictably when the deadlock detector is triggered, affecting workflow reliability in production environments.",
      "rootCause": "Concurrent map access in commandsHelper.addCommand() and commandStateMachineBase.moveState() - one goroutine reads the map while another deletes from it, likely introduced by changes to deadlock detection in a recent PR.",
      "proposedFix": null,
      "workaround": null,
      "related": [],
      "keyQuote": "Data race observed in VersionLoopWorkflow, after the deadlock detector fired... Likely suspect is this PR",
      "resolution": null,
      "resolutionDetails": null,
      "number": 1240,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:56.794Z"
    },
    {
      "summary": "The NamespaceClient mock's Update function is missing the request argument, causing argument mismatch when attempting to use this mock to return values.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Update"
      ],
      "components": [
        "NamespaceClient",
        "mocks"
      ],
      "concepts": [
        "mocking",
        "test-setup",
        "argument-mismatch",
        "mock-validation"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot properly mock NamespaceClient.Update calls in tests, preventing effective unit testing of code that uses this client.",
      "rootCause": "Missing request argument in the Update function signature of the NamespaceClient mock implementation.",
      "proposedFix": "Add the missing request argument to the Update function in mocks/NamespaceClient.go line 80.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The missing request argument was added to the NamespaceClient mock's Update function.",
      "related": [],
      "keyQuote": "This line is missing the `request` argument to the `Update` function. This means that there is _always_ a mismatch in arguments when attempting to use this mock to return values.",
      "number": 1238,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:57.176Z"
    },
    {
      "summary": "Add support for the Build ID Reachability API in the Go SDK, allowing developers to query which build IDs are reachable within a temporal workflow or activity.",
      "category": "feature",
      "subcategory": "build-id-versioning",
      "apis": [
        "BuildIDReachability"
      ],
      "components": [
        "worker",
        "sdk-core",
        "versioning"
      ],
      "concepts": [
        "build-id",
        "reachability",
        "versioning",
        "compatibility",
        "deployment"
      ],
      "severity": "medium",
      "userImpact": "Go SDK users cannot use the Build ID Reachability API to query build ID compatibility, limiting their ability to manage safe deployments.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Build ID Reachability API support was implemented in the Go SDK.",
      "related": [],
      "keyQuote": "Build ID reachability API should be supported in the Go SDK",
      "number": 1237,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:42.711Z"
    },
    {
      "summary": "Test `TestVersionLoopWorkflow` can sometimes fail because the workflow does not yield for more than a second, likely due to the for loop taking too long. Reducing the number of iterations in the loop is suggested as a fix.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "workflow-execution"
      ],
      "concepts": [
        "test-flakiness",
        "timing",
        "yield",
        "workflow-blocking",
        "performance"
      ],
      "severity": "low",
      "userImpact": "Developers experience intermittent test failures in the version loop workflow test, reducing confidence in the test suite.",
      "rootCause": "The for loop in TestVersionLoopWorkflow takes too long to execute, preventing the workflow from yielding within a one-second threshold.",
      "proposedFix": "Reduce the number of iterations in the for loop within the test.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed by reducing iterations in the test loop to ensure the workflow yields within timing constraints.",
      "related": [],
      "keyQuote": "Test `TestVersionLoopWorkflow` can sometimes fail because the workflow does not yield for more then a second",
      "number": 1236,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:44.710Z"
    },
    {
      "summary": "Defers in workflow.Go are currently running in parallel during cache eviction, but should run deterministically and in sequence. While PR #1210 fixed the main consequence, edge cases remain where parallel execution could cause user issues, and we need to ensure cache eviction doesn't get blocked by this fix.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "workflow.Go"
      ],
      "components": [
        "workflow-cache",
        "defer-execution",
        "cache-eviction"
      ],
      "concepts": [
        "determinism",
        "sequencing",
        "concurrency",
        "cache-management",
        "cleanup",
        "goroutine-safety"
      ],
      "severity": "high",
      "userImpact": "Users may experience undefined behavior when defers in workflows run in parallel, especially during cache eviction scenarios, potentially causing data races and logic errors.",
      "rootCause": "Defers in workflow.Go are being executed concurrently instead of sequentially during cache eviction.",
      "proposedFix": "Run defers deterministically and in sequence on cache eviction while ensuring the eviction process is not blocked.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed with related fix in PR #1210, though edge cases were addressed in follow-up work.",
      "related": [
        1209,
        1210
      ],
      "keyQuote": "Defers in workflow.Go should be run deterministically and in sequence on cache eviction.",
      "number": 1235,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:43.587Z"
    },
    {
      "summary": "Implementation to prevent users from combining sessions and worker versioning together, as the version API cannot currently handle the constraints imposed by sessions. The system will fail when both features are used together.",
      "category": "feature",
      "subcategory": "sessions",
      "apis": [],
      "components": [
        "worker",
        "session-manager",
        "version-api"
      ],
      "concepts": [
        "sessions",
        "worker-versioning",
        "api-constraints",
        "feature-compatibility",
        "versioning"
      ],
      "severity": "medium",
      "userImpact": "Users attempting to use sessions with worker versioning will receive a clear failure instead of encountering undefined behavior or runtime errors.",
      "rootCause": "The version API's constraints are incompatible with session requirements, making simultaneous use unsupported.",
      "proposedFix": "Add validation to fail when users attempt to create both a session worker and a versioned worker together.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation added to prevent combining sessions and worker versioning by failing early with a clear error.",
      "related": [
        1227
      ],
      "keyQuote": "users cannot combine sessions and worker versioning . Until the version API can handle the constraints of sessions we agreeded to fail when trying to combine sessions and worker version",
      "number": 1234,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:31.371Z"
    },
    {
      "summary": "Request to add a RawValue type to the Go SDK that allows users to retrieve signal/payload data without automatic data conversion, similar to Python SDK's RawValue. This is particularly useful for handling corrupted signals.",
      "category": "feature",
      "subcategory": "data-conversion",
      "apis": [],
      "components": [
        "data-converter",
        "signal-handling"
      ],
      "concepts": [
        "raw-payload",
        "data-conversion",
        "signal-processing",
        "error-handling",
        "type-system"
      ],
      "severity": "low",
      "userImpact": "Users can now access raw signal/payload data without automatic conversion, enabling handling of corrupted or problematic data.",
      "rootCause": null,
      "proposedFix": "Add a RawValue type similar to Python SDK's RawValue that bypasses data conversion",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented as a new RawValue type in the Go SDK",
      "related": [
        603
      ],
      "keyQuote": "Sometimes users just want to get the payload from something without attempting any data conversion.",
      "number": 1231,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:29.613Z"
    },
    {
      "summary": "Users of the Workflow linter need a way to override the entry point for checking, as generic helper functions wrapping the actual workflow logic cause the checker to analyze the wrapper instead of the deterministic workflow code.",
      "category": "feature",
      "subcategory": "workflow-checker",
      "apis": [],
      "components": [
        "workflowcheck",
        "linter",
        "workflow-determinism"
      ],
      "concepts": [
        "determinism",
        "generics",
        "entry-point",
        "linting",
        "static-analysis"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use generic helper functions to wrap workflows without the linter false-alarming on non-deterministic code in the wrapper.",
      "rootCause": "The workflow checker cannot trace through generic function wrappers to identify the actual workflow entry point that needs determinism checking.",
      "proposedFix": "Allow configuring an alternate entry point method for the linter to check (e.g., (w *Workflow) Execute instead of (w *Workflow) Run).",
      "workaround": "Recent changes in #1215 now check all functions accepting workflow.Context as first parameter, which resolved the issue.",
      "resolution": "fixed",
      "resolutionDetails": "PR #1215 implemented checking all functions with workflow.Context as first parameter, allowing the checker to find the actual workflow logic.",
      "related": [
        1215
      ],
      "keyQuote": "since we're using generics the workflow checker doesn't know that the main body of the workflow is actually the w.Execute function",
      "number": 1229,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:28.339Z"
    },
    {
      "summary": "Calling workflow.CreateSession while using a versioned worker fails because the internal session creation activity cannot locate a compatible worker, resulting in a ScheduleToStart timeout. Worker versioning and workflow sessions are fundamentally incompatible due to the session creation activity using a different task queue without version linkage.",
      "category": "bug",
      "subcategory": "worker-versioning",
      "apis": [
        "CreateSession",
        "UpdateWorkerBuildIdCompatibility",
        "CompleteSession"
      ],
      "components": [
        "worker",
        "session-management",
        "task-queue",
        "internal-activities"
      ],
      "concepts": [
        "worker-versioning",
        "session-creation",
        "task-queue-routing",
        "activity-scheduling",
        "build-id-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot use workflow sessions with versioned workers, blocking the use of both features together in production deployments.",
      "rootCause": "The internalSessionCreationActivity uses a task queue without version info, and the server has no mechanism to link version info across multiple task queues, causing the activity to fail scheduling.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Worker versioning and sessions are not compatible at this time because the task queue used for internalSessionCreationActivity does not have the same version info",
      "number": 1227,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:13.853Z"
    },
    {
      "summary": "Feature request to implement typed search attributes in the Go SDK, enabling compile-time type safety and better IDE support for search attribute definitions.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [],
      "components": [
        "search-attributes",
        "type-system"
      ],
      "concepts": [
        "type-safety",
        "compile-time-checking",
        "search-attributes",
        "api-design",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Users lack compile-time type checking for search attributes, leading to runtime errors and reduced IDE support for attribute definitions.",
      "rootCause": null,
      "proposedFix": "Implement typed search attributes as defined in the SDK proposal document",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented following the SDK typed search attributes proposal",
      "related": [],
      "keyQuote": "Implementation of typed search attributes",
      "number": 1218,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:16.469Z"
    },
    {
      "summary": "Feature request to implement worker autotuning for the Go SDK, allowing workers to automatically adjust their performance parameters based on configurable rules.",
      "category": "feature",
      "subcategory": "worker-autotuning",
      "apis": [],
      "components": [
        "worker",
        "performance-tuning"
      ],
      "concepts": [
        "autotuning",
        "performance",
        "worker-configuration",
        "resource-optimization"
      ],
      "severity": "medium",
      "userImpact": "Enables developers to have workers automatically optimize their performance without manual configuration.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved as a Go-specific implementation of a general SDK feature",
      "related": [],
      "keyQuote": "Temporal worker should be able to autotune themselves based on some set of rules",
      "number": 1216,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:14.299Z"
    },
    {
      "summary": "Feature request to add a queryable registry interface to the worker so users can programmatically retrieve information about registered activities and workflows. This would help with service discovery and introspection without requiring external data structures.",
      "category": "feature",
      "subcategory": "worker-registry",
      "apis": [
        "Worker"
      ],
      "components": [
        "worker",
        "registry"
      ],
      "concepts": [
        "service-discovery",
        "introspection",
        "registration",
        "metadata-query"
      ],
      "severity": "low",
      "userImpact": "Users could query the worker to discover registered activities and workflows at runtime instead of maintaining external registries or service discovery mechanisms.",
      "rootCause": null,
      "proposedFix": "Add queryable registry interface to the Worker that allows users to retrieve registered activities and workflows.",
      "workaround": "Store registration information in an external data structure, or expose a simple HTTP API that returns what was registered.",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainers determined this is unnecessary because users are already adding to the registry and can track what they add themselves. Adding new methods to interfaces is also a breaking change.",
      "related": [],
      "keyQuote": "Users are the ones adding to the registry, so they can keep track of what they add... we still sometimes do it [breaking changes].",
      "number": 1212,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:55.712Z"
    },
    {
      "summary": "Request to implement the full client.Client interface in TestWorkflowEnvironment, specifically the CancelWorkflow method. The test environment struct is missing several client methods, making it unsuitable as a drop-in replacement for the actual client.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "CancelWorkflow"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "client.Client"
      ],
      "concepts": [
        "testing",
        "mocking",
        "interface-implementation",
        "workflow-cancellation"
      ],
      "severity": "low",
      "userImpact": "Users cannot use TestWorkflowEnvironment as a complete mock client in test suites when testing workflow cancellation functionality.",
      "rootCause": "TestWorkflowEnvironment is intentionally designed as a testing utility rather than a full client implementation, leading to interface incompleteness.",
      "proposedFix": "Either add missing method implementations to TestWorkflowEnvironment or provide a separate client implementation for testing.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "The maintainers decided that TestWorkflowEnvironment should not fully implement the client.Client interface as doing so would be confusing for users who expect full client behavior. The test environment serves a different purpose than a production client.",
      "related": [],
      "keyQuote": "The test environment is not meant to implement the client. That would be confusing for people that expect client behavior.",
      "number": 1211,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:54:03.084Z"
    },
    {
      "summary": "A race condition occurs when evicting a workflow from cache in the Go SDK, particularly during child workflow cancellation operations. The issue manifests as concurrent map access violations when multiple goroutines attempt to interact with command state machines during workflow cleanup.",
      "category": "bug",
      "subcategory": "workflow-caching",
      "apis": [
        "ExecuteChildWorkflow",
        "WithCancel"
      ],
      "components": [
        "workflow-cache",
        "command-state-machine",
        "child-workflow-executor"
      ],
      "concepts": [
        "race-condition",
        "concurrency",
        "cache-eviction",
        "child-workflow-cancellation",
        "goroutine-safety",
        "synchronization"
      ],
      "severity": "high",
      "userImpact": "Users experience unpredictable runtime errors and crashes when running workflows with concurrent child workflow operations, particularly during cancellation, making workflows unreliable in production.",
      "rootCause": "Unsynchronized access to the commands map in commandsHelper during cache eviction when multiple workflow goroutines attempt concurrent read/write operations to the command state machine.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The race condition was fixed by synchronizing access to the command state machine during cache eviction operations.",
      "related": [
        743,
        1190
      ],
      "keyQuote": "Evicting a workflow from cache does causes a race condition in the SDK",
      "number": 1209,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:59.340Z"
    },
    {
      "summary": "Child context cancellation propagates in non-deterministic order because Go map iteration order is random. This can cause issues when a parent context cancels multiple children, as the selector may record real-time-first event instead of state-based cancellation.",
      "category": "bug",
      "subcategory": "context-cancellation",
      "apis": [
        "WithCancel",
        "ExecuteActivity",
        "NewSelector"
      ],
      "components": [
        "context",
        "workflow-execution",
        "selector"
      ],
      "concepts": [
        "determinism",
        "context-propagation",
        "cancellation-order",
        "map-iteration",
        "non-deterministic-behavior",
        "child-contexts"
      ],
      "severity": "medium",
      "userImpact": "Workflows with multiple concurrent activities may exhibit unpredictable cancellation behavior and test flakiness due to non-deterministic cancellation ordering.",
      "rootCause": "Child contexts are stored in a Go map which has non-deterministic iteration order, causing parent context cancellation to propagate to children in random order.",
      "proposedFix": "Maintain child-context order using a deterministic data structure (like a slice) instead of a map for storing child contexts, similar to the fix applied in the Cadence Go client.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1340
      ],
      "keyQuote": "Map order in Go is not deterministic so the order child contexts are canceled is not deterministic.",
      "number": 1208,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:43.546Z"
    },
    {
      "summary": "workflowcheck static analyzer cannot detect issues in workflow implementations accessed through interfaces. When registering workflows via interface methods rather than concrete type methods, the checker fails to analyze the workflow code for forbidden operations like time.Now().",
      "category": "feature",
      "subcategory": "static-analysis",
      "apis": [
        "RegisterWorkflow"
      ],
      "components": [
        "workflowcheck",
        "worker",
        "workflow-registry"
      ],
      "concepts": [
        "static-analysis",
        "interface-implementation",
        "type-resolution",
        "linting",
        "workflow-detection"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use interface-based workflow patterns without losing static analysis coverage for detecting non-deterministic operations in workflows.",
      "rootCause": "Static analyzer cannot follow interface implementations to discover actual workflow implementations, as Go lacks compile-time interface implementation markers.",
      "proposedFix": "Either: 1) Use var _ SomeInterface = (*SomeType)(nil) pattern to find implementations, 2) Assume any function taking ctx workflow.Context as first parameter is a workflow and analyze all of them, or 3) Provide user annotation mechanism for marking workflow entry points.",
      "workaround": "Register functions/methods on concrete types instead of using interfaces, or implement Register(worker.WorkflowRegistry) method on interface.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by implementing support for analyzing functions that take workflow.Context as first parameter, eliminating the need for explicit workflow registration discovery.",
      "related": [],
      "keyQuote": "A static analyzer is not going to be able to follow implementations of interfaces because Go does not have a way to define which types are meant to implement an interface at compile time.",
      "number": 1207,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:42.521Z"
    },
    {
      "summary": "Feature request to add a result field to RespondActivityTaskFailedRequest so that partial results can be obtained when an activity fails, similar to the result field in RespondActivityTaskCompletedRequest.",
      "category": "feature",
      "subcategory": "activity-error-handling",
      "apis": [
        "ExecuteActivity",
        "RespondActivityTaskFailedRequest",
        "RespondActivityTaskCompletedRequest",
        "NewApplicationError"
      ],
      "components": [
        "activity-executor",
        "future",
        "error-handling"
      ],
      "concepts": [
        "error-handling",
        "result-retrieval",
        "activity-failure",
        "error-details",
        "cross-language-compatibility"
      ],
      "severity": "low",
      "userImpact": "Users cannot access partial results when an activity fails, making it difficult to handle errors that still produce useful data.",
      "rootCause": "Temporal architecture design choice to support multiple languages and maintain backward compatibility by treating result and error as mutually exclusive.",
      "proposedFix": "Add result field to RespondActivityTaskFailedRequest matching RespondActivityTaskCompletedRequest.Result structure, or alternatively use NewApplicationError with details.",
      "workaround": "Use NewApplicationError with details parameter to return error information along with data.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer explained that the current architecture (result XOR error) is intentional for cross-language support and backward compatibility. Users should use NewApplicationError with details instead.",
      "related": [],
      "keyQuote": "In Temporal a workflow or an activity can either return a result or an error... Returning an error and a value that are both valid is a special case.",
      "number": 1201,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:40.318Z"
    },
    {
      "summary": "Worker shutdown should drain already-polled tasks instead of dropping them. Currently, when a worker shuts down, it abandons any tasks it has already polled but hasn't started processing. The request is to allow these tasks to be processed within the worker's stop timeout before closing.",
      "category": "feature",
      "subcategory": "worker-shutdown",
      "apis": [],
      "components": [
        "worker",
        "task-poller",
        "shutdown-handler"
      ],
      "concepts": [
        "graceful-shutdown",
        "task-draining",
        "resource-cleanup",
        "backpressure",
        "shutdown-timeout"
      ],
      "severity": "medium",
      "userImpact": "Users experience dropped tasks during worker shutdown, leading to potential task loss and inconsistent workflow execution.",
      "rootCause": "Worker shutdown logic immediately closes without processing already-polled tasks, treating them as discardable.",
      "proposedFix": "Modify worker shutdown to stop accepting new tasks but allow already-polled tasks to be processed within the stop timeout window.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1195
      ],
      "keyQuote": "When a worker is shutting down, it should stop accepting new tasks, but let any it already has polled try to be processed in the worker stop timeout",
      "number": 1197,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:27.480Z"
    },
    {
      "summary": "Version 1.24.0 of the Go SDK uses atomic.Bool which requires Go 1.19+, but go.mod hasn't been updated to reflect this minimum requirement. The code should either update go.mod or use uberatomic.Bool for consistency.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "go.mod",
        "atomic-operations",
        "dependency-management"
      ],
      "concepts": [
        "version-requirement",
        "compatibility",
        "dependency-constraint",
        "go-version",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users on Go versions below 1.19 will experience compilation failures when upgrading to v1.24.0.",
      "rootCause": "PR #1164 introduced atomic.Bool (Go 1.19+) without updating go.mod minimum version requirement.",
      "proposedFix": "Update go.mod to specify Go 1.19+ as minimum requirement, or replace atomic.Bool with uberatomic.Bool for consistency with existing code.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved when Go module file is updated to reflect Go 1.19+ requirement during CI update for Go 1.21.",
      "related": [
        1164
      ],
      "keyQuote": "This PR added the usage of atomic.Bool which was only added in Go v1.19",
      "number": 1196,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:26.799Z"
    },
    {
      "summary": "Update SDK name and version in task-level metadata when they change on the workflow, matching the values sent in client-name and client-version gRPC headers.",
      "category": "feature",
      "subcategory": "metadata",
      "apis": [],
      "components": [
        "metadata",
        "task-execution",
        "workflow"
      ],
      "concepts": [
        "sdk-version",
        "client-metadata",
        "task-metadata",
        "workflow-state"
      ],
      "severity": "low",
      "userImpact": "Ensures task-level metadata accurately reflects the current SDK version, improving debugging and compatibility tracking.",
      "rootCause": null,
      "proposedFix": "When SDK name or version changes on the workflow, update the task-level metadata to match current client-name and client-version values.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation updated to track and propagate SDK name/version changes to task metadata.",
      "related": [
        321
      ],
      "keyQuote": "if either SDK name or SDK version changed on the workflow from what was last seen on some task, set it to the current values",
      "number": 1194,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:25.198Z"
    },
    {
      "summary": "Concurrent map writes in the SDK's command state machine cause fatal crashes when parent workflows trigger large numbers of child workflows. The issue manifests as race conditions in the commandsHelper that make the SDK and all workflows on the runner unresponsive.",
      "category": "bug",
      "subcategory": "concurrency-synchronization",
      "apis": [
        "ExecuteActivity",
        "RequestCancelActivity",
        "StartWorkflow",
        "NewFuture"
      ],
      "components": [
        "command-state-machine",
        "commandsHelper",
        "workflow-environment",
        "activity-executor"
      ],
      "concepts": [
        "concurrent-map-access",
        "race-condition",
        "synchronization",
        "child-workflows",
        "activity-cancellation",
        "goroutine-safety"
      ],
      "severity": "critical",
      "userImpact": "SDK crashes with fatal concurrent map write error during high-volume child workflow execution, causing complete workflow execution failure and blocking all workflows on the affected runner.",
      "rootCause": "Missing synchronization protection for map writes in commandsHelper.addCommand() method when multiple goroutines attempt concurrent access during activity cancellation in high-concurrency scenarios.",
      "proposedFix": "Add synchronization (mutex) protection to the concurrent map access in the command state machine's addCommand method.",
      "workaround": "Avoid using defers in workflows as a temporary mitigation until the fix is released.",
      "resolution": "fixed",
      "resolutionDetails": "The concurrent map write issue was identified and fixed in the command state machine, with the fix merged and released in a subsequent SDK version.",
      "related": [],
      "keyQuote": "fatal error: concurrent map writes... when a parent workflow triggers a large number of child workflows... the impact is catastrophic as it impacts all the workflows executing on the runner.",
      "number": 1190,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:12.865Z"
    },
    {
      "summary": "Package documentation for testsuite on pkg.go.dev displays the MIT License instead of the proper package documentation because the license header in freeport.go is not separated from the package declaration by a blank line.",
      "category": "docs",
      "subcategory": "documentation-rendering",
      "apis": [],
      "components": [
        "testsuite",
        "freeport",
        "package-documentation"
      ],
      "concepts": [
        "documentation",
        "formatting",
        "package-docs",
        "license-header",
        "parsing",
        "pkg.go.dev"
      ],
      "severity": "low",
      "userImpact": "Users viewing the SDK documentation on pkg.go.dev see an irrelevant license text instead of the actual testsuite package description.",
      "rootCause": "Missing blank line between the license comment block and the 'package' keyword in testsuite/freeport.go causes pkg.go.dev parser to treat the license as the package documentation.",
      "proposedFix": "Add a blank line between the license header and the package declaration in testsuite/freeport.go.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The blank line was added to separate the license header from the package declaration.",
      "related": [],
      "keyQuote": "It shows \"The MIT License\" for `testsuite` because https://pkg.go.dev/go.temporal.io/sdk/testsuite is showing the license as the package docs",
      "number": 1189,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:10.144Z"
    },
    {
      "summary": "The Go SDK uses an archived Facebook clock library that requires verbose mocking syntax. The request is to switch to a more actively maintained and user-friendly clock library like clockwork for improved testability and to consolidate dependencies.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "mock-clock",
        "workflow-testing"
      ],
      "concepts": [
        "time-mocking",
        "testing",
        "dependency-management",
        "maintainability",
        "usability"
      ],
      "severity": "low",
      "userImpact": "Users must use a verbose workaround to mock time in tests and depend on an archived library, making unit testing less intuitive.",
      "rootCause": "The current clock library is archived and its mocking API is unintuitive compared to alternatives like clockwork.",
      "proposedFix": "Migrate from github.com/facebookarchive/clock to github.com/jonboulle/clockwork or remove the dependency entirely and implement custom mocking code in the SDK.",
      "workaround": "Users can implement their own clock mocking using alternatives like clockwork in their own test suites.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "With github.com/jonboulle/clockwork, it feels a bit more intuitive and readable: env.mockClock = clockwork.NewFakeClockAt(startTime)",
      "number": 1177,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:53:13.514Z"
    },
    {
      "summary": "Workflow fails with \"BadRequestCancelActivityAttributes: invalid history builder state\" when using a disconnected context with WaitForCancellation enabled to handle cancellation and timeouts gracefully.",
      "category": "bug",
      "subcategory": "cancellation-handling",
      "apis": [
        "ExecuteActivity",
        "NewDisconnectedContext",
        "WithCancel",
        "NewTimer",
        "NewSelector"
      ],
      "components": [
        "workflow-context",
        "activity-executor",
        "cancellation-handler",
        "history-builder"
      ],
      "concepts": [
        "cancellation",
        "disconnected-context",
        "timeout",
        "activity-lifecycle",
        "state-management",
        "workflow-execution"
      ],
      "severity": "high",
      "userImpact": "Users cannot implement graceful cancellation workflows that use disconnected contexts to handle both timeouts and cancellations, blocking a common workflow pattern.",
      "rootCause": "Invalid history builder state when attempting to add activity cancel-requested event after using a disconnected context with WaitForCancellation enabled.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #1181 which addressed the interaction between disconnected contexts and WaitForCancellation flag.",
      "related": [
        1181
      ],
      "keyQuote": "The workflow fails with BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event",
      "number": 1176,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:57.384Z"
    },
    {
      "summary": "OpenTelemetry TracingInterceptor fails when encountering invalid SpanContext from OpenTracing parent spans during migration, causing workflows to fail. Request to add an option to ignore invalid SpanContext and continue silently.",
      "category": "feature",
      "subcategory": "opentelemetry-tracing",
      "apis": [],
      "components": [
        "TracingInterceptor",
        "opentelemetry-contrib",
        "interceptor"
      ],
      "concepts": [
        "tracing",
        "span-context",
        "opentelemetry",
        "opentracing-migration",
        "error-handling",
        "graceful-degradation"
      ],
      "severity": "high",
      "userImpact": "Long-running workflows fail during OpenTracing to OpenTelemetry migration when encountering incompatible span contexts, disrupting critical services.",
      "rootCause": "TracingInterceptor returns an error when unable to extract valid SpanContext from OpenTracing parent span, preventing workflow execution",
      "proposedFix": "Add an optional configuration to TracingInterceptor to ignore invalid SpanContext errors and continue execution without establishing parent span connections",
      "workaround": "DataDog interceptor handles this gracefully; OpenTelemetry itself does not return errors for SpanContext extraction",
      "resolution": "fixed",
      "resolutionDetails": "Solution accepted as reasonable by maintainers; addressed by adding option to ignore tracing errors",
      "related": [],
      "keyQuote": "It's acceptable for spans to not connect to their parents for a short time; it is not acceptable for a critical workflow to fail because of a failure to trace.",
      "number": 1174,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:55.499Z"
    },
    {
      "summary": "Activity testing with OnActivity mock doesn't properly verify non-retryable error configurations. When testing error handling from activities, there's no way to confirm that activity options setting errors as non-retryable are actually applied, since mocked errors are always marked as retryable.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "OnActivity"
      ],
      "components": [
        "test-framework",
        "activity-executor",
        "error-handling"
      ],
      "concepts": [
        "testing",
        "mocking",
        "non-retryable-errors",
        "activity-options",
        "error-configuration",
        "verification"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably verify that their non-retryable error configurations in activity options are correctly applied during testing, making it difficult to ensure error handling behavior matches production.",
      "rootCause": "OnActivity mock always marks returned errors as retryable, preventing verification of non-retryable error settings configured in activity options.",
      "proposedFix": "OnActivity should fail tests when attempting to return an activity marked as retryable from a workflow with non-retryable error options, and properly mark non-retryable errors with appropriate metadata.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "there isn't a good alternative to know that i've set the error as non-retryable properly from temporal's perspective",
      "number": 1173,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:58.506Z"
    },
    {
      "summary": "Request to temporarily expose the gRPC client connection from the Go SDK for use by the in-development cloud API. This was a temporary measure as the cloud API was not yet stable and the approach was later superseded by a more comprehensive solution.",
      "category": "feature",
      "subcategory": "grpc-client",
      "apis": [],
      "components": [
        "grpc-client",
        "internalbindings",
        "cloud-api"
      ],
      "concepts": [
        "grpc-connection",
        "api-stability",
        "temporary-exposure",
        "cloud-integration"
      ],
      "severity": "low",
      "userImpact": "Allows cloud API to access the internal gRPC connection without requiring separate connection management.",
      "rootCause": null,
      "proposedFix": "Add GetGRPCConnection(internal.Client) *grpc.ClientConn to go.temporal.io/sdk/internalbindings with experimental warning",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Not pursued as the approach was changed. A more full-fledged cloud client solution was implemented instead (see #1426).",
      "related": [
        1426
      ],
      "keyQuote": "This is not the approach we're going to take, see #1426 for a more full-fledged cloud client.",
      "number": 1172,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:44.177Z"
    },
    {
      "summary": "TestActivityEnvironment has a hard-coded 10 minute timeout that prevents testing activities requiring longer execution times. User requests ability to configure timeout values when running activities in the test environment.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestActivityEnvironment"
      ],
      "components": [
        "test-activity-environment",
        "activity-executor",
        "test-suite"
      ],
      "concepts": [
        "timeout",
        "testing",
        "activity-execution",
        "configuration",
        "test-framework",
        "long-running-activities"
      ],
      "severity": "medium",
      "userImpact": "Users cannot effectively test activities with execution times exceeding 10 minutes without using a real server, requiring additional boilerplate code and coupling to external test infrastructure.",
      "rootCause": "TestActivityEnvironment has hard-coded 10 minute timeout without configuration options",
      "proposedFix": "Add ability to set timeout values as options when creating or running activities in TestActivityEnvironment",
      "workaround": "Use testsuite package to start a real development server for integration testing, though this requires additional boilerplate code",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently, the TestActivityEnvironment has a hard-coded 10 minute timeout. If I want to use the test suite to run an activity which takes longer than that, it fails with a timeout error.",
      "number": 1167,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:40.451Z"
    },
    {
      "summary": "TestWorkflowEnvironment.XByID methods don't work correctly after SetStartWorkflowOptions updates the workflow ID. The runningWorkflows map uses the default ID and isn't updated when the primary ID changes, causing workflows to appear not found.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "SetStartWorkflowOptions",
        "SignalWorkflowByID"
      ],
      "components": [
        "test-environment",
        "workflow-registry",
        "runningWorkflows-map"
      ],
      "concepts": [
        "workflow-id",
        "test-isolation",
        "state-synchronization",
        "delayed-callbacks",
        "id-mapping"
      ],
      "severity": "medium",
      "userImpact": "Developers testing workflows in TestWorkflowEnvironment cannot reliably signal workflows after changing their primary ID.",
      "rootCause": "The runningWorkflows map is initialized with the default ID and not updated when SetStartWorkflowOptions is called with a different ID.",
      "proposedFix": "Update the runningWorkflows map whenever SetStartWorkflowOptions is called with a new ID to keep the mapping in sync.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The runningWorkflows map is now properly updated when SetStartWorkflowOptions changes the workflow ID.",
      "related": [],
      "keyQuote": "We set the runningWorkflows map to the default ID and don't update the map on SetStartWorkflowOptions like we should.",
      "number": 1160,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:42.362Z"
    },
    {
      "summary": "Add a structured logging wrapper for Go's standard slog library. The SDK needs a NewStructuredLogger adapter to convert slog.Logger instances to the SDK's logger interface, enabling users to use the modern slog package with Temporal.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logging",
        "logger-interface",
        "log-adapter"
      ],
      "concepts": [
        "structured-logging",
        "slog",
        "logger-wrapper",
        "compatibility",
        "interface-adaptation"
      ],
      "severity": "low",
      "userImpact": "Users can now use Go's modern slog structured logging library directly with the Temporal SDK instead of being limited to older logging approaches.",
      "rootCause": null,
      "proposedFix": "Implement a slogLogger struct that wraps slog.Logger and implements the SDK's log.Logger and log.WithLogger interfaces with appropriate method mappings.",
      "workaround": "Users can manually implement the wrapper following the code example in the issue, or refer to the issue for a reference implementation.",
      "resolution": "fixed",
      "resolutionDetails": "The NewStructuredLogger wrapper was implemented in the SDK to bridge slog.Logger to the SDK's logger interfaces.",
      "related": [
        960
      ],
      "keyQuote": "Once it is we can add that. In the meantime, a sample can be added or people can just refer to this issue for that simple implementation.",
      "number": 1158,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:29.247Z"
    },
    {
      "summary": "Local activities in the Go SDK need support for WaitForCancellation option to allow them to react to worker stop cancellation events.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity",
        "activity-executor",
        "worker"
      ],
      "concepts": [
        "cancellation",
        "worker-stop",
        "graceful-shutdown",
        "cleanup",
        "signal-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly handle cleanup or cancellation logic in local activities when workers are stopped.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Local activities need to be able to react to worker stop cancellation if they want.",
      "number": 1157,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:24.897Z"
    },
    {
      "summary": "When a worker stops while an activity is running, the activity cancellation error is rejected by the server with 'unable to mark activity as canceled' instead of being recorded as failed. This causes delays as the server waits for timeout before retrying, unlike other SDKs which convert non-server-requested cancellations to application errors.",
      "category": "bug",
      "subcategory": "activity-cancellation",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "task-completion"
      ],
      "concepts": [
        "cancellation",
        "error-handling",
        "worker-shutdown",
        "retry",
        "timeout"
      ],
      "severity": "high",
      "userImpact": "Activities take longer to retry after worker shutdown because server waits for timeout instead of immediately failing the task.",
      "rootCause": "SDK sends activity cancelled status for context cancellations not initiated by server, which server rejects. Should send application error instead for non-server-requested cancellations.",
      "proposedFix": "Only send activity cancelled status if server requested the cancellation; wrap other cancellation errors as application errors instead. Add test proving worker stop during non-heartbeating activity retries on next worker.",
      "workaround": "Return a custom error with small NextRetryDelay from interceptor instead of relying on automatic retry after timeout.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1086
      ],
      "keyQuote": "unable to mark activity as canceled without activity being request canceled first",
      "number": 1156,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:27.928Z"
    },
    {
      "summary": "Add support for intercepting workflow.Await calls on WorkflowOutboundInterceptor. Currently, many workflow package calls are available for interception, but workflow.Await is not yet included.",
      "category": "feature",
      "subcategory": "interceptor",
      "apis": [
        "workflow.Await",
        "WorkflowOutboundInterceptor"
      ],
      "components": [
        "workflow",
        "interceptor",
        "outbound-interceptor"
      ],
      "concepts": [
        "intercepting",
        "workflow-execution",
        "extension-points",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot intercept or extend workflow.Await behavior through the WorkflowOutboundInterceptor, limiting customization and observability capabilities.",
      "rootCause": null,
      "proposedFix": "Add workflow.Await interception support to WorkflowOutboundInterceptor interface.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and integrated into WorkflowOutboundInterceptor.",
      "related": [],
      "keyQuote": "Many `workflow` package calls are on `WorkflowOutboundInterceptor`, but not this one yet. We should add it.",
      "number": 1155,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:12.863Z"
    },
    {
      "summary": "User expected the Args field in ScheduleWorkflowAction to accept any type like traditional workflow execution, but it requires []interface{}. Clarification provided that this is expected behavior and no type conversion is needed.",
      "category": "question",
      "subcategory": "schedule-workflow",
      "apis": [
        "ScheduleClient.Create",
        "ScheduleWorkflowAction"
      ],
      "components": [
        "schedule-client",
        "workflow-action"
      ],
      "concepts": [
        "arguments",
        "type-conversion",
        "api-design",
        "workflow-scheduling"
      ],
      "severity": "low",
      "userImpact": "Users may be confused about the expected argument format for scheduled workflows and whether type conversion is required.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": "Pass arguments as a list ([]interface{}) to the Args field of ScheduleWorkflowAction.",
      "resolution": "invalid",
      "resolutionDetails": "Clarified as expected behavior - no type conversion needed, just pass arguments as a list. User education resolved the confusion.",
      "related": [],
      "keyQuote": "You should not need to convert any types, just pass your arguments in as a list",
      "number": 1153,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:14.268Z"
    },
    {
      "summary": "Users request the ability to customize trace attribute keys used by the Tracing Interceptor. Currently, keys like temporalWorkflowID, temporalRunID, and temporalActivityID are hardcoded with no configuration option, forcing users to create custom interceptors for simple key renaming.",
      "category": "feature",
      "subcategory": "tracing-interceptor",
      "apis": [
        "interceptor.Interceptor",
        "interceptor.Tracer",
        "interceptor.TracerOptions",
        "interceptor.NewTracingInterceptor"
      ],
      "components": [
        "tracing-interceptor",
        "interceptor",
        "tracer-options",
        "opentelemetry-tracer",
        "opentracing-tracer"
      ],
      "concepts": [
        "trace-attributes",
        "custom-configuration",
        "observability",
        "span-tags",
        "trace-customization",
        "interceptor-extension"
      ],
      "severity": "medium",
      "userImpact": "Users cannot customize trace attribute keys without implementing a heavy custom interceptor solution, limiting flexibility for organizations with specific naming conventions.",
      "rootCause": "Trace attribute keys are hardcoded in the tracing interceptor with no configuration mechanism to override them.",
      "proposedFix": "Add key customization options to interceptor.TracerOptions and port them to opentelemetry.TracerOptions and opentracing.TracerOptions, allowing users to override default key names.",
      "workaround": "Create a custom interceptor.Tracer that wraps the default tracer and overrides StartSpan to rename tags, though this doesn't allow access to context for additional attributes.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The only way to customise those keys is to create our own implementation of interceptor.Interceptor which is kind of heavy work to simply rename these keys.",
      "number": 1149,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:13.392Z"
    },
    {
      "summary": "Concurrent map read/write panic occurs in tchannel-go when repeatedly starting and stopping a Temporal test server in tests. The issue manifests as a race condition in the handler registration during server setup.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "tchannel-go",
        "handler-registration"
      ],
      "concepts": [
        "concurrency",
        "race-condition",
        "map-access",
        "server-lifecycle",
        "test-isolation"
      ],
      "severity": "high",
      "userImpact": "Users running multiple test iterations with server start/stop cycles encounter crashes that prevent test execution.",
      "rootCause": "Concurrent map read and write in tchannel-go's handler registration during repeated server initialization cycles.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Identified as duplicate of temporalio/temporal#4000, which is a server-side tchannel-go concurrency issue.",
      "related": [
        4000
      ],
      "keyQuote": "This looks like the same tchannel-go concurrent map write issue as temporalio/temporal#4000. This is a server-side issue.",
      "number": 1145,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:57.281Z"
    },
    {
      "summary": "Non-determinism occurs when replaying mutable side-effects behind workflow versioning because GetVersion doesn't generate a command during replay, causing incorrect lookup in mutableSideEffectsRecorded map and missing marker command generation.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "GetVersion",
        "MutableSideEffect",
        "ExecuteActivity"
      ],
      "components": [
        "event-handlers",
        "command-state-machine",
        "workflow-versioning"
      ],
      "concepts": [
        "determinism",
        "workflow-replay",
        "side-effects",
        "version-markers",
        "command-generation",
        "event-ordering"
      ],
      "severity": "high",
      "userImpact": "Workflows using mutable side-effects inside versioned code paths crash with panic during replay due to missing marker commands.",
      "rootCause": "GetVersion does not generate a command during workflow replay, causing mutableSideEffectsRecorded map lookup to use incorrect commandsHelper.nextCommandEventID values, resulting in missing side-effect marker commands.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        809
      ],
      "keyQuote": "GetVersion doesn't generate a command explicitly while replaying, leading to wrong lookup in mutableSideEffectsRecorded due to wrong nextCommandEventID value.",
      "number": 1144,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:58.946Z"
    },
    {
      "summary": "Request to automatically instrument Activities based on configuration rather than requiring manual instrumentation for each activity. The author seeks built-in success/failure counts and latency metrics grouped by activity name.",
      "category": "feature",
      "subcategory": "metrics-instrumentation",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "metrics"
      ],
      "concepts": [
        "instrumentation",
        "metrics",
        "monitoring",
        "activity-execution",
        "observability",
        "performance-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users with many activities must manually instrument each one or miss activity-specific metrics; automatic instrumentation would reduce boilerplate and enable better observability by default.",
      "rootCause": null,
      "proposedFix": "Wrap instrumentation before and after ExecuteActivity execution, controlled by configuration/options, following existing Go metrics instrumentation patterns.",
      "workaround": "Manually instrument each activity or enable cluster-level metrics (which don't contain activity-specific labels).",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Have Activities automatically instrumented, if enabled via configuration/options. Propose to wrap instrumentation before and after ExecuteActivity",
      "number": 1138,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:52:00.634Z"
    },
    {
      "summary": "Feature request to support OpenTelemetry metrics as an alternative to Tally. OpenTelemetry was previously considered unstable but is now stable, and the SDK should provide native support to avoid requiring users to integrate multiple metrics libraries.",
      "category": "feature",
      "subcategory": "observability-metrics",
      "apis": [],
      "components": [
        "metrics-handler",
        "opentelemetry-contrib",
        "sdk-configuration"
      ],
      "concepts": [
        "observability",
        "metrics-instrumentation",
        "opentelemetry",
        "tally-metrics",
        "library-integration",
        "deployment-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users adopting OpenTelemetry are forced to integrate both OpenTelemetry and Tally metrics libraries, complicating their deployment configuration.",
      "rootCause": "SDK only supports Tally metrics; OpenTelemetry API was previously unstable but is now stable and widely adopted.",
      "proposedFix": "Implement OpenTelemetry metrics handler in the SDK to provide native support alongside or instead of Tally.",
      "workaround": "Implement the metrics.Handler interface to wrap OpenTelemetry (acknowledged as not ideal due to internal package exposure).",
      "resolution": "fixed",
      "resolutionDetails": "OpenTelemetry metrics implemented and released in separate contrib package (opentelemetry/v0.4.0), though subsequent versions revealed dependency incompatibilities with protobuf library versions.",
      "related": [],
      "keyQuote": "For Temporal to support OpenTelemetry for its metrics instrumentation.",
      "number": 1137,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:45.337Z"
    },
    {
      "summary": "OnSignalExternalWorkflow mock is not triggered when signaling a child workflow that was started with env.OnWorkflow. The test environment attempts to signal the actual workflow instead of calling the mock, making it impossible to assert that SignalExternalWorkflow was called on mocked child workflows.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [
        "SignalExternalWorkflow",
        "OnSignalExternalWorkflow",
        "OnWorkflow"
      ],
      "components": [
        "test-environment",
        "workflow-mocking",
        "signal-handling"
      ],
      "concepts": [
        "mocking",
        "child-workflows",
        "signal-routing",
        "test-assertions",
        "workflow-communication"
      ],
      "severity": "low",
      "userImpact": "Users cannot properly test and assert signal calls to child workflows in the test environment, limiting test coverage for workflows that signal their children.",
      "rootCause": "The test environment treats mocked child workflows as real workflows, attempting to signal them directly rather than routing signals through the OnSignalExternalWorkflow mock.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers clarified this is intended behavior - the test environment handles signals between known workflows but doesn't mock signals to external workflows. Mocking OnSignalExternalWorkflow for known child workflows could lead to inconsistent test code.",
      "related": [],
      "keyQuote": "If the test environment is aware of the workflow being signaled then the test environment knows what will happen on the signal request, so there is no need to mock it.",
      "number": 1134,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:41.660Z"
    },
    {
      "summary": "User reported a workflow deadlock when using timers in both root scope and coroutines, manifesting as a 'workflow goroutine didn't yield for over a second' error. The issue was resolved when the user discovered they needed to call selector.Select() to actually block on the selector.",
      "category": "question",
      "subcategory": "workflow-selector-concurrency",
      "apis": [
        "workflow.Go",
        "workflow.NewTimer",
        "workflow.NewSelector"
      ],
      "components": [
        "workflow-dispatcher",
        "selector",
        "coroutine-executor"
      ],
      "concepts": [
        "deadlock-detection",
        "goroutine-yielding",
        "blocking-selector",
        "concurrent-timers",
        "workflow-execution"
      ],
      "severity": "low",
      "userImpact": "Users may incorrectly implement workflow selectors with multiple timers and encounter spurious deadlock errors.",
      "rootCause": "User forgot to call selector.Select() to block on the selector, causing the workflow goroutine to not yield control properly.",
      "proposedFix": "Call selector.Select(ctx) after adding futures to the selector to actually block and wait for events.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was user error - the workflow code was missing the required selector.Select() call to block on the selector. Documentation clarifies this requirement.",
      "related": [],
      "keyQuote": "To wait until a future is ready you need to call `Select`, See this take from the documentation I linked above.",
      "number": 1133,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:44.545Z"
    },
    {
      "summary": "Add opt-in support for visiting all payloads at once in the proxy visitor interceptor instead of handling them one set at a time. This enables users to apply transformations (like encryption/decryption) across all payloads collected from a proto message.",
      "category": "feature",
      "subcategory": "payload-visitor",
      "apis": [
        "VisitPayloads"
      ],
      "components": [
        "proxy",
        "payload-visitor",
        "interceptor",
        "grpc-client"
      ],
      "concepts": [
        "payload-transformation",
        "interceptor",
        "proto-message",
        "batching",
        "encryption-decryption"
      ],
      "severity": "low",
      "userImpact": "Users currently must implement custom payload collection logic in user-land; native support would simplify building payload transforming interceptors.",
      "rootCause": null,
      "proposedFix": "Add an `AllAtOnce bool` option to `VisitPayloadsOptions` that causes a single visitor call with all collected payloads, with documentation requirements that output payloads must be 1:1 with input and `VisitPayloadsContext.Parent` will be nil.",
      "workaround": "Users can implement `CollectAllPayloads()` and `ApplyToAllPayloads()` utility functions as shown in the issue to gather payloads and apply transformations.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users want to collect these and then visit them together all at once.",
      "number": 1132,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:27.392Z"
    },
    {
      "summary": "WorkerActivitiesPerSecond rate limit is applied after receiving polls from the server, causing potential timeouts when activity processing is delayed. This creates issues when users set low rate limits (e.g., 1 activity per 10 seconds) combined with heartbeat timeouts.",
      "category": "bug",
      "subcategory": "activity-rate-limiting",
      "apis": [
        "WorkerActivitiesPerSecond"
      ],
      "components": [
        "worker",
        "activity-executor",
        "poller"
      ],
      "concepts": [
        "rate-limiting",
        "timeout",
        "heartbeat",
        "polling",
        "activity-processing",
        "server-timeout"
      ],
      "severity": "high",
      "userImpact": "Activities can timeout due to rate limiting delays even when intentionally configured with low throughput, breaking documented usage patterns.",
      "rootCause": "Rate limit is enforced post-poll-pre-process rather than pre-poll, causing server timeouts to occur while waiting for the rate limit to allow activity processing.",
      "proposedFix": "Either fix the timing of when the rate limit is applied (move it pre-poll), or at minimum add documentation warning users about this interaction with heartbeat timeouts.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "if they had a heartbeat timeout, it could timeout before it starts",
      "number": 1131,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:29.886Z"
    },
    {
      "summary": "Request to expose the `taskLimiter` field of workers to allow dynamic rate limit adjustments at runtime. The proposal includes a reflection-based workaround demonstrating the use case, though maintainers clarified that the limiter has different behavior than expected and the proper solution requires tracking with issue #569.",
      "category": "feature",
      "subcategory": "worker-rate-limiting",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "rate-limiter"
      ],
      "concepts": [
        "rate-limiting",
        "worker-configuration",
        "dynamic-adjustment",
        "workload-management",
        "thread-safety"
      ],
      "severity": "medium",
      "userImpact": "Users with fluctuating workloads cannot dynamically adjust worker task rates without restarting workers, limiting operational flexibility.",
      "rootCause": "The `taskLimiter` field is unexposed (private) in the worker implementation, preventing runtime rate adjustments.",
      "proposedFix": "Expose the `taskLimiter` field as public API to allow direct rate limit modifications at runtime, leveraging `rate.Limiter`'s mutex-based thread safety.",
      "workaround": "Maintain rate limits using external methods or restart workers, though these approaches lack flexibility.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers clarified that the limiter doesn't dynamically limit available slots as proposedit only affects time processing after slots are used. The proper solution requires implementing issue #569, which addresses true dynamic slot management.",
      "related": [
        569
      ],
      "keyQuote": "This limiter doesn't do what you may think. This doesn't dynamically limit available slots, it just affects time processing after slots are used.",
      "number": 1130,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:29.308Z"
    },
    {
      "summary": "TestWorkflowEnvironment's OnWorkflow method doesn't automatically register mocked workflows like OnActivity does, and mocking workflows by name doesn't provide proper error handling when the workflow hasn't been pre-registered.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "OnWorkflow",
        "OnActivity"
      ],
      "components": [
        "workflow_testsuite",
        "test-environment",
        "workflow-registration"
      ],
      "concepts": [
        "mocking",
        "workflow-registration",
        "test-setup",
        "reflection",
        "consistency"
      ],
      "severity": "medium",
      "userImpact": "Users writing tests with TestWorkflowEnvironment must manually register mocked workflows unlike mocked activities, causing inconsistent API behavior and potential silent failures.",
      "rootCause": "OnWorkflow method lacks the automatic registration logic that exists in OnActivity when using reflect.Func, and mock-by-name doesn't validate registration before attempting to use the workflow.",
      "proposedFix": "Add automatic workflow registration in OnWorkflow similar to OnActivity's implementation at lines 338-340, and add proper error handling for mock-by-name scenarios.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflows that are mocked are automatically registered when using a reflect.Func as a reflect.TypeOf(workflow) when invoking the api OnWorkflow, the same way this happens using OnActivity",
      "number": 1127,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:13.495Z"
    },
    {
      "summary": "ReceiveWithTimeout doesn't cancel outstanding timers when the receive operation completes before timeout, causing timers to fire in the background with no listeners. This can trigger unnecessary workflow replays.",
      "category": "bug",
      "subcategory": "signal-handling",
      "apis": [
        "ReceiveWithTimeout"
      ],
      "components": [
        "signal-receiver",
        "timer-manager",
        "workflow-execution"
      ],
      "concepts": [
        "timeout",
        "timer-cancellation",
        "signal-processing",
        "resource-cleanup",
        "replay"
      ],
      "severity": "medium",
      "userImpact": "Users experience unnecessary workflow replays when timers fire in the background after ReceiveWithTimeout completes successfully, potentially affecting performance and correctness.",
      "rootCause": "Each ReceiveWithTimeout call creates a timer, but if the call completes successfully before timeout, the timer is not cancelled and continues to fire in the background.",
      "proposedFix": "Cancel outstanding timers when ReceiveWithTimeout completes or is cancelled.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Consolidated with issue #986 as a duplicate.",
      "related": [
        986
      ],
      "keyQuote": "Today if the ReceiveWithTimeout call completes successfully before timeout, then the timer fires in the background but has no visible effect because nothing is listening to it anymore.",
      "number": 1125,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:10.728Z"
    },
    {
      "summary": "Activity functions with variadic arguments cannot be registered and called from workflows due to reflection limitations. The SDK uses reflect.Value.Call() instead of reflect.Value.CallSlice(), preventing proper argument unpacking for functions with variadic parameters like gRPC client methods.",
      "category": "feature",
      "subcategory": "activity-registration",
      "apis": [
        "ExecuteActivity",
        "RegisterActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "reflection",
        "argument-marshaling"
      ],
      "concepts": [
        "variadic-arguments",
        "reflection",
        "function-signature",
        "type-conversion",
        "interoperability",
        "gRPC-integration"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use gRPC client methods or other variadic functions as activities without writing wrapper functions, complicating integration of third-party APIs.",
      "rootCause": "executeFunction() in internal_worker.go uses reflect.Value.Call() which does not handle variadic arguments; CallSlice() would be needed to unpack array arguments into variadic parameters.",
      "proposedFix": "Change internal_worker.go to use reflect.Value.CallSlice() instead of Call(), or implement logic to unpack variadic arguments from array parameters passed to ExecuteActivity().",
      "workaround": "Create a wrapper function that converts variadic parameters to array parameters, then register and call the wrapper function instead of the original.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I need to make gRPC function calls from my workflows. All gRPC client functions generated by `protoc` have the variadic parameter `grpc.CallOption`",
      "number": 1114,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:51:14.994Z"
    },
    {
      "summary": "User reported that panics from goroutines created within activities crash the entire worker instead of being caught by the SDK's panic recovery mechanism.",
      "category": "question",
      "subcategory": "activity-execution",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "panic-handling"
      ],
      "concepts": [
        "panic-recovery",
        "goroutine-management",
        "error-handling",
        "worker-stability"
      ],
      "severity": "medium",
      "userImpact": "Users who create goroutines in their activities may experience unexpected worker crashes from panics they expected the SDK to handle.",
      "rootCause": "Go SDK cannot intercept panics in goroutines created by user code - Go language limitation prevents libraries from wrapping arbitrary goroutine calls with recover().",
      "proposedFix": null,
      "workaround": "Users must implement their own panic recovery (try-catch) in any goroutines they create within activities.",
      "resolution": "wontfix",
      "resolutionDetails": "SDK maintainer clarified this is a Go language limitation and user responsibility to handle panics in their own goroutines.",
      "related": [],
      "keyQuote": "Temporal cannot catch panics in every goroutine you create. You are responsible for handling your own panics in your goroutines.",
      "number": 1111,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:59.380Z"
    },
    {
      "summary": "ExecuteWorkflow's context timeout is being halved internally, causing workflows to timeout after half the user-specified duration. The issue stems from logic that halves the RPC timeout for retry purposes, but incorrectly applies this to the user-provided context deadline as well.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflowOptions"
      ],
      "components": [
        "client",
        "context-handling",
        "retry-policy",
        "timeout-management"
      ],
      "concepts": [
        "timeout",
        "context-deadline",
        "retry-logic",
        "gRPC-deadline",
        "deadline-propagation"
      ],
      "severity": "high",
      "userImpact": "Workflows fail prematurely with context deadline exceeded errors at half the expected timeout duration, breaking user-defined timeout contracts.",
      "rootCause": "The RPC timeout is correctly halved to allow retries within the user's context deadline, but the user-provided context timeout itself is being halved instead of only halving the RPC-level timeout.",
      "proposedFix": "Separate the RPC timeout (which should be halved for retry logic) from the user-provided context timeout (which should remain unchanged), ensuring only the RPC deadline is adjusted internally.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Making RPC timeout half the context timeout is fine, we just need to make sure to only halve the RPC timeout not the context timeout.",
      "number": 1104,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:58.302Z"
    },
    {
      "summary": "UpsertSearchAttributes returns nil error but fails the workflow task when the server rejects invalid search attributes. User requested configuration to prevent workflow task failures on search attribute errors.",
      "category": "question",
      "subcategory": "search-attributes",
      "apis": [
        "UpsertSearchAttributes"
      ],
      "components": [
        "workflow",
        "search-attributes",
        "command-generation"
      ],
      "concepts": [
        "error-handling",
        "workflow-execution",
        "search-attributes",
        "validation",
        "server-rejection"
      ],
      "severity": "low",
      "userImpact": "Workflows fail due to server-side search attribute validation errors with no SDK-level error handling option.",
      "rootCause": "The Temporal server fails the workflow task when search attributes are invalid; the SDK generates the command but the server rejects it during execution.",
      "proposedFix": "Configuration or environment variable to control whether workflow task failures should occur on search attribute errors.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Determined to be expected behavior - the SDK cannot prevent server-side task failures. Server is responsible for validating search attributes.",
      "related": [],
      "keyQuote": "I believe this is the Temporal server failing the workflow task because the search attribute is invalid. There is nothing the SDK can do if the server fails the workflow task.",
      "number": 1103,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:56.460Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not surface mock assertion errors from testify, causing tests to pass when they should fail due to unexpected activity invocations. The test environment silently swallows testify's failure signal instead of propagating it.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow",
        "OnActivity"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "mock-integration",
        "test-utilities"
      ],
      "concepts": [
        "mock-assertions",
        "test-failure-propagation",
        "invocation-counting",
        "error-handling"
      ],
      "severity": "high",
      "userImpact": "Tests fail silently when activities are called more times than expected, allowing bugs to slip through test coverage.",
      "rootCause": "TestWorkflowEnvironment does not surface or respect failure signals from testify's mock framework. Testify expects early failure on unexpected invocations, but when the test continues, the invocation counter is not incremented, causing AssertNumberOfCalls to report incorrect counts.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I'd expect TestWorkflowEnvironment to surface and respect the error and failure surfaced by testify, and mark the test case as failed.",
      "number": 1100,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:41.577Z"
    },
    {
      "summary": "TestWorkflowEnvironment's SetWorkflowRunTimeout causes deferred statements to run, but in the real Temporal server, workflows that timeout do not execute defer statements. This is a behavioral inconsistency between the test environment and production.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-execution",
        "timeout-handling"
      ],
      "concepts": [
        "defer-execution",
        "timeout",
        "test-environment",
        "goroutine-cleanup",
        "workflow-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users cannot accurately test workflow timeout behavior because the test framework differs from production in how it handles deferred cleanup statements.",
      "rootCause": "TestWorkflowEnvironment may handle timeouts differently than the server, possibly related to cache eviction and goroutine management. In Go, panic and runtime.Goexit both call defer, but discarding everything instead of running mocks is complex.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflows that timeout from TestWorkflowEnvironment.SetWorkflowRunTimeout run deferred statements, but workflows that timeout from the real server do not run defer statements",
      "number": 1099,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:44.984Z"
    },
    {
      "summary": "Request to implement comprehensive CI testing across all platforms supported by the Go SDK, following the approach used in the Python and .NET SDKs.",
      "category": "feature",
      "subcategory": "ci-testing",
      "apis": [],
      "components": [
        "ci",
        "test-infrastructure",
        "platform-support"
      ],
      "concepts": [
        "continuous-integration",
        "platform-compatibility",
        "automated-testing",
        "test-coverage",
        "multi-platform",
        "devops"
      ],
      "severity": "medium",
      "userImpact": "Ensures the Go SDK works reliably across all supported platforms without requiring manual verification.",
      "rootCause": null,
      "proposedFix": "Implement multi-platform CI testing following the patterns established in Python and .NET SDKs",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Multi-platform CI testing was implemented for the Go SDK",
      "related": [],
      "keyQuote": "Every platform we support should be tested in CI. See what we do in Python and .NET for an example.",
      "number": 1098,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:42.680Z"
    },
    {
      "summary": "Dev server cannot be stopped on Windows because the implementation relies on Unix signals. The fix requires platform-specific code using Windows console control APIs to properly interrupt the process.",
      "category": "bug",
      "subcategory": "dev-server",
      "apis": [],
      "components": [
        "dev-server",
        "process-management",
        "windows-support"
      ],
      "concepts": [
        "signal-handling",
        "process-termination",
        "platform-specific",
        "console-control",
        "windows-api"
      ],
      "severity": "high",
      "userImpact": "Windows users cannot properly stop the development server, forcing them to use external process termination methods.",
      "rootCause": "The dev server implementation uses Unix signals (SIGINT) which are not supported on Windows.",
      "proposedFix": "Create platform-specific files (util_windows.go and util_nonwindows.go) with separate sendInterrupt() implementations using Windows console control APIs for Windows and Unix signals for other platforms.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved via PR #1129 implementing platform-specific process interruption.",
      "related": [
        1129
      ],
      "keyQuote": "Dev server should stop on Windows, but we foolishly used signals.",
      "number": 1097,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:30.729Z"
    },
    {
      "summary": "Go SDK v1.22.1 fails to replay workflow history JSON files that contain null workerVersioningId fields, which are included by the Temporal Web UI. The SDK should handle these null fields gracefully instead of throwing an error.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowHistoryFromJSONFile"
      ],
      "components": [
        "history-parser",
        "workflow-replayer",
        "event-unmarshaling"
      ],
      "concepts": [
        "backward-compatibility",
        "null-handling",
        "JSON-deserialization",
        "version-migration",
        "schema-evolution"
      ],
      "severity": "high",
      "userImpact": "Users cannot replay workflow histories exported from Temporal Web UI v2.10.3 with Go SDK v1.22.1, breaking existing compatibility tests.",
      "rootCause": "The SDK's JSON unmarshaling logic treats the workerVersioningId field as required and rejects null values instead of ignoring them, despite this field being optional in the serialized history.",
      "proposedFix": "Modify the JSON unmarshaling logic to ignore null values for optional fields like workerVersioningId, maintaining backward compatibility with history files from older Web UI versions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        1084
      ],
      "keyQuote": "While the ideal solution is probably to ensure that the Web UI does not include null attributes like these, the fact that there's a version in production that includes them means that the SDK probably needs to handle them",
      "number": 1091,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:30.050Z"
    },
    {
      "summary": "Request to expose OriginalRunId and FirstRunId fields in the Go SDK's WorkflowInfo, matching functionality already available in Java SDK and Cadence Go SDK.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow",
        "workflow-info"
      ],
      "concepts": [
        "workflow-execution",
        "run-id",
        "workflow-history",
        "api-parity"
      ],
      "severity": "medium",
      "userImpact": "Users need access to original and first run IDs for workflow execution tracking and correlation, which is already available in other SDKs.",
      "rootCause": null,
      "proposedFix": "Add OriginalRunId and FirstRunId fields to WorkflowInfo struct, matching the implementation in Java SDK and Cadence Go SDK.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fields were exposed in WorkflowInfo to provide parity with Java SDK and Cadence SDK implementations.",
      "related": [],
      "keyQuote": "They are already provided in Java SDK",
      "number": 1087,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:26.991Z"
    },
    {
      "summary": "Users need a graceful shutdown mechanism for Go workers that waits for all in-flight activities to complete before returning, rather than applying a hard timeout that may interrupt long-running activities.",
      "category": "feature",
      "subcategory": "worker-shutdown",
      "apis": [
        "Stop",
        "WorkerStopTimeout"
      ],
      "components": [
        "worker",
        "activity-executor",
        "shutdown-handler"
      ],
      "concepts": [
        "graceful-shutdown",
        "activity-completion",
        "timeout-handling",
        "resource-cleanup",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably ensure all long-running activities complete before their workers shut down, risking incomplete work and potential data inconsistency.",
      "rootCause": "Current WorkerStopTimeout applies a hard deadline that interrupts activities rather than waiting for them to naturally complete.",
      "proposedFix": "Add a worker option to allow waiting for all activities to finish before Stop() returns, providing true graceful shutdown.",
      "workaround": "Set WorkerStopTimeout to a value longer than expected activity duration, but this still doesn't guarantee activity completion.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        261
      ],
      "keyQuote": "Users want to wait till all their activities are complete before killing their workers.",
      "number": 1086,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:13.612Z"
    },
    {
      "summary": "Workflow replay immediately exits without running code after upgrading to go.temporal.io/api v1.19, when previously working with v1.18.1. The issue was related to a bug in the SDK that was subsequently fixed in master/v1.22.1.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowHistoryFromJSONFile"
      ],
      "components": [
        "replayer",
        "workflow-engine",
        "history-processor"
      ],
      "concepts": [
        "replay",
        "version-compatibility",
        "api-upgrade",
        "history-loading"
      ],
      "severity": "high",
      "userImpact": "Users cannot replay workflow histories after upgrading the API version, breaking their ability to test and debug workflows offline.",
      "rootCause": "A bug in the SDK related to API v1.19 that caused replay to exit immediately without executing code. The issue was resolved in later SDK versions.",
      "proposedFix": "Upgrade to SDK v1.22.1 or later which includes the fix for this replay bug.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in later SDK releases (v1.22.1+). Users reporting the issue were advised to upgrade to master or latest released version.",
      "related": [
        1091
      ],
      "keyQuote": "A replay immediately exits without running code. Used to work with version go.temporal.io/api v1.18.1.",
      "number": 1084,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:16.705Z"
    },
    {
      "summary": "The num_pollers metric was not being exposed in worker metrics output, even though the SDK had tests for it. The issue was resolved by updating to a newer SDK version (v1.21.1) where the metric started displaying correctly.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "metrics"
      ],
      "concepts": [
        "metrics",
        "monitoring",
        "observability",
        "poller",
        "worker-configuration"
      ],
      "severity": "low",
      "userImpact": "Users monitoring worker performance via metrics were unable to see the num_pollers metric even though it was supposed to be available.",
      "rootCause": "Likely a version-specific issue where the metric was not being properly exported in certain SDK versions prior to v1.21.1.",
      "proposedFix": null,
      "workaround": "Update to SDK version v1.21.1 or later where the metric is properly exposed.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by updating to go.temporal.io/sdk v1.21.1 which properly exposes the num_pollers metric in worker metrics output.",
      "related": [],
      "keyQuote": "after setting it to v1.21.1 metric starts being displayed.",
      "number": 1078,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:14.395Z"
    },
    {
      "summary": "Verify that workflow execution completes at the same point during replay as in the original execution. The issue was resolved through a specific commit that ensures UpdateExecutionComplete behaves consistently across replay scenarios.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "workflow-executor",
        "replay-engine",
        "update-handler"
      ],
      "concepts": [
        "replay",
        "workflow-execution",
        "update-execution",
        "determinism",
        "state-consistency"
      ],
      "severity": "medium",
      "userImpact": "Ensures that workflow updates complete at consistent points during replay, preventing non-deterministic behavior that could cause workflow execution failures.",
      "rootCause": "UpdateExecutionComplete was not completing at the same point on replay as during original execution, causing inconsistent workflow behavior.",
      "proposedFix": "Fixed through commit 720dab006426a69d3e2ef0efdb1cc7cb817e3049",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved with commit 720dab006426a69d3e2ef0efdb1cc7cb817e3049",
      "related": [],
      "keyQuote": "Check update workflow execution completes at the same point on replay",
      "number": 1075,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:01.025Z"
    },
    {
      "summary": "Update the client API documentation to reflect the new advanced visibility features that are now available when using a SQL database backend.",
      "category": "docs",
      "subcategory": "visibility",
      "apis": [],
      "components": [
        "client",
        "visibility"
      ],
      "concepts": [
        "visibility",
        "advanced-visibility",
        "SQL-database",
        "documentation",
        "API-docs"
      ],
      "severity": "low",
      "userImpact": "Users need updated documentation to understand and utilize the advanced visibility features now available with SQL database backends.",
      "rootCause": null,
      "proposedFix": "Update client API docs in client.go around lines 369-380 to reflect the advanced visibility features available with SQL DB",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to reflect advanced visibility features now available with SQL database",
      "related": [],
      "keyQuote": "Update client API docs related to visibility since advanced visibility features are now available with SQL DB",
      "number": 1074,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:50:02.022Z"
    },
    {
      "summary": "When a worker is restarted without restarting the process, cached workflows can no longer execute local activities because the local activity tunnel is not reset, causing the workflow to become stuck.",
      "category": "bug",
      "subcategory": "worker-restart",
      "apis": [
        "LocalActivity"
      ],
      "components": [
        "worker",
        "workflow-cache",
        "activity-tunnel",
        "workflow-task-handler"
      ],
      "concepts": [
        "worker-restart",
        "cache-invalidation",
        "local-activity",
        "connection-reuse",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Users cannot restart workers without restarting the entire process if workflows are cached, as local activities will fail to execute.",
      "rootCause": "The workflow context holds a stale local activity channel and the workflow task handler remains stale after worker restart, causing cached workflows to use outdated references.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Cached workflows can no longer start local activities. The workflow execution was using the local activity tunnel for the worker before the restart",
      "number": 1068,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:59.795Z"
    },
    {
      "summary": "Local activity timeout handling is inconsistent between documentation and implementation. The code incorrectly requires only one timeout parameter and overrides one with the other, and it doesn't distinguish between StartToCloseTimeout and ScheduleToCloseTimeout for retry logic. Additionally, the SDK is missing ScheduleToStartTimeout that exists in the Java SDK.",
      "category": "bug",
      "subcategory": "local-activity-timeouts",
      "apis": [
        "LocalActivityOptions",
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity-executor",
        "activity-options",
        "timeout-handling"
      ],
      "concepts": [
        "timeout",
        "retry",
        "deadline",
        "local-activity",
        "schedule-to-close",
        "start-to-close"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably control individual timeout behavior for local activities and retries, making it difficult to implement proper timeout semantics.",
      "rootCause": "Implementation incorrectly overrides one timeout with another and treats all deadline exceeded errors as schedule-to-close timeouts rather than distinguishing between timeout types.",
      "proposedFix": "Fix the timeout logic to respect both ScheduleToCloseTimeout and StartToCloseTimeout independently, differentiate timeout types in error handling, and add ScheduleToStartTimeout support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the timeout inconsistencies were addressed in the implementation.",
      "related": [],
      "keyQuote": "If we fix this bug we have another problem that StartToCloseTimeout is not retried because it always treats ErrDeadlineExceeded as a TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
      "number": 1066,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:48.410Z"
    },
    {
      "summary": "The workflowcheck command's -V flag for displaying version information doesn't work as documented, throwing an error instead. The issue is caused by a Go bug in the flag parsing that requires using -V=full instead, but users also report path resolution problems when attempting the workaround.",
      "category": "bug",
      "subcategory": "cli-tools",
      "apis": [],
      "components": [
        "workflowcheck",
        "cli-flag-parsing"
      ],
      "concepts": [
        "version-display",
        "flag-parsing",
        "command-line-tools",
        "user-experience",
        "documentation"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily check the installed version of workflowcheck due to the documented flag not working as described.",
      "rootCause": "Go bug in flag parsing (golang.org/x/tools) that doesn't properly handle -V flag; also requires updating golang.org/x/tools dependency",
      "proposedFix": "Update golang.org/x/tools to a version that fixes the Go flag parsing bug",
      "workaround": "Use -V=full instead of -V, though this may require upgrading Go version",
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified as a Go tooling bug requiring a dependency update to golang.org/x/tools",
      "related": [
        57716
      ],
      "keyQuote": "This is a Go bug: https://github.com/golang/go/issues/57716. They didn't have proper docs, you need to use `-V=full`. We just need to update `golang.org/x/tools` in our go.mod.",
      "number": 1065,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:48.962Z"
    },
    {
      "summary": "workflowcheck tool incorrectly reports non-deterministic check failures when code containing non-deterministic operations is properly wrapped in SideEffect, which should be ignored by the checker.",
      "category": "bug",
      "subcategory": "workflowcheck",
      "apis": [
        "SideEffect"
      ],
      "components": [
        "workflowcheck",
        "workflow-checker",
        "determinism-validation"
      ],
      "concepts": [
        "non-determinism",
        "side-effects",
        "static-analysis",
        "workflow-validation",
        "deterministic-code"
      ],
      "severity": "medium",
      "userImpact": "Developers receive false positive errors from workflowcheck tool when using SideEffect to wrap non-deterministic code, blocking workflow development.",
      "rootCause": "workflowcheck was not properly excluding SideEffect blocks when performing non-deterministic code analysis.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by PR #1230 which fixed the workflowcheck tool to properly ignore SideEffect blocks during non-determinism checks.",
      "related": [
        1230
      ],
      "keyQuote": "workflowcheck is failing non-deterministic check when code is wrapped with the SideEffect.",
      "number": 1063,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:44.745Z"
    },
    {
      "summary": "Documentation for client.ExecuteWorkflow API is confusing and discourages valid use cases where executing workflows across server instances is necessary. User requests clearer documentation and best practices for cross-server workflow execution.",
      "category": "docs",
      "subcategory": "client-api-documentation",
      "apis": [
        "ExecuteWorkflow",
        "ExecuteChildWorkflow"
      ],
      "components": [
        "client",
        "workflow-execution",
        "documentation"
      ],
      "concepts": [
        "cross-server-execution",
        "workflow-orchestration",
        "api-clarity",
        "best-practices",
        "documentation-guidance"
      ],
      "severity": "medium",
      "userImpact": "Users are confused about when to use client.ExecuteWorkflow versus workflow.ExecuteChildWorkflow, potentially leading to incorrect implementation choices for cross-server scenarios.",
      "rootCause": "Documentation note discourages client.ExecuteWorkflow usage without clarifying valid use cases for executing workflows across different server instances.",
      "proposedFix": "Add clear documentation explaining valid use cases for client.ExecuteWorkflow and best practices for cross-server workflow execution scenarios.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was clarified to explain valid use cases for client.ExecuteWorkflow when executing workflows across server instances.",
      "related": [],
      "keyQuote": "I'm looking to execute a Workflow from a Workflow on another Server instance... Have clear documentation explaining that my use case is valid",
      "number": 1062,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:32.566Z"
    },
    {
      "summary": "Users accidentally pass workflow.Context instead of context.Context to activities, resulting in a confusing \"too few input arguments\" error. The SDK should warn when ExecuteActivity is called with a function that takes workflow.Context, helping users catch this common mistake and preventing accidental workflow invocations outside of workflow context.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "type-checking",
        "error-messages"
      ],
      "concepts": [
        "context-types",
        "parameter-validation",
        "developer-experience",
        "type-safety",
        "error-clarity"
      ],
      "severity": "medium",
      "userImpact": "New users encounter confusing error messages when accidentally passing workflow.Context to activities, making debugging difficult and potentially indicating a logic error in their code.",
      "rootCause": "The SDK does not validate at call time whether an activity function's parameter types match expectations, specifically checking for workflow.Context which should never be used in activities.",
      "proposedFix": "Add runtime validation in ExecuteActivity to detect when a function takes workflow.Context as a parameter and provide a clear, helpful error message.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was likely addressed through improved type checking or validation in activity execution.",
      "related": [],
      "keyQuote": "A issue new users run into is they define an activity that takes a `workflow.Context` as a parameter, often just mistyping `context.Context`.",
      "number": 1061,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:34.009Z"
    },
    {
      "summary": "During workflow replay after a worker crash, the update acceptance validator is skipped but Accept() is still called on the update state machine, causing a duplicate UpdateAccepted event to be added to the history that breaks subsequent replays.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Accept"
      ],
      "components": [
        "update-state-machine",
        "workflow-replay",
        "history",
        "worker"
      ],
      "concepts": [
        "replay",
        "state-machine",
        "durability",
        "history",
        "update-acceptance",
        "idempotency"
      ],
      "severity": "high",
      "userImpact": "Workflows that experience worker crashes while processing updates will have corrupted history that fails to replay correctly.",
      "rootCause": "The update validator is not re-run during replay, but Accept() is still called on the update state machine, resulting in a duplicate UpdateAccepted event being persisted to history.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by #1059, which presumably fixes the issue by ensuring validators are re-run or Accept() is not called during replay.",
      "related": [
        1059
      ],
      "keyQuote": "If a workflow replays due to something like a worker crash while there is an update in-flight, we don't re-run the validator for the update but we _do_ call Accept()",
      "number": 1057,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:30.771Z"
    },
    {
      "summary": "The Go SDK fails to respect the EncodedFailureAttributes server capability, always encoding failures regardless of whether the server supports this feature.",
      "category": "bug",
      "subcategory": "failure-encoding",
      "apis": [],
      "components": [
        "failure-handling",
        "server-capability-detection",
        "encoding"
      ],
      "concepts": [
        "capability-negotiation",
        "server-compatibility",
        "failure-serialization",
        "protocol-compliance"
      ],
      "severity": "medium",
      "userImpact": "Users with servers that don't support EncodedFailureAttributes may experience incompatibility or unexpected behavior when failures are encoded.",
      "rootCause": "Go SDK ignores the EncodedFailureAttributes capability flag from the server and unconditionally encodes failures.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Go SDK ignores `EncodedFailureAttributes`.",
      "number": 1054,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:15.152Z"
    },
    {
      "summary": "The `TemporalChangeVersion` search attribute accumulates values every time `getVersion` is called in Java and Go SDKs, causing the search attribute to exceed its size limit and trap workflows in WFT failure loops. The fix should either stop adding new versions or remove oldest ones when the limit is reached, with clear error/warning logging.",
      "category": "bug",
      "subcategory": "versioning",
      "apis": [
        "getVersion"
      ],
      "components": [
        "search-attributes",
        "workflow-execution",
        "temporal-change-version"
      ],
      "concepts": [
        "search-attribute-size-limit",
        "version-accumulation",
        "workflow-failure-loop",
        "memory-bloat"
      ],
      "severity": "high",
      "userImpact": "Workflows using getVersion can get stuck in WFT failure loops when search attribute size limits are exceeded, with no easy recovery path.",
      "rootCause": "TemporalChangeVersion search attribute continuously accumulates values without eviction or size management when getVersion is called repeatedly.",
      "proposedFix": "Either stop adding new versions to TemporalChangeVersion when size limit is reached, or remove the oldest versions from the list. Log clear error/warning when the situation occurs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed after implementing size limit handling and logging for the TemporalChangeVersion search attribute.",
      "related": [],
      "keyQuote": "The search attribute value size is capped, which causes user workflows to get stuck in a WFT failure loop without an easy way of out of this situation.",
      "number": 1052,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:19.471Z"
    },
    {
      "summary": "A data race condition exists in the eager activity executor where a wait group is being mutated during concurrent access between activity task handling and worker shutdown, potentially causing missed activity tasks if received during Stop.",
      "category": "bug",
      "subcategory": "eager-activity-execution",
      "apis": [],
      "components": [
        "eager-activity-executor",
        "task-poller",
        "base-worker",
        "synchronization"
      ],
      "concepts": [
        "data-race",
        "concurrent-access",
        "goroutine-safety",
        "wait-group",
        "worker-shutdown",
        "task-handling"
      ],
      "severity": "high",
      "userImpact": "Users may experience lost or missed activity tasks if they are received while the worker is shutting down, potentially causing workflows to fail or hang.",
      "rootCause": "The wait group used for synchronization is being mutated concurrently by activity task handling and worker shutdown logic without proper synchronization, causing a race condition detected by Go's race detector.",
      "proposedFix": "Switch to using channels instead of wait groups for synchronization, or implement proper locking around wait group access during shutdown.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed through refactoring synchronization primitives away from the problematic wait group approach.",
      "related": [],
      "keyQuote": "we're mutating that wait group while waiting on it and not sure there's an easy way out short of switching to channels",
      "number": 1050,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:18.448Z"
    },
    {
      "summary": "Workflow goroutines continue executing after the main workflow function returns, which violates expected behavior where goroutines should never run post-completion. This creates semantic inconsistency and potential memory leaks if goroutines are not properly cleaned up.",
      "category": "bug",
      "subcategory": "goroutine-lifecycle",
      "apis": [],
      "components": [
        "workflow-engine",
        "goroutine-scheduler",
        "workflow-executor"
      ],
      "concepts": [
        "goroutine-lifecycle",
        "workflow-completion",
        "concurrency-control",
        "memory-management",
        "process-semantics"
      ],
      "severity": "medium",
      "userImpact": "Users cannot rely on goroutine lifecycle semantics being consistent with workflow completion, leading to potential bugs and memory leaks when goroutines execute after workflow returns.",
      "rootCause": "Workflow engine does not prevent goroutine execution after the main workflow function returns; current implementation uses runtime.Goexit which still allows defer statements to execute.",
      "proposedFix": "Implement strict workflow goroutine lifecycle management where no goroutines run after workflow completion, similar to os.Exit() semantics rather than parent-child process model.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed as the current behavior became desirable with the addition of workflow updates feature (temporalio/features#481), which requires goroutines to potentially execute after main workflow completion.",
      "related": [
        481
      ],
      "keyQuote": "I think workflow completion is like os.Exit(). But yes, if today we run coroutines after workflow complete we probably can't change without that SDK version marker thing.",
      "number": 1049,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:04.312Z"
    },
    {
      "summary": "Channel.Receive can consume a message before the blocked goroutine is woken up, causing ReceiveAsync to miss messages. This contradicts the guarantee that draining all signal messages through ReceiveAsync prevents signal loss.",
      "category": "bug",
      "subcategory": "channel-receive",
      "apis": [
        "Channel.Receive",
        "Channel.ReceiveAsync",
        "Selector"
      ],
      "components": [
        "channel",
        "goroutine-scheduler",
        "signal-handling"
      ],
      "concepts": [
        "message-ordering",
        "goroutine-synchronization",
        "signal-delivery",
        "race-condition",
        "workflow-completion",
        "command-handling"
      ],
      "severity": "high",
      "userImpact": "Users may lose signal messages when relying on ReceiveAsync to drain pending signals before workflow completion.",
      "rootCause": "The goroutine blocked on Channel.Receive doesn't get woken up before ReceiveAsync consumes the message, causing a race condition in message delivery order.",
      "proposedFix": "Either ensure AsyncReceive always takes precedence, or give the main workflow goroutine the lowest precedence (approach taken by other SDKs).",
      "workaround": "Ensure clean goroutine exit by requiring non-primary coroutines with Receive to coordinate completion with the primary coroutine in user code.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue author agreed that requiring clean goroutine exit is the correct approach rather than changing message ordering semantics.",
      "related": [
        259
      ],
      "keyQuote": "requiring the clean goroutine exit is the way to go",
      "number": 1048,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:00.393Z"
    },
    {
      "summary": "User-provided data converters are not applied to memo fields when creating workflows and schedules in the Go SDK, unlike other SDKs. The issue requires finding a backwards-compatible fix approach since changing this behavior could break running workflows.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "CreateWorkflowExecution",
        "CreateSchedule"
      ],
      "components": [
        "workflow-client",
        "schedule-client",
        "data-converter"
      ],
      "concepts": [
        "data-serialization",
        "memo",
        "backwards-compatibility",
        "default-behavior"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use custom data converters for memo fields, limiting serialization flexibility and creating inconsistent behavior compared to other SDKs.",
      "rootCause": "The Go SDK hardcodes the default data converter for memos instead of using the user-provided one, unlike other Temporal SDKs.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Go uses the default data converter. Need to decide how we will fix this as changing is not backwards compatible and could break running workflows",
      "number": 1045,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:49:01.702Z"
    },
    {
      "summary": "SDK updates sent to a workflow while the worker is stopped are not being properly processed when the worker restarts. Two scenarios are demonstrated: updates waiting on activities fail with context deadline errors, and updates sent during worker downtime are not acknowledged in the workflow history.",
      "category": "bug",
      "subcategory": "workflow-updates",
      "apis": [
        "ExecuteWorkflow",
        "UpdateWorkflow",
        "SetUpdateHandler",
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "workflow-execution",
        "update-handler",
        "history-replay"
      ],
      "concepts": [
        "update-handling",
        "worker-restart",
        "history-replay",
        "sticky-queue",
        "speculative-tasks",
        "context-deadline"
      ],
      "severity": "high",
      "userImpact": "Workflows cannot reliably receive and process updates when workers are restarted or unavailable, causing update requests to fail or be lost.",
      "rootCause": "Two separate issues: (1) History replay after worker crash doesn't use the replayer's inferMessages logic to recover pending updates, (2) Speculative update tasks queued to sticky queue are not retried when a new worker incarnation starts with a different sticky queue",
      "proposedFix": "Use the same inferMessages call from the replayer during history replay in the code path that catches up workflow context after a crash; implement retry logic for speculative tasks on sticky queue mismatch",
      "workaround": "Disabling sticky queues works around the second issue (though this triggers a different bug that must also be fixed)",
      "resolution": "fixed",
      "resolutionDetails": "Closed by PR #1055, with related fixes in #1057 and temporalio/temporal#4018",
      "related": [
        1055,
        1057,
        4018
      ],
      "keyQuote": "we don't actually use the replayer...The same inferMessages call that is used by the replayer can be used in this additional code path",
      "number": 1044,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:47.299Z"
    },
    {
      "summary": "User seeks a way to get task queue backlog size for implementing autoscaling of workers. The `DescribeTaskQueue` API's `BacklogCountHint` field returns 0 even when tasks are queued, making it unsuitable for scaling decisions.",
      "category": "question",
      "subcategory": "task-queue-monitoring",
      "apis": [
        "DescribeTaskQueue",
        "WorkflowService"
      ],
      "components": [
        "worker",
        "task-queue",
        "metrics",
        "client"
      ],
      "concepts": [
        "autoscaling",
        "backlog",
        "task-queue-status",
        "polling",
        "worker-capacity",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably determine task queue backlog size to implement dynamic worker autoscaling, forcing them to rely on indirect metrics or custom solutions.",
      "rootCause": "The `BacklogCountHint` field is an internal implementation detail that doesn't accurately reflect actual task queue depth and is not intended for user-facing scaling decisions.",
      "proposedFix": "Improve documentation to clarify that SDK-side slot metrics and server-side poll metrics should be used instead of `BacklogCountHint` for autoscaling decisions.",
      "workaround": "Use server-side poll metrics (poll success rate, available slots) and SDK-side slot metrics to infer when scaling is needed, rather than directly querying backlog size.",
      "resolution": "wontfix",
      "resolutionDetails": "The issue was addressed as a documentation/guidance matter. The `BacklogCountHint` is not suitable for scaling; users should use poll success metrics and slot utilization instead.",
      "related": [],
      "keyQuote": "the hint may not reflect that value. I am getting details on that value now, but it is a mostly internal value that you should not use for scaling workers.",
      "number": 1043,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:47.810Z"
    },
    {
      "summary": "User needs guidance on how to test activity functions that call `activity.GetLogger(ctx)` with a proper activity context. The issue is that calling such functions from regular tests fails because they require a valid activity context that isn't available in standard test setup.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [
        "GetLogger"
      ],
      "components": [
        "activity-context",
        "test-suite",
        "activity-interceptor"
      ],
      "concepts": [
        "testing",
        "activity-context",
        "logging",
        "interceptor",
        "test-environment"
      ],
      "severity": "low",
      "userImpact": "Developers cannot easily unit test helper functions within activities that depend on the activity context for logging or other operations.",
      "rootCause": "Activity context is not directly accessible outside of the activity execution environment; `activity.GetLogger()` requires a properly initialized activity context that regular context.Background() cannot provide.",
      "proposedFix": "Use `testsuite.WorkflowTestSuite` with `ActivityTestEnvironment` to test activity functions, or create an activity-like wrapper function in tests that delegates to the function being tested.",
      "workaround": "Create a simple activity-like function in your test case that delegates to the function you want to test, allowing it to be invoked through the `ActivityTestEnvironment`.",
      "resolution": "stale",
      "resolutionDetails": "Issue was closed due to inactivity. The suggested solution was to use the WorkflowTestSuite and ActivityTestEnvironment for proper activity context testing.",
      "related": [],
      "keyQuote": "To the environment, there is (mostly) no difference between a \"full blown activity\" and \"a function that's called inside the activity\". That test environment is for all functions that accept an activity context.",
      "number": 1042,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:48.432Z"
    },
    {
      "summary": "Parent workflow hangs when spawning multiple child workflows with the same workflowId. The second attempt to get the child workflow execution blocks indefinitely because the ChildWorkflowExecutionAlreadyStartedError is not propagated to all futures.",
      "category": "bug",
      "subcategory": "child-workflow-execution",
      "apis": [
        "ExecuteChildWorkflow",
        "GetChildWorkflowExecution"
      ],
      "components": [
        "child-workflow-executor",
        "workflow-future",
        "error-propagation"
      ],
      "concepts": [
        "child-workflow",
        "workflow-id-collision",
        "determinism",
        "error-handling",
        "async-execution"
      ],
      "severity": "high",
      "userImpact": "Workflows hang when attempting to spawn child workflows with duplicate IDs, blocking legitimate use cases where the same child workflow ID is reused.",
      "rootCause": "The ChildWorkflowExecutionAlreadyStartedError is only set on one of the two futures used by child workflow execution, causing the execution future to never unblock when the error occurs.",
      "proposedFix": "Propagate the ChildWorkflowExecutionAlreadyStartedError to both child workflow futures, with potential versioning via SDKFlags to maintain determinism for existing workflows.",
      "workaround": "Maintain a set of child workflow futures keyed by their ID and check before starting new children, or avoid using the same workflow ID for any child workflow.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was caused by PR #999 not propagating the error to both futures. A fix was proposed using SDKFlags for versioning to preserve determinism.",
      "related": [
        999,
        1056
      ],
      "keyQuote": "The ChildWorkflowExecutionAlreadyStartedError is only set on one of the two futures child workflow use, so waiting on the execution future never unblocks.",
      "number": 1041,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:28.257Z"
    },
    {
      "summary": "ScheduleCalendarSpec should default unset ranges to zero range instead of requiring at least one Range for every field (except year), aligning with other SDK implementations like TypeScript.",
      "category": "feature",
      "subcategory": "schedule-calendar-spec",
      "apis": [
        "ScheduleCalendarSpec"
      ],
      "components": [
        "schedule",
        "calendar-spec",
        "sdk-go"
      ],
      "concepts": [
        "default-values",
        "user-experience",
        "sdk-alignment",
        "schedule-configuration",
        "field-validation"
      ],
      "severity": "medium",
      "userImpact": "Users currently have difficulty configuring schedules because unset ranges require explicit specification instead of sensible defaults available in other SDKs.",
      "rootCause": "ScheduleCalendarSpec requires at least one Range to be present for all fields besides year, deviating from SDK implementations in TypeScript and others.",
      "proposedFix": "Set unset ranges to the zero range when creating a schedule, matching the behavior of other SDKs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation aligned ScheduleCalendarSpec with other SDKs by setting unset ranges to zero range by default.",
      "related": [],
      "keyQuote": "This is difficult for users and is not what was implemented in other SDKs. The ask is to align with other SDKs like typescript and set unset ranges to the zero range when creating a schedule",
      "number": 1040,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:29.431Z"
    },
    {
      "summary": "Calling a value receiver method with a pointer type causes a panic in ExecuteActivity due to Go's automatic dereferencing behavior. The issue arises from reflection attempting to call methods on nil pointers in the activity invocation path.",
      "category": "bug",
      "subcategory": "activity-invocation",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "reflection-handler",
        "method-invocation"
      ],
      "concepts": [
        "method-receiver",
        "pointer-dereferencing",
        "reflection",
        "type-safety",
        "panic-recovery"
      ],
      "severity": "medium",
      "userImpact": "Users encounter runtime panics when passing pointer types to activities that have value receiver methods, limiting how they can structure activity definitions.",
      "rootCause": "Go's method spec automatically dereferences pointers when accessing value receiver methods (pt.Mv  (*pt).Mv), but the Temporal SDK's reflection-based activity invocation doesn't account for this, resulting in nil pointer dereference when the pointer is nil or uninitialized.",
      "proposedFix": "Support uncurried method syntax (e.g., ActivityStruct.Activity instead of a.Activity) to avoid automatic dereferencing, or add validation checks in the workflow type checker to detect and warn about incompatible method-pointer combinations.",
      "workaround": "Use pointer receiver methods with initialized pointers, or use top-level functions instead of methods for activities.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There is an alternative in that we may be able to support `ActivityStruct.Activity` but that basically uncurries the first arg as the receiver which has other implications.",
      "number": 1037,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:32.548Z"
    },
    {
      "summary": "Workflowcheck should validate that serialized structs don't have unexported fields unless they have a json-ignore tag, as this is a common mistake when implementing workflows. Should also handle custom MarshalJSON implementations that may serialize unexported fields.",
      "category": "feature",
      "subcategory": "workflow-validation",
      "apis": [],
      "components": [
        "workflowcheck",
        "serialization",
        "struct-validation"
      ],
      "concepts": [
        "serialization",
        "struct-fields",
        "json-tags",
        "unexported-fields",
        "validation",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Developers frequently make mistakes by including unexported fields in serializable workflow structs, which causes runtime failures.",
      "rootCause": "Workflowcheck does not validate that serialized structs only contain exported fields or properly json-tagged unexported fields.",
      "proposedFix": "Enhance workflowcheck to detect unexported fields on serialized structs and error unless they have json-ignore tags. Similar to Go's vet structtag check but for Temporal workflows.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "People make this mistake plenty. There's rarely value for an unexported field on a serialized struct.",
      "number": 1035,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:09.750Z"
    },
    {
      "summary": "OnUpsertSearchAttributes and OnUpsertMemo mocking behavior is unclear. These mock interceptors are currently event listeners that cannot affect workflow behavior, but users are confused about their purpose and whether they should support mocking with return values or error handling.",
      "category": "docs",
      "subcategory": "test-framework",
      "apis": [
        "OnUpsertSearchAttributes",
        "OnUpsertMemo"
      ],
      "components": [
        "test-framework",
        "mocking",
        "workflow-execution",
        "interceptors"
      ],
      "concepts": [
        "mocking",
        "event-listeners",
        "search-attributes",
        "memo",
        "test-environment",
        "validation",
        "behavior-parity"
      ],
      "severity": "low",
      "userImpact": "Users are confused about whether OnUpsertSearchAttributes and OnUpsertMemo can be mocked in tests, leading to potential misuse and false expectations about test behavior.",
      "rootCause": "Unclear documentation about whether these interceptors are meant to be event listeners or mockable functions that can affect behavior.",
      "proposedFix": "Document that OnUpsertSearchAttributes and OnUpsertMemo are event listeners that cannot affect behavior, with rationale that mocking would create discrepancies between test and real environments.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We should document that `OnUpsertSearchAttributes` and `OnUpsertMemo` are just `event listeners`. Mocking these calls return value in the test environment doesn't make sense since the real environment and the test environment perform identical validation",
      "number": 1033,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:12.291Z"
    },
    {
      "summary": "Users need visibility into session state to determine whether a session has failed, particularly when an activity fails due to session failure. This feature request asks to expose the internal session state information to SDK users so they can reliably handle session failures and implement proper recovery logic.",
      "category": "feature",
      "subcategory": "session-management",
      "apis": [
        "ExecuteActivity",
        "SessionInfo"
      ],
      "components": [
        "session-executor",
        "activity-executor",
        "error-handling"
      ],
      "concepts": [
        "session-failure",
        "activity-cancellation",
        "session-state",
        "heartbeat",
        "error-propagation",
        "session-recovery"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably determine if an activity failure was caused by session failure, making it difficult to implement proper session recovery logic.",
      "rootCause": "Session state information was not exposed to users, forcing them to infer session failures from error types and cancellation states which is unreliable.",
      "proposedFix": "Expose the already-existing session state on SessionInfo to users, ensuring it is properly marked as failed when an activity fails due to session failure.",
      "workaround": "Use a dummy activity approach to reliably detect session failures by checking if ExecuteActivity returns ErrSessionFailed after activity cancellation.",
      "resolution": "fixed",
      "resolutionDetails": "SessionInfo.SessionState was exposed in Go SDK v1.21.0 to allow users to check the session state directly, with a note that session state may be stale up to SessionOptions.HeartbeatTimeout.",
      "related": [],
      "keyQuote": "SessionInfo.SessionState was exposed in the go sdk v1.21.0. Note: Sessions have an inherently stale view of the worker they are running on.",
      "number": 1021,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:48:14.798Z"
    },
    {
      "summary": "Importing the Go SDK causes a 7MB memory spike due to Protobuf type registration in init() clauses. The user inquires if this is expected behavior and whether a lighter SDK variant exists.",
      "category": "bug",
      "subcategory": "memory-footprint",
      "apis": [],
      "components": [
        "protobuf",
        "sdk-initialization",
        "type-registry"
      ],
      "concepts": [
        "memory-usage",
        "import-overhead",
        "protobuf-registration",
        "initialization",
        "performance",
        "startup"
      ],
      "severity": "medium",
      "userImpact": "Users cannot adopt the SDK in memory-constrained environments without significant overhead on application startup.",
      "rootCause": "Protobuf creates a global map of all registered types in init() clauses, consuming approximately 7MB of memory upon import.",
      "proposedFix": null,
      "workaround": "Use the Temporal CLI as a subprocess (though it also uses more than 7MB) or defer SDK inclusion to future releases.",
      "resolution": "wontfix",
      "resolutionDetails": "The user decided to remove Temporal support for their 1.10 release and revisit in 1.11 if improvements are made. The team acknowledged the memory cost is acceptable given the type safety benefits Protobuf provides.",
      "related": [],
      "keyQuote": "The whole reason we lean on Protobuf is to have that type safety at an acceptable cost of a few megs.",
      "number": 1018,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:52.446Z"
    },
    {
      "summary": "Request for a non-memoized version of GetVersion API that can be safely used within long-running loops to enable deterministic workflow code versioning without growing search attributes unboundedly.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "GetVersion"
      ],
      "components": [
        "workflow-engine",
        "versioning",
        "determinism"
      ],
      "concepts": [
        "versioning",
        "long-running-workflows",
        "determinism",
        "replay",
        "code-updates",
        "memoization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot safely update workflow code in long-running loops without complex workarounds that risk search attribute overflow.",
      "rootCause": "The memoized GetVersion API grows unboundedly when called multiple times in a loop with different version keys, making it unsuitable for iterative versioning in long-running workflows.",
      "proposedFix": "Provide a non-memoized version of GetVersion API similar to TypeScript SDK's patching API that can be used safely within loops.",
      "workaround": "Create wrapper function that reuses a single version key until max version is reached, then version per iteration; however this approach is unintuitive and can still fail with large search attributes.",
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of temporalio/features#518, tracked as temporalio/features#591",
      "related": [
        518,
        591
      ],
      "keyQuote": "Provide a non memorized version of the `GetVersion` API that can be used in a loop like the typescript patched API",
      "number": 1016,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:56.643Z"
    },
    {
      "summary": "MutableSideEffect is not deterministic when called multiple times with the same ID in the same WFT (workflow task). The function uses the latest value for replay, causing different behavior between initial execution and replay if the value changes within the same WFT.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "MutableSideEffect",
        "ExecuteActivity"
      ],
      "components": [
        "workflow-engine",
        "mutable-side-effect",
        "history-recording"
      ],
      "concepts": [
        "determinism",
        "workflow-replay",
        "side-effects",
        "state-consistency",
        "workflow-task",
        "history"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely call MutableSideEffect multiple times with the same ID in a single workflow task, as it will behave differently on replay than on initial execution.",
      "rootCause": "The Go SDK records only the nextCommandID and user-defined marker ID for MutableSideEffect, providing insufficient information to distinguish between multiple calls with the same ID in a single WFT. Only the latest value is retained for replay.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Author concluded that fixing this would require writing new information to the history. The issue cannot be resolved without a breaking change to the history format.",
      "related": [
        809
      ],
      "keyQuote": "The Go SDK always uses the latest value of a MutableSideEffect up to the current WFT for each ID so if MutableSideEffect returns a different value in the same WFT the last will be used on replay.",
      "number": 1014,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:54.378Z"
    },
    {
      "summary": "Create a new semantic version tag (v0.1.0) for the workflowcheck tool in contrib/tools to mark a reference point for the workflow checking utility.",
      "category": "feature",
      "subcategory": "tooling",
      "apis": [],
      "components": [
        "workflowcheck",
        "contrib/tools"
      ],
      "concepts": [
        "versioning",
        "tagging",
        "release",
        "tooling",
        "workflow-validation"
      ],
      "severity": "low",
      "userImpact": "Users can reference a stable version of the workflowcheck tool for workflow validation.",
      "rootCause": null,
      "proposedFix": "Create a new tag contrib/tools/workflowcheck/v0.1.0",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The workflowcheck tool was tagged as contrib/tools/workflowcheck/v0.1.0",
      "related": [],
      "keyQuote": "workflowcheck is tagged as contrib/tools/workflowcheck/v0.1.0",
      "number": 1012,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:40.038Z"
    },
    {
      "summary": "WorkflowReplayer.ReplayWorkflowHistory silently fails when the workflow input cannot be deserialized, returning nil instead of an error. This prevents proper compatibility checking during replay since deserialization failures are not reported.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowHistory"
      ],
      "components": [
        "replayer",
        "deserialization",
        "workflow-input"
      ],
      "concepts": [
        "error-handling",
        "deserialization",
        "compatibility-checking",
        "replay-validation"
      ],
      "severity": "high",
      "userImpact": "Users cannot detect deserialization failures when replaying workflows, making it impossible to validate workflow compatibility with different data formats.",
      "rootCause": "The replayer does not properly handle deserialization errors for workflow input during replay, silently skipping the workflow instead of propagating the error.",
      "proposedFix": "The replayer should return an error when workflow input deserialization fails, treating it as a task failure.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in a later version (confirmed working in v1.20.0)",
      "related": [],
      "keyQuote": "Because of this, if there is a de-serialization problem we can't really test compatibility, as the replayer always returns nil.",
      "number": 1011,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:36.984Z"
    },
    {
      "summary": "The Go SDK documentation is missing a proper heading for the 'Async/Manual Activity Completion' section. The text appears as plain text instead of a heading in the rendered documentation due to the slash character preventing implicit heading recognition.",
      "category": "docs",
      "subcategory": "documentation-formatting",
      "apis": [],
      "components": [
        "documentation",
        "activity-doc"
      ],
      "concepts": [
        "documentation-structure",
        "heading-formatting",
        "markdown-rendering",
        "activity-completion",
        "api-documentation"
      ],
      "severity": "low",
      "userImpact": "Users reading the Go SDK documentation are confused by missing section headings, making it difficult to navigate and understand the documentation structure.",
      "rootCause": "The slash character in 'Async/Manual Activity Completion' prevents it from being recognized as an implicit heading in the documentation generator, requiring an explicit heading marker.",
      "proposedFix": "Prefix the line with '# ' to make it an explicit heading in the doc.go file.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by adding explicit heading markup to the documentation.",
      "related": [],
      "keyQuote": "I suspect that the slash disqualifies this text as an implicit heading, and therefore prefixing [that line] with `# ` to make it an explicit heading might fix it.",
      "number": 1010,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:38.727Z"
    },
    {
      "summary": "User unable to execute an activity defined in a Node.js service from a Go workflow. The activity name matched what was expected, but the execution failed until the user passed the activity name as a string.",
      "category": "question",
      "subcategory": "cross-service-activity",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "workflow",
        "activity-executor",
        "cross-service-communication"
      ],
      "concepts": [
        "activity-invocation",
        "service-integration",
        "activity-naming",
        "inter-service-calls"
      ],
      "severity": "low",
      "userImpact": "Users attempting to call activities across different services may encounter execution failures if they don't use string-based activity names.",
      "rootCause": "Activity invocation across services requires passing the activity name as a string rather than a function reference or different naming convention.",
      "proposedFix": "Use string-based activity name when calling ExecuteActivity: workflow.ExecuteActivity(ctx, \"nodeActivity\").Get(ctx, nil)",
      "workaround": "Pass the activity name as a string literal to ExecuteActivity instead of other invocation methods.",
      "resolution": "fixed",
      "resolutionDetails": "User resolved the issue by passing the activity name as a string to ExecuteActivity.",
      "related": [],
      "keyQuote": "This issue got resolved by just passing the activity name. err := workflow.ExecuteActivity(ctx, \"nodeActivity\").Get(ctx, nil)",
      "number": 1008,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:22.530Z"
    },
    {
      "summary": "Context deadline and cancellation errors are wrapped in gRPC status errors by the Go SDK client, breaking standard context error checking patterns. Users must check gRPC error codes instead of using errors.Is() with context.DeadlineExceeded or context.Canceled.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [
        "GetWorkflow",
        "Get"
      ],
      "components": [
        "client",
        "context-handling",
        "error-wrapping",
        "grpc-integration"
      ],
      "concepts": [
        "context-cancellation",
        "timeout",
        "deadline-exceeded",
        "error-handling",
        "grpc-errors",
        "protocol-abstraction"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot reliably detect context timeouts and cancellations using standard Go patterns, requiring them to understand gRPC error details.",
      "rootCause": "gRPC relays context deadlines server-side and returns gRPC status errors instead of native context errors, breaking the abstraction between protocol and SDK API.",
      "proposedFix": null,
      "workaround": "Use uber-go/multierr to combine the original gRPC error with a proper context.DeadlineExceeded error.",
      "resolution": "wontfix",
      "resolutionDetails": "Returning gRPC errors is part of the SDK's API contract; changing this would break existing users who rely on gRPC error handling.",
      "related": [],
      "keyQuote": "returning gRPC errors is part of our API contract, and we have no plans to break existing error handling",
      "number": 1007,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:20.972Z"
    },
    {
      "summary": "Setting MaxConcurrentWorkflowTaskExecutionSize to 1 causes the worker to not execute any tasks. The root cause is that the number of workflow task pollers is limited by this setting, preventing the worker from picking up work when set below the minimum required pollers.",
      "category": "bug",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "worker",
        "workflow-task-poller",
        "configuration"
      ],
      "concepts": [
        "concurrency",
        "task-polling",
        "worker-configuration",
        "task-execution",
        "load-balancing"
      ],
      "severity": "high",
      "userImpact": "Users setting MaxConcurrentWorkflowTaskExecutionSize to 1 find their worker unable to execute any tasks, completely blocking workflow execution.",
      "rootCause": "The MaxConcurrentWorkflowTaskExecutionSize setting is used to limit the number of workflow task pollers, but it must be at least equal to MaxConcurrentWorkflowTaskPollers for the worker to function. Setting it to 1 means only 1 poller starts, which only polls on the sticky queue and never picks up work.",
      "proposedFix": "Enforce that MaxConcurrentWorkflowTaskExecutionSize must be greater than or equal to MaxConcurrentWorkflowTaskPollers, and document this invariant (currently only documented for Java SDK, but applies to Go SDK as well).",
      "workaround": "Set MaxConcurrentWorkflowTaskExecutionSize to at least 2 instead of 1.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by enforcing the minimum value and documenting the invariant across SDKs.",
      "related": [],
      "keyQuote": "MaxConcurrentWorkflowTaskExecutionSize should never be less than MaxConcurrentWorkflowTaskPollers",
      "number": 1003,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:24.406Z"
    },
    {
      "summary": "Workflow commands (e.g., Sleep) produced inside side-effect or query handler functions cause replay issues because these functions aren't called during replay, preventing command generation. Need a panic with clear error message to catch this mistake early.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "SideEffect",
        "Sleep"
      ],
      "components": [
        "workflow-engine",
        "replay-system",
        "side-effect-handler",
        "query-handler"
      ],
      "concepts": [
        "replay",
        "command-generation",
        "side-effects",
        "queries",
        "determinism",
        "error-detection"
      ],
      "severity": "high",
      "userImpact": "Users can write code that appears valid but silently fails during workflow replay, leading to incorrect behavior and hard-to-debug issues.",
      "rootCause": "Side-effect and query handler functions are not re-executed during replay, so any workflow commands produced within them are not regenerated, breaking the deterministic replay contract.",
      "proposedFix": "Add panic with clear error message when workflow commands are detected being produced within side-effect or query handler functions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation added panic detection for commands produced in side-effect and query handler contexts.",
      "related": [],
      "keyQuote": "The snippet below looks like valid code but will cause replay issues since the side effect function is not called on replay",
      "number": 1000,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:07.928Z"
    },
    {
      "summary": "Request to support dynamic query and update handlers in the Go SDK that act as fallbacks when no specific handler matches. These handlers should accept a handler name string and encoded values array.",
      "category": "feature",
      "subcategory": "query-update-handlers",
      "apis": [
        "QueryHandler",
        "UpdateHandler"
      ],
      "components": [
        "workflow-execution",
        "handler-registry",
        "query-system",
        "update-system"
      ],
      "concepts": [
        "dynamic-routing",
        "handler-fallback",
        "flexible-api",
        "encoded-values",
        "extensibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot implement generic or dynamic query/update handlers that work with arbitrary handler names without pre-registering each one.",
      "rootCause": null,
      "proposedFix": "Add support for a dynamic query or update handler that accepts (string name, []converter.EncodedValue) and is invoked when no other handler matches",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Need to allow a dynamic query or update handler that is called when no other query or update handler is found",
      "number": 997,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:02.551Z"
    },
    {
      "summary": "Add an opt-in worker option to control whether the __stack_trace query response uses custom data conversion. Currently the stack trace query response is not converted, but this feature allows users to enable data conversion for stack trace queries if needed.",
      "category": "feature",
      "subcategory": "stack-trace-query",
      "apis": [],
      "components": [
        "worker",
        "query-handler",
        "data-converter"
      ],
      "concepts": [
        "stack-trace",
        "data-conversion",
        "query-response",
        "worker-option",
        "encoding"
      ],
      "severity": "low",
      "userImpact": "Users gain the option to control whether stack trace query responses are encoded using their custom data converter, enabling more consistent data handling across different query types.",
      "rootCause": null,
      "proposedFix": "Introduce a new worker option `StackTraceQueryUsesConverter bool` to opt-in to having the stack trace query use the custom data converter for encoding/conversion.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Make a new worker option like `StackTraceQueryUsesConverter bool`. If false, the `__stack_trace` query response should not be converted/encoded/etc, but if `true` it should be.",
      "number": 996,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:47:03.535Z"
    },
    {
      "summary": "The gRPC interceptor automatically retries ResourceExhausted errors, but messages larger than the server's 4MB limit should fail immediately rather than retry. Need to prevent retry of grpc-message-size-too-large errors while still retrying other ResourceExhausted cases.",
      "category": "bug",
      "subcategory": "grpc-error-handling",
      "apis": [],
      "components": [
        "grpc-interceptor",
        "retry-logic",
        "message-serialization"
      ],
      "concepts": [
        "retry",
        "error-handling",
        "grpc",
        "message-size",
        "resource-exhaustion"
      ],
      "severity": "medium",
      "userImpact": "Oversized workflow task completions cause implicit retries instead of failing workflow tasks, leading to delayed failure visibility and potential retry storms.",
      "rootCause": "The gRPC interceptor treats all ResourceExhausted errors uniformly and retries them, but grpc-message-size-too-large errors are unrecoverable and should not be retried.",
      "proposedFix": "Distinguish grpc-message-size-too-large errors from other ResourceExhausted errors and skip retry logic for this specific case. May require message string checking or changing error type before retry interceptor processes it.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented logic to detect and skip retry for grpc-message-size-too-large errors while preserving retry behavior for other ResourceExhausted errors.",
      "related": [
        466,
        624
      ],
      "keyQuote": "We need to stop retrying this one in particular but still retry others. If we can prevent it from going over the wire without pre-calculating the size that would be best.",
      "number": 995,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:46:44.384Z"
    },
    {
      "summary": "The Go SDK replayer cannot accept a custom workflow ID, causing child workflows with IDs derived from the parent's ID to fail during replay with non-determinism errors. The issue requests a way to set the workflow ID when replaying a history.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "Replayer",
        "StartChildWorkflowOptions"
      ],
      "components": [
        "replayer",
        "workflow-execution",
        "command-state-machine"
      ],
      "concepts": [
        "workflow-id",
        "replay",
        "determinism",
        "child-workflows",
        "history-replay",
        "test-framework"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows with dynamically derived child workflow IDs encounter false non-determinism errors during CI replay testing.",
      "rootCause": "The replayer uses 'ReplayId' as the workflow ID instead of accepting a custom execution ID from the history, causing child workflow ID derivations based on the parent ID to produce different values during replay.",
      "proposedFix": "Allow providing a custom execution ID (derived from recorded history filename) when replaying a history, as other Temporal SDKs support.",
      "workaround": "Record the workflow execution ID in a side-effect to make child workflow ID derivation deterministic.",
      "resolution": "fixed",
      "resolutionDetails": "The Go SDK was enhanced to support setting the workflow ID on the replayer, addressing the core issue.",
      "related": [],
      "keyQuote": "Unlike our other SDKs, the Go SDK does not offer a way to set the workflow ID on the replayer.",
      "number": 994,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:46:41.882Z"
    },
    {
      "summary": "The QueryWorkflowWithOptions method bypasses the client interceptor, while the non-options form goes through it. The interceptor should wrap all query calls, including the options variant.",
      "category": "bug",
      "subcategory": "interceptor",
      "apis": [
        "QueryWorkflowWithOptions",
        "QueryWorkflow"
      ],
      "components": [
        "client",
        "interceptor",
        "query"
      ],
      "concepts": [
        "interceptor",
        "method-dispatch",
        "query-execution",
        "options-pattern",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers using QueryWorkflowWithOptions bypass custom interceptor logic, breaking observability and middleware functionality.",
      "rootCause": "QueryWorkflowWithOptions calls the non-intercepted form instead of having the interceptor wrap both variants",
      "proposedFix": "Route QueryWorkflowWithOptions through the interceptor, with error handling to convert query rejected errors appropriately",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "QueryWorkflowWithOptions now goes through the interceptor chain like the non-options form",
      "related": [],
      "keyQuote": "The client interceptor for queries should intercept all query calls, not just the non-options form.",
      "number": 991,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:46:40.017Z"
    },
    {
      "summary": "AwaitWithTimeout does not cancel its timer when the condition is satisfied, causing unnecessary workflow tasks to be created and waking idle workflows. The issue requests a compatible way to cancel these timers, potentially using SDK version markers to enable future-only fixes.",
      "category": "bug",
      "subcategory": "timer-cancellation",
      "apis": [
        "AwaitWithTimeout",
        "ReceiveWithTimeout"
      ],
      "components": [
        "workflow-engine",
        "timer-manager",
        "signal-handling"
      ],
      "concepts": [
        "timer-cancellation",
        "workflow-task-optimization",
        "resource-efficiency",
        "idle-workflows",
        "LRU-cache",
        "signal-handling"
      ],
      "severity": "medium",
      "userImpact": "Idle workflows are unnecessarily woken up to process erroneous timer tasks, impacting performance and resource utilization.",
      "rootCause": "AwaitWithTimeout does not cancel timers after the condition is satisfied, allowing the timer to fire and create unnecessary workflow tasks.",
      "proposedFix": "Implement SDK version markers on the first workflow task completion to enable backward-compatible fixes for timer cancellation in future SDK versions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1125
      ],
      "keyQuote": "An otherwise idle workflow is now woken up to run. It'll be put to the top of LRU cache, replay itself, etc.",
      "number": 986,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:46:16.045Z"
    },
    {
      "summary": "User reports that WorkflowRunTimeout doesn't throw an error or allow cleanup via defer function when the timeout is reached. The workflow simply terminates without entering the defer block, making it difficult to detect timeouts or send alerts.",
      "category": "question",
      "subcategory": "workflow-timeout",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflowOptions"
      ],
      "components": [
        "workflow-execution",
        "timeout-handling",
        "context-management"
      ],
      "concepts": [
        "timeout",
        "deadline",
        "cleanup",
        "error-handling",
        "workflow-termination",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably detect workflow timeouts or perform cleanup logic, making it difficult to implement alerting and monitoring for long-running workflows with hard deadlines.",
      "rootCause": "WorkflowRunTimeout is designed to hard-terminate workflow execution without running additional workflow tasks, so defer blocks and other cleanup logic are never executed.",
      "proposedFix": "Use a parent workflow to supervise child workflows and react to completion/failure, or implement a timer at workflow start that cancels the workflow when it expires to allow cleanup logic.",
      "workaround": "Implement a parent workflow pattern to supervise child workflows, or use workflow.NewTimer to create a timeout timer that allows cleanup when triggered.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers clarified this is intended behavior - WorkflowRunTimeout is a hard deadline that terminates execution. Business logic should not depend on timeout handling; alternatives like parent workflows or timers are recommended.",
      "related": [],
      "keyQuote": "Per our documentation on WorkflowRunTimeout it will terminate the workflow execution so no other workflow tasks should be run. We don't recommend putting any business logic on workflow timeouts.",
      "number": 984,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:46:21.236Z"
    },
    {
      "summary": "Local activities in workflows don't properly trigger nondeterminism errors during replay when local activity calls are added or removed. The workflow execution commands are missing from replay history, causing a mismatch between real and replay event sequences.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "internal_task_handlers",
        "workflow_replayer",
        "history_processor"
      ],
      "concepts": [
        "determinism",
        "replay",
        "local-activities",
        "history-mismatch",
        "event-ordering"
      ],
      "severity": "high",
      "userImpact": "Users cannot rely on nondeterminism detection when modifying local activity calls in workflows, which can lead to silent failures during replay validation.",
      "rootCause": "Workflow execution commands are not added to replay history when the workflow returns, causing a mismatch between respondEvents and replayEvents. The break statements on workflow complete skip adding WorkflowExecution events to the history.",
      "proposedFix": "Remove the break statements on workflow complete to ensure WorkflowExecution events are properly added to both respondEvents and replayEvents, allowing the replayer to catch nondeterminism errors.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by ensuring workflow execution commands are properly included in replay history for nondeterminism detection.",
      "related": [
        876
      ],
      "keyQuote": "the replay does not error when adding or removing local activity calls, causing false negatives in nondeterminism detection",
      "number": 983,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:46:18.560Z"
    },
    {
      "summary": "Mock activities cannot be registered with string names in test workflow environments without first registering them. The library requires activities to be registered before mocking, which is cumbersome for testing workflows with cross-language activities that lack Go function counterparts.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "OnActivity",
        "RegisterActivity",
        "RegisterActivityWithOptions"
      ],
      "components": [
        "workflow_testsuite",
        "test-framework",
        "activity-mock",
        "local-activities"
      ],
      "concepts": [
        "mocking",
        "testing",
        "activity-registration",
        "cross-language-workflows",
        "test-setup"
      ],
      "severity": "medium",
      "userImpact": "Developers struggle to test workflows with cross-language activities and must create dummy functions to satisfy registration requirements before mocking.",
      "rootCause": "Local activities validate argument types at registration time rather than at dispatch time, making the registration check unnecessarily restrictive for mocking scenarios.",
      "proposedFix": "Drop the registration assertion for mock activities since OnActivity overrides the original function behavior entirely, making prior registration unnecessary.",
      "workaround": "Register a dummy function with the proper argument types before calling OnActivity, or use RegisterActivity with RegisterOptions.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Could this assertion be dropped? It feels quite unnecessary.",
      "number": 982,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:57.513Z"
    },
    {
      "summary": "workflowcheck tool incorrectly flags fmt.Errorf, fmt.Sprintf and similar functions as non-deterministic, even though they are deterministic enough for workflow use. This causes errors in recent Go versions (1.19+) and blocks Go version updates on CI pipelines.",
      "category": "bug",
      "subcategory": "workflowcheck",
      "apis": [],
      "components": [
        "workflowcheck",
        "determinism-checker"
      ],
      "concepts": [
        "determinism-analysis",
        "reflection",
        "fmt-package",
        "static-analysis",
        "go-version-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot update to newer Go versions (1.19+) when their workflows use common functions like fmt.Errorf due to false positive determinism violations.",
      "rootCause": "workflowcheck incorrectly marks fmt and reflect functions as non-deterministic due to deep call chains into runtime functions; the tool needs explicit whitelist or different analysis approach for stdlib formatting functions.",
      "proposedFix": "Explicitly mark fmt.Errorf, fmt.Sprintf and similar functions as deterministic, and consider reducing call-chain depth analysis to avoid reporting deep runtime implementation details.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This appears to happen more in recent version of golang 1.19 and 1.20 and is blocking updating the golang version on some pipelines.",
      "number": 980,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:57.283Z"
    },
    {
      "summary": "Workflow replay fails inconsistently across Go versions due to protojson serialization adding random whitespace, causing byte-level payload comparisons to fail even when semantic content is identical.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replayer",
        "payload-serialization",
        "data-converter",
        "protojson-encoding"
      ],
      "concepts": [
        "determinism",
        "serialization",
        "replay-validation",
        "version-compatibility",
        "proto-encoding"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably use workflow replay for regression testing and backwards compatibility validation across different Go versions.",
      "rootCause": "protojson encoder randomly prepends whitespace before fields in multiline output, behavior dependent on Go version; replayer performs byte-level comparison of marshalled payloads instead of semantic comparison.",
      "proposedFix": "Remove or make optional the strict payload comparison in replay validation, or allow custom result equality checking for workflow outcomes.",
      "workaround": "Create custom data converter to ensure consistent payload encoding regardless of Go version.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved as part of PR #990 which removed strict payload comparison mode.",
      "related": [
        990
      ],
      "keyQuote": "Replays can fail once the Go version changes due to random whitespace in protojson serialization, though results are semantically identical.",
      "number": 978,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:46:01.168Z"
    },
    {
      "summary": "Test framework doesn't fail when mock invocations are missing or incorrect, causing tests to pass despite uncaught PanicErrors in activity execution. Developers need a way to detect missing mocks to catch configuration errors early.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "test-environment",
        "mock-framework",
        "workflow-test-env"
      ],
      "concepts": [
        "mock-validation",
        "activity-invocation",
        "test-assertions",
        "error-detection",
        "test-failure"
      ],
      "severity": "high",
      "userImpact": "Tests incorrectly pass when activity mocks are forgotten, allowing invalid test configurations to ship undetected.",
      "rootCause": "The test framework detects mock invocation discrepancies but does not propagate these as test failures, treating missing mocks the same as intentional error handling.",
      "proposedFix": "Mark tests as FAILED when mock invocation assertions fail, or expose the env.mock field to allow manual verification of mock calls.",
      "workaround": "Manually check workflow errors using env.GetWorkflowError() and assert no errors occurred, though this doesn't catch missing mocks.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        642
      ],
      "keyQuote": "There is a difference between an activity failing in prod for a legitimate reason and activity failing due to a forgotten mock invocation.",
      "number": 975,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:38.554Z"
    },
    {
      "summary": "Request to implement a programmatic list API with history iterator support in the Go SDK to align with the Java SDK's API design. The discussion identifies a broader need to reconsider the Go client API architecture rather than continue adding features incrementally.",
      "category": "feature",
      "subcategory": "client-api",
      "apis": [
        "ListWorkflows",
        "DescribeWorkflow",
        "DescribeWorkflowExecution",
        "ListWorkflowsOptions",
        "WorkflowExecutionIterator",
        "HistoryEventIterator",
        "WorkflowHistory"
      ],
      "components": [
        "client",
        "list-workflows",
        "history-iterator",
        "workflow-execution"
      ],
      "concepts": [
        "api-design",
        "iterator-pattern",
        "workflow-listing",
        "history-replay",
        "backward-compatibility",
        "api-deprecation"
      ],
      "severity": "medium",
      "userImpact": "Users need a programmatic way to list workflows and iterate over execution histories for workflow replay, following Java SDK patterns.",
      "rootCause": "Go SDK lacks the comprehensive workflow listing and history iteration APIs present in the Java SDK, and the broader client API interface needs architectural reconsideration.",
      "proposedFix": "Implement ListWorkflows API accepting ListWorkflowsOptions with Query parameter, returning WorkflowExecutionIterator; add WorkflowExecution, WorkflowExecutionDescription, and WorkflowHistory wrappers; add HistoryEventIterator; support WorkflowHistory in worker.WorkflowReplayer; consider deprecating existing List*Workflow and DescribeWorkflowExecution APIs.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed pending broader discussion about the future direction of the Go client API and which components should be prioritized.",
      "related": [
        1552
      ],
      "keyQuote": "There are a lot of things wrong with the client interface, and just bolting more things on it may not be the solution.",
      "number": 972,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:37.746Z"
    },
    {
      "summary": "Move proxy and interceptor code generation from sdk-go to api-go as a standalone tool package. This reduces API dependencies in the SDK and enables future-proofing for new API packages.",
      "category": "feature",
      "subcategory": "code-generation",
      "apis": [],
      "components": [
        "code-generation",
        "proxy",
        "interceptor",
        "api-go"
      ],
      "concepts": [
        "code-generation",
        "proxy-pattern",
        "interceptor-pattern",
        "payload-handling",
        "grpc",
        "modularity",
        "api-dependencies"
      ],
      "severity": "medium",
      "userImpact": "Reduces SDK dependencies on api-go and provides a reusable code generation tool for proxy and interceptor patterns.",
      "rootCause": "SDK currently relies on every API message through proxy and interceptor code generation, creating unnecessary coupling.",
      "proposedFix": "Create cmd/generateproxy binary in api-go that generates proxy and interceptor code, with separate go.mod to avoid forcing dependencies. Tool should generate go.temporal.io/api/proxy package with WorkflowServiceProxyServer and PayloadVisitorInterceptor.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented - proxy and interceptor code generation was moved to api-go as a standalone tool.",
      "related": [],
      "keyQuote": "We need to move the code gen for proxy and interceptor to https://github.com/temporalio/api-go.",
      "number": 971,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:41.514Z"
    },
    {
      "summary": "Search attributes and memos are kept from previous workflow runs when the workflow context is reset due to cache staleness, causing non-determinism errors. The mutation state should be cleared when the context is reset, but currently persists.",
      "category": "bug",
      "subcategory": "workflow-context-reset",
      "apis": [
        "ExecuteWorkflow",
        "SignalWorkflow",
        "UpsertSearchAttributes",
        "GetInfo",
        "GetSignalChannel"
      ],
      "components": [
        "workflow-context",
        "search-attributes",
        "memos",
        "cache",
        "worker"
      ],
      "concepts": [
        "cache-staleness",
        "non-determinism",
        "state-reset",
        "mutable-state",
        "workflow-replay",
        "search-attributes",
        "memos"
      ],
      "severity": "high",
      "userImpact": "Workflows fail with non-determinism errors when cache resets occur and search attributes or memos have been mutated, breaking workflow execution reliability.",
      "rootCause": "When workflow context is reset due to cache staleness, the mutable search attributes map and memo map are not being cleared, retaining state from previous workflow runs.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was fixed by ensuring search attributes and memos are reset when workflow context is reset due to cache staleness.",
      "related": [],
      "keyQuote": "When a workflow's context is reset due to cache staleness, the mutated search attribute map remains (and I presume memo too)",
      "number": 970,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:22.038Z"
    },
    {
      "summary": "Request to display stack traces of deadlocking coroutines in Go SDK workflows. When deadlock detection triggers, users only see the stack of the timed-out coroutine, not the blocked workflow coroutines that caused the deadlock.",
      "category": "feature",
      "subcategory": "deadlock-detection",
      "apis": [
        "workflow.Go"
      ],
      "components": [
        "deadlock-detector",
        "runtime-stack-trace",
        "coroutine-tracking"
      ],
      "concepts": [
        "deadlock",
        "stack-trace",
        "goroutine",
        "coroutine-debugging",
        "runtime-introspection",
        "timeout-detection"
      ],
      "severity": "medium",
      "userImpact": "Users have difficulty diagnosing workflow deadlocks because they cannot see the stack traces of blocked coroutines, making troubleshooting complex concurrency issues harder.",
      "rootCause": "Go does not provide direct APIs to identify or introspect specific goroutines by ID, requiring workarounds like stack parsing or internal reflection.",
      "proposedFix": "Track goroutine IDs when workflow.Go is called, then parse runtime.Stack() output to filter and display only the stack traces of running coroutines for the workflow. Can be made opt-in if performance is a concern.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented stack trace collection for deadlocked coroutines. Discussion clarified that only one coroutine can be executing at timeout, simplifying the implementation approach.",
      "related": [],
      "keyQuote": "Allow users to see a stack of all running coroutines of a workflow",
      "number": 969,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:20.020Z"
    },
    {
      "summary": "Remove two deprecated metrics `local_activity_canceled` and `local_activity_failed` that have been replaced by newer versions. The maintainer expressed concerns about the silent nature of this removal and indicated it's unlikely to be prioritized.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "local-activity"
      ],
      "concepts": [
        "deprecation",
        "backward-compatibility",
        "metrics-removal",
        "silent-breaking-change"
      ],
      "severity": "low",
      "userImpact": "Users relying on the deprecated metrics would experience silent metric output removal without compiler errors.",
      "rootCause": null,
      "proposedFix": "Remove the deprecated metrics and update any code referencing them to use the new metric names.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The cost of duplicate metrics is much much lower than the cost of removing them. This would be a silent removal, i.e. that there would be no compiler error to fix.",
      "number": 968,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:17.139Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not complete workflows synchronously when nested workflows are started by activities on new environment instances. The workflow continues executing in a separate goroutine after ExecuteWorkflow returns, requiring manual polling to detect completion.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow",
        "IsWorkflowCompleted"
      ],
      "components": [
        "testsuite",
        "test-workflow-environment",
        "activity-executor"
      ],
      "concepts": [
        "synchronous-execution",
        "nested-workflows",
        "goroutines",
        "workflow-completion",
        "test-harness",
        "timing-issue"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows with nested workflow executions in activities encounter synchronization issues where child workflows complete asynchronously, breaking expected test behavior.",
      "rootCause": "When activities instantiate new TestWorkflowEnvironment instances and execute workflows on them, the workflow completion logic operates asynchronously instead of synchronously as documented.",
      "proposedFix": null,
      "workaround": "Manually poll IsWorkflowCompleted() in a loop to wait for the workflow to complete before continuing.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "One of the nested test workflows that is started by an activity on a new testsuite.TestWorkflowEnvironment exits its ExecuteWorkflow call before testEnvironment.WorkflowIsCompleted() returns true.",
      "number": 967,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:05.059Z"
    },
    {
      "summary": "User requested exporting the asyncFuture interface to enable wrapping workflow futures with custom validation logic. The SDK's internal type assertion prevented wrapped futures from being used with selectors, but the maintainer suggested using composition with a custom interface instead.",
      "category": "feature",
      "subcategory": "workflow-future",
      "apis": [
        "Future",
        "Selector",
        "NewFuture"
      ],
      "components": [
        "workflow",
        "future",
        "selector"
      ],
      "concepts": [
        "composition",
        "interface-wrapping",
        "validation",
        "type-assertion",
        "future-chaining"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily wrap workflow futures with custom validation logic due to SDK's internal type checking in selectors.",
      "rootCause": "The SDK performs a type assertion check for the internal asyncFuture interface when futures are passed to selectors, preventing user-created wrapper implementations.",
      "proposedFix": "Export the asyncFuture interface to allow users to implement it in their wrapper types.",
      "workaround": "Create a custom wrapper interface and provide a helper method to unwrap the future when passing to selectors, allowing composition without matching the Temporal interface.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer rejected exporting asyncFuture, explaining that internal futures passed to helpers must be unwrapped. Users should use composition with custom types instead of implementing the Temporal interface.",
      "related": [],
      "keyQuote": "Futures passed back into helpers like selector are meant to be the unwrapped future that was created by Temporal. Since you're already wrapping, there's no reason to reuse the Temporal interface, use your own type.",
      "number": 964,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:01.147Z"
    },
    {
      "summary": "workflowcheck static analyzer cannot detect workflow function types when registered via a map with `any` value type, requiring manual workarounds. Feature request to allow users to opt-out of this registration-time analysis for dynamic registration patterns.",
      "category": "feature",
      "subcategory": "static-analysis",
      "apis": [
        "RegisterWorkflowWithOptions"
      ],
      "components": [
        "workflowcheck",
        "static-analyzer",
        "workflow-registration"
      ],
      "concepts": [
        "static-analysis",
        "type-inference",
        "dynamic-registration",
        "compiler-errors",
        "workflow-validation"
      ],
      "severity": "low",
      "userImpact": "Developers using dynamic workflow registration with `any` type maps cannot use workflowcheck static analysis without refactoring their registration code.",
      "rootCause": "Go static analyzer cannot determine runtime types of map values typed as `any`, limiting what workflowcheck can validate at compile time.",
      "proposedFix": "Provide a mechanism to allow users to ignore workflowcheck errors for dynamic registration patterns, or use type markers to enable static analysis of `any`-typed values.",
      "workaround": "Avoid converting functions to `any` type in the map; instead keep compile-time type information by registering workflows in a separate statement after retrieving them from the map.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We should let people ignore the workflowcheck registration-time analysis if the registration code is too dynamic for static analysis to discover.",
      "number": 962,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:45:03.123Z"
    },
    {
      "summary": "Workflow loggers use different stack depths than activity loggers due to an extra wrapping layer in the workflow logger, making it impossible to use a shared caller-skip configuration with logging frameworks like Zap or Zerolog.",
      "category": "bug",
      "subcategory": "logging-stack-depth",
      "apis": [
        "GetLogger",
        "ExecuteActivity"
      ],
      "components": [
        "workflow-logger",
        "activity-logger",
        "logger-wrapper"
      ],
      "concepts": [
        "stack-depth",
        "caller-skip",
        "logging-framework",
        "replay-safety",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure a single caller-skip value that works consistently for both workflow and activity logging when using frameworks that auto-detect stack depth.",
      "rootCause": "The workflow logger is wrapped in a replay-safe version that adds an extra stack frame, while activity loggers are not similarly wrapped, creating an asymmetry in call stack depth.",
      "proposedFix": "Implement a `WithCallerSkip` interface that loggers can implement to allow the SDK to adjust caller skip depth dynamically, maintaining backwards compatibility.",
      "workaround": "Adjust caller skip count differently for workflows vs activities in the logging framework configuration.",
      "resolution": "fixed",
      "resolutionDetails": "A WithCallerSkip interface was implemented allowing loggers to adjust caller skip depth dynamically without breaking backwards compatibility.",
      "related": [],
      "keyQuote": "The same log statements in workflow and activity should be at the same stack depth so that a shared caller-skip can work for both.",
      "number": 960,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:48.340Z"
    },
    {
      "summary": "ScheduleAction interface type matching is confusing because both ScheduleWorkflowAction and *ScheduleWorkflowAction can be assigned, but only the pointer version works at runtime. The receiver should be changed to require pointers exclusively.",
      "category": "bug",
      "subcategory": "api-design",
      "apis": [
        "ScheduleAction",
        "ScheduleWorkflowAction"
      ],
      "components": [
        "schedule-client",
        "type-system"
      ],
      "concepts": [
        "interface-matching",
        "receiver-semantics",
        "type-safety",
        "pointer-semantics"
      ],
      "severity": "medium",
      "userImpact": "Developers can assign non-pointer ScheduleWorkflowAction to ScheduleAction, which compiles but fails at runtime, causing confusing errors.",
      "rootCause": "Go receivers that are non-pointers match both pointer and non-pointer types, but the interface is designed to only work with pointers. The receiver definition allows both but only pointer receivers should be valid.",
      "proposedFix": "Change the receiver to `func (*ScheduleWorkflowAction) isScheduleAction()` to require pointers and prevent non-pointer assignments.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed via PR #959 which changed the receiver to pointer-only.",
      "related": [
        959
      ],
      "keyQuote": "ScheduleAction can be set to ScheduleWorkflowAction _or_ *ScheduleWorkflowAction, but the latter fails at runtime.",
      "number": 958,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:46.579Z"
    },
    {
      "summary": "ScheduleOptions.ID documentation claims it's optional with UUID default, but the runtime requires it and throws an error when missing. Additionally, the schedule workflow ID may have a timestamp appended for uniqueness, which wasn't documented.",
      "category": "docs",
      "subcategory": "schedule-options",
      "apis": [
        "ScheduleOptions"
      ],
      "components": [
        "schedule-client",
        "schedule-options",
        "documentation"
      ],
      "concepts": [
        "schedule-id",
        "workflow-id",
        "optional-fields",
        "uuid-generation",
        "timestamp-appending",
        "id-uniqueness",
        "api-consistency"
      ],
      "severity": "medium",
      "userImpact": "Developers are misled by documentation claiming ID is optional, leading to runtime errors and confusion about how schedule IDs relate to workflow IDs.",
      "rootCause": "Documentation was incorrect - the schedule ID is actually required, not optional. Additionally, the behavior of appending timestamps to workflow IDs was undocumented.",
      "proposedFix": "Update documentation to clarify that ID is required and add comment explaining that the schedule workflow ID may have a timestamp appended for uniqueness.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed via PR #959, which updated the documentation and comments to clarify ID is required and that timestamps may be appended.",
      "related": [
        158
      ],
      "keyQuote": "The workflow id of the started workflow may not match this exactly, it may have a timestamp appended for uniqueness.",
      "number": 957,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:47.407Z"
    },
    {
      "summary": "When stopping a worker, a 'worker stopping' error is logged at WARN level during task polling, which is misleading since it's not a real polling failure. The request is to either move this to debug level or suppress it entirely.",
      "category": "other",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "worker",
        "task-poller",
        "logging"
      ],
      "concepts": [
        "shutdown",
        "logging-level",
        "error-suppression",
        "worker-lifecycle"
      ],
      "severity": "low",
      "userImpact": "Users see misleading WARN-level logs when stopping workers, cluttering log output with non-critical messages.",
      "rootCause": "Task polling errors are logged at WARN level even when they occur during graceful worker shutdown, which is expected behavior.",
      "proposedFix": "Move the 'worker stopping' polling error to debug level or suppress it entirely since it occurs during normal shutdown.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        882
      ],
      "keyQuote": "It's not really a poll \"failure\" if the worker is stopping.",
      "number": 955,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:26.484Z"
    },
    {
      "summary": "Remove unnecessary error return from OpenTelemetry tracing interceptor function that always returns nil. The maintainer requests keeping the error return for future API compatibility to avoid breaking changes if error handling is needed later.",
      "category": "other",
      "subcategory": "opentelemetry-tracing",
      "apis": [],
      "components": [
        "opentelemetry",
        "tracing-interceptor"
      ],
      "concepts": [
        "api-design",
        "backwards-compatibility",
        "future-proofing",
        "error-handling"
      ],
      "severity": "low",
      "userImpact": "No user impact; this is an internal API design discussion about whether to remove an unused error return value.",
      "rootCause": null,
      "proposedFix": "Remove the error return from the function signature since it always returns nil",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer decided to keep the error return for future proofing and API stability, declining to remove it.",
      "related": [],
      "keyQuote": "This is for future proofing. We may return an error from it one day, so we need it to be present now so we don't break people later.",
      "number": 954,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:30.265Z"
    },
    {
      "summary": "Eager activity execution should be limited to 3 per workflow task completion by default, not through a global MaxConcurrentActivityExecutionSize setting. The options MaxConcurrentActivityExecutionSize and DisableEagerActivities should be removed to align with other SDKs and simplify the API.",
      "category": "bug",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "eager-activities"
      ],
      "concepts": [
        "concurrency-limiting",
        "activity-throttling",
        "workflow-task-completion",
        "eager-execution"
      ],
      "severity": "medium",
      "userImpact": "Users may experience unexpected worker overload or behavior inconsistency if eager activities are not properly throttled at the per-workflow-task level rather than globally.",
      "rootCause": "MaxConcurrentActivityExecutionSize was set as a default when the actual requirement was to limit eager activities per workflow task completion to 3, not globally across the worker.",
      "proposedFix": "Remove the global MaxConcurrentActivityExecutionSize and DisableEagerActivities options, and hardcode a new setting that limits eager activity requests to 3 per workflow task completion.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Removed global eager activity configuration options and implemented per-workflow-task limiting of 3 eager activities.",
      "related": [
        946
      ],
      "keyQuote": "Instead we should have set the max number of eager activities requested per workflow task completion to 3.",
      "number": 950,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:29.599Z"
    },
    {
      "summary": "Test suite has a hidden default of 10 maximum activity attempts that users cannot override. Users should be able to configure this default instead of being forced to accept it or modify their workflow code.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "activity-executor",
        "workflow-runner"
      ],
      "concepts": [
        "retry-policy",
        "activity-attempts",
        "test-configuration",
        "default-values",
        "test-environment-parity",
        "workflow-testing"
      ],
      "severity": "medium",
      "userImpact": "Users must either accept the hidden test default of 10 attempts or modify their workflow code, creating a mismatch between test and production environments.",
      "rootCause": "The test suite hardcodes a default maximum activity attempts value of 10 with no configuration option to override it.",
      "proposedFix": "Add a configuration option to allow users to override the default maximum activity attempts value in the test suite.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A user shouldn't have to be forced to set maximum attempts in their workflow because the test suite has a hidden default.",
      "number": 949,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:11.263Z"
    },
    {
      "summary": "The workflow test suite defaults to a maximum activity attempt of 10, but this behavior was not documented when the feature was implemented in PR #462. This task is to add documentation for this test framework default.",
      "category": "docs",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "activity-executor",
        "workflow-testing"
      ],
      "concepts": [
        "testing",
        "activity-attempts",
        "defaults",
        "documentation",
        "test-configuration"
      ],
      "severity": "low",
      "userImpact": "Users of the workflow test suite may not understand the default maximum activity attempt limit of 10, potentially causing confusion when tests behave unexpectedly.",
      "rootCause": null,
      "proposedFix": "Add documentation explaining that the workflow test suite defaults to a maximum activity attempt of 10.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was added for the workflow test suite's default maximum activity attempt limit of 10.",
      "related": [
        462
      ],
      "keyQuote": "When https://github.com/temporalio/sdk-go/pull/462 was done, no documentation was made. Document this.",
      "number": 948,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:08.691Z"
    },
    {
      "summary": "A panic occurs when attempting to start a child workflow with the same ID as one already running, instead of returning ChildWorkflowExecutionAlreadyStartedError. The issue manifests as 'Error adding duplicate command' in the command state machine.",
      "category": "bug",
      "subcategory": "child-workflow-execution",
      "apis": [
        "ExecuteChildWorkflow",
        "WithChildOptions"
      ],
      "components": [
        "command-state-machine",
        "workflow-environment",
        "child-workflow-executor"
      ],
      "concepts": [
        "duplicate-detection",
        "workflow-id-collision",
        "command-deduplication",
        "panic-recovery",
        "error-handling",
        "workflow-state-management"
      ],
      "severity": "high",
      "userImpact": "Workflow executions crash with a panic instead of gracefully handling duplicate child workflow IDs, making it impossible to recover from this error condition.",
      "rootCause": "The command state machine does not properly check for duplicate child workflow IDs before attempting to add a new command, resulting in an illegal state transition that causes a panic.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved in the SDK; the command state machine now properly validates duplicate child workflow IDs and returns ChildWorkflowExecutionAlreadyStartedError instead of panicking.",
      "related": [],
      "keyQuote": "An attempt to start a child workflow with the same ID as the one already running should result in ChildWorkflowExecutionAlreadyStartedError.",
      "number": 947,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:44:14.956Z"
    },
    {
      "summary": "Dependency security vulnerability in golang.org/x/tools-v0.1.12 containing three jQuery vulnerabilities (CVE-2020-11022, CVE-2015-9251, CVE-2012-6708) with CVSS scores of 6.1 each. Issue was automatically closed and reopened by Mend based on vulnerability inventory status.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "build-tools",
        "golang-tools"
      ],
      "concepts": [
        "vulnerability",
        "security",
        "dependency-upgrade",
        "XSS",
        "jQuery",
        "supply-chain"
      ],
      "severity": "medium",
      "userImpact": "Users may be exposed to cross-site scripting (XSS) vulnerabilities through the vulnerable jQuery versions embedded in golang.org/x/tools dependency.",
      "rootCause": "golang.org/x/tools-v0.1.12 includes vulnerable jQuery versions (1.9.0-3.0.0 range) with XSS vulnerabilities in DOM manipulation methods.",
      "proposedFix": "Upgrade golang.org/x/tools to a version that updates jQuery to 3.5.0 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was removed from the dependency inventory or marked as ignored.",
      "related": [],
      "keyQuote": "This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.",
      "number": 945,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:53.345Z"
    },
    {
      "summary": "SearchAttribute values from DescribeWorkflowExecution are unmarshaled as float64 instead of integer type when using the default converter with interface{}. This is due to JSON's default behavior treating all numbers as float64, and the user must either provide the target type or use a custom converter.",
      "category": "question",
      "subcategory": "search-attributes",
      "apis": [
        "DescribeWorkflowExecution"
      ],
      "components": [
        "converter",
        "data-converter",
        "search-attributes"
      ],
      "concepts": [
        "type-conversion",
        "json-unmarshaling",
        "interface{}",
        "search-attributes",
        "data-serialization"
      ],
      "severity": "low",
      "userImpact": "Users working with integer search attributes must use custom converters or explicitly pass target types to handle type conversion correctly.",
      "rootCause": "Go's default JSON unmarshaling behavior treats all numbers as float64 when unmarshaling to interface{}, and Temporal's default converter doesn't special-case search attributes differently from other payloads.",
      "proposedFix": null,
      "workaround": "Use a custom converter with encoding/json.Decoder.UseNumber or provide the target type explicitly during unmarshaling.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers determined this is intended behavior - search attributes follow the same conversion rules as other payloads, and users should handle type conversion explicitly.",
      "related": [
        228
      ],
      "keyQuote": "It could if we treated search attributes as different than any other integer in the system, but we do not.",
      "number": 942,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:56.767Z"
    },
    {
      "summary": "Implement nightly CI tests against the server master branch to catch SDK-server incompatibilities early. The testing will be performed in the sdk-features repository instead.",
      "category": "feature",
      "subcategory": "ci-testing",
      "apis": [],
      "components": [
        "ci",
        "integration-tests",
        "test-framework"
      ],
      "concepts": [
        "nightly-testing",
        "integration-testing",
        "compatibility",
        "server-version",
        "ci-pipeline"
      ],
      "severity": "medium",
      "userImpact": "Ensures SDK compatibility with latest server versions is caught quickly, reducing incompatibility issues reaching users.",
      "rootCause": null,
      "proposedFix": "Run nightly CI tests in sdk-features repository against server master branch",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Testing moved to sdk-features repository (issue #150) as a more appropriate location for integration testing",
      "related": [
        150
      ],
      "keyQuote": "In order to catch SDK-server incompatibilities ASAP, we should test integration of the latest version of these components.",
      "number": 939,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:54.094Z"
    },
    {
      "summary": "Add support for replaying multiple workflow histories in a loop in the Go SDK, similar to existing functionality in TypeScript and Python SDKs. The team decided this wasn't necessary as a built-in feature since calling ReplayWorkflowHistory in a loop is already performant, but a list API for histories should be added to match other SDKs.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowHistory"
      ],
      "components": [
        "workflow-engine",
        "replay-engine",
        "history-processor"
      ],
      "concepts": [
        "replay",
        "history",
        "workflow-execution",
        "testing",
        "determinism",
        "concurrency"
      ],
      "severity": "low",
      "userImpact": "Users wanting to replay multiple workflow histories would benefit from a consistent list API across all SDKs, though looping manually is already acceptable.",
      "rootCause": null,
      "proposedFix": "Add a list API for histories in the Go SDK following the same pattern as other SDKs, allowing users to list and iterate through workflow histories.",
      "workaround": "Call ReplayWorkflowHistory in a loop, which is already performant and the idiomatic Go approach.",
      "resolution": "wontfix",
      "resolutionDetails": "Determined that multi-history replay as a built-in feature wasn't necessary since looping with ReplayWorkflowHistory is already performant. Scope shifted to adding a list API for histories instead (tracked separately in issue #972).",
      "related": [
        972
      ],
      "keyQuote": "it's easy (and performant) enough to call `ReplayWorkflowHistory` in a loop, so we probably don't need this",
      "number": 938,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:36.465Z"
    },
    {
      "summary": "Session fails when a worker restarts, but for many use cases with cached shared state, the session should survive worker restarts and only fail if the worker is down long-term indicating host failure. Request is for support of durable worker IDs and automatic session re-establishment timeouts.",
      "category": "feature",
      "subcategory": "session-management",
      "apis": [
        "CreateSession",
        "CompleteSession"
      ],
      "components": [
        "worker",
        "session-manager",
        "task-queue"
      ],
      "concepts": [
        "session-persistence",
        "worker-restart",
        "durability",
        "state-caching",
        "fault-tolerance",
        "timeout",
        "retry"
      ],
      "severity": "medium",
      "userImpact": "Users with cached shared state on disk cannot maintain sessions across worker restarts without manual workarounds, limiting fault tolerance and operational flexibility.",
      "rootCause": "Current session implementation terminates sessions immediately when the owning worker restarts, without distinguishing between temporary restarts (e.g., version updates) and permanent failures.",
      "proposedFix": "Support special durable worker IDs that persist across restarts and introduce a timeout mechanism for automatic session re-establishment after worker restarts.",
      "workaround": "Create per-worker task queues and assign consistent task queue across restarts, or use a combination of sessions with per-worker task queues that allow workflow retry logic to select healthy workers.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "For many use cases, a restart of a worker is not a problem as the shared state is cached on the host disk, and the session should continue as if nothing happened.",
      "number": 937,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:38.819Z"
    },
    {
      "summary": "Users cannot unit test workflows with a populated ContinuedExecutionRunID field, which prevents testing all workflow paths. A request to expose or set this value during test execution.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "GetInfo",
        "ContinuedExecutionRunID"
      ],
      "components": [
        "test-workflow-environment",
        "workflow-context",
        "workflow-info"
      ],
      "concepts": [
        "testing",
        "workflow-continuation",
        "unit-testing",
        "context-setup",
        "test-coverage",
        "mocking"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot fully test workflows that use ContinuedExecutionRunID, resulting in incomplete test coverage.",
      "rootCause": "TestWorkflowEnvironment does not expose a way to set or populate the ContinuedExecutionRunID field in workflow context.",
      "proposedFix": "Expose the mutable WorkflowInfo pointer via TestWorkflowEnvironment.WorkflowInfo() method to allow setting context values during test execution.",
      "workaround": "Use elaborate workarounds like dependency injection or variables to fake the ContinuedExecutionRunID value in tests.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently, one cannot do that so not all workflow paths may be unit tested.",
      "number": 935,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:38.890Z"
    },
    {
      "summary": "When a workflow query fails due to deserialization errors in the workflow input payload, there are no log messages or error indicators to help diagnose the problem. Users see missing query results in the UI without understanding why.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "dispatcher",
        "history-replay",
        "deserialization"
      ],
      "concepts": [
        "error-logging",
        "workflow-state",
        "input-deserialization",
        "diagnostics",
        "replay",
        "query-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot diagnose why workflow queries fail or why stacktraces are unavailable, making it difficult to troubleshoot deserialization issues.",
      "rootCause": "From the dispatcher perspective, deserialization failures are indistinguishable from normal workflow termination with errors, making it unclear when to log the failure.",
      "proposedFix": "Log errors when workflow enters error state after replaying just the StartWorkflow event, as that indicates deserialization failure.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        932
      ],
      "keyQuote": "The problem is from the dispatcher startup perspective, these errors are indistinguishable from normal termination with workflow error.",
      "number": 933,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:23.146Z"
    },
    {
      "summary": "Add support for failure encoding in proxy gRPC interceptor by moving message and stack trace into encoded attributes, allowing proxies to transparently support encoded failure attributes through the interceptor.",
      "category": "feature",
      "subcategory": "grpc-interceptor",
      "apis": [],
      "components": [
        "grpc-interceptor",
        "payload-codec",
        "failure-encoding"
      ],
      "concepts": [
        "failure-encoding",
        "message-encoding",
        "stack-trace",
        "encoded-attributes",
        "proxy-support",
        "grpc-proxy"
      ],
      "severity": "medium",
      "userImpact": "Proxies using the gRPC interceptor can now transparently support encoded failure attributes in a way that's understandable in the UI.",
      "rootCause": null,
      "proposedFix": "Alter generateinterceptor/main.go to add EncodeCommonAttributes bool flag to PayloadCodecGRPCClientInterceptorOptions, moving message and stack trace to encoded attributes pre-encode and back out post-decode.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as converter.NewFailureGRPCClientInterceptor in PR #974",
      "related": [
        924,
        974
      ],
      "keyQuote": "move the message and stack trace to the encoded attributes pre-encode (and back out post-decode). This will allow proxies using this interceptor to support encoded failure attributes transparently",
      "number": 930,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:19.552Z"
    },
    {
      "summary": "Request for a custom time source in workflows to enable testing time-dependent behavior. User needs to simulate workflow execution over dynamically sized time spans using a fake clock that controls workflow.Now() and workflow.Sleep().",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "Now",
        "Sleep"
      ],
      "components": [
        "workflow-runtime",
        "time-source",
        "test-suite"
      ],
      "concepts": [
        "time-simulation",
        "testing",
        "mocking",
        "scheduling",
        "time-control"
      ],
      "severity": "low",
      "userImpact": "Users testing time-dependent workflows cannot easily simulate fast-forwarding through long time periods without the ability to control the clock.",
      "rootCause": null,
      "proposedFix": "Allow configuration of a custom time source (fake clock) that controls workflow.Now() and workflow.Sleep() behavior in tests.",
      "workaround": "Use RegisterDelayedCallback in the test suite to control execution timing at specific points in workflow execution.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue closed as the existing test suite with RegisterDelayedCallback provides sufficient time control for testing purposes. Custom time sources in non-test environments are unreasonable due to server-side timeouts and other system dependencies.",
      "related": [],
      "keyQuote": "controlling time in a non-test-environment workflow is unreasonable as many internal things such as timeouts rely on clocks you cannot substitute",
      "number": 929,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:22.090Z"
    },
    {
      "summary": "Scheduled workflows experience significant delays (up to a minute) before starting execution in the Go SDK. Multiple workflows in a loop show some waiting in scheduled state longer than expected before transitioning to running state.",
      "category": "bug",
      "subcategory": "workflow-scheduling",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "worker",
        "task-poller",
        "scheduler"
      ],
      "concepts": [
        "scheduling",
        "delay",
        "workflow-execution",
        "task-queue",
        "concurrency",
        "performance"
      ],
      "severity": "medium",
      "userImpact": "Users experience unexpected delays when starting multiple scheduled workflows, causing workflows to remain in scheduled state for up to a minute before execution begins.",
      "rootCause": "Server-side issue in scheduled workflow processing, fixed in Temporal server version 1.21.1 (addressed by temporalio/temporal#4562)",
      "proposedFix": "Upgrade to Temporal server version 1.21.1 or above",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by temporalio/temporal#4562 in server 1.21.1+. Issue was on server side, not SDK side.",
      "related": [],
      "keyQuote": "The delay between Scheduled Workflow task and actual start of the workflow should be quite small. It certainly should not be order of a minute.",
      "number": 928,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:08.274Z"
    },
    {
      "summary": "User requests a built-in query to inspect which signals are waiting to be processed by a workflow, distinguishing between pending signals and already-processed ones for debugging and monitoring purposes.",
      "category": "feature",
      "subcategory": "workflow-signals",
      "apis": [
        "GetSignalChannel"
      ],
      "components": [
        "workflow-runtime",
        "signal-dispatcher",
        "query-handler"
      ],
      "concepts": [
        "signal-inspection",
        "workflow-state",
        "debugging",
        "monitoring",
        "signal-queue"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily inspect which signals are queued and waiting to be processed, making it difficult to debug signal-related workflow issues.",
      "rootCause": null,
      "proposedFix": "Implement a built-in query that returns the list of signals currently waiting to be processed by the workflow.",
      "workaround": "Users can create their own custom query and manually track signals using workflowOutboundInterceptor GetSignalChannel, though this captures all signals rather than just waiting ones.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed as a duplicate of temporalio/sdk-features#51, indicating the feature is being tracked at a higher level.",
      "related": [
        51
      ],
      "keyQuote": "what I exactly need is \"waiting signals\" which means what can I send to the flow now",
      "number": 927,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:05.004Z"
    },
    {
      "summary": "After a worker process restarts, session is recreated with the same ID instead of returning ErrSessionFailed, preventing proper error handling for session failures. Additionally, in some cases activities hang indefinitely in Scheduled state when the session worker dies.",
      "category": "bug",
      "subcategory": "session-management",
      "apis": [
        "CreateSession",
        "ExecuteActivity",
        "GetSessionInfo"
      ],
      "components": [
        "session-manager",
        "worker-restart",
        "activity-scheduler",
        "task-queue"
      ],
      "concepts": [
        "session-failure",
        "worker-restart",
        "activity-timeout",
        "heartbeat",
        "session-recovery"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly handle session failures when workers restart, making it difficult to implement recovery logic and potentially leaving activities in hanging states.",
      "rootCause": "Session is recreated with the same ID after worker restart rather than being marked as failed; activity reschedule logic does not account for the original session worker being unavailable.",
      "proposedFix": null,
      "workaround": "Set up workflow retry policy to retry the entire workflow when session fails, or react to session failure explicitly in workflow code.",
      "resolution": "invalid",
      "resolutionDetails": "Issue closed due to lack of reproduction. Behavior was partially explained as intended (session cancellation on failure), but some aspects (activity hanging in Scheduled state) were acknowledged as potential bugs. Issue #937 references a planned feature for smoother session handling on worker restart.",
      "related": [
        746,
        937
      ],
      "keyQuote": "If I kill the worker with the session and start it back up after its HeartbeatTimeout and before its CreationTimeout, the session gets recreated with the same ID without any session failures reported",
      "number": 926,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:43:04.609Z"
    },
    {
      "summary": "The Godoc documentation for workflow.Sleep and workflow.NewTimer incorrectly states their second resolution. The documentation needs to be corrected to accurately describe the time unit resolution.",
      "category": "docs",
      "subcategory": "documentation",
      "apis": [
        "workflow.Sleep",
        "workflow.NewTimer"
      ],
      "components": [
        "documentation",
        "godoc"
      ],
      "concepts": [
        "timer",
        "sleep",
        "time-resolution",
        "duration",
        "documentation-accuracy"
      ],
      "severity": "low",
      "userImpact": "Users reading the Godoc may be misled about the time resolution capabilities of Sleep and NewTimer functions.",
      "rootCause": "Godoc comments contain incorrect statements about second resolution",
      "proposedFix": "Remove the incorrect statements from the Godoc comments",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Statements about incorrect second resolution were removed from Godoc",
      "related": [],
      "keyQuote": "Just remove the statements",
      "number": 925,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:50.447Z"
    },
    {
      "summary": "TestWorkflowEnvironment.SignalExternalWorkflow has a data race when signal data is modified after being sent. A concurrent goroutine attempts to look up mock signals while the workflow modifies the signal payload, causing race conditions detectable with go test -race.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "SignalExternalWorkflow"
      ],
      "components": [
        "testWorkflowEnvironmentImpl",
        "test-suite",
        "mock-integration"
      ],
      "concepts": [
        "data-race",
        "concurrency",
        "signal-handling",
        "test-isolation",
        "goroutine-safety"
      ],
      "severity": "high",
      "userImpact": "Users testing workflows that signal external workflows and modify signal data experience intermittent test failures and race condition warnings.",
      "rootCause": "TestWorkflowEnvironment.SignalExternalWorkflow spawns a new goroutine to look up the correct mock signal receiver concurrently with workflow execution, while the workflow modifies the signal payload data simultaneously.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        908
      ],
      "keyQuote": "a new go-routine is spawned, which tries to look up the correct mock of the signal receiver _concurrently_ with the rest of the workflow proceeding (and modifying the data of the signal currently being processed)",
      "number": 922,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:49.557Z"
    },
    {
      "summary": "Set a sensible default limit of 3 for MaxConcurrentEagerActivityExecutionSize instead of unlimited, reducing resource consumption and improving default behavior alignment with other SDKs.",
      "category": "feature",
      "subcategory": "eager-activity-execution",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "configuration"
      ],
      "concepts": [
        "concurrency-limit",
        "resource-management",
        "eager-execution",
        "default-settings",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users will experience better resource efficiency and more predictable behavior without needing to manually configure activity execution limits.",
      "rootCause": null,
      "proposedFix": "Default MaxConcurrentEagerActivityExecutionSize to 3 instead of unlimited; allow users to set very high values if they need effectively unlimited concurrency.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Default value was changed to 3 for MaxConcurrentEagerActivityExecutionSize to match behavior in sdk-core and sdk-java.",
      "related": [],
      "keyQuote": "Make `0` be the same as `3`, and ask users to just give a really high number if they want effectively unlimited.",
      "number": 919,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:47.067Z"
    },
    {
      "summary": "User requests an external type for internal.WorkflowClient to enable mocking of ExecuteWorkflow in unit tests, similar to how internal.WorkflowRun is exposed as client.WorkflowRun.",
      "category": "feature",
      "subcategory": "testing",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "client",
        "testing",
        "mocking"
      ],
      "concepts": [
        "unit-testing",
        "mocking",
        "interface-abstraction",
        "internal-types",
        "test-helpers"
      ],
      "severity": "low",
      "userImpact": "Developers cannot easily mock ExecuteWorkflow method in unit tests without access to internal.WorkflowClient type.",
      "rootCause": "internal.WorkflowClient is not exposed through a public interface like internal.WorkflowRun is exposed as client.WorkflowRun.",
      "proposedFix": "Define a public external type for internal.WorkflowClient, similar to existing pattern with client.WorkflowRun.",
      "workaround": "Mock the client.Client interface directly using composition and override ExecuteWorkflow method instead of mocking internal types.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers recommended using standard mocking patterns with the public client.Client interface rather than exposing internal types.",
      "related": [],
      "keyQuote": "You shouldn't need access to any particular implementation of client.Client. For example... type MyClient struct { client.Client ... }",
      "number": 918,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:32.639Z"
    },
    {
      "summary": "Feature request to add ability to mock or intercept side effect calls in the Go SDK test suite. Users need `TestWorkflow.OnSideEffect` and `TestWorkflow.OnMutableSideEffect` methods to control side effect behavior during testing.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "SideEffect",
        "MutableSideEffect"
      ],
      "components": [
        "test-framework",
        "workflow-testing",
        "side-effects"
      ],
      "concepts": [
        "testing",
        "mocking",
        "test-doubles",
        "side-effects",
        "interception",
        "test-isolation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test workflows that use side effects without being able to mock or control their behavior.",
      "rootCause": null,
      "proposedFix": "Add OnSideEffect and OnMutableSideEffect methods to TestWorkflow to allow mocking side effect calls.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented and merged into the test framework",
      "related": [],
      "keyQuote": "Add something like `TestWorkflow.OnSideEffect` and `TestWorkflow.OnMutableSideEffect`",
      "number": 916,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:35.032Z"
    },
    {
      "summary": "Default Prometheus sanitization options are altering metric label values by converting characters like dots to underscores, which breaks semantic meaning of workflow and activity names. The request is to stop modifying label values or make sanitization more permissive.",
      "category": "other",
      "subcategory": "metrics-prometheus",
      "apis": [],
      "components": [
        "tally",
        "prometheus",
        "metrics"
      ],
      "concepts": [
        "metrics",
        "label-sanitization",
        "prometheus",
        "tally",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users with dots or slashes in workflow/activity names lose semantic information when metrics are emitted because label values are altered.",
      "rootCause": "The current Prometheus sanitization options in contrib/tally/prometheus.go are configured to replace special characters in label values, converting dots to underscores and removing valid characters.",
      "proposedFix": "Change the Characters option to tally.UnderscoreDashDotCharacters to be more permissive, or potentially add support for forward slashes in sanitization options.",
      "workaround": "Locally change the Characters option to tally.UnderscoreDashDotCharacters to allow dots and dashes in metric label values.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we're naming workflows and activities according to fully qualified Protobuf names, so we have things like company.domain.Workflow, which was turned into company_domain_Workflow",
      "number": 912,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:30.294Z"
    },
    {
      "number": 910,
      "repository": "temporalio-sdk-go",
      "summary": "Request to add an activity.InActivity(context.Context) bool function to determine whether a context is an activity context. This would allow developers to check if code is executing within an activity execution context.",
      "category": "feature",
      "subcategory": "activity-context",
      "apis": [
        "InActivity"
      ],
      "components": [
        "activity",
        "context"
      ],
      "concepts": [
        "context-detection",
        "activity-execution",
        "runtime-introspection",
        "execution-context"
      ],
      "severity": "low",
      "userImpact": "Developers can now programmatically determine if their code is running within an activity context, enabling context-aware behavior.",
      "rootCause": null,
      "proposedFix": "Implement activity.InActivity(context.Context) bool function",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and the issue closed",
      "related": [],
      "keyQuote": "Need to know whether the context is an activity context.",
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:16.468Z"
    },
    {
      "summary": "Activity worker poller fails to stop when the first poll operation encounters a fatal error (e.g., namespace not found). The issue may be resolved by reordering initialization steps in the worker base code.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [],
      "components": [
        "worker",
        "activity-poller",
        "worker-base"
      ],
      "concepts": [
        "fatal-error",
        "worker-shutdown",
        "initialization-order",
        "error-handling",
        "polling"
      ],
      "severity": "high",
      "userImpact": "Workers may not properly shut down when encountering fatal errors on startup, leaving dangling activity pollers that continue polling.",
      "rootCause": "Initialization order in internal_worker_base.go lines 438-441 may not ensure activity poller stops before poll failure propagates.",
      "proposedFix": "Switch the order of worker initialization steps in internal_worker_base.go to ensure activity poller stop takes precedence.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Seems if the first poll fails w/ fatal error, there may be a case where the activity worker stop is not taking hold.",
      "number": 909,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:18.227Z"
    },
    {
      "summary": "The test framework's activity heartbeat mechanism is not concurrency-safe, causing race detector errors when multiple goroutines in an activity attempt to heartbeat simultaneously. The unsafe code is in getActivityHandle which was previously identified but never fixed.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [
        "RecordActivityHeartbeat"
      ],
      "components": [
        "test-framework",
        "activity-executor",
        "internal_workflow_testsuite"
      ],
      "concepts": [
        "concurrency-safety",
        "race-condition",
        "heartbeat",
        "goroutine",
        "test-environment"
      ],
      "severity": "high",
      "userImpact": "Users testing activities with concurrent goroutines using the test framework will encounter race detector errors and undefined behavior.",
      "rootCause": "The getActivityHandle function in internal_workflow_testsuite.go is not protected against concurrent access from multiple goroutines.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The concurrency-unsafe code in getActivityHandle was fixed to properly handle concurrent heartbeat calls from multiple goroutines.",
      "related": [
        780
      ],
      "keyQuote": "Race detector says this is clashing. Specifically at ... getActivityHandle, that is not concurrency safe.",
      "number": 908,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:14.859Z"
    },
    {
      "summary": "Worker's Stop() method is not reentrant, causing a panic when called after a fatal error has already triggered worker termination. Users expect the stop to be idempotent without panicking.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Stop"
      ],
      "components": [
        "worker",
        "lifecycle-management"
      ],
      "concepts": [
        "reentrancy",
        "idempotency",
        "error-handling",
        "worker-termination",
        "panic-prevention"
      ],
      "severity": "high",
      "userImpact": "Users calling worker.Stop() after a fatal error causes the application to panic instead of gracefully handling the redundant stop call.",
      "rootCause": "Stop() method is not reentrant, meaning it cannot safely handle being called multiple times concurrently or sequentially",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The Stop() method was made reentrant to handle multiple calls safely",
      "related": [],
      "keyQuote": "If a fatal error causes worker stop, a user calling worker stop should not panic",
      "number": 903,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:02.174Z"
    },
    {
      "summary": "Request to create new version tags for contrib/opentracing and contrib/opentelemetry modules to release new features that have been added.",
      "category": "feature",
      "subcategory": "release-management",
      "apis": [],
      "components": [
        "contrib/opentracing",
        "contrib/opentelemetry"
      ],
      "concepts": [
        "versioning",
        "release",
        "tagging",
        "contrib-modules"
      ],
      "severity": "low",
      "userImpact": "Users cannot access new features in opentracing and opentelemetry contrib modules until releases are tagged.",
      "rootCause": null,
      "proposedFix": "Create new tags for contrib/opentracing and contrib/opentelemetry modules",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "New releases were tagged for the contrib modules",
      "related": [],
      "keyQuote": "Need new tags for new features",
      "number": 901,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:03.519Z"
    },
    {
      "summary": "Signals are silently dropped when they fail to deserialize, and there's no warning logged to alert developers. The request is to add warning logs for failed signal deserialization and document behavior in selectors when the receive callback occurs.",
      "category": "feature",
      "subcategory": "signal-handling",
      "apis": [
        "SignalWithID",
        "GetSignal"
      ],
      "components": [
        "signal-handler",
        "deserializer",
        "selector"
      ],
      "concepts": [
        "serialization",
        "signal-processing",
        "error-logging",
        "deserialization",
        "callback",
        "debugging"
      ],
      "severity": "medium",
      "userImpact": "Developers lack visibility into signal deserialization failures, making it difficult to debug why signals aren't being processed.",
      "rootCause": "No warning is logged when signal deserialization fails, causing silent failures that are hard to detect.",
      "proposedFix": "Add warning logs when signal deserialization fails and document selector behavior when receive callback occurs with deserialization errors.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Signals are silently dropped when they can't deserialize",
      "number": 900,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:42:01.639Z"
    },
    {
      "summary": "Two high-severity vulnerabilities (CVE-2019-0210 and CVE-2019-0205) detected in github.com/uber-go/tally/v4-v4.1.1 dependency. Both are Apache Thrift vulnerabilities affecting Go JSON protocol implementations, causing potential panics and endless loops on invalid input. Upgrade to version 0.13.0 or later is recommended.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "tally-metrics",
        "thrift-protocol"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "dependency-upgrade",
        "network-attack"
      ],
      "severity": "critical",
      "userImpact": "Applications using the vulnerable tally dependency could crash or hang when processing malicious or malformed network input, causing service unavailability.",
      "rootCause": "Apache Thrift versions 0.9.3-0.12.0 have panic and infinite loop vulnerabilities in TJSONProtocol and TSimpleJSONProtocol implementations when processing invalid input.",
      "proposedFix": "Upgrade github.com/uber-go/tally/v4 to version 0.13.0 or later, which includes the fixed Apache Thrift dependency.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "In Apache Thrift 0.9.3 to 0.12.0, a server implemented in Go using TJSONProtocol or TSimpleJSONProtocol may panic when feed with invalid input data.",
      "number": 899,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:49.167Z"
    },
    {
      "summary": "Three jQuery vulnerabilities in golang.org/x/tools-v0.1.10 dependency, including a medium-severity XSS issue affecting DOM manipulation. This issue was automatically closed by Mend as the vulnerable library was no longer part of the dependency inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "build-system"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "xss",
        "dom-manipulation",
        "dependency-upgrade",
        "jquery"
      ],
      "severity": "medium",
      "userImpact": "Users could be exposed to XSS attacks if the vulnerable jQuery dependency was used in web-based tooling or documentation generation.",
      "rootCause": "golang.org/x/tools-v0.1.10 transitively depends on vulnerable jQuery versions (pre-3.5.0) which have XSS vulnerabilities in DOM manipulation methods.",
      "proposedFix": "Upgrade golang.org/x/tools to a version that uses jQuery 3.5.0 or later, or remove the dependency if not essential.",
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Automatically closed by Mend because the vulnerable library was either ignored or is no longer part of the dependency inventory.",
      "related": [],
      "keyQuote": "This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.",
      "number": 898,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:44.952Z"
    },
    {
      "summary": "Four vulnerabilities detected in golang.org/x/tools-v0.1.8 dependency, primarily jQuery XSS issues with CVSS scores ranging from 5.3 to 6.1. The issue was automatically closed by Mend after the vulnerable library was removed from the inventory.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "build-tools",
        "golang.org/x-tools"
      ],
      "concepts": [
        "security-vulnerability",
        "xss-attack",
        "dependency-upgrade",
        "jquery",
        "transitive-dependency"
      ],
      "severity": "medium",
      "userImpact": "Vulnerable dependencies could potentially allow XSS attacks if the SDK is used in contexts where untrusted HTML is processed.",
      "rootCause": "golang.org/x/tools-v0.1.8 included vulnerable jQuery versions (pre-3.5.0) that had XSS vulnerabilities in DOM manipulation methods.",
      "proposedFix": "Upgrade golang.org/x/tools to a version that depends on jQuery 3.5.0 or later, and address CVE-2022-29526 in golang.org/x/sys.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The vulnerable library was removed from the Mend inventory, indicating the dependency was either upgraded or removed from the codebase.",
      "related": [],
      "keyQuote": "This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.",
      "number": 897,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:47.456Z"
    },
    {
      "summary": "Request to expose the raw operator service getter to the Go SDK client interface, allowing direct access to operator service functionality.",
      "category": "feature",
      "subcategory": "client-interface",
      "apis": [
        "OperatorService"
      ],
      "components": [
        "client",
        "operator-service"
      ],
      "concepts": [
        "service-exposure",
        "client-interface",
        "operator-api",
        "raw-access"
      ],
      "severity": "low",
      "userImpact": "Users who need operator service functionality will have direct access through the client interface without workarounds.",
      "rootCause": null,
      "proposedFix": "Add raw operator service getter to client interface",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The operator service was exposed through the client interface",
      "related": [],
      "keyQuote": "Add raw operator service getter to client interface.",
      "number": 896,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:28.655Z"
    },
    {
      "summary": "Request for a tagged release of the Tally contrib library to include changes from issue #756. The release was subsequently completed with tag contrib/tally/v0.2.0.",
      "category": "feature",
      "subcategory": "contrib-library-release",
      "apis": [],
      "components": [
        "tally-contrib",
        "contrib-library",
        "release-management"
      ],
      "concepts": [
        "versioning",
        "release",
        "contrib-library",
        "dependency-management",
        "packaging"
      ],
      "severity": "low",
      "userImpact": "Users can now use the updated Tally contrib library with bug fixes and improvements through an official tagged release.",
      "rootCause": null,
      "proposedFix": "Release contrib/tally/v0.2.0 with changes from #756",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tagged release contrib/tally/v0.2.0 was created to include the requested changes.",
      "related": [
        756
      ],
      "keyQuote": "There is now a tag for `contrib/tally/v0.2.0`",
      "number": 891,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:32.223Z"
    },
    {
      "summary": "Workflow and activity methods with identical names collide in the test framework's mock system, causing incorrect mock signature validation errors despite the workflow executing correctly in production. The test framework doesn't incorporate type information when creating mock names, leading to ambiguity between methods with the same name in different contexts.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "test-suite",
        "mock-framework",
        "workflow-execution"
      ],
      "concepts": [
        "name-collision",
        "mock-expectations",
        "type-disambiguation",
        "test-validation",
        "method-resolution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use identical method names for workflows and activities in tests, restricting naming conventions and forcing workarounds despite actual workflows functioning correctly.",
      "rootCause": "Mock framework doesn't incorporate type information into mock names, causing name collisions between workflow and activity methods with identical names when registering mock expectations.",
      "proposedFix": "Incorporate type information into mock names to allow proper disambiguation between methods with the same name but different types/packages.",
      "workaround": "Rename activity methods to have different names from workflow methods.",
      "resolution": "fixed",
      "resolutionDetails": "Pull request #1371 was referenced as fixing this issue.",
      "related": [
        1371
      ],
      "keyQuote": "I have a set of workflows and activities implemented as methods on a struct. I happened to name an activity method with the same name as the workflow method.",
      "number": 887,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:28.555Z"
    },
    {
      "summary": "When using NewClientFromExisting, calling Close() on either the parent or child client closes the connection for both immediately, rather than having independent lifecycles where resources are only cleaned up when all references are closed.",
      "category": "bug",
      "subcategory": "client-lifecycle",
      "apis": [
        "NewClientFromExisting",
        "Close"
      ],
      "components": [
        "client",
        "connection-management",
        "resource-cleanup"
      ],
      "concepts": [
        "lifecycle-management",
        "reference-counting",
        "resource-sharing",
        "client-cloning",
        "connection-pooling"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely share cloned clients without risk of closing the connection for all users, making it difficult to use in large programs with shared client instances.",
      "rootCause": "The Close() method closes the shared connection immediately without reference counting or tracking how many client instances are using it.",
      "proposedFix": "Implement independent lifecycles for cloned clients with reference counting so resources are only cleaned up when all client instances are closed.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was addressed through implementation of reference counting for cloned clients to manage independent lifecycles.",
      "related": [
        881
      ],
      "keyQuote": "I can call `Close` on only one or both of them, and resources will be cleaned up when appropriate.",
      "number": 886,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:16.016Z"
    },
    {
      "summary": "Feature request to enable passing open sessions from parent workflows to child workflows. Child workflows should be able to use sessions opened by the parent while they remain active, with the parent responsible for opening and closing the session.",
      "category": "feature",
      "subcategory": "sessions",
      "apis": [
        "GetSessionInfo",
        "RecreateSession"
      ],
      "components": [
        "workflow-engine",
        "session-management",
        "child-workflow"
      ],
      "concepts": [
        "session-sharing",
        "parent-child-workflows",
        "resource-reuse",
        "stateful-execution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently share active sessions between parent and child workflows, limiting the ability to coordinate stateful operations across workflow boundaries.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": "Use RecreateSession with a recreate token to open a new session on the same worker, but this creates a separate session rather than sharing the same one.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This feature request is to give ability to share session among multiple workflows while it is still open.",
      "number": 884,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:13.540Z"
    },
    {
      "summary": "Remove unnecessary warning log that fires when a worker is explicitly stopped. Currently logs 'Failed to poll for task' with error 'worker stopping' even though this is expected behavior during graceful shutdown.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "worker",
        "polling",
        "logging"
      ],
      "concepts": [
        "graceful-shutdown",
        "worker-stop",
        "log-noise",
        "expected-behavior"
      ],
      "severity": "low",
      "userImpact": "Users see warning logs during normal worker shutdown that incorrectly suggest an error condition, causing confusion and noise in log aggregation systems.",
      "rootCause": "The polling loop logs all failures without distinguishing between unexpected errors and expected ones that occur during graceful worker shutdown.",
      "proposedFix": "Suppress the log message when the worker is explicitly stopping, as this is not an error condition.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The poll failure log is now suppressed when the worker is in a stopping state.",
      "related": [],
      "keyQuote": "Failed to poll for task. ... \"Error\": \"worker stopping\" ... We should stop",
      "number": 882,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:16.501Z"
    },
    {
      "summary": "Completed workflows are not properly checking for command/event mismatches when activities are replayed in a different order, allowing non-deterministic issues to go undetected. A conditional protecting against premature workflow completion is preventing determinism checks from running on completed workflows.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "task-handler",
        "replayer",
        "workflow-execution"
      ],
      "concepts": [
        "determinism",
        "non-determinism",
        "command-event-mismatch",
        "workflow-replay",
        "history-validation"
      ],
      "severity": "high",
      "userImpact": "Users can have non-deterministic workflows go undetected when replaying completed workflows with different activity orderings, leading to silent failures in production.",
      "rootCause": "The !w.isWorkflowCompleted conditional at internal_task_handlers.go:946 disables determinism checks for completed workflows to prevent premature completion issues, but this also prevents detection of command/event mismatches.",
      "proposedFix": "Re-enable determinism checks on completed workflows while ensuring no issues arise with premature workflow completion due to panic errors and maintaining backward compatibility with existing code.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Determinism checks were re-enabled for completed workflows with proper safeguards for premature completion scenarios",
      "related": [],
      "keyQuote": "This is not occurring because of the !w.isWorkflowCompleted conditional at https://github.com/temporalio/sdk-go/blob/38b2b69f18bdc3bcaf1b4e48f940d1c60b5f9253/internal/internal_task_handlers.go#L946",
      "number": 876,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:57.977Z"
    },
    {
      "summary": "Query handlers can perform unsafe operations like starting activities, which violates read-only semantics. The solution involves accepting context as a parameter in query handlers while restricting its capabilities and adding static analyzer checks.",
      "category": "feature",
      "subcategory": "query-handlers",
      "apis": [
        "ExecuteActivity",
        "QueryHandler"
      ],
      "components": [
        "query-handler",
        "context",
        "workflow-runtime"
      ],
      "concepts": [
        "read-only",
        "safety",
        "validation",
        "mutation-prevention",
        "static-analysis"
      ],
      "severity": "medium",
      "userImpact": "Query handlers can currently perform unsafe mutating operations, breaking the semantic contract that queries should be read-only and not affecting workflow state.",
      "rootCause": "Query handler context lacks restrictions to prevent execution of activities and other mutating operations that should only occur in workflow code.",
      "proposedFix": "Allow query handlers to accept context as first parameter with backwards compatibility, disallow execute activity on that context, and add workflowcheck static analyzer check to enforce restrictions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        177
      ],
      "keyQuote": "Queries can start activities and such and they shouldn't",
      "number": 875,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:59.312Z"
    },
    {
      "summary": "Feature request to change Worker.Run() to accept chan struct{} instead of chan interface{}, enabling direct use of context.Done() channels for shutdown signaling.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Worker.Run",
        "Worker.Start",
        "Worker.Stop"
      ],
      "components": [
        "worker",
        "interruption-handling"
      ],
      "concepts": [
        "channel-signaling",
        "context-cancellation",
        "graceful-shutdown",
        "api-ergonomics",
        "type-safety"
      ],
      "severity": "low",
      "userImpact": "Users cannot conveniently pass context.Done() to Worker.Run(), requiring workarounds or helper functions.",
      "rootCause": "Worker.Run() signature uses chan interface{} which is not compatible with chan struct{} due to Go's type system.",
      "proposedFix": "Change Worker.Run() to accept chan struct{} instead of chan interface{}. Alternative: add RunCtx(context.Context) method.",
      "workaround": "Create a top-level helper function that wraps Worker.Run() with a chan interface{}, or use Start()+Stop() for fine-grained control.",
      "resolution": "wontfix",
      "resolutionDetails": "Breaking change not acceptable for current version. Suggested for v2 of the SDK.",
      "related": [],
      "keyQuote": "Then maybe something to keep in mind for v2 of the SDK.",
      "number": 874,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:41:01.543Z"
    },
    {
      "summary": "The slots available metric is not being properly removed when a worker stops, potentially causing incorrect slot accounting in monitoring and observability.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [],
      "components": [
        "worker",
        "metrics",
        "slot-management"
      ],
      "concepts": [
        "slots",
        "worker-lifecycle",
        "metrics-tracking",
        "resource-management",
        "cleanup"
      ],
      "severity": "medium",
      "userImpact": "Users may see incorrect or stale metrics for available slots after workers stop, leading to confused monitoring and debugging.",
      "rootCause": "Slots available metric added during worker start may not be properly decremented or removed during worker stop.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Slots available added on start are removed on stop",
      "number": 873,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:45.831Z"
    },
    {
      "summary": "Review and finalize the Go SDK's high-level API for schedules before releasing to users. The server and tctl already use the Go SDK client's schedule functionality, but the API needs to be vetted for public use.",
      "category": "feature",
      "subcategory": "schedules",
      "apis": [
        "Schedule"
      ],
      "components": [
        "schedules",
        "client-api",
        "go-sdk"
      ],
      "concepts": [
        "api-design",
        "schedules",
        "public-api",
        "client-interface",
        "workflow-scheduling"
      ],
      "severity": "medium",
      "userImpact": "Users need a stable, well-designed Go SDK API for scheduling workflows before the feature can be considered production-ready.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The schedule API was reviewed and made available in the Go SDK for public use.",
      "related": [],
      "keyQuote": "we should review this API before handing it off to users",
      "number": 871,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:44.390Z"
    },
    {
      "summary": "Documentation for error handling in the workflow package references a non-existent `error.CustomError()` function and lacks clarity on the mutual exclusivity of result and error in workflow run's Get method.",
      "category": "docs",
      "subcategory": "error-handling",
      "apis": [
        "workflow.Get"
      ],
      "components": [
        "documentation",
        "error-handling",
        "workflow"
      ],
      "concepts": [
        "error-handling",
        "documentation",
        "api-clarity",
        "result-error-exclusivity"
      ],
      "severity": "low",
      "userImpact": "Developers following the documentation may reference non-existent error handling APIs and have unclear expectations about result and error return values.",
      "rootCause": "Stale documentation referencing removed or non-existent error APIs; missing clarity on Get method contract",
      "proposedFix": "Update error references to remove stale API mentions; clarify in workflow run's Get documentation that result and error are mutually exclusive",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to remove stale error references and clarify the mutual exclusivity of result and error in workflow Get methods",
      "related": [],
      "keyQuote": "Make sure none of the error references are stale. Also update workflow run's `Get` to clarify that result and error are mutually exclusive",
      "number": 870,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:43.111Z"
    },
    {
      "summary": "Panic occurs when `Stop` is called before `Run` has fully started due to a race condition. The assertion in `AggregatedWorker.Run` fails if Stop executes before Start completes, causing a panic instead of returning an error.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Run",
        "Stop",
        "Start",
        "AggregatedWorker"
      ],
      "components": [
        "worker",
        "internal_worker",
        "lifecycle-management"
      ],
      "concepts": [
        "race-condition",
        "goroutine-synchronization",
        "shutdown",
        "panic-handling",
        "startup-timing"
      ],
      "severity": "medium",
      "userImpact": "Users who call Stop before Run fully starts experience an unhandled panic, making graceful shutdown unpredictable during application startup.",
      "rootCause": "The assertion in AggregatedWorker.Run does not account for the legitimate race condition where Stop may be called before the worker has fully started.",
      "proposedFix": "Return an error like ErrClosed instead of panicking when Stop is called before Run completes.",
      "workaround": "Only call Stop from within an activity that has executed at least once, or use Start instead of Run to have more control over shutdown timing.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue closed in favor of using Start instead of Run. Users concerned about this race should use Start and Stop for more explicit control. Documentation for Run was updated to note the potential panic.",
      "related": [],
      "keyQuote": "Users concerned about this race should use Start and Stop. Users should not use `Run` if they're concerned they may shutdown before running.",
      "number": 868,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:29.179Z"
    },
    {
      "summary": "TestWorkflowEnvironment doesn't enforce WorkflowExecutionTimeout on child workflows. Workflow execution timeouts are not being enforced during unit testing with testEnv.ExecuteWorkflow(), and error messages reference non-existent timeout types.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "test-environment",
        "workflow-execution",
        "timeout-enforcement"
      ],
      "concepts": [
        "timeout",
        "workflow-execution-timeout",
        "child-workflow",
        "unit-testing",
        "deadline"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test workflow timeout behavior in unit tests, preventing proper validation of timeout configurations before production.",
      "rootCause": "TestWorkflowEnvironment does not enforce WorkflowExecutionTimeout; only WorkflowRunTimeout is enforced, and timeout enforcement logic is missing or incomplete.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Child workflow is allowed to run without timing out. A child workflow times out if WorkflowRunTimeout is specified and exceeded.",
      "number": 866,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:28.301Z"
    },
    {
      "summary": "The replayer uses a different run ID source than the runtime after a workflow reset, affecting default child workflow ID generation. The replayer should be updated to use the runtime's run ID source for consistency.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replayer",
        "workflow-execution",
        "child-workflow"
      ],
      "concepts": [
        "run-id",
        "workflow-reset",
        "child-workflow-id",
        "execution-state"
      ],
      "severity": "high",
      "userImpact": "Replayed workflows generate different child workflow IDs than the runtime, causing behavioral mismatches during replay and reset scenarios.",
      "rootCause": "Replayer uses `temporal.api.history.v1.WorkflowExecutionStartedEventAttributes.original_execution_run_id` while runtime uses `temporal.api.workflowservice.v1.workflow_execution.run_id`",
      "proposedFix": "Update the replayer to use the runtime's run ID source (`temporal.api.workflowservice.v1.workflow_execution.run_id`) instead of the original execution run ID",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Replayer was updated to use the correct run ID source for consistency with runtime behavior",
      "related": [],
      "keyQuote": "replayer uses temporal.api.history.v1.WorkflowExecutionStartedEventAttributes.original_execution_run_id while runtime uses temporal.api.workflowservice.v1.workflow_execution.run_id",
      "number": 865,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:25.588Z"
    },
    {
      "summary": "Non-deterministic workflow errors in the Go SDK should be clearly labeled as such. Currently, only one of three related errors mentions non-determinism, making it unclear to users that certain errors indicate non-deterministic behavior in workflows.",
      "category": "other",
      "subcategory": "error-messages",
      "apis": [],
      "components": [
        "error-handling",
        "workflow-runtime"
      ],
      "concepts": [
        "non-determinism",
        "error-clarity",
        "workflow-execution",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Users encountering non-deterministic workflow errors may not immediately recognize the root cause without clear error messaging.",
      "rootCause": "Error messages lack consistent non-determinism labeling across multiple error types",
      "proposedFix": "Prepend \"nondeterministic workflow: \" to the other two non-determinism-related errors",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed in favor of PR #1281 which implements the error message improvements",
      "related": [
        1281
      ],
      "keyQuote": "Prepend \"nondeterministic workflow: \" to the other two.",
      "number": 864,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:10.511Z"
    },
    {
      "summary": "Users need to create a new client from an existing client's connection while changing non-connection options. The discussion explores design options and identifies a challenge with gRPC interceptors that set namespace metrics at dial time.",
      "category": "feature",
      "subcategory": "client-creation",
      "apis": [],
      "components": [
        "client",
        "connection",
        "grpc",
        "metrics",
        "interceptors"
      ],
      "concepts": [
        "connection-reuse",
        "client-options",
        "grpc-interceptors",
        "namespace-metrics",
        "dial-time-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot efficiently create multiple clients sharing the same connection with different options, and there are concerns about metrics consistency when reusing connections across clients.",
      "rootCause": "gRPC interceptors that set namespace metrics are only applied at dial time, making it difficult to handle namespace context when creating new clients from existing connections without changing the metrics behavior.",
      "proposedFix": "Three potential solutions discussed: (1) Accept WorkflowService in client options to ignore connection options, (2) Accept grpc.ClientConn in options with optional connection exposure, or (3) Create a Clone(existingClient Client, newOptions Options) function.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "One of the proposed solutions was implemented to allow creating new clients from existing connections.",
      "related": [],
      "keyQuote": "We use gRPC interceptors, which are only done at dial time, to put the namespace on the following all client methods",
      "number": 861,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:12.905Z"
    },
    {
      "summary": "A panic occurs in eager activity code when RespondWorkflowTaskCompleted returns an error, because the code assumes a response is present without proper error handling. The fix should unreserve activity spots as if no tasks were returned.",
      "category": "bug",
      "subcategory": "eager-activity",
      "apis": [
        "RespondWorkflowTaskCompleted"
      ],
      "components": [
        "internal_eager_activity",
        "activity-executor",
        "workflow-task-handler"
      ],
      "concepts": [
        "panic-handling",
        "error-response",
        "resource-cleanup",
        "eager-execution",
        "activity-reservation"
      ],
      "severity": "high",
      "userImpact": "Users experience application panics when eager activity responses encounter errors, causing workflow task processing to crash unexpectedly.",
      "rootCause": "The code in internal_eager_activity.go assumes a response is always present when RespondWorkflowTaskCompleted is called, without checking for errors first.",
      "proposedFix": "Add proper error handling to check if a response is present before accessing it; unreserve activity spots when an error occurs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The panic issue was resolved by adding proper error handling and response presence checks in the eager activity code.",
      "related": [],
      "keyQuote": "Panics because we foolishly assume a response is present in `internal_eager_activity.go`",
      "number": 860,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:40:09.242Z"
    },
    {
      "summary": "Context timeout with very short heartbeat throttle intervals causes immediate context expiration. Setting heartbeat throttle interval to very small values (like 1 nanosecond) causes the context to timeout immediately due to using `context.WithTimeout(ctx, i.heartbeatThrottleInterval)`.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "heartbeat",
        "activity-executor",
        "context-handling"
      ],
      "concepts": [
        "timeout",
        "throttling",
        "context-management",
        "heartbeat-interval"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure very short heartbeat throttle intervals without experiencing immediate context timeouts.",
      "rootCause": "Using `context.WithTimeout(ctx, i.heartbeatThrottleInterval)` directly with the throttle interval value causes premature context expiration when the interval is very small.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified as a bug in heartbeat timeout handling where small interval values caused immediate context expiration.",
      "related": [
        660
      ],
      "keyQuote": "For whatever reason in #660, I put `context.WithTimeout(ctx, i.heartbeatThrottleInterval)` which means that context times out immediately",
      "number": 859,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:57.563Z"
    },
    {
      "summary": "User requests that RPC failures in the Go SDK include reason codes or error type information to distinguish between business logic errors (like 404 NotFound) and actual service failures (like 500s). This would help them monitor Temporal Cloud connectivity and distinguish operational issues from expected application behavior.",
      "category": "feature",
      "subcategory": "metrics-observability",
      "apis": [
        "DescribeWorkflowExecution"
      ],
      "components": [
        "grpc-client",
        "metrics",
        "error-handling"
      ],
      "concepts": [
        "rpc-failures",
        "error-codes",
        "metrics-cardinality",
        "monitoring",
        "error-classification",
        "interceptors"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily distinguish between expected errors (NotFound) and actual service failures when monitoring RPC metrics, making it difficult to set up accurate alerting.",
      "rootCause": "RPC failures are recorded as a generic metric without distinguishing error types, making it unclear whether the failure is a business logic error or connectivity/service issue.",
      "proposedFix": "Use gRPC interceptors to record custom metrics with error code tags, allowing users to filter metrics by error type rather than relying on a single generic failure metric.",
      "workaround": "Users can implement custom gRPC interceptors using grpc.WithUnaryInterceptor and set them on client.Options.ConnectionOptions.DialOptions to extract and record error codes as custom metrics.",
      "resolution": "wontfix",
      "resolutionDetails": "The SDK maintainers decided not to add reason codes to the default RPC failure metric, as it would unexpectedly increase metric cardinality for all users. Instead, they recommended users implement custom gRPC interceptors to record metrics according to their specific needs.",
      "related": [],
      "keyQuote": "I don't think we really want to add a tag on the existing metric that others are using and thereby increase their metric cardinality unexpectedly.",
      "number": 858,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:58.006Z"
    },
    {
      "summary": "Calling worker.Stop() twice causes a panic when trying to close an already-closed channel. The issue questions whether Stop should be idempotent or if users should be responsible for tracking worker state.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Stop"
      ],
      "components": [
        "worker",
        "channel-management"
      ],
      "concepts": [
        "panic",
        "channel-closure",
        "idempotency",
        "lifecycle",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Users who accidentally call Stop() multiple times will experience a panic, potentially crashing their application.",
      "rootCause": "The Stop() method closes a channel without checking if it's already closed, and there's no atomic way to prevent double-stops.",
      "proposedFix": null,
      "workaround": "Users should maintain their own state to track whether they've already called Stop().",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainers decided not to make Stop() idempotent, arguing that just like file deletion, calling Stop() twice should not be allowed. They plan to document that Stop() cannot be called twice.",
      "related": [],
      "keyQuote": "I am not convinced we need to allow worker functions to be safe for multiple calls.",
      "number": 855,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:56.470Z"
    },
    {
      "summary": "Request to implement the num_pollers metric for the Go SDK to track the number of active activity and workflow pollers for cluster tuning and outage analysis.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "worker",
        "pollers"
      ],
      "concepts": [
        "monitoring",
        "observability",
        "performance-tuning",
        "cluster-management",
        "activity-pollers",
        "workflow-pollers"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily monitor active poller counts during cluster tuning or post-mortem analysis without this metric.",
      "rootCause": null,
      "proposedFix": "Implement the num_pollers metric as documented in the Temporal SDK metrics reference.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The num_pollers metric was implemented for the Go SDK.",
      "related": [],
      "keyQuote": "There is no clear way to tell how many pollers were active at any given time when tuning a cluster or doing an outage post mortem.",
      "number": 854,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:43.773Z"
    },
    {
      "summary": "Dependency security vulnerability in testify v1.8.0's transitive dependency stretchr/objx v0.4.0 (CVE-2022-28948) causing potential DoS through unsafe YAML deserialization. Issue was automatically resolved when the vulnerable library was removed from the project's dependency inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "test-framework"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-management",
        "yaml-deserialization",
        "denial-of-service",
        "cvss-7.5"
      ],
      "severity": "high",
      "userImpact": "Users of the SDK could be vulnerable to denial-of-service attacks through unsafe YAML deserialization in the testify test framework dependency.",
      "rootCause": "CVE-2022-28948 in stretchr/objx v0.4.0 causes crashes when deserializing invalid YAML input, accessible through testify's transitive dependencies.",
      "proposedFix": "Upgrade stretchr/objx to v3.0.0 or remove the vulnerable dependency from the project.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was marked as ignored or removed from the project's dependency inventory.",
      "related": [],
      "keyQuote": "An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.",
      "number": 853,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:41.955Z"
    },
    {
      "summary": "SDK v1.15.0 is incompatible with api v1.9.0 due to missing GetWorkerBuildIdOrdering method implementation in the workflow service proxy server.",
      "category": "bug",
      "subcategory": "dependency-compatibility",
      "apis": [],
      "components": [
        "client",
        "service-proxy",
        "workflow-service"
      ],
      "concepts": [
        "version-compatibility",
        "interface-implementation",
        "dependency-management",
        "build-error"
      ],
      "severity": "high",
      "userImpact": "Users cannot build their applications when upgrading to SDK v1.15.0 with api v1.9.0 due to missing method implementation.",
      "rootCause": "The workflowServiceProxyServer type does not implement the updated workflowservice.WorkflowServiceServer interface which requires the GetWorkerBuildIdOrdering method.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "This issue was identified as a duplicate of issue #832, which addresses the same compatibility problem.",
      "related": [
        832
      ],
      "keyQuote": "cannot use &workflowServiceProxyServer{} as type workflowservice.WorkflowServiceServer (missing GetWorkerBuildIdOrdering method)",
      "number": 847,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:43.490Z"
    },
    {
      "summary": "Documentation issue: A code comment references a fully qualified function name (go.temporal.io/sdk/contrib/tally.NewMetricsHandler) that the issue author believes should be a direct URL to the Go package documentation. The maintainer clarified that function references are intentional, not meant to be URLs.",
      "category": "docs",
      "subcategory": "code-documentation",
      "apis": [
        "NewMetricsHandler"
      ],
      "components": [
        "metrics",
        "documentation",
        "contrib-tally"
      ],
      "concepts": [
        "documentation",
        "api-reference",
        "metrics-handler",
        "code-comments"
      ],
      "severity": "low",
      "userImpact": "Users reading the code may be confused about whether function references in comments should be clickable URLs or fully qualified names.",
      "rootCause": "Misunderstanding about the intended format of function references in code comments",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer clarified that function references are intentionally formatted as fully qualified names, not URLs, and decided not to change this convention",
      "related": [],
      "keyQuote": "That's not meant to be a URL, that's a fully qualified function reference. I am not sure we want to change function references to URLs.",
      "number": 846,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:25.880Z"
    },
    {
      "summary": "Activity function alias lookup is incorrectly performed regardless of task queue, when it should only look up aliases in the local registry when executing on the same task queue.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "task-queue-router",
        "function-registry"
      ],
      "concepts": [
        "task-queue",
        "function-alias",
        "activity-lookup",
        "local-registry",
        "cross-queue-execution"
      ],
      "severity": "medium",
      "userImpact": "Users may experience unexpected behavior when using activity function aliases across different task queues, as aliases are resolved incorrectly.",
      "rootCause": "Activity alias lookup logic does not check or validate the task queue context before performing registry lookups.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The alias lookup logic was fixed to only perform lookups in the local registry when executing on the same task queue.",
      "related": [],
      "keyQuote": "ExecuteActivity should only look up function alias in local registry when executing on the same task queue.",
      "number": 845,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:27.117Z"
    },
    {
      "summary": "Documentation should clarify that reusing output variables across multiple ch.Receive/ReceiveAsync or future.Get calls can cause unexpected behavior, especially with json.Unmarshal. Developers should declare fresh variables for each invocation.",
      "category": "docs",
      "subcategory": "channels-futures",
      "apis": [
        "Receive",
        "ReceiveAsync",
        "Get"
      ],
      "components": [
        "channels",
        "futures",
        "unmarshaling"
      ],
      "concepts": [
        "variable-reuse",
        "json-unmarshaling",
        "state-management",
        "anti-patterns",
        "documentation"
      ],
      "severity": "medium",
      "userImpact": "Developers may experience unexpected behavior when reusing output variables across multiple channel or future operations due to json.Unmarshal semantics.",
      "rootCause": "json.Unmarshal behavior with reused variables, particularly when dealing with maps in the target type structure",
      "proposedFix": "Update code comments and documentation to explicitly recommend declaring fresh variables for each ch.Receive/ReceiveAsync or future.Get invocation",
      "workaround": "Declare a new variable in each iteration instead of reusing the same variable across multiple calls",
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to clarify that output variables should not be reused across multiple invocations",
      "related": [],
      "keyQuote": "sharing an output variable across multiple invocations is almost always an anti-pattern",
      "number": 844,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:28.573Z"
    },
    {
      "summary": "Add documentation clarifying that external mock callbacks for activities, local activities, child workflows, and external workflow operations run on separate goroutines and are not thread-safe, which may confuse developers writing tests.",
      "category": "docs",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "StartChildWorkflow",
        "SignalExternalWorkflow",
        "CancelExternalWorkflow"
      ],
      "components": [
        "test-suite",
        "mock-callbacks",
        "goroutine-execution"
      ],
      "concepts": [
        "thread-safety",
        "goroutines",
        "testing",
        "mocks",
        "callbacks",
        "concurrency"
      ],
      "severity": "low",
      "userImpact": "Test developers may incorrectly assume mock callbacks are thread-safe and write unsafe test code, leading to race conditions and flaky tests.",
      "rootCause": null,
      "proposedFix": "Add documentation to the test suite explaining that callbacks for external mocks run on separate goroutines and are not thread-safe.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was added to the test suite clarifying the non-thread-safe nature of external mock callbacks.",
      "related": [],
      "keyQuote": "callbacks for mocks on activities, local activities, child workflows, signal external workflow, and cancel external workflow are all done on separate goroutines and not thread safe",
      "number": 843,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:09.884Z"
    },
    {
      "summary": "Request to add custom payload processing support to the codec gRPC interceptor, allowing users to selectively skip processing for certain payload types (like headers) instead of processing all non-search-attribute payloads.",
      "category": "feature",
      "subcategory": "codec-interceptor",
      "apis": [],
      "components": [
        "codec",
        "gRPC-interceptor",
        "payload-processing"
      ],
      "concepts": [
        "custom-processor",
        "header-handling",
        "payload-filtering",
        "codec-options",
        "interception"
      ],
      "severity": "low",
      "userImpact": "Users who need selective payload processing (e.g., skipping tracing headers) would have more flexible control over codec behavior.",
      "rootCause": null,
      "proposedFix": "Add a CustomProcessor field to PayloadCodecGRPCClientInterceptorOptions that accepts a function taking a ProcessContext with Stack, Current, Encode, and Next fields, allowing custom logic to conditionally skip processing.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "No reason to make it purposefully less flexible. For example, what if you wanted to conditionally skip processing an object?",
      "number": 842,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:11.044Z"
    },
    {
      "summary": "The SDK does not provide qualified proto message type names for the deprecated github.com/golang/protobuf library, only for the newer google.golang.org/protobuf. A dependency conflict prevents supporting the older library version.",
      "category": "bug",
      "subcategory": "protobuf-serialization",
      "apis": [],
      "components": [
        "proto_json_payload_converter",
        "protobuf-support"
      ],
      "concepts": [
        "protobuf",
        "serialization",
        "compatibility",
        "message-types",
        "deprecated-library"
      ],
      "severity": "low",
      "userImpact": "Users relying on the deprecated github.com/golang/protobuf library cannot access qualified proto message type names in metadata.",
      "rootCause": "Dependency conflict: the SDK properly depends on google.golang.org/protobuf (1.4.0+), which prevents depending on the older pre-1.4.0 github.com/golang/protobuf to extract message type information.",
      "proposedFix": null,
      "workaround": "Use the newer google.golang.org/protobuf library instead of the deprecated github.com/golang/protobuf.",
      "resolution": "wontfix",
      "resolutionDetails": "Cannot be implemented due to dependency constraints. The deprecated library is too old to support alongside the modern protobuf dependency.",
      "related": [],
      "keyQuote": "we cannot depend on the pre `1.4.0` `github.com/golang/protobuf` to check this because we properly depend on the later one. This really old version is deprecated",
      "number": 837,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:39:14.220Z"
    },
    {
      "summary": "User couldn't check if an error is a ContinueAsNewError in an Interceptor because the type was in the internal package and not publicly accessible. The issue was resolved by pointing out that ContinueAsNewError is already exposed in the public workflow package.",
      "category": "question",
      "subcategory": "error-handling",
      "apis": [
        "ExecuteWorkflow",
        "ContinueAsNewError"
      ],
      "components": [
        "interceptor",
        "error-handling",
        "workflow"
      ],
      "concepts": [
        "type-checking",
        "error-wrapping",
        "internal-package",
        "public-api",
        "accessibility"
      ],
      "severity": "low",
      "userImpact": "Users writing interceptors were unable to type-assert for ContinueAsNewError errors due to the type being unexpectedly internal.",
      "rootCause": "ContinueAsNewError was in the internal package, but it is actually exposed in the public workflow package, causing confusion.",
      "proposedFix": "Use the publicly exposed ContinueAsNewError from go.temporal.io/sdk/workflow instead of accessing the internal package.",
      "workaround": "Reference ContinueAsNewError from the public workflow package: pkg.go.dev/go.temporal.io/sdk/workflow#ContinueAsNewError",
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by clarifying that ContinueAsNewError is publicly available in the workflow package, not just in internal.",
      "related": [],
      "keyQuote": "It is exposed at https://pkg.go.dev/go.temporal.io/sdk/workflow#ContinueAsNewError",
      "number": 834,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:58.361Z"
    },
    {
      "summary": "User asks about implementing an interceptor to capture panics and errors from workflows and activities for Sentry integration, specifically questioning how to handle signal interception. The maintainer clarifies that signals processed through channels don't panic and error handling is not necessary for signal handlers.",
      "category": "question",
      "subcategory": "interceptors",
      "apis": [
        "HandleSignal"
      ],
      "components": [
        "interceptor",
        "signal-handler",
        "workflow-inbound"
      ],
      "concepts": [
        "panic-handling",
        "error-capture",
        "signal-processing",
        "interceptor-chain",
        "monitoring",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Users implementing error monitoring interceptors can understand that signal handlers don't require panic/error capture since they operate via channels.",
      "rootCause": "User misunderstanding about how signal handlers work internally - signals are processed through channels and don't directly panic",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Resolved as not applicable after clarification that signal handlers operate via channels and don't panic, so panic capture is unnecessary",
      "related": [],
      "keyQuote": "Since signals are handled via channels in Go, user code can't really panic/error the interceptor signal handler unless it was a user-defined interceptor signal handler panicking downstream.",
      "number": 833,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:55.098Z"
    },
    {
      "summary": "Go SDK v1.15.0 is incompatible with temporal API v1.9.0 due to missing GetWorkerBuildIdOrdering method implementation. The issue was resolved by embedding UnimplementedWorkflowServiceServer to prevent new API changes from breaking older SDKs.",
      "category": "bug",
      "subcategory": "api-compatibility",
      "apis": [],
      "components": [
        "service_proxy",
        "workflow_service_server",
        "client"
      ],
      "concepts": [
        "versioning",
        "api-compatibility",
        "interface-implementation",
        "breaking-changes",
        "dependency-management"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to the latest temporal SDK cannot build their applications due to interface incompatibility with the latest API version.",
      "rootCause": "API v1.9.0 added GetWorkerBuildIdOrdering method to WorkflowServiceServer interface, but SDK v1.15.0's workflowServiceProxyServer implementation did not include this method.",
      "proposedFix": "Embed UnimplementedWorkflowServiceServer in the service proxy to automatically provide implementations for new API methods, preventing older SDKs from breaking with newer API versions.",
      "workaround": "Users can either downgrade the API dependency (go get go.temporal.io/api@v1.8.0) or use the master branch of the SDK (not recommended).",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by embedding UnimplementedWorkflowServiceServer to handle new API methods gracefully without requiring SDK updates.",
      "related": [],
      "keyQuote": "I think what I am going to do here is at least embed `UnimplementedWorkflowServiceServer` so that new APIs don't break older SDKs.",
      "number": 832,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:57.044Z"
    },
    {
      "summary": "SDK debug and error logs don't respect the logger from the interceptor chain, preventing users from adding custom fields (like trace IDs) to all workflow/activity execution logs. Users need a way to inject context-aware logging across all SDK-generated logs, not just user-initiated GetLogger calls.",
      "category": "feature",
      "subcategory": "logging-observability",
      "apis": [
        "GetLogger",
        "ExecuteActivity"
      ],
      "components": [
        "logger",
        "interceptor",
        "worker",
        "activity-executor"
      ],
      "concepts": [
        "logging",
        "observability",
        "context-aware",
        "tracing",
        "interceptor-chain",
        "log-fields"
      ],
      "severity": "medium",
      "userImpact": "Users cannot inject custom context (like trace IDs) into SDK-generated logs, limiting observability and incident response capabilities for distributed systems.",
      "rootCause": "SDK only invokes GetLogger on explicit user calls, not internally before emitting debug/error logs, so the interceptor chain cannot customize those logs.",
      "proposedFix": "Implement a ContextAwareLogger interface that SDK calls before each log statement, or invoke GetLogger internally at key logging points to apply interceptor customizations.",
      "workaround": "Provide custom logger at client level, though this cannot access workflow/activity context for request-scoped fields.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A common failure mode...is that a small number of top level requests will generate a large number of Go SDK generated error logs...We're looking for a way to quickly identify how many root/top level parent workflows are impacted",
      "number": 829,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:41.650Z"
    },
    {
      "summary": "Replaying workflows with local activities executed by interceptors causes panics due to missing interceptor execution during replay. The replayer does not run worker interceptors, leading to event mismatches between recording and replay.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replayer",
        "interceptors",
        "event-handlers",
        "decision-state-machine"
      ],
      "concepts": [
        "workflow-replay",
        "local-activities",
        "interceptors",
        "event-mismatch",
        "non-determinism",
        "scheduling"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely replay workflows that use local activities called by interceptors, causing production issues when re-hydrating workflow instances from recorded events.",
      "rootCause": "The WorkflowReplayer does not run worker interceptors, causing a mismatch between the events recorded during original execution (with interceptor modifications) and the replayed execution.",
      "proposedFix": "Add SetWorkerInterceptors method to WorkflowReplayer to allow interceptors to be executed during replay, ensuring event consistency.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented SetWorkerInterceptors method for WorkflowReplayer to ensure interceptors are executed during replay, matching the original execution behavior.",
      "related": [],
      "keyQuote": "The replayer does not run interceptors. I will add worker.WorkflowReplayer.SetWorkerInterceptors([]WorkerInterceptor) which should be fairly easy.",
      "number": 828,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:39.582Z"
    },
    {
      "summary": "Dependency security vulnerability in go-yaml (transitive dependency via testify v1.7.0) with CVE-2022-28948 causing potential DoS through YAML deserialization crashes. Issue was automatically closed after the vulnerable library was removed from the inventory.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "yaml-parser",
        "testing-framework"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "yaml-deserialization",
        "dependency-chain",
        "cvss",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Users could experience DoS attacks through malicious YAML deserialization if the vulnerable go-yaml dependency is used in their applications.",
      "rootCause": "An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.",
      "proposedFix": "Upgrade go-yaml to version 3.0.0 or later",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or no longer part of the Mend inventory, indicating the vulnerability was resolved.",
      "related": [],
      "keyQuote": "An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.",
      "number": 827,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:37.234Z"
    },
    {
      "summary": "Compilation error due to missing GetNamespace field in ScheduleActivityTaskCommandAttributes when using api v1.8.0 with sdk v1.14.0. The field was removed in a recent api commit, causing a version mismatch between sdk and api dependencies.",
      "category": "bug",
      "subcategory": "dependency-mismatch",
      "apis": [],
      "components": [
        "command",
        "ScheduleActivityTaskCommandAttributes",
        "dependency-management"
      ],
      "concepts": [
        "version-mismatch",
        "api-compatibility",
        "compilation-error",
        "dependency-versioning"
      ],
      "severity": "high",
      "userImpact": "Users cannot compile their code when they update the api dependency to v1.8.0 without updating the sdk to v1.15.0 or later.",
      "rootCause": "The Namespace field (field number 3) was removed from ScheduleActivityTaskCommandAttributes in api v1.8.0, but sdk v1.14.0 and earlier still referenced it, creating an incompatibility.",
      "proposedFix": "Upgrade sdk to v1.15.0 which is compatible with api v1.8.0.",
      "workaround": "Keep api at v1.7.1 until upgrading sdk, or use older sdk versions.",
      "resolution": "fixed",
      "resolutionDetails": "SDK v1.15.0 was released with support for api v1.8.0, resolving the compilation error.",
      "related": [],
      "keyQuote": "I am releasing a new Go SDK version today or tomorrow that works properly with 1.8.0 of that library.",
      "number": 825,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:20.992Z"
    },
    {
      "summary": "The OnFatalError callback in worker.Options was not being invoked for users calling worker.Start() directly, only for worker.Run(). This fix ensures the callback is properly triggered in both code paths.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [
        "worker.Start",
        "worker.Run",
        "worker.Options.OnFatalError"
      ],
      "components": [
        "worker",
        "error-handling",
        "lifecycle-management"
      ],
      "concepts": [
        "callback-invocation",
        "fatal-errors",
        "error-propagation",
        "worker-initialization"
      ],
      "severity": "medium",
      "userImpact": "Users who rely on OnFatalError callback for error handling will not receive notifications when using worker.Start() instead of worker.Run().",
      "rootCause": "The OnFatalError callback implementation was incomplete, only being invoked in the worker.Run() code path but not in worker.Start().",
      "proposedFix": "Ensure the OnFatalError callback is invoked consistently for both worker.Start() and worker.Run() code paths and add tests to verify the behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The callback invocation was properly implemented for both worker.Start() and worker.Run() paths with appropriate test coverage.",
      "related": [
        800
      ],
      "keyQuote": "Make sure that callback is invoked for those using worker.Start() too and test it.",
      "number": 822,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:21.158Z"
    },
    {
      "summary": "Workflow with cron scheduler fails with 'Attempt to generate a command before processing WorkflowTaskStarted event' error when executing activities. User gets panic on cron-scheduled execution but same workflow runs fine when started manually.",
      "category": "bug",
      "subcategory": "cron-scheduling",
      "apis": [
        "ExecuteActivity",
        "WithActivityOptions",
        "NewFuture",
        "Go"
      ],
      "components": [
        "workflow-executor",
        "command-state-machine",
        "event-handler",
        "cron-scheduler"
      ],
      "concepts": [
        "cron-scheduling",
        "activity-execution",
        "event-replay",
        "workflow-state",
        "timing-issue"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably execute activities within cron-scheduled workflows, limiting the ability to run periodic background tasks.",
      "rootCause": "Attempt to generate workflow commands before the WorkflowTaskStarted event has been processed during cron execution. Possible timing or state initialization issue specific to cron-triggered runs versus manual starts.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Issue closed due to lack of reproduction steps. User provided workflow code but not complete runnable example needed to debug.",
      "related": [
        678
      ],
      "keyQuote": "Attempt to generate a command before processing WorkflowTaskStarted event",
      "number": 821,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:25.316Z"
    },
    {
      "summary": "The workflow static analyzer tool incorrectly raises a non-deterministic error when using workflow.AwaitWithTimeout in workflows. This causes false positive warnings that prevent valid code from passing analysis.",
      "category": "bug",
      "subcategory": "static-analysis",
      "apis": [
        "workflow.AwaitWithTimeout"
      ],
      "components": [
        "static-analyzer",
        "workflow-runtime"
      ],
      "concepts": [
        "timeout",
        "determinism",
        "static-analysis",
        "validation",
        "error-reporting"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use workflow.AwaitWithTimeout without triggering false warnings from the static analyzer, blocking valid workflow implementations.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Looks as static analyzer raises an error on: isNotTimeout, err := workflow.AwaitWithTimeout( ctx, content.ApprovalExpiration, submitSelector.HasPending)",
      "number": 818,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:07.476Z"
    },
    {
      "summary": "Dependency vulnerability in go-yaml/yaml v2.4.0 with CVE-2022-28948 causing denial of service through crash when deserializing invalid input. Fixed by upgrading to v3.0.0.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "yaml-parser",
        "unmarshaling",
        "dependency-management"
      ],
      "concepts": [
        "vulnerability",
        "denial-of-service",
        "deserialization",
        "dependency-upgrade",
        "cvss-7.5"
      ],
      "severity": "high",
      "userImpact": "Applications using the SDK could crash when processing malformed YAML data, resulting in service unavailability.",
      "rootCause": "An issue in the Unmarshal function in Go-Yaml v2.4.0 causes crashes when deserializing invalid input.",
      "proposedFix": "Upgrade github.com/go-yaml/yaml from v2.4.0 to v3.0.0",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The vulnerable library was either marked as ignored or removed from the dependency inventory, and the issue was automatically closed by Mend.",
      "related": [],
      "keyQuote": "An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.",
      "number": 817,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:04.324Z"
    },
    {
      "summary": "Investigation into unit testing child workflows that signal their parent workflow. The issue questioned whether parent execution info was properly accessible in unit tests and requested either support for parent workflow signaling or a way to configure parent execution info for testing.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowInfo.ParentExecution",
        "SignalExternalWorkflow",
        "ExecuteChildWorkflow",
        "GetSignalChannel"
      ],
      "components": [
        "test-suite",
        "workflow-execution",
        "signal-handling",
        "child-workflow"
      ],
      "concepts": [
        "parent-child-workflows",
        "signal-routing",
        "unit-testing",
        "workflow-context",
        "external-signals"
      ],
      "severity": "low",
      "userImpact": "Users testing child workflows that signal their parents may struggle to set up proper test scenarios without a clear mechanism to configure parent execution info.",
      "rootCause": null,
      "proposedFix": "Investigate and implement support for parent workflow signaling in unit tests, or provide a way to set parent execution info in the test environment.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Author confirmed that a provided test case demonstrates the functionality works as intended. The original issue was determined to be unrelated to a framework limitation and was caused by user code.",
      "related": [],
      "keyQuote": "Confirmed with user this is was an unrelated issue with their code",
      "number": 816,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:38:07.835Z"
    },
    {
      "summary": "Workflow replay fails when a workflow is terminated because the SDK lacks a switch case for the WORKFLOW_EXECUTION_TERMINATED event type. The termination event is not handled, causing the replayer to fail.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "event-handlers",
        "replayer",
        "workflow-execution"
      ],
      "concepts": [
        "event-handling",
        "workflow-termination",
        "replay",
        "state-machine",
        "event-processing"
      ],
      "severity": "high",
      "userImpact": "Users cannot replay workflows that were terminated, making it impossible to use the replayer for testing or debugging terminated workflows.",
      "rootCause": "Missing switch case for EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED in the event handler (internal_event_handlers.go line 810)",
      "proposedFix": "Add a switch case for EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED event type, similar to how continue-as-new events are handled",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Switch case for workflow execution terminated event was added to the event handlers",
      "related": [],
      "keyQuote": "We don't have a switch case for EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED so running in replayer causes failure",
      "number": 815,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:49.399Z"
    },
    {
      "summary": "workflowcheck tool fails to detect deadlocks and non-deterministic code violations when workflows contain sleep calls or other blocking operations. The tool should catch these violations but currently passes without errors, potentially masking runtime issues.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "workflowcheck",
        "workflow-engine",
        "history-matching"
      ],
      "concepts": [
        "deadlock-detection",
        "non-determinism",
        "goroutine",
        "blocking-operations",
        "workflow-validation",
        "deterministic-execution"
      ],
      "severity": "high",
      "userImpact": "Developers cannot rely on workflowcheck to catch non-deterministic or blocking code in workflows, leading to runtime failures that pass static checks.",
      "rootCause": "workflowcheck does not properly detect blocking operations like time.Sleep that are outside Temporal-controlled runtime, and the history matching logic ignores non-event operations.",
      "proposedFix": null,
      "workaround": "Use RegisterWorkflow as the entry point for workflowcheck analysis to catch issues, though this does not fully solve the detection problem.",
      "resolution": "fixed",
      "resolutionDetails": "Discussion clarified that sleep/print operations outside Temporal-controlled runtime are the issue. The tool limitations were acknowledged and the expected behavior of workflow validation was explained.",
      "related": [],
      "keyQuote": "Workflow code is expected to run until all coroutines are yielded in a couple of milliseconds. This is important to worker scaling and replaying.",
      "number": 814,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:52.308Z"
    },
    {
      "summary": "A workflow task failure occurs after a schedule-to-start timeout, causing an 'activity ID not found' panic that retries 13,000+ times before mysteriously succeeding. The issue is difficult to reproduce and occurs across multiple workers despite identical binary checksums.",
      "category": "bug",
      "subcategory": "workflow-task-processing",
      "apis": [],
      "components": [
        "workflow-task-processor",
        "activity-executor",
        "retry-logic",
        "worker"
      ],
      "concepts": [
        "timeout",
        "retry",
        "activity-resolution",
        "workflow-task-failure",
        "race-condition",
        "distributed-timing"
      ],
      "severity": "high",
      "userImpact": "Users experience unpredictable workflow task failures with excessive retry attempts (13K+) that eventually succeed, causing delays and operational uncertainty.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "After about 13K retry attempts, it magically succeed eventually. The binary checksum is the same before and after the failure.",
      "number": 813,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:47.730Z"
    },
    {
      "summary": "User requests changes to the OnUpsertSearchAttributes hook in TestWorkflowEnvironment to accept interface{} instead of map[string]interface{}, similar to OnActivity, to enable better mock argument matching and recording in workflow tests.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "UpsertSearchAttributes"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "test-hooks",
        "mock-framework"
      ],
      "concepts": [
        "search-attributes",
        "testing",
        "mock-matching",
        "deterministic-replay",
        "test-utilities"
      ],
      "severity": "low",
      "userImpact": "Users cannot use standard mock matching patterns like mock.Anything with OnUpsertSearchAttributes due to its specific map[string]interface{} signature.",
      "rootCause": "OnUpsertSearchAttributes signature differs from OnActivity by accepting map[string]interface{} instead of interface{}, preventing flexible mock argument matching.",
      "proposedFix": "Change OnUpsertSearchAttributes parameter type from map[string]interface{} to interface{} to match OnActivity's signature.",
      "workaround": "Users can attempt to match with specific keys and mock.Anything values, though this was reported as not working effectively.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I would like a way to use OnUpsertSearchAttributes or some other similar hook more like OnActivity.",
      "number": 810,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:31.221Z"
    },
    {
      "summary": "User requests new APIs ReplayWorkflowHistoryFromReader and ReplayPartialWorkflowHistoryFromReader to support reading replay histories from io.Reader sources, enabling use cases like go:embed, remote storage, and gzipped files.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowHistoryFromReader",
        "ReplayPartialWorkflowHistoryFromReader"
      ],
      "components": [
        "WorkflowReplayer",
        "replay-api",
        "test-framework"
      ],
      "concepts": [
        "replay",
        "testing",
        "history-streaming",
        "embedded-files",
        "flexible-storage"
      ],
      "severity": "low",
      "userImpact": "Users testing workflows with go:embed or alternative replay history sources must manually parse JSON or implement their own reader abstraction.",
      "rootCause": null,
      "proposedFix": "Add ReplayWorkflowHistoryFromReader(logger log.Logger, jsonFile io.Reader) error and ReplayPartialWorkflowHistoryFromReader methods to the WorkflowReplayer interface",
      "workaround": "Users can use bytes.NewReader to wrap []byte or manually parse history from custom sources",
      "resolution": "fixed",
      "resolutionDetails": "Maintainer agreed to implement reader-based APIs using io.Reader parameter, including both full and partial replay variants",
      "related": [],
      "keyQuote": "Add `ReplayWorkflowHistoryFromReader` to enable use cases like go:embed, remote server storage, or gzipped histories",
      "number": 808,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:32.514Z"
    },
    {
      "summary": "User requested support for testing workflows that use `ContinueAsNewError` by adding an `EnableRunContinueAsNew` option to `TestWorkflowEnvironment` that would restart the workflow instead of returning the error.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ContinueAsNewError"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-testing",
        "continue-as-new"
      ],
      "concepts": [
        "testing",
        "unit-testing",
        "continue-as-new",
        "workflow-execution",
        "child-workflows",
        "integration-testing"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily unit test workflows that rely on `ContinueAsNewError` for multi-run behavior without setting up full integration tests.",
      "rootCause": "The test suite represents a single workflow run and does not support simulating multi-run scenarios triggered by `ContinueAsNewError`.",
      "proposedFix": "Add an `EnableRunContinueAsNew` method to `TestWorkflowEnvironment` to execute the workflow instead of returning the error.",
      "workaround": "Use integration testing with a full Temporal server setup or mock child workflows with `env.OnWorkflow`.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer clarified that unit tests should test single runs, not multi-run scenarios. Multi-run testing is better suited for integration tests with `temporalite/temporaltest`.",
      "related": [],
      "keyQuote": "The workflow unit test represents a single run, not multiple (be it by retry, continue as new, cron, etc).",
      "number": 805,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:34.657Z"
    },
    {
      "summary": "User asks how to extract trace IDs from workflow context for logging purposes, similar to how it's done in activities. The issue discusses the limitation that span context storage uses non-exported struct keys in the SDK.",
      "category": "question",
      "subcategory": "tracing-instrumentation",
      "apis": [
        "GetInfo"
      ],
      "components": [
        "workflow-context",
        "interceptor",
        "tracing"
      ],
      "concepts": [
        "tracing",
        "span-context",
        "logging",
        "instrumentation",
        "observability",
        "context-propagation"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily extract trace IDs from workflow context for structured logging, limiting observability in distributed tracing scenarios.",
      "rootCause": "Span context is stored in a non-exported struct key in the workflow context, making it inaccessible to users without SDK modifications.",
      "proposedFix": "Set a custom value via TracerOptions.SpanContextKey to access span information, or pass custom info through context and workflow.GetInfo().",
      "workaround": "Use TracerOptions.SpanContextKey with a custom value to extract span context, or implement custom context propagation instead of relying on span info.",
      "resolution": "answered",
      "resolutionDetails": "SDK maintainer provided guidance on using TracerOptions.SpanContextKey for custom span extraction and recommended alternative approaches for propagating trace information.",
      "related": [],
      "keyQuote": "You may set `TracerOptions.SpanContextKey` to a custom value of your choice and then use that value to extract the span out of the context.",
      "number": 804,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:15.967Z"
    },
    {
      "summary": "MutableSideEffect fails during workflow replay with payload decoding errors. The function works initially but crashes when workers are restarted and workflows are replayed, due to double-base64 encoding and improper command counter management during deterministic replay.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "MutableSideEffect"
      ],
      "components": [
        "workflow-engine",
        "side-effect-handler",
        "command-counter",
        "payload-encoding"
      ],
      "concepts": [
        "determinism",
        "replay",
        "command-ordering",
        "marker-recording",
        "callback-equality"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably use MutableSideEffect across worker restarts, as workflow replay causes panics and prevents workflow execution from completing.",
      "rootCause": "Two issues: (1) double-base64 encoding of payloads from history wrapping without proper unwrapping; (2) command counter mismatch during replay - markers are not recorded when mutable side effect results are equal during normal execution, but the SDK cannot determine equality during replay, causing the counter to diverge and break command IDs for subsequent operations like timers.",
      "proposedFix": "Use marker lookahead during replay to determine whether a marker was recorded, allowing proper command counter synchronization regardless of callback result equality.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed using marker lookahead to properly handle command counter during replay by checking history to determine if markers were recorded.",
      "related": [
        151
      ],
      "keyQuote": "mutable side effects have never worked properly during replay... we need to know if we should record a command or not, and if we don't get it right, the command counter mismatches",
      "number": 803,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:19.366Z"
    },
    {
      "summary": "Logs are not being propagated to OpenTracing spans when tracing is enabled in the Go SDK. The tracingWorkflowOutboundInterceptor ignores the TracerSpanRef parameter when calling GetLogger, causing logs to lose their tracing context.",
      "category": "bug",
      "subcategory": "tracing-opentracing",
      "apis": [
        "GetLogger"
      ],
      "components": [
        "interceptor",
        "tracing-interceptor",
        "tracer"
      ],
      "concepts": [
        "tracing",
        "opentracing",
        "spans",
        "logging",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Users enabling OpenTracing cannot see workflow logs in their traces, limiting observability and debugging capabilities.",
      "rootCause": "The BaseTracer.GetLogger() method intentionally does not apply logs to traces by default, as the feature was designed to be opt-in via custom tracer implementations.",
      "proposedFix": "Implement a custom tracer that overrides GetLogger to provide tracing-enabled logging, as mentioned in the default interceptor design.",
      "workaround": "Users can implement their own interceptor.Tracer wrapping/delegating to existing ones and provide a custom GetLogger implementation that attaches logs to traces.",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainer clarified this is intentional design - the default implementation does not attach logs to traces by default. Users needing this feature should implement a custom tracer.",
      "related": [
        655
      ],
      "keyQuote": "The default implementation of GetLogger intentionally does not apply logs to the trace... if this is important for you, you can implement your own tracer",
      "number": 802,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:18.663Z"
    },
    {
      "summary": "ApplicationError does not expose the raw error message; calling .Error() adds formatting details (error type and non-retryable status). User needs access to the raw message to pass to the UI.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "ApplicationError"
      ],
      "components": [
        "error-types",
        "application-error",
        "worker"
      ],
      "concepts": [
        "error-message",
        "error-wrapping",
        "error-formatting",
        "unwrap",
        "raw-error"
      ],
      "severity": "medium",
      "userImpact": "Users cannot retrieve the clean raw error message from ApplicationError without additional formatting, making it difficult to display errors in user-facing UIs.",
      "rootCause": "ApplicationError's Error() method adds formatting with type and non-retryable information; private message() method prevents direct access.",
      "proposedFix": "Expose the raw error message through a public method or ensure proper Unwrap() convention support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved in #766, merged to master before the next release.",
      "related": [
        766
      ],
      "keyQuote": "I need the raw error message from the Application Error to pass it on to the UI.",
      "number": 797,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:00.381Z"
    },
    {
      "summary": "Increase the default gRPC maximum message size to 128MB in the Go SDK to align with other Temporal SDKs.",
      "category": "feature",
      "subcategory": "grpc-configuration",
      "apis": [],
      "components": [
        "grpc",
        "client-configuration"
      ],
      "concepts": [
        "message-size",
        "protocol-buffers",
        "sdk-consistency",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to send larger workflow/activity payloads without hitting gRPC message size limits, matching behavior in other SDKs.",
      "rootCause": null,
      "proposedFix": "Change the default gRPC max message size parameter to 128MB",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Default gRPC max message size was updated to 128MB to match other SDKs",
      "related": [],
      "keyQuote": "Matches other SDKs",
      "number": 794,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:00.709Z"
    },
    {
      "summary": "Redesign client initialization to support lazy connectivity. Deprecate NewClient in favor of explicit Dial (eager) and NewLazyClient (lazy) constructors, with server capabilities fetched on-demand and a new CheckHealth method for health verification.",
      "category": "feature",
      "subcategory": "client-initialization",
      "apis": [
        "NewClient",
        "Dial",
        "NewLazyClient",
        "CheckHealth"
      ],
      "components": [
        "client",
        "connection-management",
        "server-capabilities"
      ],
      "concepts": [
        "lazy-loading",
        "eager-connection",
        "server-capabilities",
        "health-check",
        "deprecation",
        "connectivity"
      ],
      "severity": "medium",
      "userImpact": "Users gain more control over client connection timing and can choose between eager and lazy initialization patterns to suit their application needs.",
      "rootCause": "NewClient unexpectedly performs server connectivity validation during construction, limiting flexibility for users who prefer lazy connection establishment.",
      "proposedFix": "Add DisableEagerConnection option to ConnectionOptions, introduce Dial and NewLazyClient constructors, implement lazy ensureServerCapabilitiesFetched, and add CheckHealth using gRPC health API.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed with client initialization refactored to support both eager and lazy connection patterns with on-demand capability fetching.",
      "related": [
        753,
        595,
        706
      ],
      "keyQuote": "Today we have NewClient which, possibly unexpectedly to users, does more than create a client, it also connects to the server to confirm all connectivity.",
      "number": 793,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:37:03.952Z"
    },
    {
      "summary": "Worker fatal errors currently kill the process without proper error handling or user notification. The request is to expose these errors through the Run call or add a WorkerFailureHandler option so users can handle errors without process termination.",
      "category": "feature",
      "subcategory": "worker-error-handling",
      "apis": [
        "Start",
        "Stop",
        "Run"
      ],
      "components": [
        "worker",
        "error-handling",
        "lifecycle"
      ],
      "concepts": [
        "error-propagation",
        "graceful-shutdown",
        "worker-failure",
        "process-lifecycle",
        "error-notification",
        "signal-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot properly handle fatal worker errors and are forced to deal with process termination, making it difficult to implement robust error handling in production systems.",
      "rootCause": "Non-retryable worker errors signal process termination instead of returning errors to the caller or providing a handler for them.",
      "proposedFix": "Expose fatal worker errors via the Run call, or add a WorkerFailureHandler option to allow users to handle errors without defaulting to process death.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We need to just stop the entire worker and relay the error. Right now, someone can Start and won't see an error until Stop is called.",
      "number": 792,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:44.254Z"
    },
    {
      "summary": "Users want to retrieve workflow results without automatically following to the next run when `new_execution_run_id` is set. This is particularly important for cron workflows where users may want to get results from an older run rather than the latest one.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowRun.Get",
        "WorkflowExecutionCompletedEventAttributes"
      ],
      "components": [
        "client",
        "workflow-run",
        "execution-history"
      ],
      "concepts": [
        "workflow-result",
        "run-following",
        "cron-jobs",
        "backwards-compatibility",
        "opt-out"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably retrieve results from older workflow runs in cron scenarios because the SDK automatically follows to newer runs.",
      "rootCause": null,
      "proposedFix": "Add an option to opt-out of automatic run-following behavior, similar to implementation in other language SDKs. The exact mechanism needs to be determined while maintaining backwards compatibility.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Enhancement was implemented to allow users to opt-out of following runs when retrieving workflow results.",
      "related": [],
      "keyQuote": "Allow users to opt-out of \"follow runs\" like we do in other languages.",
      "number": 789,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:44.942Z"
    },
    {
      "summary": "Documentation for workflow.GetLastError is inaccurate. It incorrectly describes the function as extracting the latest failure from any previous run, when it should only extract the latest failure if the last run failed. Clarification needed for GetLastCompletionResult and API proto documentation.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "GetLastError",
        "GetLastCompletionResult"
      ],
      "components": [
        "workflow-api",
        "documentation",
        "api-protos"
      ],
      "concepts": [
        "workflow-failure",
        "error-handling",
        "workflow-state",
        "run-history",
        "api-clarity"
      ],
      "severity": "medium",
      "userImpact": "Developers using GetLastError may misunderstand its behavior and incorrectly assume it retrieves errors from any previous run rather than only the last run.",
      "rootCause": "Documentation does not accurately reflect the actual behavior of GetLastError regarding which run's failure is returned.",
      "proposedFix": "Update documentation to clarify that GetLastError only extracts the latest failure if the last run failed, and update API protos with this information.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was corrected to accurately describe GetLastError behavior and GetLastCompletionResult semantics.",
      "related": [],
      "keyQuote": "GetLastError extracts the latest failure only if the last run failed. If it did not fail or there is not a last run, nil is returned.",
      "number": 786,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:47.823Z"
    },
    {
      "summary": "The task queue label is not being recorded on the temporal_worker_task_slots_available metric, preventing users from distinguishing metrics across different task queues.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "metrics"
      ],
      "concepts": [
        "metrics",
        "task-queue",
        "monitoring",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use task queue as a dimension in the temporal_worker_task_slots_available metric, limiting their ability to monitor worker capacity per queue.",
      "rootCause": "Task queue label is not being set when the metric is recorded.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Task queue label was added to the temporal_worker_task_slots_available metric.",
      "related": [],
      "keyQuote": "Expect worker task queue to be on `temporal_worker_task_slots_available` but it is not",
      "number": 784,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:32.356Z"
    },
    {
      "summary": "ReplayWorkflowExecution fails when workflow history spans multiple pages because pagination parameters are not properly utilized, causing 'extra replay command' errors.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowExecution"
      ],
      "components": [
        "worker",
        "history-pagination",
        "replay-engine"
      ],
      "concepts": [
        "pagination",
        "history-processing",
        "workflow-replay",
        "long-running-workflows",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably replay workflows with long execution histories, breaking testing and debugging workflows with multiple loop iterations.",
      "rootCause": "Pagination parameters in the request struct are defined but not used when fetching workflow history, causing incomplete history retrieval.",
      "proposedFix": "Implement proper pagination logic to handle multi-page workflow history retrieval in the ReplayWorkflowExecution code.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The bug was identified in internal_worker.go line 1121 and the workflowservice request struct, with pagination support added to properly handle long histories.",
      "related": [],
      "keyQuote": "We are not properly using pagination here and we should. I will fix this in short order.",
      "number": 781,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:29.280Z"
    },
    {
      "summary": "Activities invoked with a cancelled context in the test environment were not respecting cancellation properly. Mocked activities could fail to return values on cancellation, and activities called for cleanup would execute despite the context being cancelled.",
      "category": "bug",
      "subcategory": "activity-cancellation",
      "apis": [
        "ExecuteActivity",
        "RecordHeartbeat"
      ],
      "components": [
        "test-framework",
        "activity-executor",
        "cancellation-handler"
      ],
      "concepts": [
        "cancellation",
        "context",
        "heartbeat",
        "cleanup",
        "test-environment",
        "activity-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows with activity cancellation and cleanup logic may encounter unexpected behavior where cancelled activities don't return values or execute despite cancellation.",
      "rootCause": "Activities invoked with a cancelled context were being started even though the context was already cancelled, causing improper cancellation handling in the test environment.",
      "proposedFix": "Activities invoked with a cancelled context should not be started at all. PR #780 was merged to fix this behavior.",
      "workaround": "Activities must properly respect cancellation by heartbeating and checking context.Done(), and should use HeartbeatTimeout to avoid waiting for the default 15-second timeout.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #780 which ensures activities invoked with a cancelled context are not started.",
      "related": [
        780
      ],
      "keyQuote": "Activities invoked with a cancelled context should not be started. PR #780 addresses this issue.",
      "number": 778,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:31.655Z"
    },
    {
      "summary": "Dependency security vulnerability in golang/tools-v0.1.10 containing 3 jQuery XSS vulnerabilities (CVE-2020-11022, CVE-2015-9251, CVE-2012-6708) with CVSS 6.1 severity. Issue was automatically closed by Mend when the vulnerable dependency was removed from inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "golang-tools",
        "build-system"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "xss",
        "jquery",
        "dependency-upgrade",
        "cvss"
      ],
      "severity": "medium",
      "userImpact": "Users relying on the SDK with vulnerable golang/tools dependencies could be exposed to cross-site scripting attacks through multiple jQuery CVE vulnerabilities.",
      "rootCause": "golang/tools-v0.1.10 included vulnerable jQuery versions that had unpatched XSS vulnerabilities in DOM manipulation methods and cross-domain Ajax request handling.",
      "proposedFix": "Upgrade golang/tools to a version that includes patched jQuery dependencies (jQuery 3.5.0 or later for CVE-2020-11022, v3.0.0 or later for CVE-2015-9251, v1.9.0 or later for CVE-2012-6708).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was removed from the dependency inventory, indicating the dependency was upgraded or removed.",
      "related": [],
      "keyQuote": "This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.",
      "number": 777,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:16.585Z"
    },
    {
      "summary": "The golang.com/tools-v0.1.8 dependency contains 3 jQuery-related vulnerabilities (CVE-2020-11022, CVE-2015-9251, CVE-2012-6708) with CVSS scores of 6.1. This was an automated security alert that was auto-closed after the vulnerable library was removed from the WhiteSource inventory.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "build-system"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-update",
        "cross-site-scripting",
        "jquery",
        "transitive-dependency"
      ],
      "severity": "medium",
      "userImpact": "Applications using sdk-go with the vulnerable golang/tools dependency could be exposed to XSS attacks through jQuery vulnerabilities, though the practical impact depends on how the library is used.",
      "rootCause": "Transitive dependency on outdated jQuery versions bundled in golang/tools-v0.1.8 containing known XSS vulnerabilities",
      "proposedFix": "Upgrade golang/tools to a version that removes or updates the vulnerable jQuery dependency",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Auto-closed by WhiteSource because the vulnerable library was removed from the project or marked as ignored in the inventory",
      "related": [],
      "keyQuote": "This issue was automatically closed by WhiteSource because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the WhiteSource inventory.",
      "number": 775,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:18.464Z"
    },
    {
      "summary": "Memory leak occurs when a workflow is queried before being cached, causing the workflow to be reallocated on each query and accumulating goroutines. The issue is caused by intentional design where query-only tasks are not cached, combined with a goroutine leak in the query handling logic.",
      "category": "bug",
      "subcategory": "workflow-caching",
      "apis": [
        "SetQueryHandler",
        "GetSignalChannel"
      ],
      "components": [
        "worker",
        "task-handler",
        "workflow-cache",
        "goroutine-management"
      ],
      "concepts": [
        "memory-leak",
        "caching",
        "query-handling",
        "goroutine-leak",
        "workflow-allocation",
        "history-replay",
        "garbage-collection"
      ],
      "severity": "high",
      "userImpact": "Workflows queried repeatedly without prior cache initialization consume excessive memory, growing unbounded and requiring worker restarts to reclaim resources.",
      "rootCause": "Query-only tasks intentionally skip caching, requiring full history replay on each query. Additionally, a goroutine leak accumulates goroutines with each query execution.",
      "proposedFix": "Fix the goroutine leak in query handling (addressed in PR #779). Consider making query cache behavior configurable to allow opt-in caching for query-only tasks.",
      "workaround": "Either (1) disable workflow cache entirely with SetStickyWorkflowCacheSize(0), or (2) ensure first workflow interaction is a signal rather than a query to trigger caching.",
      "resolution": "fixed",
      "resolutionDetails": "PR #779 fixed the goroutine leak in query handling. Query-only task caching remains intentional design for side-effect-free queries.",
      "related": [
        779
      ],
      "keyQuote": "the memory is constantly rising with each query... I have opened a PR at #779 to fix the goroutine/mem leak that is occurring from queries over and over",
      "number": 774,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:18.222Z"
    },
    {
      "summary": "User encounters a deadlock error when using `time.Sleep()` in a workflow with a cron schedule. The error 'deadlock detected: workflow goroutine \"root\" didn't yield for over a second' occurs because blocking operations are not allowed in Temporal workflows.",
      "category": "question",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteWorkflow",
        "RegisterWorkflow"
      ],
      "components": [
        "workflow-executor",
        "goroutine-scheduler"
      ],
      "concepts": [
        "deadlock",
        "blocking-operations",
        "time-sleep",
        "workflow-constraints",
        "cron-schedule",
        "goroutine-yield"
      ],
      "severity": "medium",
      "userImpact": "Users who attempt to use standard blocking operations like `time.Sleep()` in workflows encounter runtime deadlock errors that halt execution.",
      "rootCause": "The user is using `time.Sleep()` which is a blocking operation that violates Temporal workflow constraints requiring non-blocking code.",
      "proposedFix": null,
      "workaround": "Use workflow-safe timing functions instead of `time.Sleep()`, such as `workflow.Sleep()` or other time-based operations provided by the Temporal SDK.",
      "resolution": "invalid",
      "resolutionDetails": "The issue was user error - calling blocking `time.Sleep()` in a workflow context. The maintainer provided documentation links explaining workflow logic requirements.",
      "related": [],
      "keyQuote": "You cannot sleep in workflows using `time.Sleep`. Please see https://docs.temporal.io/docs/go/how-to-develop-a-workflow-definition-in-go#workflow-logic-requirements-in-go",
      "number": 773,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:00.010Z"
    },
    {
      "summary": "Data converters used in workflows are constrained by Temporal's deadlock detection timeout. Advanced use cases need the ability to perform data conversion outside this constraint, potentially by measuring conversion time and adjusting the deadlock detector timeout accordingly.",
      "category": "feature",
      "subcategory": "data-conversion",
      "apis": [],
      "components": [
        "data-converter",
        "deadlock-detector",
        "workflow-execution"
      ],
      "concepts": [
        "data-conversion",
        "deadlock-detection",
        "timeout",
        "performance",
        "constraint"
      ],
      "severity": "medium",
      "userImpact": "Users with advanced data converter implementations that need flexibility from deadlock detection constraints are unable to optimize their use cases.",
      "rootCause": "Data conversion is performed within the workflow deadlock detection scope, which applies Temporal's workflow deadlock timeout rules to conversion operations.",
      "proposedFix": "Measure time spent in DataConverter and extend the deadlock detector timeout by this value, or implement a timer that can be stopped and started again.",
      "workaround": "Measure conversion time and compensate the deadlock detector timeout.",
      "resolution": "fixed",
      "resolutionDetails": "Implementation decided on measuring time spent in DataConverter and adjusting the deadlock detector timeout accordingly.",
      "related": [],
      "keyQuote": "Some advanced use cases of workflow data converters do not want to be bound to Temporal workflow deadlock rules",
      "number": 769,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:03.211Z"
    },
    {
      "summary": "User wants to add SetOnActivityHeartbeatListener method to TestActivityEnvironment, similar to the functionality available in workflow environment for testing purposes.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "TestActivityEnvironment"
      ],
      "components": [
        "test-framework",
        "activity-executor",
        "testing-utilities"
      ],
      "concepts": [
        "heartbeat",
        "testing",
        "listener",
        "activity-environment",
        "test-setup"
      ],
      "severity": "low",
      "userImpact": "Users testing activities cannot simulate and verify heartbeat listener behavior, limiting test coverage.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "SetOnActivityHeartbeatListener was added to TestActivityEnvironment API",
      "related": [],
      "keyQuote": "Should be able to have heartbeat listener in activity environment same as in workflow environment",
      "number": 768,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:36:01.323Z"
    },
    {
      "summary": "workflowcheck tool hangs indefinitely when analyzing workflow code that uses text/template, due to the tool's non-determinism analysis following recursive function calls through the template package.",
      "category": "bug",
      "subcategory": "workflowcheck-tool",
      "apis": [],
      "components": [
        "workflowcheck",
        "determinism-analyzer",
        "template-package"
      ],
      "concepts": [
        "non-determinism",
        "infinite-loop",
        "static-analysis",
        "reflection",
        "concurrency"
      ],
      "severity": "high",
      "userImpact": "Developers cannot use text/template in workflows as workflowcheck hangs when analyzing such code, preventing validation of workflow determinism.",
      "rootCause": "The workflowcheck tool's non-determinism analysis recursively follows function calls through text/template and reflect packages, hitting sync.Map iteration which causes infinite loop or excessive analysis on certain platforms (Linux/macOS).",
      "proposedFix": null,
      "workaround": "Remove or comment out text/template usage before running workflowcheck.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by improving the non-determinism detection in workflowcheck to handle reflection and template package calls more efficiently without infinite recursion.",
      "related": [],
      "keyQuote": "calls non-deterministic function (*sync.Map).dirtyLocked - iterates over map",
      "number": 767,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:47.649Z"
    },
    {
      "summary": "Request to add built-in helpers for workflow.NewUUID() and workflow.NewRandom() to make it more convenient for workflow developers. Declined because the SDKs use deterministic seeded pseudorandom instead of side effects, and adding these helpers would codify API differences across SDKs without consensus.",
      "category": "feature",
      "subcategory": "workflow-utilities",
      "apis": [],
      "components": [
        "workflow",
        "uuid-generation",
        "randomness"
      ],
      "concepts": [
        "determinism",
        "side-effects",
        "uuid",
        "randomness",
        "sdk-consistency",
        "convenience"
      ],
      "severity": "low",
      "userImpact": "Developers currently need to use side effects or implement their own logic for UUID and random number generation in workflows.",
      "rootCause": "API design inconsistency: Go SDK uses side effects while other SDKs use deterministic seeded pseudorandom generation",
      "proposedFix": "Add built-in workflow.NewUUID() and workflow.NewRandom() helper functions",
      "workaround": "Use side effects or manually implement deterministic random generation with math/rand.NewSource()",
      "resolution": "wontfix",
      "resolutionDetails": "Closed as the proposed one-line helpers don't add significant value. Other SDKs use deterministic pseudorandom without side effects, and adding Go-specific helpers would codify API differences without SDK consensus.",
      "related": [
        765
      ],
      "keyQuote": "we fear codifying the difference in API... we encourage use of side effects... but this isn't what we're doing in other SDKs",
      "number": 764,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:46.430Z"
    },
    {
      "summary": "Users request exposure of the raw message string from ApplicationError without the additional formatting that Error() method appends. The feature request is for a method like RawMessage() to access just the core error message.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "error-handling",
        "ApplicationError"
      ],
      "concepts": [
        "error-message",
        "message-formatting",
        "error-details",
        "API-exposure",
        "user-facing-errors"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily access the raw error message from ApplicationError without parsing or unwrapping the formatted output.",
      "rootCause": null,
      "proposedFix": "Expose a RawMessage() method on ApplicationError to return the unformatted message string.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to expose the raw message from ApplicationError.",
      "related": [],
      "keyQuote": "Some users want the string message without the things appended that Error() has",
      "number": 758,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:48.053Z"
    },
    {
      "summary": "Sticky queries can fail with invalid state machine transitions when the workflow cache is evicted on the server but the SDK rebuilds history that has since advanced beyond the original query's previousStartedEventID, causing outdated replay mode calculations.",
      "category": "bug",
      "subcategory": "query-execution",
      "apis": [],
      "components": [
        "query-handler",
        "state-machine",
        "workflow-executor",
        "history-retrieval"
      ],
      "concepts": [
        "state-transition",
        "replay-mode",
        "workflow-cache",
        "event-history",
        "previousStartedEventID",
        "cache-eviction",
        "consistency"
      ],
      "severity": "high",
      "userImpact": "Sticky query operations fail with cryptic state machine errors when server loses workflow cache but SDK cache is also evicted, making some queries unreliable.",
      "rootCause": "When a sticky query is dispatched but the SDK has lost the workflow cache, getWorkflowExecutionHistory is called to rebuild state. If history advances between query dispatch and retrieval, the previousStartedEventID becomes outdated, causing the state machine to attempt invalid transitions during replay.",
      "proposedFix": "Three approaches proposed: (1) Process all events in replay mode for query tasks (SDK-only), (2) Include nextEventID in query task and truncate history (requires server change, implemented in Cadence), (3) Have getWorkflowExecutionHistory return previousStartedEventID (requires server change).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Existing SDK implementation will continue to use that outdated previousStartedEventID to run the query task and this will lead to invalid state transition error.",
      "number": 755,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:31.501Z"
    },
    {
      "summary": "Need to create an integration/end-to-end test for the gRPC proxy that uses a custom codec/converter with both client and worker to run a workflow.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "grpc-proxy",
        "codec",
        "converter",
        "integration-tests"
      ],
      "concepts": [
        "testing",
        "integration-test",
        "grpc-proxy",
        "custom-codec",
        "end-to-end-test"
      ],
      "severity": "medium",
      "userImpact": "Users need test coverage to ensure gRPC proxy works correctly with custom codecs/converters.",
      "rootCause": null,
      "proposedFix": "Create test in test/integration_test.go that uses a proxy and custom codec/converter for both client and worker to run a workflow",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Create test (maybe in `test/integration_test.go`) that uses a proxy and a custom codec/converter for both the client and worker to run a workflow.",
      "number": 754,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:31.501Z"
    },
    {
      "summary": "SDK removed lazy connection capability in v1.14.0 when getCapabilities call was added during client creation. User requests restoration of lazy connection option to prevent blocking service startup during deploy/scale events when Temporal server is unavailable.",
      "category": "feature",
      "subcategory": "client-connection",
      "apis": [
        "NewClient"
      ],
      "components": [
        "client",
        "connection-manager",
        "capabilities-check"
      ],
      "concepts": [
        "lazy-loading",
        "connection-initialization",
        "fail-fast",
        "startup-blocking",
        "service-reliability"
      ],
      "severity": "high",
      "userImpact": "Services cannot tolerate blocking on Temporal server connection during startup, causing service failures during deploy/scale events when multiple dependencies exist.",
      "rootCause": "The mandatory getCapabilities call during client creation in v1.14.0 forces eager connection, removing the ability to defer connection until first use.",
      "proposedFix": "Each call on the client should check connection status and use a mutex to create connection lazily before allowing operations to proceed.",
      "workaround": "Duplicate the entire client interface in the application to wrap calls with lazy connection logic, or implement a separate factory pattern with explicit GetConnection() call.",
      "resolution": "fixed",
      "resolutionDetails": "Internal discussion concluded that moving to lazy connection model was the right approach across languages.",
      "related": [],
      "keyQuote": "Fail fast in a critical application with multiple concerns is a non-starter. It can block and bring an entire service down during a deploy, scale up, or other lifecycle event",
      "number": 753,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:34.151Z"
    },
    {
      "summary": "Go SDK metrics need to be reformatted to comply with OpenMetrics specification to achieve consistency with Java SDK, requiring counter metrics to have `_total` suffix and timer metrics to have `_seconds` suffix before bucket/count suffixes.",
      "category": "other",
      "subcategory": "metrics-format",
      "apis": [],
      "components": [
        "metrics-exporter",
        "prometheus-registry",
        "telemetry"
      ],
      "concepts": [
        "metrics-naming",
        "openmetrics-compliance",
        "prometheus-format",
        "standardization",
        "backwards-compatibility",
        "dashboard-unification"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use unified dashboards and Grafana queries across Go and Java SDKs due to inconsistent metrics naming conventions.",
      "rootCause": "Go SDK uses Prometheus naming conventions that differ from OpenMetrics specification, while Java SDK is already compliant.",
      "proposedFix": "Expose corrected metrics in addition to old format, or provide opt-in configuration option for new format to maintain backwards compatibility.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating metrics were likely synchronized with OpenMetrics standard.",
      "related": [],
      "keyQuote": "Temporal GoSDK should issue metrics in compliance with OpenMetrics specification to allow having a single dashboard and set of Grafana queries for both Java and Go SDKs.",
      "number": 750,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:17.243Z"
    },
    {
      "summary": "Activity cancellation in workflows causes a panic with \"lookup failed for scheduledEventID to activityID\" error since version 1.13.1. The issue occurs when canceling activities within a signal handler, leading to a mismatch between scheduled event IDs and activity IDs.",
      "category": "bug",
      "subcategory": "activity-cancellation",
      "apis": [
        "WithCancel",
        "Go"
      ],
      "components": [
        "activity-executor",
        "event-scheduler",
        "workflow-context"
      ],
      "concepts": [
        "activity-cancellation",
        "event-id-mismatch",
        "panic-recovery",
        "non-determinism",
        "workflow-signals"
      ],
      "severity": "high",
      "userImpact": "Workflows panic and crash when users attempt to cancel running activities, preventing proper activity lifecycle management.",
      "rootCause": "Non-deterministic behavior or event ID mismatch in the activity scheduling and cancellation logic introduced in version 1.13.1.",
      "proposedFix": "Fixed by PR #741 which addresses the event ID lookup issue in activity cancellation.",
      "workaround": "Upgrade to the master branch or wait for the release containing PR #741; ensure workflow implementation is deterministic.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by PR #741 which fixed the event ID lookup problem. Maintainers also noted that non-determinism in workflows can cause similar issues.",
      "related": [
        741
      ],
      "keyQuote": "lookup failed for scheduledEventID to activityID: scheduleEventID: 197, activityID: 196",
      "number": 747,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:19.239Z"
    },
    {
      "summary": "Concurrent map writes occur during deferred disconnected context cancellation in the Go SDK, causing fatal runtime errors under high load. The issue manifests as a race condition during activity cancellation when context cleanup happens concurrently with command state machine operations.",
      "category": "bug",
      "subcategory": "concurrency-race-condition",
      "apis": [
        "RequestCancelActivity"
      ],
      "components": [
        "context",
        "command-state-machine",
        "activity-executor",
        "workflow-dispatcher"
      ],
      "concepts": [
        "concurrent-map-writes",
        "race-condition",
        "context-cancellation",
        "goroutine-safety",
        "deferred-cleanup"
      ],
      "severity": "critical",
      "userImpact": "Production workflows fail with fatal errors under load due to concurrent map access during activity cancellation.",
      "rootCause": "Workflow cache eviction logic caused race conditions between goroutines accessing the commands map during context cleanup, particularly in NewDisconnectedContext deferred cleanup during activity cancellation.",
      "proposedFix": "Implement proper synchronization in the workflow cache eviction mechanism to prevent concurrent access to the commands map during cleanup operations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Root cause identified as workflow cache eviction race condition (issue #1209). Fixed in Go SDK 1.25.1 with additional follow-up work in issues #1270 and #1235.",
      "related": [
        721,
        1209,
        1240,
        1270,
        1235
      ],
      "keyQuote": "The root cause was actually a race due to how the SDK evicts workflows from cache",
      "number": 743,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:17.716Z"
    },
    {
      "summary": "Documentation for Client.ListWorkflow needs clarification about which operations require Elasticsearch. Currently the docs incorrectly state that ES is required for all calls, but some operations work without it.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "ListWorkflow"
      ],
      "components": [
        "client",
        "documentation"
      ],
      "concepts": [
        "elasticsearch",
        "search",
        "api-requirements",
        "documentation-accuracy"
      ],
      "severity": "low",
      "userImpact": "Users are confused about whether Elasticsearch is required for ListWorkflow operations, potentially leading them to unnecessary infrastructure setup.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Explain some things on the calls work w/ only ES but others don't require ES.",
      "number": 742,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:00.182Z"
    },
    {
      "summary": "Local activity execution by string name fails during workflow replay. The issue appears specific to local activities registered by name rather than by function reference, causing replay to break when the activity is not available in the current registration context.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "workflow-engine",
        "activity-registry",
        "local-activities"
      ],
      "concepts": [
        "replay",
        "local-activities",
        "activity-registration",
        "name-based-lookup",
        "history-replay"
      ],
      "severity": "medium",
      "userImpact": "Users cannot successfully replay workflows that execute local activities registered by string name, breaking workflow history replay functionality.",
      "rootCause": "Local activities registered by name are not properly resolved during workflow replay when the activity registration context differs from the original execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was confirmed to be specific to local activities registered by name, and a fix was provided by the maintainer.",
      "related": [],
      "keyQuote": "The issue seems to be specific to local activities registered by name. I will confirm replication and provide fix.",
      "number": 740,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:02.484Z"
    },
    {
      "summary": "Verify that the temporal_workflow_task_execution_failed metric is incremented when a data converter fails to convert workflow input, and confirm temporal_activity_execution_failed metric is properly updated on activity failures.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "data-converter",
        "metrics-handler",
        "workflow-execution",
        "activity-execution"
      ],
      "concepts": [
        "metric-tracking",
        "data-conversion",
        "failure-handling",
        "prometheus-monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users may miss visibility into workflow and activity failures if metrics are not properly incremented during data conversion failures.",
      "rootCause": "Data converter failure during workflow input conversion may not trigger the temporal_workflow_task_execution_failed metric update.",
      "proposedFix": "Ensure the metric is updated in the data converter failure code path.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Metric updates were confirmed to be working correctly for both workflow task execution failures and activity execution failures.",
      "related": [],
      "keyQuote": "We may not be updating `temporal_workflow_task_execution_failed` when a data converter fails to convert workflow input.",
      "number": 737,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:35:04.262Z"
    },
    {
      "summary": "User requested SignalWithStartWorkflow support in the Go SDK test suite. The feature exists in the client but lacks a direct testing equivalent, forcing users to rely on integration tests instead of unit tests.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "SignalWithStartWorkflow"
      ],
      "components": [
        "testsuite",
        "test-workflow-environment",
        "signal-handling"
      ],
      "concepts": [
        "testing",
        "signals",
        "workflow-startup",
        "unit-testing",
        "test-utilities"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily unit test workflows that use SignalWithStartWorkflow, forcing them to resort to slower integration tests.",
      "rootCause": "TestWorkflowEnvironment lacks a dedicated method for SignalWithStartWorkflow, though RegisterDelayedCallback with 0 delay can simulate it.",
      "proposedFix": "Include SignalWithStartWorkflow in the test suite API, potentially as an enhancement to TestWorkflowEnvironment.",
      "workaround": "Use testsuite.TestWorkflowEnvironment.RegisterDelayedCallback with 0 delayDuration to simulate SignalWithStart.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed after clarification that the workaround exists via RegisterDelayedCallback with 0 delay, and documentation was improved via temporalio/documentation#939.",
      "related": [
        939
      ],
      "keyQuote": "Use 0 delayDuration to send a signal to simulate SignalWithStart.",
      "number": 736,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:45.633Z"
    },
    {
      "summary": "Worker restart mid-session causes workflow to fail with a lookup error when trying to map scheduledEventID to activityID. The error occurs when a worker pod is killed during an active session, preventing the workflow from completing.",
      "category": "bug",
      "subcategory": "session-worker-recovery",
      "apis": [],
      "components": [
        "workflow-task-handler",
        "decision-state-machine",
        "event-handler"
      ],
      "concepts": [
        "session",
        "worker-restart",
        "activity-scheduling",
        "event-mapping",
        "state-recovery",
        "distributed-coordination"
      ],
      "severity": "high",
      "userImpact": "Workflows with sessions become permanently stuck when workers are killed during active sessions, unable to recover or complete.",
      "rootCause": "Improper handling of activity event mapping when worker restarts mid-session; the SDK fails to correctly correlate scheduled activity events with activity IDs after recovery.",
      "proposedFix": "Fix handling of session recovery and event mapping as addressed in PR #746.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #746 which was released in a subsequent version.",
      "related": [
        722,
        746
      ],
      "keyQuote": "lookup failed for scheduledEventID to activityID: scheduleEventID: 35, activityID: 35",
      "number": 732,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:48.075Z"
    },
    {
      "summary": "WorkflowStartTime returns zero value in test workflows, making it difficult to test workflows that use this parameter for timing logic. Users expect test workflows to set WorkflowStartTime similar to how workflow.Now() works.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "GetInfo",
        "WorkflowStartTime"
      ],
      "components": [
        "test-framework",
        "workflow-context",
        "time-handling"
      ],
      "concepts": [
        "testing",
        "workflow-initialization",
        "time-values",
        "test-data",
        "workflow-metadata"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test workflows that depend on WorkflowStartTime for timing logic, as the parameter returns a zero value in tests.",
      "rootCause": "Test workflows do not set WorkflowStartTime when initializing workflow context, unlike real workflows.",
      "proposedFix": "Allow setting WorkflowStartTime parameter in test workflows, ideally defaulting to the same value as workflow.Now() at workflow start.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "During test workflow.GetInfo(ctx).WorkflowStartTime returns an zero value which makes it hard to test the workflow.",
      "number": 730,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:48.262Z"
    },
    {
      "summary": "Add an Await branch to Selector to allow waiting on conditions alongside Futures and Channels. This prevents users from accidentally mixing Await with Selector, which can lead to subtle bugs where timing expectations are violated.",
      "category": "feature",
      "subcategory": "workflow-coordination",
      "apis": [
        "Selector",
        "Await",
        "AwaitWithTimeout"
      ],
      "components": [
        "selector",
        "workflow-context",
        "condition-waiting"
      ],
      "concepts": [
        "selector-pattern",
        "await",
        "condition-checking",
        "concurrency-control",
        "workflow-logic",
        "timeout"
      ],
      "severity": "medium",
      "userImpact": "Users can now safely wait on arbitrary conditions within Selectors without mixing incompatible APIs, reducing the risk of subtle timing bugs.",
      "rootCause": "Selector API only supports Futures and Channels, forcing users to use separate Await calls which can cause timing issues when used together.",
      "proposedFix": "Add AddAwait(condition func() bool, f func()) method to Selector that calls f when condition returns true during Select execution.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This leads to situations when unexperienced users mix Await with Selector in the same function which leads to subtle bugs.",
      "number": 728,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:29.493Z"
    },
    {
      "summary": "Activity cancellation in workflows with retries causes a BadRequestCancelActivityAttributes history builder error. When a parent workflow cancels child activities that have retry policies, the SDK generates invalid history state, leading to internal state errors.",
      "category": "bug",
      "subcategory": "activity-cancellation",
      "apis": [
        "ExecuteActivity",
        "ExecuteChildWorkflow",
        "WithCancel",
        "WithActivityOptions"
      ],
      "components": [
        "activity-executor",
        "history-builder",
        "workflow-state-machine",
        "cancellation-handler"
      ],
      "concepts": [
        "activity-cancellation",
        "retry-policy",
        "history-validation",
        "state-machine",
        "workflow-context",
        "concurrent-activities"
      ],
      "severity": "high",
      "userImpact": "Users experience internal state errors and workflow failures when canceling activities with retry policies, preventing reliable activity cancellation patterns.",
      "rootCause": "History builder receives invalid action sequence when canceling activities with retry policies, resulting in 'add-activitytask-cancel-requested-event' state violation",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through fixes to activity cancellation handling in the Go SDK",
      "related": [],
      "keyQuote": "BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event",
      "number": 724,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:34.137Z"
    },
    {
      "summary": "Child workflows with SDK-generated IDs fail to reset because the auto-generated ID is based on the original runID, which changes after reset. During replay, the workflow can't find the corresponding child workflow command, causing a non-deterministic error.",
      "category": "bug",
      "subcategory": "workflow-reset",
      "apis": [
        "ExecuteChildWorkflow"
      ],
      "components": [
        "workflow-state-machine",
        "child-workflow-handler",
        "replay-engine"
      ],
      "concepts": [
        "workflow-reset",
        "determinism",
        "child-workflow-id-generation",
        "runID",
        "history-replay",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely reset workflows that use child workflows without explicitly specifying a child workflow ID, as the reset will cause non-deterministic errors during replay.",
      "rootCause": "Child workflow IDs are auto-generated based on the workflow's runID. When a workflow is reset, the runID changes, but the historical child workflow ID references remain based on the original runID, creating a mismatch during replay.",
      "proposedFix": "Generate child workflow IDs based on the workflow's OriginalRunId instead of the current runID, as the original runID remains constant across resets.",
      "workaround": "Explicitly specify child workflow IDs in the child workflow options to avoid SDK auto-generation.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #1803 which addresses the child workflow ID generation to handle resets correctly.",
      "related": [
        1385,
        1803
      ],
      "keyQuote": "After reset, the workflow's runID changes but in workflow history the child workflow ID is still based on the original runID. Hence the not found and non-deterministic error.",
      "number": 723,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:34.343Z"
    },
    {
      "summary": "CreateSession activity was retrying on errors it should not retry, including timeouts. The issue requires disabling all retries on session creation activity and leveraging server-side changes to handle the 'too many sessions' case through max concurrent activities.",
      "category": "bug",
      "subcategory": "session-management",
      "apis": [
        "CreateSession"
      ],
      "components": [
        "worker",
        "session-creation",
        "activity-retry-policy"
      ],
      "concepts": [
        "retry-logic",
        "session-creation",
        "error-handling",
        "max-concurrent-activities",
        "timeout",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Session creation may retry on errors like timeouts that should not be retried, causing unexpected behavior and potential duplicate sessions.",
      "rootCause": "Intentional retry-prevention logic was inadvertently removed in a prior commit, allowing session creation activity to retry all errors except 'too many sessions'.",
      "proposedFix": "Disable all retries on session creation activity and use max concurrent activities to handle the 'too many sessions' case, requiring a server-side change (temporal/temporal#2524) to disable timeout retries.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by disabling all retries on session creation activity and leveraging server-side retry policy changes to handle timeout exclusions. Max concurrent activity size is also set on session creation worker.",
      "related": [
        739,
        741,
        2524
      ],
      "keyQuote": "Do not have session creation activity failure retry anything but 'too many sessions'.",
      "number": 722,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:17.752Z"
    },
    {
      "summary": "Data races in coroutine context cancellation when using WithCancel in workflows. Multiple concurrent goroutines access and modify context state without proper synchronization, causing race conditions during cancellation propagation.",
      "category": "bug",
      "subcategory": "coroutine-cancellation",
      "apis": [
        "WithCancel",
        "NewCoroutine"
      ],
      "components": [
        "context-cancellation",
        "coroutine-dispatcher",
        "workflow-executor"
      ],
      "concepts": [
        "data-race",
        "concurrency",
        "context-cancellation",
        "goroutine-synchronization",
        "race-condition",
        "concurrent-access"
      ],
      "severity": "high",
      "userImpact": "Workflow coroutines using context cancellation may experience unpredictable behavior and potential crashes due to unsynchronized concurrent access to context state.",
      "rootCause": "Unsynchronized read/write access to cancelCtx fields in internal/context.go during propagateCancel() and cancel() operations when multiple goroutines interact with context cancellation simultaneously.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Data races in context cancellation were fixed with proper synchronization mechanisms in the cancelCtx implementation.",
      "related": [],
      "keyQuote": "Here are some data races in master as of this writing: Write at 0x00c000236868 by goroutine 11 / Previous read at 0x00c000236868 by goroutine 10",
      "number": 720,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:14.627Z"
    },
    {
      "summary": "Worker becomes unresponsive when MaxConcurrentWorkflowTaskPoller is set to 1 because it only polls from the sticky queue, preventing any workflow progress. The issue requires either smarter queue polling logic or enforcing a minimum concurrent poller requirement.",
      "category": "bug",
      "subcategory": "worker-polling",
      "apis": [],
      "components": [
        "worker",
        "workflow-task-poller",
        "sticky-queue"
      ],
      "concepts": [
        "concurrency-limit",
        "queue-polling",
        "deadlock",
        "resource-constraint",
        "sticky-scheduling"
      ],
      "severity": "high",
      "userImpact": "Workers silently fail to process workflows when misconfigured with a concurrent poller limit of 1, causing complete workflow execution stalls.",
      "rootCause": "Worker's preference for sticky queue polling causes it to never poll from the normal queue when MaxConcurrentWorkflowTaskPoller is limited to 1, creating a deadlock scenario.",
      "proposedFix": "Either implement smarter queue polling that periodically polls from the normal queue, or enforce a minimum of 2 workflow task pollers and fail worker startup with clear error message if constraint violated.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing intelligent queue polling strategy that balances sticky queue preferences with normal queue polling.",
      "related": [],
      "keyQuote": "Current silently doing nothing is not acceptable.",
      "number": 719,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:15.880Z"
    },
    {
      "summary": "Request to add a metric tracking time elapsed from activity scheduling to the last retry attempt, enabling users to set alerts for activities that keep failing. Current metrics only cover successful executions or single task execution, leaving a gap for monitoring failing activity chains.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "retry-handler"
      ],
      "concepts": [
        "activity-scheduling",
        "retry-logic",
        "end-to-end-latency",
        "alerting",
        "monitoring",
        "time-tracking",
        "failure-detection"
      ],
      "severity": "medium",
      "userImpact": "Users currently lack a built-in metric to detect and alert on activities that repeatedly fail and retry, requiring them to implement custom monitoring solutions.",
      "rootCause": null,
      "proposedFix": "Add an SDK-side metric reporting elapsed time from activity schedule to last activity attempt, tagged with activity type.",
      "workaround": "Users can implement custom metrics to track this metric themselves.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1035
      ],
      "keyQuote": "We should add a metric reporting how much time passed from an activity schedule to the last activity attempt. This metric should have an activity type as a tag and be SDK side.",
      "number": 718,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:34:02.244Z"
    },
    {
      "summary": "Terminating a workflow while processing can leak goroutines that get stuck forever, particularly in complex DSL workflows with many parallel activities. The leaked coroutines remain blocked on channel operations and cannot be cleaned up.",
      "category": "bug",
      "subcategory": "workflow-termination",
      "apis": [],
      "components": [
        "workflow-executor",
        "coroutine-dispatcher",
        "channel-implementation",
        "workflow-environment"
      ],
      "concepts": [
        "goroutine-leak",
        "resource-cleanup",
        "workflow-termination",
        "parallel-activities",
        "channel-closure",
        "memory-leak"
      ],
      "severity": "high",
      "userImpact": "Users running complex parallel workflows can accumulate leaked goroutines when workflows are terminated, causing memory leaks and degraded worker performance over time.",
      "rootCause": "Workflow termination does not properly close channels or signal waiting coroutines, leaving them blocked indefinitely on channel receive operations.",
      "proposedFix": "Ensure all channels are closed and coroutines are properly signaled when a workflow is terminated.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        779
      ],
      "keyQuote": "If a dsl workflow is terminated before all activities are processed, any pending coroutines handling them will be stuck forever.",
      "number": 716,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:54.187Z"
    },
    {
      "summary": "OpenTracing-enabled workers fail when OpenTracing span context is missing from headers, requiring workflows to be started with OpenTracing-enabled clients. This differs from OpenTelemetry's behavior which gracefully handles missing spans.",
      "category": "bug",
      "subcategory": "interceptors-opentracing",
      "apis": [],
      "components": [
        "interceptor",
        "opentracing",
        "worker",
        "propagation"
      ],
      "concepts": [
        "span-extraction",
        "headers",
        "distributed-tracing",
        "error-handling",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "OpenTracing-enabled workers cannot accept requests from non-OpenTracing clients, limiting interoperability and requiring all clients to support OpenTracing.",
      "rootCause": "OpenTracing's Tracer.Extract() raises ErrSpanContextNotFound when span context is absent in headers, whereas OpenTelemetry's TextMapPropagator.Extract() gracefully handles missing spans.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "with this error we are requiring opentracing-enabled workers to have their workflows started with opentracing-enabled clients which is not cool",
      "number": 712,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:56.197Z"
    },
    {
      "summary": "The //workflowcheck:ignore comment directive appears to interfere with Godoc documentation generation in the Go SDK. Need to verify the interaction between workflow check directives and documentation tooling.",
      "category": "bug",
      "subcategory": "workflow-check-directives",
      "apis": [],
      "components": [
        "workflow-checker",
        "godoc-integration",
        "code-generation"
      ],
      "concepts": [
        "workflow-validation",
        "code-documentation",
        "linting",
        "comment-directives",
        "go-tooling"
      ],
      "severity": "low",
      "userImpact": "Developers may encounter issues with documentation generation when using workflow check directives in their code.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Seems to interfere",
      "number": 710,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:42.909Z"
    },
    {
      "summary": "Workflowcheck's hierarchical tree for non-determinism detection only shows direct import reasons, not transitive ones. Nested children don't display the final leaf reason, limiting visibility into the root cause of non-determinism issues.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "workflowcheck",
        "non-determinism-detector",
        "import-resolver"
      ],
      "concepts": [
        "non-determinism",
        "transitive-dependencies",
        "hierarchical-tree",
        "leaf-reasons",
        "determinism-checking"
      ],
      "severity": "medium",
      "userImpact": "Users debugging non-determinism issues cannot see the complete chain of causes, making it harder to identify the root problem.",
      "rootCause": "Only direct import reasons are carried over during hierarchy traversal, not transitive ones from nested children.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Author determined that including transitive reasons causes excessive memory overhead, so chose not to implement full transitive reasoning at this time.",
      "related": [],
      "keyQuote": "I only carry over reasoning from the direct imports, not transitive ones.",
      "number": 709,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:41.443Z"
    },
    {
      "summary": "Poll failures are currently logged only at DEBUG level after verbose logging is enabled. The request is to increase visibility by logging them at WARN level, specifically for connection failures.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "worker",
        "poller",
        "logging"
      ],
      "concepts": [
        "poll-failure",
        "visibility",
        "logging-level",
        "connection-failure",
        "debug-diagnostics"
      ],
      "severity": "medium",
      "userImpact": "Users have limited visibility into poll failures without explicitly enabling verbose logging, making it harder to diagnose connectivity and operational issues.",
      "rootCause": null,
      "proposedFix": "Add poll failures at WARN level, conditionally on connection failure to avoid noise.",
      "workaround": "Enable verbose logging via EnableVerboseLogging to see poll failures at DEBUG level.",
      "resolution": "fixed",
      "resolutionDetails": "Poll failures are now logged at WARN level for improved visibility.",
      "related": [],
      "keyQuote": "Confirm they aren't noisy then add them at WARN level. If at all possible, only do this on connection failure.",
      "number": 707,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:39.627Z"
    },
    {
      "summary": "Make the rpcLongPollTimeout configuration option available in WorkflowServiceStubsOptions for the Go SDK, similar to the Java SDK implementation.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [
        "WorkflowServiceStubsOptions"
      ],
      "components": [
        "client",
        "service-stubs",
        "configuration"
      ],
      "concepts": [
        "timeout",
        "long-polling",
        "rpc",
        "configuration",
        "client-options"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently configure the long poll timeout for workflow service stubs, limiting their ability to tune RPC behavior for their specific environments.",
      "rootCause": null,
      "proposedFix": "Add rpcLongPollTimeout as a configurable option in WorkflowServiceStubsOptions, following the pattern established in the Java SDK.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        988
      ],
      "keyQuote": "The original issue in JavaSDK: https://github.com/temporalio/sdk-java/issues/988",
      "number": 705,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:25.619Z"
    },
    {
      "summary": "Request to add a Zap logger implementation as a contrib module that provides a high-performance adapter using Zap's SugaredLogger for the SDK's log.Logger interface.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "contrib",
        "logger",
        "zap-adapter"
      ],
      "concepts": [
        "logging",
        "performance",
        "stdlib-compatibility",
        "contrib-module",
        "key-value-logging"
      ],
      "severity": "medium",
      "userImpact": "Users can now use Zap logging directly with the SDK instead of manually implementing their own adapter.",
      "rootCause": null,
      "proposedFix": "Add zap child module to contrib folder using zap.SugaredLogger <level>W calls, update vanity URL to go.temporal.io/sdk/contrib/zap, and tag release as contrib/zap/v0.1.0",
      "workaround": "Manually implement log.Logger using Zap as shown in samples-go/zapadapter",
      "resolution": "fixed",
      "resolutionDetails": "Zap logger contribution was added to the SDK contrib modules",
      "related": [
        1158
      ],
      "keyQuote": "It should rely on the *zap.S's <level>W calls which are higher performing than you see from other people's adapters",
      "number": 704,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:28.832Z"
    },
    {
      "summary": "Async activities with heartbeat timeouts fail unexpectedly because external completion mechanisms cannot provide periodic heartbeats while waiting for manual input. User expects either automatic heartbeat generation for async activities or special handling to prevent timeout.",
      "category": "question",
      "subcategory": "activity-heartbeat",
      "apis": [
        "CompleteActivity",
        "CompleteActivityByID",
        "RecordActivityHeartbeat",
        "RecordActivityHeartbeatByID"
      ],
      "components": [
        "activity-executor",
        "heartbeat-handler",
        "async-completion"
      ],
      "concepts": [
        "heartbeat-timeout",
        "async-activity",
        "external-completion",
        "activity-state-pending",
        "worker-deadlock",
        "long-running-operations"
      ],
      "severity": "medium",
      "userImpact": "Users using async activities for manual input waiting experience unexpected heartbeat timeout failures, limiting the usefulness of async completion for long-running operations.",
      "rootCause": "Async activities are treated as running from the server perspective and require continuous heartbeats, but external completion mechanisms (especially those waiting for user input from other services) cannot reliably send periodic heartbeats.",
      "proposedFix": "Server could implement special handling for activities in ErrResultPending state to skip heartbeat timeout validation, or provide automatic heartbeat generation for async activities.",
      "workaround": "Send RecordActivityHeartbeat or RecordActivityHeartbeatByID periodically from the external service handling the async completion, or disable heartbeat timeout entirely on the activity.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers confirmed this is intended behavior. Heartbeat requirement is by design to detect worker deadlock and ensure activity execution hasn't gone away. Recommended alternatives are using signals or child workflows which don't require heartbeats.",
      "related": [],
      "keyQuote": "It is by intention that starting an activity with a heartbeat timeout must have heartbeats within that timeout occur until it is completed/failed.",
      "number": 703,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:28.866Z"
    },
    {
      "summary": "Replace health check with server capabilities lookup via getServerInfo to enable better error handling decisions. Remove health check options and use internal_error_differentiation capability to stop gRPC retrying internal errors.",
      "category": "feature",
      "subcategory": "client-initialization",
      "apis": [
        "getServerInfo"
      ],
      "components": [
        "client",
        "server-capabilities",
        "health-check",
        "error-handling"
      ],
      "concepts": [
        "server-capabilities",
        "health-check",
        "error-differentiation",
        "client-creation",
        "retry-logic",
        "graceful-degradation"
      ],
      "severity": "high",
      "userImpact": "Users must adapt their client initialization code as health check options are removed and replaced with capabilities-based approach.",
      "rootCause": "Health check system is limiting for error handling decisions; server capabilities provide better information for retry logic.",
      "proposedFix": "Call getServerInfo during client creation instead of health check, handle 404s gracefully, fail fast on other errors, and leverage internal_error_differentiation capability.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented server capabilities lookup and internal error differentiation instead of health check mechanism.",
      "related": [],
      "keyQuote": "Leverage the `internal_error_differentiation` capability to, if true, stop gRPC retrying internal errors",
      "number": 701,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:11.482Z"
    },
    {
      "summary": "Request for a static analysis tool to detect non-determinism in Go workflows. The proposal includes moving existing temporal-determinist tool to the repo, integrating with golangci-lint and staticcheck.io, and documenting IDE integration with the ability to ignore specific calls or code sections.",
      "category": "feature",
      "subcategory": "development-tools",
      "apis": [],
      "components": [
        "static-analysis",
        "workflow-validation",
        "linting"
      ],
      "concepts": [
        "non-determinism",
        "code-analysis",
        "workflow-safety",
        "determinism-checking",
        "developer-tools",
        "linting-integration"
      ],
      "severity": "medium",
      "userImpact": "Developers can automatically detect non-deterministic code patterns in workflows, reducing runtime errors and improving workflow reliability.",
      "rootCause": null,
      "proposedFix": "Move temporal-determinist tool to contrib/tools/temporal-check, integrate with golangci-lint and staticcheck.io, document IDE integration, and add ability to ignore specific calls or code sections.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by implementing static analysis tooling for detecting non-determinism, with integration into standard Go linting tools.",
      "related": [],
      "keyQuote": "No tooling for detecting non-determinism in workflows.",
      "number": 700,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:14.784Z"
    },
    {
      "summary": "Feature request to make the \"unable to find workflow type\" error non-retryable and hard-fail the workflow, instead of allowing retries to support delayed worker deployments. The requester suggests implementing a catch-all workflow implementation pattern (#543) as a solution.",
      "category": "feature",
      "subcategory": "workflow-type-resolution",
      "apis": [],
      "components": [
        "worker",
        "workflow-registry",
        "error-handling"
      ],
      "concepts": [
        "retry",
        "workflow-type-registration",
        "deployment",
        "error-configuration",
        "workflow-execution",
        "failure-handling"
      ],
      "severity": "medium",
      "userImpact": "Users need better control over how missing workflow types are handled, allowing them to configure hard failures instead of retries when deploying workers.",
      "rootCause": null,
      "proposedFix": "Support a catch-all workflow implementation pattern to handle missing workflow types gracefully",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        543
      ],
      "keyQuote": "Need to investigate options about making it non-retryable.",
      "number": 698,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:33:12.164Z"
    },
    {
      "summary": "Data converter WithContext is not being called for local activity response errors and marker details. The issue is complicated by the fact that errors and marker metadata use custom converters without context information during both serialization and deserialization.",
      "category": "bug",
      "subcategory": "data-conversion",
      "apis": [],
      "components": [
        "data-converter",
        "local-activity",
        "error-handling",
        "marker-serialization"
      ],
      "concepts": [
        "context-aware-conversion",
        "custom-converter",
        "serialization",
        "deserialization",
        "replay",
        "error-handling"
      ],
      "severity": "high",
      "userImpact": "Custom data converter implementations that rely on context information will not receive context when processing local activity errors and marker metadata, causing serialization/deserialization failures.",
      "rootCause": "Local activity completion records results, errors, and marker details using different converters. While results use context-aware converter, errors and marker details use custom-but-not-context-aware converters. During replay, context is not available when deserializing errors, preventing use of context-aware converters even if available.",
      "proposedFix": null,
      "workaround": "Custom converter creators who rely on context-aware pieces should passthrough data when they don't have context-specific information.",
      "resolution": "invalid",
      "resolutionDetails": "Issue was resolved by documenting that context-aware data converters should not rely on being given a context, and opening issue #699 as a related compatibility note.",
      "related": [
        699
      ],
      "keyQuote": "we don't have such a context when we are extracting the error back out...so we'll have to create such a header-infused context on every single replay",
      "number": 697,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:59.910Z"
    },
    {
      "summary": "RetryPolicy is not propagated when using ContinueAsNew, and there's no parameter to set it explicitly. The policy should either be automatically inherited or accepted as a configuration parameter.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "ContinueAsNewWorkflowExecution"
      ],
      "components": [
        "workflow-executor",
        "retry-policy",
        "continue-as-new"
      ],
      "concepts": [
        "retry",
        "workflow-continuation",
        "policy-propagation",
        "execution-attributes",
        "configuration",
        "lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Workflows using ContinueAsNew lose their retry configuration, potentially causing unexpected behavior when retries are needed after continuation.",
      "rootCause": "ContinueAsNewWorkflowExecutionCommandAttributes does not include or propagate RetryPolicy from the parent workflow.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "RetryPolicy propagation was implemented for ContinueAsNew workflows.",
      "related": [],
      "keyQuote": "RetryPolicy should either be propagated or accepted as a param for continue as new",
      "number": 695,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:56.462Z"
    },
    {
      "summary": "Request to change heartbeat failure log level from debug to warn to increase visibility of heartbeat failures in Go SDK.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "logging"
      ],
      "concepts": [
        "heartbeat",
        "logging",
        "observability",
        "failure-detection"
      ],
      "severity": "low",
      "userImpact": "Users will have better visibility into heartbeat failures without needing to enable debug logging.",
      "rootCause": null,
      "proposedFix": "Change the log level of heartbeat failures from debug to warn",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Log level for heartbeat failures was changed from debug to warn level",
      "related": [],
      "keyQuote": "Right now heartbeat failures are debug level",
      "number": 692,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:56.803Z"
    },
    {
      "summary": "Support for receiver-less method references in OnActivity mocks for Go. The incorrect syntax `OnActivity((*myStruct).MyFunc)` makes the receiver the first argument, while `OnActivity(new(myStruct).MyFunc)` works correctly with a receiver instance.",
      "category": "docs",
      "subcategory": "test-framework",
      "apis": [
        "OnActivity",
        "RegisterActivity"
      ],
      "components": [
        "mock",
        "activity-registration",
        "test-framework"
      ],
      "concepts": [
        "method-reference",
        "receiver-handling",
        "reflection",
        "function-pointer"
      ],
      "severity": "low",
      "userImpact": "Users cannot use receiver-less method references in OnActivity mocks and must use instance method references instead.",
      "rootCause": "Go's reflection system cannot reliably determine at runtime whether a function pointer represents a receiver-less method reference versus a regular function, making it impossible to automatically adjust parameter handling.",
      "proposedFix": "Clarify in documentation the correct syntax for registering activities and mocking them with method references.",
      "workaround": "Use instance method references like `OnActivity(new(myStruct).MyFunc)` instead of receiver-less references like `OnActivity((*myStruct).MyFunc)`.",
      "resolution": "wontfix",
      "resolutionDetails": "Investigation confirmed the limitation cannot be resolved at runtime, so documentation was updated to clarify the behavior.",
      "related": [
        586
      ],
      "keyQuote": "After investigation, I have confirmed we cannot really do anything here at runtime because we also don't support registration of activities this way",
      "number": 688,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:45.044Z"
    },
    {
      "summary": "make test fails on macOS with a SIGABRT crash during test execution due to a known macOS-specific issue with the Go race detector. The issue was resolved by setting MallocNanoZone=0 environment variable before running tests.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-runner",
        "makefile",
        "race-detector"
      ],
      "concepts": [
        "testing",
        "macOS",
        "race-detector",
        "environment-variable",
        "runtime-crash",
        "signal-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers on macOS cannot run the test suite without encountering a crash, blocking local development and CI/CD workflows.",
      "rootCause": "macOS-specific issue with Go's race detector causing SIGABRT with unknown class error, related to memory allocation (MallocNanoZone).",
      "proposedFix": "Add MallocNanoZone=0 environment variable to test commands in Makefile for integration tests.",
      "workaround": "Set MallocNanoZone=0 before running go test, or upgrade to Go 1.18+ which fixes the issue.",
      "resolution": "fixed",
      "resolutionDetails": "Applied patch to Makefile adding MallocNanoZone=0 environment variable to integration test commands, based on workaround identified in golang/go#49138.",
      "related": [
        49138
      ],
      "keyQuote": "Your error seems to be a mac-specific known issue when using race detector on mac. You can mimic what https://github.com/Shopify/toxiproxy did (specifically add MallocNanoZone=0 before running go test).",
      "number": 687,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:42.633Z"
    },
    {
      "summary": "Activities can return CanceledError without server-side cancellation being received, causing incorrect RespondActivityTaskCanceledRequest to be sent. The enhancement proposes ensuring canceled errors are only sent when the server actually initiated a cancellation, wrapping other cases as retryable ApplicationFailure, and ensuring cross-SDK consistency with appropriate tests.",
      "category": "bug",
      "subcategory": "activity-cancellation",
      "apis": [
        "CanceledError",
        "RespondActivityTaskCanceledRequest"
      ],
      "components": [
        "activity-executor",
        "task-pollers",
        "error-handling"
      ],
      "concepts": [
        "cancellation",
        "error-handling",
        "server-communication",
        "activity-lifecycle",
        "retry-logic"
      ],
      "severity": "high",
      "userImpact": "Activities can report cancellation to the server without actually being cancelled by the server, potentially causing incorrect workflow behavior and state inconsistency.",
      "rootCause": "The activity pollers unconditionally send RespondActivityTaskCanceledRequest when receiving CanceledError or context.Canceled, regardless of whether a server-side cancellation was actually in flight.",
      "proposedFix": "Only send RespondActivityTaskCanceledRequest if the server actually sent a cancellation; wrap CanceledError/context.Canceled as retryable ApplicationFailure in other cases; ensure SDK consistency; add tests for cancel behavior with and without server cancellation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation ensured that canceled errors are only reported to server when cancellation was requested, and other cases are wrapped as ApplicationFailure with cross-SDK consistency and comprehensive test coverage.",
      "related": [
        2344
      ],
      "keyQuote": "Make sure to only handle those cancelled errors as actually sending a cancel to the server if the server sent us a cancel",
      "number": 686,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:43.833Z"
    },
    {
      "summary": "The Go SDK needs a SkipLogger interface to allow custom loggers to adjust caller skip levels during workflow replay, similar to the interface available in the Temporal server.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logger",
        "client",
        "replay"
      ],
      "concepts": [
        "caller-skip",
        "logging",
        "workflow-replay",
        "custom-logger",
        "log-wrapper"
      ],
      "severity": "low",
      "userImpact": "Users with custom loggers cannot properly adjust caller skip levels during workflow replay, potentially causing incorrect log output.",
      "rootCause": "The Go SDK lacks a SkipLogger interface that allows runtime adjustment of the caller skip parameter during replay scenarios.",
      "proposedFix": "Implement a SkipLogger interface in the Go SDK that mirrors the server implementation, allowing skip value adjustment (e.g., setting skip to 1) during replay.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "A SkipLogger interface was implemented in the Go SDK to allow custom loggers to adjust caller skip levels during replay.",
      "related": [],
      "keyQuote": "Like the server does, we should also have a skip interface that we can call w/ the value of `1` on when replaying.",
      "number": 685,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:30.156Z"
    },
    {
      "summary": "User unable to test an activity that calls activity.GetLogger() because the activity context lacks the required activityInterceptorContextKey. The issue was resolved by using the testsuite package's TestActivityEnvironment instead of calling the activity directly with context.TODO().",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [
        "GetLogger",
        "ExecuteActivity"
      ],
      "components": [
        "activity-interceptor",
        "test-suite",
        "activity-context"
      ],
      "concepts": [
        "testing",
        "activity-execution",
        "context-management",
        "logger",
        "interceptor",
        "test-environment"
      ],
      "severity": "medium",
      "userImpact": "Users cannot directly test activities that use activity.GetLogger() without using the proper TestActivityEnvironment from the testsuite package.",
      "rootCause": "Direct activity calls with context.TODO() lack the activityInterceptorContextKey required by activity.GetLogger() to retrieve the logger.",
      "proposedFix": "Use testsuite.WorkflowTestSuite to create a TestActivityEnvironment, register the activity, and call it via env.ExecuteActivity() instead of calling the activity directly.",
      "workaround": "Use TestActivityEnvironment from go.temporal.io/sdk/testsuite package to properly initialize activity context with required interceptor.",
      "resolution": "fixed",
      "resolutionDetails": "User confirmed the workaround works by using TestActivityEnvironment.ExecuteActivity() instead of direct activity invocation.",
      "related": [
        163
      ],
      "keyQuote": "If you want to use an activity context with all the activity bells and whistles, you need to use the testsuite package and create a suite and an activity environment.",
      "number": 682,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:28.696Z"
    },
    {
      "summary": "GetWorkflowError() doesn't expose stack trace information for workflow panics, requiring users to manually unwrap nested error types using undocumented patterns. The issue was resolved by suggesting users leverage Go's errors.As() function for cleaner error type assertion.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "GetWorkflowError",
        "WorkflowExecutionError"
      ],
      "components": [
        "error-handling",
        "test-framework",
        "workflow-execution"
      ],
      "concepts": [
        "stack-trace",
        "panic",
        "error-unwrapping",
        "error-assertion",
        "testing",
        "debugging",
        "user-experience"
      ],
      "severity": "low",
      "userImpact": "Developers debugging workflow panics must use undocumented error unwrapping patterns instead of clean, standard Go error handling practices.",
      "rootCause": "PanicError.StackTrace() is only available on activity errors, not exposed at the workflow error level, requiring manual error type unwrapping.",
      "proposedFix": "Provide a documented way to access stack traces from workflow panics, potentially through a method on WorkflowExecutionError or clearer documentation of errors.As() usage pattern.",
      "workaround": "Use errors.As() to extract the underlying PanicError: `var panicErr *temporal.PanicError; if errors.As(err, &panicErr) { panicErr.StackTrace() }`",
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by maintainer providing the standard Go errors.As() pattern as the recommended solution, which is cleaner than manual type casting.",
      "related": [],
      "keyQuote": "Use `errors.As` instead, e.g.: `if errors.As(err, &panicErr) { fmt.Printf(\"Got panic error, trace: %v\", panicErr.StackTrace()) }`",
      "number": 679,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:27.392Z"
    },
    {
      "summary": "Worker panics intermittently while executing activities in batched workflows with multiple concurrent activity executions. Issue appears related to race conditions during activity scheduling and processing on newly-scheduled workflows.",
      "category": "bug",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "workflow-environment",
        "event-handlers"
      ],
      "concepts": [
        "panic",
        "concurrency",
        "activity-scheduling",
        "workflow-execution",
        "race-condition",
        "batching"
      ],
      "severity": "high",
      "userImpact": "Workers crash unexpectedly during activity execution, disrupting workflow processing and requiring manual intervention or restart.",
      "rootCause": "Likely a race condition when activity cancellations, heartbeats, or state changes are processed on newly-scheduled-but-not-yet-started workflows, possibly related to concurrent access during batch activity execution.",
      "proposedFix": null,
      "workaround": "Refactor activity scheduling to check futures only once instead of multiple times, as suggested in issue #475.",
      "resolution": "invalid",
      "resolutionDetails": "Issue did not reproduce after upgrading Temporal server from v1.12.3 to v1.14.2. Appears to have been fixed in server-side code between v1.13.1 and v1.14. Deferred to #475 for related investigation.",
      "related": [
        475,
        2300
      ],
      "keyQuote": "Worker panics intermittently while executing an activity. Occurs on server v1.13.1, but not after upgrade to v1.14.2.",
      "number": 678,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:13.913Z"
    },
    {
      "summary": "Two tests are flaky in CI: TestCustomResolver occasionally expects 1 but gets 2, and TestOpenTelemetryTracing sometimes has an extra span in the children array. Both failures suggest race conditions or timing issues in test execution.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "grpc-dialer",
        "opentelemetry-interceptor",
        "test-infrastructure"
      ],
      "concepts": [
        "flaky-tests",
        "race-condition",
        "timing",
        "span-tracking",
        "test-stability"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests reduce confidence in the SDK's reliability and make CI/CD pipelines unreliable, affecting developer productivity.",
      "rootCause": "Likely race condition or timing-dependent behavior in span collection or resolver initialization causing non-deterministic test results.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through test stabilization fixes",
      "related": [],
      "keyQuote": "expected: 1 actual: 2 ... expected 4 children, actual 5 children - non-deterministic test failures in CI",
      "number": 677,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:13.167Z"
    },
    {
      "summary": "WithChildOptions API misleadingly applies to general workflow options instead of just child workflows, affecting continue-as-new behavior and potentially surprising users. Documentation is needed to clarify this design and discourage context reuse.",
      "category": "docs",
      "subcategory": "continue-as-new",
      "apis": [
        "WithChildOptions",
        "WithWorkflowRunTimeout",
        "NewContinueAsNewError"
      ],
      "components": [
        "workflow-options",
        "child-workflows",
        "continue-as-new"
      ],
      "concepts": [
        "api-naming",
        "context-reuse",
        "workflow-configuration",
        "options-inheritance",
        "documentation"
      ],
      "severity": "medium",
      "userImpact": "Users may be confused by WithChildOptions affecting general workflow options and may experience unexpected behavior when using continue-as-new.",
      "rootCause": "API naming is misleading - WithChildOptions actually modifies general workflow options that are reused in NewContinueAsNewError",
      "proposedFix": "Document the issue and discourage context reuse in general",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "WithChildOptions would only apply to children, but it actually changes the general workflow options",
      "number": 676,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:32:14.996Z"
    },
    {
      "summary": "Activity timeout configuration was confusing because the godoc comments didn't clearly explain that at least one of ScheduleToCloseTimeout or StartToCloseTimeout is required. The issue reporter thought both ScheduleToStart and StartToClose were required when ScheduleToClose was not provided.",
      "category": "docs",
      "subcategory": "activity-timeouts",
      "apis": [
        "ActivityOptions",
        "ExecuteActivity"
      ],
      "components": [
        "activity-options",
        "documentation",
        "godoc"
      ],
      "concepts": [
        "timeout",
        "activity-configuration",
        "scheduling",
        "documentation-clarity"
      ],
      "severity": "low",
      "userImpact": "Users are confused about activity timeout requirements, potentially leading to incorrect timeout configuration.",
      "rootCause": null,
      "proposedFix": "Improve the godoc comments on ActivityOptions to more clearly specify that at least one of ScheduleToCloseTimeout or StartToCloseTimeout is required, independent of ScheduleToStartTimeout.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Behavior is expected and working as designed. The issue was resolved by clarifying in comments that this is documented behavior, not a bug. The suggestion to improve godoc comments was acknowledged but the core behavior was confirmed as correct.",
      "related": [
        632
      ],
      "keyQuote": "Definitely expected behavior (and is expected across all SDKs, as it is enforced server side). Simply: At least one of ScheduleToCloseTimeout or StartToCloseTimeout is required.",
      "number": 675,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:59.869Z"
    },
    {
      "summary": "Function name aliasing during workflow/activity registration creates ambiguity and confusion. When registering with an explicit name, the function name is automatically aliased, causing unintended function references to match and test suites to execute unexpected workflows.",
      "category": "feature",
      "subcategory": "workflow-registration",
      "apis": [
        "RegisterWorkflowWithOptions",
        "ExecuteWorkflow"
      ],
      "components": [
        "workflow-registry",
        "registration",
        "test-framework"
      ],
      "concepts": [
        "function-aliasing",
        "registration-ambiguity",
        "name-uniqueness",
        "function-reference",
        "implicit-registration"
      ],
      "severity": "medium",
      "userImpact": "Users registering workflows with explicit names can have their code silently execute the wrong workflow when called by function reference, leading to confusing test failures and runtime behavior.",
      "rootCause": "The registration system automatically creates an alias for the function name in addition to the explicit name, and doesn't enforce uniqueness checking on the alias like it does for explicit names.",
      "proposedFix": "Add `workflow.RegisterOptions.DisableFunctionNameAlias` option to allow disabling the automatic function name aliasing during registration.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by qualifying the alias to prevent ambiguity, as mentioned in comment 2.",
      "related": [
        425
      ],
      "keyQuote": "Even though ExecuteWorkflow attempts implicit register, it silently ignores as expected if already registered. The ExecuteWorkflow actually tries to execute the registered one due to the alias which is very confusing.",
      "number": 672,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:57.376Z"
    },
    {
      "summary": "User requests documentation on how to provide authorization tokens in the Go SDK, similar to the existing Java SDK documentation. The issue describes two implementation methods: using HeadersProvider or gRPC dial options with interceptors.",
      "category": "docs",
      "subcategory": "authorization",
      "apis": [
        "client.Options.HeadersProvider",
        "client.Options.ConnectionOptions.DialOptions"
      ],
      "components": [
        "client",
        "authentication",
        "grpc-interceptor",
        "header-provider"
      ],
      "concepts": [
        "authorization",
        "authentication",
        "tokens",
        "headers",
        "grpc-metadata",
        "bearer-token",
        "documentation"
      ],
      "severity": "medium",
      "userImpact": "Go SDK users lack clear documentation on implementing authorization token handling, making it harder to secure their Temporal connections compared to other SDKs.",
      "rootCause": "Missing documentation and samples for authorization token configuration in the Go SDK.",
      "proposedFix": "Create documentation similar to the Java SDK authorization guide and provide sample code showing both HeadersProvider and gRPC interceptor approaches.",
      "workaround": "Use client.Options.HeadersProvider with a custom header provider that returns Authorization headers with Bearer tokens, or use gRPC dial options with custom interceptors.",
      "resolution": "fixed",
      "resolutionDetails": "Documentation was created and a sample implementation was added to samples-go repository (serverjwtauth example) demonstrating custom header provider for JWT authentication.",
      "related": [
        160
      ],
      "keyQuote": "you can set `client.Options.HeadersProvider` with an instance that returns a map with `Authorization` as the key and `Bearer <mytoken>` as the value",
      "number": 671,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:56.707Z"
    },
    {
      "summary": "Go SDK experiences event ordering issues when an activity task starts and completes between workflow task scheduling and starting. A lookup error occurs trying to map scheduled event IDs to activity IDs in unexpected event sequences.",
      "category": "bug",
      "subcategory": "event-ordering",
      "apis": [],
      "components": [
        "workflow-task-handler",
        "activity-task-handler",
        "event-dispatcher"
      ],
      "concepts": [
        "event-ordering",
        "history-replay",
        "event-scheduling",
        "activity-lifecycle",
        "workflow-execution",
        "event-mapping"
      ],
      "severity": "medium",
      "userImpact": "Users may encounter lookup failures when their workflow history contains events in certain unexpected orders, causing workflow execution to fail.",
      "rootCause": "The SDK's event ordering logic does not properly handle activity task start and completion events that occur before the corresponding workflow task start event.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Added test coverage in sdk-features to replicate the event sequence, though the original bug could not be reproduced.",
      "related": [],
      "keyQuote": "lookup failed for scheduledEventID to activityID: scheduleEventID: 109, activityID: 108",
      "number": 670,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:42.614Z"
    },
    {
      "summary": "Clarify and document which contexts (workflow and activity context parameters) are cancelled when a worker stops, and ensure this behavior is properly tested. The issue was resolved by confirming that GetWorkerStopChannel provides during-stop handling and context cancellation handles after-stop-graceful-handling-timeout.",
      "category": "docs",
      "subcategory": "worker-lifecycle",
      "apis": [
        "GetWorkerStopChannel"
      ],
      "components": [
        "worker",
        "activity",
        "context-management"
      ],
      "concepts": [
        "graceful-shutdown",
        "context-cancellation",
        "worker-stop",
        "timeout-handling"
      ],
      "severity": "low",
      "userImpact": "Users need clear documentation on which contexts are cancelled during worker shutdown to properly implement graceful shutdown logic.",
      "rootCause": "Lack of clarity in documentation about context cancellation behavior during worker stop; the functionality was already implemented but not clearly documented.",
      "proposedFix": "Document that GetWorkerStopChannel can be used for during-worker-stop graceful handling, and parameter context can be used for after-worker-stop-graceful-handling-timeout handling.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by confirming existing functionality in GetWorkerStopChannel documentation. Clarified that workflow contexts don't need worker-tied cancellation (workflows run less than a second), while activity contexts have specific cancellation semantics.",
      "related": [],
      "keyQuote": "the parameter context can be used for after-worker-stop-graceful-handling-timeout handling",
      "number": 667,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:41.480Z"
    },
    {
      "summary": "Issue placeholder requesting to move to the next item. Minimal content with no technical details.",
      "category": "other",
      "subcategory": "administrative",
      "apis": [],
      "components": [],
      "concepts": [],
      "severity": "low",
      "userImpact": "No user impact - this appears to be an internal administrative placeholder.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue contains only a placeholder comment with no actionable content.",
      "related": [],
      "keyQuote": "Move to next issue",
      "number": 666,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:42.897Z"
    },
    {
      "summary": "Channel Receive currently requires a pointer to a pointer when converting from a pointer type, but the feature request is to allow regular pointers for this conversion, similar to how futures already work.",
      "category": "feature",
      "subcategory": "channels",
      "apis": [
        "Receive",
        "Send"
      ],
      "components": [
        "channels",
        "type-conversion"
      ],
      "concepts": [
        "pointer-conversion",
        "type-safety",
        "API-consistency",
        "generics",
        "data-marshaling"
      ],
      "severity": "low",
      "userImpact": "Users must use pointer-to-pointer types when receiving values from channels with Send, creating unnecessary complexity and inconsistency with other Temporal APIs.",
      "rootCause": "Channel Receive implementation requires explicit pointer-to-pointer dereferencing instead of supporting implicit conversion like other parts of the SDK.",
      "proposedFix": "Modify channel Receive to accept regular pointers when converting pointer types, matching the behavior of futures and other SDK conversion patterns.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        593
      ],
      "keyQuote": "Support regular pointers when converting pointers in channels instead of always requiring pointers to pointers.",
      "number": 665,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:27.943Z"
    },
    {
      "summary": "Request to add Must-style convenience functions (MustNewInterceptor and MustNewTracingInterceptor) for opentracing and opentelemetry that panic on error instead of returning error values, since these functions don't typically fail in practice.",
      "category": "feature",
      "subcategory": "interceptor-api",
      "apis": [
        "MustNewInterceptor",
        "MustNewTracingInterceptor"
      ],
      "components": [
        "interceptor",
        "opentracing",
        "opentelemetry"
      ],
      "concepts": [
        "convenience-function",
        "error-handling",
        "sdk-api",
        "must-pattern",
        "panic-on-error"
      ],
      "severity": "low",
      "userImpact": "Provides a more convenient API for users who want to use opentracing/opentelemetry interceptors without handling errors that rarely occur in practice.",
      "rootCause": null,
      "proposedFix": "Add Must-style wrapper functions that panic on error instead of returning errors.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Author reconsidered the value of these convenience shortcuts and determined they were not worth adding.",
      "related": [],
      "keyQuote": "I'm no longer convinced in the value of these shortcuts. We should reopen if necessary.",
      "number": 664,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:26.179Z"
    },
    {
      "summary": "The SetStartWorkflowOptions method in the test suite doesn't properly set the workflow ID when passed via the ID field. Users cannot rename workflows in tests because the ID option is ignored during ExecuteWorkflow.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "SetStartWorkflowOptions",
        "ExecuteWorkflow",
        "GetInfo"
      ],
      "components": [
        "test-environment",
        "workflow-info",
        "test-suite"
      ],
      "concepts": [
        "workflow-id",
        "test-configuration",
        "options-handling",
        "workflow-execution",
        "test-setup"
      ],
      "severity": "medium",
      "userImpact": "Users cannot set custom workflow IDs in test environments, limiting test flexibility and forcing them to work with default IDs.",
      "rootCause": "The setStartWorkflowOptions function does not handle the ID field from StartWorkflowOptions, only checking and setting timeout and task queue properties.",
      "proposedFix": "Add ID field handling to the setStartWorkflowOptions function to set wf.WorkflowExecution.ID when options.ID is provided.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The ID field handling was added to setStartWorkflowOptions to properly set the workflow ID from StartWorkflowOptions.",
      "related": [],
      "keyQuote": "If a new ID is passed in, it's not set on the workflowInfo.",
      "number": 661,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:29.633Z"
    },
    {
      "summary": "Exploration of deprecating the `Control` attribute used in signal external workflow and request cancel external workflow operations in the Go SDK. The `Control` field was inherited from Cadence SDK and contains an auto-incremented ID for internal state machine tracking, but its deprecation needs careful evaluation for compatibility concerns.",
      "category": "feature",
      "subcategory": "external-workflow-operations",
      "apis": [
        "SignalExternalWorkflow",
        "RequestCancelExternalWorkflow"
      ],
      "components": [
        "decision-state-machine",
        "event-handlers",
        "internal-state-management"
      ],
      "concepts": [
        "deprecation",
        "state-machine",
        "backwards-compatibility",
        "external-workflow-control",
        "id-tracking",
        "api-design"
      ],
      "severity": "low",
      "userImpact": "Users currently depend on the Control attribute for external workflow operations; deprecation would require migration path and compatibility considerations.",
      "rootCause": "The Control attribute is an inherited design from Cadence SDK used for auto-incrementing IDs in internal state machine tracking across multiple operation types (activities, timers, child workflows, etc.), making it difficult to deprecate without breaking changes.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I am afraid it is not easy to deprecate since it is in active use and could affect compatibility if changed.",
      "number": 659,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:15.009Z"
    },
    {
      "summary": "gogo/protobuf is unmaintained and the SDK should migrate to google.golang.org/protobuf. Migration is blocked on server-side changes, but there's debate about whether the performance concerns still apply for general-purpose worker clients.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "protobuf-serialization",
        "payload-converter",
        "dependencies"
      ],
      "concepts": [
        "unmaintained-dependency",
        "backwards-compatibility",
        "migration",
        "protobuf-library",
        "performance"
      ],
      "severity": "medium",
      "userImpact": "Users may be exposed to security risks or bugs from an unmaintained protobuf dependency, and the SDK carries unnecessary legacy support code.",
      "rootCause": "gogo/protobuf is unmaintained and blocked on server-side API migration (temporalio/temporal#38)",
      "proposedFix": "Migrate to google.golang.org/protobuf as the standard library, pending resolution of server-side blocking issues",
      "workaround": "The gogo dependency is harmless if not used in user code; only affects those using gogoproto structs",
      "resolution": "fixed",
      "resolutionDetails": "Issue closed but gogo dependency retained for backwards compatibility in ProtoJSONPayloadConverter and ProtoPayloadConverter",
      "related": [
        38
      ],
      "keyQuote": "gogoproto is still in the mod file because ProtoJSONPayloadConverter and ProtoPayloadConverter support gogoproto structs and we did not remove support for backwards compatibility",
      "number": 658,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:13.520Z"
    },
    {
      "summary": "The Go SDK's activity heartbeat throttling interval is hardcoded to 10 minutes, which is longer than other SDKs. This issue requests making the interval configurable and reducing the default to be more consistent across all Temporal SDKs.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "ActivityOptions",
        "HeartbeatDetails"
      ],
      "components": [
        "activity-executor",
        "heartbeat-throttler",
        "worker-config"
      ],
      "concepts": [
        "heartbeat",
        "throttling",
        "configuration",
        "activity-timeout",
        "consistency",
        "sdk-alignment"
      ],
      "severity": "medium",
      "userImpact": "Users have less control over heartbeat behavior and experience inconsistent activity timeout handling compared to other SDKs due to the long default throttling interval.",
      "rootCause": "The heartbeat throttling interval is hardcoded to 10 minutes in the Go SDK implementation, differing from behavior specified in the cross-SDK specification.",
      "proposedFix": "Make the heartbeat throttling interval configurable through ActivityOptions and reduce the default interval below 10 minutes to match other SDK implementations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The interval was made configurable and the default was reduced to align with other SDKs.",
      "related": [],
      "keyQuote": "Go SDK to implement this behavior: https://temporalio.notion.site/Activity-heartbeats-inconsistent-behavior-between-SDKs-32d81da0748044a8932481d2c9864791",
      "number": 656,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:31:11.294Z"
    },
    {
      "summary": "The mocked version of ExecuteWorkflow in the test suite doesn't accept a custom Context parameter like the production version does, making it difficult to test workflows that rely on context information such as user IDs.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "testsuite",
        "test-workflow-environment",
        "context-propagation"
      ],
      "concepts": [
        "testing",
        "context-injection",
        "context-propagation",
        "workflow-execution",
        "mocking"
      ],
      "severity": "low",
      "userImpact": "Developers cannot easily pass context information to workflows during testing, requiring workarounds like custom context propagators.",
      "rootCause": "The testsuite.TestWorkflowEnvironment.ExecuteWorkflow method signature differs from the production Client.ExecuteWorkflow, lacking context.Context parameter support.",
      "proposedFix": "Add a ctx parameter to the mock variant of ExecuteWorkflow and propagate it through the test environment.",
      "workaround": "Use custom Context Propagators or Interceptors on worker options to inject context information in tests.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed due to lack of concrete use case. The issue reporter could not provide a concrete example of the use case without the test environment, and maintainers explained that context values cannot be injected into workflow context in the same way across distributed systems.",
      "related": [],
      "keyQuote": "The code in my workflows/activities may rely on context information (e.g. user ID). So, in tests, it needs to be passed from somewhere",
      "number": 654,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:57.253Z"
    },
    {
      "summary": "Add support for exposing whether an activity is local in the Go SDK, bringing feature parity with Java SDK's activity.GetInfo API.",
      "category": "feature",
      "subcategory": "activity-info",
      "apis": [
        "activity.GetInfo"
      ],
      "components": [
        "activity",
        "activity-executor",
        "worker"
      ],
      "concepts": [
        "local-activity",
        "activity-metadata",
        "api-parity",
        "SDK-feature",
        "activity-context"
      ],
      "severity": "low",
      "userImpact": "Users cannot determine if an activity is running locally, limiting visibility into activity execution context.",
      "rootCause": null,
      "proposedFix": "Expose the local boolean field on activity.Info structure",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to expose local activity status in activity.GetInfo",
      "related": [],
      "keyQuote": "Java exposes whether an activity is local, Go does not.",
      "number": 648,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:54.961Z"
    },
    {
      "summary": "The SDK's query response API only exposes a single value, but the query registration validates that there are exactly two return types with the second being an error type. This creates a disconnect between the validation rules and the available API surface.",
      "category": "feature",
      "subcategory": "query-interface",
      "apis": [
        "Query"
      ],
      "components": [
        "query-handler",
        "type-validation",
        "response-api"
      ],
      "concepts": [
        "return-types",
        "error-handling",
        "api-consistency",
        "type-safety",
        "validation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot fully utilize query return type validation rules in their code, as the API doesn't expose access to multiple return values despite the underlying validation expecting them.",
      "rootCause": "The query response API design only provides access to a single value, while the registration-time validation enforces exactly two return types (value and error).",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Confirmed that the implementation correctly errors at query registration time if there aren't exactly two return types with the second being an error type.",
      "related": [],
      "keyQuote": "Confirmed that we error at query registration time if there aren't exactly two return types and the second one is error.",
      "number": 646,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:58.632Z"
    },
    {
      "summary": "Upgrade the Tally metrics library to a newer version that has resolved a statsd dependency issue, eliminating the need for users to maintain `replace` directives in their projects.",
      "category": "other",
      "subcategory": "dependencies",
      "apis": [],
      "components": [
        "metrics",
        "tally",
        "statsd"
      ],
      "concepts": [
        "dependency-management",
        "metrics-collection",
        "third-party-libraries",
        "build-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users no longer need to use `replace` directives in their module configuration to work around statsd dependency issues with Tally.",
      "rootCause": "Tally had an unresolved statsd dependency that was fixed in upstream uber-go/tally PR #171.",
      "proposedFix": "Upgrade Tally to the version with the fix merged and tagged, and apply the same upgrade to the server project.",
      "workaround": "Use a `replace` directive in go.mod to work around the statsd dependency issue.",
      "resolution": "fixed",
      "resolutionDetails": "Tally was upgraded to include the statsd dependency fix.",
      "related": [],
      "keyQuote": "Right now anyone using this SDK and statsd has to use a `replace` directive.",
      "number": 645,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:39.969Z"
    },
    {
      "summary": "Workflow panics with 'lookup failed for scheduledEventID to activityID' when root workflow cancels an intermediate workflow that has a cleanup activity and child workflow. The panic occurs during event processing when the SDK fails to map scheduled event IDs to activity IDs.",
      "category": "bug",
      "subcategory": "workflow-cancellation",
      "apis": [
        "ExecuteChildWorkflow",
        "ExecuteActivity",
        "NewDisconnectedContext",
        "WithActivityOptions",
        "WithChildOptions"
      ],
      "components": [
        "decision-state-machine",
        "event-handlers",
        "workflow-execution-context",
        "activity-scheduler"
      ],
      "concepts": [
        "workflow-cancellation",
        "cleanup-activities",
        "child-workflows",
        "event-mapping",
        "disconnected-context",
        "state-machine"
      ],
      "severity": "high",
      "userImpact": "Workflows crash with a panic when attempting to execute cleanup activities after cancellation with child workflows, making graceful shutdown impossible in this pattern.",
      "rootCause": "Mismatch between scheduled event IDs and activity IDs in the decision state machine when processing events for activities scheduled in a disconnected context after child workflow cancellation.",
      "proposedFix": null,
      "workaround": "Avoid executing cleanup activities in a disconnected context after child workflow cancellation, or restructure workflow to not combine child workflows with post-cancellation cleanup.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in a subsequent release by correcting the event ID mapping logic in the decision state machine",
      "related": [],
      "keyQuote": "lookup failed for scheduledEventID to activityID: scheduleEventID: 15, activityID: 14",
      "number": 644,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:44.071Z"
    },
    {
      "summary": "Mock assertion methods like `Once()` and `Twice()` in the Go SDK test framework show inconsistent behavior: panicking on over-invocation (which tests may pass) while failing on under-invocation, making the invocation count assertions unreliable for testing.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "OnActivity",
        "ExecuteWorkflow",
        "AssertExpectations",
        "GetWorkflowError"
      ],
      "components": [
        "test-suite",
        "mock-activity",
        "assertion-framework"
      ],
      "concepts": [
        "mocking",
        "invocation-count",
        "test-assertions",
        "retry-logic",
        "panic-handling",
        "assertion-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users writing tests for activities with retries get misleading test results when using invocation count assertions, as over-invocations panic but don't fail tests while under-invocations properly fail.",
      "rootCause": "The underlying testify mock library only fails assertions at the assertion site for fewer calls than expected, but panics at call-site for more calls, and panics in workflows don't automatically fail tests unless explicitly checked.",
      "proposedFix": "Either document that invocation count assertions should not be used, or recover from panics and fail the test when assertion violations occur.",
      "workaround": "Manually count invocations in the mock body and assert later, or check `env.GetWorkflowError()` for panic errors with prefix matching and fail the test explicitly.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        608
      ],
      "keyQuote": "invocation count assertions should probably best be avoided...the ease of adding counts can tempt one to overly assert counts leading to unnecessary expectations about the internals",
      "number": 642,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:39.954Z"
    },
    {
      "summary": "Expose the gRPC client and connection settings to users to provide greater flexibility in customizing gRPC behavior. Currently these are hidden from users, limiting their ability to configure advanced options.",
      "category": "feature",
      "subcategory": "grpc-client",
      "apis": [
        "WorkflowService"
      ],
      "components": [
        "client",
        "connection",
        "grpc-client"
      ],
      "concepts": [
        "grpc",
        "dial-options",
        "context",
        "client-customization",
        "api-exposure"
      ],
      "severity": "medium",
      "userImpact": "Users gain the ability to customize gRPC client behavior and dial options, enabling advanced configuration scenarios previously impossible.",
      "rootCause": null,
      "proposedFix": "Add WorkflowService() method to Client and expose GRPCDialOptions in ConnectionOptions, applying custom options after SDK defaults.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The gRPC client and dial options were exposed to users as requested through API additions.",
      "related": [],
      "keyQuote": "the benefit of hiding gRPC no longer outweighs the cost of decreased user flexibility",
      "number": 641,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:27.585Z"
    },
    {
      "summary": "ExecuteWorkflow with string name fails when passing fewer parameters than the workflow expects, causing a panic that regressed from a previous release.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "workflow-executor",
        "parameter-binding"
      ],
      "concepts": [
        "parameter-mismatch",
        "workflow-invocation",
        "backward-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot use ExecuteWorkflow with string names and variable argument counts, breaking existing code patterns.",
      "rootCause": "Regression introduced in PR #610 that changed how parameters are validated for string-based workflow execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bug was fixed by reverting or correcting the parameter validation logic introduced in #610.",
      "related": [
        610
      ],
      "keyQuote": "This works in all released versions, but just regressed in #610 to cause a panic.",
      "number": 639,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:25.823Z"
    },
    {
      "summary": "Activity cancellation and heartbeats don't work properly without HeartbeatTimeout set. Documentation needs clarification on the 10-minute batching default and its impact on cancellation timing.",
      "category": "docs",
      "subcategory": "activity-heartbeat",
      "apis": [
        "ExecuteActivity",
        "RecordHeartbeat"
      ],
      "components": [
        "activity-executor",
        "heartbeat-handler",
        "cancellation-mechanism"
      ],
      "concepts": [
        "cancellation",
        "heartbeat",
        "timeout",
        "context",
        "batching",
        "server-sync"
      ],
      "severity": "high",
      "userImpact": "Users may experience delayed activity cancellation (up to 10 minutes) or silent failures when using heartbeats without configuring HeartbeatTimeout.",
      "rootCause": "Internal 10-minute batching default is applied when HeartbeatTimeout is not set, causing significant delays in actual server-side heartbeat transmission and cancellation detection.",
      "proposedFix": "Document the requirement for HeartbeatTimeout and add warnings when heartbeating is attempted without it. Clarify the 10-minute batching behavior and its impact on cancellation timing.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation updated and warnings added to alert users when heartbeating without HeartbeatTimeout configured.",
      "related": [],
      "keyQuote": "After the first heartbeat, it can take 10m to actually send another heartbeat which is what tells it the activity has been cancelled.",
      "number": 638,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:24.718Z"
    },
    {
      "summary": "Users need a way to start a worker for activity-only execution without registering workflow handlers. Request for a WorkerOption flag to explicitly disable the workflow worker component.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "RegisterWorkflow"
      ],
      "components": [
        "worker",
        "workflow-worker",
        "registry",
        "activity-worker"
      ],
      "concepts": [
        "worker initialization",
        "lazy loading",
        "optional components",
        "activity-only execution",
        "backward compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently run a worker that only handles activities, limiting deployment flexibility for activity-dedicated hosts.",
      "rootCause": "Workflow worker is always initialized regardless of whether workflows will be registered, with no option to disable it.",
      "proposedFix": "Add a WorkerOption flag to explicitly disable workflow worker initialization, with lazy startup of workflow worker deferred until first workflow registration.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as a WorkerOption flag for backward compatibility, following discussion that concluded the options flag approach was the best compromise.",
      "related": [],
      "keyQuote": "After an offline discussion, it looks like the original proposal with the options flag is the best compromise which is backward compatible.",
      "number": 636,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:10.889Z"
    },
    {
      "summary": "User reported that concurrent ExecuteWorkflow calls generated the same RunID, but this was actually expected behavior where workflow IDs need to be unique and the default ID reuse policy creates new run IDs for failed workflows.",
      "category": "question",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflow",
        "GetID",
        "GetRunID"
      ],
      "components": [
        "workflow-client",
        "workflow-execution",
        "id-reuse-policy"
      ],
      "concepts": [
        "workflow-id",
        "run-id",
        "concurrent-execution",
        "id-reuse-policy",
        "workflow-uniqueness"
      ],
      "severity": "low",
      "userImpact": "Users may be confused about workflow ID and run ID semantics when executing concurrent workflows, expecting each execution to have a unique ID.",
      "rootCause": "User misunderstanding of the difference between workflow ID and run ID, and the intended behavior of the default ID reuse policy.",
      "proposedFix": null,
      "workaround": "Use unique workflow IDs for each concurrent execution, or configure the StartWorkflowOptions with appropriate ID reuse policies.",
      "resolution": "invalid",
      "resolutionDetails": "Issue was resolved as invalid - the reported behavior was actually expected and correct. The user was confusing workflow ID with run ID, and the default reuse policy behavior is by design.",
      "related": [],
      "keyQuote": "Multiple workflow runs should use unique workflow IDs. Of course reusing an ID on a failed workflow by default creates a new run ID.",
      "number": 630,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:12.716Z"
    },
    {
      "summary": "Request for a built-in API to help manage ContinueAsNew requirements for infinitely running workflows. Users currently need to implement custom wrappers to track action counts and history size to determine when to call ContinueAsNew.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteActivity",
        "SignalWorkflow",
        "ContinueAsNew"
      ],
      "components": [
        "workflow-engine",
        "client-api",
        "workflow-history"
      ],
      "concepts": [
        "workflow-continuation",
        "history-management",
        "action-tracking",
        "event-counting",
        "workflow-lifecycle",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Users managing multiple infinitely running workflows must implement custom interceptors to track when to call ContinueAsNew, adding complexity and maintenance burden.",
      "rootCause": null,
      "proposedFix": "Provide built-in API to check if ContinueAsNew is required, with configurable limits per workflow type. Expose event count and history size from WorkflowInfo.",
      "workaround": "Wrap the Workflow API in a custom struct that maintains an action counter, incrementing it on stateful API calls, and regularly check if the counter exceeds a safe threshold.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        357
      ],
      "keyQuote": "The history size is now available in WorkflowInfo protobuf so this should be easy to add.",
      "number": 628,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:30:09.866Z"
    },
    {
      "summary": "SDK inconsistently sets RequestId for API calls. Some operations like StartWorkflow set it, but others like SignalWorkflow and CancelWorkflow do not, creating risk of duplicate calls during retries.",
      "category": "bug",
      "subcategory": "request-id-handling",
      "apis": [
        "StartWorkflow",
        "SignalWithStartWorkflow",
        "SignalWorkflow",
        "CancelWorkflow"
      ],
      "components": [
        "client",
        "workflow-service",
        "api-calls"
      ],
      "concepts": [
        "request-id",
        "idempotency",
        "duplicate-prevention",
        "retry-logic",
        "consistency"
      ],
      "severity": "medium",
      "userImpact": "Inconsistent RequestId usage across different workflow operations increases the risk of duplicate execution when SDK retries API calls.",
      "rootCause": "SDK implementation inconsistently sets RequestId parameter across different workflow operation APIs.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "SDK was updated to consistently set RequestId across all API calls.",
      "related": [],
      "keyQuote": "SDK code should always set RequestId to avoid duplicate calls in case of retry.",
      "number": 627,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:55.981Z"
    },
    {
      "summary": "Unhandled panics from workflow code running in coroutines created by workflow.Go() cause crashes. The panic originates from a slice bounds check error in the stack trace generation code.",
      "category": "bug",
      "subcategory": "panic-handling",
      "apis": [
        "workflow.Go"
      ],
      "components": [
        "dispatcher",
        "stack-trace-generation",
        "coroutine-execution"
      ],
      "concepts": [
        "panic-recovery",
        "error-handling",
        "stack-trace",
        "goroutine",
        "bounds-checking"
      ],
      "severity": "high",
      "userImpact": "Unhandled panics in workflow coroutines crash the workflow execution instead of being caught and reported properly.",
      "rootCause": "Slice bounds out of range error in getStackTraceRaw() at internal_workflow.go:863 when processing stack traces from panicking goroutines.",
      "proposedFix": "Add bounds checks to the stack trace line filter to prevent index out of range panics.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bounds checks were added to the stack trace line filter despite inability to replicate the exact conditions.",
      "related": [],
      "keyQuote": "Despite being unable to replicate, I am adding bounds checks to the stack trace line filter.",
      "number": 624,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:55.197Z"
    },
    {
      "summary": "Activity cancellation fails during event handling when unwinding, a regression introduced in v1.10.0. The issue occurs in specific scenarios when activities need to be cancelled and events must be properly handled during the unwinding process.",
      "category": "bug",
      "subcategory": "activity-cancellation",
      "apis": [],
      "components": [
        "activity-executor",
        "event-handler",
        "workflow-execution"
      ],
      "concepts": [
        "cancellation",
        "event-handling",
        "unwinding",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Users experience failures when cancelling activities in certain scenarios, breaking activity execution reliability.",
      "rootCause": "Regression introduced in v1.10.0 (PR #504) in the event handling logic during activity cancellation unwinding",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        504,
        481
      ],
      "keyQuote": "Activity cancellation has an event problem when unwinding. This was introduced in v1.10.0 in #504.",
      "number": 623,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:57.427Z"
    },
    {
      "summary": "Local activities do not catch panics, preventing proper retry behavior. Panics inside goroutines started by the local activity executor are not recovered, causing the worker to crash instead of handling the error gracefully.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "task-pollers",
        "local-activity-executor",
        "worker"
      ],
      "concepts": [
        "panic-recovery",
        "error-handling",
        "retry-logic",
        "goroutine-management",
        "activity-execution"
      ],
      "severity": "high",
      "userImpact": "Local activities crash the worker when they panic, preventing proper error recovery and retry policies from being applied.",
      "rootCause": "Panics inside goroutines started in internal_task_pollers.go line 537 are not recovered or caught.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Panic recovery was added to the local activity executor to catch panics and treat them as activity failures subject to retry logic.",
      "related": [],
      "keyQuote": "Local activities, to be subject to retry and such like regular activities, should recover from panics.",
      "number": 621,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:40.300Z"
    },
    {
      "summary": "Tracing tags are inconsistent across Temporal SDKs. This feature request seeks to standardize tracing tags across Java, TypeScript, Go, and other SDKs for consistent observability and monitoring.",
      "category": "feature",
      "subcategory": "tracing-observability",
      "apis": [],
      "components": [
        "tracing",
        "observability",
        "sdk-coordination"
      ],
      "concepts": [
        "tracing",
        "tags",
        "observability",
        "consistency",
        "cross-sdk",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Inconsistent tracing tags across SDKs make it difficult for users to monitor and correlate Temporal workflows across polyglot deployments.",
      "rootCause": null,
      "proposedFix": "Standardize tracing tag naming and structure across all Temporal SDKs (Java, TypeScript, Go, Python, etc.)",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        862,
        360
      ],
      "keyQuote": "Tracing tags are not consistent across SDKs.",
      "number": 619,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:43.261Z"
    },
    {
      "summary": "Documentation for worker.New incorrectly references a non-existent namespace parameter. Additionally, the docs lack clarity about why creating a worker requires a client.Client instance.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "worker.New",
        "client.Client"
      ],
      "components": [
        "worker",
        "documentation"
      ],
      "concepts": [
        "api-docs",
        "parameter-documentation",
        "client-dependency",
        "worker-initialization"
      ],
      "severity": "low",
      "userImpact": "Users reading worker.New documentation are confused by references to non-existent parameters and unclear explanations of the client requirement.",
      "rootCause": "Documentation comments reference a namespace parameter that doesn't exist in the worker.New function signature.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Author committed to clarifying the worker.New docs to explain the client requirement.",
      "related": [],
      "keyQuote": "worker.New has docs that refer to a non-existent namespace param (also check other docs for the same bad params).",
      "number": 618,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:41.460Z"
    },
    {
      "summary": "User requested better error messages when calling an activity with the wrong number of parameters. Currently, the SDK silently accepts fewer parameters and only reports type mismatches on the first misaligned parameter, making debugging difficult.",
      "category": "feature",
      "subcategory": "activity-validation",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "parameter-validation",
        "error-reporting"
      ],
      "concepts": [
        "parameter-count",
        "error-messages",
        "debugging",
        "type-mismatch",
        "function-signature"
      ],
      "severity": "low",
      "userImpact": "Users debugging activity parameter mismatches receive unclear error messages about type failures instead of parameter count violations, extending debug time.",
      "rootCause": "The SDK validates parameters by attempting to decode each one sequentially without first checking parameter count matches the activity function signature.",
      "proposedFix": "Add parameter count validation before attempting to decode individual parameters, reporting count mismatches explicitly.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "The maintainer determined the SDK intentionally allows fewer parameters (giving zero values to missing ones), so the current behavior is by design. The type error on misaligned parameters is the correct diagnostic.",
      "related": [],
      "keyQuote": "Any parameter you don't provide will be given the zero value. Therefore fewer parameters are allowed. The error about it being the wrong type is the correct one.",
      "number": 617,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:26.481Z"
    },
    {
      "summary": "Investigate discrepancies between client-side and server-side gRPC request latency measurements in the Go SDK. Proposed solutions include adding gRPC metadata with server-measured durations and exposing lower-level gRPC stats to identify whether differences stem from interceptor overhead or HTTP/2 message handling.",
      "category": "feature",
      "subcategory": "metrics-observability",
      "apis": [],
      "components": [
        "grpc-client",
        "interceptor",
        "metrics",
        "dial-options"
      ],
      "concepts": [
        "latency",
        "observability",
        "gRPC-stats",
        "performance-measurement",
        "request-duration",
        "metadata"
      ],
      "severity": "medium",
      "userImpact": "Users cannot accurately measure and compare end-to-end latency between client and server, making it difficult to diagnose performance issues.",
      "rootCause": "Difference between client-measured latency (including serialization/interceptor operations) and server-measured latency; unclear which measurement point is authoritative.",
      "proposedFix": "Expose gRPC stats via dial options and implement server-side gRPC interceptor to include end-to-end duration in metadata for comparison and warning thresholds.",
      "workaround": "Use external profiling tools or metrics collectors to separately measure client and server latencies.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "See if there is a gRPC metric that is low-level enough to apply to HTTP2 messages specifically so that we can see if there is a difference between our interceptor-based ones",
      "number": 616,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:28.300Z"
    },
    {
      "summary": "Add support for header propagation in signal and query interceptors, matching the existing implementation for workflows and activities. This feature requires server-side changes and depends on related issues for completion.",
      "category": "feature",
      "subcategory": "interceptors",
      "apis": [],
      "components": [
        "interceptors",
        "signals",
        "queries"
      ],
      "concepts": [
        "header-propagation",
        "interceptors",
        "signals",
        "queries",
        "cross-cutting-concerns"
      ],
      "severity": "medium",
      "userImpact": "Users cannot propagate headers through signal and query interceptors, limiting integration with distributed tracing and context propagation systems.",
      "rootCause": null,
      "proposedFix": "Support header propagation for signals and queries using the same mechanism as workflows and activities",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "PR implementation completed, waiting for server release to update CI and merge",
      "related": [
        610
      ],
      "keyQuote": "Support header propagation for signals and queries the same way as we do for workflows and activities.",
      "number": 615,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:23.970Z"
    },
    {
      "summary": "Cron child workflows with PARENT_CLOSE_POLICY_ABANDON run forever in test environments due to auto-fire timers, causing tests to hang indefinitely until timeout. The test suite needs a way to terminate child cron workflows regardless of their parent close policy.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "WithChildWorkflowOptions",
        "GetWorkflowInfo",
        "Sleep",
        "NewTimer",
        "NewSelector"
      ],
      "components": [
        "workflow-testsuite",
        "cron-workflow",
        "child-workflow",
        "parent-close-policy"
      ],
      "concepts": [
        "cron-scheduling",
        "child-workflows",
        "parent-policy",
        "test-timeout",
        "workflow-termination",
        "infinite-loop"
      ],
      "severity": "high",
      "userImpact": "Users cannot test cron child workflows with abandon policy in the test suite without the test hanging and eventually panicking on timeout.",
      "rootCause": "Cron workflows with auto-fire timers continue firing even with PARENT_CLOSE_POLICY_ABANDON in test environments, and the test suite lacks a mechanism to terminate child workflows regardless of their parent close policy.",
      "proposedFix": "Implement a \"close\" or \"terminate all\" method on the test environment that stops all workflows for that test regardless of how they were started or their parent close policy.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed by implementing test environment enhancements to handle cron workflow termination with abandon policies.",
      "related": [
        471
      ],
      "keyQuote": "within testsuite, if you run a child cron-job with PARENT_CLOSE_POLICY_ABANDON the test will run forever until it hits a time-out, in which case it panics",
      "number": 614,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:10.053Z"
    },
    {
      "summary": "User requests ability to mock activities with the same name on different task queues in test workflows. Currently, the testing framework cannot distinguish between identically-named activities running on different queues, forcing users to rename activities to disambiguate them in tests.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "RegisterActivity",
        "OnActivity"
      ],
      "components": [
        "test-suite",
        "activity-mocking",
        "task-queue-routing"
      ],
      "concepts": [
        "activity-registration",
        "task-queue-isolation",
        "mock-filtering",
        "test-mocking",
        "activity-disambiguation"
      ],
      "severity": "medium",
      "userImpact": "Users must rename activities to have different names when testing multiple activities with the same signature on different task queues, reducing code clarity and consistency.",
      "rootCause": "TestWorkflowEnvironment.OnActivity and Worker.RegisterActivity do not support task-queue-specific registration, treating all activities with the same name as identical regardless of their target queue.",
      "proposedFix": "Add task-queue filtering capability to OnActivity mock registration to allow specifying which queue an activity mock applies to, similar to how activities are dispatched at runtime.",
      "workaround": "Use a callback function with activity.GetInfo(ctx).TaskQueue checks inside the mock to handle multiple activities with the same name, though this requires correct signature matching and is less robust.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers determined that task-queue-specific mocking would require significant changes to the registration system. Users were advised to rename activities with domain prefixes (e.g., GetCarById instead of GetById) for clarity.",
      "related": [],
      "keyQuote": "It would be a significant change I'm afraid to have task-queue specific registration and mocking inside the test suite.",
      "number": 609,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:12.676Z"
    },
    {
      "summary": "Request to make EncodingDataConverter and payload encoders context-aware to access contextual information during encoding. The feature was ultimately abandoned due to architectural constraints (avoiding circular package dependencies between converter and workflow packages).",
      "category": "feature",
      "subcategory": "data-conversion",
      "apis": [],
      "components": [
        "converter",
        "payload-encoder",
        "data-converter"
      ],
      "concepts": [
        "context-awareness",
        "data-encoding",
        "package-dependencies",
        "circular-imports"
      ],
      "severity": "low",
      "userImpact": "Users cannot access contextual information when using custom encoding data converters and payload encoders.",
      "rootCause": "Circular package dependency between converter and workflow packages prevents implementation of context-aware encoding converters.",
      "proposedFix": "Make EncodingDataConverter and PayloadEncoder context-aware by calling underlying context-aware implementations.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Feature was abandoned due to architectural constraints - maintaining package separation between converter and workflow packages to avoid circular dependencies was deemed more important than context-awareness for encoding converters.",
      "related": [],
      "keyQuote": "After some thought, we have decided to abandon context-awareness for encoding data converters at the moment.",
      "number": 607,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:29:09.678Z"
    },
    {
      "summary": "User requests a non-blocking variant of WorkflowRun.Get() that returns immediately instead of long-polling when the workflow is still running, to avoid blocking behavior and timeout issues on slower networks.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowRun.Get",
        "Client.DescribeWorkflowExecution"
      ],
      "components": [
        "workflow-client",
        "workflow-execution"
      ],
      "concepts": [
        "blocking-call",
        "long-poll",
        "non-blocking",
        "workflow-status",
        "timeout"
      ],
      "severity": "low",
      "userImpact": "Users must choose between blocking indefinitely or using a low timeout that may fail on slow networks when waiting for workflow completion.",
      "rootCause": null,
      "proposedFix": "Add a flag to WorkflowRun.Get() or create a new method (e.g., TryGet, GetAsync) that returns immediately without long-polling.",
      "workaround": "Call Client.DescribeWorkflowExecution in a loop until workflow status is no longer running, then call Get().",
      "resolution": "wontfix",
      "resolutionDetails": "Team decided the workaround is sufficient and adding this method to the interface is not worth the maintenance burden since it would be equivalent to the existing workaround.",
      "related": [],
      "keyQuote": "It will be useful to add a flag in this method (or define a new method) that does not do long poll and instead returns immediately if the workflow is still running.",
      "number": 604,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:54.777Z"
    },
    {
      "summary": "SignalWithStartWorkflow accepts workflow ID in two different ways (parameter and options), but only uses the parameter form while ignoring the options form, creating a confusing API. The request is to document this behavior clearly and add validation to error when the options ID differs from the parameter.",
      "category": "other",
      "subcategory": "workflow-execution",
      "apis": [
        "SignalWithStartWorkflow",
        "SignalWorkflow",
        "ExecuteWorkflow"
      ],
      "components": [
        "workflow-client",
        "signal-execution",
        "api-design"
      ],
      "concepts": [
        "workflow-id",
        "parameter-consistency",
        "api-design",
        "validation",
        "documentation"
      ],
      "severity": "medium",
      "userImpact": "Users may provide workflow ID in options expecting it to be used, but it gets silently ignored, leading to unexpected behavior and confusion.",
      "rootCause": "SignalWithStartWorkflow uses parameter-based ID (like SignalWorkflow) instead of options-based ID (like ExecuteWorkflow), creating inconsistent API patterns.",
      "proposedFix": "Document that ID in options is disallowed and add error handling to reject requests where the options ID differs from the workflowID parameter.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was addressed by enforcing consistent parameter usage and validation in SignalWithStartWorkflow.",
      "related": [],
      "keyQuote": "Document that the ID in options is disallowed and error if it is provided and is different than the workflowID parameter.",
      "number": 603,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:56.905Z"
    },
    {
      "summary": "Replace deprecated OpenTracing API with OpenTelemetry API for distributed tracing support. The issue requests modernization to use OpenTelemetry instead of the superseded OpenTracing framework.",
      "category": "feature",
      "subcategory": "observability-tracing",
      "apis": [],
      "components": [
        "tracing",
        "instrumentation",
        "observability"
      ],
      "concepts": [
        "distributed-tracing",
        "opentelemetry",
        "context-propagation",
        "observability",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use modern OpenTelemetry for distributed tracing and must rely on the deprecated OpenTracing API.",
      "rootCause": "OpenTracing is superseded by OpenTelemetry; context propagation issues prevent using OpenTelemetry bridge with OpenTracing.",
      "proposedFix": "Replace OpenTracing API with OpenTelemetry API for native support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of issue #529 and proposal https://github.com/temporalio/proposals/pull/45",
      "related": [
        529
      ],
      "keyQuote": "OpenTracing API needs to be replaced with OpenTelemetry API.",
      "number": 602,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:53.305Z"
    },
    {
      "summary": "Request to support querying workflow metadata. This is a feature request blocked on SDK consensus across Temporal SDKs regarding how to expose workflow metadata query capabilities.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [],
      "components": [
        "workflow",
        "query-api"
      ],
      "concepts": [
        "workflow-metadata",
        "query",
        "state-inspection",
        "workflow-inspection"
      ],
      "severity": "medium",
      "userImpact": "Users cannot query and retrieve metadata about running workflows across SDKs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Issue closed with external dependency label, blocked on SDK features consensus (temporalio/features#51) without implementation.",
      "related": [
        51
      ],
      "keyQuote": "See original issue temporalio/sdk-features#51",
      "number": 601,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:39.022Z"
    },
    {
      "summary": "Child workflow logger was reported to be outputting during replay, which should not occur as loggers should not log on replay. Upon investigation, the issue could not be replicated and was confirmed by the original user to not be an issue.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "IsReplaying"
      ],
      "components": [
        "workflow",
        "logger",
        "child-workflow"
      ],
      "concepts": [
        "replay",
        "logging",
        "determinism",
        "workflow-execution"
      ],
      "severity": "low",
      "userImpact": "Users may see unexpected log output during child workflow replays, potentially causing confusion about logging behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "The issue could not be replicated by the maintainer. When testing child workflows with workflow.IsReplaying(ctx) returning true, no logging occurred. The original user confirmed this is not an issue.",
      "related": [],
      "keyQuote": "Confirmed from original user that this is not an issue.",
      "number": 600,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:42.260Z"
    },
    {
      "summary": "Implement a data converter wrapper that compresses payloads using a customizable algorithm with configurable minimum size threshold. The converter must handle previously compressed data transparently and support both single Payload and multiple Payloads approaches.",
      "category": "feature",
      "subcategory": "data-converter",
      "apis": [],
      "components": [
        "data-converter",
        "payload-handler",
        "compression-algorithm"
      ],
      "concepts": [
        "compression",
        "payload-wrapping",
        "data-serialization",
        "performance-optimization",
        "algorithm-customization"
      ],
      "severity": "medium",
      "userImpact": "Users gain ability to reduce data size in workflows and activities through transparent compression, improving storage and network efficiency.",
      "rootCause": null,
      "proposedFix": "Create a compression data converter wrapper that compresses individual Payloads with configurable algorithms and minimum size thresholds, with option to combine multiple payloads into a single compressed payload.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as a configurable data converter wrapper supporting compression algorithms with customizable minimum size threshold.",
      "related": [],
      "keyQuote": "We can compress all of the separate Payloads into a single Payload and do the reverse when we decompress.",
      "number": 596,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:40.801Z"
    },
    {
      "summary": "Users need a public method to check if the WorkflowClient's underlying connection to the Temporal server is healthy. Currently, a private checkHealth method exists but is not exposed for user-facing observability and auto-recovery use cases.",
      "category": "feature",
      "subcategory": "health-check",
      "apis": [
        "WorkflowClient",
        "WorkflowServiceStubs"
      ],
      "components": [
        "client",
        "connection",
        "grpc-channel"
      ],
      "concepts": [
        "health-check",
        "connection-status",
        "observability",
        "auto-recovery",
        "gRPC-health",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users cannot programmatically verify if their WorkflowClient connection is healthy, limiting observability and preventing automated recovery strategies.",
      "rootCause": "The checkHealth method exists but is private and not exposed in the public API.",
      "proposedFix": "Expose a public healthCheck or isHealthy method on WorkflowServiceStubs (or WorkflowClient if stubs wrapper unavailable), implementing gRPC health check protocol.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The health check functionality was exposed as a public method on the WorkflowClient.",
      "related": [
        828,
        312
      ],
      "keyQuote": "Temporal SDK should expose a method like WorkflowServiceStubs#healthCheck that allows users to check if the WorkflowClient underlying connection to Temporal server is healthy.",
      "number": 595,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:28.347Z"
    },
    {
      "summary": "Request for metrics to monitor task pool status and worker capacity in the Go SDK. Users need visibility into how many concurrent tasks are running versus the maximum allowed to determine if their worker fleet is appropriately sized.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "task-scheduler",
        "metrics"
      ],
      "concepts": [
        "concurrent-tasks",
        "capacity-monitoring",
        "resource-utilization",
        "fleet-scaling",
        "worker-pool"
      ],
      "severity": "medium",
      "userImpact": "Users cannot determine fleet adequacy or implement dynamic scaling without metrics for current task capacity usage.",
      "rootCause": null,
      "proposedFix": "Implement gauge metrics for running tasks and a fixed metric for max tasks, possibly with labels per task type.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Metrics were implemented to expose task pool status including running task counts and maximum capacity limits.",
      "related": [
        569
      ],
      "keyQuote": "a gauge for running tasks and a fixed metric for max tasks...let me determine if my fleet of workers is large enough",
      "number": 594,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:26.566Z"
    },
    {
      "summary": "Index out of range panic occurring in ringpop-go's memberlist iterator when accessing members. The panic happens at index 1532 with length 1532, indicating a boundary condition issue in the gossiping protocol.",
      "category": "bug",
      "subcategory": "member-discovery",
      "apis": [],
      "components": [
        "ringpop-go",
        "memberlist",
        "gossip-protocol"
      ],
      "concepts": [
        "concurrency",
        "race-condition",
        "bounds-checking",
        "member-list",
        "index-out-of-range"
      ],
      "severity": "high",
      "userImpact": "Temporal Go SDK crashes with a runtime panic during member gossip operations, causing service disruptions.",
      "rootCause": "Off-by-one or race condition in memberlist.MemberAt() or memberlistIter.Next() when accessing members at boundary condition (index 1532 with length 1532).",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was determined to be in ringpop-go dependency (not actively developed), not the SDK itself. User encouraged to reopen if specifically an SDK issue.",
      "related": [],
      "keyQuote": "This appears like it may be an issue with https://github.com/temporalio/ringpop-go instead of this repository.",
      "number": 587,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:25.885Z"
    },
    {
      "summary": "Activity mocking in the test framework fails when attempting to match exact struct argument values. The mock library performs equality checks on pointers by memory address rather than value, causing mismatches for pointer fields in activity input structs.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "OnActivity"
      ],
      "components": [
        "test-framework",
        "activity-mocking",
        "mock-matching"
      ],
      "concepts": [
        "argument-matching",
        "pointer-equality",
        "test-mocking",
        "struct-comparison",
        "memory-address"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably mock activities with pointer fields in input structs during testing, requiring workarounds like custom matchers.",
      "rootCause": "The underlying testify/mock library performs pointer equality checks based on memory address rather than value, and the SDK's OnActivity wrapper doesn't provide special handling for this case.",
      "proposedFix": "Use mock.MatchedBy() with custom comparison logic to match pointer field values instead of memory addresses.",
      "workaround": "Use mock.MatchedBy(func(in *DeleteRoleActivityInput) bool { return *in.Role == \"testRole\" }) to perform custom equality checks on pointer fields.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue is a limitation of the underlying testify/mock library's equality semantics. SDK maintainers clarified that workarounds exist via mock.MatchedBy() and that pointer parameters in activity inputs are generally discouraged.",
      "related": [],
      "keyQuote": "The mocking library is https://pkg.go.dev/github.com/stretchr/testify/mock so the parameter matching is done via Mock.On... it just does equality check. In Go, equality check on pointers means they must point to the same thing.",
      "number": 586,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:11.169Z"
    },
    {
      "summary": "IsWorkflowExecutionAlreadyStartedError does not correctly identify WorkflowExecutionAlreadyStarted errors that occur in child workflows. The error message indicates it's a workflow execution already started error, but the error type checking function returns false.",
      "category": "bug",
      "subcategory": "child-workflows",
      "apis": [
        "ExecuteChildWorkflow",
        "IsWorkflowExecutionAlreadyStartedError"
      ],
      "components": [
        "child-workflow-executor",
        "error-handling",
        "error-detection"
      ],
      "concepts": [
        "error-type-checking",
        "child-workflows",
        "error-unwrapping",
        "execution-errors",
        "error-classification"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably detect and handle WorkflowExecutionAlreadyStarted errors from child workflows, forcing them to use string matching instead of type-safe error checking.",
      "rootCause": "IsWorkflowExecutionAlreadyStartedError function does not properly recognize or unwrap WorkflowExecutionAlreadyStarted errors when they occur within ChildWorkflowExecutionError.",
      "proposedFix": null,
      "workaround": "Compare error message string with 'workflow execution already started' instead of using IsWorkflowExecutionAlreadyStartedError function.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "temporal.IsWorkflowExecutionAlreadyStartedError(err) never returns true, even when the err is cast to ChildWorkflowExecutionError and unwrapped",
      "number": 580,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:13.535Z"
    },
    {
      "summary": "Worker's multiple pollers share a single connection to only one frontend server, causing uneven load distribution. Feature request to distribute pollers across multiple frontend servers for better load balancing.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [],
      "components": [
        "grpc-dialer",
        "worker",
        "frontend-connection"
      ],
      "concepts": [
        "load-distribution",
        "connection-pooling",
        "round-robin",
        "high-availability",
        "scaling"
      ],
      "severity": "medium",
      "userImpact": "Workers cannot efficiently distribute load across multiple frontend servers, limiting scalability when worker count is small relative to frontend server count.",
      "rootCause": "Pollers share a single connection and DNS round-robin only works with DNS-resolved addresses, not explicit address lists.",
      "proposedFix": "Support multiple addresses for explicit round-robin distribution or provide DNS-based round-robin via dns:/// prefix, with potential future support for weighted or fallback connection strategies.",
      "workaround": "Use dns:/// prefix for DNS-based round-robin or start more workers to distribute load evenly.",
      "resolution": "fixed",
      "resolutionDetails": "Immediate use case solved by documenting dns:/// prefix solution. PR #582 and #585 provide explicit multiple address support and documentation respectively.",
      "related": [
        582,
        585
      ],
      "keyQuote": "DNS-based round-robin is already supported today, and we can add a small resolver to work with multiple addresses.",
      "number": 577,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:28:12.396Z"
    },
    {
      "summary": "Documentation comments contain outdated error references (EntityNotExistsError, BadRequestError, InternalServiceError) from old Thrift API that no longer exist and need to be replaced with currently used errors.",
      "category": "docs",
      "subcategory": "documentation-comments",
      "apis": [],
      "components": [
        "documentation",
        "error-handling"
      ],
      "concepts": [
        "error-types",
        "documentation-accuracy",
        "API-migration",
        "code-comments",
        "deprecation"
      ],
      "severity": "low",
      "userImpact": "Users reading documentation comments may encounter references to errors that no longer exist, causing confusion about which exceptions to handle.",
      "rootCause": "Thrift API was replaced with new error types, but documentation comments were not updated to reflect the change.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There are many leftovers from old Thrift errors in documentation comments: `EntityNotExistsError`, `BadRequestError`, `InternalServiceError` and others do not exist anymore",
      "number": 576,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:54.505Z"
    },
    {
      "summary": "The `temporal_activity_endtoend_latency` metric is redundant and misleading, duplicating the sum of `activity_scheduletostart_latency` and `activity_execution_latency`. It should measure the time from when an activity was first scheduled to when it completed successfully, requiring a fix to use `GetScheduledTime` instead of `GetStartedTime`.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "task-pollers"
      ],
      "concepts": [
        "latency",
        "metric-accuracy",
        "activity-lifecycle",
        "timing"
      ],
      "severity": "medium",
      "userImpact": "Users receive misleading metrics about activity execution latency, making it difficult to accurately monitor and diagnose activity performance issues.",
      "rootCause": "The metric uses `GetStartedTime` instead of `GetScheduledTime`, causing it to measure only execution latency rather than the full schedule-to-completion time.",
      "proposedFix": "Change the metric calculation in internal_task_pollers.go line 895 from using `GetStartedTime` to `GetScheduledTime`, and only record the metric when the activity completes successfully.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fix implemented to use `GetScheduledTime` and only record on successful completion, matching Java SDK changes from PR #800.",
      "related": [
        799
      ],
      "keyQuote": "This metric is almost completely duplicative of `activity_scheduletostart_latency` + `activity_execution_latency` currently. It provides effectively no value and is misleading.",
      "number": 573,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:56.933Z"
    },
    {
      "summary": "NewWorkflowReplayer lacks support for custom data converters, preventing users from replaying workflow history with custom serialization logic.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "NewWorkflowReplayer"
      ],
      "components": [
        "workflow-replayer",
        "data-converter"
      ],
      "concepts": [
        "workflow-replay",
        "data-serialization",
        "custom-converter",
        "history-replay",
        "deserialization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot replay workflow history files that were serialized with custom data converters.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "NewWorkflowReplayer should be able to replay history json file with custom data converter",
      "number": 571,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:57.452Z"
    },
    {
      "summary": "The Temporal Go client can only send signals to workflows in the same namespace. The feature request asks for the ability to send signals to workflows in different namespaces, similar to the WithWorkflowNamespace option available within workflows.",
      "category": "feature",
      "subcategory": "signal-namespace",
      "apis": [
        "SignalWorkflow",
        "WithWorkflowNamespace"
      ],
      "components": [
        "client",
        "signal-service",
        "namespace-routing"
      ],
      "concepts": [
        "namespace-isolation",
        "cross-namespace-communication",
        "signal-delivery",
        "client-options",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot send signals across namespaces from the client, limiting multi-tenant and cross-namespace workflow orchestration scenarios.",
      "rootCause": "SignalWorkflow function uses only the client's default namespace and does not support namespace override options like WithWorkflowNamespace does in workflows.",
      "proposedFix": "Add a WithWorkflowNamespace context option to the client's SignalWorkflow method to allow specifying the target namespace, similar to the workflow-level implementation.",
      "workaround": "Create a custom workflow that receives the signal request and forwards the signal to the target namespace using the workflow's WithWorkflowNamespace capability.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by enabling users to use the gRPC service directly to send signals to any namespace, providing more flexible cross-namespace signaling capabilities.",
      "related": [
        641
      ],
      "keyQuote": "With #641, you will be able to use the gRPC service directly to send signals in any way to any namespace.",
      "number": 570,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:43.471Z"
    },
    {
      "summary": "Request to dynamically adjust MaxConcurrentActivityExecutionSize without restarting the worker. Currently, this value can only be set at worker startup, requiring a full restart to change it.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "task-queue"
      ],
      "concepts": [
        "concurrency-limits",
        "dynamic-configuration",
        "resource-management",
        "worker-tuning",
        "slot-allocation"
      ],
      "severity": "medium",
      "userImpact": "Users must restart workers to adjust concurrent activity execution limits, causing service disruption and overhead.",
      "rootCause": "Pool-transfer internals made dynamic adjustment difficult; required redesign of slot management system.",
      "proposedFix": "Expose SlotLimiter interface with AcquireSlot(), ReleaseSlot(), and AvailableSlots() methods; add ActivityTaskSlotLimiter and WorkflowTaskSlotLimiter options to worker configuration.",
      "workaround": "Restart the worker to reset MaxConcurrentActivityExecutionSize, though this is resource-intensive.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented via new WorkerTuner and SlotSupplier interfaces in PR #1546, allowing dynamic slot management without restart.",
      "related": [
        1546
      ],
      "keyQuote": "Without restarting a worker, I would like to be able to adjust the value of MaxConcurrentActivityExecutionSize.",
      "number": 569,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:40.664Z"
    },
    {
      "summary": "Custom data converter is not being applied to local activity results. When using a custom data converter in the SDK, local activity results are not converted through it, appearing as plain text instead of being properly serialized.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity",
        "data-converter",
        "worker"
      ],
      "concepts": [
        "serialization",
        "data-conversion",
        "local-activities",
        "encryption",
        "payload-encoding"
      ],
      "severity": "medium",
      "userImpact": "Users with custom data converters (e.g., for encryption) cannot properly serialize local activity results, breaking their data handling pipeline.",
      "rootCause": "Incorrect wiring of custom data converter in local activity execution path within the Go SDK",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Investigation revealed the issue was actually in the samples-go repository (PR #140), not in the SDK itself. The wiring in the Go SDK is correct.",
      "related": [],
      "keyQuote": "This was actually due to https://github.com/temporalio/samples-go/pull/140, the wiring in the go SDK is correct.",
      "number": 568,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:38.520Z"
    },
    {
      "summary": "LocalActivity is not retried when no retry policy is specified, relying instead on workflow task retries. The issue discusses whether this behavior should be changed and requests unit and integration tests to verify retry behavior for both local and remote activities.",
      "category": "bug",
      "subcategory": "local-activity-retry",
      "apis": [
        "LocalActivity",
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity-executor",
        "task-handlers",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "local-activity",
        "error-handling",
        "workflow-task",
        "failure-recovery"
      ],
      "severity": "medium",
      "userImpact": "Users expect local activities to be automatically retried when activity calls fail, but lack of explicit retry policy configuration prevents retries at the activity level.",
      "rootCause": "When retry options are nil, the code in internal_task_handlers.go prevents local activity retries, instead relying on workflow task retries.",
      "proposedFix": "Add default retry policy behavior for local activities similar to remote activities; add unit and integration tests to verify retry behavior.",
      "workaround": "Currently local activity failures are caught by workflow task retries, which retry until workflow timeout.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "LocalActivity is not retried if no retry policy is specified. Or if retry policy is specified with only MaxAttempt=3 and all other fields left as unspecified.",
      "number": 563,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:27.311Z"
    },
    {
      "summary": "User requests more customizable history output for workflows - the current GetWorkflowHistory output is difficult to manipulate into custom formats since HistoryEvent is directly derived from Protobuf definitions rather than being idiomatic Go structures.",
      "category": "feature",
      "subcategory": "workflow-history",
      "apis": [
        "GetWorkflowHistory"
      ],
      "components": [
        "history",
        "protobuf-bindings",
        "workflow-execution"
      ],
      "concepts": [
        "history-events",
        "event-filtering",
        "data-transformation",
        "protobuf-compatibility",
        "api-ergonomics"
      ],
      "severity": "low",
      "userImpact": "Users providing custom workflow event history output must manually parse and transform Protobuf-derived HistoryEvent structures rather than working with idiomatic Go constructs.",
      "rootCause": "HistoryEvent is directly derived from Protobuf definitions for server compatibility, lacking Go-idiomatic helper methods or conversion utilities.",
      "proposedFix": "Provide helpers around the history object or iterator to extract and transform specific event types and attributes into custom shapes.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers decided to keep raw history for server compatibility but remain open to helper utilities. Issue closed without implementing full conversion to idiomatic Go structs.",
      "related": [],
      "keyQuote": "The raw history does let us remain compatible with the server, but it might make sense to have helpers around either the history object or the iterator to extract certain things.",
      "number": 560,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:25.902Z"
    },
    {
      "summary": "TestCancelTimerAfterActivity test was experiencing flakiness with activity timeout errors during timer cancellation operations. The test has since stabilized and no longer appears flaky in CI.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "RequestCancelTimer",
        "NewTimer"
      ],
      "components": [
        "worker",
        "timer",
        "activity-executor",
        "test-integration"
      ],
      "concepts": [
        "flakiness",
        "timer-cancellation",
        "activity-timeout",
        "scheduling",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests reduce confidence in the SDK and waste developer time with intermittent failures that are difficult to debug.",
      "rootCause": "Activity timeout (ScheduleToStart) occurring during timer cancellation, though the underlying cause was not explicitly identified in the discussion.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The test no longer appears flaky in CI according to the maintainer's comment.",
      "related": [],
      "keyQuote": "This test does not appear flaky anymore in CI",
      "number": 558,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:24.065Z"
    },
    {
      "summary": "TestCancelChildWorkflowUnusualTransitions test is flaky, causing intermittent test failures with assertion errors and panic(nil) runtime issues. The test was later confirmed to be stable in CI.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow"
      ],
      "components": [
        "test-suite",
        "worker",
        "child-workflow"
      ],
      "concepts": [
        "flaky-test",
        "test-stability",
        "race-condition",
        "cancellation",
        "workflow-transition"
      ],
      "severity": "medium",
      "userImpact": "Intermittent test failures disrupt development workflows and CI/CD reliability for contributors working with child workflow cancellation.",
      "rootCause": "Test exhibited flakiness in execution, likely due to timing issues or race conditions in child workflow cancellation transitions, though root cause not explicitly identified.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test stabilized and no longer appears flaky in CI as confirmed by maintainer.",
      "related": [],
      "keyQuote": "This test does not appear flaky anymore in CI",
      "number": 557,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:10.952Z"
    },
    {
      "summary": "TestBasic integration test is flaky, failing with counter value mismatch (expected 5 but got 9) and subtest panic errors. The test appears to have timing or execution order issues causing inconsistent results across runs.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "integration-tests",
        "worker",
        "activity-executor",
        "test-infrastructure"
      ],
      "concepts": [
        "flakiness",
        "timing",
        "test-reliability",
        "counter-accuracy",
        "subtest-execution",
        "panic-handling"
      ],
      "severity": "high",
      "userImpact": "Flaky tests reduce confidence in SDK reliability and block CI/CD pipelines, making it difficult to verify legitimate code changes.",
      "rootCause": "Likely timing or race condition in test execution causing non-deterministic counter values and subtest panic when parent test calls FailNow.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through test framework improvements and timing fixes.",
      "related": [],
      "keyQuote": "Expected value doesn't match actual value for counter temporal_request: expected: int(5) actual: int64(9)",
      "number": 556,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:11.441Z"
    },
    {
      "summary": "TestActivityNotRegisteredRetry test in the Go SDK is flaky, failing with inconsistent metric counts (expected 2 invocations but got 3). The test appears to have been resolved in CI according to later investigation.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "test-suite",
        "activity-executor",
        "worker",
        "metrics"
      ],
      "concepts": [
        "flaky-test",
        "metric-tracking",
        "unregistered-activity",
        "retry-logic",
        "test-stability"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests reduce confidence in the SDK's reliability and make it harder to verify correct behavior of activity retry mechanisms.",
      "rootCause": "Race condition or timing issue in the test causing variable unregistered activity invocation counts, likely related to retry timing.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test no longer appears flaky in CI according to investigation by cretz.",
      "related": [],
      "keyQuote": "This test does not appear flaky anymore in CI",
      "number": 555,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:27:07.764Z"
    },
    {
      "summary": "TestActivityNotRegisteredRetry test is flaky, failing intermittently with metric assertion errors. The test expects counter temporal_unregistered_activity_invocation to be 2 but gets 1, and sometimes fails with panic on parent test.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "test-integration",
        "metrics"
      ],
      "concepts": [
        "flaky-test",
        "race-condition",
        "metric-assertion",
        "activity-registration",
        "retry-logic"
      ],
      "severity": "medium",
      "userImpact": "Test failures create noise in CI/CD pipelines and make it difficult to detect real issues, affecting developer productivity.",
      "rootCause": "Likely a race condition in metric collection or activity retry logic that causes the counter to not increment reliably under certain timing conditions.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Author closed the issue due to difficulty reproducing it individually, suggesting it may be environment-specific or require further investigation.",
      "related": [],
      "keyQuote": "Hard to repro individually. Going to close for now.",
      "number": 554,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:55.062Z"
    },
    {
      "summary": "TestAsyncActivityCompletion test was flaky in CI, sometimes producing only one asyncComplete result instead of the expected two. The test no longer appears to be flaky according to maintainer comments.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "integration-tests",
        "async-activity-completion"
      ],
      "concepts": [
        "test-flakiness",
        "async-operations",
        "activity-completion",
        "test-reliability"
      ],
      "severity": "low",
      "userImpact": "Flaky tests reduce confidence in test suite reliability and can mask actual issues.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test no longer appears flaky in CI according to maintainer assessment",
      "related": [],
      "keyQuote": "This test does not appear flaky anymore in CI",
      "number": 553,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:56.481Z"
    },
    {
      "summary": "TestActivityStartedAtSameTimeAsTimerCancel integration test was flaky, producing intermittent workflow timeout errors during execution. The test instability has been resolved and no longer appears in CI.",
      "category": "bug",
      "subcategory": "test-flakiness",
      "apis": [],
      "components": [
        "integration-tests",
        "activity-executor",
        "timer-manager"
      ],
      "concepts": [
        "test-flakiness",
        "timing-race-condition",
        "workflow-timeout",
        "activity-timer-interaction"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests reduce confidence in SDK stability and can block CI/CD pipelines with false failures.",
      "rootCause": "Race condition between activity start and timer cancellation causing intermittent StartToClose timeout errors",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test no longer appears flaky in CI, indicating the underlying race condition has been resolved through SDK fixes",
      "related": [],
      "keyQuote": "Workflow timeout (type: StartToClose)",
      "number": 552,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:53.771Z"
    },
    {
      "summary": "TestActivityRetryOnTimeoutStableError test was failing intermittently in CI with a WorkflowExecutionError when it expected nil. The test later stabilized and no longer appears flaky.",
      "category": "bug",
      "subcategory": "test-flakiness",
      "apis": [],
      "components": [
        "test-framework",
        "activity-retry",
        "worker"
      ],
      "concepts": [
        "timeout",
        "retry",
        "test-flakiness",
        "workflow-execution",
        "error-handling"
      ],
      "severity": "low",
      "userImpact": "Intermittent test failures create noise in CI/CD pipelines and reduce confidence in the test suite reliability.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The test stabilized on its own and no longer appears flaky in CI, indicating the underlying issue was resolved.",
      "related": [],
      "keyQuote": "This test does not appear flaky anymore in CI",
      "number": 551,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:39.371Z"
    },
    {
      "summary": "TestActivityRetryOnStartToCloseTimeout test was experiencing flakiness in CI, failing with unexpected ScheduleToClose timeouts during activity retry scenarios. The issue was later resolved and no longer appears in the test suite.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "retry-logic",
        "test-suite",
        "timeout-handling"
      ],
      "concepts": [
        "timeout",
        "retry",
        "flakiness",
        "activity-lifecycle",
        "schedule-to-close",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests in the SDK reduce confidence in release quality and can block CI/CD pipelines.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test no longer appears flaky in CI, indicating the underlying timeout or retry logic issue was resolved.",
      "related": [],
      "keyQuote": "activity failed due to unexpected timeout ScheduleToClose",
      "number": 549,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:35.299Z"
    },
    {
      "summary": "TestActivityNotRegisteredRetry test was flaky, exhibiting non-deterministic behavior in the unregistered activity invocation counter metric. The test expected a counter value of 2 but intermittently received 1, indicating timing or race condition issues.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "activity-executor",
        "metrics",
        "test-integration"
      ],
      "concepts": [
        "flakiness",
        "test-reliability",
        "metrics",
        "activity-registration",
        "race-condition",
        "counter"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests reduce confidence in the SDK and make CI/CD pipelines unreliable, potentially masking real issues.",
      "rootCause": "Race condition or timing issue in test causing inconsistent unregistered activity invocation counter values",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test no longer exhibits flakiness in CI, indicating the underlying issue was resolved",
      "related": [],
      "keyQuote": "Expected value doesn't match actual value for counter temporal_unregistered_activity_invocation",
      "number": 548,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:37.246Z"
    },
    {
      "summary": "TestActivityRetryOnError test is flaky, sometimes receiving only 2 retries instead of the expected 3, indicating intermittent issues with activity retry logic under test conditions.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "activity-executor",
        "retry-logic",
        "test-integration"
      ],
      "concepts": [
        "retry",
        "flakiness",
        "timing",
        "activity-execution",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests reduce confidence in the SDK's activity retry mechanism and can block CI/CD pipelines unpredictably.",
      "rootCause": "Likely race condition or timing issue in activity retry mechanism causing it to sometimes skip the final retry attempt under test conditions.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through fixing the underlying activity retry mechanism to ensure consistent behavior.",
      "related": [],
      "keyQuote": "Not equal: expected: [\"fail\", \"fail\", \"fail\"], actual: [\"fail\", \"fail\"]",
      "number": 547,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:19.810Z"
    },
    {
      "summary": "TestActivityRetryOnHBTimeout integration test is flaky, failing intermittently with 'invalid activityID or activity already timed out' errors during activity retry attempts.",
      "category": "bug",
      "subcategory": "testing",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-worker",
        "activity-retry",
        "integration-tests",
        "heartbeat"
      ],
      "concepts": [
        "flakiness",
        "timeout",
        "retry",
        "heartbeat",
        "activity-execution",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Flaky integration tests reduce confidence in the SDK's activity retry and heartbeat mechanisms.",
      "rootCause": "Race condition or timing issue in activity retry handling with heartbeat timeout scenarios",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed or improved by PR #545; confirmed no longer flaky in CI",
      "related": [
        545
      ],
      "keyQuote": "invalid activityID or activity already timed out or invoking workflow is completed",
      "number": 546,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:18.788Z"
    },
    {
      "summary": "Request to support dynamic activity and workflow implementations that can be loaded at runtime, matching feature parity with the Java SDK.",
      "category": "feature",
      "subcategory": "dynamic-activities-workflows",
      "apis": [
        "RegisterWorkflowWithOptions",
        "RegisterActivityWithOptions",
        "GetLogger",
        "GetInfo"
      ],
      "components": [
        "worker",
        "workflow-registration",
        "activity-registration",
        "registry"
      ],
      "concepts": [
        "dynamic-loading",
        "runtime-registration",
        "fallthrough-handler",
        "extension-point",
        "worker-splitting",
        "dsl-support"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to dynamically register and execute activities and workflows at runtime for use cases like DSLs and worker splitting.",
      "rootCause": null,
      "proposedFix": "Add Dynamic flag to RegisterOptions for both workflows and activities, requiring function signatures that accept a string name and slice of EncodedValue parameters.",
      "workaround": "Use explicit activities/workflows with input parameters to decide behavior inside the body instead of dynamic registration.",
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented with RegisterOptions{Dynamic: true} for both workflows and activities.",
      "related": [
        245
      ],
      "keyQuote": "workflow or activity is called when one for the specific name is not found",
      "number": 543,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:22.752Z"
    },
    {
      "summary": "Feature request to allow ContinueAsNew to automatically transfer unprocessed signals from the current workflow run to the new run, preventing signal loss when a developer fails to drain the signal channel before continuing.",
      "category": "feature",
      "subcategory": "workflow-continuation",
      "apis": [
        "ContinueAsNew",
        "ReceiveAsync",
        "Select"
      ],
      "components": [
        "workflow-engine",
        "signal-handler",
        "workflow-continuation"
      ],
      "concepts": [
        "signal-processing",
        "workflow-continuation",
        "state-transfer",
        "signal-draining",
        "error-prevention"
      ],
      "severity": "medium",
      "userImpact": "Developers risk losing signals when transitioning to a new workflow run if they don't manually drain all pending signals first.",
      "rootCause": "ContinueAsNew does not automatically transfer unprocessed signals to the new run, requiring manual handling that can be error-prone.",
      "proposedFix": "Implement automatic signal transfer capability in ContinueAsNew to carry over all unprocessed signals to the new workflow run.",
      "workaround": "Developers must manually drain signals using either a selector loop with selector.HasPending() or ReceiveAsync until it returns false before calling ContinueAsNew.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If a developer fails to drain signal channel before calling ContinueAsNew then it might result in loosing important signals without processing them.",
      "number": 533,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:05.510Z"
    },
    {
      "summary": "ByteSliceConverter panics when converting []byte payload to interface{} type, preventing activities from accepting bytes via the interface{} parameter pattern used for flexible payload handling.",
      "category": "bug",
      "subcategory": "payload-conversion",
      "apis": [],
      "components": [
        "ByteSliceConverter",
        "payload-converter",
        "activity-worker"
      ],
      "concepts": [
        "type-conversion",
        "payload-handling",
        "interface-flexibility",
        "panic-recovery",
        "activity-parameters"
      ],
      "severity": "medium",
      "userImpact": "Users cannot write activities that accept bytes through interface{} parameters, limiting flexibility in activity parameter handling.",
      "rootCause": "ByteSliceConverter does not properly handle conversion to interface{} type, causing a panic instead of converting the bytes payload.",
      "proposedFix": "Modify ByteSliceConverter to accept interface{} in FromPayload method and properly convert []byte payloads to this type.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "ByteSliceConverter was updated to support interface{} type in FromPayload conversion.",
      "related": [],
      "keyQuote": "ByteSliceConverter be able to convert []byte payload to interface{}. But it actually panics instead.",
      "number": 530,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:03.445Z"
    },
    {
      "summary": "The Go SDK's interceptor design lacks capabilities present in Java and Node.js SDKs. Interceptors cannot modify default SDK behavior, don't capture full operation spans for tracing, and some methods aren't properly chainable, limiting use cases like authorization and distributed tracing.",
      "category": "feature",
      "subcategory": "interceptors",
      "apis": [
        "StartWorkflow",
        "SignalWorkflow",
        "QueryWorkflow"
      ],
      "components": [
        "interceptors",
        "client",
        "tracing"
      ],
      "concepts": [
        "interceptor-chain",
        "authorization",
        "distributed-tracing",
        "operation-span",
        "SDK-consistency",
        "protocol-design"
      ],
      "severity": "high",
      "userImpact": "Users cannot implement authorization checks for workflow operations or properly trace distributed workflows using interceptors, limiting observability and security features.",
      "rootCause": "The interceptor architecture was not designed to be fully chainable or to capture entire operation spans, and differs from Java/Node.js implementations.",
      "proposedFix": "Redesign interceptors to match Java/Node.js capabilities: make them chainable, capture full operation spans, and allow modification of default SDK behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The interceptor design was redesigned to match Java and Node.js SDK capabilities with proper chaining and operation span coverage.",
      "related": [
        526
      ],
      "keyQuote": "Interceptors should have similar capabilities across the different SDKs, they should all be chainable, capture the entires span of the operation and allow modification of the default SDK behavior.",
      "number": 529,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:26:02.659Z"
    },
    {
      "summary": "Request to clarify and simplify the documentation comment for ActivityOptions.ActivityID field. The field already works as intended, so the comment warning against use should be updated to be clearer about when and why it should be used.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "ActivityOptions"
      ],
      "components": [
        "activity",
        "workflow-options"
      ],
      "concepts": [
        "activity-id",
        "documentation",
        "api-clarity",
        "configuration",
        "optional-parameters"
      ],
      "severity": "low",
      "userImpact": "Developers are confused by outdated documentation that discourages use of a feature that already works properly.",
      "rootCause": "The ActivityID field documentation contains misleading comments suggesting it should not be used and referencing future work, when the feature is already functional.",
      "proposedFix": "Update the comment to simply read: '// ActivityID - Business level activity ID\\n// Optional: default empty string'",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was clarified to remove the confusing warnings about the ActivityID field.",
      "related": [],
      "keyQuote": "ActivityID - Business level activity ID, this is not needed for most of the cases if you have to specify this then talk to temporal team.",
      "number": 528,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:48.888Z"
    },
    {
      "summary": "Request to add OpenTracing support to the Go SDK for distributed tracing and observability. The feature is referenced in related discussion #515.",
      "category": "feature",
      "subcategory": "observability-tracing",
      "apis": [],
      "components": [
        "tracing",
        "instrumentation",
        "observability"
      ],
      "concepts": [
        "distributed-tracing",
        "observability",
        "opentracing",
        "instrumentation",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users need OpenTracing integration to trace Temporal workflows across distributed systems and integrate with observability platforms.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "OpenTracing support was implemented and the issue was closed.",
      "related": [
        515
      ],
      "keyQuote": "See related discussion in #515",
      "number": 526,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:50.414Z"
    },
    {
      "summary": "Documentation for the Client interface mentions Cassandra and MySQL as databases where ListWorkflow will return BadRequestError, but does not mention Postgres. The issue asks whether Postgres should be added to this list or if ListWorkflow is actually supported on Postgres without Elasticsearch.",
      "category": "docs",
      "subcategory": "client-documentation",
      "apis": [
        "ListWorkflow"
      ],
      "components": [
        "client",
        "documentation"
      ],
      "concepts": [
        "postgres",
        "elasticsearch",
        "cassandra",
        "mysql",
        "database-support",
        "api-limitations"
      ],
      "severity": "low",
      "userImpact": "Users reading the Client documentation may be confused about ListWorkflow support and requirements for Postgres databases.",
      "rootCause": "Documentation is incomplete or inaccurate regarding Postgres support in Client interface comments.",
      "proposedFix": "Update documentation to either include Postgres in the list of databases where ListWorkflow returns BadRequestError, or clarify if ListWorkflow is supported on Postgres without Elasticsearch.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I assume that this should read '[...] will return BadRequestError when using Cassandra, MySQL or Postgres'?",
      "number": 524,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:49.545Z"
    },
    {
      "summary": "Heartbeat data fails to be recorded when an activity reports failure because the activity context is closed before the GRPC heartbeat request is sent. This causes heartbeat details to be lost on retry attempts.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [
        "GetHeartbeatDetails"
      ],
      "components": [
        "activity-executor",
        "heartbeat-batching",
        "grpc-client"
      ],
      "concepts": [
        "heartbeat",
        "retry",
        "activity-failure",
        "context-lifecycle",
        "batching",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Activities lose heartbeat progress data on failure, preventing proper recovery and retry state restoration.",
      "rootCause": "Activity context is closed before the heartbeat batching code can send the final heartbeat GRPC request on the activity failure code path.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by ensuring the activity context remains open long enough for pending heartbeat requests to complete before failure handling closes the context.",
      "related": [],
      "keyQuote": "activity context is closed on the code path for activity failure handling, so the GRPC request is never made",
      "number": 521,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:34.774Z"
    },
    {
      "summary": "ExecuteWorkflow with WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE was incorrectly replacing a running workflow instead of returning the existing workflow ID and run ID as documented.",
      "category": "bug",
      "subcategory": "workflow-id-reuse-policy",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "workflow-client",
        "workflow-execution",
        "id-reuse-policy"
      ],
      "concepts": [
        "workflow-id-reuse",
        "duplicate-handling",
        "running-workflow",
        "policy-enforcement"
      ],
      "severity": "high",
      "userImpact": "Users could lose running workflows when attempting to re-execute with the same ID, contradicting the documented behavior of ALLOW_DUPLICATE policy.",
      "rootCause": "The ExecuteWorkflow API incorrectly implemented the WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE logic, replacing running workflows instead of allowing duplicates.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test confirming duplicate ID behavior was merged, showing that ExecuteWorkflow now correctly returns the same workflow ID and run ID when executing for the same ID while it is still running.",
      "related": [],
      "keyQuote": "The current logic is: The new created workflow will REPLACE the current running workflow with the same id.",
      "number": 518,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:36.289Z"
    },
    {
      "summary": "The codahale/hdrhistogram Go module dependency has been transferred to the HdrHistogram organization. The dependency URL needs to be updated to point to the new repository at github.com/HdrHistogram/hdrhistogram-go, which includes performance improvements in recent versions.",
      "category": "feature",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "dependencies",
        "go-modules"
      ],
      "concepts": [
        "dependency-update",
        "repository-migration",
        "performance-improvement",
        "module-management"
      ],
      "severity": "medium",
      "userImpact": "Users need to update their dependency references to maintain access to bug fixes and performance improvements in the hdrhistogram library.",
      "rootCause": "The original codahale/hdrhistogram repository was archived and transferred to the HdrHistogram organization for better maintenance and community contribution.",
      "proposedFix": "Update the dependency URL to github.com/HdrHistogram/hdrhistogram-go@v0.9.0 or later using `go mod edit -replace` command.",
      "workaround": "For Go modules, use the @v0.9.0 tag which reflects the exact code at the point of transfer: `go mod edit -replace github.com/codahale/hdrhistogram=github.com/HdrHistogram/hdrhistogram-go@v0.9.0`",
      "resolution": "fixed",
      "resolutionDetails": "No longer needed - the issue was resolved by updating the dependency reference.",
      "related": [],
      "keyQuote": "The dependency URL should be modified to point to the new repository URL at github.com/HdrHistogram/hdrhistogram-go.",
      "number": 517,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:33.031Z"
    },
    {
      "summary": "Add interceptor support for Signal and Query operations in the Go SDK. Currently, interceptors are not available for these operations, preventing fine-grained authorization and observability features like open tracing.",
      "category": "feature",
      "subcategory": "interceptors",
      "apis": [
        "Signal",
        "Query"
      ],
      "components": [
        "interceptors",
        "signal-handler",
        "query-handler"
      ],
      "concepts": [
        "authorization",
        "observability",
        "open-tracing",
        "headers",
        "interceptor-chain"
      ],
      "severity": "medium",
      "userImpact": "Users cannot implement fine-grained authorization or open tracing instrumentation for Signal and Query operations.",
      "rootCause": null,
      "proposedFix": "Implement Signal/Query interceptors following the same pattern as workflow and activity interceptors, ensuring headers are passed through the server.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Signal and Query interceptors were implemented in the Go SDK.",
      "related": [],
      "keyQuote": "We don't have Query/Signal interceptors... We should be able to support open tracing for all calls, headers should be available on API calls too.",
      "number": 515,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:17.241Z"
    },
    {
      "summary": "TestActivityEnvironment.ExecuteActivity requires explicit RegisterActivity call when invoking activities by function reference, even though the activity instance is provided directly to ExecuteActivity. This forces unnecessary boilerplate in activity unit tests.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "RegisterActivity"
      ],
      "components": [
        "test-suite",
        "activity-executor",
        "test-environment"
      ],
      "concepts": [
        "activity-registration",
        "test-setup",
        "boilerplate-reduction",
        "activity-invocation"
      ],
      "severity": "medium",
      "userImpact": "Developers must write redundant registration code when unit testing activities with function references, increasing test complexity and reducing code clarity.",
      "rootCause": "TestActivityEnvironment.ExecuteActivity requires activity registration in the taskqueue even when the activity function is directly provided as an argument.",
      "proposedFix": null,
      "workaround": "Comment out the RegisterActivity call as shown in the issue, or register the activity before calling ExecuteActivity.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I expect this code to work without the commented section",
      "number": 514,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:21.026Z"
    },
    {
      "summary": "Use the NON_DETERMINISTIC_ERROR cause when responding to workflow task failures due to non-deterministic workflow logic, aligning with Temporal server's error categorization.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "RespondWorkflowTaskFailed"
      ],
      "components": [
        "workflow-executor",
        "error-handling",
        "task-processing"
      ],
      "concepts": [
        "non-deterministic-error",
        "workflow-task-failure",
        "error-categorization",
        "cause-reporting",
        "determinism"
      ],
      "severity": "medium",
      "userImpact": "Provides developers with more accurate error categorization when workflows fail due to non-deterministic logic, improving debugging and error handling.",
      "rootCause": "SDK does not properly categorize non-deterministic errors using the appropriate WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR cause code.",
      "proposedFix": "Organize and categorize error handling throughout the SDK to detect non-deterministic errors and use WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR as the cause for RespondWorkflowTaskFailed.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented proper error categorization to use WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR for non-deterministic workflow logic failures.",
      "related": [
        1726
      ],
      "keyQuote": "use WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR as cause for RespondWorkflowTaskFailed if user workflow logic is non-deterministic",
      "number": 513,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:19.443Z"
    },
    {
      "summary": "Sessions need support for non-retryable errors such as heartbeat failures and worker panics that shouldn't be retried since the worker state is lost. Cadence already supports this via retry policy settings for sessions, but the Temporal Go SDK does not.",
      "category": "feature",
      "subcategory": "sessions",
      "apis": [],
      "components": [
        "sessions",
        "retry-policy",
        "worker"
      ],
      "concepts": [
        "heartbeat",
        "panic",
        "retry",
        "non-retryable-errors",
        "worker-state",
        "session-management"
      ],
      "severity": "medium",
      "userImpact": "Users cannot prevent retries of session tasks that fail due to heartbeat issues or worker panics, leading to wasted retries and incorrect behavior.",
      "rootCause": "The Temporal Go SDK does not implement non-retryable error handling in sessions, unlike Cadence which supports this through retry policy settings.",
      "proposedFix": "Add support for marking errors as non-retryable in session retry policies, similar to Cadence's implementation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Some errors need to be non-retryable in sessions, for example heartbeat failures and panics that bring down the worker shouldn't be retried because the worker's state will have been lost.",
      "number": 505,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:01.408Z"
    },
    {
      "summary": "The SDK incorrectly sends timer cancel commands for timers that have already fired during workflow cancellations, which violates the expected behavior that cancel commands should never be sent for already-resolved timers.",
      "category": "bug",
      "subcategory": "timer-management",
      "apis": [],
      "components": [
        "timer-executor",
        "workflow-cancellation",
        "command-handler"
      ],
      "concepts": [
        "timer",
        "cancellation",
        "command-sequencing",
        "state-management",
        "workflow-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Workflows may encounter unexpected behavior when timers fire during cancellation, potentially causing SDK errors or incorrect cancellation semantics.",
      "rootCause": "The SDK does not properly track fired timer state before issuing cancel commands during workflow cancellation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by properly handling timer state during workflow cancellations to avoid issuing cancel commands for already-resolved timers.",
      "related": [],
      "keyQuote": "We should never send a timer cancel command for a timer that has already fired",
      "number": 503,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:05.995Z"
    },
    {
      "summary": "The poller uses an overly aggressive retry policy when encountering ResourceExhausted errors, instead of backing off as expected. The issue discusses whether ResourceExhausted should receive special treatment compared to other retryable gRPC error codes.",
      "category": "bug",
      "subcategory": "poller-retry-policy",
      "apis": [],
      "components": [
        "poller",
        "retry-policy",
        "grpc-client"
      ],
      "concepts": [
        "backoff",
        "retry",
        "resource-exhaustion",
        "error-handling",
        "rate-limiting"
      ],
      "severity": "medium",
      "userImpact": "Users experience aggressive retries that consume resources when the server is resource-exhausted, instead of backing off and allowing recovery.",
      "rootCause": "Poller's retry policy treats ResourceExhausted errors the same as other retryable errors without implementing backoff behavior.",
      "proposedFix": "Implement special handling for ResourceExhausted errors with backoff/exponential delay, potentially different from other retryable error codes.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "current retry policy is overly aggressive. I would like to discuss this with Alex before we make a change though.",
      "number": 502,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:25:04.633Z"
    },
    {
      "summary": "Activity execution fails with misleading error message \"Call with too few input arguments\" when the wrong context type is passed to an activity. The error message doesn't clearly indicate that the context parameter is incorrect.",
      "category": "bug",
      "subcategory": "error-messages",
      "apis": [],
      "components": [
        "activity-executor",
        "error-handling"
      ],
      "concepts": [
        "context",
        "parameter-validation",
        "error-messaging",
        "activity-invocation"
      ],
      "severity": "medium",
      "userImpact": "Developers receive confusing error messages when accidentally passing the wrong context to activities, making debugging difficult.",
      "rootCause": "Error validation logic doesn't distinguish between incorrect context type and actual missing arguments, resulting in the same generic error message.",
      "proposedFix": "Improve error message to specifically indicate when the wrong context type is passed to an activity, distinguishing it from missing arguments.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #1093 by improving error validation and messages for context parameter validation in activity invocation.",
      "related": [
        1093
      ],
      "keyQuote": "The error does not provide good information.",
      "number": 500,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:45.666Z"
    },
    {
      "summary": "Go SDK test suite cannot query a workflow after signaling it due to framework limitations, unlike real applications and other SDKs. This requires splitting signal and query operations into separate delayed callbacks in tests, which doesn't match real-world usage patterns.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "SignalWorkflow",
        "QueryWorkflow"
      ],
      "components": [
        "test-suite",
        "workflow-testing",
        "signal-handler",
        "query-handler"
      ],
      "concepts": [
        "signal",
        "query",
        "testing",
        "read-after-write-consistency",
        "test-framework-limitation",
        "workflow-state"
      ],
      "severity": "medium",
      "userImpact": "Test developers must write unrealistic test code that splits signal and query operations into separate callbacks, making tests not reflective of actual production behavior.",
      "rootCause": "The Go testing framework does not provide read-after-write consistency for query operations following signal operations, a limitation not present in real Go applications or other SDKs like Java.",
      "proposedFix": "Implement read-after-write consistency in the Go test framework to allow querying workflows immediately after signaling them, matching behavior in production and other SDKs.",
      "workaround": "Split signal and query operations into separate delayed callbacks in tests, as shown in the ecommerce blog post example.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The inability to query after the signal is purely Go testing framework limitation. In both real Go applications and Java we provide read after write consistency in signal then query case.",
      "number": 497,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:50.625Z"
    },
    {
      "summary": "ActivityError lacks public accessor methods for its fields like retryState, activityID, and event IDs. Users currently must parse the error string to extract these values. The request is to add getter functions for ActivityError fields and potentially for other error types as well.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "ActivityError"
      ],
      "components": [
        "error-handling",
        "activity-executor",
        "workflow-runtime"
      ],
      "concepts": [
        "error-accessors",
        "retry-state",
        "activity-metadata",
        "error-parsing",
        "api-ergonomics"
      ],
      "severity": "medium",
      "userImpact": "Users can now directly access ActivityError fields without parsing string representations, making error handling in workflows more convenient and robust.",
      "rootCause": null,
      "proposedFix": "Add public getter methods for ActivityError fields: RetryState(), ActivityID(), ScheduledEventID(), StartedEventID(), ActivityType(), and Identity(). Consider implementing similar accessors for other error types.",
      "workaround": "Parse the ActivityError.Error() string output to extract field values, or use Unwrap() to access the underlying cause error.",
      "resolution": "fixed",
      "resolutionDetails": "Public accessor methods were added to ActivityError and other error types to expose previously private fields.",
      "related": [],
      "keyQuote": "I think for convenience reasons we should also provide values for the above variables so that users are not forced to parse the string if they need these details",
      "number": 496,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:47.769Z"
    },
    {
      "summary": "Calling `GetChildWorkflowExecution()` on a mocked child workflow in tests causes the child workflow to complete immediately instead of respecting the mocked delay. The parent workflow sees `IsReady() == true` immediately after calling `GetChildWorkflowExecution()` and sleeping, rather than waiting for the configured mock delay.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "GetChildWorkflowExecution",
        "IsReady"
      ],
      "components": [
        "test-suite",
        "workflow-mock",
        "child-workflow-execution"
      ],
      "concepts": [
        "mocking",
        "child-workflow",
        "test-execution",
        "execution-state",
        "timing",
        "future-ready"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot reliably test parent workflows that call `GetChildWorkflowExecution()` on mocked children, as the mock's configured delays are ignored.",
      "rootCause": "The test framework's `OnWorkflow` mock appears to complete the child workflow prematurely when `GetChildWorkflowExecution()` is called, bypassing the `.After()` delay configuration.",
      "proposedFix": null,
      "workaround": "Register a custom mock workflow using `RegisterWorkflowWithOptions` with the desired behavior instead of using `OnWorkflow`.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The parent sees `IsReady() == true` immediately after calling `GetChildWorkflowExecution` and sleeping",
      "number": 495,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:30.430Z"
    },
    {
      "summary": "Child workflows with the same workflow ID could not be reused immediately after the previous child completed, even with WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE. The issue was caused by command state machine IDs depending only on the child's workflow ID, preventing reuse without unique IDs.",
      "category": "bug",
      "subcategory": "child-workflow-reuse",
      "apis": [
        "ExecuteChildWorkflow",
        "ChildWorkflowOptions"
      ],
      "components": [
        "command-state-machine",
        "workflow-executor",
        "decision-handler"
      ],
      "concepts": [
        "workflow-id-reuse",
        "child-workflow",
        "command-deduplication",
        "state-machine",
        "policy"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reuse child workflow IDs immediately after completion, forcing them to use unique IDs or add workarounds.",
      "rootCause": "Internal command state machine uses child workflow ID as the command ID, so reusing the same ID before the command is removed from state causes duplicate command panic.",
      "proposedFix": null,
      "workaround": "Use unique child workflow IDs for each invocation, or use signals/select patterns to control workflows without polling.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was eventually resolved by ensuring proper cleanup of commands from the state machine when child workflows complete, allowing ID reuse as per policy.",
      "related": [],
      "keyQuote": "if the same workflow ever tries to create two children with the same ID (which is legal if it made sure that the first has completed before) it will still panic",
      "number": 492,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:34.318Z"
    },
    {
      "summary": "TestSuite workflow retry mechanism is not functioning correctly. When a workflow returns an ApplicationError in the test environment, it should retry according to the RetryPolicy, but instead it only executes once and fails.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflowOptions",
        "RetryPolicy",
        "NewApplicationError"
      ],
      "components": [
        "test-suite",
        "workflow-execution",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "error-handling",
        "test-isolation",
        "workflow-execution",
        "retry-policy",
        "application-error"
      ],
      "severity": "high",
      "userImpact": "Developers cannot properly test workflow retry behavior using the test suite, making it impossible to verify that workflows correctly retry on recoverable errors.",
      "rootCause": "The test suite environment does not properly implement retry logic for workflows that return ApplicationError, treating the error as final instead of retriable.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "TestSuite should mimic actual behavior when workflow returns ApplicationError; which is to retry",
      "number": 491,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:30.684Z"
    },
    {
      "summary": "Data race condition in dispatcherImpl.ExecuteUntilAllBlocked where the executing state is written without a lock in a defer statement while being concurrently read by goroutines spawned via NewCoroutine, causing random test flakes.",
      "category": "bug",
      "subcategory": "concurrency",
      "apis": [
        "ExecuteUntilAllBlocked",
        "IsExecuting",
        "NewCoroutine",
        "Await"
      ],
      "components": [
        "dispatcherImpl",
        "workflow-executor",
        "coroutine-scheduler",
        "test-framework"
      ],
      "concepts": [
        "data-race",
        "concurrency",
        "goroutine",
        "locking",
        "deadlock-detection",
        "synchronization"
      ],
      "severity": "high",
      "userImpact": "Users experience random flakes in workflow tests due to race conditions between goroutines accessing shared state without proper synchronization.",
      "rootCause": "The executing state is written without a lock in the defer statement of ExecuteUntilAllBlocked while concurrently read by IsExecuting calls from goroutines spawned by NewCoroutine, particularly during deadlock detection and coroutine completion simultaneously.",
      "proposedFix": "Add locking around the write to the executing state in the defer statement of ExecuteUntilAllBlocked to synchronize access with concurrent reads by IsExecuting.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fix applied by adding proper locking to the defer statement that writes to the executing state, preventing concurrent read/write races.",
      "related": [],
      "keyQuote": "goroutine 11 is updating executing without a lock in the defer statement while goroutine 21 is reading the executing state, probably via IsExecuting()",
      "number": 488,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:17.281Z"
    },
    {
      "summary": "Child workflows fail to cancel when parent is cancelled, causing a state machine panic with invalid history builder state error. The issue appears related to activity task cancellation handling during child workflow termination.",
      "category": "bug",
      "subcategory": "child-workflows",
      "apis": [
        "CancelChildWorkflow"
      ],
      "components": [
        "state-machine",
        "history-builder",
        "child-workflow-executor",
        "cancellation-handler"
      ],
      "concepts": [
        "cancellation",
        "state-machine",
        "child-workflows",
        "history-validation",
        "error-propagation",
        "workflow-termination"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably cancel parent workflows when they have child workflows, causing runtime panics and failed cancellation operations.",
      "rootCause": "Invalid state machine transitions when propagating cancellations to child workflows, particularly with activity task cancel events in the history builder.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        481
      ],
      "keyQuote": "BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event",
      "number": 483,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:13.071Z"
    },
    {
      "summary": "Workflow queries hang indefinitely when the workflow execution is unavailable (e.g., due to panic) instead of timing out. The Go SDK lacks a default query timeout like tctl's 5-second default, causing client hangs.",
      "category": "bug",
      "subcategory": "workflow-query",
      "apis": [
        "QueryWorkflow"
      ],
      "components": [
        "client",
        "query-handler",
        "workflow-execution"
      ],
      "concepts": [
        "timeout",
        "query",
        "panic",
        "availability",
        "hanging",
        "deadlock"
      ],
      "severity": "high",
      "userImpact": "Applications calling workflow queries may hang indefinitely when the workflow is unavailable, blocking client operations and requiring manual intervention to restart.",
      "rootCause": "The Go SDK does not implement a default timeout for workflow queries, unlike tctl which has a 5-second default timeout.",
      "proposedFix": "Implement a configurable default timeout for workflow queries in the Go SDK client, with a reasonable default value (e.g., 5 seconds matching tctl behavior).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The client hangs while running a query for a workflow execution that is not available (ex: panicking)",
      "number": 482,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:14.013Z"
    },
    {
      "summary": "Canceling a workflow can cause infinite replay attempts when a cancel event is processed before the corresponding activity completion event in the history, leaving the state machine in an invalid state and causing repeated BadRequestCancelActivityAttributes errors.",
      "category": "bug",
      "subcategory": "workflow-cancellation",
      "apis": [
        "CancelWorkflow",
        "ExecuteActivity",
        "ExecuteLocalActivity"
      ],
      "components": [
        "state-machine",
        "history-builder",
        "workflow-executor",
        "activity-processor"
      ],
      "concepts": [
        "cancellation",
        "replay",
        "history-ordering",
        "event-ordering",
        "state-machine-integrity",
        "concurrent-events"
      ],
      "severity": "high",
      "userImpact": "Workflows fail to properly cancel and enter an infinite replay loop, requiring manual termination and blocking normal workflow completion.",
      "rootCause": "The state machine attempts to cancel activities even when the cancel event appears before the activity completion event in history due to event ordering issues, creating an invalid history builder state that cannot be recovered without special handling for alternate branches.",
      "proposedFix": "Allow the Go state machine to replay 'alternate branches' beyond cancel events to recover from invalid states, or ensure cancel events always appear first in event history ordering.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was mitigated in SDK v1.10.0 and fully resolved by v1.11.0 through improved event history ordering and state machine handling. Related fixes in PR #504 and #623.",
      "related": [
        469,
        623,
        504
      ],
      "keyQuote": "Cancelling a workflow concurrently with an activity completion creates an invalid state due to the ordering of events in the workflow history",
      "number": 481,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:24:01.563Z"
    },
    {
      "summary": "Activity results are not stored when a worker is stopped gracefully during activity execution, causing the activity to restart from the beginning instead of continuing from where it was interrupted.",
      "category": "bug",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "task-poller"
      ],
      "concepts": [
        "graceful-shutdown",
        "activity-result-persistence",
        "worker-interrupt",
        "state-recovery"
      ],
      "severity": "high",
      "userImpact": "Users experience activity restarts and lost progress when gracefully stopping and restarting workers during long-running activities.",
      "rootCause": "The SDK does not record activity results when the worker receives an interrupt signal, causing loss of intermediate state.",
      "proposedFix": "Modify the task poller to properly complete and record the activity result before stopping the worker during graceful shutdown.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #579 by properly recording activity results during graceful worker shutdown.",
      "related": [
        520,
        579,
        731
      ],
      "keyQuote": "The worker should properly complete the activity in this case when it receives the interrupt.",
      "number": 480,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:58.841Z"
    },
    {
      "summary": "A panic occurs when querying a workflow during failure and retry - the SDK attempts to generate a command before processing WorkflowTaskStarted event. This happens when queries are issued concurrently while the workflow is retrying after activity failure.",
      "category": "bug",
      "subcategory": "query-handling",
      "apis": [
        "QueryWorkflow",
        "SetQueryHandler",
        "ExecuteActivity",
        "StartWorkflow"
      ],
      "components": [
        "workflow-worker",
        "command-generation",
        "query-handler",
        "event-processing"
      ],
      "concepts": [
        "query",
        "retry",
        "panic",
        "workflow-failure",
        "concurrent-operations",
        "event-replay"
      ],
      "severity": "high",
      "userImpact": "Workflows that are retried after activity failure panic when queries are concurrently issued, causing workflow execution to fail.",
      "rootCause": "The SDK attempts to generate a command before processing WorkflowTaskStarted event when handling queries during workflow retry states, violating event ordering assumptions.",
      "proposedFix": "Server-side fix via https://github.com/temporalio/temporal/pull/2826 to properly handle queries during workflow retry, cron, or pending continue as new states.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2300,
        2826
      ],
      "keyQuote": "Attempt to generate a command before processing WorkflowTaskStarted event due to WorkerType WorkflowWorker Error operation GetWorkflowExecution encounter not found",
      "number": 475,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:58.298Z"
    },
    {
      "summary": "Workflow replay fails with a panic when a workflow contains multiple consecutive calls to GetVersion. The panic occurs during event processing with a lookup error for scheduledEventID to activityID mapping, breaking query functionality.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "GetVersion",
        "ExecuteActivity"
      ],
      "components": [
        "workflow-replay",
        "decision-state-machine",
        "event-handler",
        "task-processor"
      ],
      "concepts": [
        "workflow-versioning",
        "event-replay",
        "state-management",
        "activity-scheduling",
        "panic-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot run workflows with multiple GetVersion calls without experiencing panics and query failures.",
      "rootCause": "Event handler lookup logic fails to properly map scheduledEventID to activityID when multiple GetVersion calls exist in sequence, causing illegal state panic during replay.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "lookup failed for scheduledEventID to activityID: scheduleEventID: 9, activityID: 9",
      "number": 473,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:38.907Z"
    },
    {
      "summary": "The test framework does not respect ParentClosePolicy settings on child workflows. When a child workflow has ParentClosePolicy set to ABANDON, the test framework should allow the child workflow to continue executing after the parent closes, but currently it doesn't.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "test-framework",
        "child-workflow",
        "workflow-execution"
      ],
      "concepts": [
        "parent-close-policy",
        "child-workflow-lifecycle",
        "workflow-termination",
        "test-isolation",
        "async-execution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test workflows that use PARENT_CLOSE_POLICY_ABANDON, limiting the test framework's ability to validate async child workflow behavior.",
      "rootCause": "The test framework implementation does not take into account the ParentClosePolicy attribute when managing child workflow lifecycle during parent workflow closure.",
      "proposedFix": "Modify the test framework to respect the ParentClosePolicy setting on child workflows, allowing child workflows with ABANDON policy to continue executing after parent closure.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test framework was updated to properly respect ParentClosePolicy settings on child workflows.",
      "related": [],
      "keyQuote": "Test framework does not respect ParentClosePolicy set on child workflow. For example, if set child workflow's ParentClosePolicy to PARENT_CLOSE_POLICY_ABANDON, which means when parent workflow closed, its child workflow should continue executing.",
      "number": 470,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:40.741Z"
    },
    {
      "summary": "Feature request to propagate context cancellations to workflow futures via a new `WorkflowCancelingGet` method that cancels the underlying workflow instead of just unblocking the Get call. This would allow conventional context-aware cancellation patterns common in Go web applications.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [
        "WorkflowRun.Get",
        "WorkflowClient.CancelWorkflow"
      ],
      "components": [
        "workflow-client",
        "workflow-run",
        "context-handling"
      ],
      "concepts": [
        "context-cancellation",
        "workflow-lifecycle",
        "goroutine-coordination",
        "cancellation-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use Go's standard context cancellation patterns to cancel workflows and their downstream activities when blocking on WorkflowRun.Get(), limiting integration with context-aware Go frameworks.",
      "rootCause": null,
      "proposedFix": "Add a new `WorkflowCancelingGet(ctx, valuePtr)` method that cancels the workflow when the context is cancelled, in addition to the existing `Get` behavior.",
      "workaround": "Use `WorkflowClient.CancelWorkflow()` directly to cancel workflows instead of relying on context propagation.",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainers indicated no plans to change how WorkflowRun.Get(ctx, valuePtr) works and suggested using WorkflowClient.CancelWorkflow() as the standard approach.",
      "related": [],
      "keyQuote": "An additional or different `WorkflowCancelingGet(ctx, valuePtr)` which cancels the workflow allows for the more conventional context cancellation behavior",
      "number": 469,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:43.719Z"
    },
    {
      "summary": "The gogo/status v1.1.0 dependency included a vulnerable version of gogo/protobuf (v1.2.0) affected by CVE-2021-3121, though the SDK's explicit go.mod dependency on v1.3.2 ensures the patched version is actually used.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "protobuf-serialization",
        "gogo-status"
      ],
      "concepts": [
        "vulnerability",
        "CVE-2021-3121",
        "protobuf",
        "dependency-resolution",
        "security-patch",
        "skippy-peanut-butter"
      ],
      "severity": "high",
      "userImpact": "Users could be exposed to CVE-2021-3121 protobuf vulnerability through transitive dependency chain despite SDK using patched version.",
      "rootCause": "gogo/status v1.1.0 dependency on vulnerable gogo/protobuf v1.2.0 (skippy peanut butter index validation issue), though go.mod explicitly pins safer v1.3.2.",
      "proposedFix": "Upgrade gogo/status to a version that depends on gogo/protobuf v1.3.2 or later, or wait for upstream fix.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by explicit go.mod dependency on gogo/protobuf v1.3.2, which takes precedence over transitive v1.2.0 dependency from gogo/status v1.1.0.",
      "related": [],
      "keyQuote": "SDK is using 1.3.2 for a while now... we have v1.3.2 in the go.mod file, it is the one that is actually in use.",
      "number": 468,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:27.084Z"
    },
    {
      "summary": "Worker silently fails activity tasks when the activity type is not registered, instead of immediately reporting an error. The activity remains stuck in the started state if the start_to_close timeout is large.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "task-queue-poller"
      ],
      "concepts": [
        "activity-type-registration",
        "error-handling",
        "timeout",
        "task-failure",
        "silent-failure"
      ],
      "severity": "high",
      "userImpact": "Users cannot detect when activities fail due to unregistered types, causing workflows to hang unexpectedly and making debugging difficult.",
      "rootCause": "Worker does not properly validate and report activity type registration status when picking up tasks from the task queue.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Worker picks up the activity task and fails silently",
      "number": 465,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:21.194Z"
    },
    {
      "summary": "User requests worker hooks to capture workflow and activity panics/errors for error tracking services like Sentry. Currently only activities can be wrapped for error reporting, but workflows lack this capability.",
      "category": "feature",
      "subcategory": "worker-hooks",
      "apis": [],
      "components": [
        "worker",
        "workflow-executor",
        "activity-executor",
        "error-handling"
      ],
      "concepts": [
        "panic-recovery",
        "error-tracking",
        "hooks",
        "worker-lifecycle",
        "monitoring",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily capture and report workflow panics to error tracking services without modifying framework internals.",
      "rootCause": null,
      "proposedFix": "Implement hook registration feature in worker API that provides non-deterministic callback functions to execute after workflow/activity panics and before retry",
      "workaround": "Use interceptors (as mentioned in the resolution comment)",
      "resolution": "fixed",
      "resolutionDetails": "Resolved through use of Interceptors, which provide the requested functionality for error/panic handling. Python example with Sentry provided as reference.",
      "related": [],
      "keyQuote": "It would be nice to have as part of the worker's API a hook registration feature which provides the ability to register non-deterministic functions",
      "number": 464,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:25.252Z"
    },
    {
      "summary": "Users need ability to control log levels for expected retry errors in activities. When polling external APIs with retries as part of normal operation, retry logs get spammed with messages for expected application errors that shouldn't be treated as error-level events.",
      "category": "feature",
      "subcategory": "activity-retries",
      "apis": [
        "ApplicationErrorOptions"
      ],
      "components": [
        "activity-executor",
        "error-handling",
        "logging",
        "retry-policy"
      ],
      "concepts": [
        "logging",
        "retry-policy",
        "application-error",
        "polling",
        "log-level",
        "activity-options"
      ],
      "severity": "medium",
      "userImpact": "Developers using activity retries for polling external APIs experience excessive error-level logging for expected failures, making logs difficult to use for actual error detection.",
      "rootCause": "The SDK logs all activity errors at error level regardless of whether the error is expected as part of retry logic or an actual failure.",
      "proposedFix": "Add a 'log-level' field to ApplicationErrorOptions that can be checked before logging the Activity Failed event, allowing developers to specify lower log levels for expected errors.",
      "workaround": "Implement a custom logger and filter logs with 'Activity Error' message and specific error keyval, though this is fragile and relies on internal log formatting.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by adding the new ApplicationErrorCategory field which allows better categorization of application errors.",
      "related": [],
      "keyQuote": "Polling using activity retries works great, but logs get spammed by expected \"errors\".",
      "number": 463,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:10.636Z"
    },
    {
      "summary": "The test framework does not apply the default retry policy to activities when no explicit policy is set, unlike the production server behavior. Activities should use a default retry policy in unit tests as they do in production.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Activity",
        "RetryPolicy"
      ],
      "components": [
        "test-framework",
        "activity-executor",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "default-behavior",
        "activity-testing",
        "policy-configuration",
        "test-parity"
      ],
      "severity": "medium",
      "userImpact": "Unit tests may not accurately reflect production behavior for activities without explicit retry policies, potentially missing retry-related bugs.",
      "rootCause": "Test framework does not implement default retry policy assignment for activities when none is explicitly configured.",
      "proposedFix": null,
      "workaround": "Explicitly set a retry policy in test activities to match expected production behavior.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #462",
      "related": [
        462
      ],
      "keyQuote": "Activity RetryPolicy is optional, and if not set a default retry policy will be used by server. We need this same behavior on local unit test.",
      "number": 461,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:10.881Z"
    },
    {
      "summary": "RegisterDelayedCallback should panic if called after ExecuteWorkflow to help users catch mistakes earlier. Currently users make this error and spend significant time debugging without clear feedback.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "RegisterDelayedCallback",
        "ExecuteWorkflow"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-testing"
      ],
      "concepts": [
        "test-debugging",
        "error-detection",
        "user-error-prevention",
        "API-misuse",
        "callback-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users who accidentally call RegisterDelayedCallback after ExecuteWorkflow waste time debugging instead of getting immediate failure feedback.",
      "rootCause": "No validation to detect when RegisterDelayedCallback is called after ExecuteWorkflow has already executed.",
      "proposedFix": "Add panic in RegisterDelayedCallback when called after ExecuteWorkflow has been invoked.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "just ran into the same issue and spent 1h troubleshooting. Definitely user issue, but was hard to debug and `panic` would be neat.",
      "number": 458,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:23:07.480Z"
    },
    {
      "summary": "The temporal_activity_execution_failure metric doesn't record activity execution failures. Activity errors return nil from the task handler, preventing the metric counter from being incremented when retryable errors occur.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "task-handler",
        "metrics",
        "activity-executor"
      ],
      "concepts": [
        "metrics",
        "activity-execution",
        "error-handling",
        "monitoring",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot accurately monitor activity execution failures via metrics, making it harder to diagnose and track error patterns in production.",
      "rootCause": "The task handler returns nil for errors in activity execution, preventing the metric counter from being incremented. The code at internal_task_handlers.go#L1838 handles the error but doesn't propagate it correctly to trigger the metric.",
      "proposedFix": "Ensure that activity execution errors properly increment the ActivityExecutionFailedCounter metric instead of returning nil.",
      "workaround": "Use the RPC metric (temporal_request with operation=RespondActivityTaskFailed) as an alternative, though it lacks activity/workflow type information and doesn't account for internal errors.",
      "resolution": "fixed",
      "resolutionDetails": "A PR was submitted to address the problem of properly logging activity execution failures to the metric.",
      "related": [],
      "keyQuote": "Activity errors don't result in any change for this metric. This is caused by returning nil for the error, but that means the code never logs it.",
      "number": 457,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:56.589Z"
    },
    {
      "summary": "Activity returning a slice of protobuf messages loses nested message data during serialization/deserialization. Root-level messages are received but nested fields are nil.",
      "category": "bug",
      "subcategory": "protobuf-serialization",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "serialization",
        "proto-converter"
      ],
      "concepts": [
        "protobuf-messages",
        "serialization",
        "nested-data",
        "type-conversion",
        "data-loss"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably return slices of protobuf messages from activities due to nested message fields being lost during transmission.",
      "rootCause": "Lists are converted via a different converter than proto messages. Pointer to proto message interface may not be JSON serializable.",
      "proposedFix": "Use full proto message type or JSON serializable types in list instead of pointers to proto message interfaces.",
      "workaround": "Use full proto message or JSON serializable types in list if needed.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue closed as the behavior is by design - lists use a different converter than proto messages, and pointers to proto interfaces are not JSON serializable. Users should use full proto messages or JSON serializable types.",
      "related": [],
      "keyQuote": "A pointer to a proto message interface may not be JSON serializable. Use full proto message or JSON serializable types in list if needed.",
      "number": 456,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:53.909Z"
    },
    {
      "summary": "Activity latency metrics (activity_schedule_to_start_latency, activity_endtoend_latency) are missing the task queue name tag in the Go SDK, unlike the Java SDK implementation.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-worker",
        "prometheus"
      ],
      "concepts": [
        "latency",
        "monitoring",
        "metrics-tagging",
        "task-queue",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily correlate activity latency metrics with specific task queues when monitoring Prometheus metrics.",
      "rootCause": "Task queue name is not being added as a tag to activity latency metrics during collection",
      "proposedFix": "Add task queue name tag to activity latency metrics to match Java SDK behavior",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Activity latency metrics like `activity_schedule_to_start_latency` and `activity_endtoend_latency` should be tagged with the task queue name like the Java SDK does.",
      "number": 449,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:56.425Z"
    },
    {
      "summary": "Worker.Start should fail (panic) after worker.Stop has been called, rather than allowing restart attempts that don't behave as users expect. Currently, users can call Stop then Start, but this doesn't properly restart the worker.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Start",
        "Stop"
      ],
      "components": [
        "worker",
        "lifecycle-management"
      ],
      "concepts": [
        "restart",
        "state-management",
        "worker-initialization",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users attempting to restart a worker by calling Stop then Start encounter unexpected behavior, requiring clearer error handling to guide proper usage patterns.",
      "rootCause": "Worker.Start does not validate that the worker has not been previously stopped, allowing invalid restart attempts.",
      "proposedFix": "Panic on worker.Start if the worker has been stopped, forcing users to create a new worker instance for restarting.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker.Start now panics after worker.Stop is called, preventing invalid restart attempts.",
      "related": [],
      "keyQuote": "Panic on worker.Start after the worker.Stop was called.",
      "number": 447,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:42.627Z"
    },
    {
      "summary": "gRPC RPC timeout values (10 seconds default, 70 seconds for long polls) are too long and cause excessive latency spikes when connections are abruptly severed during cluster maintenance or upgrades. The issue requests making the maxRPCTimeout configurable so users can adjust it based on their specific scenarios.",
      "category": "feature",
      "subcategory": "rpc-timeout-configuration",
      "apis": [
        "StartWorkflowExecution"
      ],
      "components": [
        "rpc-client",
        "context-management",
        "connection-handling"
      ],
      "concepts": [
        "timeout",
        "rpc",
        "latency",
        "connection-resilience",
        "configuration",
        "graceful-shutdown",
        "network-reliability"
      ],
      "severity": "medium",
      "userImpact": "Users experience latency spikes lasting up to 10-70 seconds when the Temporal cluster undergoes upgrades or node recycling due to long gRPC timeouts.",
      "rootCause": "Fixed maxRPCTimeout values (10 seconds default, 70 seconds for long polls) don't account for abrupt connection severing during maintenance, causing requests to hang for the full timeout duration before retry.",
      "proposedFix": "Make maxRPCTimeout configurable (without changing current default) to allow users to set values appropriate for their use cases, including values greater than 10 seconds for operations like StartWorkflowExecution with large payloads.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1104
      ],
      "keyQuote": "letting maxRPCTimeout be configurable (w/o changing current default) might be an okay option for now?",
      "number": 444,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:40.084Z"
    },
    {
      "summary": "User encounters errors for previously registered activities that are no longer used by any workflows and cannot de-register them from workers. The error occurs on staging where old test workflows leave orphaned activity registrations.",
      "category": "question",
      "subcategory": "worker-registration",
      "apis": [],
      "components": [
        "worker",
        "activity-registry",
        "task-queue"
      ],
      "concepts": [
        "activity-registration",
        "worker-lifecycle",
        "activity-cleanup",
        "versioning",
        "backward-compatibility"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily clean up unused activity registrations from workers, resulting in confusing error messages when those activities are no longer needed.",
      "rootCause": "User expected explicit de-registration API for activities, but the SDK design relies on simply not registering activities in subsequent worker deployments.",
      "proposedFix": "Use versioning to branch code and keep old activities registered only as long as workflows using them exist, then remove once migrated to new workflows.",
      "workaround": "Identify and terminate/reset all workflows using old activities before removing their registrations from the worker.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer clarified that de-registration is implicit by not registering during worker startup. Recommended using versioning for gradual migration instead.",
      "related": [
        598
      ],
      "keyQuote": "You don't need to \"de-register\" activities explicitly, you do that by deploying a worker that doesn't register an activity during startup.",
      "number": 443,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:41.302Z"
    },
    {
      "summary": "Metrics reporting for gRPC calls to Temporal server include intermediate retry failures even when the final call succeeds, making the reported failure rate misleading. The request is to add a higher-level metric that excludes retries for ultimately successful calls while still including retry latency.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "interceptor",
        "grpc-client"
      ],
      "concepts": [
        "retry",
        "availability-metrics",
        "sla-reporting",
        "failure-rate",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users receive misleading availability metrics that conflate transient retry failures with actual service failures.",
      "rootCause": "The metrics interceptor records success/failure per-request, so retried failed requests are counted as failures even if the overall operation succeeds.",
      "proposedFix": "Add an additional higher-level metric that excludes intermediate retries for ultimately successful calls, while preserving retry latency in the calculation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Enhancement accepted to add metrics that differentiate between overall SLA and SLA including retry failures.",
      "related": [],
      "keyQuote": "an additional metric that excludes retries for ultimately successful calls would be useful",
      "number": 442,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:24.743Z"
    },
    {
      "summary": "Request to add a method to access and assert on the workflow signal channel state in the testing environment. Users currently cannot verify whether all received signals were consumed by the workflow without modifying workflow code.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-environment",
        "signal-channel",
        "workflow-testing"
      ],
      "concepts": [
        "signal-handling",
        "testing",
        "assertions",
        "workflow-state",
        "channel-observation"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot verify signal consumption in tests without modifying workflow code, limiting their ability to validate signal handling behavior.",
      "rootCause": null,
      "proposedFix": "Add env.GetWorkflowSignalChannel() or similar method to the testing environment to expose signal channel state.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There's no way to observe the state of the workflow signal channel and perform assertions on it.",
      "number": 439,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:28.242Z"
    },
    {
      "summary": "Client creation fails completely if health check intermittently fails with no built-in retry mechanism. Users must either disable health checks or implement retries in their application layer.",
      "category": "feature",
      "subcategory": "client-creation",
      "apis": [],
      "components": [
        "client-creation",
        "health-check",
        "grpc-connection"
      ],
      "concepts": [
        "retry",
        "health-check",
        "resilience",
        "connection-establishment",
        "failure-handling",
        "timeout"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably create clients when the health check service has intermittent failures, forcing them to disable health checks or implement custom retry logic.",
      "rootCause": "The checkHealth function has no retry mechanism and is called synchronously during client creation, causing immediate failure on any health check error.",
      "proposedFix": "Add more sophisticated retry logic to health check calls during client creation, or provide configuration options in ConnectionOptions to control retry behavior.",
      "workaround": "Disable health check via DisableHealthCheck option or implement retries in application layer.",
      "resolution": "fixed",
      "resolutionDetails": "Addressed in issue #453 with enhanced retry and reconnection logic.",
      "related": [
        453
      ],
      "keyQuote": "User's only option is to disable the health check or add retries on their application layer.",
      "number": 438,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:26.327Z"
    },
    {
      "summary": "Activity context is not canceled when the service is unreachable for the heartbeat timeout duration. Instead, the error is logged and a new heartbeat is issued, preventing activities from being notified about connectivity issues.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-manager",
        "service-connection"
      ],
      "concepts": [
        "timeout",
        "heartbeat",
        "context-cancellation",
        "connection-failure",
        "service-reachability"
      ],
      "severity": "high",
      "userImpact": "Activities cannot reliably detect and respond to service connectivity failures, potentially causing them to continue processing when they should be canceled.",
      "rootCause": "Heartbeat failure does not trigger activity context cancellation; instead it just logs an error and reschedules the next heartbeat.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Activity context is canceled (Done channel is closed) if it cannot reach the service for the duration of the heartbeat timeout.",
      "number": 437,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:13.745Z"
    },
    {
      "summary": "Workflow panics due to deadlock detection when many goroutines run concurrently. Users need to lower MaxConcurrentWorkflowTaskExecutionSize and MaxConcurrentActivityExecutionSize defaults, and request making the 1-second deadlock timeout configurable.",
      "category": "feature",
      "subcategory": "deadlock-detection",
      "apis": [],
      "components": [
        "worker",
        "workflow-task-executor",
        "activity-executor"
      ],
      "concepts": [
        "deadlock-detection",
        "concurrency",
        "goroutine-scheduling",
        "timeout",
        "performance",
        "load-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot scale workflow execution with higher concurrency limits without triggering deadlock detection panics, limiting throughput and requiring manual tuning of worker configuration.",
      "rootCause": "Deadlock detector uses a fixed 1-second timeout to detect when goroutines cannot be scheduled; under high load with many concurrent tasks, legitimate goroutines may exceed this threshold, triggering false-positive panics.",
      "proposedFix": "Make the deadlock detection timeout value configurable via a worker option instead of relying only on the TEMPORAL_DEBUG environment variable.",
      "workaround": "Set the TEMPORAL_DEBUG environment variable to disable deadlock detection entirely, or reduce MaxConcurrentWorkflowTaskExecutionSize and MaxConcurrentActivityExecutionSize values.",
      "resolution": "fixed",
      "resolutionDetails": "The team acknowledged the request and decided to make the 1-second timeout configurable as a future enhancement.",
      "related": [],
      "keyQuote": "Deadlock detector fires when a goroutine cannot get scheduled for execution for one second. It means that that your process is significantly overloaded.",
      "number": 435,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:13.642Z"
    },
    {
      "summary": "Querying a workflow inside RegisterDelayedCallback() with 0 duration causes a nil pointer dereference crash in the test environment. The query handler isn't registered in time when the callback executes immediately with 0 delay.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "QueryWorkflow",
        "RegisterDelayedCallback",
        "SignalWorkflow"
      ],
      "components": [
        "test-workflow-environment",
        "query-handler",
        "delayed-callback"
      ],
      "concepts": [
        "test-environment",
        "timing",
        "query",
        "callback",
        "race-condition"
      ],
      "severity": "medium",
      "userImpact": "Users cannot query workflows in delayed callbacks with 0 duration during testing, limiting test coverage for certain workflow patterns.",
      "rootCause": "When RegisterDelayedCallback() is called with 0 duration, the callback executes immediately before the query handler is properly registered in the test environment.",
      "proposedFix": null,
      "workaround": "Use a non-zero duration (e.g., 1 millisecond) for RegisterDelayedCallback() instead of 0 duration.",
      "resolution": "wontfix",
      "resolutionDetails": "After investigation, the team decided to update documentation rather than fix the test framework, as supporting this would require significant changes and the pattern isn't feasible in real-world scenarios.",
      "related": [],
      "keyQuote": "0 duration on RegisterDelayedCallback will always break if you try to query inside of it because of a bug where the query handler isn't registered yet.",
      "number": 433,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:22:12.035Z"
    },
    {
      "summary": "Activity responses that contain non-serializable types like `error` fields fail silently with no worker log output. The JSON serializer successfully marshals the struct but fails to unmarshal it on the next workflow task, causing confusion for developers who must inspect the web UI to discover the issue.",
      "category": "bug",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "json-converter",
        "activity-executor",
        "payload-converter"
      ],
      "concepts": [
        "json-serialization",
        "error-handling",
        "interface-marshaling",
        "silent-failure",
        "logging"
      ],
      "severity": "medium",
      "userImpact": "Developers receive no error logs when activities return non-serializable types, requiring manual inspection of the web UI to diagnose failures.",
      "rootCause": "The default JSON converter marshals structs with error fields without error (serializing the error as an empty object), but fails to unmarshal the result. The failure only appears during subsequent workflow task processing, with no corresponding worker log entry.",
      "proposedFix": "Improve documentation about JSON serialization limitations with interface types, and consider validation in the JSON converter to detect non-serializable fields at marshal time.",
      "workaround": "Implement custom JSON Marshal/Unmarshal functions for types containing interface fields, or use wrapper types instead of error fields.",
      "resolution": "wontfix",
      "resolutionDetails": "The issue was recognized as a limitation of Go's JSON serializer behavior with interface types rather than an SDK bug. Resolution focused on improving documentation rather than changing serializer behavior.",
      "related": [],
      "keyQuote": "The reason why this doesn't produce any message when you complete an activity is because underlying json serializer succeeds and we successfully send bytes back to the server",
      "number": 432,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:59.866Z"
    },
    {
      "summary": "Activity end-to-end latency metric is incorrectly recorded using the poll start time instead of the actual activity task scheduled time, causing inaccurate latency measurements.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "activity-executor",
        "metrics",
        "task-pollers"
      ],
      "concepts": [
        "latency",
        "metrics",
        "activity-scheduling",
        "time-measurement",
        "performance-monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users receive inaccurate activity latency metrics that don't reflect true end-to-end activity execution time.",
      "rootCause": "ActivityEndToEndLatency timer uses pollStartTime (when the poll request was made) instead of the actual activity task scheduled time, misaligning it with how ScheduleToStart is calculated.",
      "proposedFix": "Use GetStartTime() method on the returned task for calculating ActivityEndToEndLatency, consistent with how ScheduleToStart is calculated.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved via merged PR that corrected the latency calculation to use the proper task start time.",
      "related": [],
      "keyQuote": "pollStartTime is the start time of when the poll was started that received the activity task, not the start time of the actual activity task.",
      "number": 431,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:57.888Z"
    },
    {
      "summary": "Activity retry policy MaximumAttempts behaves differently in Go SDK workflow unit tests versus real Temporal server. When MaximumAttempts is set to n, unit tests execute the activity n+1 times instead of n times, causing a discrepancy in retry behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "RetryPolicy"
      ],
      "components": [
        "test-suite",
        "activity-executor",
        "retry-handler",
        "task-handlers"
      ],
      "concepts": [
        "retry",
        "unit-testing",
        "activity-execution",
        "attempt-counting",
        "retry-policy",
        "test-harness"
      ],
      "severity": "medium",
      "userImpact": "Unit tests produce different retry behavior than production, potentially masking issues or causing incorrect test assertions about activity retry counts.",
      "rootCause": "1-based vs 0-based attempt numbering discrepancy between SDK test framework and actual Temporal server, similar to temporal server PR #554",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Confirmed fixed in a later version; exact same replication code now passes the test suite",
      "related": [
        232
      ],
      "keyQuote": "Activity retry refactors: To disable Activity retries, configure Activities with RetryOptions that set maximumAttempts to 1.",
      "number": 429,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:55.581Z"
    },
    {
      "summary": "Test framework fails when asserting that an activity wasn't called. The mock setup using OnActivity().Panic() expects the activity to be invoked, causing the test to fail when the activity is correctly not called due to conditional branching.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "WorkflowExecute"
      ],
      "components": [
        "testsuite",
        "workflow-mock",
        "activity-mock"
      ],
      "concepts": [
        "conditional-branches",
        "activity-assertions",
        "mock-expectations",
        "test-verification",
        "false-positives"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test that activities are not called in conditional workflows, making it difficult to verify correct branching logic in unit tests.",
      "rootCause": "The mock framework treats unmet expectations as test failures, but there's no distinction between an activity that should be called but wasn't vs. an activity that shouldn't be called at all.",
      "proposedFix": "Implement a way to assert that an activity should not be called, possibly through a method like OnActivity().Never() or similar that expects zero invocations instead of failing on unmet expectations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The SDK was updated to properly handle assertions that activities should not be called in test scenarios.",
      "related": [],
      "keyQuote": "Should return an error if the activity was called and the assert should pass if the activity wasn't called.",
      "number": 427,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:43.817Z"
    },
    {
      "summary": "Workflow and activity with the same name may be confused by the SDK, causing the wrong function signature to be used when executing the activity.",
      "category": "bug",
      "subcategory": "registration-resolution",
      "apis": [
        "ExecuteActivity",
        "RegisterWorkflow",
        "RegisterActivity"
      ],
      "components": [
        "worker",
        "activity-registry",
        "workflow-registry"
      ],
      "concepts": [
        "name-collision",
        "registration",
        "function-resolution",
        "activity-execution",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Users defining workflow and activity with the same name may experience unexpected behavior where the SDK uses the wrong function signature.",
      "rootCause": "The SDK's name resolution mechanism may not properly distinguish between workflow and activity registrations when they share the same name.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Unable to reproduce the issue. The reporter attempted registration with aliases and confirmed the SDK correctly distinguished between workflow and activity with the same name.",
      "related": [],
      "keyQuote": "I'm unable to repro this issue. Workflow and activity code... I have a workflow and activity named \"FooBar\" and I'm able to start a workflow that runs activity using a name alias.",
      "number": 425,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:41.305Z"
    },
    {
      "summary": "Invoking struct local activities fails with nil pointer dereference when passing method values like `a.GetGreeting`. The SDK cannot access the receiver pointer of method values to validate and invoke them correctly.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity-handler",
        "activity-executor",
        "reflection"
      ],
      "concepts": [
        "method-values",
        "receiver-pointer",
        "reflection",
        "nil-dereference",
        "activity-invocation"
      ],
      "severity": "high",
      "userImpact": "Users cannot invoke struct local activities using method value syntax (e.g., `a.GetGreeting`), forcing them to either initialize structs or use string-based activity lookup.",
      "rootCause": "Reflection cannot access the receiver pointer of method values, so the SDK cannot validate it's not nil or invoke the method safely through reflection.",
      "proposedFix": "Look up the function name in the activity registry and call it by registration, or require method expression syntax like `(*Activities).GetGreeting` instead of method values.",
      "workaround": "Users can initialize structs before calling local activities, or call activities by string name instead of method reference.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #436 with changes to how local activities handle method invocation and receiver validation.",
      "related": [
        405,
        436
      ],
      "keyQuote": "The problem seems to be if you pass a 'method value' like `a.GetGreeting` there is no way to use reflection or anything else to access the receiver pointer",
      "number": 424,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:39.714Z"
    },
    {
      "summary": "Local activities with only error return parameters that return nil cause a 'Failed to parse server response' error in the web UI, though the CLI displays the workflow history correctly.",
      "category": "bug",
      "subcategory": "local-activity-serialization",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity",
        "serialization",
        "web-ui-integration"
      ],
      "concepts": [
        "error-handling",
        "return-parameters",
        "nil-serialization",
        "web-ui",
        "response-parsing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot view workflow history in the web UI when using local activities that return only error parameters with nil values.",
      "rootCause": "Improper serialization or parsing of local activity results when only an error return parameter exists and it's nil.",
      "proposedFix": "Fix in SDK to properly handle the case where a local activity has only an error return parameter and returns nil, as addressed in PR #367.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in sdk-go v1.5.0 through a change in how local activity results are serialized/parsed to handle error-only return parameters correctly.",
      "related": [
        365,
        306
      ],
      "keyQuote": "When running a workflow with a local activity that has only an error return parameter, and the local activity returns nil, the web UI can't show the workflow and shows this error: 13 INTERNAL: Failed to parse server response",
      "number": 421,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:26.599Z"
    },
    {
      "summary": "User requests ability to access workflow history size information through workflow.GetInfo() to proactively detect when history size is approaching limits and decide whether to continue as new, avoiding history size exceeded errors.",
      "category": "feature",
      "subcategory": "workflow-history",
      "apis": [
        "GetInfo"
      ],
      "components": [
        "workflow",
        "history",
        "info"
      ],
      "concepts": [
        "history-size",
        "event-count",
        "limits",
        "continue-as-new",
        "workflow-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users implementing custom DSLs on Temporal cannot proactively manage history growth and avoid history size exceeded errors.",
      "rootCause": null,
      "proposedFix": "Expose history size and event count information through workflow.GetInfo(ctx) API.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Workflow info now includes history size and length, allowing users to access this information and make informed decisions about continuing as new.",
      "related": [],
      "keyQuote": "Is it possible to return history size information trough workflow.GetInfo(ctx)? In this way, I'm able to check wf-history-size and wf-event-count in workflow to decide continue as new or not.",
      "number": 420,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:24.722Z"
    },
    {
      "summary": "The error handling documentation in workflow/doc.go is outdated and still references CustomError and GenericError which are no longer part of the current implementation. Documentation needs review to match actual implementation.",
      "category": "docs",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "documentation",
        "error-handling",
        "workflow"
      ],
      "concepts": [
        "error-handling",
        "api-documentation",
        "implementation-mismatch",
        "deprecation"
      ],
      "severity": "low",
      "userImpact": "Users may be confused by outdated error handling documentation that references non-existent APIs.",
      "rootCause": "Documentation was not updated when error handling implementation changed.",
      "proposedFix": "Review and update workflow/doc.go to match current error handling implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #879",
      "related": [
        879
      ],
      "keyQuote": "workflow/doc.go contains up-to-date information about failures. It is still referencing CustomError and GenericError.",
      "number": 417,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:28.244Z"
    },
    {
      "summary": "Documentation for WorkflowIDReusePolicy and WorkflowExecutionErrorWhenAlreadyStarted is confusing because it doesn't clearly explain that reuse policy only applies to completed/failed workflows, and the parameter descriptions don't properly clarify when each applies.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "ExecuteWorkflow",
        "WorkflowIDReusePolicy",
        "WorkflowExecutionErrorWhenAlreadyStarted"
      ],
      "components": [
        "client",
        "workflow-execution",
        "documentation"
      ],
      "concepts": [
        "workflow-reuse",
        "workflow-id-deduplication",
        "error-handling",
        "policy-configuration",
        "api-clarity"
      ],
      "severity": "low",
      "userImpact": "Developers are confused about when to use WorkflowIDReusePolicy and WorkflowExecutionErrorWhenAlreadyStarted parameters, leading to incorrect usage and misunderstanding of workflow ID handling.",
      "rootCause": "Documentation lacks clarity on the scope of WorkflowIDReusePolicy (completed workflows only) and how it relates to the WorkflowExecutionErrorWhenAlreadyStarted parameter.",
      "proposedFix": "Rephrase documentation to clarify that WorkflowExecutionErrorWhenAlreadyStarted controls behavior for in-progress workflows, while WorkflowIDReusePolicy applies to completed/failed workflows, and ensure both settings are explained together.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to clarify the parameters.",
      "related": [],
      "keyQuote": "if the WorkflowIDReusePolicy only applies to completed/failed workflows only, I'm not sure how we'd have a \"current\" or last run.",
      "number": 416,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:11.375Z"
    },
    {
      "summary": "RetryPolicy's BackoffCoefficient field was throwing a validation error when not defined, despite documentation indicating it should default to 2.0. The issue was whether to fix the code to apply the default value or update documentation to indicate it's a required field.",
      "category": "bug",
      "subcategory": "retry-policy",
      "apis": [
        "RetryPolicy"
      ],
      "components": [
        "retry-policy",
        "activity",
        "workflow"
      ],
      "concepts": [
        "backoff",
        "retry",
        "default-value",
        "validation",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users creating activities or workflows without explicitly setting BackoffCoefficient receive a confusing validation error contradicting the documentation.",
      "rootCause": "BackoffCoefficient was not properly defaulting to 2.0 when undefined in RetryPolicy struct, despite documentation claiming it should.",
      "proposedFix": "Either fix code to backfill BackoffCoefficient with default value 2.0 when not defined, or update documentation to indicate it's a required field.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by PR #462, which likely implemented proper default value handling for BackoffCoefficient.",
      "related": [
        462
      ],
      "keyQuote": "When not defined it throws a error saying `BackoffCoefficient cannot be less than 1 on retry policy` suggesting it is defaulting to something other than `2.0`",
      "number": 413,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:12.367Z"
    },
    {
      "summary": "Documentation link in the SDK repository's about section points to a broken URL. The link to the Go SDK overview page was incorrect due to a typo in a redirect rule, which was subsequently fixed.",
      "category": "docs",
      "subcategory": "documentation-links",
      "apis": [],
      "components": [
        "documentation",
        "repository-metadata"
      ],
      "concepts": [
        "documentation-links",
        "redirect-rules",
        "sdk-overview",
        "broken-links"
      ],
      "severity": "low",
      "userImpact": "Users following the SDK overview link from the repository about section encounter a 404 error instead of reaching the documentation.",
      "rootCause": "Typo in the redirect rule for the Go SDK overview documentation URL.",
      "proposedFix": "Fix the redirect rule in the documentation repository to point to the correct URL.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The typo in the redirect rule was fixed via temporalio/documentation PR #369.",
      "related": [],
      "keyQuote": "Looks like there was a typo in the redirect rule. Fixed here: https://github.com/temporalio/documentation/pull/369",
      "number": 412,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:21:13.738Z"
    },
    {
      "summary": "ChildWorkflowExecution Future's GetChildWorkflowExecution().Get() call doesn't return an error when child workflow start fails with WORKFLOW_ALREADY_EXISTS error. The parent workflow blocks indefinitely instead of receiving the error.",
      "category": "bug",
      "subcategory": "child-workflow-execution",
      "apis": [
        "ExecuteChildWorkflow",
        "GetChildWorkflowExecution",
        "Get"
      ],
      "components": [
        "child-workflow",
        "future",
        "error-handling"
      ],
      "concepts": [
        "error-propagation",
        "workflow-already-exists",
        "async-execution",
        "error-handling",
        "child-workflow-failure"
      ],
      "severity": "high",
      "userImpact": "Parent workflows cannot properly handle child workflow creation failures when the child workflow ID already exists, causing the parent to block indefinitely.",
      "rootCause": "ChildWorkflowExecution Future does not propagate CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS error to the Get() call.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Error propagation was implemented for WORKFLOW_ALREADY_EXISTS and related child workflow execution failures.",
      "related": [],
      "keyQuote": "The following code has to return an error if a child start failed due to CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS. Nothing is returned.",
      "number": 411,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:57.209Z"
    },
    {
      "summary": "ListClosedWorkflow only supports a single filter, requiring inefficient workarounds to query with multiple conditions like type and status. The request is to support multiple filters in List*Workflow methods for more efficient queries.",
      "category": "feature",
      "subcategory": "list-workflows-query",
      "apis": [
        "ListClosedWorkflow",
        "ListWorkflow"
      ],
      "components": [
        "list-workflows",
        "query-engine",
        "filter-support"
      ],
      "concepts": [
        "filtering",
        "query-efficiency",
        "multiple-conditions",
        "result-filtering",
        "workflow-search"
      ],
      "severity": "medium",
      "userImpact": "Users must inefficiently fetch large result sets and filter in-application code instead of pushing filter logic to the server.",
      "rootCause": null,
      "proposedFix": "Extend List*Workflow methods to accept multiple filters instead of just one.",
      "workaround": "Fetch all workflows matching one filter criterion, then iterate through results to find those matching additional criteria.",
      "resolution": "fixed",
      "resolutionDetails": "ListWorkflow was introduced as a replacement for ListClosedWorkflow, supporting a query parameter that can filter on multiple conditions.",
      "related": [],
      "keyQuote": "ListClosedWorkflow has bee superseded by ListWorkflow that takes a query parameter that can filter on multiple conditions.",
      "number": 410,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:59.588Z"
    },
    {
      "summary": "Activity retry policy is not respected in workflow test environments. When testing workflows with activities that have a retry policy, the test framework fails to retry activities on failure, causing tests to incorrectly report workflow errors.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity",
        "WithActivityOptions"
      ],
      "components": [
        "test-suite",
        "activity-executor",
        "retry-policy",
        "mock-environment"
      ],
      "concepts": [
        "retry",
        "testing",
        "activity-execution",
        "error-handling",
        "workflow-context",
        "default-policy"
      ],
      "severity": "high",
      "userImpact": "Developers cannot accurately test workflow behavior with activity retries, leading to incorrect test assertions and potential production bugs.",
      "rootCause": "The default retry policy is set by the Temporal server but is not applied to the local unit test environment.",
      "proposedFix": "Set the default retry policy for the test environment to match server behavior.",
      "workaround": "Explicitly set the retry policy in workflow ActivityOptions rather than relying on the default policy.",
      "resolution": "fixed",
      "resolutionDetails": "Default retry policy behavior was implemented for test environments to match server behavior.",
      "related": [
        461
      ],
      "keyQuote": "The default policy is set by server, we need to set the default one for test as well.",
      "number": 406,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:56.478Z"
    },
    {
      "summary": "ExecuteLocalActivity results in the activity struct pointer being nil when the activity is registered as a struct instance, while ExecuteActivity works correctly. This causes panics when the activity method tries to access receiver fields.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteLocalActivity",
        "ExecuteActivity",
        "RegisterActivity"
      ],
      "components": [
        "local-activity-executor",
        "activity-registration",
        "workflow-context"
      ],
      "concepts": [
        "nil-pointer",
        "method-receiver",
        "struct-instantiation",
        "activity-invocation"
      ],
      "severity": "high",
      "userImpact": "Users cannot use struct-based activities with ExecuteLocalActivity as the receiver becomes nil, causing runtime panics.",
      "rootCause": "Local activity execution does not properly preserve the struct receiver pointer when invoking methods on registered activity instances.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #426 as noted in closing comment",
      "related": [
        436,
        426
      ],
      "keyQuote": "ExecuteLocalActivity results in the struct pointer to the activities being nil. This does not happen when the activity is executed normally.",
      "number": 405,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:40.853Z"
    },
    {
      "summary": "Deadlock detection timeout is triggered when executing long-running operations like RSA key generation in workflows/side effects, causing unnecessary restarts. User requests API to extend or control the deadlock detection timeout for specific operations.",
      "category": "feature",
      "subcategory": "deadlock-detection",
      "apis": [
        "SideEffect"
      ],
      "components": [
        "deadlock-detection",
        "workflow-executor",
        "context"
      ],
      "concepts": [
        "timeout",
        "deadlock-detection",
        "long-running-operations",
        "workflow-execution",
        "side-effects",
        "synchronous-operations"
      ],
      "severity": "medium",
      "userImpact": "Users cannot safely execute long-running synchronous operations in workflows without triggering deadlock detection, forcing them to use workarounds or disable deadlock detection entirely.",
      "rootCause": "Deadlock detection has a fixed timeout threshold (~1 second) that is exceeded by legitimate long-running operations like RSA key generation.",
      "proposedFix": "Add API functions like `ctx.SetDeadlockTimeout(seconds)` and `defer ctx.ResetDeadlockTimeout()` to allow users to temporarily extend the deadlock detection timeout around expensive operations. Also suggested: `ctx.Alive()` for loops.",
      "workaround": "Use `TEMPORAL_DEBUG` flag to disable deadlock detection, though this is not recommended for production. Alternatively, use local activities instead of side effects, though even local activities can trigger deadlock detection for sufficiently expensive operations.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be great to have a few functions to give hints to the deadlock detection so that I could do something like this before calling an API that takes a bit longer than a second",
      "number": 404,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:39.832Z"
    },
    {
      "summary": "Activity errors returned as custom error types cannot be checked using `errors.Is()` because errors are wrapped in ApplicationError when crossing process boundaries. The issue involves confusion about which methods exist for accessing original error information.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "error-handling",
        "activity-executor",
        "test-framework"
      ],
      "concepts": [
        "error-wrapping",
        "process-boundaries",
        "error-type-assertion",
        "error-chain"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use standard Go error checking patterns like `errors.Is()` with activity errors, forcing them to use `errors.As()` and manual field comparison instead.",
      "rootCause": "Errors are reconstructed when crossing process boundaries, so the original error object identity is lost. Temporal errors don't implement `Is()` method, only `Unwrap()` and support for `errors.As()`.",
      "proposedFix": "Implement `Is()` method on Temporal error types that perform deep field comparison rather than pointer equality, while carefully handling cases like CanceledError and ApplicationError with varying fields.",
      "workaround": "Use `errors.As()` with type assertion instead of `errors.Is()`, or compare ApplicationError's message and type fields manually.",
      "resolution": "wontfix",
      "resolutionDetails": "By design - errors crossing process boundaries must be reconstructed, making pointer equality checks impossible. The maintainers clarified the correct approach using `errors.As()` instead.",
      "related": [
        1453
      ],
      "keyQuote": "The reason is that the process that called an activity and the process that implements the activity are frequently not the same... it is not really possible to return a Go error across process boundaries.",
      "number": 403,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:43.952Z"
    },
    {
      "summary": "User reported that CancelWorkflow() returns *serviceerror.NotFound with a generic 'sql: no rows in result set' message instead of EntityNotExistsError when a workflow doesn't exist. Discussion clarified this was a misunderstanding about Go error handling patterns rather than an actual bug.",
      "category": "question",
      "subcategory": "error-handling",
      "apis": [
        "CancelWorkflow",
        "GetWorkflow"
      ],
      "components": [
        "client",
        "error-handling",
        "service-error"
      ],
      "concepts": [
        "error-types",
        "type-assertion",
        "not-found-error",
        "standard-library-compatibility"
      ],
      "severity": "low",
      "userImpact": "Users unfamiliar with Go's type assertion pattern may struggle with proper error handling for non-existent workflows.",
      "rootCause": "User misunderstanding about Go error handling patterns (using errors.Is for type checking vs type assertions)",
      "proposedFix": null,
      "workaround": "Use type assertion pattern: _, isNotFound := err.(*serviceerror.NotFound)",
      "resolution": "invalid",
      "resolutionDetails": "Closed as invalid. The issue was based on incorrect assumptions about Go error handling. Type assertions are the standard way to verify error types, not errors.Is.",
      "related": [],
      "keyQuote": "This is not true. It _is_ the standard way to verify error types. errors.Is is the standard way to verify _equality_. But this is a server error and you don't want to verify equality, you want to verify that it is not found for any reason.",
      "number": 395,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:25.496Z"
    },
    {
      "summary": "Request to add QueryWorkflowByID method to TestWorkflowEnvironment for querying child workflows in unit tests. This feature enables developers to verify child workflow behavior within test scenarios.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "QueryWorkflowByID",
        "TestWorkflowEnvironment"
      ],
      "components": [
        "test-framework",
        "workflow-testing",
        "child-workflows"
      ],
      "concepts": [
        "testing",
        "query",
        "child-workflows",
        "unit-tests",
        "workflow-verification"
      ],
      "severity": "low",
      "userImpact": "Developers lack the ability to query and test child workflows in unit test scenarios, limiting test coverage for workflows that spawn child workflows.",
      "rootCause": null,
      "proposedFix": "Add QueryWorkflowByID(workflowID, queryType string, args ...interface{}) method to TestWorkflowEnvironment",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was implemented and the issue was closed",
      "related": [],
      "keyQuote": "add func (e *TestWorkflowEnvironment) QueryWorkflowByID(workflowID, queryType string, args ...interface{}) (converter.EncodedValue, error)",
      "number": 390,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:23.572Z"
    },
    {
      "summary": "Client creation does not validate the input address (host:port) format, causing cryptic connection errors later when the invalid address is used. Validation should occur during client initialization rather than at connection time.",
      "category": "bug",
      "subcategory": "client-initialization",
      "apis": [
        "Client"
      ],
      "components": [
        "client",
        "connection",
        "address-validation"
      ],
      "concepts": [
        "validation",
        "connection-error",
        "initialization",
        "address-format",
        "error-reporting"
      ],
      "severity": "medium",
      "userImpact": "Users receive confusing connection errors at runtime instead of clear validation errors during client setup.",
      "rootCause": "Missing input validation for address parameter in client creation, deferred to connection time",
      "proposedFix": "Add validation of host:port format during client creation before connection attempts",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed as resolution is configurable; validation approach may vary based on configuration",
      "related": [],
      "keyQuote": "host port should be validated during client creation",
      "number": 389,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:26.212Z"
    },
    {
      "summary": "In SDK 1.5.0, registering activities as struct methods without explicit naming causes conflicts between structs with identically named methods, and ExecuteActivity cannot find activities even when registered with a Name prefix. This differs from 1.4.1 where struct method naming scoping worked automatically.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "RegisterActivity",
        "RegisterActivityWithOptions",
        "ExecuteActivity",
        "ExecuteLocalActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "registration",
        "naming"
      ],
      "concepts": [
        "struct-methods",
        "activity-naming",
        "naming-conflicts",
        "registration-scoping",
        "method-resolution",
        "activity-lookup"
      ],
      "severity": "high",
      "userImpact": "Users migrating from 1.4.1 to 1.5.0 cannot register multiple struct types with identically named methods or execute activities registered with struct method names.",
      "rootCause": "A change in how activity method names are registered and resolved between struct instances; struct method names are no longer automatically scoped by the struct type name.",
      "proposedFix": "Restore automatic struct type name prefixing for activity method names during registration and execution, or provide automatic name qualification for struct-based activities.",
      "workaround": "Manually set RegisterOptions.Name to the struct type name when registering, and use string names (e.g., \"MyStruct.Activity1\") when executing activities instead of method references.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers confirmed the behavior is expected: activity names are based on non-qualified method names, requiring explicit Name prefixes for disambiguation. Closing as expected behavior rather than fixing.",
      "related": [
        92
      ],
      "keyQuote": "I have confirmed, even in a fresh 1.4.1 clone, that activities are registered based on their non-qualified method name and to prevent ambiguity for the same method names on different structs a name prefix must be used.",
      "number": 379,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:11.199Z"
    },
    {
      "summary": "Workflow panics with an illegal state error when cancel occurs during workflow sleep, followed by a cleanup activity execution. The panic indicates a failure to lookup the scheduled event ID to activity ID mapping, leaving the workflow stuck in Running state instead of transitioning to Canceled.",
      "category": "bug",
      "subcategory": "cancellation-handling",
      "apis": [
        "ExecuteActivity",
        "Sleep",
        "NewDisconnectedContext"
      ],
      "components": [
        "workflow-execution-engine",
        "event-handler",
        "decision-state-machine",
        "activity-scheduler"
      ],
      "concepts": [
        "cancellation",
        "state-machine",
        "event-processing",
        "cleanup-activities",
        "workflow-lifecycle",
        "panic-recovery"
      ],
      "severity": "high",
      "userImpact": "Workflows become stuck in Running state when canceled during sleep with cleanup activities, requiring manual intervention and preventing proper workflow termination.",
      "rootCause": "The decision state machine fails to locate the scheduled event ID to activity ID mapping when processing activity task scheduled events after a cancellation during workflow sleep, causing an illegal state panic.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflow panic... lookup failed for scheduledEventID to activityID: scheduleEventID: 11, activityID: 10",
      "number": 378,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:06.566Z"
    },
    {
      "summary": "Feature request to add an ApplicationErrorBuilder for Go SDK that uses method chaining to construct ApplicationError instances more concisely than the current NewApplicationError function.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "NewApplicationError"
      ],
      "components": [
        "error-handling",
        "api-design"
      ],
      "concepts": [
        "builder-pattern",
        "method-chaining",
        "error-construction",
        "api-ergonomics",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers would have a more concise and readable way to construct application errors using builder pattern instead of verbose function calls.",
      "rootCause": null,
      "proposedFix": "Implement ApplicationErrorBuilder with chaining methods like WithCause(), WithMessage(), WithNonRetryable(), and Build()",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers declined the feature as builder pattern is not idiomatic Go and they prefer a single standard way to construct ApplicationError",
      "related": [],
      "keyQuote": "We currently have no plans to add an `ApplicationErrorBuilder` they are not a common approach in Go and we do not want to introduce multiple ways to construct an `ApplicationError`",
      "number": 377,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:20:07.568Z"
    },
    {
      "summary": "Workflow panics when a SideEffect is used inside a versioned block during query execution. The panic occurs with the error 'lookup failed for scheduledEventID to activityID', preventing newly launched workflows from being queried even though the workflow itself completes successfully.",
      "category": "bug",
      "subcategory": "versioning",
      "apis": [
        "SideEffect"
      ],
      "components": [
        "decision-state-machine",
        "event-handler",
        "workflow-execution"
      ],
      "concepts": [
        "versioning",
        "side-effect",
        "query",
        "event-processing",
        "activity-scheduling",
        "workflow-panic"
      ],
      "severity": "high",
      "userImpact": "Users cannot query newly launched workflows that use SideEffect inside versioned blocks, even though the workflows execute successfully, blocking legitimate use cases like adding unique IDs to activities.",
      "rootCause": "The SDK's event handler fails to correctly map scheduledEventID to activityID when a SideEffect is combined with versioning, causing an illegal state panic during event processing.",
      "proposedFix": null,
      "workaround": "Remove either the SideEffect or the versioning - the issue only occurs when both are present together.",
      "resolution": "fixed",
      "resolutionDetails": "A unit test was created to reproduce the issue and a fix was implemented by the SDK maintainers.",
      "related": [],
      "keyQuote": "lookup failed for scheduledEventID to activityID: scheduleEventID: 8, activityID: 8",
      "number": 374,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:52.003Z"
    },
    {
      "summary": "Local activities that return only an error type fail to deserialize in temporal-web due to nil values in gRPC MarkerRecordedEvent payloads. The issue occurs when activities have no return value besides an error parameter.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "local-activity-executor",
        "grpc-serialization",
        "marker-event"
      ],
      "concepts": [
        "deserialization",
        "nil-handling",
        "gRPC",
        "return-types",
        "marker-recording"
      ],
      "severity": "high",
      "userImpact": "Users cannot view workflows containing local activities with error-only return types in temporal-web without gRPC parsing errors.",
      "rootCause": "When a local activity returns only an error (nil value), the `result` key in MarkerRecordedEventAttributes.details is set to nil. Node gRPC libraries fail to parse nil values in map<string, Payloads> fields.",
      "proposedFix": "Change the `result` key value from nil to an empty Payloads array in the MarkerRecordedEvent details when activity return type is error-only.",
      "workaround": "Add at least an empty return value to activities so they return (interface{}, error) instead of just error.",
      "resolution": "fixed",
      "resolutionDetails": "SDK-Go addressed the issue by not setting nil values in MarkerRecordedEventAttributes.details, instead using empty Payloads.",
      "related": [],
      "keyQuote": "The easiest is to fix this in go SDK itself. The issue didn't repro with sdk-java as it doesn't set `null` value in details of type `map<string, Payloads>`",
      "number": 365,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:54.586Z"
    },
    {
      "summary": "Tracer is not exporting workflow traces, only child activity traces are captured. Workflow-level traces should be available with activities as child traces.",
      "category": "bug",
      "subcategory": "tracing",
      "apis": [],
      "components": [
        "tracer",
        "workflow-executor",
        "activity-executor"
      ],
      "concepts": [
        "distributed-tracing",
        "observability",
        "span-hierarchy",
        "jaeger-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot see workflow-level traces in their distributed tracing system, limiting visibility into workflow execution.",
      "rootCause": "Workflow tracer is not properly exporting trace spans for workflow execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Workflow trace export was implemented to properly capture workflow spans with activities as child spans.",
      "related": [],
      "keyQuote": "Using tracer, we should be able to have trace for the workflow with child trace for activities",
      "number": 362,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:49.350Z"
    },
    {
      "summary": "Go's built-in map range iteration is non-deterministic, requiring users to implement workarounds. This request asks for a helper function to support deterministic iteration over maps.",
      "category": "feature",
      "subcategory": "map-iteration",
      "apis": [],
      "components": [
        "workflow-execution",
        "determinism"
      ],
      "concepts": [
        "determinism",
        "map-iteration",
        "replay",
        "generics",
        "workaround"
      ],
      "severity": "medium",
      "userImpact": "Users need to implement custom deterministic map iteration logic for workflows, adding complexity and potential for bugs.",
      "rootCause": "Go's built-in range over map uses random iteration order for security reasons, which conflicts with workflow replay requirements.",
      "proposedFix": "Add a helper function that supports deterministic iteration over maps, with considerations for map key comparability requirements.",
      "workaround": "Users must implement their own deterministic iteration logic manually.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented through SDK support for deterministic map iteration, addressing the need when range-over-func became available.",
      "related": [],
      "keyQuote": "Some helper to support deterministic iteration over map.",
      "number": 359,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:38.662Z"
    },
    {
      "summary": "JSON input payloads in workflow history are invalid and improperly encoded, with special characters like accents being escaped as Unicode sequences instead of being preserved correctly. This affects debugging through the Temporal Web UI and history API calls.",
      "category": "bug",
      "subcategory": "json-encoding",
      "apis": [],
      "components": [
        "workflow-history",
        "json-serialization",
        "web-ui"
      ],
      "concepts": [
        "encoding",
        "json-serialization",
        "unicode",
        "debugging",
        "payload-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly inspect workflow input payloads in the Web UI or via the history API due to malformed JSON and incorrect character encoding.",
      "rootCause": "JSON encoding does not properly handle non-ASCII characters like accented letters, converting them to escaped Unicode sequences.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal encoding doesn't support accents in the input too. `firstName:Pr\\u00e9nom test` for `firstName:Prnom test`",
      "number": 358,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:35.318Z"
    },
    {
      "summary": "Activity registration in the Go SDK fails silently when struct methods don't conform to the expected activity signature, processing methods up until the non-conforming one without any error or warning.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "RegisterActivityWithOptions"
      ],
      "components": [
        "activity-registry",
        "worker",
        "registration"
      ],
      "concepts": [
        "activity-binding",
        "method-signature",
        "error-handling",
        "validation",
        "silent-failure",
        "registration-logic"
      ],
      "severity": "high",
      "userImpact": "Developers cannot easily identify which activity methods failed to register, leading to missing activities and hard-to-debug runtime errors.",
      "rootCause": "The activity registration code does not validate method signatures and fails silently instead of reporting which methods don't match the expected signature.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Activity registration now validates signatures and provides clear error messages for non-conforming methods.",
      "related": [],
      "keyQuote": "When registering an activity struct that has methods that don't conform to the expected signature, activity registration should either fail with an error (maybe panic/fail in tests) or skip over the function.",
      "number": 356,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:37.105Z"
    },
    {
      "summary": "Request to allow string activity names in `workflow.ExecuteLocalActivity` to support DSL use-cases without requiring reflection-based implementations or multiple file changes.",
      "category": "feature",
      "subcategory": "local-activity-execution",
      "apis": [
        "ExecuteLocalActivity",
        "ExecuteActivity"
      ],
      "components": [
        "workflow",
        "activity-executor",
        "DSL-support"
      ],
      "concepts": [
        "activity-naming",
        "reflection",
        "DSL",
        "string-parameters",
        "local-activities"
      ],
      "severity": "medium",
      "userImpact": "Users with DSL use-cases must either implement custom reflection-based solutions or manage multiple file changes when adding activities.",
      "rootCause": null,
      "proposedFix": "Allow string `activity` parameter values for `workflow.ExecuteLocalActivity` similar to existing `workflow.ExecuteActivity` functionality.",
      "workaround": "Implement the reflection-based call solution in a switch statement.",
      "resolution": "fixed",
      "resolutionDetails": "ExecuteLocalActivity was updated to support string activity names matching ExecuteActivity behavior.",
      "related": [],
      "keyQuote": "Allow string `activity` parameter values for `workflow.ExecuteLocalActivity` the same way `workflow.ExecuteActivity` allows it currently.",
      "number": 354,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:24.402Z"
    },
    {
      "summary": "Feature request to allow injection of additional gRPC client interceptors to enable custom authorization metadata in outgoing requests. User has forked the SDK to add a CredentialsInterceptor to ConnectionOptions but seeks the Temporal team's preferred approach.",
      "category": "feature",
      "subcategory": "grpc-interceptors",
      "apis": [],
      "components": [
        "grpc-dialer",
        "connection-options",
        "client"
      ],
      "concepts": [
        "authorization",
        "metadata",
        "gRPC interceptors",
        "custom claims",
        "authentication",
        "credentials"
      ],
      "severity": "medium",
      "userImpact": "Users cannot inject custom authorization metadata into gRPC client requests, limiting authentication customization options.",
      "rootCause": "SDK does not expose gRPC UnaryClientInterceptor injection mechanism in ConnectionOptions.",
      "proposedFix": "Add CredentialsInterceptor field to ConnectionOptions struct to allow injection of gRPC UnaryClientInterceptor for authorization metadata.",
      "workaround": "Fork the SDK and manually add CredentialsInterceptor field to ConnectionOptions and integrate it in grpc_dialer.go.",
      "resolution": "fixed",
      "resolutionDetails": "Issue #368 was identified as addressing this requirement.",
      "related": [
        277,
        368
      ],
      "keyQuote": "In order to use a custom claims mapper / authorizer in the server, we need to be able to inject authorization metadata into the client request",
      "number": 353,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:21.831Z"
    },
    {
      "summary": "ReplayLogger.With doesn't properly expand the variadic keyvals parameter when passing arguments to the underlying logger, causing all arguments to be passed as a single array instead of separate arguments.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "ReplayLogger",
        "logging"
      ],
      "concepts": [
        "variadic arguments",
        "parameter expansion",
        "function delegation",
        "logging configuration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly configure logging with the ReplayLogger when using the With method with multiple key-value pairs.",
      "rootCause": "Missing spread operator (...) on keyvals parameter when calling the underlying logger's With method, causing the slice to be passed as a single argument instead of being expanded.",
      "proposedFix": "Append ... to keyvals on line 81: return NewReplayLogger(With(l.logger, keyvals...), l.isReplay, l.enableLoggingInReplay)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "keyvals on this line needs to have `...` appended like so: return NewReplayLogger(With(l.logger, keyvals...), l.isReplay, l.enableLoggingInReplay)",
      "number": 352,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:22.454Z"
    },
    {
      "summary": "When canceling a parent workflow through a mocked child workflow, the parent workflow panics instead of returning a cancellation error. The test framework doesn't properly propagate cancellation from child to parent workflows.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteChildWorkflow",
        "WithChildOptions",
        "CancelWorkflow",
        "IsCanceledError"
      ],
      "components": [
        "workflow-testing",
        "child-workflow-execution",
        "workflow-cancellation",
        "test-environment"
      ],
      "concepts": [
        "cancellation",
        "parent-child-workflow",
        "workflow-testing",
        "mocking",
        "error-handling",
        "panic"
      ],
      "severity": "high",
      "userImpact": "Users cannot properly test cancellation scenarios involving parent and child workflows, making it difficult to validate workflow cancellation behavior in test environments.",
      "rootCause": "The test environment's mock workflow execution does not properly handle cancellation propagation when a mocked child workflow cancels the parent, resulting in either panics or incorrect error handling.",
      "proposedFix": null,
      "workaround": "The issue mentions using Return() with the mock, but this prevents proper cancellation error propagation.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When mocking a child workflow to run a function that cancels the parent workflow, it should return that the parent workflow was cancelled.",
      "number": 351,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:07.539Z"
    },
    {
      "summary": "User asks whether they can change the input of a running workflow using signals, and requests example code. The issue was redirected to the community forum as it's a usage question rather than a bug or feature request.",
      "category": "question",
      "subcategory": "workflow-signals",
      "apis": [
        "Signal"
      ],
      "components": [
        "workflow-engine",
        "signal-handler"
      ],
      "concepts": [
        "workflow-input",
        "signaling",
        "workflow-modification",
        "runtime-changes"
      ],
      "severity": "low",
      "userImpact": "Users need guidance on whether and how to modify workflow inputs during execution via signals.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue redirected to community forum as a support question rather than a bug or feature request.",
      "related": [],
      "keyQuote": "Can I change input of running workflow with signaling? Is there any sample example for this?",
      "number": 347,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:08.080Z"
    },
    {
      "summary": "RequestCancelExternalWorkflow().Get(ctx, nil) blocks forever when the canceled workflow returns ErrCanceled, but works correctly when it returns nil. When a variable is passed to Get() instead, it returns properly but the error value is nil.",
      "category": "bug",
      "subcategory": "external-workflow-cancellation",
      "apis": [
        "RequestCancelExternalWorkflow",
        "ExecuteChildWorkflow",
        "GetChildWorkflowExecution"
      ],
      "components": [
        "workflow-client",
        "future-handling",
        "cancellation-logic",
        "error-propagation"
      ],
      "concepts": [
        "workflow-cancellation",
        "external-workflow",
        "blocking-behavior",
        "error-handling",
        "child-workflows"
      ],
      "severity": "high",
      "userImpact": "Developers cannot reliably wait for external workflow cancellation to complete when the canceled workflow returns ErrCanceled, causing their code to hang indefinitely.",
      "rootCause": "Potential issue in how Get() handles nil error results when waiting for canceled external workflows that return ErrCanceled.",
      "proposedFix": null,
      "workaround": "Pass a variable to Get() instead of nil: RequestCancelExternalWorkflow(...).Get(ctx, &wfErr) instead of Get(ctx, nil)",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If the workflow being canceled returns nil, Get() properly blocks until the canceled workflow has exited, but if the canceled workflow returns ErrCanceled then Get() never returns.",
      "number": 346,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:19:10.372Z"
    },
    {
      "summary": "A panic occurs when cancelling a child workflow followed immediately by cancelling the parent workflow, with an invalid state transition error in the workflow state machine.",
      "category": "bug",
      "subcategory": "workflow-cancellation",
      "apis": [
        "CancelWorkflow",
        "WithCancel"
      ],
      "components": [
        "workflow-state-machine",
        "child-workflow-executor",
        "cancellation-handler"
      ],
      "concepts": [
        "state-transition",
        "panic",
        "cancellation",
        "parent-child-workflows",
        "signal-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably cancel parent workflows after cancelling child workflows, causing workflows to hang and requiring manual termination.",
      "rootCause": "Invalid state transition in the command state machine when handling completion events for child workflows that have been cancelled, resulting in an Unknown state attempting to process ChildWorkflow completion.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "invalid state transition: attempt to handleCompletionEvent, CommandType: ChildWorkflow, state=Unknown",
      "number": 343,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:50.786Z"
    },
    {
      "summary": "Feature request to make context.Context an implicit/optional parameter in activity mocks so users don't have to explicitly pass mock.Anything for it, similar to how it's automatically propagated during execution.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "mock-framework",
        "testing"
      ],
      "concepts": [
        "mocking",
        "activity-testing",
        "context-propagation",
        "test-ergonomics",
        "signature-matching"
      ],
      "severity": "low",
      "userImpact": "Users must explicitly include mock.Anything for context.Context parameters when mocking activities, creating friction in test setup.",
      "rootCause": "Mock libraries require exact signature matching between mock expectations and actual function signatures, but context.Context is implicitly propagated during execution.",
      "proposedFix": "Allow context.Context to be an implicit/optional parameter in activity mocks that doesn't require explicit mock.Anything specification.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer determined that allowing signature mismatch for context.Context specifically would be confusing and error-prone, as mock libraries generally require exact signature matching.",
      "related": [],
      "keyQuote": "In general mock libraries require mock signature to match what is being mocked, seems confusing and error prone to allow a mismatch just for context.Context",
      "number": 336,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:55.027Z"
    },
    {
      "summary": "The ConvertFailureToError function incorrectly overwrites the original failure source with 'GoSDK', losing important diagnostic information about where the failure actually originated.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [
        "ConvertFailureToError"
      ],
      "components": [
        "error-converter",
        "failure-handling"
      ],
      "concepts": [
        "failure-source",
        "error-origin",
        "diagnostic-information",
        "root-cause-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users lose critical debugging information about failure origins, making it harder to diagnose and troubleshoot issues in workflows.",
      "rootCause": "ConvertFailureToError function explicitly sets the failure source to 'GoSDK' instead of preserving the original source value",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Sets GoSDK",
      "number": 335,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:51.785Z"
    },
    {
      "summary": "ExecuteLocalActivity() calls trigger a deadlock detection panic in SDK v1.3.0, occurring in ~90% of cases. The issue is caused by the new deadlock detector firing when workflow threads are blocked (e.g., by debuggers), rather than a genuine deadlock condition.",
      "category": "bug",
      "subcategory": "local-activity",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "workflow-executor",
        "deadlock-detector",
        "coroutine-state"
      ],
      "concepts": [
        "deadlock-detection",
        "debugging",
        "goroutine-blocking",
        "workflow-thread",
        "yield-timeout"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to v1.3.0 experience frequent workflow panics when using local activities, forcing them to downgrade or disable the deadlock detector.",
      "rootCause": "The deadlock detector introduced in v1.3.0 fires when workflow goroutines don't yield for over a second, including legitimate cases where threads are blocked by debuggers or other external factors.",
      "proposedFix": "Add TEMPORAL_DEBUG environment variable to disable deadlock detection during debugging, or allow configuration of DeadlockDetectionTimeout via worker options.",
      "workaround": "Either stay on v1.2.0, set TEMPORAL_DEBUG=true, or configure DeadlockDetectionTimeout to a higher value (e.g., 5 minutes) via worker.Options.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by PR #330 which introduced TEMPORAL_DEBUG environment variable and made deadlock detection configurable via DeadlockDetectionTimeout in worker options.",
      "related": [
        330
      ],
      "keyQuote": "Yes, blocking the workflow thread on breakpoint would cause the deadlock detector to fire. The #330 introduced the TEMPORAL_DEBUG environment variable that can be used to disable the deadlock detector for debugging purposes.",
      "number": 329,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:39.095Z"
    },
    {
      "summary": "User requested the ability to register workflows by struct (similar to activity registration) to avoid naming collisions when multiple packages contain workflows with the same function name. The SDK currently only uses function names without package context, causing panics on duplicate names.",
      "category": "feature",
      "subcategory": "workflow-registration",
      "apis": [
        "RegisterWorkflow"
      ],
      "components": [
        "worker",
        "workflow-registry"
      ],
      "concepts": [
        "naming-collision",
        "workflow-registration",
        "package-scoping",
        "struct-registration"
      ],
      "severity": "low",
      "userImpact": "Users with multiple workflows sharing the same function name across different packages are forced to use aliases or manual naming workarounds to avoid registration conflicts.",
      "rootCause": "The workflow registration code only extracts the function name without including package information, unlike activity registration which supports struct-based registration.",
      "proposedFix": "Allow registering workflows through struct pointers similar to the existing activity registration pattern, or ensure function names include package context.",
      "workaround": "Use worker.RegisterWorkflowWithOptions with RegisterWorkflowOptions.Name to explicitly specify workflow names, or use aliases.",
      "resolution": "wontfix",
      "resolutionDetails": "Feature was rejected as struct-based workflow registration could be confusing to new users since workflows are expected to be stateless. Users are directed to use RegisterWorkflowWithOptions instead.",
      "related": [],
      "keyQuote": "Registering workflows by struct is not something we plan to support as it can be very confusing to the new users. The reason is that workflows are expected to be stateless.",
      "number": 328,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:40.013Z"
    },
    {
      "summary": "User inquires about adopting Zap logger instead of Logrus, which is in maintenance mode. Issue was resolved when user discovered Logrus adapters can be used with Temporal.",
      "category": "question",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logging",
        "logger-integration"
      ],
      "concepts": [
        "logging",
        "logger-selection",
        "library-maintenance",
        "adapter-pattern"
      ],
      "severity": "low",
      "userImpact": "Users concerned about Logrus maintenance can use adapters to integrate alternative loggers like Zap.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": "Use Logrus adapter to plug with Temporal instead of switching loggers entirely.",
      "resolution": "self_resolved",
      "resolutionDetails": "User discovered that Logrus adapters can be used with Temporal, eliminating the need for a logger switch.",
      "related": [],
      "keyQuote": "Found can use logur adapter to plug with Temporal..so I'll close this Issue",
      "number": 324,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:35.988Z"
    },
    {
      "summary": "Feature request to add a LocalActivityOption to exclude local activity input arguments from history events. Local activities used for state logging generate large histories unnecessarily storing input data that's only for human consumption and not used by the SDK.",
      "category": "feature",
      "subcategory": "local-activity",
      "apis": [
        "LocalActivityOption"
      ],
      "components": [
        "local-activity-marker",
        "history-events",
        "event-handler"
      ],
      "concepts": [
        "history-size",
        "local-activity",
        "marker-event",
        "arguments",
        "optimization"
      ],
      "severity": "medium",
      "userImpact": "Users with large state logging workflows via local activities experience bloated history sizes that could be reduced by excluding unnecessary input arguments.",
      "rootCause": "Local activity input arguments are currently always included in marker events regardless of necessity, contributing to history bloat in scenarios with large state objects.",
      "proposedFix": "Add LocalActivityOption.DoNotIncludeArgumentsIntoHistory option to allow excluding input from the local activity marker event.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        441
      ],
      "keyQuote": "The local activity input is included in the marker event only for human consumption and is not used by the SDK.",
      "number": 313,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:23.375Z"
    },
    {
      "summary": "PostgreSQL database initialization fails on fresh setup with 'relation schema_version does not exist' error. The AUTO_SETUP feature is unable to properly create required database schema during startup with CockroachDB as the backing store.",
      "category": "bug",
      "subcategory": "database-initialization",
      "apis": [],
      "components": [
        "database-setup",
        "schema-initialization",
        "postgresql-persistence"
      ],
      "concepts": [
        "database-migration",
        "schema-versioning",
        "auto-setup",
        "initialization",
        "postgresql",
        "cockroachdb"
      ],
      "severity": "high",
      "userImpact": "Users cannot start a Temporal server instance with PostgreSQL/CockroachDB on a fresh database when AUTO_SETUP is enabled.",
      "rootCause": "Database schema initialization process fails to create the schema_version table before attempting to read it, likely due to missing schema setup scripts or improper execution order.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Issue was moved/duplicated to temporalio/temporal#1088 for tracking in the main server repository.",
      "related": [
        1088
      ],
      "keyQuote": "Unable to start server: sql schema version compatibility check failed: unable to read DB schema version keyspace/database: temporal error: pq: relation \"schema_version\" does not exist.",
      "number": 309,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:21.462Z"
    },
    {
      "summary": "User reported that custom error types defined in the internal package were inaccessible from external modules despite documentation suggesting they should be available. The issue was resolved when the author discovered the error types were also exported in the public temporal package.",
      "category": "docs",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "error-handling",
        "public-api",
        "internal-package"
      ],
      "concepts": [
        "error-types",
        "package-visibility",
        "documentation-accuracy",
        "public-api-design"
      ],
      "severity": "low",
      "userImpact": "Users following the error handling documentation may be confused about where to import custom error types from.",
      "rootCause": "Documentation did not clearly indicate that custom error types are available in the public temporal package, not the internal package.",
      "proposedFix": null,
      "workaround": "Import error types from go.temporal.io/sdk/temporal instead of attempting to use the internal package.",
      "resolution": "invalid",
      "resolutionDetails": "The author discovered that custom error types are exported in the public temporal package, making this a documentation clarity issue rather than an actual accessibility problem.",
      "related": [],
      "keyQuote": "Apparently I'm blind, as they are also in `go.temporal.io/sdk/temporal`",
      "number": 305,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:25.331Z"
    },
    {
      "summary": "Feature request to add Selector.HasPending method that checks if there are pending items without blocking, simplifying workflow completion logic that needs to drain all signals before returning.",
      "category": "feature",
      "subcategory": "selector-workflow",
      "apis": [
        "Selector",
        "ReceiveChannel",
        "Select",
        "ReceiveAsync",
        "GetSignalChannel"
      ],
      "components": [
        "selector",
        "workflow-context",
        "signal-handling",
        "channel-management"
      ],
      "concepts": [
        "signal-delivery",
        "non-blocking-check",
        "workflow-completion",
        "channel-draining",
        "pending-messages"
      ],
      "severity": "medium",
      "userImpact": "Users currently must manually drain all signal channels using ReceiveAsync before safely completing workflows, requiring verbose boilerplate code.",
      "rootCause": null,
      "proposedFix": "Add Selector.HasPending method that returns true if Selector.Select would not block, allowing simple loop condition like 'for keepGoing || s.HasPending { s.Select(ctx) }'",
      "workaround": "Manually iterate through all channels calling ReceiveAsync in a loop until no more messages are received before completing the workflow.",
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and merged, providing the requested HasPending method on Selector.",
      "related": [],
      "keyQuote": "Add Selector.HasPending method that returns true if Selector.Select is not going to block if called.",
      "number": 301,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:06.512Z"
    },
    {
      "summary": "Data race condition on cache eviction where a goroutine writes to coroutine state while another reads it during workflow cache cleanup. This causes concurrent access to the same memory location without synchronization.",
      "category": "bug",
      "subcategory": "concurrency",
      "apis": [],
      "components": [
        "dispatcher",
        "cache-eviction",
        "coroutine-state",
        "workflow-execution-context"
      ],
      "concepts": [
        "data-race",
        "concurrency",
        "synchronization",
        "cache-eviction",
        "goroutine",
        "memory-access"
      ],
      "severity": "high",
      "userImpact": "Users running long-duration workflows may encounter data race warnings and potential undefined behavior during workflow cache eviction.",
      "rootCause": "Unsynchronized concurrent access to coroutineState during cache eviction - goroutine writing to state.close() while dispatcher.Close() reads it during onEviction().",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by synchronizing access to coroutine state during cache eviction, likely through mutual exclusion or atomic operations.",
      "related": [
        294
      ],
      "keyQuote": "WARNING: DATA RACE Write at 0x00c000120629 by goroutine 124: go.temporal.io/sdk/internal.(*coroutineState).close()",
      "number": 295,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:08.846Z"
    },
    {
      "summary": "Documentation contains outdated references to activity.Register that should be removed. The API has evolved and these examples are no longer accurate or recommended.",
      "category": "docs",
      "subcategory": "activity-registration",
      "apis": [
        "Register"
      ],
      "components": [
        "activity",
        "documentation",
        "worker"
      ],
      "concepts": [
        "activity-registration",
        "documentation-accuracy",
        "API-evolution",
        "deprecation",
        "code-examples"
      ],
      "severity": "low",
      "userImpact": "Users reading the documentation may encounter outdated code examples that don't reflect the current recommended way to register activities.",
      "rootCause": "Documentation was not updated when the activity.Register API was changed or deprecated.",
      "proposedFix": "Remove all references to activity.Register from the documentation in three identified locations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #306 by removing outdated activity.Register references from documentation.",
      "related": [
        41,
        306
      ],
      "keyQuote": "I found three places mention about activity.Register",
      "number": 292,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:18:09.673Z"
    },
    {
      "summary": "Feature request to expose the failure of a previous workflow run through the workflow context API. Currently, getLastCompletionResult is available to communicate previous run results, but there's no equivalent API to access the failure details when continueAsNew occurs due to cron or retry policies.",
      "category": "feature",
      "subcategory": "workflow-context",
      "apis": [
        "getLastCompletionResult"
      ],
      "components": [
        "workflow-context",
        "continue-as-new",
        "retry-policy"
      ],
      "concepts": [
        "failure-handling",
        "workflow-history",
        "completion-result",
        "retry",
        "cron",
        "previous-run"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access failure details from previous workflow runs when using continueAsNew, limiting their ability to implement conditional logic based on failure types.",
      "rootCause": null,
      "proposedFix": "Expose a lastFailure API that provides access to the failure of the previous run, similar to how getLastCompletionResult works for successful runs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The lastFailure API was implemented to expose failure information from previous workflow runs in continueAsNew scenarios.",
      "related": [],
      "keyQuote": "Expose lastFailure api which exposes failure of previous run but we still did a continueAsNew because of cron or retry policy.",
      "number": 291,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:52.109Z"
    },
    {
      "summary": "Feature request to register local activities only without enabling regular task queue activity consumption. Users want to isolate workflow workers from business logic while still using local activities.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "worker",
        "activity-poller",
        "local-activities"
      ],
      "concepts": [
        "worker-isolation",
        "activity-registration",
        "task-queue",
        "local-activity-execution",
        "worker-options"
      ],
      "severity": "medium",
      "userImpact": "Users can now isolate workflow workers from business logic by registering only local activities without consuming from task queues.",
      "rootCause": null,
      "proposedFix": "Add a `LocalActivityWorkerOnly` worker option that disables regular activity polling when set to true.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in both Go and Java SDKs with new `LocalActivityWorkerOnly` worker option that disables regular activity polling.",
      "related": [],
      "keyQuote": "It will be useful to be able to register local activities only without enabling task queue activity consumption.",
      "number": 284,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:54.000Z"
    },
    {
      "summary": "Request to create a Registry interface in the worker package containing only registration methods for workflows and activities, allowing consumers to avoid depending on the full Worker interface with Start/Stop methods.",
      "category": "feature",
      "subcategory": "worker-registry",
      "apis": [],
      "components": [
        "worker",
        "workflow-registry",
        "activity-registry"
      ],
      "concepts": [
        "interface-design",
        "registration",
        "separation-of-concerns",
        "api-surface"
      ],
      "severity": "low",
      "userImpact": "Consumers can depend on a more focused Registry interface instead of the full Worker interface, reducing unnecessary coupling.",
      "rootCause": null,
      "proposedFix": "Define a Registry or WorkerRegistry interface with registration methods and embed it in the Worker interface. Consider splitting into separate WorkflowRegistry and ActivityRegistry interfaces.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Registry interface was implemented to provide a focused API for workflow and activity registration without Start/Stop methods.",
      "related": [],
      "keyQuote": "Define a `Registry` or a `WorkerRegistry` interface in the worker package with the registration methods and embed it in the worker interface.",
      "number": 280,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:52.970Z"
    },
    {
      "summary": "StartWorkflow and OnWorkflowTaskStarted are triggered twice on the same worker during QueryWorkflow, causing workflow state corruption when using extension APIs with external memory.",
      "category": "bug",
      "subcategory": "query-workflow",
      "apis": [
        "StartWorkflow",
        "QueryWorkflow",
        "OnWorkflowTaskStarted"
      ],
      "components": [
        "worker",
        "query-engine",
        "workflow-instance-manager"
      ],
      "concepts": [
        "state-corruption",
        "duplicate-execution",
        "workflow-environment",
        "extension-api",
        "memory-management"
      ],
      "severity": "high",
      "userImpact": "Workflow state gets corrupted when querying workflows that use external memory through extension APIs due to duplicate workflow initialization.",
      "rootCause": "The SDK creates a second workflow version without destroying the previous state during query execution, causing conflicting state in external memory.",
      "proposedFix": "Either reuse the existing workflow environment or properly destroy the previous version before querying.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through SDK fixes to prevent duplicate workflow initialization during query operations.",
      "related": [],
      "keyQuote": "Temporal Go SDK issues a second workflow version without destroying previous state which corrupts the workflow state if external memory used.",
      "number": 279,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:39.112Z"
    },
    {
      "summary": "Feature request to expose access to the underlying gRPC ServiceClient in the Go SDK to enable creation of default clients and access to low-level gRPC functionality, particularly needed for SDK code generation like in the PHP SDK.",
      "category": "feature",
      "subcategory": "grpc-client-exposure",
      "apis": [],
      "components": [
        "grpc-client",
        "client-initialization"
      ],
      "concepts": [
        "grpc-service-client",
        "client-access",
        "sdk-integration",
        "code-generation"
      ],
      "severity": "low",
      "userImpact": "SDK developers need direct access to underlying gRPC clients to implement proper client code generation and extend SDK functionality.",
      "rootCause": null,
      "proposedFix": "Expose the grpc.ServiceClient to allow access to the underlying gRPC client during client creation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Expose access to grpc.ServiceClient so we can create default golang client and get access to underlying GRPC client",
      "number": 277,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:36.987Z"
    },
    {
      "summary": "Worker logs verbose 'no activities/workflow registered' messages at INFO level when running separate workers for activities and workflows. Request to reduce log severity to DEBUG level to reduce noise.",
      "category": "other",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "worker",
        "logger"
      ],
      "concepts": [
        "logging",
        "worker-configuration",
        "activity-registration",
        "workflow-registration",
        "log-levels"
      ],
      "severity": "low",
      "userImpact": "Users running separate activity and workflow workers see annoying informational messages that don't provide actionable value.",
      "rootCause": "Worker logs activity/workflow registration status at INFO level regardless of deployment architecture.",
      "proposedFix": "Change the log level of 'no activities/workflow registered' message from INFO to DEBUG.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Log severity was reduced to DEBUG level in a subsequent release.",
      "related": [],
      "keyQuote": "Keep the message but use DEBUG level.",
      "number": 276,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:35.870Z"
    },
    {
      "summary": "When a workflow with a retry policy receives a non-retryable error from an activity, the workflow incorrectly gets retried despite the error type matching the NonRetryableErrorTypes specification. The error originating from the activity is not being properly recognized as non-retryable at the workflow level.",
      "category": "bug",
      "subcategory": "retry-policy",
      "apis": [
        "ExecuteActivity",
        "NewApplicationError"
      ],
      "components": [
        "retry-engine",
        "error-handling",
        "workflow-executor",
        "activity-executor"
      ],
      "concepts": [
        "retry-policy",
        "non-retryable-errors",
        "error-propagation",
        "activity-errors",
        "error-type-matching",
        "retry-logic"
      ],
      "severity": "high",
      "userImpact": "Users cannot prevent workflow retries when activities return non-retryable errors, causing workflows to exhaust all retry attempts before failing.",
      "rootCause": "The retry logic at the workflow level is not properly checking the error type from activities against the workflow's NonRetryableErrorTypes specification.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue closed by reporter after community discussion clarified the behavior; likely user misunderstanding of how retry policies apply across activity and workflow boundaries.",
      "related": [],
      "keyQuote": "I would expect the workflow to quit on the first attempt, but it keeps getting retried until MaxAttempts is reached.",
      "number": 275,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:20.744Z"
    },
    {
      "summary": "Feature request to add a WorkflowClient method for retrieving the RunId of a workflow, eliminating the need to call the lower-level DescribeWorkflowExecution API for this common operation.",
      "category": "feature",
      "subcategory": "workflow-client",
      "apis": [
        "WorkflowClient",
        "DescribeWorkflowExecution"
      ],
      "components": [
        "workflow-client",
        "client-api"
      ],
      "concepts": [
        "run-id",
        "workflow-identification",
        "client-convenience",
        "workflow-metadata"
      ],
      "severity": "low",
      "userImpact": "Users currently require lower-level API calls to retrieve a workflow's RunId, which is a common operation that should be directly accessible through the main WorkflowClient.",
      "rootCause": null,
      "proposedFix": "Add a method to WorkflowClient to get the run id directly (and potentially workflow status)",
      "workaround": "Use DescribeWorkflowExecution call to obtain the RunId",
      "resolution": "fixed",
      "resolutionDetails": "RunId is now accessible through WorkflowClient methods",
      "related": [],
      "keyQuote": "Add a way to get the run id (and maybe workflow status) directly using the WorkflowClient.",
      "number": 272,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:24.326Z"
    },
    {
      "summary": "When WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE is set, ExecuteWorkflow returns the previous workflow result instead of rejecting the duplicate call. Users need an option to force returning WorkflowExecutionAlreadyStarted error to detect duplicate calls.",
      "category": "feature",
      "subcategory": "workflow-deduplication",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflowOptions"
      ],
      "components": [
        "workflow-client",
        "execution-reuse-policy"
      ],
      "concepts": [
        "deduplication",
        "workflow-reuse",
        "error-handling",
        "idempotency",
        "duplicate-detection"
      ],
      "severity": "medium",
      "userImpact": "Users cannot detect whether an ExecuteWorkflow call is a duplicate when using REJECT_DUPLICATE reuse policy, making it impossible to distinguish between first execution and reuse.",
      "rootCause": "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE returns previous workflow result instead of error for duplicate calls.",
      "proposedFix": "Add StartWorkflowOptions.FailOnAlreadyStarted option to force returning WorkflowExecutionAlreadyStarted error for duplicate calls.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #220 in the same repository.",
      "related": [
        220
      ],
      "keyQuote": "Add StartWorkflowOptions.FailOnAlreadyStareted option that would force returning WorkflowExecutionAlreadyStarted in this case.",
      "number": 268,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:22.006Z"
    },
    {
      "summary": "Request to expose activity start and completion information (timestamps, attempt numbers, etc.) to workflow code so developers can access metadata about activity execution lifecycle.",
      "category": "feature",
      "subcategory": "activity-metadata",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "workflow-runtime",
        "activity-result-handler"
      ],
      "concepts": [
        "activity-lifecycle",
        "execution-metadata",
        "timestamps",
        "attempt-tracking",
        "activity-information"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot currently access detailed activity execution metadata within workflows, limiting visibility into activity behavior and debugging capabilities.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        228
      ],
      "keyQuote": "Expose activity start and completion information to the workflow code",
      "number": 266,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:07.753Z"
    },
    {
      "summary": "Go SDK lacks an ActivityInterceptor feature that exists in the Java SDK. This feature would enable logging, tracing, and other cross-cutting concerns for activity execution.",
      "category": "feature",
      "subcategory": "activity-interceptor",
      "apis": [],
      "components": [
        "activity-executor",
        "interceptor-framework",
        "worker"
      ],
      "concepts": [
        "logging",
        "tracing",
        "cross-cutting-concerns",
        "interceptor-pattern",
        "activity-execution",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot intercept and customize activity execution behavior for logging, tracing, and monitoring purposes.",
      "rootCause": null,
      "proposedFix": "Implement ActivityInterceptor similar to Java SDK's implementation to allow activity execution interception.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "ActivityInterceptor was implemented in the Go SDK to match Java SDK functionality.",
      "related": [],
      "keyQuote": "This one would be really useful, especially for logging, tracing, of activities etc...",
      "number": 265,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:05.350Z"
    },
    {
      "summary": "String search attributes in the Go SDK are including unwanted quotation characters in retrieved values. This is a bug related to how search attribute values are formatted or escaped.",
      "category": "bug",
      "subcategory": "search-attributes",
      "apis": [],
      "components": [
        "search-attributes",
        "string-handling"
      ],
      "concepts": [
        "search-attributes",
        "string-encoding",
        "value-formatting",
        "quotation-marks"
      ],
      "severity": "medium",
      "userImpact": "Users retrieving string search attributes get incorrect values that include unwanted quotation characters, causing data corruption or parsing errors.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "related": [
        524
      ],
      "keyQuote": "Retrieved String Search Attribute includes quotation characters",
      "resolution": null,
      "resolutionDetails": null,
      "number": 247,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:17:08.808Z"
    },
    {
      "summary": "Google protocol buffer compiler-generated structs are not fully supported by the SDK, unlike gogo-generated structs. This causes issues with enum serialization when using google protobuf in activity arguments.",
      "category": "bug",
      "subcategory": "proto-serialization",
      "apis": [],
      "components": [
        "proto-marshaller",
        "jsonpb",
        "serialization"
      ],
      "concepts": [
        "protocol-buffers",
        "struct-serialization",
        "enum-handling",
        "google-protoc",
        "gogo-proto",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably use google protocol buffer compiler-generated structs in activity arguments due to incorrect enum serialization.",
      "rootCause": "SDK only supports gogo proto structs and uses gogo jsonpb marshaller, which handles google proto structs differently, particularly for enums.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved long time ago according to the issue author.",
      "related": [],
      "keyQuote": "Currently only gogo proto structs are supported since we use gogo jsonpb and proto marshaller.",
      "number": 243,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:51.266Z"
    },
    {
      "summary": "Documentation claimed Tracer property was available in WorkerOptions, but it was actually removed and only available in ClientOptions. User reported missing tracer support and confusion about trace span relationships when using OpenTelemetry.",
      "category": "docs",
      "subcategory": "tracing",
      "apis": [
        "WorkerOptions",
        "ClientOptions"
      ],
      "components": [
        "tracer",
        "worker",
        "client-options"
      ],
      "concepts": [
        "distributed-tracing",
        "opentracing",
        "span-propagation",
        "context-propagation",
        "opentelemetry"
      ],
      "severity": "medium",
      "userImpact": "Users were confused by outdated documentation and struggled to implement proper distributed tracing across workers.",
      "rootCause": "Documentation was not updated when Tracer property was moved from WorkerOptions to ClientOptions.",
      "proposedFix": "Update documentation to reflect that Tracer is only in ClientOptions. Provide clear examples and integration tests for tracing setup.",
      "workaround": "Set tracer on all workers and starters manually; check the implementation in tracer.go and tracer_test.go.",
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated at docs.temporal.io/docs/go-tracing/. Integration tests were added and end-to-end sample provided in samples-go/ctxpropagation/.",
      "related": [],
      "keyQuote": "Doc is outdated and will fix it soon. I removed all duplicate options from WorkerOptions and move few of them to ClientOptions.",
      "number": 239,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:53.363Z"
    },
    {
      "summary": "RecordActivityHeartbeat should return an error if the activity has been canceled, instead of being a no-op. Currently users must manually select on the context to check if it's done.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "RecordActivityHeartbeat"
      ],
      "components": [
        "activity-executor",
        "context-handling"
      ],
      "concepts": [
        "cancellation",
        "error-handling",
        "heartbeat",
        "activity-lifecycle",
        "context-done"
      ],
      "severity": "medium",
      "userImpact": "Users must perform additional manual checks when an activity is canceled instead of receiving immediate error feedback from heartbeat recording.",
      "rootCause": null,
      "proposedFix": "Modify RecordActivityHeartbeat to check if the activity context is done and return an error if so.",
      "workaround": "Manually select on the activity context to check if it has been canceled.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If the Activity is canceled, the user has to still do a select on the context to see if it is Done.",
      "number": 238,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:49.444Z"
    },
    {
      "summary": "Duplicate protobuf extension registration panic occurs when using Temporal SDK with conflicting protobuf dependencies. Multiple transitive dependencies (envoyproxy/protoc-gen-validate, cncf/udpa) register the same gogo.proto extensions, causing initialization failure in Go applications.",
      "category": "bug",
      "subcategory": "protobuf-dependencies",
      "apis": [],
      "components": [
        "protobuf",
        "module-loading",
        "gogo-proto"
      ],
      "concepts": [
        "dependency-conflict",
        "protobuf-extension",
        "initialization",
        "go-modules",
        "transitive-dependencies"
      ],
      "severity": "high",
      "userImpact": "Applications using the SDK fail to start with a panic error when protobuf dependencies are improperly configured or when transitive dependencies have conflicting extension registrations.",
      "rootCause": "Multiple transitive dependencies (protoc-gen-validate, udpa) included in the dependency tree register the same protobuf extensions (e.g., descriptor.EnumOptions 62001) to gogo.proto, causing duplicate registration panics during module initialization.",
      "proposedFix": "Update dependency versions or refactor dependency tree to avoid multiple registrations of the same protobuf extensions. Using latest master commit resolved the issue.",
      "workaround": "Remove vendor directory and use Go modules with 'go mod download' instead of vendoring; ensure go.mod/go.sum properly resolve dependencies without duplication.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by updating to a later version of dependencies (confirmed working on latest master commit). The issue was related to how protobuf extensions were registered across multiple transitive dependencies.",
      "related": [],
      "keyQuote": "panic: proto: duplicate extension registered: descriptor.EnumOptions 62001",
      "number": 236,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:38.383Z"
    },
    {
      "summary": "Remove legacy code related to the disable sticky execution flag. The sticky execution feature is now standard and the backwards compatibility code for disabling it is no longer needed.",
      "category": "feature",
      "subcategory": "sticky-execution",
      "apis": [],
      "components": [
        "sticky-execution",
        "worker",
        "code-cleanup"
      ],
      "concepts": [
        "backwards-compatibility",
        "feature-removal",
        "deprecation",
        "sticky-execution",
        "technical-debt"
      ],
      "severity": "low",
      "userImpact": "Removes legacy code paths, simplifying the SDK and reducing maintenance burden without affecting user-facing functionality.",
      "rootCause": "Sticky execution feature was released with backwards compatibility flag; the flag is no longer needed as sticky execution is now standard.",
      "proposedFix": "Remove all code related to disabling sticky execution and associated backwards compatibility logic.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #318 which removed the disable sticky execution flag and associated legacy code.",
      "related": [
        318
      ],
      "keyQuote": "We have a bunch of code in GoSDK which was created to be able to release sticky execution feature in backwards compatible manner. This is no longer needed and should be removed",
      "number": 233,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:35.152Z"
    },
    {
      "summary": "Local activities executed in parallel cause workflow to hang because they are incorrectly assigned the same activity ID. The ID counter is only incremented after a local activity completes, not when they start.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "command-state-machine",
        "event-handlers",
        "activity-execution",
        "workflow-replay"
      ],
      "concepts": [
        "parallel-execution",
        "activity-id-assignment",
        "workflow-deadlock",
        "backwards-compatibility",
        "event-replay",
        "sequencing"
      ],
      "severity": "high",
      "userImpact": "Workflows that spawn multiple local activities in parallel will hang indefinitely, blocking workflow execution entirely.",
      "rootCause": "Local activity IDs are generated using GenerateSequenceID() which returns the same ID for all parallel activities since the counter only increments after an activity completes, not when it starts. This causes duplicate activity IDs which break replay matching.",
      "proposedFix": "Find a backwards-compatible way to assign unique IDs to parallel local activities without breaking existing workflow event histories that rely on the current ID semantics.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Local Activities executed in parallel cause the Workflow to hang...they are incorrectly assigned the same activity ID as it uses the 'next command event ID' and for local activities, that next command event ID is only incremented when the local activity finishes.",
      "number": 228,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:34.281Z"
    },
    {
      "summary": "ExecuteWorkflow does not raise WorkflowExecutionAlreadyStartedError when a workflow with the same ID is restarted using WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY. The error is silently consumed and an existing WorkflowRun is returned instead.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "workflow-client",
        "error-handling",
        "reuse-policy"
      ],
      "concepts": [
        "workflow-id-reuse",
        "duplicate-execution",
        "error-propagation",
        "workflow-execution-state"
      ],
      "severity": "high",
      "userImpact": "Users migrating from Cadence cannot properly handle duplicate workflow executions and cannot distinguish between new and existing workflow runs based on error types.",
      "rootCause": "ExecuteWorkflow consumes WorkflowExecutionAlreadyStartedError internally and returns existing WorkflowRun instead of propagating the error to the caller.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by ensuring WorkflowExecutionAlreadyStartedError is properly raised to callers when appropriate reuse policies are set.",
      "related": [],
      "keyQuote": "Being able to receive `WorkflowExecutionAlreadyStartedError` on `ExecuteWorkflow` if `ReusePolicy` is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`",
      "number": 220,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:21.477Z"
    },
    {
      "summary": "Child workflow cancellation causes an apparent deadlock in the Go SDK, preventing workflow execution from completing normally when cancelling child workflows in a pandemic test scenario.",
      "category": "bug",
      "subcategory": "child-workflows",
      "apis": [
        "CancelWorkflow"
      ],
      "components": [
        "workflow-executor",
        "child-workflow-handler",
        "cancellation-logic"
      ],
      "concepts": [
        "deadlock",
        "cancellation",
        "child-workflows",
        "synchronization",
        "workflow-blocking"
      ],
      "severity": "high",
      "userImpact": "Users experience workflow executions that appear to deadlock when attempting to cancel child workflows, preventing proper workflow completion.",
      "rootCause": "Child workflow cancellation does not properly handle synchronization between parent and child workflow states, causing the parent workflow to block indefinitely.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved in a subsequent version through proper cancellation signal handling in child workflow execution.",
      "related": [],
      "keyQuote": "Cancellation of Child Workflows leads to an apparent deadlock",
      "number": 213,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:21.898Z"
    },
    {
      "summary": "syscall.Kill is undefined on Windows, breaking compilation of the Go SDK on Windows platforms. The code uses Unix-specific syscall APIs without platform-specific guards.",
      "category": "bug",
      "subcategory": "platform-compatibility",
      "apis": [],
      "components": [
        "internal_worker_base",
        "syscall",
        "windows-compatibility"
      ],
      "concepts": [
        "platform-specific-code",
        "windows-support",
        "build-failure",
        "cross-platform"
      ],
      "severity": "high",
      "userImpact": "Windows developers cannot build or use the SDK v0.27.0 due to compilation errors from undefined Unix-only syscall functions.",
      "rootCause": "syscall.Kill is a Unix-specific function that is not available on Windows; the code lacks platform-specific build constraints or conditional compilation.",
      "proposedFix": "Use platform-specific build tags or conditional compilation to handle Windows and Unix differently, similar to the approach in bugsnag-go.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Likely resolved by adding platform-specific guards or using cross-platform alternatives to syscall.Kill in internal_worker_base.go.",
      "related": [],
      "keyQuote": "undefined: syscall.Kill on Windows 10 after moving to v0.27.0",
      "number": 208,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:20.054Z"
    },
    {
      "summary": "Request for a mechanism to support backward-incompatible changes to workflow and activity function signatures while maintaining compatibility with callers using the old signatures.",
      "category": "feature",
      "subcategory": "signature-evolution",
      "apis": [],
      "components": [
        "workflow-engine",
        "activity-executor",
        "function-signature"
      ],
      "concepts": [
        "backward-compatibility",
        "signature-versioning",
        "function-evolution",
        "migration-path",
        "api-stability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot modify workflow or activity function signatures in breaking ways without disrupting existing callers or duplicating function logic.",
      "rootCause": null,
      "proposedFix": "Implement a versioning or overloading mechanism that allows multiple signatures for the same workflow or activity while maintaining backward compatibility.",
      "workaround": "Use input and output structures for activities and workflows to allow flexible parameter passing.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There is no way to change workflow or activity function signature in a nonbackward compatible way.",
      "number": 198,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:07.600Z"
    },
    {
      "summary": "Go SDK incorrectly handles ContinueAsNew when two workflows in different packages have the same function name, causing the wrong workflow to be executed. The SDK should either crash on startup if duplicate function names are registered or properly differentiate between them.",
      "category": "bug",
      "subcategory": "workflow-registration",
      "apis": [
        "ContinueAsNew",
        "RegisterWorkflow"
      ],
      "components": [
        "workflow-registry",
        "worker",
        "registration"
      ],
      "concepts": [
        "workflow-naming",
        "function-resolution",
        "duplicate-detection",
        "package-scoping",
        "registration-validation"
      ],
      "severity": "high",
      "userImpact": "Users with workflows having identical function names in different packages will have the wrong workflow invoked during ContinueAsNew operations, causing runtime confusion and incorrect workflow execution.",
      "rootCause": "The SDK uses only the simple function name as the workflow identifier/alias without considering package context, allowing two different functions with the same name to overwrite each other's registration.",
      "proposedFix": "The SDK should panic if a workflow name is reused during registration unless DisableAlreadyRegisteredCheck is explicitly set to true in the options.",
      "workaround": "Reference the custom workflow name (registered via options) instead of the function pointer when calling ContinueAsNew.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by clarifying that function name is used as the default workflow name and can be overridden via options. Related issue #672 opened to allow disabling function name as an alias.",
      "related": [
        672
      ],
      "keyQuote": "This code should panic if a name is reused unless `DisableAlreadyRegisteredCheck` is explicitly set to true in the options.",
      "number": 197,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:05.652Z"
    },
    {
      "summary": "Request to support graceful cleanup logic execution within sessions during workflow cancellation, currently requiring ugly workarounds. Users need better control over session lifecycle to handle cleanup when workflows are cancelled.",
      "category": "feature",
      "subcategory": "session-management",
      "apis": [
        "NewDisconnectedContext"
      ],
      "components": [
        "session-manager",
        "workflow-cancellation",
        "context"
      ],
      "concepts": [
        "cleanup",
        "cancellation",
        "session-lifecycle",
        "graceful-shutdown",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot execute cleanup logic cleanly when workflows are cancelled, forcing them to implement workarounds to properly close session resources.",
      "rootCause": null,
      "proposedFix": "Add an option like 'keep session info' when using NewDisconnectedContext, or export session queue to allow manual management.",
      "workaround": "Implement ugly workarounds outside the session framework (specific workarounds not detailed in issue).",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        193
      ],
      "keyQuote": "Cancellation of a workflow should allow executing some cleanup logic in a session without ugly workarounds.",
      "number": 194,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:16:06.311Z"
    },
    {
      "summary": "Request to support generic workflow and activity implementations that can handle multiple types dynamically. This would enable frameworks built on top of the Go SDK (like the proposed PHP SDK) to load and unload implementations at runtime without restarting the worker.",
      "category": "feature",
      "subcategory": "worker-registration",
      "apis": [
        "RegisterWorkflow",
        "RegisterActivity"
      ],
      "components": [
        "worker",
        "registry",
        "workflow-handler",
        "activity-handler"
      ],
      "concepts": [
        "dynamic-loading",
        "generic-handler",
        "runtime-registration",
        "type-dispatch",
        "framework-integration"
      ],
      "severity": "medium",
      "userImpact": "Framework developers can dynamically load workflow and activity implementations at runtime without worker restarts, enabling remote artifact storage and hot-reloading scenarios.",
      "rootCause": null,
      "proposedFix": "Provide a generic workflow/activity implementation handler that receives the workflow or activity type as an argument, allowing dynamic dispatch to appropriate implementations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Generic workflow and activity registration support was implemented in the SDK, allowing handlers to receive type information for dynamic dispatch.",
      "related": [],
      "keyQuote": "A generic workflow implementation handler that receives the workflow type (or activity type) as an argument.",
      "number": 191,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:50.037Z"
    },
    {
      "summary": "Context propagation is broken in the test suite. The code path that extracts headers from context passed to testWorkflowEnvironment.Execute is missing, preventing context propagators from working correctly during unit tests.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Execute"
      ],
      "components": [
        "testsuite",
        "context-propagation",
        "test-environment"
      ],
      "concepts": [
        "context-propagation",
        "headers",
        "unit-testing",
        "workflow-execution",
        "test-isolation"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot properly test context propagation in their workflows, limiting the ability to validate custom context propagators during unit testing.",
      "rootCause": "The testWorkflowEnvironment.Execute code path does not extract headers from context, unlike the production code path.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #29, which addresses the same context propagation problem in the test suite.",
      "related": [
        29
      ],
      "keyQuote": "The code path that extracts headers from context passed to testWorkflowEnvironment.Execute is not present in the testsuite code.",
      "number": 190,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:52.147Z"
    },
    {
      "summary": "Worker reports a 'premature end of stream' validation error when processing a transient decision that is scheduled after a decision failure. The error indicates a mismatch between expected and actual event IDs in the workflow history.",
      "category": "bug",
      "subcategory": "history-processing",
      "apis": [],
      "components": [
        "worker",
        "history-processor",
        "decision-handler"
      ],
      "concepts": [
        "transient-decision",
        "history-events",
        "decision-failure",
        "event-stream",
        "validation"
      ],
      "severity": "high",
      "userImpact": "Workflow executions fail with validation errors when transient decisions follow failed decisions, preventing normal workflow progression.",
      "rootCause": "Mismatch in event ID tracking when processing transient decisions after decision failures, causing the history processor to expect an event ID that doesn't exist in the stream",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "history_events: premature end of stream, expectedLastEventID=55 but no more events after eventID=53",
      "number": 186,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:53.175Z"
    },
    {
      "summary": "Worker fails to connect to Temporal server with unclear namespace error messages. The feature request asks for better error handling that checks the connection before starting the worker and provides a clear, user-friendly error message like 'Unable to connect to Temporal server at localhost:7233'.",
      "category": "feature",
      "subcategory": "connection-error-handling",
      "apis": [],
      "components": [
        "worker",
        "client-connection",
        "error-handling"
      ],
      "concepts": [
        "connection",
        "error-messaging",
        "server-connectivity",
        "worker-startup",
        "debugging",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users receive confusing namespace errors when unable to connect to the server, making it difficult to diagnose connection problems.",
      "rootCause": "Worker attempts to connect and reports namespace-related errors instead of detecting and reporting the actual connection failure.",
      "proposedFix": "Check connection before starting worker and log a clear error message indicating the connection failure and server address.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by pull request #214 which implemented improved connection error handling.",
      "related": [
        214
      ],
      "keyQuote": "Check connection before starting worker and log clear error message such as \"Unable connect to Temporal server at localhost:7233\"",
      "number": 183,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:37.492Z"
    },
    {
      "summary": "Feature request to add support for clean worker shutdown that waits for activity sessions to complete, not just individual activities. Currently worker.Close() waits for running activities, but users need to wait for entire sessions that execute multiple activities.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Close"
      ],
      "components": [
        "worker",
        "session-management",
        "activity-executor"
      ],
      "concepts": [
        "graceful-shutdown",
        "session-completion",
        "worker-lifecycle",
        "activity-coordination"
      ],
      "severity": "medium",
      "userImpact": "Users cannot gracefully shut down workers while ensuring all activities within a session complete, forcing them to implement custom shutdown logic.",
      "rootCause": null,
      "proposedFix": "Add capability to wait for activity session completion when calling worker.Close()",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The clean worker shutdown waits for all currently running activities to complete. But in some cases, there is a need to wait for the whole session, which executes multiple activities to completion.",
      "number": 181,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:35.678Z"
    },
    {
      "summary": "Request to accept a Logger interface instead of requiring *zap.Logger in ClientOptions, allowing users to provide custom logging implementations without forcing zap as a dependency.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [
        "ClientOptions"
      ],
      "components": [
        "client",
        "logger-interface",
        "structured-logging"
      ],
      "concepts": [
        "logging-abstraction",
        "dependency-injection",
        "interface-design",
        "structured-fields",
        "logger-adapter"
      ],
      "severity": "low",
      "userImpact": "Users are forced to use zap.Logger and cannot integrate their own logging libraries with the temporal-go-sdk client.",
      "rootCause": "SDK currently accepts *zap.Logger directly in ClientOptions and uses zap-specific structured logging fields throughout the codebase.",
      "proposedFix": "Define a Logger interface and accept it in ClientOptions instead of *zap.Logger, abstracting away the zap dependency.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The SDK was updated to accept a Logger interface instead of *zap.Logger, allowing users to provide custom logging implementations.",
      "related": [],
      "keyQuote": "I'd like to pass in a custom Logger instance when instantiating a temporal client. Expecting a `*zap.Logger` instance forces consumers to use zap.",
      "number": 178,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:35.344Z"
    },
    {
      "summary": "NewNonRetryableApplicationError is not being respected and activities are still retried despite the flag. The issue occurs when an error (cause) is passed to the constructor, but works correctly when nil is passed.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [
        "NewNonRetryableApplicationError"
      ],
      "components": [
        "error-handler",
        "activity-executor",
        "retry-logic"
      ],
      "concepts": [
        "retry-policy",
        "non-retryable-errors",
        "activity-execution",
        "error-propagation",
        "retry-behavior"
      ],
      "severity": "high",
      "userImpact": "Activities that should never retry are being retried unexpectedly, causing incorrect application behavior and unexpected delays.",
      "rootCause": "The presence of an error (cause) parameter in NewNonRetryableApplicationError prevents the non-retryable flag from being respected by the retry mechanism.",
      "proposedFix": null,
      "workaround": "Pass nil as the error parameter when creating NewNonRetryableApplicationError: NewNonRetryableApplicationError(\"msg\", nil, \"details\")",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "After much investigation it seems adding an `error` (cause) to `NewNonRetryableApplicationError` - is what is causing the issue",
      "number": 175,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:19.861Z"
    },
    {
      "summary": "Activities timeout incorrectly in test environments when called from child workflows, returning StartToClose timeout errors even though sufficient timeout is configured. The issue occurs when ScheduleToCloseTimeout is uninitialized while ScheduleToStartTimeout and StartToCloseTimeout are set.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "GetWorkflowError"
      ],
      "components": [
        "test-workflow-environment",
        "activity-executor",
        "child-workflow"
      ],
      "concepts": [
        "timeout",
        "activity-scheduling",
        "test-environment",
        "workflow-nesting",
        "deadline-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test workflows that call activities from child workflows in test environments without encountering spurious timeout errors.",
      "rootCause": "Uninitialized ScheduleToCloseTimeout combined with parent-child workflow execution in test environment causes incorrect deadline propagation to activities.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "GetWorkflowError() returns an error: TimeoutType: StartToClose, Cause: context deadline exceeded",
      "number": 167,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:21.147Z"
    },
    {
      "summary": "mocks.Client doesn't implement the client.Client interface, making it unsuitable for mocking the client in tests.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "mocks",
        "client-interface"
      ],
      "concepts": [
        "mocking",
        "testing",
        "interface-compliance",
        "test-doubles"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use mocks.Client to mock client.Client in their tests, forcing them to work around the broken mock implementation.",
      "rootCause": "mocks.Client implementation doesn't satisfy the client.Client interface contract",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The mocks.Client was updated to properly implement the client.Client interface",
      "related": [],
      "keyQuote": "mocks.Client doesn't implement client.Client interface.",
      "number": 164,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:18.128Z"
    },
    {
      "summary": "Namespace registration fails with 'unknown service' error when using mismatched versions of Go SDK libraries and temporal-proto, or when unable to connect to the Temporal frontend service.",
      "category": "bug",
      "subcategory": "client-setup",
      "apis": [
        "Register",
        "NewNamespaceClient"
      ],
      "components": [
        "namespace-client",
        "service-discovery",
        "version-compatibility"
      ],
      "concepts": [
        "version-mismatch",
        "connection-error",
        "service-registration",
        "dependency-management",
        "client-initialization"
      ],
      "severity": "high",
      "userImpact": "Users cannot register namespaces or create workflows when library versions are mismatched or the frontend service is unreachable, blocking basic workflow setup.",
      "rootCause": "Version mismatch between go.temporal.io/temporal and go.temporal.io/temporal-proto libraries, or inability to connect to the Temporal frontend service due to incorrect host/port configuration.",
      "proposedFix": "Ensure all Go SDK libraries (temporal, temporal-proto) match versions. Verify that the client can connect to the Temporal frontend service at the configured host and port.",
      "workaround": "Downgrade Go SDK libraries to match the Temporal server version (e.g., use 0.23.1 when server is 0.23.1), or use matching docker image tags.",
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved through version alignment - users confirmed that matching Go SDK versions with server versions or using consistent docker image tags resolved the problem.",
      "related": [],
      "keyQuote": "If you downgrade your go libraries to match the docker images (0.23.1) it worked as expected for me.",
      "number": 163,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:03.597Z"
    },
    {
      "summary": "Race condition in Register*WithOptions functions due to unprotected map reads. The issue parallels a similar bug in the parent Cadence project where concurrent access to a map without synchronization causes data races.",
      "category": "bug",
      "subcategory": "worker-registration",
      "apis": [],
      "components": [
        "worker",
        "registration",
        "map-synchronization"
      ],
      "concepts": [
        "race-condition",
        "concurrency",
        "data-race",
        "map-access",
        "synchronization"
      ],
      "severity": "high",
      "userImpact": "Concurrent calls to Register*WithOptions functions could cause crashes or undefined behavior due to unsynchronized map access.",
      "rootCause": "Map read operations were not protected by synchronization primitives (mutex or similar), allowing concurrent access",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Map access is now properly protected by a map synchronization mechanism",
      "related": [
        979
      ],
      "keyQuote": "Issue is stale - map access is properly protected by a map now.",
      "number": 149,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:03.811Z"
    },
    {
      "summary": "Request to support returning WorkflowExecutionAlreadyStartedError in tests. The issue references a Cadence client PR and was resolved by a specific commit that addressed this test functionality.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-utilities",
        "workflow-execution",
        "error-handling"
      ],
      "concepts": [
        "testing",
        "error-simulation",
        "workflow-execution",
        "duplicate-detection",
        "test-support"
      ],
      "severity": "low",
      "userImpact": "Developers can now test error handling for duplicate workflow execution attempts in their test suites.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by commit e204e07feb1328c2828fa4bbebd0cf92ebe2c8f1 which implemented support for returning WorkflowExecutionAlreadyStartedError in tests.",
      "related": [],
      "keyQuote": "closing since looks like this was resolved https://github.com/temporalio/sdk-go/commit/e204e07feb1328c2828fa4bbebd0cf92ebe2c8f1",
      "number": 139,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:15:05.792Z"
    },
    {
      "summary": "Support for specifying a custom activity ID during activity invocation to enable asynchronous activity completion by ID. Discussion revealed this feature may already be implemented via ExecuteActivityOptions.ActivityID.",
      "category": "feature",
      "subcategory": "activity-invocation",
      "apis": [
        "ExecuteActivity",
        "CompleteActivityById",
        "Activity.getActivityTask"
      ],
      "components": [
        "activity-executor",
        "workflow-execution",
        "activity-options"
      ],
      "concepts": [
        "activity-id",
        "asynchronous-completion",
        "task-token",
        "idempotency",
        "activity-management"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to specify custom activity IDs to complete activities asynchronously and enable idempotent activity retries.",
      "rootCause": null,
      "proposedFix": "Use ExecuteActivityOptions.ActivityID field to allow users to specify custom activity IDs during invocation",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was already implemented in the Go SDK via ExecuteActivityOptions.ActivityID field, as confirmed by code reference to internal_activity.go",
      "related": [
        86
      ],
      "keyQuote": "Users can choose IDs but our framework makes it optional to decrease the crust. (ExecuteActivityOptions)",
      "number": 129,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:49.737Z"
    },
    {
      "summary": "ContextPropagator is not invoked for ExecuteLocalActivity, only for ExecuteActivity. This prevents proper context propagation in local activity execution.",
      "category": "bug",
      "subcategory": "context-propagation",
      "apis": [
        "ExecuteActivity",
        "ExecuteLocalActivity"
      ],
      "components": [
        "activity-executor",
        "context-propagator"
      ],
      "concepts": [
        "context-propagation",
        "local-activities",
        "execution-context",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot rely on context propagation for local activities, limiting their ability to maintain consistent context across activity types.",
      "rootCause": "ContextPropagator invocation logic was missing for the ExecuteLocalActivity code path.",
      "proposedFix": "Add ContextPropagator invocation to ExecuteLocalActivity similar to how it's implemented in ExecuteActivity.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in Cadence and cherry-picked into the Go SDK via commit ccea6a6fb6d5f219e0c1abf5b5573bbc3cce4072",
      "related": [],
      "keyQuote": "ContextPropagator is invoked only inside ExecuteActivity and not ExecuteLocalActivity",
      "number": 127,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:46.420Z"
    },
    {
      "summary": "Request to add automatic heartbeating for long-running activities to detect worker liveness without requiring manual heartbeat implementation. Feature was previously available in Cadence and would simplify activity implementation.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "Activity.RecordHeartbeat"
      ],
      "components": [
        "activity-executor",
        "worker",
        "client"
      ],
      "concepts": [
        "heartbeat",
        "liveness-detection",
        "worker-health",
        "long-running-activities",
        "timeout",
        "activity-management"
      ],
      "severity": "medium",
      "userImpact": "Users implementing long-running activities must manually implement heartbeating logic just to signal worker liveness, increasing code complexity.",
      "rootCause": null,
      "proposedFix": "Add built-in autoheartbeating mechanism similar to Cadence's implementation (referenced PRs #1053 and #1088)",
      "workaround": "Implement manual heartbeating in activities or use a simple utility function as described in community forum discussion",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "it would be very nice to not have to implement heartbeating in long-running activities where the ~only reason to implement heartbeating is to know whether a worker is alive or not",
      "number": 126,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:48.460Z"
    },
    {
      "summary": "Activity mocking in tests currently requires registering a dummy activity implementation beforehand, which is unintuitive and cumbersome. The user requests removal of this requirement for a better testing experience.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "RegisterWithOptions",
        "OnActivity"
      ],
      "components": [
        "activity-registration",
        "test-mocking",
        "activity-executor"
      ],
      "concepts": [
        "mocking",
        "testing",
        "activity-registration",
        "test-setup",
        "test-framework",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers must write boilerplate dummy activity registrations when mocking activities in tests, reducing code clarity and increasing test complexity.",
      "rootCause": "Current design requires activities to be registered before mocking, likely due to internal activity lookup and registration mechanisms.",
      "proposedFix": null,
      "workaround": "Register a dummy activity with an empty implementation in SetupSuite before mocking with OnActivity.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I find it quite odd/hard to use in cadence that I have to register an activity before mocking it with On Activity.",
      "number": 125,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:33.741Z"
    },
    {
      "summary": "Activity error information is lost when ScheduleToCloseTimeout expires during retries. Currently, the system returns a generic ScheduleToClose timeout error instead of preserving the original activity error, making it difficult for developers to understand what actually failed.",
      "category": "bug",
      "subcategory": "activity-retry",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "retry-handler",
        "timeout-manager",
        "error-handling"
      ],
      "concepts": [
        "timeout",
        "retry",
        "error-handling",
        "activity-lifecycle",
        "error-information",
        "ScheduleToCloseTimeout"
      ],
      "severity": "high",
      "userImpact": "Users cannot determine the root cause of activity failures when retries are exhausted by timeout, as the original error is discarded.",
      "rootCause": "The timeout exit condition does not propagate or preserve the original activity error when ScheduleToCloseTimeout is exceeded during retries.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was addressed to ensure activity errors are preserved and returned even when ScheduleToCloseTimeout is exceeded during retries.",
      "related": [
        119
      ],
      "keyQuote": "Currently only 1st case will return actual activity error but 2nd will return TimeoutType: ScheduleToClose error w/o information about original error.",
      "number": 120,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:31.244Z"
    },
    {
      "summary": "Child workflows incorrectly inherit the parent's WorkflowRunTimeout instead of defaulting to their own WorkflowExecutionTimeout. This causes child workflows to have unexpectedly short run timeouts even when explicitly configured with longer execution timeouts.",
      "category": "bug",
      "subcategory": "child-workflow-timeout",
      "apis": [
        "ChildWorkflowOptions",
        "StartWorkflowOptions"
      ],
      "components": [
        "child-workflow",
        "timeout-management",
        "workflow-options"
      ],
      "concepts": [
        "timeout",
        "inheritance",
        "child-workflow",
        "execution-timeout",
        "run-timeout",
        "default-values"
      ],
      "severity": "high",
      "userImpact": "Child workflows experience premature timeouts inherited from parent workflows, causing unexpected task failures despite explicit timeout configuration.",
      "rootCause": "Child workflow timeout logic incorrectly inherits WorkflowRunTimeout from parent execution instead of defaulting based on the child's own WorkflowExecutionTimeout configuration.",
      "proposedFix": "Default child workflow WorkflowRunTimeout to match the child's WorkflowExecutionTimeout rather than inheriting from parent.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Ported to server-side issue temporalio/temporal#565 for resolution.",
      "related": [
        565
      ],
      "keyQuote": "Defaulting child to the execution timeout that was specified by the parent makes more sense.",
      "number": 118,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:32.918Z"
    },
    {
      "summary": "Selector incorrectly loops forever when a closed channel is received instead of matching it once like it does for Futures. The AddReceive handler should only fire once when a channel is closed, not continuously.",
      "category": "bug",
      "subcategory": "workflow-selector",
      "apis": [
        "AddReceive",
        "Select"
      ],
      "components": [
        "selector",
        "workflow-execution",
        "channel-handling"
      ],
      "concepts": [
        "blocking",
        "channel-closure",
        "event-matching",
        "control-flow"
      ],
      "severity": "high",
      "userImpact": "Workflows using selectors with closed channels hang indefinitely instead of progressing, blocking workflow execution.",
      "rootCause": "Selector does not properly match closed channels once like it does for Futures, causing infinite loop behavior when a Done() channel closes.",
      "proposedFix": "Match closed channels only once in the selector, applying the same logic used for Future resolution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Selector behavior was corrected during stabilization phase to properly handle closed channels as single-match events.",
      "related": [],
      "keyQuote": "We should match it only once the same way it is done for a `Future`.",
      "number": 116,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:18.999Z"
    },
    {
      "summary": "Race condition exists in testWorkflowEnvironmentImpl that is currently bypassed by a workaround. The issue needs to be properly fixed rather than worked around.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "testWorkflowEnvironmentImpl",
        "testsuite"
      ],
      "concepts": [
        "race-condition",
        "concurrency",
        "testing",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "Test suite may have unpredictable behavior due to race conditions, affecting reliability of workflow testing.",
      "rootCause": "Race condition in testWorkflowEnvironmentImpl implementation",
      "proposedFix": null,
      "workaround": "Currently bypassed by workaround in internal_workflow_testsuite_test.go",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently it bypassed by workaround: https://github.com/temporalio/temporal-go-sdk/blob/master/internal/internal_workflow_testsuite_test.go#L1751 but it must be properly fixed.",
      "number": 108,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:16.192Z"
    },
    {
      "summary": "A panic occurs in serviceerror.FromStatus when converting a gRPC status with a NotFound detail that the service doesn't properly include. The interface conversion fails because it tries to cast a nil value to *failure.NotFound.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [
        "StartWorkflowExecution"
      ],
      "components": [
        "serviceerror",
        "grpc-dialer",
        "error-interceptor"
      ],
      "concepts": [
        "error-conversion",
        "interface-conversion",
        "panic",
        "null-safety",
        "protobuf-details"
      ],
      "severity": "high",
      "userImpact": "Users experience immediate application crashes when the SDK encounters certain gRPC responses from the server.",
      "rootCause": "The serviceerror.FromStatus function attempts to convert a nil NotFound detail to *failure.NotFound without null checking, causing a panic during interface conversion.",
      "proposedFix": null,
      "workaround": "Roll back temporal-proto dependency to version 0.20.21",
      "resolution": "fixed",
      "resolutionDetails": "Fixed upstream in temporal-proto-go by commit fd32111876d6ed73c2771107460783b09fb36a6f",
      "related": [],
      "keyQuote": "panic: interface conversion: interface {} is nil, not *failure.NotFound",
      "number": 104,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:16.330Z"
    },
    {
      "summary": "Users cannot pass workflow Channels as parameters to child workflows and activities because Channel is not a value type. The proposal is to pass channel ID information to activities and use SignalWorkflow calls to communicate back to the workflow.",
      "category": "feature",
      "subcategory": "channel-parameters",
      "apis": [
        "ExecuteActivity",
        "NewChannel",
        "NewSelector",
        "SignalWorkflow"
      ],
      "components": [
        "activity-executor",
        "workflow-execution",
        "channel-system",
        "signaling"
      ],
      "concepts": [
        "channel-passing",
        "inter-process-communication",
        "value-types",
        "child-workflows",
        "activity-parameters",
        "signal-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot pass Channels as activity or child workflow parameters, limiting their ability to implement certain communication patterns in workflows.",
      "rootCause": "Channel is not a value type and cannot be serialized as a parameter.",
      "proposedFix": "Pass channel ID information to activities and use SignalWorkflow calls to send data back to the workflow, with the signal being pushed to the corresponding channel in the workflow.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Channel is currently not possible as Channel is not a value type.",
      "number": 101,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:59.304Z"
    },
    {
      "summary": "Remove the error return value from WorkflowClient.CloseConnection and rename it to Close, as the error is not useful in practice.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [
        "WorkflowClient.CloseConnection"
      ],
      "components": [
        "workflow-client",
        "connection-management"
      ],
      "concepts": [
        "api-design",
        "error-handling",
        "connection-lifecycle",
        "usability"
      ],
      "severity": "low",
      "userImpact": "Users will have a simpler, more idiomatic API for closing workflow client connections without unnecessary error handling.",
      "rootCause": null,
      "proposedFix": "Rename WorkflowClient.CloseConnection to Close and remove error return value",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by #131",
      "related": [
        131
      ],
      "keyQuote": "Rename WorkflowClient.CloseConnection to Close and remote error as it is not very useful anyway.",
      "number": 97,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:01.094Z"
    },
    {
      "summary": "The Go SDK's meta tag resolution doesn't work for subpackages like `go.temporal.io/temporal/worker`, only for the root package. The `go get` command requires proper `<meta>` tags for package discovery, which need to be provided at every package level.",
      "category": "bug",
      "subcategory": "go-get-meta-tags",
      "apis": [],
      "components": [
        "go-import",
        "meta-tags",
        "package-discovery"
      ],
      "concepts": [
        "package-resolution",
        "go-get",
        "meta-tags",
        "godoc",
        "import-path",
        "version-control"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use `go get` to import subpackages of the Go SDK, breaking standard Go dependency management.",
      "rootCause": "GitHub Pages only supports custom 404 pages at the root level, making it impossible to serve meta tags from subdirectory URLs without creating individual index.html files for each package.",
      "proposedFix": "Create directory structure for every package with index.html files that return the appropriate `<meta name=\"go-import\">` tags.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by implementing proper package-level directory structure with index.html files to serve go-import meta tags.",
      "related": [],
      "keyQuote": "we need to return `<meta>` tag not only on go module level but also on every package level",
      "number": 95,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:14:01.323Z"
    },
    {
      "summary": "Worker start/stop behavior should allow callers to handle signal listening separately. The issue requests a design more aligned with a worker actor pattern similar to appkit, where signal handling is decoupled from worker lifecycle management.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Worker"
      ],
      "components": [
        "worker",
        "signal-handling",
        "lifecycle-management"
      ],
      "concepts": [
        "signal-listening",
        "worker-startup",
        "worker-shutdown",
        "actor-pattern",
        "caller-responsibility",
        "decoupling"
      ],
      "severity": "low",
      "userImpact": "Users cannot independently manage signal listening and worker lifecycle, forcing them to accept the built-in signal handling behavior.",
      "rootCause": null,
      "proposedFix": "Decouple signal listening from worker start/stop, allowing callers to handle signals explicitly similar to an actor pattern (as shown in the referenced appkit PR).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by implementing worker lifecycle changes that allow callers to manage signal handling separately from worker start/stop operations.",
      "related": [
        642
      ],
      "keyQuote": "Listening to signals should be left to the caller.",
      "number": 94,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:44.113Z"
    },
    {
      "summary": "Build fails on freshly cloned repository due to errcheck tool finding an unclosed file handle in the copyright license generation tool.",
      "category": "bug",
      "subcategory": "build-tools",
      "apis": [],
      "components": [
        "build-system",
        "errcheck",
        "copyright-tool"
      ],
      "concepts": [
        "resource-cleanup",
        "file-handle",
        "build-failure",
        "linting",
        "error-checking"
      ],
      "severity": "high",
      "userImpact": "Users cannot build the SDK immediately after cloning the repository, blocking local development setup.",
      "rootCause": "Missing f.Close() error check in internal/cmd/tools/copyright/licensegen.go line 141 - errcheck tool detects unclosed file handle.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The unclosed file handle in the copyright license generation tool was fixed by properly closing the file.",
      "related": [],
      "keyQuote": "f.Close() (line 141 in licensegen.go) - errcheck detected unclosed resource causing build failure",
      "number": 91,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:41.414Z"
    },
    {
      "summary": "Current SDK uses type aliasing to separate internal and public APIs, which causes problems with Go tooling. The proposal is to create public copies of interfaces and structures with casting between internal and public versions.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [],
      "components": [
        "type-system",
        "public-api",
        "internal-api"
      ],
      "concepts": [
        "type-aliasing",
        "api-separation",
        "code-generation",
        "type-safety",
        "tooling-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users may experience issues with Go tooling and IDE support due to type aliasing in the SDK structure.",
      "rootCause": "Type aliasing approach used to separate internal and public APIs doesn't work well with Go tooling ecosystem",
      "proposedFix": "Create public copies of all interfaces and structures with explicit casting between internal and public versions",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        61
      ],
      "keyQuote": "The current generation of tools doesn't work well with type aliasing which is used to separate internal implementation and public APIs",
      "number": 89,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:45.289Z"
    },
    {
      "summary": "Customer requests a health check feature for WorkflowClient to verify connectivity to Temporal frontends without executing workflows. Currently, no error is returned until actual workflow operations are attempted.",
      "category": "feature",
      "subcategory": "client-initialization",
      "apis": [
        "NewClient",
        "WorkflowClient"
      ],
      "components": [
        "client",
        "connection",
        "frontend"
      ],
      "concepts": [
        "health-check",
        "connectivity-verification",
        "initialization",
        "error-handling",
        "grpc"
      ],
      "severity": "low",
      "userImpact": "Users cannot validate their Temporal client configuration early, forcing them to discover connection issues only when attempting workflow operations.",
      "rootCause": null,
      "proposedFix": "Add ability to call gRPC health check endpoint of the frontends from WorkflowClient.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support health check calls from WorkflowClient.",
      "related": [],
      "keyQuote": "does temporal client have something similar to Ping() ... would be nice to have something similar to SELECT 1 in postgres",
      "number": 86,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:30.302Z"
    },
    {
      "summary": "Request to suppress logging and metrics for activity errors that are handled gracefully by workflows. Users want to avoid noisy error logs for expected error scenarios that are subsequently handled via ContinueAsNewError or similar patterns.",
      "category": "feature",
      "subcategory": "logging-error-handling",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "logging",
        "metrics"
      ],
      "concepts": [
        "error-logging",
        "error-suppression",
        "graceful-handling",
        "metrics-recording",
        "interceptors",
        "application-errors"
      ],
      "severity": "medium",
      "userImpact": "Users cannot suppress noisy error logs and metrics for expected activity errors that are handled gracefully in workflow logic.",
      "rootCause": "All activity execution errors are logged at error level and recorded in metrics regardless of whether they are handled gracefully downstream.",
      "proposedFix": "Move logging into interceptors allowing customization, or provide a way to mark errors as benign (non-error category) to log at debug level and skip metrics recording.",
      "workaround": "Use interceptors to customize error logging behavior.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by adding ApplicationErrorOptions with Category field allowing ApplicationErrorCategoryBenign to log at debug level and skip metrics recording.",
      "related": [
        1925
      ],
      "keyQuote": "You will be able to use `temporal.NewApplicationErrorWithOptions` with `ApplicationErrorCategoryBenign` to have the error logged at debug level instead of error level",
      "number": 78,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:27.085Z"
    },
    {
      "summary": "Remove the WorkerOptions.Disable[Activity|Workflow]Worker option as it's no longer needed. Both activities and workflows are now registered directly with the worker, making this option redundant.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "worker-options",
        "activity-registration",
        "workflow-registration"
      ],
      "concepts": [
        "worker-configuration",
        "registration",
        "options-management",
        "api-cleanup",
        "simplification"
      ],
      "severity": "low",
      "userImpact": "Users will need to remove usage of these deprecated options when upgrading, simplifying worker configuration.",
      "rootCause": "Global registration was previously required, making the disable options necessary; this constraint no longer applies.",
      "proposedFix": "Remove WorkerOptions.DisableActivityWorker and WorkerOptions.DisableWorkflowWorker options from the codebase.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Options were removed as part of API cleanup since activities and workflows registration made them unnecessary.",
      "related": [],
      "keyQuote": "It was needed due to global registration. Now as both activities and workflows are registered with the worker this option is excessive.",
      "number": 77,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:27.916Z"
    },
    {
      "summary": "Test_WorkflowLocalActivityWithMockAndListeners test is flaky, occasionally failing with assertion errors about expected vs actual counts and listener state. The test passes reliably after a few restarts.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "local-activity",
        "mock",
        "listeners"
      ],
      "concepts": [
        "flaky-test",
        "race-condition",
        "test-isolation",
        "mock-behavior",
        "listener-state",
        "timing"
      ],
      "severity": "medium",
      "userImpact": "Developers working with the Go SDK test suite experience unreliable test results that pass inconsistently, hindering development velocity.",
      "rootCause": "Likely race condition or timing issue in test setup/teardown affecting mock and listener state initialization",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by issue #182",
      "related": [
        182
      ],
      "keyQuote": "After few restarts test usually pass.",
      "number": 75,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:09.618Z"
    },
    {
      "summary": "Request to add a linter for the Go SDK to check for common mistakes that violate SDK-imposed restrictions in workflow and activity implementations. Resolved by implementing the workflowchecker tool in contrib/tools.",
      "category": "feature",
      "subcategory": "linting",
      "apis": [],
      "components": [
        "workflow",
        "activity",
        "linter"
      ],
      "concepts": [
        "code-quality",
        "validation",
        "best-practices",
        "static-analysis",
        "restrictions"
      ],
      "severity": "medium",
      "userImpact": "Helps developers catch SDK implementation mistakes early through automated linting rather than discovering them at runtime.",
      "rootCause": null,
      "proposedFix": "Implement a linter based on the contributed cadencelint tool to validate workflow and activity code",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by implementing workflowchecker tool in contrib/tools/workflowcheck",
      "related": [],
      "keyQuote": "Closing since this is solved with the workflowchecker",
      "number": 72,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:13.749Z"
    },
    {
      "summary": "NewWorker has a downcast and panic that needs to be refactored and removed. Users cannot wrap the temporal client with custom implementations due to worker needing internal client details.",
      "category": "feature",
      "subcategory": "worker-initialization",
      "apis": [
        "NewWorker"
      ],
      "components": [
        "worker",
        "client",
        "interceptors"
      ],
      "concepts": [
        "client-wrapping",
        "internal-dependencies",
        "interceptors",
        "architecture"
      ],
      "severity": "medium",
      "userImpact": "Users cannot wrap the temporal client with their own implementations due to internal client dependencies in NewWorker.",
      "rootCause": "Worker requires access to internal client implementation details, preventing client wrapping and requiring explicit type checks with panic.",
      "proposedFix": "Refactor NewWorker to remove downcast and panic; support client interception through the interceptors proposal instead of allowing client wrapping.",
      "workaround": "Use client interceptors (via interceptors proposal) to achieve functionality instead of wrapping the client.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        69,
        45
      ],
      "keyQuote": "However, due to the worker still needing internal things from the client, it can't be wrapped, but all functionality should be available via interceptors.",
      "number": 70,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:13:11.745Z"
    },
    {
      "summary": "Remove the mocks package that uses mockery and replace it with gomocks, which is used everywhere else in the codebase. Customers can generate mocks themselves using the mockgen tool.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "mocks",
        "testing",
        "gomocks"
      ],
      "concepts": [
        "mock-generation",
        "test-utilities",
        "code-generation",
        "testing-framework",
        "dependency-cleanup"
      ],
      "severity": "low",
      "userImpact": "Removes bundled mocks package, requiring users to generate their own mocks using mockgen tool instead.",
      "rootCause": null,
      "proposedFix": "Replace mockery-based mocks package with gomocks, allowing customers to use mockgen tool directly.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        928,
        929
      ],
      "keyQuote": "mocks package uses mockery and we are using gomocks everywhere else. Mocks can be easily generated by customers using mockgen tool.",
      "number": 61,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:55.925Z"
    },
    {
      "summary": "Migrate service_wrapper_test to interceptor_test after service_wrapper was replaced with gRPC interceptor in #58. Tests need to be updated to reflect the architectural change.",
      "category": "other",
      "subcategory": "test-migration",
      "apis": [],
      "components": [
        "service-wrapper",
        "interceptor",
        "test-framework"
      ],
      "concepts": [
        "test-migration",
        "refactoring",
        "interceptor-pattern",
        "grpc",
        "architecture"
      ],
      "severity": "medium",
      "userImpact": "Ensures test coverage is maintained after architectural changes to the SDK's request handling mechanism.",
      "rootCause": "service_wrapper was replaced with gRPC interceptor, leaving tests referencing old implementation",
      "proposedFix": "Migrate service_wrapper_test to interceptor_test to align with new architecture",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tests were migrated from service_wrapper_test to interceptor_test following the architectural change",
      "related": [
        58
      ],
      "keyQuote": "service_wrapper was replaced with gRPC interceptor (#58) and tests needs to be migrated too.",
      "number": 60,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:58.898Z"
    },
    {
      "summary": "Add a workflow deadlock detector to the Go SDK, similar to the existing implementation in the Java SDK. This feature would help developers identify and prevent workflows from getting stuck due to deadlock conditions.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-engine",
        "deadlock-detection",
        "worker"
      ],
      "concepts": [
        "deadlock",
        "workflow-blocking",
        "detection",
        "monitoring",
        "debugging"
      ],
      "severity": "medium",
      "userImpact": "Developers using the Go SDK would be able to detect and debug workflow deadlock conditions, improving reliability and development experience.",
      "rootCause": null,
      "proposedFix": "Implement a deadlock detector similar to the Java SDK implementation (referenced in issue #28)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Deadlock detection was implemented in the Go SDK workflow engine",
      "related": [
        28
      ],
      "keyQuote": "Similar Java SDK issue: https://github.com/temporalio/temporal-java-client/issues/28",
      "number": 59,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:57.692Z"
    },
    {
      "summary": "Sticky cache is leaked when a worker stops, causing memory and goroutine leaks. The issue stems from using a global singleton cache that can't be properly cleaned up when multiple workers share it. The fix is to create a per-worker sticky cache and purge it completely on worker.Stop().",
      "category": "bug",
      "subcategory": "sticky-cache",
      "apis": [],
      "components": [
        "sticky-cache",
        "worker",
        "memory-management"
      ],
      "concepts": [
        "resource-leak",
        "cache-management",
        "worker-lifecycle",
        "goroutine-leak",
        "singleton-pattern"
      ],
      "severity": "high",
      "userImpact": "Users experience memory leaks and goroutine leaks when stopping workers due to sticky cache not being properly cleaned up.",
      "rootCause": "Sticky cache is implemented as a global singleton, making it impossible to clear entries belonging to a specific worker without affecting other workers.",
      "proposedFix": "Create a per-worker sticky cache instance and completely purge it when worker.Stop() is called.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #310 which implements per-worker sticky cache with proper cleanup.",
      "related": [
        310
      ],
      "keyQuote": "The right fix here is to create stickyCache per worker and purge it completely on worker.Stop()",
      "number": 51,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:41.716Z"
    },
    {
      "summary": "TestWorkflowEnvironment currently only supports testing multiple workflows in parent-child relationships. The feature request is to extend it to support testing independent workflows that are not parent-child related.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment"
      ],
      "components": [
        "test-framework",
        "workflow-environment",
        "testing-utilities"
      ],
      "concepts": [
        "testing",
        "workflow-isolation",
        "test-scenarios",
        "independent-workflows",
        "environment-setup"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily test multiple independent workflows together using TestWorkflowEnvironment, limiting test coverage for complex scenarios.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        616
      ],
      "keyQuote": "It would be good to be able to use TestWorkflowEnvironment to test 2 workflows that are not parent-child.",
      "number": 50,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:42.463Z"
    },
    {
      "summary": "ExecuteActivity context parameters are being ignored when SideEffect is called multiple times with different contexts. The activity receives an ID generated from the wrong context instead of the explicitly passed one.",
      "category": "bug",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity",
        "SideEffect",
        "WithActivityOptions"
      ],
      "components": [
        "workflow-context",
        "activity-executor",
        "side-effect"
      ],
      "concepts": [
        "context-handling",
        "activity-options",
        "idempotency",
        "context-isolation",
        "parameter-passing"
      ],
      "severity": "high",
      "userImpact": "Activities receive incorrect identifiers when multiple WithActivityOptions contexts are created with SideEffect calls, causing activities to be executed with wrong IDs.",
      "rootCause": "Context created by WithActivityOptions is not properly isolated when SideEffect is called multiple times, causing subsequent SideEffect calls to use the latest context rather than the one passed to ExecuteActivity.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bug in context isolation and parameter passing for ExecuteActivity was identified and resolved.",
      "related": [
        372
      ],
      "keyQuote": "RunPartProcessor activity ends up with an id that contains the word completeentity. So not sure if the problem is that I've called SideEffect twice in a row with different parameters.",
      "number": 49,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:45.190Z"
    },
    {
      "summary": "Simplify NewClient API signature to accept hostPort and domain directly instead of requiring callers to manually construct gRPC connections. The change hides complexity, allows mandatory interceptors and default load balancing configuration, and provides cleaner API ergonomics.",
      "category": "feature",
      "subcategory": "client-initialization",
      "apis": [
        "NewClient"
      ],
      "components": [
        "client",
        "grpc-connection",
        "options"
      ],
      "concepts": [
        "API-simplification",
        "gRPC-configuration",
        "interceptors",
        "load-balancing",
        "defaults",
        "extensibility"
      ],
      "severity": "medium",
      "userImpact": "Users currently need deep knowledge of gRPC internals to construct clients; this change enables simpler, more intuitive client initialization.",
      "rootCause": "Current NewClient signature requires manual gRPC connection setup and client instantiation, exposing implementation details and making it difficult to apply mandatory interceptors and default configurations.",
      "proposedFix": "Change NewClient to accept hostPort and domain directly, add GRPCOptions to Options struct, and internally merge passed options with mandatory defaults. Alternative approach: provide three separate constructor methods (NewClientLocal, NewClientByAddress, NewClientFromGRPC).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing simplified client initialization API that abstracts gRPC connection details and provides reasonable defaults.",
      "related": [],
      "keyQuote": "This is overwhelming and requires deep understanding of go-client internals.",
      "number": 39,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:28.371Z"
    },
    {
      "summary": "Workflow and activity type names currently include the full package path prefix (e.g., `go.temporal.io/temporal/internal.splitJoinActivityWorkflow`), which makes it difficult to move workflows between directories and requires manual string naming. The proposal is to remove the path prefix and use only the simple name (e.g., `splitJoinActivityWorkflow`).",
      "category": "feature",
      "subcategory": "naming-conventions",
      "apis": [],
      "components": [
        "workflow-registration",
        "activity-registration",
        "type-naming"
      ],
      "concepts": [
        "naming",
        "modularity",
        "code-organization",
        "refactoring",
        "portability"
      ],
      "severity": "medium",
      "userImpact": "Users currently struggle with moving workflows between directories due to hardcoded path-based type names, requiring manual string specifications.",
      "rootCause": null,
      "proposedFix": "Change workflow and activity type names to use only the simple function name without the package path prefix.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The path prefix was removed from type names and capitalization of the first letter was added.",
      "related": [],
      "keyQuote": "This make moving workflows between directories hard and forces specifying string name for every workflow.",
      "number": 38,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:28.800Z"
    },
    {
      "summary": "Add support for scheduling activities and child workflows across namespace boundaries in the Go SDK. Currently works on single clusters but breaks when cross-datacenter features are enabled.",
      "category": "feature",
      "subcategory": "cross-namespace-scheduling",
      "apis": [
        "ExecuteActivity",
        "StartChildWorkflow"
      ],
      "components": [
        "workflow-executor",
        "activity-scheduler",
        "child-workflow-handler"
      ],
      "concepts": [
        "cross-namespace",
        "multi-datacenter",
        "cross-cluster",
        "activity-routing",
        "workflow-scheduling"
      ],
      "severity": "high",
      "userImpact": "Users cannot schedule activities or child workflows across namespaces when using cross-datacenter deployments.",
      "rootCause": "Current implementation assumes single cluster/namespace context and lacks routing logic for cross-namespace targets.",
      "proposedFix": "Implement via Nexus integration as mentioned in resolution comment.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Addressed through Nexus, which provides cross-namespace and cross-cluster service invocation capabilities.",
      "related": [],
      "keyQuote": "This will be solved with Nexus",
      "number": 36,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:30.117Z"
    },
    {
      "summary": "Add ability to pass configuration to workflows safely without breaking determinism. Currently there's no clean way to share configuration with workflows that isn't passed as arguments or through unsafe context propagators.",
      "category": "feature",
      "subcategory": "workflow-configuration",
      "apis": [
        "GetConfiguration"
      ],
      "components": [
        "workflow",
        "worker-options",
        "context-propagator"
      ],
      "concepts": [
        "configuration",
        "determinism",
        "side-effect",
        "workflow-execution",
        "context-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users need a safe, determinism-preserving way to pass configuration to workflows without exposing implementation details to clients.",
      "rootCause": null,
      "proposedFix": "Add `configuration` field to WorkerOptions and provide `workflow.GetConfiguration()` method that uses SideEffect, MutableSideEffect, or local activity to preserve determinism.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add `configuration` field to WorkerOptions and return them to the workflow through workflow.GetConfiguration(&config)",
      "number": 35,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:14.939Z"
    },
    {
      "summary": "The testsuite requires headers to be injected directly into WorkflowTestSuite instead of using context propagators. A new setContext() method is needed to read headers from context using configured ContextPropagators, and context propagation to child workflows appears broken in the testsuite.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowTestSuite",
        "TestWorkflowEnvironment",
        "ContextPropagators"
      ],
      "components": [
        "testsuite",
        "context-propagation",
        "workflow-execution"
      ],
      "concepts": [
        "context-propagation",
        "headers",
        "child-workflows",
        "test-framework",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test context propagation in workflows using the testsuite, requiring manual header injection instead of standard context propagator mechanisms.",
      "rootCause": "TestWorkflowEnvironment does not support reading headers from context using configured ContextPropagators, and child workflow context propagation is broken in the testsuite.",
      "proposedFix": "Add TestWorkflowEnvironment.setContext(...) method which reads headers from context using configured ContextPropagators.",
      "workaround": "Inject headers directly into WorkflowTestSuite through WorkflowTestSuite#SetHeader.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I propose to add `TestWorkflowEnvironment.setContext(...)` method which reads header from the context using configured `ContextPropagators`.",
      "number": 29,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:14.785Z"
    },
    {
      "summary": "DataConverter.fromData should receive function results as pointers instead of by value for consistency with how arguments are deserialized.",
      "category": "bug",
      "subcategory": "data-serialization",
      "apis": [
        "DataConverter"
      ],
      "components": [
        "data-converter",
        "serialization"
      ],
      "concepts": [
        "consistency",
        "pointer-semantics",
        "deserialization",
        "data-conversion"
      ],
      "severity": "low",
      "userImpact": "Inconsistent API usage for DataConverter could confuse users and lead to subtle bugs in custom data converters.",
      "rootCause": "DataConverter.fromData receives function results by value while arguments are passed as pointers, creating inconsistent API behavior.",
      "proposedFix": "Pass function results as pointers to DataConverter.fromData to maintain consistency with argument deserialization.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through refactoring or external code merges.",
      "related": [],
      "keyQuote": "Currently when deserializing arguments they are passed as pointer. But when deserializing a function result it is passed by value into DataConverter.fromData.",
      "number": 2,
      "repo": "temporalio-sdk-go",
      "generatedAt": "2026-01-11T02:12:15.454Z"
    }
  ]
}