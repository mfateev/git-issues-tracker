# temporalio/sdk-go - Complete Issue Dump

**Generated:** 2026-01-09
**Total Issues:** 824
**Total Upvotes:** 237
**Total Comments:** 1451

## Table of Contents

- [Summary](#summary)
- [Top Labels](#top-labels)
- [Issue Index](#issue-index)
- [All Issues](#all-issues)

## Summary

| Metric | Value |
|--------|-------|
| Open Issues | 824 |
| Issues with Upvotes | 107 (13%) |
| Total Upvotes | 237 |
| Total Comments | 1451 |

## Top Labels

| Label | Count |
|-------|-------|
| enhancement | 370 |
| potential-bug | 275 |
| bug | 76 |
| external dependency | 20 |
| Mend: dependency security vulnerability | 9 |
| question | 4 |
| next-gen | 2 |

## Issue Index

| # | ðŸ‘ | ðŸ’¬ | Title |
|---|-----|-----|-------|
| [#916](#916) | 21 | 0 | Ability to mock/intercept side effect calls in test suite |
| [#181](#181) | 16 | 0 | Add ability for a clean worker shutdown that waits for a session completion. |
| [#543](#543) | 11 | 8 | Support dynamic activity and workflow implementations |
| [#832](#832) | 8 | 8 | temporal SDK not compatible with temporal API v1.9.0 |
| [#1326](#1326) | 7 | 3 | go get fails because sourcegraph.com/sourcegraph/appdash-data is no longer available |
| [#829](#829) | 6 | 5 | Use interceptor logger for all logs related to a workflow or activity execution |
| [#265](#265) | 8 | 1 | Add ActivityInterceptor |
| [#1385](#1385) | 2 | 12 | Extend workflowcheck tool to detect reads from (WorkflowExecution).RunId and suggest alternatives. |
| [#1190](#1190) | 0 | 16 | Temporal SDK crash  |
| [#78](#78) | 3 | 10 | Add ability to not log errors from activities |
| [#1282](#1282) | 5 | 5 | Heartbeat timeout not raised while testing |
| [#481](#481) | 0 | 15 | Canceling workflow can cause infinite replay attempts |
| [#89](#89) | 7 | 1 | Refactor SDK to avoid type aliasing |
| [#1537](#1537) | 0 | 14 | Unable to connect to cluster after updating to 1.27.0 |
| [#1352](#1352) | 4 | 6 | Serialization context for codecs and converters |
| [#1158](#1158) | 2 | 10 | Add slog logger implementation |
| [#658](#658) | 4 | 6 | gogo/protobuf is unmaintained |
| [#1382](#1382) | 4 | 5 | workflowcheck v0.1.0 fails with Go 1.22 |
| [#743](#743) | 2 | 8 | Concurrent map writes during deferred disconnected context cancellation |
| [#1573](#1573) | 0 | 11 | gRPC code "Unavailable" is being reported as "Unknown" by temporal SDK Client |
| [#1149](#1149) | 4 | 3 | Allow custom trace attribute keys |
| [#1018](#1018) | 1 | 9 | The memory usage from including the Temporal SDK is very large |
| [#960](#960) | 0 | 11 | Loggers use different stack depths when being called from workflow vs activity |
| [#929](#929) | 0 | 11 | Allow custom time source |
| [#887](#887) | 0 | 11 | TestSuite: Workflow names seemingly collide with activity names in mock expectations |
| [#774](#774) | 0 | 11 | Possible memory leak when loading a workflow with a query |
| [#1687](#1687) | 4 | 2 |  undefined: nexus.HandlerErrorTypeDownstreamTimeout error |
| [#1423](#1423) | 0 | 10 | contrib/datadog/v0.3.0 release |
| [#808](#808) | 1 | 8 | Add ReplayWorkflowHistoryFromReader (or similar) |
| [#529](#529) | 4 | 2 | Redesign interceptors to match the Java / Node.js capabilities |
| [#492](#492) | 0 | 10 | Cannot reuse Workflow ID immediately |
| [#313](#313) | 4 | 2 | Allow including local activity input into the history |
| [#1424](#1424) | 0 | 9 | Context deadline exceeded when using the context passed to the activity |
| [#1041](#1041) | 0 | 9 | Workflow got hanged if spawn childWorkflow with same workflowId |
| [#866](#866) | 4 | 1 | TestWorkflowEnvironment doesn't enforce WorkflowExecutionTimeout |
| [#723](#723) | 3 | 3 | Unable to reset workflow with completed childworkflow whose child workflowID is generated by SDK |
| [#722](#722) | 0 | 9 | CreateSession improperly retrying errors it should not |
| [#642](#642) | 1 | 7 | Inconsistent behavior when asserting invocations |
| [#636](#636) | 0 | 9 | Add WorkerOption to disable workflow worker |
| [#480](#480) | 0 | 9 | Activity result is not stored (and continued) when stopping worker gracefully |
| [#475](#475) | 0 | 9 | Panic when querying during Workflow failure + retry  |
| [#374](#374) | 4 | 1 | Workflow panic when querying a workflow using a side effect inside a versioned block |
| [#1330](#1330) | 0 | 8 | Add TaskQueue to TracerStartSpanOptions |
| [#1137](#1137) | 0 | 8 | Support OpenTelemetry Metrics |
| [#1114](#1114) | 1 | 6 | Support activity functions with variadic arguments   |
| [#1021](#1021) | 0 | 8 | Expose session state to users |
| [#978](#978) | 0 | 8 | Replay results inconsistent between Go versions |
| [#928](#928) | 0 | 8 | Delay in starting a scheduled workflow |
| [#814](#814) | 0 | 8 | workflowcheck not working |
| [#802](#802) | 3 | 2 | Logs are not added to OpenTracing Spans when tracing is enabled |
| [#236](#236) | 0 | 8 | panic: proto: duplicate extension registered |
| [#197](#197) | 2 | 4 | Go SDK does not handle two different workflows registered with same function name properly |
| [#1706](#1706) | 0 | 7 | ProcessWorkflowTask is not stopped on worker.Stop() |
| [#1672](#1672) | 1 | 5 | AssertNumberOfCalls on an Activity succeeds even if the Activity is not called the asserted number of times. |
| [#1651](#1651) | 0 | 7 | Running activities in separate processes  |
| [#1525](#1525) | 0 | 7 | Go SDK 1.26.0+ cannot deserialize `go.temporal.io/api` proto messages originally serialized as `gogoproto` messages    |
| [#1375](#1375) | 2 | 3 | Data race due to missing lock/unlock |
| [#1355](#1355) | 0 | 7 | support generic functions for activites |
| [#1084](#1084) | 0 | 7 | Bug with version go.temporal.io/api v1.19 |
| [#1043](#1043) | 0 | 7 | [question] Is there any way to get the task queue size (backlog)? |
| [#986](#986) | 1 | 5 | AwaitWithTimeout does not cancel its timer when condition is satisfied |
| [#983](#983) | 0 | 7 | Replaying non deterministic workflows that use local activities can give false negatives |
| [#957](#957) | 0 | 7 | ScheduleOptions.ID says optional, but runtime requires it |
| [#937](#937) | 0 | 7 | Add ability to keep session open in case of a worker restart. |
| [#884](#884) | 2 | 3 | [Feature Request] Add ability to support passing sessions from parent to child wf |
| [#825](#825) | 0 | 7 | attributes.GetNamespace undefined (type *command.ScheduleActivityTaskCommandAttributes has no field or method GetNamespace) (compile) |
| [#586](#586) | 0 | 7 | Activity mocking in test framework not able to do exact match of arguments |
| [#577](#577) | 0 | 7 | Distribute pollers to multiple frontend servers. |
| [#518](#518) | 0 | 7 | WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE will replace a running workflow |
| [#329](#329) | 0 | 7 | Potential deadlock detected: workflow goroutine "root" didn't yield for over a second |
| [#167](#167) | 2 | 3 | Activity times out in test environment with child workflow |
| [#129](#129) | 1 | 5 | Support passing activityId to an activity invocation  |
| [#1834](#1834) | 0 | 6 | SDK client connection Issue on localhost  |
| [#1808](#1808) | 0 | 6 | Configure extra log fields for SDK workflow and activity logs |
| [#1752](#1752) | 2 | 2 | unsuccessfulOperationErr.Failure undefined |
| [#1450](#1450) | 1 | 4 | Metric `workflow_task_execution_failed` is used with different sets of labels causing errors with Prometheus |
| [#1331](#1331) | 0 | 6 | Temporal Go SDK can not be used with bazel_gazelle 0.32+ |
| [#1310](#1310) | 1 | 4 | Unable to compile using v1.26.1 |
| [#1208](#1208) | 2 | 2 | Canceling a context with multiple child contexts can be non deterministic |
| [#1125](#1125) | 0 | 6 | ReceiveWithTimeout should cancel outstanding timers |
| [#1103](#1103) | 1 | 4 | workflow.UpsertSearchAttributes sdk function doesn't return error but fails the workflow task. |
| [#1049](#1049) | 0 | 6 | All workflow gorounies should never run after workflow method returns. |
| [#1042](#1042) | 1 | 4 | How can I test Temporal code that uses `activity.GetLogger(ctx)`? |
| [#1003](#1003) | 0 | 6 | Setting MaxConcurrentWorkflowTaskExecutionSize to 1 results in worker not executing any tasks |
| [#982](#982) | 1 | 4 | Cannot register mock activity with string name on test workflow environment |
| [#926](#926) | 0 | 6 | Unable to reproduce `workflow.ErrSessionFailed`, session gets recreated with same ID after process restarts |
| [#868](#868) | 0 | 6 | panic if `Run` and `Stop` race |
| [#858](#858) | 0 | 6 | Record Reason Code for RPC Failure |
| [#778](#778) | 0 | 6 | Potential issue with activity mocking and cancellation |
| [#736](#736) | 1 | 4 | Cannot use SignalWithStartWorkflow in tests |
| [#679](#679) | 2 | 2 | GetWorkflowError() does not yield stack trace for a panic |
| [#678](#678) | 0 | 6 | Worker panics while executing activity |
| [#570](#570) | 0 | 6 | Temporal Client send signal to different namespace |
| [#404](#404) | 2 | 2 | Setting deadlock detection timeouts? |
| [#284](#284) | 0 | 6 | Add the ability to register local activities only |
| [#2109](#2109) | 2 | 1 | MutableSideEffect in test framework ignores cmp function |
| [#1935](#1935) | 0 | 5 | client.Dial HostPort does not resolve Docker container DNS names |
| [#1805](#1805) | 0 | 5 | Current "latest" sdk-go incompatible with just-released api-go v1.44.0 |
| [#1691](#1691) | 0 | 5 | Auto propagate context value to activity |
| [#1351](#1351) | 1 | 3 | Support interceptor on WorkflowRun.Get |
| [#1207](#1207) | 1 | 3 | Handle interfaces in workflowcheck |
| [#1156](#1156) | 0 | 5 | Activity cancel error returned when not initiated server side is rejected by server |
| [#1048](#1048) | 0 | 5 | Channel.Receive consumes message before goroutine is woken up |
| [#1007](#1007) | 1 | 3 | Temporal breaks context error handling |
| [#942](#942) | 0 | 5 | SearchAttribute from DescribeWorkflowExecution return wrong type for Integer  |
| [#938](#938) | 0 | 5 | Multi-history replay support |
| [#828](#828) | 0 | 5 | Replay of Local Activities Executed by an Interceptor |
| [#821](#821) | 0 | 5 | Workflow executionsRow not found |
| [#803](#803) | 0 | 5 | MutableSideEffect doesn't seem to work |
| [#747](#747) | 0 | 5 | lookup failed for scheduledEventID to activityID since 1.13.1 |
| [#718](#718) | 2 | 1 | Add metric for time passed from the activity scheduling to the last attempt |
| [#659](#659) | 0 | 5 | Possibility to deprecate attribute `Control` |
| [#630](#630) | 0 | 5 | Concurrent ExecuteWorkflow will gen same RunId |
| [#614](#614) | 0 | 5 | Testing cron child workflow with parent policy abandon runs forever |
| [#596](#596) | 0 | 5 | Compression data converter |
| [#595](#595) | 1 | 3 | Expose health check on WorkflowClient |
| [#495](#495) | 0 | 5 | Calling `GetChildWorkflowExecution` for a mocked workflow in a test causes the runner to complete the child workflow. |
| [#433](#433) | 0 | 5 | Test environment `RegisterDelayedCallback()` with 0 duration which performs a query crashes |
| [#421](#421) | 1 | 3 | [Bug] 13 INTERNAL: Failed to parse server response when local activity has only error return parameter and returns nil |
| [#61](#61) | 2 | 1 | Remove mocks package |
| [#2065](#2065) | 1 | 2 | NewTestActivityEnvironment no longer implements worker.ActivityRegistry |
| [#2027](#2027) | 0 | 4 | Workflowcheck does not compile with go1.25.0 |
| [#1976](#1976) | 0 | 4 | ContinueAsNew should create new root span |
| [#1895](#1895) | 0 | 4 | Support simulating race conditions during signal draining |
| [#1840](#1840) | 0 | 4 | Activities with the same name from different struct methods are treated and handled as the same. |
| [#1716](#1716) | 0 | 4 | Make it possible to keep workflows in worker cache also if they're only queried |
| [#1701](#1701) | 0 | 4 | go.temporal.io/sdk/contrib/datadog to provide way to access DataDog spans from within a workflow |
| [#1689](#1689) | 0 | 4 | TestWorkflowEnvironment has non-standard RunID "default-test-run-id" |
| [#1643](#1643) | 0 | 4 | Ignore search attributes from GetVersion in mocks |
| [#1638](#1638) | 0 | 4 | Workflow Update in Test Environment should dedup updates by ID |
| [#1627](#1627) | 0 | 4 | workflowcheck built on 1.23 does not find any findings |
| [#1582](#1582) | 2 | 0 | Updated context functions to match context library |
| [#1570](#1570) | 0 | 4 | Suppor Temporal Cloud API Keys in Go SDK client |
| [#1554](#1554) | 0 | 4 | Unknown NonDeterministicError |
| [#1550](#1550) | 0 | 4 | After upgrading to 1.27.0 we get a context deadline exceeded |
| [#1410](#1410) | 2 | 0 | Consider migrating away from golang/mock |
| [#1397](#1397) | 1 | 2 | Add Support for `ReplayWorkflowHistoryOptions` to `ReplayWorkflowHistoryFromJSONFile` & `ReplayPartialWorkflowHistoryFromJSONFile` |
| [#1380](#1380) | 0 | 4 | The timeout is triggered twice earlier than ScheduleToCloseTimeout is set |
| [#1364](#1364) | 0 | 4 |  Move SDK Errors Out of Internal Package for Enhanced Usability |
| [#1339](#1339) | 0 | 4 | workflow.CreateSession create more sessions than MaxConcurrentSessionExecutionSize |
| [#1274](#1274) | 0 | 4 | schedule not working as expected |
| [#1229](#1229) | 0 | 4 | Workflowchecker - override the entry point for the linter |
| [#1174](#1174) | 1 | 2 | Allow ignoring invalid SpanContext in OpenTelemetry TracingInterceptor |
| [#1167](#1167) | 0 | 4 | Allow setting activity timeouts in TestActivityEnvironment |
| [#1138](#1138) | 0 | 4 | Auto instrument Activities if enabled |
| [#1100](#1100) | 1 | 2 | TestWorkflowEnvironment should surface errors and respect failure signal surfaced by underlying mock |
| [#1063](#1063) | 1 | 2 | workflowcheck is failing non-deterministic checks when code is wrapped with SideEffect |
| [#1016](#1016) | 1 | 2 | Provide a mechanism to version in a long running loop |
| [#984](#984) | 0 | 4 | No error will be thrown if WorkflowRunTimeout is reached |
| [#949](#949) | 1 | 2 | Allow user to override default maximum activity attempts in test suite |
| [#927](#927) | 1 | 2 | built-in query for waiting signals to go-sdk |
| [#805](#805) | 0 | 4 | testsuite support restarting workflow if returned `NewContinueAsNewError` |
| [#797](#797) | 0 | 4 | Access raw error message |
| [#732](#732) | 0 | 4 | lookup failed for scheduledEventID to activityID |
| [#703](#703) | 0 | 4 | Heartbeat timeout failure for async waiting activity |
| [#671](#671) | 0 | 4 | How to provide an Authorization Token in Golang |
| [#654](#654) | 0 | 4 | Mocked version of `ExecuteWorkflow` doesn't accept a custom Context |
| [#628](#628) | 1 | 2 | Workflow API to check if ContinueAsNew is required |
| [#618](#618) | 1 | 2 | Fix worker.New docs |
| [#594](#594) | 0 | 4 | Metric for determining task pool status |
| [#533](#533) | 0 | 4 | ContinueAsNew which transfers all unprocessed signals to new run |
| [#463](#463) | 0 | 4 | Retry Policy Loglevel |
| [#444](#444) | 0 | 4 | maxRPCTimeout value is too long |
| [#429](#429) | 0 | 4 | Activity RetryPolicy MaximumAttempts behaves differently in workflow unit test compared to executing same workflow against real temporal server |
| [#425](#425) | 1 | 2 | Workflow and activity with same name seems to confuse SDK |
| [#403](#403) | 0 | 4 | Can't use `errors.Is` to check a returned error |
| [#395](#395) | 0 | 4 | CancelWorkflow() should return EntityNotExistsError error if workflow does not exist |
| [#379](#379) | 0 | 4 | Registering activities by struct is weird in 1.5.0 |
| [#365](#365) | 0 | 4 | [Bug] Local Activities fail to deserialize at gRPC if return type is error |
| [#353](#353) | 1 | 2 | Allow the injection of additional grpc client interceptors |
| [#351](#351) | 2 | 0 | [Testing] Cancellation of Parent Workflow with Child Workflow Panics |
| [#328](#328) | 0 | 4 | Registering workflows by struct |
| [#239](#239) | 0 | 4 | Tracer property in WorkerOptions is missing |
| [#178](#178) | 1 | 2 | Accept a Logger interface instead of *zap.Logger |
| [#163](#163) | 0 | 4 | Namespace registration returns: unknown service |
| [#70](#70) | 1 | 2 | Refactor NewWorker and remove downcast |
| [#2103](#2103) | 0 | 3 | Cosmetic bug in logger |
| [#2097](#2097) | 0 | 3 | Feature Request: Add Context to MetricsHandler for Exemplar Support |
| [#2066](#2066) | 0 | 3 | Lost messages from workflow.NewChannel(ctx) |
| [#2049](#2049) | 0 | 3 | Support `fmt.Stringer` in `ExecuteActivity` |
| [#2046](#2046) | 1 | 1 | Make Deadlock Converter Configurable |
| [#2044](#2044) | 0 | 3 | AssertActivityCalled does not capture calls or/and argument being passed |
| [#1986](#1986) | 0 | 3 | SDK should warn when using structures to define a workflow |
| [#1961](#1961) | 0 | 3 | Getting a strange error when writing tests which does not occur in real temporal deployment |
| [#1942](#1942) | 0 | 3 | CLI supports redrive task queue and start workflow |
| [#1936](#1936) | 1 | 1 | `workflowcheck` invalidly assumes `reflect.New` is non-deterministic |
| [#1912](#1912) | 0 | 3 | activity Schedule To Close timeoutï¼ˆActivity complete after timeoutï¼‰ |
| [#1906](#1906) | 1 | 1 | workflowcheck crash (index out of range) |
| [#1890](#1890) | 0 | 3 | Context is mutated between interceptors and activity |
| [#1759](#1759) | 1 | 1 | Change activity error to warn, or allow it to be configurable  |
| [#1703](#1703) | 0 | 3 | fatal error: concurrent map writes when u |
| [#1681](#1681) | 0 | 3 | Update Godoc for `internal` structs/funcs to clarify the package they are exposed under |
| [#1670](#1670) | 0 | 3 | Erroneous extra replay command when replaying mid-workflow tasks |
| [#1609](#1609) | 1 | 1 | Support ContextAware for failure converters |
| [#1576](#1576) | 0 | 3 | Workflow-init support docs |
| [#1458](#1458) | 0 | 3 | Set Temporal-Namespace header on every namespace-specific gRPC request |
| [#1406](#1406) | 0 | 3 | Calls to worfklowService.GetSystemInfo are not included in the distrubuted trace. |
| [#1405](#1405) | 0 | 3 | PR 1404 breaks workflowcheck |
| [#1316](#1316) | 0 | 3 | Add support for GetUnhandledUpdateNames |
| [#1287](#1287) | 0 | 3 | Error "getState: illegal access from outside of workflow context" after sdk update  1.22.1 -> 1.25.1 |
| [#1280](#1280) | 0 | 3 | Requesting a way to expose workflow IDs from relevant worker request response protos |
| [#1279](#1279) | 0 | 3 | Requesting a way to expose Opentelemetry trace parent information from worker request response protos |
| [#1177](#1177) | 0 | 3 | Switch to a new clock library |
| [#1176](#1176) | 0 | 3 | [Bug] BadRequestCancelActivityAttributes invalid history builder state for action |
| [#1153](#1153) | 0 | 3 | type ScheduleWorkflowAction(ScheduleClient) is expecting Args field value as []interface{} rather than interface{} |
| [#1133](#1133) | 0 | 3 | Workflow deadlock when having a timer in the root scope and a timer in a coroutine |
| [#1044](#1044) | 0 | 3 | SDK updates not being properly run |
| [#1037](#1037) | 0 | 3 | Calling a value receiver method with a pointer type causes a panic when used through `ExecuteActivity` |
| [#1035](#1035) | 0 | 3 | Workflowcheck should check that serialized objects do not have unexported, non-json-ignored fields |
| [#1008](#1008) | 0 | 3 | Not able to execute activity which is on another service. |
| [#972](#972) | 0 | 3 | Programatic list API with intoHistories iterator |
| [#964](#964) | 0 | 3 | Export asyncFuture interface  |
| [#962](#962) | 0 | 3 | "workflowcheck" fails to detect argument type |
| [#955](#955) | 0 | 3 | Suppress "worker stopping" polling errors |
| [#945](#945) | 0 | 3 | golang.org/x/tools-v0.1.12: 3 vulnerabilities (highest severity is: 6.1) - autoclosed |
| [#897](#897) | 0 | 3 | golang.org/x/tools-v0.1.8: 4 vulnerabilities (highest severity is: 6.1) - autoclosed |
| [#875](#875) | 0 | 3 | Safer queries (and update validators) |
| [#874](#874) | 0 | 3 | Accept <- chan struct{} in Worker.Run |
| [#842](#842) | 0 | 3 | Support custom object processing in codec gRPC interceptor |
| [#815](#815) | 1 | 1 | Terminated workflow fails replay |
| [#813](#813) | 0 | 3 | Weird workflow task failure |
| [#764](#764) | 0 | 3 | Add built-ins for workflow.NewUUID() and workflow.NewRandom() |
| [#740](#740) | 0 | 3 | Execute local activity by string name fails during replay |
| [#737](#737) | 0 | 3 | Confirm that temporal_workflow_task_execution_failed is updated on data conversion failure |
| [#704](#704) | 0 | 3 | Add zap implementation of logger in contrib |
| [#697](#697) | 0 | 3 | Context aware data converter not getting context on local activity response |
| [#688](#688) | 1 | 1 | Support receiver-less method refs in OnActivity mocks |
| [#675](#675) | 0 | 3 | Specifying StartToCloseTimeout but no ScheduleToStartTimeout or ScheduleToCloseTimeout does not return an error |
| [#672](#672) | 0 | 3 | Allow disabling of function name aliasing during registration |
| [#644](#644) | 0 | 3 | Workflow panics after cancellation with clean up activity and child workflow |
| [#617](#617) | 0 | 3 | Better error message when calling activity with wrong number of parameters. |
| [#609](#609) | 0 | 3 | Test activities with same name on different queues (run from the same workflow) |
| [#604](#604) | 0 | 3 | WorkflowRun.Get method should support a flag to disable long poll |
| [#602](#602) | 0 | 3 | Support OpenTelemetry tracing |
| [#569](#569) | 0 | 3 | Dynamically adjusting MaxConcurrentActivityExecutionSize without restarting a worker |
| [#515](#515) | 0 | 3 | Add Signal/Query interceptors |
| [#488](#488) | 0 | 3 | data race in dispatcherImpl.ExecuteUntilAllBlocked |
| [#458](#458) | 1 | 1 | TestWorkflowEnvironment: Fail RegisterDelayedCallback after ExecuteWorkflow |
| [#456](#456) | 1 | 1 | How to return `[]*proto.Message` from an activity? |
| [#435](#435) | 0 | 3 | Workflow panic due to potential deadlock detected when many goroutines are running |
| [#432](#432) | 0 | 3 | JSON Serialization Errors From Activity Responses Fail Silently |
| [#424](#424) | 0 | 3 | Invocation of struct local activities is broken. |
| [#336](#336) | 1 | 1 | Don't Require mock.Anything For context.Context Activity Parameter |
| [#175](#175) | 1 | 1 | NewNonRetryableApplicationError not respected by  |
| [#164](#164) | 1 | 1 | mocks.Client is broken |
| [#126](#126) | 0 | 3 | Add autoheartbeating of activities |
| [#39](#39) | 0 | 3 | Change client.NewClient signature |
| [#2131](#2131) | 0 | 2 | Configurable minRPCTimeout for activity worker instead of using MaxHeartbeatThrottleInterval for RPC timeout. And allow retry manually when network error.. |
| [#2107](#2107) | 1 | 0 | Panic in temporal unit test framework. |
| [#2102](#2102) | 0 | 2 | Feature Request: WorkflowRun function to get input |
| [#2076](#2076) | 0 | 2 | SideEffects markers are very difficult to navigate in the timeline |
| [#2061](#2061) | 0 | 2 | add trace-id and span-id tags to sdk logs |
| [#2047](#2047) | 0 | 2 | Can the work queue be manually paused? |
| [#2003](#2003) | 0 | 2 | Feature request: more robust deployments with shutdownGraceTime |
| [#1985](#1985) | 0 | 2 | StartDevServer fails with Cloudflare `Error 1101` when downloading Temporal v1.27.2 |
| [#1980](#1980) | 0 | 2 | Feature Request: Include Version in workflowcheck -V=full Output |
| [#1954](#1954) | 1 | 0 | Ability to get original Logger from activity.GetLogger(ctx) / workflow.GetLogger(ctx) |
| [#1951](#1951) | 1 | 0 | UpdateWorkflow does not use context aware data converter |
| [#1932](#1932) | 0 | 2 | Provide a type-safe implementation of workflow.ExecuteActivity |
| [#1929](#1929) | 0 | 2 | OTel emitted metrics do not match behavior described in the docs |
| [#1916](#1916) | 0 | 2 | Can we have a option for local activity for not marking result to the history |
| [#1887](#1887) | 1 | 0 | enabling FIPS only mode with go 1.24.1 raises panic related to MD5 usage |
| [#1884](#1884) | 0 | 2 | Serialization context for codecs and converters |
| [#1882](#1882) | 0 | 2 | Caller skips is incorrectly calculated when a custom logger is provided to the SDK client |
| [#1857](#1857) | 1 | 0 | WorkflowIdReusePolicy document should mention WorkflowExecutionErrorWhenAlreadyStarted option |
| [#1856](#1856) | 1 | 0 | ExecuteWorkflow API document with return errors |
| [#1764](#1764) | 0 | 2 | Versioning override AutoUpgrade using a ref to an empty deployment struct instead of a nil pointer |
| [#1740](#1740) | 0 | 2 | Can we get a release of workflowcheck? â¤ï¸  |
| [#1728](#1728) | 0 | 2 | Simplify the update-wth-start API |
| [#1673](#1673) | 0 | 2 | Support user metadata on activities and child/scheduled workflows |
| [#1646](#1646) | 1 | 0 | SetStartTime for activity test env |
| [#1614](#1614) | 0 | 2 | For `go.temporal.io/api/proxy.VisitPayloadsOptions.Visitor`, parent not properly reset (and clarify docs) |
| [#1611](#1611) | 0 | 2 | GetSystemInfo - panic |
| [#1596](#1596) | 0 | 2 | Treat a 100 percent ramp in a versioning assignment rule as unramped |
| [#1594](#1594) | 0 | 2 | Workflow replay error: lookup failed for scheduledEventID to activityID |
| [#1593](#1593) | 0 | 2 | Consider potential range-over-func APIs |
| [#1549](#1549) | 0 | 2 | Customize buckets per metric |
| [#1535](#1535) | 0 | 2 | Temporal Opentelemetry interceptor to use (and export) new temporal header Carrier interface |
| [#1527](#1527) | 0 | 2 | Stop checking that context is cancelled when a `CanceledError` is received |
| [#1526](#1526) | 0 | 2 | Starting DevServer with UI Enabled May Fail Due to Invalid Port Number |
| [#1493](#1493) | 0 | 2 | Add a `RawValue` payload converter like exists in other SDKs |
| [#1492](#1492) | 0 | 2 | Make TraceID and SpanID logger keys configurable |
| [#1468](#1468) | 0 | 2 | Interceptors are skipped for mocked activities |
| [#1443](#1443) | 0 | 2 | Use of grpc-ecosystem/go-grpc-middleware/retry prevents dead code elimination |
| [#1420](#1420) | 0 | 2 | Support the new versioning API |
| [#1386](#1386) | 0 | 2 | Activity spans not nested under parent workflow |
| [#1372](#1372) | 0 | 2 | Document `Client.GetSearchAttributes` doesn't work in cloud |
| [#1324](#1324) | 0 | 2 | Concurrent map writes with ActivityTestEnvironment |
| [#1322](#1322) | 1 | 0 | Worker autotuning - Pollers |
| [#1304](#1304) | 0 | 2 | Add GetName() func to Signal Chanel to return human readable name |
| [#1275](#1275) | 0 | 2 | Inconsistent Activity Alias Mapping Behavior Across Multiple Task Queues |
| [#1273](#1273) | 0 | 2 | [Testsuite] Registering a Workflow and Activity with the same name and mocking  the activity causes issues |
| [#1270](#1270) | 0 | 2 | Clean up internal/context |
| [#1216](#1216) | 0 | 2 | Worker autotuning - PoC |
| [#1201](#1201) | 0 | 2 | RespondActivityTaskFailedRequest add result field |
| [#1160](#1160) | 1 | 0 | TestWorkflowEnvironment.XByID does not work with primary ID after primary ID updated |
| [#1145](#1145) | 0 | 2 | Err on setup: concurrent map read and map write |
| [#1144](#1144) | 1 | 0 | Non-determinism while replaying mutable side-effect behind workflow versioning  |
| [#1134](#1134) | 0 | 2 | OnSignalExternalWorkflow doesn't function when signaling child workflow |
| [#1130](#1130) | 0 | 2 | Proposal for Accessible `taskLimiter` for Worker Rate Modification |
| [#1086](#1086) | 0 | 2 | Add support for a graceful shutdown of go workers where all activities are finished before the worker returns |
| [#1065](#1065) | 0 | 2 | `workflowcheck` command `-V` (version) option does not work |
| [#1061](#1061) | 1 | 0 | Warn on calling an `ExecuteActivity` on a function that takes a `workflow.Context` |
| [#1052](#1052) | 0 | 2 | Fix getVersion search attribute bloat |
| [#1050](#1050) | 0 | 2 | Data race in eager activity handling |
| [#1033](#1033) | 0 | 2 | OnUpsertSearchAttributes and OnUpsertMemo unclear about mocking ability |
| [#1011](#1011) | 0 | 2 | WorkflowReplayer.ReplayWorkflowHistory doesn't return error when there is a de-serialization problem with the input |
| [#995](#995) | 0 | 2 | Do not auto-retry gRPC-message-size-too-large errors |
| [#969](#969) | 0 | 2 | Ability to dump stack of deadlocking coroutine |
| [#954](#954) | 0 | 2 | remove error from return since it always return nil |
| [#950](#950) | 0 | 2 | Eager activity execution should be limited to 3 per workflow task completion by default |
| [#933](#933) | 0 | 2 | No problem indicators on failed workflow input deserialization during queries |
| [#918](#918) | 0 | 2 | Define an external type for internal.WorflowClient |
| [#899](#899) | 0 | 2 | github.com/uber-go/tally/v4-v4.1.1: 2 vulnerabilities (highest severity is: 7.5) |
| [#865](#865) | 1 | 0 | Replayer uses different run ID than runtime after reset |
| [#855](#855) | 0 | 2 | Panic with double stop on worker |
| [#847](#847) | 0 | 2 | sdk 1.15.0 seems to be incompatible with go.temporal.io/api v1.9.0 |
| [#845](#845) | 1 | 0 | Activity function alias lookup is done even on different task queue |
| [#834](#834) | 0 | 2 | Can't check if a error is type ContinueAsNewError in Interceptor |
| [#833](#833) | 0 | 2 | Captures and reports panic/errors in an interceptor |
| [#816](#816) | 0 | 2 | Investigate how to unit test child workflows signalling a parent |
| [#804](#804) | 0 | 2 | How can i get span trace id from workflow context? |
| [#789](#789) | 1 | 0 | Allow getting workflow result to not follow runs |
| [#784](#784) | 1 | 0 | Task queue not recorded on temporal_worker_task_slots_available metric |
| [#769](#769) | 0 | 2 | Move some data conversion out of the deadlock detection scope |
| [#767](#767) | 0 | 2 | workflowcheck gets stuck forever when using templates in the workflow |
| [#754](#754) | 1 | 0 | gRPC Proxy Integration Test |
| [#709](#709) | 0 | 2 | Nested children in workflowcheck aren't showing the final leaf reason for non-determinism |
| [#687](#687) | 0 | 2 | `make test` fails |
| [#682](#682) | 0 | 2 | Failed to test a activity with logger |
| [#656](#656) | 1 | 0 | Heartbeat throttling interval should be configurable and default interval should be less than 10 minutes |
| [#638](#638) | 0 | 2 | Document about and warn when attempting to use activity cancellation/heartbeats without HeartbeatTimeout |
| [#624](#624) | 0 | 2 | unhandled panic from workflow code |
| [#616](#616) | 0 | 2 | Investigate options around latency reporting and comparison with server |
| [#607](#607) | 0 | 2 | Allow `EncodingDataConverter` to be context aware |
| [#603](#603) | 1 | 0 | Document/enforce `SignalWithStartWorkflow` does not use same workflow ID option as `ExecuteWorkflow` |
| [#601](#601) | 0 | 2 | Support workflow metadata query |
| [#600](#600) | 0 | 2 | Child workflow logger being output during replay |
| [#587](#587) | 0 | 2 | panic: runtime error: index out of range [1532] with length 1532 |
| [#573](#573) | 0 | 2 | `temporal_activity_endtoend_latency` is not useful as-is |
| [#563](#563) | 0 | 2 | missing default retry policy for local activity |
| [#560](#560) | 0 | 2 | Provide more customizable history output |
| [#546](#546) | 0 | 2 | TestActivityRetryOnHBTimeout is flaky |
| [#521](#521) | 0 | 2 | Heartbeat data is not successfully recorded when an activity reports failure |
| [#513](#513) | 0 | 2 | Use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` for non-deterministic workflow |
| [#500](#500) | 0 | 2 | [Bug?] Incorrect error `Call with too few input arguments` when activity uses the wrong context |
| [#497](#497) | 1 | 0 | [Test suite] Query after signal works in SDK, but not in Test Suite |
| [#442](#442) | 0 | 2 | Reported Metrics around availability include initial retry failures even if final call succeeds |
| [#439](#439) | 1 | 0 | Include a way to perform assertions on the workflow signal channel in the testing environment |
| [#431](#431) | 0 | 2 | ActivityEndToEndLatency Incorrectly Recorded |
| [#420](#420) | 0 | 2 | Get history size information in workflow |
| [#405](#405) | 0 | 2 | Struct pointer to Activities is nil when executed using ExecuteLocalActivity  |
| [#359](#359) | 0 | 2 | Add deterministic range over map helper |
| [#358](#358) | 0 | 2 | [Bug] the json input is invalid in the workflow history and with a wrong encoding for accents |
| [#352](#352) | 1 | 0 | ReplayLogger.With doesn't expand keyvals variadic function parameter |
| [#292](#292) | 0 | 2 | [doc] Should remove all activity.Register in document |
| [#280](#280) | 0 | 2 | Add a Registry/WorkerRegistry interface to the worker package |
| [#266](#266) | 1 | 0 | Expose activity start and completion information to the workflow code |
| [#228](#228) | 0 | 2 | Workflow hangs if we try to run two local activities in parallel |
| [#190](#190) | 0 | 2 | testsuite context propagation is broken |
| [#118](#118) | 0 | 2 | ChildWorkflow inherits WorkflowRunTimeout from parent |
| [#104](#104) | 0 | 2 | Panic in serviceerror.FromStatus |
| [#101](#101) | 1 | 0 | Add ability to pass Channel as a parameter to Child workflow and activity |
| [#97](#97) | 0 | 2 | Remove error from WorkflowClient.CloseConnection |
| [#95](#95) | 0 | 2 | Go SDK meta tag resolution not working properly |
| [#59](#59) | 1 | 0 | Add workflow deadlock detector |
| [#51](#51) | 0 | 2 | sticky cache: fix resource leaks on worker.Stop() |
| [#35](#35) | 1 | 0 | Add ability to pass configuration to a workflow |
| [#2141](#2141) | 0 | 1 | Activity Alias Collision in Test Environment When Using Anonymous Functions |
| [#2136](#2136) | 0 | 1 | Understanding the Worker Slots Gauge |
| [#2130](#2130) | 0 | 1 | `TEMPORAL_LOG_LEVEL` variable |
| [#2101](#2101) | 0 | 1 | Feature Request: WorkflowRun GetWithOptions() option to populate valuePtr for failed run |
| [#2098](#2098) | 0 | 1 | Update ChildWorkflowOptions comment to indicate the default WorkflowIDReusePolicy and WorkflowIdConflictPolicy |
| [#2084](#2084) | 0 | 1 | Add support for static summary for side effects and mutable side effects |
| [#2064](#2064) | 0 | 1 | Allow heartbeats after Activity cancellation |
| [#2058](#2058) | 0 | 1 | ResetWorkflow panic policy |
| [#2040](#2040) | 0 | 1 | Test environment does not deliver signals to mocked child workflow |
| [#2039](#2039) | 0 | 1 | Joining errors causes TestWorkflowEnvironment to hide panics and pass test |
| [#2021](#2021) | 0 | 1 | Graceful worker shutdown of sessions |
| [#2017](#2017) | 0 | 1 | Add first execution run ID to workflow info |
| [#2011](#2011) | 0 | 1 | `WorkerDeploymentVersion.BuildId` should be `...BuildID` (as everywhere else) |
| [#2010](#2010) | 0 | 1 | Setting a mock activity to Never isn't always enforced |
| [#2001](#2001) | 0 | 1 | Try synctest for time control |
| [#1993](#1993) | 0 | 1 | Do we have any temporal service health status metrics -This is just for information |
| [#1966](#1966) | 0 | 1 | better error messages when Error context deadline exceeded |
| [#1940](#1940) | 0 | 1 | Bug: remote dataconverter schedule decsribe |
| [#1928](#1928) | 0 | 1 | Race condition with Local Activities and worker shutdown |
| [#1926](#1926) | 0 | 1 | Warn when the server-provided task start time is fairly different than time SDK begins processing the task |
| [#1880](#1880) | 0 | 1 | Many internal `GetSystemInfo` requests use `defaultGetSystemInfoTimeout` even if `ConnectionOptions.GetSystemInfoTimeout` was passed |
| [#1865](#1865) | 0 | 1 | [api-go] Repeated Payload not being visited |
| [#1864](#1864) | 0 | 1 | [api-go] Support repeated Any fields |
| [#1862](#1862) | 0 | 1 | [api-go] Support direct Payload's and Payload`s at top-level of Any in payload visitor |
| [#1842](#1842) | 0 | 1 | Support "RawValue" non-converted values |
| [#1809](#1809) | 0 | 1 | [api-go] Add test for proxy to make sure all payloads are visited even if it's not reachable |
| [#1757](#1757) | 0 | 1 | `WithStartOperation` docs fix |
| [#1715](#1715) | 0 | 1 | Add VersioningOverride to StartWorkflowExecutionRequest |
| [#1714](#1714) | 0 | 1 | Add versioning fields to WorkflowExecutionInfo |
| [#1712](#1712) | 0 | 1 | Add support for the UpdateWorkflowExecutionOptions API |
| [#1705](#1705) | 0 | 1 | User-defined RequestId for SignalWorkflow |
| [#1624](#1624) | 0 | 1 | Signal sent to Selector can be lost if Default path blocks  |
| [#1602](#1602) | 0 | 1 | Update internal timers to use NewTimerWithOptions and a summary |
| [#1598](#1598) | 0 | 1 | Typed nil versioning ramp panics |
| [#1587](#1587) | 0 | 1 | Activity failure is not encrypted with the key set to the context propagator, used to encrypt workflow and activity payload |
| [#1586](#1586) | 0 | 1 | Allow passing explicit search attributes when continuing as new |
| [#1574](#1574) | 0 | 1 | Batched heartbeat got canceled due to caller context cancellation |
| [#1561](#1561) | 0 | 1 | Support Search Attributes in Schedules via Query Update |
| [#1551](#1551) | 0 | 1 | Typed search attributes issue with SignalWithStartWorkflow |
| [#1547](#1547) | 0 | 1 | Testing - child workflow update handler not registered in test |
| [#1521](#1521) | 0 | 1 | Workflow-friendly concurrency control |
| [#1501](#1501) | 0 | 1 | Expose UpdateID in an update handler |
| [#1499](#1499) | 0 | 1 | Warn or error when update handlers dangle across CAN or workflow exit |
| [#1497](#1497) | 0 | 1 | Ensure our proxy helpers forward metadata |
| [#1479](#1479) | 0 | 1 | Wrap GRPC::CANCELED and DEADLINE_EXCEEDED in an SDK Timeout exception for Update |
| [#1477](#1477) | 0 | 1 | temporal_worker_task_slots_available only reports workflow slots when using opentelemetry metrics handler |
| [#1474](#1474) | 0 | 1 | Tracing interceptor support for Nexus Operations |
| [#1471](#1471) | 0 | 1 | Support New Versioning in WorkflowInfo.GetCurrentBuildID() |
| [#1445](#1445) | 0 | 1 | OTel metric handler improvements |
| [#1441](#1441) | 0 | 1 | temporal_workflow_task_execution_failed not emitted on replay |
| [#1399](#1399) | 0 | 1 | Reset `WorkflowPanicPolicy` option |
| [#1395](#1395) | 0 | 1 | Make TestWorkflowEnvironment return errors with stack traces |
| [#1376](#1376) | 0 | 1 | Expose next retry delay on Application Failure in all SDKs |
| [#1354](#1354) | 0 | 1 | Please help regenerate mocks |
| [#1334](#1334) | 0 | 1 | Allow opting out of tracer span creation on schedule create |
| [#1323](#1323) | 0 | 1 | Dynamic worker config |
| [#1300](#1300) | 0 | 1 | Better Task Failures when passing incorrect options to Execute[Local]Activity |
| [#1284](#1284) | 0 | 1 | [feature]: Allow GetCurrentHistoryLength() to return > 0 during tests |
| [#1271](#1271) | 0 | 1 | Make nondeterminism errors more clear |
| [#1261](#1261) | 0 | 1 | Simplify/fix worker API |
| [#1259](#1259) | 0 | 1 | contrib/opentelemetry release that has AllowInvalidParentSpans |
| [#1257](#1257) | 0 | 1 | Allow RetryPolicyOptions to take a predicate (function) to evaluate whether to retry or not |
| [#1231](#1231) | 0 | 1 | Add RawValue type  |
| [#1227](#1227) | 0 | 1 | Worker versioning + workflow session |
| [#1212](#1212) | 0 | 1 | Queryable registry |
| [#1211](#1211) | 0 | 1 | Client for test environment [golang] |
| [#1209](#1209) | 0 | 1 | Race condition when evicting a workflow from cache |
| [#1196](#1196) | 0 | 1 | v1.24.0 requires Go v1.19+ |
| [#1172](#1172) | 0 | 1 | Temporarily expose gRPC client connection for cloud API use |
| [#1111](#1111) | 0 | 1 | Panic from goroutine is not caught and crashes worker |
| [#1104](#1104) | 0 | 1 | Context timeout is halved on client.ExecuteWorkflow |
| [#1099](#1099) | 0 | 1 | TestWorkflowEnvironment timeouts run defer statements |
| [#1097](#1097) | 0 | 1 | Stopping dev server not supported on Windows |
| [#1078](#1078) | 0 | 1 | num_pollers not exposed in worker metrics |
| [#1075](#1075) | 0 | 1 | Verify UpdateExecutionComplete on replay |
| [#1068](#1068) | 0 | 1 | LocalActivity Tunnel not reset on stale cache lookup |
| [#1057](#1057) | 0 | 1 | Double Update Accepted Event Due to Replay |
| [#1045](#1045) | 0 | 1 | Memo does not go through user provided data coverter |
| [#1014](#1014) | 0 | 1 | workflow.MutableSideEffect not deterministic if called multiple times with the same ID in the same WFT |
| [#1012](#1012) | 0 | 1 | Tag workflowcheck |
| [#1000](#1000) | 0 | 1 | Panic with clear error message when workflow commands are produced in a side-effect/query function |
| [#996](#996) | 0 | 1 | Opt-in to having stack trace query use custom data converter |
| [#994](#994) | 0 | 1 | Cannot set workflow ID for replayer |
| [#980](#980) | 0 | 1 | workflowcheck should allow fmt.Errorf and fmt.Sprintf and others |
| [#975](#975) | 0 | 1 | Missing mock invocation causes PanicError in a test but the test succeeds with exit code 0. |
| [#970](#970) | 0 | 1 | Search attributes and memos are kept from previous runs when resetting workflow context |
| [#968](#968) | 0 | 1 | Remove deprecated metrics |
| [#967](#967) | 0 | 1 | testsuite.TestWorkflowEnvironment does not complete workflows synchronously when activities create new environments to start nested workflows |
| [#958](#958) | 0 | 1 | Confusing interface match for client.ScheduleWorkflowAction |
| [#947](#947) | 0 | 1 | Panic: Error adding duplicate command on duplicated child workflow |
| [#939](#939) | 0 | 1 | Nightly CI against server `master` |
| [#935](#935) | 0 | 1 | Testing: Be Able to Unit Test a Workflow with a Populated `ContinuedExecutionRunID` |
| [#930](#930) | 0 | 1 | Support failure encoding in proxy gRPC interceptor |
| [#922](#922) | 0 | 1 | TestWorkflowEnvironment.SignalExternalWorkflow data race on signal data |
| [#912](#912) | 0 | 1 | Change default Prometheus santitize options to not change values |
| [#901](#901) | 0 | 1 | Tag new releases for contrib/opentracing and contrib/opentelemetry |
| [#898](#898) | 0 | 1 | golang.org/x/tools-v0.1.10: 3 vulnerabilities (highest severity is: 6.1) - autoclosed |
| [#891](#891) | 0 | 1 | New Tally contrib lib release |
| [#886](#886) | 0 | 1 | independent lifecycles for cloned clients |
| [#876](#876) | 0 | 1 | Completed workflow not properly checking command/event mismatch for non-determinism |
| [#864](#864) | 0 | 1 | Make possible non-deterministic errors clear that's what they may be |
| [#861](#861) | 0 | 1 | Support creating new client from existing client's connection |
| [#854](#854) | 0 | 1 | num_pollers metric |
| [#853](#853) | 0 | 1 | github.com/stretchr/testify-v1.8.0: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#846](#846) | 0 | 1 | URL in metrics API 404s |
| [#837](#837) | 0 | 1 | Support github.com/golang/protobuf messageType name |
| [#827](#827) | 0 | 1 | github.com/stretchr/testify-v1.7.0: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#817](#817) | 0 | 1 | github.com/go-yaml/yaml-v2.4.0: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#810](#810) | 0 | 1 | OnUpsertSearchAttributes changes / additions |
| [#793](#793) | 0 | 1 | Deprecate NewClient, create Dial, NewLazyClient, and CheckHealth calls and support laziness |
| [#792](#792) | 0 | 1 | Expose fatal worker error in some way and stop killing process |
| [#781](#781) | 0 | 1 | ReplayWorkflowExecution fails when history is too long |
| [#777](#777) | 0 | 1 | github.com/golang/tools-v0.1.10: 3 vulnerabilities (highest severity is: 6.1) - autoclosed |
| [#775](#775) | 0 | 1 | github.com/golang/tools-v0.1.8: 3 vulnerabilities (highest severity is: 6.1) - autoclosed |
| [#773](#773) | 0 | 1 | deadlock detected: workflow goroutine "root" didn't yield for over a second |
| [#753](#753) | 0 | 1 | Allow lazy connection on client |
| [#716](#716) | 0 | 1 | If a workflow is terminated while processing, it can leak coroutines |
| [#698](#698) | 0 | 1 | Allow "unable to find workflow type" error to be configured to hard-fail the workflow |
| [#695](#695) | 0 | 1 | RetryPolicy not propagated on ContinueAsNew |
| [#686](#686) | 0 | 1 | Manually returned activity cancel error without receiving a server-side cancellation |
| [#670](#670) | 0 | 1 | Test activity start and complete between workflow schedule and start |
| [#667](#667) | 0 | 1 | Test and document exactly what contexts are cancelled on worker stop |
| [#666](#666) | 0 | 1 | - |
| [#664](#664) | 0 | 1 | Add opentracing.MustNewInterceptor and opentelemetry.MustNewTracingInterceptor |
| [#646](#646) | 0 | 1 | Confirm support or lack of for multiple query return types |
| [#615](#615) | 0 | 1 | Header support for signals and queries |
| [#568](#568) | 0 | 1 | custom data converter is not correctly wired up for local activity |
| [#558](#558) | 0 | 1 | TestCancelTimerAfterActivity is flaky |
| [#557](#557) | 0 | 1 | TestCancelChildWorkflowUnusualTransitions is flaky |
| [#555](#555) | 0 | 1 | TestActivityNotRegisteredRetry is flaky |
| [#554](#554) | 0 | 1 | TestActivityNotRegisteredRetry is flaky |
| [#553](#553) | 0 | 1 | TestAsyncActivityCompletion is flaky |
| [#552](#552) | 0 | 1 | TestActivityStartedAtSameTimeAsTimerCancel is flaky |
| [#551](#551) | 0 | 1 | TestActivityRetryOnTimeoutStableError is flaky |
| [#549](#549) | 0 | 1 | TestActivityRetryOnStartToCloseTimeout is flaky |
| [#548](#548) | 0 | 1 | TestActivityNotRegisteredRetry is flaky |
| [#528](#528) | 0 | 1 | clarify `ActivityOptions.ActivityID` |
| [#517](#517) | 0 | 1 | codahale/hdrhistogram repo url has been transferred under the github HdrHstogram umbrella |
| [#502](#502) | 0 | 1 | Backoff poller on ResourceExhausted error |
| [#496](#496) | 0 | 1 | Add accessors for ActivityError fields |
| [#473](#473) | 0 | 1 | Workflow replay is broken if workflow contains multiple subsequent calls to GetVersion |
| [#469](#469) | 0 | 1 | Propgate Context Cancellations to Workflow Futures which are blocked on `Get(ctx, valuePtr)` |
| [#468](#468) | 0 | 1 | Vulnerability CVE-2021-3121 |
| [#464](#464) | 0 | 1 | Add workflow/activity error/panic worker hooks |
| [#461](#461) | 0 | 1 | Default retry policy is not set in test framework |
| [#457](#457) | 0 | 1 | temporal_activity_execution_failure Metric Doesn't Seem to Work |
| [#443](#443) | 0 | 1 | Add support to de-register workflows and activities |
| [#438](#438) | 0 | 1 | Client creation doesn't have any retries if health check intermittently fails |
| [#417](#417) | 0 | 1 | Error handling documentation outdated |
| [#416](#416) | 0 | 1 | Confusing Docs Around Reuse Policy |
| [#413](#413) | 0 | 1 | BackoffCoefficient must be defined and not defaulting to default value of 2.0 |
| [#412](#412) | 0 | 1 | SDK Overview link in the about section on the right side of the repository is broken (page not found) |
| [#410](#410) | 0 | 1 | Multiple filter support on ListWorkflow client methods |
| [#406](#406) | 0 | 1 | Activity Retry Policy is ignored in workflow tests |
| [#389](#389) | 0 | 1 | Add validation of input addr during client creation |
| [#377](#377) | 0 | 1 | Add an ApplicationErrorBuilder |
| [#356](#356) | 0 | 1 | Registering Activity Fails Silently When Function Doesn't Match Signature |
| [#347](#347) | 0 | 1 | regarding change in inputs of running workflow |
| [#324](#324) | 0 | 1 | Logrus maintaince mode |
| [#309](#309) | 0 | 1 | relation "schema_version" does not exist on fresh postgresql DB |
| [#305](#305) | 0 | 1 | Custom error types inaccessible as they are defined in internal package |
| [#295](#295) | 0 | 1 | Data race on cache eviction |
| [#275](#275) | 0 | 1 | If a retryable workflow returns a non-retryable error that was originally returned by an activity, the workflow still gets retried |
| [#268](#268) | 0 | 1 | Add ability to reject ExecuteWorkflow call on duplicated workflow |
| [#243](#243) | 0 | 1 | Support proto structs generated by google proto compiler |
| [#233](#233) | 0 | 1 | Deprecate and remove disable sticky execution flag |
| [#220](#220) | 0 | 1 | Unable to get WorkflowExecutionAlreadyStartedError |
| [#208](#208) | 0 | 1 | Unix specific API breaks windows development |
| [#194](#194) | 0 | 1 | Support seamless cleanup during session cancellation |
| [#183](#183) | 0 | 1 | Report connection issues in more user friendly way |
| [#149](#149) | 0 | 1 | Race in Register...WithOptions due to un-protected map read |
| [#139](#139) | 0 | 1 | Support returning WorkflowExecutionAlreadyStartedError in tests |
| [#127](#127) | 0 | 1 | Enable ContextPropagator for ExecuteLocalActivity |
| [#116](#116) | 0 | 1 | Selector should match closed channel once |
| [#94](#94) | 0 | 1 | Worker Start/Stop behavior |
| [#86](#86) | 0 | 1 | Add ability to call healthcheck from WorkflowClient |
| [#75](#75) | 0 | 1 | Test_WorkflowLocalActivityWithMockAndListeners is flaky |
| [#72](#72) | 0 | 1 | Add code linting to the SDK |
| [#50](#50) | 0 | 1 | Make TestWorkflowEnvironment support test multiple workflows |
| [#49](#49) | 0 | 1 | Context used for ExecuteActivity is ignored or SideEffect ignores parameters |
| [#38](#38) | 0 | 1 | Remove path prefix from activity and workflow type names |
| [#36](#36) | 0 | 1 | Add support for cross namespace activity and child workflow scheduling |
| [#2](#2) | 0 | 1 | Pass function result by pointer to the DataConverter for consistency |
| [#2140](#2140) | 0 | 0 | OpenTelemetry incorrect metric type for Counter |
| [#2124](#2124) | 0 | 0 | Support non-workflow activities |
| [#2123](#2123) | 0 | 0 | [api-go] Proxy: allow payload visitor to run in parallel |
| [#2114](#2114) | 0 | 0 | Set GrpcMessageTooLarge as failure_reason for workflow task failed metric |
| [#2111](#2111) | 0 | 0 | workflow_completed and workflow_continue_as_new counters should be logged after a successful reporting to the server |
| [#2108](#2108) | 0 | 0 | Allow overriding of the Worker Deployment Version when invoking a Child Workflow |
| [#2106](#2106) | 0 | 0 | Poller Autoscaling can't scale past InitialNumberOfPollers |
| [#2094](#2094) | 0 | 0 | Worker Heartbeating |
| [#2092](#2092) | 0 | 0 | go.temporal.io/sdk/contrib/envconfig docs mention wrong path |
| [#2090](#2090) | 0 | 0 | Starting a child workflow in tests leaks goroutines |
| [#2089](#2089) | 0 | 0 | Add resource tuner metrics |
| [#2086](#2086) | 0 | 0 | [go] Plugin + SimplePlugin |
| [#2085](#2085) | 0 | 0 | Add support for firstExecutionRunId to cancel and terminate |
| [#2083](#2083) | 0 | 0 | Use normal task queue name for sticky task queue client metrics |
| [#2053](#2053) | 0 | 0 | Expose Temporal Nexus operation info to Temporal Nexus operation authors |
| [#2045](#2045) | 0 | 0 | Ensure tests exist to confirm custom slot supplier slot info has proper fields |
| [#2034](#2034) | 0 | 0 | [Feature Request] Reclassify Benign Application errors in OpenTelemetry |
| [#2033](#2033) | 0 | 0 | Flaky tests: TestIntegrationSuite/TestGrpcMessageTooLarge |
| [#2031](#2031) | 0 | 0 | Add Go to Waitgroup |
| [#2030](#2030) | 0 | 0 | Move RESOURCE_EXHAUSTED_CAUSE_EXT_GRPC_MESSAGE_TOO_LARGE to upstream API |
| [#2025](#2025) | 0 | 0 | Fix DescribeTaskQueueEnhanced w/ stats to use non-deprecated APIs |
| [#2024](#2024) | 0 | 0 | Set Span Kinds in Otel tracer interceptors |
| [#2020](#2020) | 0 | 0 | Plugin support |
| [#2015](#2015) | 0 | 0 | Remove usage of deprecated `Control` fields |
| [#2006](#2006) | 0 | 0 | Add a compiler check to ensure the WorkflowReplayer interface implements the WorkflowRegistry interface. |
| [#2005](#2005) | 0 | 0 | OnWorkflow test mocker doesn't propagate context headers |
| [#1999](#1999) | 0 | 0 | DataConverter silent all encoding error |
| [#1997](#1997) | 0 | 0 | workflowRunOperationToken should not encode version if 0 |
| [#1988](#1988) | 0 | 0 | Add Summary to LocalActivityOptions |
| [#1983](#1983) | 0 | 0 | Expose StartToCloseTimeout in ActivityInfo struct |
| [#1971](#1971) | 0 | 0 | [go] Add `WorkflowTaskFailedCause` to `RespondQueryTaskCompletedRequest` |
| [#1963](#1963) | 0 | 0 | GetWorkerStopChannel no longer indicates worker shutdown for Local Activities |
| [#1948](#1948) | 0 | 0 | Remove license headers from files in api-go |
| [#1947](#1947) | 0 | 0 | Remove license headers from files |
| [#1943](#1943) | 0 | 0 | `SearchAttributes.Copy` is getting flagged by `workflowcheck` |
| [#1931](#1931) | 0 | 0 | [go] SDK support for activity reset |
| [#1930](#1930) | 0 | 0 | Have implicit activity context timeout start-to-close be relative to system time not server time |
| [#1921](#1921) | 0 | 0 | [api-go] Remove cloud submodule and cloud protos |
| [#1919](#1919) | 0 | 0 | Show retry policy on activity info |
| [#1908](#1908) | 0 | 0 | Apply application failure logging and metrics behaviour according to ApplicationErrorCategory |
| [#1899](#1899) | 0 | 0 | Heartbeating activities should be interrupted when the activities are paused. |
| [#1889](#1889) | 0 | 0 | [api-go] Support proxy interceptor returning valid response and error |
| [#1886](#1886) | 0 | 0 | [api-go] failure converter/payload codec interceptor order issue |
| [#1874](#1874) | 0 | 0 | Document that local activities should not use anonymous functions |
| [#1869](#1869) | 0 | 0 | SetOnChildWorkflowCompletedListener doesn't work as expected |
| [#1868](#1868) | 0 | 0 | ResourceBasedSlotSupplier.ReleaseSlot not implemented |
| [#1861](#1861) | 0 | 0 | Add summary to Nexus operation |
| [#1860](#1860) | 0 | 0 | testsuite.TestUpdateCallback method should be given no-ops when not provided |
| [#1848](#1848) | 0 | 0 | Expose root workflow execution |
| [#1846](#1846) | 0 | 0 | AsTime() on a nil pointer converts to  Jan. 1st, 1970 at midnight UTC |
| [#1843](#1843) | 0 | 0 | Built-in query responses should use "RawValue" |
| [#1839](#1839) | 0 | 0 | Remove old Nexus workflow run operation token format |
| [#1838](#1838) | 0 | 0 | Non-deterministic workflow code can send incorrect WFT completion without task failure |
| [#1829](#1829) | 0 | 0 | doclink: Incorrect "Exposed" requirement in method without context |
| [#1827](#1827) | 0 | 0 | TestNumPollersCounter consistently fails on stable macos-arm in CI |
| [#1825](#1825) | 0 | 0 | [api-go] Proxy gRPC interceptors in should visit payloads and failures of gRPC errors too |
| [#1817](#1817) | 0 | 0 | Expose Workflow cancel cause/reason |
| [#1815](#1815) | 0 | 0 | Environment configuration |
| [#1812](#1812) | 0 | 0 | Doc tool flags missing annotations on variable declarations |
| [#1811](#1811) | 0 | 0 | [api-go] Code gen for payload visiting should walk all descriptors instead of workflow service reachability |
| [#1810](#1810) | 0 | 0 | Change application error to Nexus HandlerError conversion to use non-retryable internal errors |
| [#1796](#1796) | 0 | 0 | Add `Patched()` and `DeprecatePatch()` APIs |
| [#1788](#1788) | 0 | 0 | Allow customization of dev server UI port |
| [#1779](#1779) | 0 | 0 | Special behavior for Temporal built-in prefixes |
| [#1778](#1778) | 0 | 0 | Rename Worker Deployment API interfaces |
| [#1777](#1777) | 0 | 0 | Add ramp to Worker Deployments |
| [#1776](#1776) | 0 | 0 | Provide flag to tell the update handler that the handling is from a re-apply |
| [#1774](#1774) | 0 | 0 | Doclink bug: duplicate "Exposed as" strings being generated |
| [#1761](#1761) | 0 | 0 | Provide client from activity context |
| [#1760](#1760) | 0 | 0 | Provide "workflow local" |
| [#1756](#1756) | 0 | 0 | Malformed code links in API docs |
| [#1739](#1739) | 0 | 0 | Fail registration of workflow types without versioning behavior |
| [#1737](#1737) | 0 | 0 | `WorkflowTestSuite.UpdateWorkflow` should generate an update ID if none is set like the `WorkflowClient` |
| [#1732](#1732) | 0 | 0 | Session worker delays with single activity limit after Tuner introduction |
| [#1725](#1725) | 0 | 0 | Add accessors for ChildWorkflowExecutionError fields |
| [#1713](#1713) | 0 | 0 | Support the Deployment API |
| [#1700](#1700) | 0 | 0 | Test environment shouldn't default to SdkFlags being true |
| [#1698](#1698) | 0 | 0 | Enable type-scoped Versioning Behavior for workflows   |
| [#1693](#1693) | 0 | 0 | Provide details and actionable info about Non Deterministic Errors |
| [#1668](#1668) | 0 | 0 | When deserializing typed search attributes, invalid values should be ignored |
| [#1667](#1667) | 0 | 0 | Add high-level workflow describe |
| [#1663](#1663) | 0 | 0 | Add workflow annotations for versioning |
| [#1650](#1650) | 0 | 0 | List of flaky tests |
| [#1648](#1648) | 0 | 0 | Show update handler and ID in logging context |
| [#1639](#1639) | 0 | 0 | Improve UX for testing Workflow Update with the Workflow Test Environment |
| [#1635](#1635) | 0 | 0 | ExecuteMultiOperation is not retrying non-admitted Updates |
| [#1633](#1633) | 0 | 0 | Modify test suite to dump junit XML |
| [#1628](#1628) | 0 | 0 | API `MockWorkflowServiceServer` does not implement `WorkflowServiceServer` properly |
| [#1622](#1622) | 0 | 0 | API Go's payload visitor not visiting `Any` for payloads inside |
| [#1612](#1612) | 0 | 0 | Request to make queryRejectedError public to enhance Interceptor error handling |
| [#1610](#1610) | 0 | 0 | Provide access to the workflow results from worker.WorkflowReplayer |
| [#1591](#1591) | 0 | 0 | Fix workflow start delay docs to say signal does not interrupt delay |
| [#1588](#1588) | 0 | 0 | Support updates in tracing interceptor |
| [#1580](#1580) | 0 | 0 | Do not warn on unfinished handlers if the workflow has failed |
| [#1567](#1567) | 0 | 0 | Worker can panic if it receives a legacy query task with no history and the SDK has a destroyed execution in cache |
| [#1566](#1566) | 0 | 0 | `go.temporal.io/api/proxy.VisitPayloads` doesn't visit `export` package |
| [#1565](#1565) | 0 | 0 | User metadata and workflow metadata query |
| [#1564](#1564) | 0 | 0 | Test Nexus with Cloud |
| [#1545](#1545) | 0 | 0 | Review and add tests for Nexus operation log and metrics labels |
| [#1539](#1539) | 0 | 0 | Support "query" when listing schedules |
| [#1536](#1536) | 0 | 0 | TERMINATE_IF_RUNNING doesn't work for duplicate child workflows |
| [#1523](#1523) | 0 | 0 | Accept search attributes in dev server startup |
| [#1520](#1520) | 0 | 0 | Workflow-friendly concurrency control |
| [#1519](#1519) | 0 | 0 | Testing |
| [#1518](#1518) | 0 | 0 | Testing |
| [#1517](#1517) | 0 | 0 | Testing |
| [#1500](#1500) | 0 | 0 | Provide methods to wait for handlers to finish |
| [#1496](#1496) | 0 | 0 | Workflow outcome is inconsistent between test env and real server |
| [#1491](#1491) | 0 | 0 | Better testing story for Nexus Operations |
| [#1483](#1483) | 0 | 0 | workflowcheck -: named files must all be in one directory; have . and workflows |
| [#1476](#1476) | 0 | 0 | Infer input type when executing a Nexus Operation from a workflow |
| [#1469](#1469) | 0 | 0 | Allow specifying attempt in TestWorkflowEnvironment |
| [#1465](#1465) | 0 | 0 | `activity_succeed_endtoend_latency` is recorded even on activity failure/cancel |
| [#1460](#1460) | 0 | 0 | QueryRejectCondition not used in QueryWorkflowWithOptions |
| [#1459](#1459) | 0 | 0 | Cloud Operations API Client |
| [#1455](#1455) | 0 | 0 | Update handler should require `workflow.Context` as first parameter |
| [#1454](#1454) | 0 | 0 | Local activity support for next-retry-delay |
| [#1449](#1449) | 0 | 0 | Clarify waiting semantics for UpdateWorkflow |
| [#1447](#1447) | 0 | 0 | Support for WorkflowIdConflictPolicy |
| [#1442](#1442) | 0 | 0 | Expose defaultConnection() method to switch between localhost and cloud based on env |
| [#1435](#1435) | 0 | 0 | It is not possible to unit test a child workflow that calls continue as new. |
| [#1427](#1427) | 0 | 0 | TestWorkflowEnvironment workflow Context does not block when canceled |
| [#1414](#1414) | 0 | 0 | [Feature Request] SDK should not return an update handle if the update has not reached the desired state |
| [#1411](#1411) | 0 | 0 | Replace use of *updatepb.WaitPolicy with enum defined in the Go SDK |
| [#1401](#1401) | 0 | 0 | API key client option |
| [#1387](#1387) | 0 | 0 | Configurable panic policy at the workflow level |
| [#1384](#1384) | 0 | 0 | Add an option to override retry policy |
| [#1360](#1360) | 0 | 0 | `testsuite.DevServer` occasionally does not stop |
| [#1359](#1359) | 0 | 0 | PollWorkflowUpdate does not use a context aware data converter |
| [#1357](#1357) | 0 | 0 | SDK should evict workflow execution from cache on failure to respond to a workflow task |
| [#1349](#1349) | 0 | 0 | WorkflowRun.Get does not use a context aware data converter |
| [#1347](#1347) | 0 | 0 | Workflow/Activity context is dropped when using `DataConverterWithoutDeadlockDetection` wrapper |
| [#1341](#1341) | 0 | 0 | WorkflowChecker should flag anonymous functions in local activities as non deterministic |
| [#1315](#1315) | 0 | 0 | Deprecate Update related SDK flags |
| [#1313](#1313) | 0 | 0 | Support OpenTelemetry Metrics |
| [#1312](#1312) | 0 | 0 | Fail task on unknown event when HistoryEvent.worker_may_ignore is false |
| [#1297](#1297) | 0 | 0 | Update handle needs to be invoked immediately when registered with pending updates |
| [#1290](#1290) | 0 | 0 | Context propagators aren't used when running local activities with the test environments |
| [#1289](#1289) | 0 | 0 | [Feature Request] Tag workflow_task_execution_failed with error type |
| [#1283](#1283) | 0 | 0 | Remove ClientOutboundInterceptor.PollWorkflowUpdate |
| [#1272](#1272) | 0 | 0 | Failed Read-Only check should cause a WFT failure in an update validator, not fail the update |
| [#1266](#1266) | 0 | 0 | `loggerWith.WithCallerSkip` should expand keyvals |
| [#1263](#1263) | 0 | 0 | Add TestWorkflowEnvironment#UpdateWorkflowByID |
| [#1252](#1252) | 0 | 0 | Panics in update state machine don't cause WFT failures |
| [#1250](#1250) | 0 | 0 | Don't use versioned workers for eager workflow start |
| [#1248](#1248) | 0 | 0 | Enable TCP Keep alive by default |
| [#1243](#1243) | 0 | 0 | Add start delay to start workflow options |
| [#1240](#1240) | 0 | 0 | Data race after deadlock detector fired |
| [#1238](#1238) | 0 | 0 | Bad Update mock in NamespaceClient breaks mocking calls to this function |
| [#1237](#1237) | 0 | 0 | Support build ID reachability API |
| [#1236](#1236) | 0 | 0 | Test `TestVersionLoopWorkflow` can sometimes fail because the workflow does not yield for more then a second  |
| [#1235](#1235) | 0 | 0 | Defers in `workflow.Go` should be run deterministically and in sequence on cache eviction. |
| [#1234](#1234) | 0 | 0 | Disable creating a session worker and a versioned worker together |
| [#1218](#1218) | 0 | 0 | [Feature Request] Typed search attributes |
| [#1197](#1197) | 0 | 0 | Drain polled tasks on shutdown |
| [#1194](#1194) | 0 | 0 | Update sdk-name and sdk-version in task-level metadata if changed |
| [#1189](#1189) | 0 | 0 | Package docs on testsuite incorrectly showing license instead |
| [#1173](#1173) | 0 | 0 | Enable testing with OnActivity and non-retryable errors to verify options are set correctly |
| [#1157](#1157) | 0 | 0 | Support LocalActivityOptions.WaitForCancellation |
| [#1155](#1155) | 0 | 0 | Support intercepting `workflow.Await` on WorkflowOutboundInterceptor |
| [#1132](#1132) | 0 | 0 | Add support for visiting all payloads at once in proxy visitor interceptor |
| [#1131](#1131) | 0 | 0 | worker.Options.WorkerActivitiesPerSecond applies after poll is received |
| [#1127](#1127) | 0 | 0 | TestWorkflowEnvironment support mocking Activity without pre-registering but doesn't support for Workflows |
| [#1098](#1098) | 0 | 0 | Test CI on all platforms we support |
| [#1091](#1091) | 0 | 0 | Replaying Workflow History Yields Unexpected Error Due to Unknown Field "workerVersioningId" |
| [#1087](#1087) | 0 | 0 | Expose OriginalRunId and FirstRunId  |
| [#1074](#1074) | 0 | 0 | Update client API docs related to visibility |
| [#1066](#1066) | 0 | 0 | LocalActivity timeouts are inconsistent |
| [#1062](#1062) | 0 | 0 | Confusing documentation for client.ExecuteWorkflow API |
| [#1054](#1054) | 0 | 0 | EncodedFailureAttributes capability should be respected |
| [#1040](#1040) | 0 | 0 | ScheduleCalendarSpec should have a default for every time except year |
| [#1010](#1010) | 0 | 0 | Missing Heading for "Async/Manual Activity Completion" in Go SDK Doc |
| [#997](#997) | 0 | 0 | Support dynamic query and update handler |
| [#991](#991) | 0 | 0 | QueryWorkflowWithOptions not going through interceptor |
| [#971](#971) | 0 | 0 | Move most interceptor/proxy-based code gen to api-go |
| [#948](#948) | 0 | 0 | Document that workflow test suite defaults to maximum activity attempt of 10 |
| [#925](#925) | 0 | 0 | Godoc for workflow.Sleep and workflow.NewTimer is wrong about second resolution |
| [#919](#919) | 0 | 0 | Default MaxConcurrentEagerActivityExecutionSize to 3 |
| [#910](#910) | 0 | 0 | Add activity.InActivity(context.Context) bool |
| [#909](#909) | 0 | 0 | Fatal poll error on worker start isn't stopping activity poller |
| [#908](#908) | 0 | 0 | Heartbeats in test environment are not concurrency-safe |
| [#903](#903) | 0 | 0 | Worker fatal error can cause double worker stop |
| [#900](#900) | 0 | 0 | Log warning on failed serialization of signal input |
| [#896](#896) | 0 | 0 | Expose operator service |
| [#882](#882) | 0 | 0 | Remove poll failure log on explicit worker stop |
| [#873](#873) | 0 | 0 | Ensure slots available metric is updated on worker stop |
| [#871](#871) | 0 | 0 | High level API for schedules |
| [#870](#870) | 0 | 0 | Documentation fixes for error handling |
| [#860](#860) | 0 | 0 | Panic in eager activity code when RespondWorkflowTaskCompleted returns error |
| [#859](#859) | 0 | 0 | Cannot set really short max heartbeat throttle interval |
| [#844](#844) | 0 | 0 | Document that valuePtrs passed to ch.Receive/ReceiveAsync or future.Get calls should not be re-used across calls |
| [#843](#843) | 0 | 0 | Document non-thread-safe callbacks in test suite |
| [#822](#822) | 0 | 0 | Properly invoke worker OnFatalError callback for users of worker.Start() |
| [#818](#818) | 0 | 0 | Workflow static analyzer tool raises non-deterministic error on workflow.AwaitWithTimeout |
| [#794](#794) | 0 | 0 | Change default gRPC max message size to 128MB |
| [#786](#786) | 0 | 0 | workflow.GetLastError documentation is wrong |
| [#768](#768) | 0 | 0 | Add TestActivityEnvironment.SetOnActivityHeartbeatListener |
| [#758](#758) | 0 | 0 | Expose ApplicationError.msg |
| [#755](#755) | 0 | 0 | Sticky query invalid state machine transition error |
| [#750](#750) | 0 | 0 | Sync metrics format with OpenMetrics and JavaSDK |
| [#742](#742) | 0 | 0 | Fix docs for Client.ListWorkflow to clarify ES requirement |
| [#730](#730) | 0 | 0 | Set WorkflowStartTime parameter in tests |
| [#728](#728) | 0 | 0 | Add Await branch to Selector |
| [#724](#724) | 0 | 0 | Activity cancellation causes history error |
| [#720](#720) | 0 | 0 | Coroutine/context cancellation race conditions |
| [#719](#719) | 0 | 0 | Worker silently doing nothing if MaxConcurrentWorkflowTaskPoller set to 1 |
| [#712](#712) | 0 | 0 | OpenTracing-enabled workers error when missing OpenTracing spans in headers |
| [#710](#710) | 0 | 0 | Verify //workflowcheck:ignore works with Godoc |
| [#707](#707) | 0 | 0 | Increase visbiility for poll failures |
| [#705](#705) | 0 | 0 | Make WorkflowServiceStubsOptions#rpcLongPollTimeout configurable |
| [#701](#701) | 0 | 0 | Implement server capabilities and replace health check |
| [#700](#700) | 0 | 0 | Static Analysis Tool for Non-Determinism |
| [#692](#692) | 0 | 0 | Change heartbeat failure log from debug to warn |
| [#685](#685) | 0 | 0 | Add SkipLogger interface for logger |
| [#677](#677) | 0 | 0 | Flaky tests with TestCustomResolver and TestOpenTelemetryTracing |
| [#676](#676) | 0 | 0 | Document dangers with workflow.WithChildOptions and workflow.WithWorkflowRunTimeout using continue as new |
| [#665](#665) | 0 | 0 | Allow channel to convert to same type set if pointer |
| [#661](#661) | 0 | 0 | Workflow ID cannot be set on testsuite with SetStartWorkflowOptions  |
| [#648](#648) | 0 | 0 | Expose local boolean from activity.GetInfo |
| [#645](#645) | 0 | 0 | Update Tally to help statsd dependency |
| [#641](#641) | 0 | 0 | Expose gRPC |
| [#639](#639) | 0 | 0 | Workflows with too few parameters fail |
| [#627](#627) | 0 | 0 | Should always Set RequestId |
| [#623](#623) | 0 | 0 | Activity cancellation in certain scenarios causes event handling failure |
| [#621](#621) | 0 | 0 | Local activities do not catch panics |
| [#619](#619) | 0 | 0 | Make tracing tags consistent across SDKs |
| [#580](#580) | 0 | 0 | WorkflowExecutionAlreadyStarted error for child workflows should work with IsWorkflowExecutionAlreadyStartedError |
| [#576](#576) | 0 | 0 | Fix errors in documentation comments |
| [#571](#571) | 0 | 0 | NewWorkflowReplayer does not support custom data converter |
| [#556](#556) | 0 | 0 | TestBasic is flaky |
| [#547](#547) | 0 | 0 | TestActivityRetryOnError is flaky |
| [#530](#530) | 0 | 0 | ByteSliceConverter should accept interface{} in FromPayload |
| [#526](#526) | 0 | 0 | Add open tracing support |
| [#524](#524) | 0 | 0 | Client interface comments don't mention Postgres |
| [#514](#514) | 0 | 0 | TestActivityEnvironment.ExecuteActivity requires RegisterActivity when invoking activity by function |
| [#505](#505) | 0 | 0 | Non-retryable errors in sessions |
| [#503](#503) | 0 | 0 | Unhandled timer fired commands during workflow cancelations can cause SDK to issue cancel cmd for already-resolved timer |
| [#491](#491) | 0 | 0 | Testsuite Workflow Retry not working |
| [#483](#483) | 0 | 0 | Propagation of cancellations to child workflows can cause state machine panic |
| [#482](#482) | 0 | 0 | Workflow query hangs if the temporal workflow execution panics (is not available) |
| [#470](#470) | 0 | 0 | Test to support ParentClosePolicy |
| [#465](#465) | 0 | 0 | Activity stays in started state when ActivityType is not registered |
| [#449](#449) | 0 | 0 | Activity Latency Metrics Missing Task Queue Name |
| [#447](#447) | 0 | 0 | worker.Start should fail after worker.Stop was called |
| [#437](#437) | 0 | 0 | Cancel activity context on service not being reachable |
| [#427](#427) | 0 | 0 | Test that an activity wasn't called |
| [#411](#411) | 0 | 0 | ChildWorkflowExecution Future doesn't return error on WORKFLOW_ALREADY_EXISTS |
| [#390](#390) | 0 | 0 | Add support for querying child workflows in unit tests |
| [#378](#378) | 0 | 0 | Workflow panics after cleanup activity, if cancel occurs during workflow sleep |
| [#362](#362) | 0 | 0 | Tracer do not export workflow trace |
| [#354](#354) | 0 | 0 | Allow string activity names in `workflow.ExecuteLocalActivity` |
| [#346](#346) | 0 | 0 | RequestCancelExternalWorkflow(...).Get(ctx, nil) blocks forever with workflow exits with ErrCanceled |
| [#343](#343) | 0 | 0 | Invalid state transition panic when cancelling a child workflow, and a parent workflow consecutively |
| [#335](#335) | 0 | 0 | Original Failure source is lost when ConvertFailureToError invoked |
| [#301](#301) | 0 | 0 | Add Selector.HasPending |
| [#291](#291) | 0 | 0 | Expose previous run failure though workflow context API |
| [#279](#279) | 0 | 0 | StartWorkflow and OnWorkflowTaskStarted triggered twice on the same worker on QueryWorkflow |
| [#277](#277) | 0 | 0 | Expose access to grpc.ServiceClient so we can create default golang client and get access to underlying GRPC client |
| [#276](#276) | 0 | 0 | Reduce the severnity of "no activities/workflow registered" message by Temporal worker |
| [#272](#272) | 0 | 0 | Get RunId using WorkflowClient |
| [#247](#247) | 0 | 0 | Retrieved String Search Attribute includes quotation characters |
| [#238](#238) | 0 | 0 | RecordActivityHeartbeat signature should be modified to return an error if activity has been canceled |
| [#213](#213) | 0 | 0 | Cancellation of Child Workflows leads to an apparent deadlock |
| [#198](#198) | 0 | 0 | Add support for doing backward incompatible changes to workflow and activity function signatures |
| [#191](#191) | 0 | 0 | Add ability to register a single generic workflow and activity implementation for multiple types |
| [#186](#186) | 0 | 0 | Worker reports validation error on processing of transient decision |
| [#125](#125) | 0 | 0 | Remove need to register mocked activity |
| [#120](#120) | 0 | 0 | Activity error is lost when ScheduleToCloseTimeout is expired during retries |
| [#108](#108) | 0 | 0 | Fix race condition in testWorkflowEnvironmentImpl |
| [#91](#91) | 0 | 0 | Build of the freshly checked out repo fails |
| [#77](#77) | 0 | 0 | Remove WorkerOptions.Disable[Activity|Workflow]Worker option |
| [#60](#60) | 0 | 0 | Migrate service_wrapper_test to interceptor_test |
| [#29](#29) | 0 | 0 | Fix context propagation in testsuite |

---

## All Issues

Issues are sorted by priority score (upvotes Ã— 2 + comments).

---

<a id="916"></a>

### #916: Ability to mock/intercept side effect calls in test suite

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/916 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-22 14:05:06.000 UTC (3y 3m ago) |
| **Updated** | 2026-01-06 00:44:12.000 UTC |
| **Closed** | 2026-01-06 00:44:12.000 UTC |
| **Upvotes** | 21 |
| **Comments** | 0 |
| **Priority Score** | 42 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 21 |

#### Description

**Is your feature request related to a problem? Please describe.**

Can't intercept side effect calls

**Describe the solution you'd like**

Add something like `TestWorkflow.OnSideEffect` and `TestWorkflow.OnMutableSideEffect`


---

<a id="181"></a>

### #181: Add ability for a clean worker shutdown that waits for a session completion.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/181 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-07-07 15:40:12.000 UTC (5y 6m ago) |
| **Updated** | 2020-07-07 15:40:12.000 UTC |
| **Upvotes** | 16 |
| **Comments** | 0 |
| **Priority Score** | 32 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 16 |

#### Description

**Is your feature request related to a problem? Please describe.**
The clean worker shutdown waits for all currently running activities to complete. But in some cases, there is a need to wait for the whole session, which executes multiple activities to completion.

**Describe the solution you'd like**
Consider adding the capability to wait for an activity session to complete when waiting for the worker.Close()

**Describe alternatives you've considered**
Do not provide such a feature.



---

<a id="543"></a>

### #543: Support dynamic activity and workflow implementations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/543 |
| **State** | CLOSED |
| **Author** | aschrijver (Arnold Schrijver) |
| **Created** | 2021-09-21 07:12:40.000 UTC (4y 3m ago) |
| **Updated** | 2025-05-16 00:58:48.000 UTC |
| **Closed** | 2025-05-16 00:58:48.000 UTC |
| **Upvotes** | 11 |
| **Comments** | 8 |
| **Priority Score** | 30 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 11 |

#### Description

**Is your feature request related to a problem? Please describe.**
In some cases, activity and workflow implementations should be loaded dynamically.

**Describe the solution you'd like**
Expose an extension point for dynamic activity loading. This issue is created to ensure feature parity among SDK's where https://github.com/temporalio/sdk-java/issues/245 already implements this for Java.

**Additional context**
In [Dynamic activities registration at runtime and worker splitting](https://community.temporal.io/t/dynamic-activities-registration-at-runtime-and-worker-splitting/930/12?u=aschrijver) on the community forum @mfateev requested another user to create this issue, but that never happened AFAIK. Hence this issue.


#### Comments (8)

<details>
<summary><strong>zhyg</strong> commented on 2022-04-27 03:18:21.000 UTC</summary>

Hi, is there some progress? 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-27 13:06:06.000 UTC</summary>

We have not prioritized this because there haven't been many requests. Are you needing dynamic activity/workflow support? In almost all cases, a properly named/registered activity/workflow should be used and field in the parameter can be provided to take different paths. Can you describe your use case (here or in Slack or in forum)?

</details>

<details>
<summary><strong>nb950</strong> commented on 2022-05-23 00:51:26.000 UTC</summary>

@cretz can you share an example of what you describe ?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-23 14:38:35.000 UTC</summary>

Something like:

```go
func FallthroughWorkflow(ctx workflow.Context) error {
  workflow.GetLogger(ctx).Info("Called workflow: " + workflow.GetInfo(ctx).WorkflowType.Name)
}

func FallthroughActivity(ctx context.Context) error {
  activity.GetLogger(ctx).Info("Called activity: " + activity.GetInfo(ctx).ActivityType.Name)
}

func Register(worker worker.Worker) error {
  worker.RegisterWorkflowWithOptions(FallthroughWorkflow, workflow.RegisterOptions{Dynamic: true})
  worker.RegisterActivityWithOptions(FallthroughActivity, activity.RegisterOptions{Dynamic: true})
}
```

So basically that workflow or activity is called when one for the specific name is not found.

</details>

<details>
<summary><strong>k-jay-c</strong> commented on 2022-07-26 08:50:35.000 UTC</summary>

Hi,

We are also looking at support for dynamic activity registration for Go.  Would be great if you can provide some ETA?

Thanks,
Jay.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-05 13:40:19.000 UTC</summary>

I think we need to do the `workflow.RegisterOptions{Dynamic: true}`/`activity.RegisterOptions{Dynamic: true}` and we need to require that the function signature accept a string name and a slice of `converter.EncodedValue` values.

</details>

<details>
<summary><strong>Abdullah-AlAttar</strong> commented on 2024-10-14 14:35:18.000 UTC</summary>

Any updates on this ? 

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-15 13:43:47.000 UTC</summary>

No updates. If you can, we strongly recommend using explicit activities/workflows and using activity/workflow input to decide what to do inside the body instead of dynamic even when dynamic is available. But it is understood in some use cases like DSLs and such that dynamic is needed.

Reactions: ðŸ‘ 1

</details>


---

<a id="832"></a>

### #832: temporal SDK not compatible with temporal API v1.9.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/832 |
| **State** | CLOSED |
| **Author** | gregorhollmig (Gregor Hollmig) |
| **Created** | 2022-06-17 12:52:50.000 UTC (3y 6m ago) |
| **Updated** | 2022-08-09 14:43:29.000 UTC |
| **Closed** | 2022-08-09 14:43:29.000 UTC |
| **Upvotes** | 8 |
| **Comments** | 8 |
| **Priority Score** | 24 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 8 |

#### Description

## Expected Behavior

I cannot build my service using temporal anymore.

With release v1.9.0 of https://github.com/temporalio/api-go/releases/tag/v1.9.0 the latest temporal SDK is not compatible anymore

## Actual Behavior

When building the service I get the message. Checking the latest code hier in master this is already adapted and I think just a release is required.

```
go.temporal.io/sdk/client/service_proxy.go:50:9: cannot use &workflowServiceProxyServer{â€¦} (value of type *workflowServiceProxyServer) as type workflowservice.WorkflowServiceServer in return statement:
	*workflowServiceProxyServer does not implement workflowservice.WorkflowServiceServer (missing GetWorkerBuildIdOrdering method)
```

## Steps to Reproduce the Problem

1. Build application with latest temporal API&SDK

## Specifications

  - Version:  v1.15.0
  - Platform: MacOS


#### Comments (8)

<details>
<summary><strong>cretz</strong> commented on 2022-06-17 13:01:38.000 UTC</summary>

Yes, you have to use the dependency specified in the go.mod of the SDK version you are using. These are not meant to be upgraded independently.

(if you must use `v1.9.0` of the API dependency, you can use the latest `master`, but of course we always suggest a properly tagged release)

</details>

<details>
<summary><strong>twmb</strong> commented on 2022-06-19 05:16:48.000 UTC</summary>

Technically, api-go's change was a breaking change, as evidenced here -- if I `go get -u ./...`, my compilation should not break.

There isn't really a great solution for this AFAICT since these are separate repos. In my own projects, once I've frozen an interface with 1.0, I've either added extension interfaces or bumped the major version. 

</details>

<details>
<summary><strong>gregorhollmig</strong> commented on 2022-06-20 09:34:00.000 UTC</summary>

Thanks for the input.
In my services I do vendor updates on a regular base as @twmb describes with `go get -u -t ./...` usually this doesn't introduce breaking changes between dependencies but helps me keep my dependencies up to date. 
I manually resolved now with ```go get -t go.temporal.io/api@v1.8.0``` 

Are you already planning to release a new version of the go sdk with support for api v.1.9.0? 

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-20 15:31:40.000 UTC</summary>

> if I go get -u ./..., my compilation should not break.

In theory yes, however with many Go libraries these days, doing things such as adding a method to an interface in a point release is common due to major version change hurtles.

> or bumped the major version

This is difficult in Go due to being forced to change everyone's import path (e.g. `/v2`)

> Are you already planning to release a new version of the go sdk with support for api v.1.9.0?

Yes, next release will have that. In the meantime, please continue to use the version required in go.mod or use `master` (not recommended of course).

</details>

<details>
<summary><strong>Tarang</strong> commented on 2022-06-28 05:33:42.000 UTC</summary>

I'm receiving this error across multiple projects. I upgraded from temporal 1.12 to temporal 1.15 while building my project.

```
# go.temporal.io/sdk/client
../../../../go/pkg/mod/go.temporal.io/sdk@v1.15.0/client/service_proxy.go:50:9: cannot use &workflowServiceProxyServer{â€¦} (value of type *workflowServiceProxyServer) as type workflowservice.WorkflowServiceServer in return statement:
        *workflowServiceProxyServer does not implement workflowservice.WorkflowServiceServer (missing GetWorkerBuildIdOrdering method)
```

I have used `go get -u` to upgrade all my packages to the latest versions & additionally used `go get -u go.temporal.io/sdk@latest` to get the latest temporal version.

I think its related to this issue.

I think there is an indirect reference to the other package

```
require (
	go.temporal.io/api v1.9.0 // indirect
)
```

Reactions: ðŸ‘€ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-28 12:51:09.000 UTC</summary>

> I have used go get -u to upgrade all my packages

You can't really do this with the current version. Rather you would just `go get go.temporal.io/sdk@latest` (not `-u`), but since you did `-u`, you can downgrade to the exact expected API version expected (`go get go.temporal.io/api@v1.8.0`).

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-28 17:04:33.000 UTC</summary>

I think what I am going to do here is at least embed `UnimplementedWorkflowServiceServer` so that new APIs don't break older SDKs. I will update when I have a PR.

Reactions: ðŸ‘ 5

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-09 14:43:29.000 UTC</summary>

This has been solved.

</details>


---

<a id="1326"></a>

### #1326: go get fails because sourcegraph.com/sourcegraph/appdash-data is no longer available

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1326 |
| **State** | CLOSED |
| **Author** | noqcks (Benji Visser) |
| **Created** | 2023-12-19 04:03:02.000 UTC (2 years ago) |
| **Updated** | 2024-01-04 22:41:22.000 UTC |
| **Closed** | 2024-01-04 22:41:22.000 UTC |
| **Upvotes** | 7 |
| **Comments** | 3 |
| **Priority Score** | 17 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 7 |

#### Description

## Actual Behavior

contrib go.mod imports `gopkg.in/DataDog/dd-trace-go.v1 v1.42.0` which has a transitive dep on `sourcegraph.com/sourcegraph/appdash-data`, but appdash-data is no longer reachable.

https://github.com/temporalio/sdk-go/blob/master/contrib/datadog/go.mod#L8

```
#25 4.314 go: go.temporal.io/sdk/contrib/datadog@v0.1.0 requires
#25 4.314 	gopkg.in/DataDog/dd-trace-go.v1@v1.42.0 requires
#25 4.314 	github.com/99designs/gqlgen@v0.14.0 requires
#25 4.314 	sourcegraph.com/sourcegraph/appdash-data@v0.0.0-20151005[221](https://github.com/myorg/myrepo/actions/runs/2257091395/job/19770439394#step:6:223)446-73f23eafcf67: unrecognized import path "sourcegraph.com/sourcegraph/appdash-data": reading https://sourcegraph.com/sourcegraph/appdash-data?go-get=1: 404 Not Found
```

upgrading `gopkg.in/DataDog/dd-trace-go.v1` to the most recent version will remove sourcegraph as a dep.

See related issues in other repos:
- https://github.com/99designs/gqlgen-contrib/issues/34

## Steps to Reproduce the Problem

go.mod
```
module mymodule

require (
	gopkg.in/DataDog/dd-trace-go.v1 v1.58.0
)
```
$ go mod tidy



#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-19 04:16:15.000 UTC</summary>

Looks like we need to upgrade our version of `gopkg.in/DataDog/dd-trace-go.v1`. In the mean time you can try explicitly upgrading `gopkg.in/DataDog/dd-trace-go.v1` to work around this issue.

</details>

<details>
<summary><strong>TCashion</strong> commented on 2023-12-29 18:21:41.000 UTC</summary>

This worked as a temporary workaround: 

`go mod edit -replace=gopkg.in/DataDog/dd-trace-go.v1@v1.42.0=gopkg.in/DataDog/dd-trace-go.v1@v1.58.1`

Is there any update on whether there will be an official upgrade in the next release of the Go SDK?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-29 19:42:19.000 UTC</summary>

@TCashion a simple `go get gopkg.in/DataDog/dd-trace-go.v1` should upgrade you to the latest.

>Is there any update on whether there will be an official upgrade in the next release of the Go SDK?

The datadog module is versioned and released separately from the Go SDK, but it will be updated.

</details>


---

<a id="829"></a>

### #829: Use interceptor logger for all logs related to a workflow or activity execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/829 |
| **State** | OPEN |
| **Author** | jlegrone (Jacob LeGrone) |
| **Created** | 2022-06-10 12:59:45.000 UTC (3y 7m ago) |
| **Updated** | 2023-02-02 21:59:51.000 UTC |
| **Upvotes** | 6 |
| **Comments** | 5 |
| **Priority Score** | 17 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 6 |

#### Description

**Is your feature request related to a problem? Please describe.**

Interceptors are already able to modify log fields emitted by workflow and activity code. But any lower-level logs emitted by the Go SDK don't respect the logger returned by the interceptor chain. These include debug level logs like "ExecuteActivity" as well as warning or error level logs like "Task processing failed with error".

Using the logger returned by the interceptor chain would allow users to filter _all_ logs related to their workflow executions by domain-specific fields, create more sophisticated monitors or metric generation pipelines, and correlate logs to traces on observability platforms where that is supported.

**Describe the solution you'd like**

Evaluate the worker's interceptor chain to get a workflow or activity logger whenever a low-level log needs to be emitted by the Go SDK.

**Describe alternatives you've considered**

It might be possible to at least handle all debug level logs like "ExecuteActivity" via a regular interceptor that is registered by default.

It would be interesting to look into implementing low level logs like "Task processing failed with error" via an interceptor as well, perhaps by extending the workflow/activity interceptor interfaces to include a method for recording SDK errors. This would bring some additional benefits since interceptors would not only be able to log those errors, but emit custom metrics or error trace spans as well.

**Additional context**

I wrote an e2e test to demonstrate. After running the test, observe that the `trace_id` log field is not included in the "ExecuteActivity" log line.

```go
package sdklogtest

import (
	"context"
	"testing"
	"time"

	"github.com/DataDog/temporalite/temporaltest"
	"go.temporal.io/sdk/activity"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/contrib/opentracing"
	"go.temporal.io/sdk/interceptor"
	"go.temporal.io/sdk/log"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func LogWorkflow(ctx workflow.Context) error {
	workflow.GetLogger(ctx).Info("hello workflow")
	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		ScheduleToCloseTimeout: time.Minute,
	}), LogActivity).Get(ctx, nil)
}

func LogActivity(ctx context.Context) error {
	activity.GetLogger(ctx).Info("hello activity")
	return nil
}

type loggingTracer struct {
	interceptor.Tracer
}

func (loggingTracer) GetLogger(logger log.Logger, ref interceptor.TracerSpanRef) log.Logger {
	return log.With(logger, "trace_id", "0112358")
}

func TestLogOutput(t *testing.T) {
	// Which tracer we use here isn't important to the test; pulling in the opentracing
	// implementation just meant I didn't have to mock a full interceptor.
	openTracer, err := opentracing.NewTracer(opentracing.TracerOptions{})
	if err != nil {
		t.Fatal(err)
	}

	// Create test Temporal server and client
	ts := temporaltest.NewServer(temporaltest.WithT(t))
	c := ts.NewClientWithOptions(client.Options{
		Interceptors: []interceptor.ClientInterceptor{
			interceptor.NewTracingInterceptor(loggingTracer{openTracer}),
		},
	})

	// Register a new worker
	w := worker.New(c, "test", worker.Options{})
	defer w.Stop()
	w.RegisterWorkflow(LogWorkflow)
	w.RegisterActivity(LogActivity)
	if err := w.Start(); err != nil {
		t.Fatal(err)
	}

	// Start a workflow that emits some logs
	wfr, err := c.ExecuteWorkflow(context.Background(), client.StartWorkflowOptions{
		TaskQueue:                "test",
		WorkflowExecutionTimeout: time.Second * 10,
	}, LogWorkflow)
	if err != nil {
		t.Fatal(err)
	}

	// Wait for workflow to complete and fail test if workflow errors.
	if err := wfr.Get(context.Background(), nil); err != nil {
		t.Fatal(err)
	}

	// There's not a way to write a test against worker log output at the moment,
	// so just fail the test so logs can be inspected by a human.
	t.Errorf("Please inspect test log output for tag `trace_id:0112358` in workflow execution logs")
}
```

#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2022-06-10 13:42:11.000 UTC</summary>

The problem here is that the interceptor is for intercepting literal calls to `activity.GetLogger` and `workflow.GetLogger`, not just all loggers. You can provide your own logger at the client level to intercept logs originating _outside_ those explicit user calls.

But you may need the context. We can do what we did with data converters. Any data converter that implements the following interface:

```go
type ContextAware interface {
	WithWorkflowContext(ctx Context) converter.DataConverter
	WithContext(ctx context.Context) converter.DataConverter
}
```

Will have those functions called before the converter is used. So maybe we can make a:

```go
type ContextAwareLogger interface {
	WithWorkflowContext(ctx Context) log.Logger
	WithContext(ctx context.Context) log.Logger
}
```

And invoke those when impl'd by the logger everywhere we have a context. The overhead should be negligible. Thoughts?

</details>

<details>
<summary><strong>jlegrone</strong> commented on 2022-06-21 19:12:19.000 UTC</summary>

A `ContextAwareLogger` interface sounds like it could be useful... but when the SDK already has a workflow or activity context available to pass into the client's default logger, why not call `workflow.GetLogger` or `activity.GetLogger` instead so that the interceptor chain is invoked as well?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-21 20:56:02.000 UTC</summary>

My assumption was that `GetLogger` was as a result of a literal `GetLogger` call, and not just before every logger use to make sure it has the latest context info. However, it might make sense to just do this and we need to just be clear that unlike other outbound interceptors, this is not 1:1 with user calls, it is more frequent and therefore needs to be careful to remain performant.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-23 15:28:29.000 UTC</summary>

After some thought, I am afraid of repeatedly calling `GetLogger` internally instead of its original purpose of only being invoked when the user invokes it. I am worried about going from people understanding that it's only called per user call, to now dozens of internal calls since the context can change many times throughout the life of a workflow/activity and one may want such context updates before each log statement.

I am back to considering the `ContextAwareLogger` approach.

</details>

<details>
<summary><strong>jlegrone</strong> commented on 2023-02-02 21:58:33.000 UTC</summary>

I'd love to revisit this issue. We're looking for ways to assess the scope of impact for incidents caused by workflow code panics and other non-versioned/deterministic changes.

A common failure mode we've observed is that a small number of top level requests will generate a large number of Go SDK generated error logs across a broad set of child workflows. We're looking for a way to quickly identify how many root/top level parent workflows are impacted by aggregating across this set of logs, but are limited by the fact that we have no way of injecting custom request-scoped attributes in Go SDK logs.

For example, aggregating workflow error logs by [dd.trace_id](https://github.com/temporalio/sdk-go/blob/a9a4baa54c97bcb2ea229f99e673156b31452fad/contrib/datadog/tracing/interceptor.go#L180-L187) would allow us to identify how many top requests are impacted and help operators make more informed decisions about whether these top level workflows should be terminated vs. rolling out a new worker version.

</details>


---

<a id="265"></a>

### #265: Add ActivityInterceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/265 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-10-08 22:49:10.000 UTC (5y 3m ago) |
| **Updated** | 2021-11-15 17:52:25.000 UTC |
| **Closed** | 2021-11-15 17:52:25.000 UTC |
| **Upvotes** | 8 |
| **Comments** | 1 |
| **Priority Score** | 17 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 8 |

#### Description

Java SDK has [ActivityInterceptor](https://github.com/temporalio/sdk-java/blob/30420212a26283cf7cbe6339512058a3186074e8/temporal-sdk/src/main/java/io/temporal/common/interceptors/ActivityInterceptor.java#L22) and Go SDK misses one.

#### Comments (1)

<details>
<summary><strong>yevgenypats</strong> commented on 2021-08-30 10:45:49.000 UTC</summary>

This one would be really useful, especially for logging, tracing, of activities etc... @mfateev any possible update on timeline ?

Reactions: ðŸ‘ 5

</details>


---

<a id="1385"></a>

### #1385: Extend workflowcheck tool to detect reads from (WorkflowExecution).RunId and suggest alternatives.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1385 |
| **State** | CLOSED |
| **Author** | askreet (Kyle Smith) |
| **Created** | 2024-02-09 20:56:42.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-09 23:12:31.000 UTC |
| **Closed** | 2024-02-09 23:12:30.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 12 |
| **Priority Score** | 16 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

**Is your feature request related to a problem? Please describe.**

I've recently learned that using the value of RunId within workflow task code is non-deterministic under workflow ~~retry~~ reset scenarios.

**Describe the solution you'd like**

I'd love for the workflowcheck tool to detect reads of this particular property within workflow functions and suggest use of the WorkflowInfo.OriginalRunId (or FirstRunId) field instead.

**Describe alternatives you've considered**

N/A.

**Additional context**

N/A.

#### Comments (12)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-09 20:58:24.000 UTC</summary>

Can you clarify the scenario? Workflow retry starts a whole new workflow so the fact that RunID changes should not lead to non determinism

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-02-09 21:35:24.000 UTC</summary>

@Quinn-With-Two-Ns It leads to non-determinism if you use the value of RunID as an input to an activity or child workflow. For example, we were rendering the URL to the Temporal UI before kicking off a child workflow that creates a pull request, linking our developers back to the workflow that was created for them. In my scenario, the workflow had previously passed this step successfully so during replay the input value to the child workflow had changed.

Edit: In fact this journey led me [this field](https://github.com/temporalio/sdk-go/blob/master/internal/workflow.go#L995-L996), which documents itself as a more viable alternative.


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-09 21:43:45.000 UTC</summary>

Activities and Child workflows are not carried over retries. Non determinism only applies to a single workflow execution. A retried workflow can take a totally different path then the parent. It sounds like your trying to use RunID as an idempotency token across workflow retries, which is an error in your code, but is not non determinism.

The workflow check is designed to catch non determinism errors not all possible programming errors,


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-09 21:44:28.000 UTC</summary>

Note: in general we do not recommend workflow retries, we recommend handling errors in your workflow.

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-02-09 22:00:20.000 UTC</summary>

> Activities and Child workflows are not carried over retries.

I don't follow what you're saying here.

The input values need to match during the execution of a workflow task, or you get a non-determinism error when you reach the point in the workflow task when it attempts to run the activity or child workflow, right? In my workflow I execute a child workflow at a point in the event stream, and during the retry the input value is not the same as it was during the previous workflow task because it refers to a Run ID, which has changed due to the retry.

To be clear, I don't expect (or desire) that the child workflow is actually run again - we're talking about replaying the event stream to determine the next action for the workflow to take.

> Note: in general we do not recommend workflow retries, we recommend handling errors in your workflow.

In my case I had a workflow fail near the end of it's run due to a program defect. I've corrected the defect and would like to replay the workflow from the point of failure. Are you suggesting that the workflow retry command is not intended for me to do that? What alternative methods are suggested for resuming my terminated, failed workflow execution so that I can complete the intended actions?

Edit: Wait, I now see the confusion in the second scenario - I've been saying "retry", I mean workflow "reset". That's what I'm trying to do ðŸ˜“. I am not using workflow retries at all.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-09 22:04:00.000 UTC</summary>

Ah OK, reset makes more sense 

>The input values need to match during the execution of a workflow task, or you get a non-determinism error when you reach the point in the workflow task when it attempts to run the activity or child workflow, right? 

No, input is not checked when the SDK is validating a workflow is deterministic. 

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-02-09 22:05:18.000 UTC</summary>

> No, input is not checked when the SDK is validating a workflow is deterministic.

Oh? If that's so that I actually am back at square one and don't understand this determinism error! Will keep digging.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-09 22:08:58.000 UTC</summary>

Only the `Activity ID` and Type is checked I believe 

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-02-09 22:16:58.000 UTC</summary>

@Quinn-With-Two-Ns You're definitely pointing me in the right direction here, I updated my code to use OriginalRunId and I'm still seeing this error:

> unknown command CommandType: ChildWorkflow, ID: 70b7166d-0175-40bb-9ec0-e0f6473625c1_29, possible causes are nondeterministic workflow definition code or incompatible change in the workflow definition

That ID is the _original_ Run ID, plus the Event ID where the child was spawned. My current thesis is that since I'm not setting a workflow ID on the child workflow execution, it's comparing a newly generated child workflow ID that does not match that value.

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-02-09 22:35:42.000 UTC</summary>

I think the interesting piece of code is: https://github.com/temporalio/sdk-go/blob/master/internal/internal_event_handlers.go#L538-L540.

```go
func (wc *workflowEnvironmentImpl) ExecuteChildWorkflow(
	params ExecuteWorkflowParams, callback ResultHandler, startedHandler func(r WorkflowExecution, e error),
) {
	if params.WorkflowID == "" {
		params.WorkflowID = wc.workflowInfo.WorkflowExecution.RunID + "_" + wc.GenerateSequenceID()
	}
```

If I understand this correctly, any child workflow execution without a deterministically set Workflow ID will make the parent execution not "reset safe".

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-09 23:09:23.000 UTC</summary>

Ah if your using child workflow without an ID then this is a know issue https://github.com/temporalio/sdk-go/issues/723. 

I would recommend setting your own ID for now since as the linked issue says the SDK generated ID needs to not conflict with future server work that is not currently prioritized. 

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-02-09 23:12:31.000 UTC</summary>

Awesome, thanks @Quinn-With-Two-Ns! I'll update our internal guidelines to always set child workflow IDs in the meantime. I wonder if _that_ is a useful check for `workflowcheck` in the meantime if we don't have a timeline for the blocking server work? Anyway, I'll close this out for now.

Reactions: ðŸ‘ 1

</details>


---

<a id="1190"></a>

### #1190: Temporal SDK crash 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1190 |
| **State** | CLOSED |
| **Author** | itendtolosealot |
| **Created** | 2023-08-08 15:09:02.000 UTC (2y 5m ago) |
| **Updated** | 2023-10-16 16:00:09.000 UTC |
| **Closed** | 2023-10-16 16:00:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 16 |
| **Priority Score** | 16 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Concurrent accesses to the maps need to be protected

## Actual Behavior
Concurrent access to the map is causing SDK to crash, leading to a stuck client. 

## Steps to Reproduce the Problem
We are unaware of specific  ways to reproduce the issue. This happens intermittently and when it does, the impact is catastrophic as it impacts all the workflows executing on the runner.  

We are using Temporal (and Temporal SDK) to develop a Serverless Workflow based orchestrator. We encountered this issue when a parent workflow triggers a large number of child workflows (Ex: ForEach statement in SWF). During the execution of the child, we are getting stack-traces like below 

```
fatal error: concurrent map writes

goroutine 84634 [running]:
go.temporal.io/sdk/internal.(*commandsHelper).addCommand(0xc00211ed20, {0x31d45e0, 0xc0011bbfe0})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_command_state_machine.go:958 +0x1eb
go.temporal.io/sdk/internal.(*activityCommandStateMachine).cancel(0xc00100d0e0)
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_command_state_machine.go:591 +0x7f
go.temporal.io/sdk/internal.(*commandsHelper).requestCancelActivityTask(0x31a57a0?, {0xc0013a0580?, 0x132eb00?})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_command_state_machine.go:1020 +0x39
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).RequestCancelActivity(0xc00111f080, {{0xc0013a0580?, 0x2705c20?}})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_event_handlers.go:663 +0x38
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity.func3({0xc000a74fb8?, 0xc000615f28?}, 0x0?)
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/workflow.go:622 +0x75
go.temporal.io/sdk/internal.(*channelImpl).Close(0xc002418040?)
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_workflow.go:887 +0x97
go.temporal.io/sdk/internal.(*cancelCtx).cancel(0xc002418000, 0x0, {0x31a57a0, 0xc0000bfd40})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/context.go:333 +0xff
go.temporal.io/sdk/internal.(*cancelCtx).cancel(0xc002c6dc20, 0x1, {0x31a57a0, 0xc0000bfd40})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/context.go:340 +0x1e2
go.temporal.io/sdk/internal.WithCancel.func1()
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/context.go:196 +0x30
runtime.Goexit()
	/usr/local/go/src/runtime/panic.go:540 +0x1bb
go.temporal.io/sdk/internal.(*coroutineState).exit.func1({0xc000ac4000?, 0x3196760?}, 0xc000a58101?)
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_workflow.go:992 +0x17
go.temporal.io/sdk/internal.(*coroutineState).initialYield(0xc00211edc0, 0x3, {0xc000a58120, 0x19})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_workflow.go:914 +0x89
go.temporal.io/sdk/internal.(*coroutineState).yield(...)
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_workflow.go:923
go.temporal.io/sdk/internal.(*channelImpl).Receive(0xc000f2e510, {0x31c5740, 0xc0015b28a0}, {0x0, 0x0})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_workflow.go:715 +0x237
go.temporal.io/sdk/internal.(*futureImpl).Get(0xc0000ce3c0, {0x31c5740, 0xc0015b28a0}, {0x2718020?, 0xc000137080})
	/go/pkg/mod/go.temporal.io/sdk@v1.23.1/internal/internal_workflow.go:318 +0x66
gitlab.eng.vmware.com/core-build/swf-runtime/pkg/runtime.(*ForEach).runBatch(0x7?, {0x31c5740, 0xc0015b28a0}, {0xc000972000?, 0xc000aac501?, 0xc000844ba0?}, {0xc0007f9000?, 0xc00099f758?, 0x2c179b4?}, {0x2c00278, ...}, ...)
	/work/pkg/runtime/foreach.go:153 +0x215
```
	
	The snippet of the code for foreach.go that's relevant to this is given below
	
	
```
futures := lo.Map(list, func(input map[string]any, i int) workflow.Future {
		future, settable := workflow.NewFuture(ctx)
		workflow.Go(ctx, func(ctx workflow.Context) {
			config := &RunActionConfiguration{
				Actions:        actions,
				Mode:           mode,
				Params:         input,
				Workflow:       configuration.Workflow,
				EnvironmentID:  configuration.EnvironmentID,
				WorkflowURL:    configuration.WorkflowURL,
				OrganizationID: configuration.OrganizationID,
			}

			settable.Set(f.actionsRunner.Run(ctx, config))
		})
		return future
	})

	var results []map[string]any

	var errList error
	for _, future := range futures {
		result := map[string]any{}
		if err := future.Get(ctx, &result); err != nil {
			errList = multierr.Append(errList, err)
		} else {
			results = append(results, result)
		}
	}
```
The line 153 in the foreach.go refers to future.Get()


## Specifications

  - Version: 1.23.1
  - Platform: Linux/Kubernetes


#### Comments (16)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-08 15:17:09.000 UTC</summary>

What does `lo.Map` do and what is its signature?

</details>

<details>
<summary><strong>itendtolosealot</strong> commented on 2023-08-08 15:31:48.000 UTC</summary>

```
func Map[T any, R any](collection []T, iteratee func(item T, index int) R) []R {
	result := make([]R, len(collection))

	for i, item := range collection {
		result[i] = iteratee(item, i)
	}

	return result
}
```
It operates as a Map operation. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-08 17:16:32.000 UTC</summary>

Can you share what else is happening in your workflow? From the stack trace it looks like you are cancelling the context, but that is not in the code sample you shared.

</details>

<details>
<summary><strong>itendtolosealot</strong> commented on 2023-08-09 03:02:55.000 UTC</summary>

[runner_logs (2).txt](https://github.com/temporalio/sdk-go/files/12297802/runner_logs.2.txt)

The workflow is invoking a collection of actionRunners, which in turn execute the ChildWorkflow. As this is a batch, the child workflows are executed in parallel.  So, in the actionRunner code,  we create a **new** context using the WithCancel() function and cancel the **new** context when the actionRunner work is completed.  

Also, at the end of the Child Workflow execution, the context is cancelled. This is because the runner doesn't distinguish between Child/Parent. At the end of every workflow execution the context is canceled.

Are these incorrect use of the SDK? I am attaching the complete logs.




</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-10 13:39:16.000 UTC</summary>

Are you seeing this exception in your parent or child workflow?

As long as your following the constraints for programming in a workflow like determinism and not using goroutines/synchronization primitives, etc.

</details>

<details>
<summary><strong>itendtolosealot</strong> commented on 2023-08-10 15:39:38.000 UTC</summary>

The failure is seen while the parent workflow is waiting on Futures from all the Child Executions. 

We are not using go routines in the workflow tasks. We use workflow.Go. 

In the runner we have a single  long running house keeping task, which is running as a go routine.  It is not responsible for activities or tasks. This go routine uses Synchronization primitives. 

At the point when this go routine gets triggered, there is no workflow.Context. Consequently, it is not possible to trigger this as a separate workflow.Go routine. 

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-10 16:20:05.000 UTC</summary>

That should all be fine, this seems like an SDK bug. Are you using any disconnected contexts in this workflow?

</details>

<details>
<summary><strong>itendtolosealot</strong> commented on 2023-08-10 16:49:37.000 UTC</summary>

Yes. Whenever a Parent/Child workflow is completed, it creates a Disconnected context. This is used to send events from the runner to an another entity to indicate the success/failure of the workflow.  



</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-10 16:53:40.000 UTC</summary>

ack most likely another instance of https://github.com/temporalio/sdk-go/issues/743

</details>

<details>
<summary><strong>itendtolosealot</strong> commented on 2023-08-12 03:42:01.000 UTC</summary>

Hi Quinn,
Thank you so much for providing a likely diagnosis for this issue. I went through #743. People appear to have been struggling to reproduce the issue. In our case, it was observed very frequently (one in 3 experiments). 
Setup:
1. Temporal (separate pods for history, matching, front-end, worker, web, etc) deployed Kubernetes Cluster deployed inside a VM
2. Task/Activity Pollers set to 32
3. We trigger a workflow, that invokes  128 child workflows in parallel using Foreach

Repeat the experiment. We hit it one out of 3 times

With the default poller setting of 2, we experienced it once in 10 experiments. 

In our case, we didn't experience any significant loading as well. 

Thanks,
Ashvin

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-16 14:29:51.000 UTC</summary>

Hi Ashvin

What has blocked us from debugging/fixing this issue is a lack of a full reproduction.

We understand it is some combination of child workflow, cancelation and possibly using a disconnected context leads to a race in the SDK




</details>

<details>
<summary><strong>itendtolosealot</strong> commented on 2023-08-22 07:23:37.000 UTC</summary>

We are looking for some workarounds for this. Are there any that come to your mind? 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-24 14:28:02.000 UTC</summary>

No unfortunately 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-24 22:32:54.000 UTC</summary>

@itendtolosealot I believe I found the issue. A potential work around, until I can PR and release a fix, would be to not use defers in workflows.


Reactions: ðŸŽ‰ 1

</details>

<details>
<summary><strong>itendtolosealot</strong> commented on 2023-09-28 10:10:17.000 UTC</summary>

I wanted to thank you for the Workaround. We have applied the WA and ran 10-12 runs at scale. We did not see the issue.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-16 16:00:09.000 UTC</summary>

Closing as the fix has no been merged and released

</details>


---

<a id="78"></a>

### #78: Add ability to not log errors from activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/78 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-03-26 15:38:50.000 UTC (5y 9m ago) |
| **Updated** | 2025-06-04 13:12:20.000 UTC |
| **Closed** | 2025-06-04 13:08:45.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 10 |
| **Priority Score** | 16 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 3 |

#### Description

From Slack:

> In the worker side, how would you skip logging activity errors (returned as *cadence.CustomError) that are subsequently handled gracefully (ContinueAsNewError) by the calling workflow? Possibly skip only partially. I couldn't find support for accessing error details + rescinding entry from zap hooks.

One idea is to move all such logging into interceptors and allow redefining them.



#### Comments (10)

<details>
<summary><strong>mfateev</strong> commented on 2020-07-31 16:04:24.000 UTC</summary>

Another request is to be able to specify logging behavior per specific error. For example we recommend failing an activity constantly to implement polling. And in this case the error should not be logged. My strawman proposal is to add "doNotLog" flag to the ApplicationError.

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>fernando-cicconeto</strong> commented on 2023-07-24 13:05:07.000 UTC</summary>

@mfateev How is this issue status? I also have a case where I need to suppress error logging for a polling activity.

Is there a way to work around this while this issue is not resolved?

Thank you!

</details>

<details>
<summary><strong>inspell</strong> commented on 2024-02-19 08:47:23.000 UTC</summary>

I also have a case where I need to suppress error logging for a polling activity.
Any status update on this?

</details>

<details>
<summary><strong>seanmoghadam</strong> commented on 2024-03-25 08:52:33.000 UTC</summary>

I also need that feature, any updates?

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-03-25 13:56:59.000 UTC</summary>

While this feature does not exist yet, you can customize your logger interface implementation to ignore "Activity error." messages. There are even tags on the log statement for which activity and error it is if you need to be specific.

</details>

<details>
<summary><strong>yiminc</strong> commented on 2024-04-17 19:45:19.000 UTC</summary>

Also need to suppress the metrics temporal_activity_execution_failed.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>techanfa</strong> commented on 2024-09-30 22:50:27.000 UTC</summary>

+1

</details>

<details>
<summary><strong>leshkasmirnov</strong> commented on 2025-02-27 14:25:44.000 UTC</summary>

+1

</details>

<details>
<summary><strong>Yogurt-lei</strong> commented on 2025-06-04 01:38:37.000 UTC</summary>

Any update? waiting this feature . : )

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-06-04 13:12:19.000 UTC</summary>

Yes, next release will have #1925. You will be able to use `temporal.NewApplicationErrorWithOptions` to create an application error that you can set `temporal.ApplicationErrorOptions{Category: temporal.ApplicationErrorCategoryBenign}` options to have the error be logged at debug level instead of error level and the metric will not be recorded.

(closed as solved, though still pending release)

</details>


---

<a id="1282"></a>

### #1282: Heartbeat timeout not raised while testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1282 |
| **State** | OPEN |
| **Author** | miquelpuigmena (Miquel Puig i Mena) |
| **Created** | 2023-10-26 16:44:42.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-06 13:57:25.000 UTC |
| **Upvotes** | 5 |
| **Comments** | 5 |
| **Priority Score** | 15 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 5 |

#### Description

I want to see how an activity times out due to heartbeat timeout while testing. But it doesn't raise the Heartbeat timeout. See the tests in Steps to Reproduce the Problem section

## Expected Behavior
I would expect to see the test failing due to HeartbeatTimeout

## Actual Behavior
The tests are passing

## Steps to Reproduce the Problem
- make a folder with `workflow.go` and `workflow_test.go` below ðŸ‘‡ 
- `go test ./...`

workflow.go
```go
package hbtimeout

import (
	"context"
	"time"

	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/workflow"
)

type In struct {
	Sleep     int
	Heartbeat int
}

func Workflow(ctx workflow.Context, in In) error {
	options := workflow.ActivityOptions{
		StartToCloseTimeout: time.Second * 10,
		HeartbeatTimeout:    time.Second * time.Duration(in.Heartbeat),
		RetryPolicy: &temporal.RetryPolicy{
			MaximumAttempts: 1,
		},
	}

	ctx = workflow.WithActivityOptions(ctx, options)

	err := workflow.ExecuteActivity(ctx, Do, in.Sleep).Get(ctx, nil)
	if err != nil {
		return err
	}

	return nil
}

func Do(ctx context.Context, sleep int) error {
	time.Sleep(time.Second * time.Duration(sleep))
	return nil
}
```
workflow_test.go
```go
package hbtimeout

import (
	"testing"
	"time"

	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/testsuite"
)

type UnitTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
}

func TestUnitTestSuite(t *testing.T) {
	suite.Run(t, new(UnitTestSuite))
}

func (s *UnitTestSuite) Test_Workflow() {
	env := s.NewTestWorkflowEnvironment()
	env.SetTestTimeout(time.Second * 20)
	env.RegisterActivity(Do)
	env.ExecuteWorkflow(Workflow, In{Sleep: 9, Heartbeat: 1})
	s.True(env.IsWorkflowCompleted())
	s.NoError(env.GetWorkflowError())
	env.AssertExpectations(s.T())
}
```

## Specifications
  - Version: 
  - Platform: testing locally


#### Comments (5)

<details>
<summary><strong>gugabfigueiredo</strong> commented on 2023-11-03 09:21:00.000 UTC</summary>

as pointed out in the #1167 , activity timeouts are hardcoded to 10min in [testWorkflowEnvironmentImpl.executeActivity](https://github.com/temporalio/sdk-go/blob/0352634b45b1b81293c9bf3cec3bb033b82f841f/internal/internal_workflow_testsuite.go#L557)

```go
func (env *testWorkflowEnvironmentImpl) executeActivity(
	activityFn interface{},
	args ...interface{},
) (converter.EncodedValue, error) {

        ...

	parameters := ExecuteActivityParams{
		ExecuteActivityOptions: ExecuteActivityOptions{
			ScheduleToCloseTimeout: 600 * time.Second,
			StartToCloseTimeout:    600 * time.Second,
		},
		ActivityType: *activityType,
		Input:        input,
		Header:       env.header,
	}

        ...
}
```

heartbeatTimeouts are straight up ignored

as a workaround I have been testing for consistent heartbeat strategies with the following, changing the code in `workflow_test.go`:
```go
func (s *UnitTestSuite) Test_Workflow() {
	env := s.NewTestWorkflowEnvironment()
	env.SetTestTimeout(time.Second * 1)
	env.RegisterActivity(Do)
        defer func() {
		err := recover()
		if r != nil {
			s.True(strings.HasPrefix(err.(string), "test timeout"))
		}
	}()
	env.ExecuteWorkflow(Workflow, In{Sleep: 9, Heartbeat: 2})
}
```

when heartbeats are set appropriately, they will keep test workflow alive and it is possible to test for consistent timeout error over longer workload.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-11-03 15:00:38.000 UTC</summary>

The workflow test environment is meant mostly for just testing workflows though it has some activity support. You should use a `TestActivityEnvironment` to test activity behavior, and if you want to test how a workflow reacts to an activity result/failure, you can mock it. If you must test these together with real-world behavior semantics, you should use a real server (e.g. `testsuite.StartDevServer`).

</details>

<details>
<summary><strong>gugabfigueiredo</strong> commented on 2023-11-05 11:59:40.000 UTC</summary>

a `TestActivityEnvironment` is just a wrapper for`testWorkflowEnvironmentImpl` ([/internal/workflow_testsuite.go#L70](https://github.com/temporalio/sdk-go/blob/0352634b45b1b81293c9bf3cec3bb033b82f841f/internal/workflow_testsuite.go#L70))
```go
	// TestActivityEnvironment is the environment that you use to test activity
	TestActivityEnvironment struct {
		impl *testWorkflowEnvironmentImpl
	}
```

which means that when running activities, the same limitations apply, this makes the test environment ignore developer setup and not behave as expected, as we cannot provide or set ExecuteActivityOptions.

[Edit]: In my case, I was just trying to validate heartbeat strategies considering different workloads

will try `testsuite.StartDevServer`, which at least I can write into tests to get the expected behavior

</details>

<details>
<summary><strong>gugabfigueiredo</strong> commented on 2023-11-05 20:30:07.000 UTC</summary>

 > will try `testsuite.StartDevServer`, which at least I can write into tests to get the expected behaviour

This worked for my needs ([see here](https://gist.github.com/gugabfigueiredo/ab64a66fac1fc2fc05c97c737da4a6f6)).

I suppose then it comes to temporal developers wether there is a use case or not for normal configurations to the Activity and Workflow test environments.

Personally, I would argue in favour of test environment interface being able to deal with this, as it seems like a lot of work to validate implementation against a simple feature. The heartbeat timeout is still set by the internal implementation, its just set to zero value while other timeouts are hardcoded ([/internal/internal_workflow_testsuite.go#L579](https://github.com/temporalio/sdk-go/blob/0352634b45b1b81293c9bf3cec3bb033b82f841f/internal/internal_workflow_testsuite.go#L579)):

```go
	parameters := ExecuteActivityParams{
		ExecuteActivityOptions: ExecuteActivityOptions{
			ScheduleToCloseTimeout: 600 * time.Second,
			StartToCloseTimeout:    600 * time.Second,
		},
		ActivityType: *activityType,
		Input:        input,
		Header:       env.header,
	}

...

	scheduleTaskAttr.HeartbeatTimeout = &parameters.HeartbeatTimeout

...
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-11-06 13:55:24.000 UTC</summary>

> a `TestActivityEnvironment` is just a wrapper for `testWorkflowEnvironmentImpl` [...] which means that when running activities, the same limitations apply

But it's a different level of exposed abstraction. The point is that if you want to test how your workflow reacts to a certain type of activity failure, mock that activity and return that error. If you want to test how your activity works regardless of workflow, use the activity environment. If you must test all behaviors of activity and workflow together based on real-time, it may not make sense to use an activity or time-skipping workflow environment, it may make sense to use a real combined one.

Some timeouts we do respect in the workflow environment however, but are on time-skipping basis not based on real time. I will leave this issue open to investigate if real-time heartbeat timeout can/should be respected.

</details>


---

<a id="481"></a>

### #481: Canceling workflow can cause infinite replay attempts

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/481 |
| **State** | CLOSED |
| **Author** | hungcs (hw) |
| **Created** | 2021-06-25 18:50:36.000 UTC (4y 6m ago) |
| **Updated** | 2023-08-29 18:19:38.000 UTC |
| **Closed** | 2023-08-29 18:19:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 15 |
| **Priority Score** | 15 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Canceling a workflow should cancel the workflow without side effects or replays.

## Actual Behavior
Canceling workflows works the majority of the time, but for some cases it returns this error:

`Task processing failed with error Namespace project TaskQueue taskqueue WorkerID 19252@hung-MacBook-Pro.local@ WorkerType WorkflowWorker Error BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event`

This causes Temporal to keep attempting replays with `Attempt 1` until the workflow is terminated manually. The workflow is marked as `running` when it should be `canceled`. In the logs, the workflow is canceled at the same activity step `(WaitQueryCompleteActivity)`, but one succeeds and other fails with the error and keeps replaying.

## Steps to Reproduce the Problem

1. `ExecuteQueryWorkflow (workflow.ActivityOptions{WaitForCancellation:    true})`
  - workflow.ExecuteLocalActivity(CreateQueryActivity)
  - workflow.ExecuteLocalActivity(RunQueryActivity)
  - f(ctx, data)
  -- workflow.ExecuteActivity(ctx, WaitQueryCompleteActivity, engine).Get(ctx, nil)....

2. client.CancelWorkflow(context.Background(), getQueryWorkflowID(queryId), "")

possibly related?: https://github.com/temporalio/sdk-go/issues/469

## Specifications

  - Version:
 -- go.temporal.io/api v1.4.1-0.20210420220407-6f00f7f98373
-- go.temporal.io/sdk v1.7.0
  - Platform:
  -- Mac

Logs:
[query 118 success- 8546f839-3403-4841-af11-a25ba8ca91eb.json.txt](https://github.com/temporalio/sdk-go/files/6718209/query.118.success-.8546f839-3403-4841-af11-a25ba8ca91eb.json.txt)
[query 119 succes - 5c3e2e65-44b7-4899-ab0d-fbf29ab21106.json.txt](https://github.com/temporalio/sdk-go/files/6718210/query.119.succes.-.5c3e2e65-44b7-4899-ab0d-fbf29ab21106.json.txt)



#### Comments (15)

<details>
<summary><strong>Sushisource</strong> commented on 2021-07-06 21:20:00.000 UTC</summary>

@hungcs If you happen to have some minimal sample code that reproduces the issue that would be much appreciated

</details>

<details>
<summary><strong>azuisleet</strong> commented on 2021-08-13 12:26:42.000 UTC</summary>

This is a result of the state machine in sdk-go completing an activity and concurrently a cancel request also issuing a cancel for the same activity.

In temporal-server, `HasActivityFinishEvent` is supposed to check for something like this, but when an activity completes, it calls `DeleteActivity` which clears all the related fields. It's not clear me to how `HasActivityFinishEvent` is meant to check for completed activities.

I will put together a sample when I get a chance, but I also need to confirm it's not an issue with the database I'm using.

</details>

<details>
<summary><strong>azuisleet</strong> commented on 2021-08-13 13:21:47.000 UTC</summary>

I have created a sample that shows this issue. 

Here is the worker:
https://gist.github.com/azuisleet/e136167e54b92b33ea45f5d3f21ac7ea

And a command to dispatch the workflow, and then cancel it at the same time as the activity:
https://gist.github.com/azuisleet/6bb9dc621e10db21dfeee12c5b46e22c

This works consistently regardless of the storage engine. The workflow becomes stuck trying to cancel a completed activity, with the server reporting the error message described above:

```
temporal                | {"level":"warn","ts":"2021-08-13T13:17:20.025Z","msg":"invalid history builder state for action","service":"history","shard-id":1,"address":"172.24.0.3:7234","shard-item":"0xc000662280","component":"history-cache","wf-action":"add-activitytask-cancel-requested-event","wf-history-event-id":12,"error-type":"InvalidHistoryAction","bool":false,"wf-schedule-id":5,"wf-id":"b639b495-490f-4958-8ae9-013374c3b6fc","wf-run-id":"e3745b20-6361-4a79-a215-805bfe82b733","wf-namespace-id":"34e86ca4-28e1-445d-8a7e-1f9a6d863d9c","logging-call-at":"mutable_state_impl.go:4400"}
temporal                | {"level":"info","ts":"2021-08-13T13:17:20.025Z","msg":"Failing the workflow task.","service":"history","shard-id":1,"address":"172.24.0.3:7234","shard-item":"0xc000662280","component":"history-engine","value":"BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event","wf-id":"b639b495-490f-4958-8ae9-013374c3b6fc","wf-run-id":"e3745b20-6361-4a79-a215-805bfe82b733","wf-namespace-id":"34e86ca4-28e1-445d-8a7e-1f9a6d863d9c","logging-call-at":"workflowTaskHandlerCallbacks.go:469"}
```

</details>

<details>
<summary><strong>azuisleet</strong> commented on 2021-08-13 21:13:26.000 UTC</summary>

Should activities be allowed to complete if a `WorkflowExecutionCancelRequested` has already been persisted in the workflow history? (`mutableState.IsCancelRequested()` being true). It seems like this isn't allowed given that the mutable state removes all traces of the activity upon completion.

</details>

<details>
<summary><strong>mnussbaum</strong> commented on 2021-11-09 21:01:09.000 UTC</summary>

I'm also seeing this issue every time I run the cancellation go sample at https://github.com/temporalio/samples-go/tree/main/cancellation

</details>

<details>
<summary><strong>hungcs</strong> commented on 2021-11-09 21:04:04.000 UTC</summary>

@mnussbaum what version of ~~Go~~ Temporal are you using? This was supposed to be fixed in [1.9](https://github.com/temporalio/sdk-go/releases/tag/v1.9.0), wondering if you're still encountering this

</details>

<details>
<summary><strong>mnussbaum</strong> commented on 2021-11-09 21:11:35.000 UTC</summary>

Go version:

```
$ go version
go version go1.17.3 linux/amd64
```

When I run the cancellation example's `cancellation/cancel/main.go` the worker from that example starts printing these lines indefinitely:

```
2021/11/09 15:58:54 INFO  heartbeating... Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ ActivityID 5 ActivityType ActivityToBeCanceled Attempt 1 WorkflowType YourWo
rkflow WorkflowID workflowID-to-cancel RunID dd0b6b04-d04b-4859-9e66-5ceac0780548
2021/11/09 15:58:54 INFO  context is cancelled Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ ActivityID 5 ActivityType ActivityToBeCanceled Attempt 1 WorkflowType Y
ourWorkflow WorkflowID workflowID-to-cancel RunID dd0b6b04-d04b-4859-9e66-5ceac0780548
2021/11/09 15:58:54 INFO  ActivityToBeCanceled returns I am canceled by Done, <nil> Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ WorkflowType YourWorkflow Workflow
ID workflowID-to-cancel RunID dd0b6b04-d04b-4859-9e66-5ceac0780548 Attempt 1
2021/11/09 15:58:54 DEBUG ExecuteActivity Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ WorkflowType YourWorkflow WorkflowID workflowID-to-cancel RunID dd0b6b04-d04
b-4859-9e66-5ceac0780548 Attempt 1 ActivityID 15 ActivityType ActivityToBeSkipped
2021/11/09 15:58:54 DEBUG RequestCancelActivity Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ WorkflowType YourWorkflow WorkflowID workflowID-to-cancel RunID dd0b6b
04-d04b-4859-9e66-5ceac0780548 Attempt 1 ActivityID 15
2021/11/09 15:58:54 INFO  Task processing failed with error Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ WorkerType WorkflowWorker Error BadRequestCancelActivityAt
tributes: invalid history builder state for action: add-activitytask-cancel-requested-event
2021/11/09 15:59:04 DEBUG Cached state staled, new task has unexpected events Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ WorkflowID workflowID-to-cancel RunID dd
0b6b04-d04b-4859-9e66-5ceac0780548 Attempt 2 CachedPreviousStartedEventID 14 TaskFirstEventID 1 TaskStartedEventID 20 PreviousStartedEventID 8
```

I believe this is the same issue based on the same `invalid history builder state for action` message in the original post, but my apologies if this is a different issue

</details>

<details>
<summary><strong>hungcs</strong> commented on 2021-11-09 21:13:46.000 UTC</summary>

sorry, I meant the temporal version 

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-09 21:23:43.000 UTC</summary>

@mnussbaum - I may have been able to replicate and this may be showing us an issue we've been seeing. I will confirm and get back.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>mnussbaum</strong> commented on 2021-11-09 21:24:05.000 UTC</summary>

I'm running temporal locally via the latest version of https://github.com/temporalio/docker-compose, which I believe is running on 1.13.0

</details>

<details>
<summary><strong>azuisleet</strong> commented on 2021-11-09 22:31:34.000 UTC</summary>

(Edited, my mistake) this issue occurred for me pre-1.10.0.

Cancelling a workflow concurrently with an activity completion creates an invalid state: The go state machine is trying cancel everything, even though it should actually replay the last activity completion event, due to the ordering of events in the workflow history, the cancel event appears before the completion event, hence the suggestion in https://github.com/temporalio/sdk-go/issues/481#issuecomment-898723337 that this may be a temporal service issue.

If the Go state machine were allowed to potentially replay "alternate branches" beyond the cancel event, it would also be able to un-stuck itself.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-09 22:56:41.000 UTC</summary>

I have opened #623 to address this.

</details>

<details>
<summary><strong>azuisleet</strong> commented on 2021-11-09 23:02:07.000 UTC</summary>

My mistake, I didn't check the version of the SDK when I was testing. I think the issue was actually mitigated with #504

When I upgrade to 1.11.0 and temporal 1.13.1, I cannot reproduce the issue, as the cancel always appears first in the event history:

![image](https://user-images.githubusercontent.com/712742/141019248-7a4beba0-824a-4a35-9f56-8b4d4b795bfb.png)

edit:
Updated my comment. I also checked v1.8.0, v1.9.0, and v1.10.0. The issue stops occurring in v1.10.0



</details>

<details>
<summary><strong>mnussbaum</strong> commented on 2021-11-10 05:40:13.000 UTC</summary>

The temporal samples-go repo looks like it's on sdk version 1.11.0 from https://github.com/temporalio/samples-go/blob/main/go.mod#L16. Do you think the error I'm seeing from the sample's cancellation example is a different issue?

```
2021/11/09 15:58:54 INFO  Task processing failed with error Namespace default TaskQueue cancel-activity WorkerID 483128@tecopa@ WorkerType WorkflowWorker Error BadRequestCancelActivityAt
tributes: invalid history builder state for action: add-activitytask-cancel-requested-event
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-08-29 18:19:38.000 UTC</summary>

The issue created as part of this was solved.

Reactions: ðŸ‘ 1

</details>


---

<a id="89"></a>

### #89: Refactor SDK to avoid type aliasing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/89 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-07 20:02:44.000 UTC (5y 9m ago) |
| **Updated** | 2025-02-04 18:12:35.000 UTC |
| **Upvotes** | 7 |
| **Comments** | 1 |
| **Priority Score** | 15 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 7 |

#### Description

The current generation of tools doesn't work well with type aliasing which is used to separate internal implementation and public APIs of the Go SDK.

The proposal is to create public copies of al interfaces and structures and cast them to/from internal.



#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2020-04-07 20:05:28.000 UTC</summary>

Related issue: #61 

Reactions: ðŸ‘ 1

</details>


---

<a id="1537"></a>

### #1537: Unable to connect to cluster after updating to 1.27.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1537 |
| **State** | CLOSED |
| **Author** | theverything (Jeffrey Horn) |
| **Created** | 2024-07-03 19:53:13.000 UTC (1y 6m ago) |
| **Updated** | 2024-07-03 20:45:56.000 UTC |
| **Closed** | 2024-07-03 20:45:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 14 |
| **Priority Score** | 14 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When using the go SDK I should be able to connect to the server.

## Actual Behavior

When using go SDK version `1.27.0` I get `failed reaching server: context deadline exceeded` when trying to connect to the server.

## Steps to Reproduce the Problem

The sdk version was bumped from `1.26.1` to `1.27.0` in the cli

  1. use the `temporal` cli @v0.13.0 `temporal operator cluster system` call succeeds 
  1. use the `temporal` cli @v0.13.1 `temporal operator cluster system` call fails 

## Specifications

  - Version: temporal server `v1.22.0`
  - Platform: Mac


#### Comments (14)

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 19:54:41.000 UTC</summary>

I didn't see anything in the release notes about min version of temporal server required

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 19:55:11.000 UTC</summary>

The Go SDK has no minimum version of the server required

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 19:56:16.000 UTC</summary>

To be clear is the bug report the `temporal` cli cannot connect to the server or the Go SDK cannot connect?

</details>

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 20:11:49.000 UTC</summary>

> To be clear is the bug report the `temporal` cli cannot connect to the server or the Go SDK cannot connect?

Go SDK. The reproduce steps use the temporal cli because it has the same issue.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 20:17:20.000 UTC</summary>

Testing `temporal` `v0.13.0` and `v0.13.1` I have not issue connecting to my local Temporal server or Temporal Cloud. The Go SDK integration tests also verify connecting against a local server started with docker, a local server started with the CLI and Temporal Cloud. Could you provide some additional details about how you are setting up your server and trying to connect?

</details>

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 20:21:07.000 UTC</summary>

Additional context.

We use tls to connect. Here is a basic go program. This works with `v1.26.1` and fails with `1.27.0`

```
package main

import (
	"context"
	"crypto/tls"
	"net"

	"go.temporal.io/sdk/client"
)

func main() {
	addr := "temporal-frontend.internal.net:443"
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		panic(err)
	}

	c, err := client.Dial(client.Options{
		HostPort:  addr,
		Namespace: "default",
		ConnectionOptions: client.ConnectionOptions{
			TLS: &tls.Config{
				MinVersion: tls.VersionTLS12,
				NextProtos: []string{
					"h2",
				},
				ServerName:         host,
				InsecureSkipVerify: false,
			},
		},
	})
	if err != nil {
		panic(err)
	}

	defer c.Close()

	_, err = c.CheckHealth(context.Background(), &client.CheckHealthRequest{})
	if err != nil {
		panic(err)
	}

	println("SERVING")
}
```

</details>

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 20:25:14.000 UTC</summary>

The equivalent cli command would look like 

`temporal operator cluster health --address=temporal-frontend.internal.net:443 --tls`

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 20:25:26.000 UTC</summary>

Can you try  specifying `addr :=  "passthrough:///temporal-frontend.internal.net:443"`


</details>

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 20:27:55.000 UTC</summary>

> Can you try specifying `addr := "passthrough:///temporal-frontend.internal.net:443"`

`address passthrough:///temporal-frontend.internal.net:443: too many colons in address`

</details>

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 20:31:03.000 UTC</summary>

Looks like I need to add the `passthrough:///` only to the `HostPort` config key. When I do that it works.

```
package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"net"

	"go.temporal.io/sdk/client"
)

func main() {
	addr := "axon-temporal-frontend.dna-compute-qa.zg-int.net:443"
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		panic(err)
	}

	c, err := client.Dial(client.Options{
		HostPort:  fmt.Sprintf("passthrough:///%s", addr),
		Namespace: "default",
		Identity:  "hello-world",
		ConnectionOptions: client.ConnectionOptions{
			TLS: &tls.Config{
				MinVersion: tls.VersionTLS12,
				NextProtos: []string{
					"h2",
				},
				ServerName:         host,
				InsecureSkipVerify: false,
			},
		},
	})
	if err != nil {
		panic(err)
	}

	defer c.Close()

	_, err = c.CheckHealth(context.Background(), &client.CheckHealthRequest{})
	if err != nil {
		panic(err)
	}

	println("SERVING")
}
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 20:31:51.000 UTC</summary>

Yes, sorry I missed the line where you are also trying to extract the host name as well.

</details>

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 20:32:42.000 UTC</summary>

Is the `passthrough:///` documented somewhere? 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 20:34:33.000 UTC</summary>

Yes it is called out in the release notes 

edit: Specifically under `Internally call grpc.NewClient instead of grpc.Dial`

https://github.com/temporalio/sdk-go/releases/tag/v1.27.0

https://grpc.io/docs/guides/custom-name-resolution/

</details>

<details>
<summary><strong>theverything</strong> commented on 2024-07-03 20:38:09.000 UTC</summary>

Thank you for your help @Quinn-With-Two-Ns 

Reactions: â¤ï¸ 1

</details>


---

<a id="1352"></a>

### #1352: Serialization context for codecs and converters

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1352 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-14 05:21:21.000 UTC (1y 12m ago) |
| **Updated** | 2025-10-14 20:56:37.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 6 |
| **Priority Score** | 14 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

**Is your feature request related to a problem? Please describe.**
Context aware data converters should have some way to get ID of outbound activities and child workflows when the data converter is being used to serialize activity input or child workflow input. This is useful if the data converter changes behaviour based on the workflow ID, for example using the ID as associated data for encryption.

In the Java SDK this is trivial because the Java SDK will pass the child workflow ID to the data converter when serializing the child workflow input

**Describe the solution you'd like**
I can think of acceptable solutions:
1. Users could create an interceptor to manually set the activity ID/ child workflow ID, maybe the SDK can provide some random generator to help create deterministic UUIDs. Other SDK already have helpers for this so maybe it is worth doing regardless.

2. Ideally the ID would be accessible in the `WithContext` or `WithWorkflowContext` call on the data converter. When we generate the ID in question we could set it on the context and pass that context with the ID to the context aware data converter. This would require some minor refactoring to when the SDK generates an activity ID/ child workflow ID


#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2024-01-16 13:55:36.000 UTC</summary>

I vote option 2. In theory one shouldn't expect an activity or workflow context to even be created without associated info that contains their ID.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-03-25 18:11:55.000 UTC</summary>

Also see the features repo issue of https://github.com/temporalio/features/issues/434

</details>

<details>
<summary><strong>ddworken</strong> commented on 2025-06-18 21:10:05.000 UTC</summary>

I just wanted to +1 this feature request, especially option 2. Getting access to the workflow ID in the codec is critical to mitigating replay attacks (as described [here](https://github.com/temporalio/features/issues/434)) so it would be quite useful if Go exposed this ability. 

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2025-10-07 17:23:39.000 UTC</summary>

Make sure to include nexus per https://github.com/temporalio/features/issues/678

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-07 23:13:20.000 UTC</summary>

@Sushisource only the input to a Nexus operations can have a serialization context, not the output. This is due to async operations like Workflows

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-10-14 20:56:36.000 UTC</summary>

I updated the title to more accurately represent what this is

</details>


---

<a id="1158"></a>

### #1158: Add slog logger implementation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1158 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-07-10 15:28:12.000 UTC (2y 6m ago) |
| **Updated** | 2025-10-20 13:02:38.000 UTC |
| **Closed** | 2023-09-01 14:09:00.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 10 |
| **Priority Score** | 14 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

**Describe the solution you'd like**

Now that https://pkg.go.dev/log/slog is a thing, we would like to add something like:

```go
type slogLogger struct{ underlying *slog.Logger }

var _ log.Logger = (*slogLogger)(nil)
var _ log.WithLogger = (*slogLogger)(nil)

func NewStructuredLogger(underlying *slog.Logger) log.Logger   { return &slogLogger{underlying} }
func (s *slogLogger) Debug(msg string, keyvals ...interface{}) { s.underlying.Debug(msg, keyvals...) }
func (s *slogLogger) Info(msg string, keyvals ...interface{})  { s.underlying.Info(msg, keyvals...) }
func (s *slogLogger) Warn(msg string, keyvals ...interface{})  { s.underlying.Warn(msg, keyvals...) }
func (s *slogLogger) Error(msg string, keyvals ...interface{}) { s.underlying.Error(msg, keyvals...) }
func (s *slogLogger) With(keyvals ...interface{}) log.Logger {
	return &slogLogger{s.underlying.With(keyvals...)}
}
```

But, we can't do it yet because it's not in the oldest Go version we support. So once it is we can add that. In the meantime, a sample can be added or people can just refer to this issue for that simple implementation.

#### Comments (10)

<details>
<summary><strong>cretz</strong> commented on 2023-07-10 15:34:16.000 UTC</summary>

Actually, what's interesting is that if you ignore `log.WithLogger`, you can just provide an `*slog.Logger` directly since our interface conforms. How lucky.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-19 13:44:08.000 UTC</summary>

>But, we can't do it yet because it's not in the oldest Go version we support

Why do we need to wait? Can't we include the logger conditionally on the go version with build tags?


</details>

<details>
<summary><strong>cretz</strong> commented on 2023-07-19 13:51:53.000 UTC</summary>

Ah, yes, build tags work. Can impl whenever. May at least want to wait until officially released (because we need to update CI to that Go version to confirm this code works).

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-11 16:02:09.000 UTC</summary>

Since `slog` already satisfies are logger interface, what is the value of wrapping?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-08-11 17:24:47.000 UTC</summary>

None, can document instead. Technically explicitly implementing `With` could help in some performance cases, but :shrug:.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-21 16:55:56.000 UTC</summary>

It may still be worth adding a wrapper to support https://github.com/temporalio/sdk-go/issues/960

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Nikola-Milovic</strong> commented on 2024-05-05 07:00:13.000 UTC</summary>

Is this still valid?

```
cannot convert slog.Default() (value of type *slog.Logger) to type "go.temporal.io/sdk/log".WithLogger: 
*slog.Logger does not implement "go.temporal.io/sdk/log".WithLogger (wrong type for method With)		
   have With(...any) *slog.Logger		
   want With(...interface{}) "go.temporal.io/sdk/log".Logger
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-05 17:21:56.000 UTC</summary>

@Nikola-Milovic not sure what you mean by "valid"?  To use `slog` with the Go SDK you can use our wrapper https://pkg.go.dev/go.temporal.io/sdk/log#NewStructuredLogger to convert an `slog` logger to our logger interfaces.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>emre-aydin</strong> commented on 2025-10-20 06:37:46.000 UTC</summary>

@Quinn-With-Two-Ns is this safe to use in an activity? What we normally do is this:

```
log.With(activity.GetLogger(ctx), ..._
```

Is it OK to use it instead of `activity.GetLogger`?


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-20 13:02:38.000 UTC</summary>

@emre-aydin If you are using slog with the Go SDK you would still use `activity.GetLogger(ctx)` to get the logger with appropriate keys 

</details>


---

<a id="658"></a>

### #658: gogo/protobuf is unmaintained

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/658 |
| **State** | CLOSED |
| **Author** | pquerna (Paul Querna) |
| **Created** | 2021-12-01 21:52:48.000 UTC (4y 1m ago) |
| **Updated** | 2024-04-15 15:29:36.000 UTC |
| **Closed** | 2023-11-21 22:24:54.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 6 |
| **Priority Score** | 14 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | tdeebswihart |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

## Expected Behavior
`github.com/gogo/protobuf` is unmaintained: https://github.com/gogo/protobuf/issues/691

At this point it would be nice for the Client SDK to consider using the standard protobuf library.

## Actual Behavior

Seems blocked on https://github.com/temporalio/temporal/issues/38

But `google.golang.org/protobuf` is the defacto dependency at this point, and the client SDK, its unclear if the performance concerns are warranted for general purpose worker clients or other non-temrporal core uses of the APIs?

#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2021-12-03 16:02:36.000 UTC</summary>

Yes, there are discussions to be had on whether the performance difference is worth it. I am gathering feedback from others.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-09 19:21:29.000 UTC</summary>

Yes, this issue is blocked on https://github.com/temporalio/temporal/issues/38 or similar since we share https://github.com/temporalio/api-go. I will leave this open pending that issue.

</details>

<details>
<summary><strong>ash2k</strong> commented on 2024-01-31 07:30:35.000 UTC</summary>

This issue is closed but the gogo dependency is still in the go.mod file. Any chances of getting rid of it completely? Also, would be nice to get a release with the change. Thank you.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-31 17:25:14.000 UTC</summary>

gogoproto is still in the mod file because `ProtoJSONPayloadConverter` and `ProtoPayloadConverter` support gogoproto structs and we did not remove support for backwards compatibility

</details>

<details>
<summary><strong>vikstrous2</strong> commented on 2024-04-15 15:12:41.000 UTC</summary>

Can you guys find a way to make this dependency optional? How long is this backwards compatibility code needed?

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-04-15 15:29:34.000 UTC</summary>

Usually quite a while. But this dependency should be harmless if you don't use it, it's only for people that still use gogoproto in _their_ protos. Can you clarify the issues that this dependency is causing?

</details>


---

<a id="1382"></a>

### #1382: workflowcheck v0.1.0 fails with Go 1.22

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1382 |
| **State** | CLOSED |
| **Author** | dancavallaro (Dan Cavallaro) |
| **Created** | 2024-02-08 18:28:55.000 UTC (1y 11m ago) |
| **Updated** | 2024-03-13 15:25:10.000 UTC |
| **Closed** | 2024-03-13 15:25:10.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 5 |
| **Priority Score** | 13 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

## Expected Behavior
workflowcheck@latest (which points to 0.1.0, the only version available at pkg.go.dev) should work with the Go 1.22 toolchain.

## Actual Behavior
When built with Go 1.22, workflowcheck fails with:

```
panic: runtime error: invalid memory address or nil pointer dereference [recovered]
	panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x1908f0]

goroutine 68 [running]:
go/types.(*Checker).handleBailout(0x400019e200, 0x4000247b98)
	/usr/local/go/src/go/types/check.go:367 +0x9c
panic({0x316ee0?, 0x5b3c50?})
	/usr/local/go/src/runtime/panic.go:770 +0x124
go/types.(*StdSizes).Sizeof(0x0, {0x3ee798, 0x5b78a0})
	/usr/local/go/src/go/types/sizes.go:228 +0x320
go/types.(*Config).sizeof(...)
	/usr/local/go/src/go/types/sizes.go:333
go/types.representableConst.func1({0x3ee798?, 0x5b78a0?})
	/usr/local/go/src/go/types/const.go:76 +0x9c
go/types.representableConst({0x3efe30, 0x5ac4e0}, 0x400019e200, 0x5b78a0, 0x4000245f98)
	/usr/local/go/src/go/types/const.go:92 +0x138
go/types.(*Checker).representation(0x400019e200, 0x4000071600, 0x5b78a0)
	/usr/local/go/src/go/types/const.go:256 +0x68
go/types.(*Checker).implicitTypeAndValue(0x400019e200, 0x4000071600, {0x3ee798, 0x5b78a0})
	/usr/local/go/src/go/types/expr.go:375 +0x340
go/types.(*Checker).convertUntyped(0x400019e200, 0x4000071600, {0x3ee798, 0x5b78a0})
	/usr/local/go/src/go/types/const.go:289 +0x30
go/types.(*Checker).matchTypes(0x400019e200, 0x40000715c0, 0x4000071600)
	/usr/local/go/src/go/types/expr.go:926 +0x7c
go/types.(*Checker).binary(0x400019e200, 0x40000715c0, {0x3ef340, 0x40000743c0}, {0x3eefb0, 0x40000109c0}, {0x3ef850, 0x40000109e0}, 0x28, 0x359a)
	/usr/local/go/src/go/types/expr.go:800 +0x114
go/types.(*Checker).exprInternal(0x400019e200, 0x0, 0x40000715c0, {0x3ef340, 0x40000743c0}, {0x0, 0x0})
	/usr/local/go/src/go/types/expr.go:1416 +0x1d4
go/types.(*Checker).rawExpr(0x400019e200, 0x0, 0x40000715c0, {0x3ef340?, 0x40000743c0?}, {0x0?, 0x0?}, 0x0)
	/usr/local/go/src/go/types/expr.go:979 +0x12c
go/types.(*Checker).expr(0x400019e200, 0x3ee540?, 0x40000715c0, {0x3ef340?, 0x40000743c0?})
	/usr/local/go/src/go/types/expr.go:1513 +0x38
go/types.(*Checker).stmt(0x400019e200, 0x0, {0x3ef6a0, 0x4000070880})
	/usr/local/go/src/go/types/stmt.go:570 +0xdb0
go/types.(*Checker).stmtList(0x400019e200, 0x0, {0x4000010b40?, 0x0?, 0x0?})
	/usr/local/go/src/go/types/stmt.go:121 +0x88
go/types.(*Checker).funcBody(0x400019e200, 0x3ee798?, {0x400000e3f0?, 0x5b7a80?}, 0x4000071300, 0x4000074450, {0x0?, 0x0?})
	/usr/local/go/src/go/types/stmt.go:41 +0x21c
go/types.(*Checker).funcDecl.func1()
	/usr/local/go/src/go/types/decl.go:852 +0x44
go/types.(*Checker).processDelayed(0x400019e200, 0x0)
	/usr/local/go/src/go/types/check.go:467 +0x12c
go/types.(*Checker).checkFiles(0x400019e200, {0x4000048120, 0x1, 0x1})
	/usr/local/go/src/go/types/check.go:411 +0x188
go/types.(*Checker).Files(...)
	/usr/local/go/src/go/types/check.go:372
golang.org/x/tools/go/packages.(*loader).loadPackage(0x4000120000, 0x40001729c0)
	/go/pkg/mod/golang.org/x/tools@v0.10.0/go/packages/packages.go:1055 +0x870
golang.org/x/tools/go/packages.(*loader).loadRecursive.func1()
	/go/pkg/mod/golang.org/x/tools@v0.10.0/go/packages/packages.go:854 +0x178
sync.(*Once).doSlow(0x0?, 0x0?)
	/usr/local/go/src/sync/once.go:74 +0x100
sync.(*Once).Do(...)
	/usr/local/go/src/sync/once.go:65
golang.org/x/tools/go/packages.(*loader).loadRecursive(0x0?, 0x0?)
	/go/pkg/mod/golang.org/x/tools@v0.10.0/go/packages/packages.go:842 +0x50
golang.org/x/tools/go/packages.(*loader).loadRecursive.func1.1(0x0?)
	/go/pkg/mod/golang.org/x/tools@v0.10.0/go/packages/packages.go:849 +0x30
created by golang.org/x/tools/go/packages.(*loader).loadRecursive.func1 in goroutine 16
	/go/pkg/mod/golang.org/x/tools@v0.10.0/go/packages/packages.go:848 +0x84
exit status 2
```

As far as I can tell, this is a known/expected issue resulting from a Go change in 1.22: https://github.com/golang/go/issues/62167. Other libraries/packages have also run into this and fixed it, e.g. https://github.com/ent/ent/issues/3864. 

And indeed from what I can tell, you've already fixed this in workflowcheck on HEAD, you just need to publish a new version. TL;DR of the issue, as I understand it, is that Go analyzers when built with the 1.22 toolchain also require a version of `x/tools` at least as new as v0.13.0. workflowcheck's go.mod has x/tools v0.13.0 *now* in the repo, but workflowcheck v0.1.0 depends on x/tools v0.10.0.

## Steps to Reproduce the Problem

Minimal example showing the error with Go 1.22:

```
> cat main.go
package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}
> docker run -it --rm -v .:/workflowcheck --workdir /workflowcheck golang:1.22-bookworm sh -c "go run go.temporal.io/sdk/contrib/tools/workflowcheck@latest main.go"
go: downloading go.temporal.io/sdk v1.25.1
go: downloading go.temporal.io/sdk/contrib/tools/workflowcheck v0.1.0
go: downloading golang.org/x/tools v0.10.0
go: downloading gopkg.in/yaml.v2 v2.4.0
go: downloading golang.org/x/sys v0.9.0
go: downloading golang.org/x/mod v0.11.0
panic: runtime error: invalid memory address or nil pointer dereference [recovered]
	panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x1908f0]
```

But it works fine with Go 1.21.7, as expected:

```
> docker run -it --rm -v .:/workflowcheck --workdir /workflowcheck golang:1.21.7-bookworm sh -c "go run go.temporal.io/sdk/contrib/tools/workflowcheck@latest main.go"
go: downloading go.temporal.io/sdk/contrib/tools/workflowcheck v0.1.0
go: downloading go.temporal.io/sdk v1.25.1
go: downloading golang.org/x/tools v0.10.0
go: downloading gopkg.in/yaml.v2 v2.4.0
go: downloading golang.org/x/sys v0.9.0
go: downloading golang.org/x/mod v0.11.0
>
```

Alternatively, a consumer can work around it by adding workflowcheck to one's go.mod/tools.go while ensuring you have a version of x/tools at least as new as v0.13.0, and then omitting `@latest` when `go install`ing workflowcheck so that it builds in module-aware mode, using the newer version of x/tools from the consumer's go.mod. 

```
> cat go.mod
module github.com/dancavallaro

go 1.22.0

require go.temporal.io/sdk/contrib/tools/workflowcheck v0.1.0

require (
	golang.org/x/mod v0.14.0 // indirect
	golang.org/x/tools v0.17.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
)
> docker run -it --rm -v .:/workflowcheck --workdir /workflowcheck golang:1.22-bookworm sh -c "go run go.temporal.io/sdk/contrib/tools/workflowcheck main.go"
go: downloading go.temporal.io/sdk/contrib/tools/workflowcheck v0.1.0
go: downloading golang.org/x/tools v0.17.0
go: downloading gopkg.in/yaml.v2 v2.4.0
go: downloading golang.org/x/mod v0.14.0
>
```

That seems like a best practice anyway so I'll stick with that, but nonetheless wanted to give you a heads up about this issue so you can publish a new version of workflowcheck. 
## Specifications

  - Version: Go 1.22 toolchain, with workflowcheck v0.1.0
  - Platform:
```
> uname -a
Darwin MAC-KJ9HW94GKX 23.3.0 Darwin Kernel Version 23.3.0: Wed Dec 20 21:31:00 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T6020 arm64
> docker run -it --rm -v .:/workflowcheck --workdir /workflowcheck golang:1.22-bookworm uname -a
Linux c23f0ee858ea 6.5.11-linuxkit #1 SMP PREEMPT Wed Dec  6 17:08:31 UTC 2023 aarch64 GNU/Linux
```

#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-08 18:32:40.000 UTC</summary>

There is already a fix merged for this https://github.com/temporalio/sdk-go/commit/72a5b6fbc0831183fb69d0debb560fdbfc6a8fdb. We will release a `v0.2.0` after the Go SDK is released. 

Reactions: ðŸ‘ 1 â¤ï¸ 3

</details>

<details>
<summary><strong>dancavallaro</strong> commented on 2024-02-08 19:02:59.000 UTC</summary>

Roger! I did see that you'd upgraded x/tools already but I wasn't sure if this specific issue was on your radar for an upcoming release. Thanks for confirming!

</details>

<details>
<summary><strong>guygof</strong> commented on 2024-03-12 13:10:41.000 UTC</summary>

> There is already a fix merged for this [72a5b6f](https://github.com/temporalio/sdk-go/commit/72a5b6fbc0831183fb69d0debb560fdbfc6a8fdb). We will release a `v0.2.0` after the Go SDK is released.

I saw 1.26.0 was released with the fix - will workflowcheck 0.2.0 be released soon? I see the latest version still crashes.
Thanks @Quinn-With-Two-Ns !

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-12 14:00:41.000 UTC</summary>

Yes it will be

Reactions: ðŸŽ‰ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-13 15:25:10.000 UTC</summary>

Closing since workflowcheck v0.2.0 is released https://github.com/temporalio/sdk-go/releases/tag/contrib%2Ftools%2Fworkflowcheck%2Fv0.2.0

</details>


---

<a id="743"></a>

### #743: Concurrent map writes during deferred disconnected context cancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/743 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-25 20:56:32.000 UTC (3y 10m ago) |
| **Updated** | 2023-10-16 15:59:42.000 UTC |
| **Closed** | 2023-10-16 15:59:41.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 8 |
| **Priority Score** | 12 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

## Expected Behavior

No concurrent map writes.

## Actual Behavior

This:

```
fatal error: concurrent map writes

goroutine 369355 [running]:
runtime.throw({0x19714cc, 0x28})
	GOROOT/src/runtime/panic.go:1198 +0x71 fp=0xc00295f418 sp=0xc00295f3e8 pc=0x433b31
runtime.mapassign(0xc00297f350, 0xc002ff1800, 0x141b073)
	GOROOT/src/runtime/map.go:585 +0x4d6 fp=0xc00295f498 sp=0xc00295f418 pc=0x40ead6
go.temporal.io/sdk/internal.(*commandsHelper).addCommand(0xc0013b7680, {0x1d2faa0, 0xc00297f350})
	external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:892 +0x1e8 fp=0xc00295f528 sp=0xc00295f498 pc=0x141e328
go.temporal.io/sdk/internal.(*activityCommandStateMachine).cancel(0xc002e6d2d8)
	external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:544 +0x7f fp=0xc00295f558 sp=0xc00295f528 pc=0x141ccdf
go.temporal.io/sdk/internal.(*commandsHelper).requestCancelActivityTask(0xc00295f5b0, {0xc001245310, 0x10000c0005c0800})
	external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:950 +0x39 fp=0xc00295f598 sp=0xc00295f558 pc=0x141eb19
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).RequestCancelActivity(0xc001c98c00, {{0xc001245310, 0x1}})
	external/io_temporal_go_sdk/internal/internal_event_handlers.go:507 +0x38 fp=0xc00295f608 sp=0xc00295f598 pc=0x1423878
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).RequestCancelActivity(0xc001ad0d20, {{0xc001245310, 0x0}})
	<autogenerated>:1 +0x2f fp=0xc00295f630 sp=0xc00295f608 pc=0x146392f
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity.func3({0x15bab80, 0xc00000f3c8}, 0x95)
	external/io_temporal_go_sdk/internal/workflow.go:525 +0x75 fp=0xc00295f670 sp=0xc00295f630 pc=0x145cd35
go.temporal.io/sdk/internal.(*channelImpl).Close(0xc000c12a60)
	external/io_temporal_go_sdk/internal/internal_workflow.go:833 +0x93 fp=0xc00295f6c8 sp=0xc00295f670 pc=0x144d653
go.temporal.io/sdk/internal.(*cancelCtx).cancel(0xc000c12a20, 0x1, {0x1cc83a0, 0xc000420ab0})
	external/io_temporal_go_sdk/internal/context.go:333 +0xe9 fp=0xc00295f778 sp=0xc00295f6c8 pc=0x1412b09
go.temporal.io/sdk/internal.NewDisconnectedContext.func1()
	external/io_temporal_go_sdk/internal/context.go:210 +0x30 fp=0xc00295f7a8 sp=0xc00295f778 pc=0x1412230
runtime.deferCallSave(0xc00295f870, 0xc0026ff420)
	GOROOT/src/runtime/panic.go:950 +0x82 fp=0xc00295f7b8 sp=0xc00295f7a8 pc=0x4332c2
runtime.runOpenDeferFrame(0x1000000004056cd, 0xc0023ae550)
	GOROOT/src/runtime/panic.go:889 +0x27b fp=0xc00295f838 sp=0xc00295f7b8 pc=0x432c5b
runtime.Goexit()
	GOROOT/src/runtime/panic.go:642 +0x187 fp=0xc00295f8b8 sp=0xc00295f838 pc=0x432227
go.temporal.io/sdk/internal.(*coroutineState).exit.func1({0xc0029ec000, 0x19ed8a0}, 0xc0009a0701)
	external/io_temporal_go_sdk/internal/internal_workflow.go:938 +0x17 fp=0xc00295f8c8 sp=0xc00295f8b8 pc=0x14624d7
go.temporal.io/sdk/internal.(*coroutineState).initialYield(0xc00162e1e0, 0x3, {0xc0009a0760, 0x1a})
	external/io_temporal_go_sdk/internal/internal_workflow.go:860 +0x89 fp=0xc00295f8f8 sp=0xc00295f8c8 pc=0x144d949
go.temporal.io/sdk/internal.(*coroutineState).yield(...)
	external/io_temporal_go_sdk/internal/internal_workflow.go:869
go.temporal.io/sdk/internal.(*channelImpl).Receive(0xc001dcf4d0, {0x1cf6e50, 0xc000c12a20}, {0x0, 0x0})
	external/io_temporal_go_sdk/internal/internal_workflow.go:684 +0x245 fp=0xc00295f980 sp=0xc00295f8f8 pc=0x144c6e5
go.temporal.io/sdk/internal.(*decodeFutureImpl).Get(0xc002e6d1b8, {0x1cf6e50, 0xc000c12a20}, {0x0, 0x0})
	external/io_temporal_go_sdk/internal/internal_workflow.go:1334 +0x4c fp=0xc00295f9e0 sp=0xc00295f980 pc=0x145122c
[<...workflow-specific-code...>]
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1(0x0)
	external/io_temporal_go_sdk/internal/internal_workflow.go:971 +0xde fp=0xc00295ffc8 sp=0xc00295ff38 pc=0x144e6be
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutineÂ·dwrapÂ·34()
	external/io_temporal_go_sdk/internal/internal_workflow.go:972 +0x2d fp=0xc00295ffe0 sp=0xc00295ffc8 pc=0x144e5ad
runtime.goexit()
	src/runtime/asm_amd64.s:1581 +0x1 fp=0xc00295ffe8 sp=0xc00295ffe0 pc=0x464101
created by go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine
	external/io_temporal_go_sdk/internal/internal_workflow.go:962 +0x365
```

This seems similar to #721 but a different cancellation path

## Steps to Reproduce the Problem

Still trying to replicate


#### Comments (8)

<details>
<summary><strong>cretz</strong> commented on 2022-03-28 15:40:12.000 UTC</summary>

An issue like this has also been fixed in #741. Despite my best efforts, I have not been able to replicate this concurrent map write and it may have been fixed by #721 or #741. Any replication by anyone hitting this in the latest version would be very helpful.

</details>

<details>
<summary><strong>thomashusa</strong> commented on 2022-06-03 18:26:37.000 UTC</summary>

I may have run into a very similar issue, also during deferred context cancellation:

```


main.main()
'	/src/cmd/worker/main.go:39 +0x229
goroutine 14 [select]:
'	/src/cmd/worker/main.go:83 +0x71
'	/go/pkg/mod/github.com/!data!dog/datadog-go@v4.8.3+incompatible/statsd/sender.go:95 +0xe5
'	/go/pkg/mod/github.com/!data!dog/datadog-go@v4.8.3+incompatible/statsd/sender.go:95 +0xe5
'	<workflow internals>
runtime.deferCallSave(0xc001bf4eb0, 0xc001bf5408)
go.temporal.io/sdk/internal.(*coroutineState).initialYield(0xc003421310, 0x3, {0xc002681480, 0x1b})
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:938 +0x17 fp=0xc001bf4f08 sp=0xc001bf4ef8 pc=0xc06f37
'	/usr/local/go/src/runtime/panic.go:661 +0x1ce fp=0xc001bf4ef8 sp=0xc001bf4e78 pc=0x435e4e
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutineÂ·dwrapÂ·34()
'	<workflow internals>
runtime.Goexit()
'	/usr/local/go/src/runtime/panic.go:950 +0x82 fp=0xc001bf4e78 sp=0xc001bf4e68 pc=0x436ea2
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:962 +0x365
go.temporal.io/sdk/internal.(*coroutineState).exit.func1({0xc0000a76c0, 0x1a7f2d0}, 0xc002681401)
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:971 +0xde fp=0xc001bf5fc8 sp=0xc001bf5f38 pc=0xbf1b1e
created by go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:833 +0x93 fp=0xc001bf4be0 sp=0xc001bf4b88 pc=0xbf0ab3
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:972 +0x2d fp=0xc001bf5fe0 sp=0xc001bf5fc8 pc=0xbf1a0d
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/context.go:196 +0x30 fp=0xc001bf4cc0 sp=0xc001bf4c90 pc=0xbb5050
'	/usr/local/go/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc001bf5fe8 sp=0xc001bf5fe0 pc=0x46aee1
'	<workflow internals>
go.temporal.io/sdk/internal.(*cancelCtx).cancel(0xc003aa4a20, 0x1, {0x1e0ef80, 0xc000216060})
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/context.go:333 +0xe9 fp=0xc001bf4c90 sp=0xc001bf4be0 pc=0xbb5aa9
go.temporal.io/sdk/internal.(*channelImpl).Receive(0xc003aa6b40, {0x1e3e078, 0xc000988ea0}, {0x0, 0x0})
go.temporal.io/sdk/internal.(*coroutineState).yield(...)
'	<workflow internals>
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:860 +0x89 fp=0xc001bf4f38 sp=0xc001bf4f08 pc=0xbf0da9
go.temporal.io/sdk/internal.(*decodeFutureImpl).Get(0xc00353b200, {0x1e3e078, 0xc000988ea0}, {0x1651fe0, 0xc003ab00d0})
runtime.goexit()
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1(0x0)
go.temporal.io/sdk/internal.WithCancel.func1()
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:1334 +0x4c fp=0xc001bf5020 sp=0xc001bf4fc0 pc=0xbf468c
go.temporal.io/sdk/internal.(*channelImpl).Close(0xc003aa4a60)
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_decision_state_machine.go:953 +0x26 fp=0xc001bf4ab0 sp=0xc001bf4a70 pc=0xbc1d66
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/workflow.go:526 +0x75 fp=0xc001bf4b88 sp=0xc001bf4b48 pc=0xc01995
go.temporal.io/sdk/internal.(*commandsHelper).requestCancelActivityTask(0xc001bf4b08, {0xc0044d7e00, 0x10000c001bf4af0})
'	/usr/local/go/src/runtime/panic.go:1198 +0x71 fp=0xc001bf49a0 sp=0xc001bf4970 pc=0x437711
'	/usr/local/go/src/runtime/map.go:469 +0x205 fp=0xc001bf49e0 sp=0xc001bf49a0 pc=0x410385
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).RequestCancelActivity(0xc000bfc0a8, {{0xc0044d7e00, 0x0}})
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity.func3({0x1645ea0, 0xc0047f7f30}, 0xde)
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).RequestCancelActivity(0xc000530300, {{0xc0044d7e00, 0xc002f5bec0}})
go.temporal.io/sdk/internal.(*commandsHelper).getCommand(0xf, {0x1, {0xc0044d7e00, 0x227447d}})
goroutine 2760 [running]:
runtime.mapaccess2(0x0, 0x0, 0x10)
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_decision_state_machine.go:877 +0x65 fp=0xc001bf4a70 sp=0xc001bf49e0 pc=0xbc1285
runtime.throw({0x1a087d3, 0x0})
'	<autogenerated>:1 +0x2f fp=0xc001bf4b48 sp=0xc001bf4b20 pc=0xc083ef
'	/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_event_handlers.go:507 +0x38 fp=0xc001bf4b20 sp=0xc001bf4ab0 pc=0xbc6ad8
fatal error: concurrent map read and map write
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-03 18:34:03.000 UTC</summary>

@thomashusa - Is it possible to replicate this in anyway somewhat reliably? Using the `-race` flag could make it more likely to happen. This can intentionally happen if you're using Go async constructs inside your workflow, but if not, we definitely want to replicate and solve this. As of yet, we've been unable to replicate.

I am going to try some more replication steps as it's clearly around cancelling an activity in a deferred way.

</details>

<details>
<summary><strong>thomashusa</strong> commented on 2022-06-06 19:46:07.000 UTC</summary>

@cretz So far we haven't been able to reliably reproduce it. For us it happens only in production under a lot of load. We're hesitant to run in production with the `-race` flag enabled and are still trying to see if we can reproduce it in development.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-05-25 11:44:56.000 UTC</summary>

https://github.com/temporalio/sdk-go/blob/269b55b8d184849209c6973fe913a427fafc07e3/internal/context.go#L239 seems to start a Goroutine in workflow context which is likely the cause. Will require some effort to fix and confirm compatible.

</details>

<details>
<summary><strong>tdeebswihart</strong> commented on 2023-09-18 21:23:40.000 UTC</summary>

[This may have just happened in CI](https://github.com/temporalio/sdk-go/actions/runs/6227934624/job/16903653066):

```
2023-09-18T21:09:05.0968374Z WARNING: DATA RACE
2023-09-18T21:09:05.0968666Z Read at 0x00c000250fc0 by goroutine 6063:
2023-09-18T21:09:05.0968983Z   runtime.mapaccess2()
2023-09-18T21:09:05.0969463Z       /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/map.go:456 +0x0
2023-09-18T21:09:05.0969904Z   go.temporal.io/sdk/internal.(*commandsHelper).addCommand()
2023-09-18T21:09:05.0970610Z       /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:929 +0xb6
2023-09-18T21:09:05.0971095Z   go.temporal.io/sdk/internal.(*commandsHelper).recordVersionMarker()
2023-09-18T21:09:05.0971828Z       /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1073 +0x512
2023-09-18T21:09:05.0972322Z   go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GetVersion()
2023-09-18T21:09:05.0973013Z       /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:799 +0x734
2023-09-18T21:09:05.0973539Z   go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).GetVersion()
2023-09-18T21:09:05.0973955Z       <autogenerated>:1 +0x78
2023-09-18T21:09:05.0974389Z   go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).GetVersion()
2023-09-18T21:09:05.0975037Z       /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1681 +0x6f
2023-09-18T21:09:05.0975529Z   go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).GetVersion()
2023-09-18T21:09:05.0976364Z       /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:336 +0x9a
2023-09-18T21:09:05.0976885Z   go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).GetVersion()
2023-09-18T21:09:05.0977304Z       <autogenerated>:1 +0x29
2023-09-18T21:09:05.0977640Z   go.temporal.io/sdk/internal.GetVersion()
2023-09-18T21:09:05.0978227Z       /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1677 +0xb7
2023-09-18T21:09:05.0978618Z   go.temporal.io/sdk/workflow.GetVersion()
2023-09-18T21:09:05.0979192Z       /home/runner/work/sdk-go/sdk-go/workflow/workflow.go:384 +0x19e
2023-09-18T21:09:05.0979638Z   go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow()
2023-09-18T21:09:05.0980251Z       /home/runner/work/sdk-go/sdk-go/test/workflow_test.go:2319 +0x113
2023-09-18T21:09:05.0980789Z   go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow-fm()
2023-09-18T21:09:05.0981183Z       <autogenerated>:1 +0x92
2023-09-18T21:09:05.0981460Z   runtime.call64()
2023-09-18T21:09:05.0982008Z       /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/asm_amd64.s:730 +0x48
2023-09-18T21:09:05.0983328Z   reflect.Value.Call()
2023-09-18T21:09:05.0983837Z       /opt/hostedtoolcache/go/1.20.8/x64/src/reflect/value.go:370 +0xc7
2023-09-18T21:09:05.0984248Z   go.temporal.io/sdk/internal.executeFunction()
2023-09-18T21:09:05.0984905Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:1806 +0x5b0
2023-09-18T21:09:05.0985426Z   go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
2023-09-18T21:09:05.0986090Z       /home/runner/work/sdk-go/sdk-go/internal/workflow.go:530 +0x23e
2023-09-18T21:09:05.0986595Z   go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
2023-09-18T21:09:05.0987285Z       /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:154 +0x76
2023-09-18T21:09:05.0987812Z   go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
2023-09-18T21:09:05.0988260Z       <autogenerated>:1 +0x29
2023-09-18T21:09:05.0988742Z   go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
2023-09-18T21:09:05.0989427Z       /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4136 +0x18e
2023-09-18T21:09:05.0989848Z   go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
2023-09-18T21:09:05.0990477Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:805 +0x41a
2023-09-18T21:09:05.0990958Z   go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
2023-09-18T21:09:05.0991621Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:512 +0x189
2023-09-18T21:09:05.0992092Z   go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
2023-09-18T21:09:05.0992760Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1057 +0x165
2023-09-18T21:09:05.0995837Z   go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
2023-09-18T21:09:05.0996566Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1058 +0x47
2023-09-18T21:09:05.0996819Z 
2023-09-18T21:09:05.0996995Z Previous write at 0x00c000250fc0 by goroutine 6062:
2023-09-18T21:09:05.0997322Z   runtime.mapdelete()
2023-09-18T21:09:05.0997796Z       /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/map.go:695 +0x0
2023-09-18T21:09:05.0998255Z   go.temporal.io/sdk/internal.(*commandStateMachineBase).moveState()
2023-09-18T21:09:05.0998968Z       /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:430 +0x646
2023-09-18T21:09:05.0999482Z   go.temporal.io/sdk/internal.(*markerCommandStateMachine).handleCommandSent()
2023-09-18T21:09:05.1000210Z       /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:836 +0xab
2023-09-18T21:09:05.1000675Z   go.temporal.io/sdk/internal.(*commandsHelper).getCommands()
2023-09-18T21:09:05.1001372Z       /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1417 +0x276
2023-09-18T21:09:05.1001919Z   go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).CompleteWorkflowTask()
2023-09-18T21:09:05.1002929Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1244 +0x81b
2023-09-18T21:09:05.1003469Z   go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).applyWorkflowPanicPolicy()
2023-09-18T21:09:05.1004227Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1142 +0x1064
2023-09-18T21:09:05.1004764Z   go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
2023-09-18T21:09:05.1005492Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1088 +0x1676
2023-09-18T21:09:05.1005934Z   go.temporal.io/sdk/internal.executeDispatcher()
2023-09-18T21:09:05.1006564Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:622 +0xc7
2023-09-18T21:09:05.1007053Z   go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted()
2023-09-18T21:09:05.1007734Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:592 +0x88
2023-09-18T21:09:05.1008785Z   go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
2023-09-18T21:09:05.1009528Z       /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1063 +0x602
2023-09-18T21:09:05.1010062Z   go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
2023-09-18T21:09:05.1010803Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
2023-09-18T21:09:05.1011317Z   go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
2023-09-18T21:09:05.1012007Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
2023-09-18T21:09:05.1012511Z   go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
2023-09-18T21:09:05.1013204Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
2023-09-18T21:09:05.1013676Z   go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
2023-09-18T21:09:05.1014339Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
2023-09-18T21:09:05.1014790Z   go.temporal.io/sdk/internal.(*baseWorker).processTask()
2023-09-18T21:09:05.1015419Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
2023-09-18T21:09:05.1015896Z   go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
2023-09-18T21:09:05.1016566Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b
2023-09-18T21:09:05.1016801Z 
2023-09-18T21:09:05.1016941Z Goroutine 6063 (running) created at:
2023-09-18T21:09:05.1017346Z   go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
2023-09-18T21:09:05.1017994Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1048 +0x66e
2023-09-18T21:09:05.1018466Z   go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
2023-09-18T21:09:05.1019140Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:308 +0x86
2023-09-18T21:09:05.1019646Z   go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
2023-09-18T21:09:05.1020338Z       /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4093 +0x201
2023-09-18T21:09:05.1020750Z   go.temporal.io/sdk/internal.newDispatcher()
2023-09-18T21:09:05.1021373Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:614 +0x27e
2023-09-18T21:09:05.1021823Z   go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
2023-09-18T21:09:05.1022467Z       /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:499 +0x1c4
2023-09-18T21:09:05.1023048Z   go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).handleWorkflowExecutionStarted()
2023-09-18T21:09:05.1023824Z       /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1269 +0x36b
2023-09-18T21:09:05.1024353Z   go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
2023-09-18T21:09:05.1025074Z       /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1044 +0x20e
2023-09-18T21:09:05.1025755Z   go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
2023-09-18T21:09:05.1026473Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
2023-09-18T21:09:05.1026989Z   go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
2023-09-18T21:09:05.1027695Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
2023-09-18T21:09:05.1028191Z   go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
2023-09-18T21:09:05.1028882Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
2023-09-18T21:09:05.1029351Z   go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
2023-09-18T21:09:05.1030000Z       /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
2023-09-18T21:09:05.1030504Z   go.temporal.io/sdk/internal.(*baseWorker).processTask()
2023-09-18T21:09:05.1031151Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
2023-09-18T21:09:05.1031811Z   go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
2023-09-18T21:09:05.1032493Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b
2023-09-18T21:09:05.1032729Z 
2023-09-18T21:09:05.1032873Z Goroutine 6062 (running) created at:
2023-09-18T21:09:05.1033263Z   go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync()
2023-09-18T21:09:05.1034094Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:352 +0x139
2023-09-18T21:09:05.1034559Z   go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher()
2023-09-18T21:09:05.1035221Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:382 +0x116
2023-09-18T21:09:05.1035651Z   go.temporal.io/sdk/internal.(*baseWorker).Start.func3()
2023-09-18T21:09:05.1036302Z       /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:284 +0x39
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-09-18 21:38:06.000 UTC</summary>

@tdeebswihart That failure is unrelated to this ticket, both are data races, but the root cause it different. It should be in it's own separate ticket.

edit: new ticket https://github.com/temporalio/sdk-go/issues/1240

Reactions: ðŸš€ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-16 15:59:41.000 UTC</summary>

For anyone reading this issue, the code @cretz pointed was actually dead code and not the cause of the problem. The root cause was actually a race due to how the SDK evicts workflows from cache, more details [here](https://github.com/temporalio/sdk-go/issues/1209). 

There is still some follow up work, but the bug described in this ticket should be resolved in the latest Go SDK `1.25.1`
* https://github.com/temporalio/sdk-go/issues/1270
* https://github.com/temporalio/sdk-go/issues/1235





Reactions: ðŸŽ‰ 1

</details>


---

<a id="1573"></a>

### #1573: gRPC code "Unavailable" is being reported as "Unknown" by temporal SDK Client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1573 |
| **State** | CLOSED |
| **Author** | uritig (guriti) |
| **Created** | 2024-07-31 16:28:32.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-08 22:29:44.000 UTC |
| **Closed** | 2024-08-01 04:42:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 11 |
| **Priority Score** | 11 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Correct gRPC code should be recorded & returned.

## Actual Behavior
gRPC code "Unavailable" is being reported as "Unknown"

## Steps to Reproduce the Problem

  1. Run a temporal server that returns Http 503 Unavailable gRPC code
  2. Verify that the correct code is being received via another client. In my case, I verified in python, a generic gRPC client & with postman. They all confirmed the "Unavailable" code.
 Sample code:
```
func testRawGrpc() {
	var grpcClient *grpc.ClientConn
	var err error
	creds := credentials.NewTLS(&tls.Config{})
	grpcClient, err = grpc.Dial("<host:port>", grpc.WithTransportCredentials(creds), grpc.WithMaxMsgSize(1*1024*1024), grpc.WithTimeout(10*time.Second))
	
	defer grpcClient.Close()

	if err != nil {
		log.Printf("unable to create client: %#v\n", err)
		return
	}

	req := workflowservice.ListNamespacesRequest{
		PageSize:        100,
		NamespaceFilter: &namespace.NamespaceFilter{IncludeDeleted: true},
	}

	resp := workflowservice.ListNamespacesResponse{}

	err = grpcClient.Invoke(context.Background(), "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces", &req, &resp)
	if err != nil {
		log.Printf("unable to ListNamespaces: %#v\n", err)
		grpcErr, _ := status.FromError(err)
		log.Printf("grpcMessage=%v, grpcCode=%v\n", grpcErr.Message(), grpcErr.Code())
		return
	}
	log.Println("ListNamespaces result:", &resp)
}
```
Notice in the logs:
```
...
grpcMessage=no healthy upstream, grpcCode=Unavailable
...
```
  3. Now, try the same with the sdk client
  
```
func testTemporalClient() {
	temporalConnectionOpts := client.ConnectionOptions{
		TLS: &tls.Config{},
	}
	temporalClientOpts := client.Options{
		HostPort:          "<host:port>",
		Namespace:         "default",
		ConnectionOptions: temporalConnectionOpts,
	}
	c, err := client.Dial(temporalClientOpts)
	if err != nil {
		grpcErr, _ := status.FromError(err)
		fmt.Printf("grpcMessage=%v, grpcCode=%v\n", grpcErr.Message(), grpcErr.Code())
		log.Println("Failed to create temporal client:", err)
		return
	}
	defer c.Close()

	req := workflowservice.ListNamespacesRequest{
		PageSize:        100,
		NamespaceFilter: &namespace.NamespaceFilter{IncludeDeleted: true},
	}

	resp, err := c.WorkflowService().ListNamespaces(context.Background(), &req)
	if err != nil {
		log.Println("Unable to ListNamespaces", err)
		grpcErr, _ := status.FromError(err)
		log.Printf("grpcMessage=%v, grpcCode=%v\n", grpcErr.Message(), grpcErr.Code())
		return
	}
	log.Println("ListNamespaces result:", resp)
}
```
Notice in the logs:
```
...
grpcMessage=failed reaching server: no healthy upstream, grpcCode=Unknown
...
```

## Specifications

  - Version: Observed in go-SDK versions v1.24.0, v1.25.0 & v1.28.1
  - Platform: Linux


#### Comments (11)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-31 17:20:12.000 UTC</summary>

In your second example is the error coming from `c, err := client.Dial(temporalClientOpts)`?

</details>

<details>
<summary><strong>uritig</strong> commented on 2024-07-31 19:10:29.000 UTC</summary>

> In your second example is the error coming from `c, err := client.Dial(temporalClientOpts)`?

Yes. That is when the System Health Check is getting triggered & hence the error.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-01 04:42:19.000 UTC</summary>

The Go SDK is not changing the status code of any errors. `status.FromError(err)` is returning `UNKNOWN` because it encounters an incompatible error type. If you checked the second parameter you would see OK is false indicating the error is not compatible with `status`. The Go SDK does not return raw grpc errors, it returns [serviceerrors](https://pkg.go.dev/go.temporal.io/api@v1.36.0/serviceerror) if you want to get the underlying status you can use `ToStatus`

</details>

<details>
<summary><strong>uritig</strong> commented on 2024-08-01 21:51:24.000 UTC</summary>

Good point. My bad for missing that. 

```
func testTemporalClient() {
	temporalConnectionOpts := client.ConnectionOptions{
		TLS: &tls.Config{},
	}
	temporalClientOpts := client.Options{
		HostPort:          "<host:port>",
		Namespace:         "default",
		ConnectionOptions: temporalConnectionOpts,
	}
	c, err := client.Dial(temporalClientOpts)
	if err != nil {
		grpcErr := serviceerror.ToStatus(err)
		fmt.Printf("grpcMessage=%s, grpcCode=%s\n", grpcErr.Message(), grpcErr.Code())
		fmt.Println("Failed to create temporal client:", err)
		return
	}
	defer c.Close()
}
```
This still prints:
```
...
grpcMessage=failed reaching server: no healthy upstream, grpcCode=Unknown
Failed to create temporal client: failed reaching server: no healthy upstream
...
```
What am I missing? Am I wrong to expect "Unavailable" is the logs above?

</details>

<details>
<summary><strong>uritig</strong> commented on 2024-08-05 19:10:51.000 UTC</summary>

@Quinn-With-Two-Ns can you please reopen this?

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-08-05 19:58:32.000 UTC</summary>

> Am I wrong to expect "Unavailable" is the logs above?

I think so. I think not even be able to establish connection is not a gRPC RPC error, it's a network error, so I wouldn't expect it to have a known gRPC status code like gRPC RPC errors which carry status codes.

</details>

<details>
<summary><strong>uritig</strong> commented on 2024-08-05 20:21:36.000 UTC</summary>

> I think so. I think not even be able to establish connection is not a gRPC RPC error, it's a network error, so I wouldn't expect it to have a known gRPC status code like gRPC RPC errors which carry status codes.

@cretz The error is "503 Unavailable" not a network error. It is a gRPC error "Unavailable". So, why shouldn't I expect that? 

Please note that all other gRPC clients (python sdk, base gRPC client, postman, etc.) return the "Unavailable" gRPC code. So should the go sdk.

Unless you have a good reason, requesting that this issue be reopened. Thank you.


</details>

<details>
<summary><strong>cretz</strong> commented on 2024-08-05 20:47:10.000 UTC</summary>

An HTTP status code of 503 unavailable is not the same as a gRPC status code of unavailable (gRPC status codes do not have HTTP numeric status codes). Granted some clients in some languages may reuse the gRPC errors pre-gRPC connectivity.

Can you show what type `err` is in your snippet? Also, can you confirm what https://pkg.go.dev/google.golang.org/grpc/status#FromError returns for this error? Same question for if using a pure gRPC client instead of an SDK client. We want to make sure we match what Go gRPC does here, so maybe we're wrapping incorrectly compared to pure gRPC use.

</details>

<details>
<summary><strong>uritig</strong> commented on 2024-08-05 21:11:21.000 UTC</summary>

> An HTTP status code of 503 unavailable is not the same as a gRPC status code of unavailable (gRPC status codes do not have HTTP numeric status codes). Granted some clients in some languages may reuse the gRPC errors pre-gRPC connectivity.

I don't quite follow what you mean here. Here are the codes: https://pkg.go.dev/google.golang.org/grpc/codes#Code .

> Can you show what type err is in your snippet? 

```
c, err := client.Dial(temporalClientOpts)
vs
grpcErr := serviceerror.ToStatus(err)
```
Does that answer your question?

> https://pkg.go.dev/google.golang.org/grpc/status#FromError returns for this error? 

@cretz please see the function: `testRawGrpc` in the description of this issue.  
I can confirm that `FromError` returns the "Unavailable" code as expected.

> We want to make sure we match what Go gRPC does here, so maybe we're wrapping incorrectly compared to pure gRPC use.

Agreed. Exactly what this issue is about.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-05 21:18:05.000 UTC</summary>

I can confirm the Go SDK is correctly wrapping the error. I can confirm if a grpc server returns `Unavailable` for `GetSystemInfo` the SDK client will return the correct status.

```
func TestUnavailable(t *testing.T) {
	// Start a server that always returns an error on get system info
	srv, err := startTestGRPCServer()
	require.NoError(t, err)
	defer srv.Stop()
	srv.getSystemInfoResponseError = status.New(codes.Unavailable, "some server failure").Err()

	// Confirm DialClient returns unavailable
	_, err = DialClient(context.Background(), ClientOptions{HostPort: srv.addr})
	status := serviceerror.ToStatus(err)
	require.Equal(t, codes.Unavailable, status.Code())
}

func TestBadHostUnavailable(t *testing.T) {
	// Confirm DialClient returns unavailable
	_, err := DialClient(context.Background(), ClientOptions{HostPort: "localhost:12345"})
	status := serviceerror.ToStatus(err)
	require.Equal(t, codes.Unavailable, status.Code())
}
```

</details>

<details>
<summary><strong>uritig</strong> commented on 2024-08-08 22:29:43.000 UTC</summary>

@Quinn-With-Two-Ns your tests fail in v1.24.0 (please see screenshot). I did not test against other released versions but they succeed against the `master` branch of this repo. 

![image](https://github.com/user-attachments/assets/884f7674-c601-446b-bea8-a0e91e74d04c)

Since it worked against the latest code and that nothing in the diff stood out to me as what may have "fixed" the issue. , I am happy to leave this issue closed & wait for the next release. 
As always, appreciate the quick responses & your time!


</details>


---

<a id="1149"></a>

### #1149: Allow custom trace attribute keys

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1149 |
| **State** | OPEN |
| **Author** | loicsaintroch (LoÃ¯c Saint-Roch) |
| **Created** | 2023-06-28 16:00:48.000 UTC (2y 6m ago) |
| **Updated** | 2025-08-07 11:42:45.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 3 |
| **Priority Score** | 11 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

**Is your feature request related to a problem? Please describe.**
Trace attribute keys are enforced by the Temporal SDK, and are as follow:
- `temporalWorkflowID`
- `temporalRunID`
- `temporalActivityID`

Found here: https://github.com/temporalio/sdk-go/blob/master/interceptor/tracing_interceptor.go#L39-L43

The only way to customise those keys is to create our own implementation of `interceptor.Interceptor` which is kind of heavy work to simply rename these keys.

**Describe the solution you'd like**
We could have the possibility to override the key values set by default in `interceptor.TracerOptions`, and port these options to `opentelemetry.TracerOptions` and `opentracing.TracerOptions`.

**Additional context**
Issue related to [this thread on Slack](https://temporalio.slack.com/archives/CTDTU3J4T/p1687932329808269)

#### Comments (3)

<details>
<summary><strong>loicsaintroch</strong> commented on 2023-06-29 08:19:16.000 UTC</summary>

As discussed on Slack, here's a possible approach _without_ having a custom `interceptor.Interceptor`.

Create your own `interceptor.Tracer`, and override the `StartSpan` function:
```go
type MyCustomTracer struct {
	interceptor.Tracer
}

func (m MyCustomTracer) StartSpan(opts *interceptor.TracerStartSpanOptions) (interceptor.TracerSpan, error) {
	if v := opts.Tags["temporalWorkflowID"]; v != "" {
		opts.Tags["temporal.workflow.id"] = v
		delete(opts.Tags, "temporalWorkflowID")
	}

	if v := opts.Tags["temporalRunID"]; v != "" {
		opts.Tags["temporal.workflow.run_id"] = v
		delete(opts.Tags, "temporalRunID")
	}

	if v := opts.Tags["temporalActivityID"]; v != "" {
		opts.Tags["temporal.activity.id"] = v
		delete(opts.Tags, "temporalActivityID")
	}

	return m.Tracer.StartSpan(opts)
}
```

Create a new tracer using the distribution of your choice, such as `opentelemetry`. Then pass this tracer in `interceptor.NewTracingInterceptor`:
```go
otelTracer, err := opentelemetry.NewTracer(opentelemetry.TracerOptions{
	// ...
})

customTracer := MyCustomTracer{
	Tracer: otelTracer,
}

var opts = client.Options{
	Interceptors: []interceptor.ClientInterceptor{
		interceptor.NewTracingInterceptor(customTracer),
	},
}
```

Leaving this issue open to let the Temporal decide if/how this should be documented or if another approach should be implemented.

Reactions: â¤ï¸ 2

</details>

<details>
<summary><strong>throwaway58383958484</strong> commented on 2024-01-24 16:46:18.000 UTC</summary>

+1 for this. We would like to inject additional attributes on our traces, and there doesn't seem to be a good way to do it. Even if we override `StartSpan` as described in [this comment](https://github.com/temporalio/sdk-go/issues/1149#issuecomment-1612613305) (great idea, by the way), we'd like to include tags that we're storing on our context, but unfortunately the context is unavailable there.



Reactions: ðŸ‘ 3

</details>

<details>
<summary><strong>olenotron</strong> commented on 2025-08-07 11:42:44.000 UTC</summary>

unfortunate that this issue didn't get any attention. It makes tracing in Temporal GO SDK quite limited.

</details>


---

<a id="1018"></a>

### #1018: The memory usage from including the Temporal SDK is very large

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1018 |
| **State** | CLOSED |
| **Author** | RyanLettieri (Ryan Lettieri) |
| **Created** | 2023-01-30 18:12:12.000 UTC (2y 11m ago) |
| **Updated** | 2023-01-31 16:20:10.000 UTC |
| **Closed** | 2023-01-31 16:20:10.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 9 |
| **Priority Score** | 11 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

Background: Developer on Dapr ( [GitHub - dapr/dapr: Dapr](https://github.com/dapr/dapr))
We are trying to include Temporal as a workflow engine in our current release (1.10)

Issue: When including the SDK in our project our memory increase spikes up by around 7MB.

SDK Versions:
[go.temporal.io/api](http://go.temporal.io/api) v1.12.0
[go.temporal.io/sdk](http://go.temporal.io/sdk) v1.17.0

Is this the expected memory usage of the inclusion of the SDK? If so, is there a â€œliteâ€ version of the SDK that wonâ€™t consume this amount of memory? If not, is there any way to decrease the memory usage that comes with the inclusion of the SDK?

## Expected Behavior
Including the go SDKs for temporal should be minor in terms of the memory usage.

## Actual Behavior

When including the temporal SDK into the project, the memory usage of the project increases by 7MB.

## Steps to Reproduce the Problem

  1. Include the temporal api and sdk into the project.
  1. Run the project.
  1.

## Specifications

  - Version: (api v1.12.0.) (SDK 1.17.0)
  - Platform:



#### Comments (9)

<details>
<summary><strong>cretz</strong> commented on 2023-01-30 18:17:30.000 UTC</summary>

Can you clarify memory usage? Are you saying the binary size are talking about runtime memory use? If runtime memory use, is it only after you start a Temporal worker or after you import a Temporal package? Client only or worker too? 7MB is usually not a heavy burden for a library like Temporal, but profiling can help determine where the memory is used.

</details>

<details>
<summary><strong>yaron2</strong> commented on 2023-01-30 18:52:56.000 UTC</summary>

Hi, Dapr maintainer here. We're talking about runtime memory use.

</details>

<details>
<summary><strong>yaron2</strong> commented on 2023-01-30 18:54:40.000 UTC</summary>

What we're seeing is increased memory after this method is executed: https://github.com/dapr/components-contrib/blob/master/workflows/temporal/temporal.go#LL49C2-L49C2.


</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-30 19:12:36.000 UTC</summary>

7MB sounds within reasonable range for a full gRPC client of a reasonably large API and Temporal worker setup. For example, protobuf registers all types in a global map. It may be worth profiling and seeing if there's anything obvious. We can do the same if too problematic.

</details>

<details>
<summary><strong>yaron2</strong> commented on 2023-01-30 19:20:24.000 UTC</summary>

Update: the memory increase occurs just by importing the package.

Currently, this type of memory increase prohibits us from including Temporal as a Workflows component in our upcoming release, so it would be great if there was a way to reduce the memory usage.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-30 19:22:14.000 UTC</summary>

That would make sense. Protobuf creates a big map of all registered types globally in `init()` clauses and we have a decent amount of protobufs. Though there may be other places too that a memory profile could uncover.

</details>

<details>
<summary><strong>RyanLettieri</strong> commented on 2023-01-30 19:41:33.000 UTC</summary>

In lieu of the size of the import, is it possible to simply use the HTTP endpoint as a hackish workaround for the time being? If so, could you point me in the right direction to get started on that implementation?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-30 19:45:52.000 UTC</summary>

I am afraid we do not (yet) have a publicly facing HTTP interface for the low-level Temporal API. The Temporal API is a bit low-level and therefore can be difficult to navigate without the higher level client. The whole reason we lean on Protobuf is to have that type safety at an acceptable cost of a few megs.

You can use the CLI as a subprocess, but that CLI is gonna use more than 7MB too.

</details>

<details>
<summary><strong>yaron2</strong> commented on 2023-01-30 19:58:28.000 UTC</summary>

> I am afraid we do not (yet) have a publicly facing HTTP interface for the low-level Temporal API. The Temporal API is a bit low-level and therefore can be difficult to navigate without the higher level client. The whole reason we lean on Protobuf is to have that type safety at an acceptable cost of a few megs.
> 
> You can use the CLI as a subprocess, but that CLI is gonna use more than 7MB too.

Thanks for the prompt response here, we appreciate this. We will remove Temporal support for 1.10 and look to include it again if anything changes in time for our 1.11 release.

</details>


---

<a id="960"></a>

### #960: Loggers use different stack depths when being called from workflow vs activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/960 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-11-17 17:23:24.000 UTC (3y 1m ago) |
| **Updated** | 2023-09-01 14:09:00.000 UTC |
| **Closed** | 2023-09-01 14:09:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 11 |
| **Priority Score** | 11 |
| **Labels** | potential-bug |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

## Expected Behavior

The same log statements in workflow and activity should be at the same stack depth so that a shared caller-skip (e.g. in Zap or Zerolog) can work for both.

## Actual Behavior

We wrap the workflow logger in a replay safe version which properly skips logs during replay. The problem is this adds an extra stack frame for just workflows. We should either: 1) wrap activities in a similar fashion, or 2) stop using a wrapped replayer, or 3) have a `interface WithSkipCallers { AddCallerSkip(int) }` interface that loggers can implement.

Only 3 is backwards compatible. 1 or 2 could break existing user expectations.

## Replication

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/rs/zerolog"
	"go.temporal.io/sdk/activity"
	"go.temporal.io/sdk/client"
	sdklog "go.temporal.io/sdk/log"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	logWriter := zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: zerolog.TimeFormatUnix}
	// We add 3 more to the skip count because we are in our log
	// TODO(cretz): We need 3 for workflows but only 2 for activities because
	// workflows add an extra wrapping which increases the stack depth
	skipLogFrameCount := zerolog.CallerSkipFrameCount + 3
	c, err := client.Dial(client.Options{
		Logger: &ZeroLogLogger{
			zerolog.New(logWriter).With().CallerWithSkipFrameCount(skipLogFrameCount).Timestamp().Logger(),
		},
	})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting worker")
	taskQueue := uuid.NewString()
	w := worker.New(c, taskQueue, worker.Options{})
	w.RegisterWorkflow(MyWorkflow)
	w.RegisterActivity(MyActivity)
	if err := w.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer w.Stop()

	log.Printf("Starting workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, MyWorkflow)
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}

	// Wait for complete
	return run.Get(ctx, nil)
}

func MyWorkflow(ctx workflow.Context) error {
	workflow.GetLogger(ctx).Info("Workflow started")
	return workflow.ExecuteActivity(
		workflow.WithActivityOptions(ctx, workflow.ActivityOptions{ScheduleToCloseTimeout: 1 * time.Minute}),
		MyActivity,
	).Get(ctx, nil)
}

func MyActivity(ctx context.Context) error {
	activity.GetLogger(ctx).Info("Activity started")
	return nil
}

type ZeroLogLogger struct{ underlying zerolog.Logger }

var _ sdklog.WithLogger = &ZeroLogLogger{}

func (z *ZeroLogLogger) Debug(msg string, keyvals ...interface{}) {
	logEvent(z.underlying.Debug(), msg, keyvals...)
}

func (z *ZeroLogLogger) Info(msg string, keyvals ...interface{}) {
	logEvent(z.underlying.Info(), msg, keyvals...)
}

func (z *ZeroLogLogger) Warn(msg string, keyvals ...interface{}) {
	logEvent(z.underlying.Warn(), msg, keyvals...)
}

func (z *ZeroLogLogger) Error(msg string, keyvals ...interface{}) {
	logEvent(z.underlying.Error(), msg, keyvals...)
}

func (z *ZeroLogLogger) With(keyvals ...interface{}) sdklog.Logger {
	return &ZeroLogLogger{z.underlying.With().Fields(keyvals).Logger()}
}

func logEvent(e *zerolog.Event, msg string, keyvals ...interface{}) {
	if len(keyvals) > 0 {
		e = e.Fields(keyvals)
	}
	// We have previously set caller skip frames to work with this
	e.Caller().Msg(msg)
}
```

#### Comments (11)

<details>
<summary><strong>Multiply</strong> commented on 2023-03-21 08:44:11.000 UTC</summary>

We've been trying to work around this with zap since we started out with Temporal as well.

What is the easiest path forward, if we'd like to contribute a workaround or fix?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-03-21 11:54:12.000 UTC</summary>

@Quinn-With-Two-Ns - thoughts on a `WithSkipCallers` interface in https://pkg.go.dev/go.temporal.io/sdk/log?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-03-21 16:30:37.000 UTC</summary>

@cretz so the idea is `WithSkipCallers` returns a new logger that skips more frames and we would check for this interface when creating the logger in certain places ?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-03-21 16:45:26.000 UTC</summary>

@Quinn-With-Two-Ns - Yes. I can think of only two places: workflow and activity execution start. I think a test can confirm https://pkg.go.dev/runtime#Caller, w/ the set number of skips inside the a log statement in activity and workflow, returns the expected frame/file/whatever.

Can call it `WithCallerSkip` instead, that may be clearer to read.

We should also update https://github.com/temporalio/samples-go/blob/dc35150cd901e0a20c107a42a3b5506b544b355d/zapadapter/zap_adapter.go#L40-L42

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-03-21 16:51:52.000 UTC</summary>

Why can't users intercept `GetLogger` calls in workflows and activities to set different  amounts in workflows vs activities?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-03-21 17:10:37.000 UTC</summary>

My concern is that we don't use `GetLogger` for our _own_ logging internally or that the interceptor isn't ready for all uses. But if you can 1) confirm or make sure we do (at least for the logger stored on these contexts that are used internally once the interceptor is ready), and 2) update the sample showing how to do it, I think that would be good enough. I think workflow not found, task failure, and panic would be good example logs to confirm.

EDIT: Hrmm, arguably you don't need log skip at some of those early times. Would be worth checking. But yes, a sample update showing that interceptors reasonably skip frames as needed is probably good enough.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-03-22 17:31:04.000 UTC</summary>

hm testing `GetLogger` since the workflow logger is wrapped it is not possible to set the skip level.

I don't like ``WithSkipCallers` just because it seems arbitrary where the SDK is skipping. I would prefer wrapping activities so the skip depth is the same, but I wouldn't die on that hill.

</details>

<details>
<summary><strong>Multiply</strong> commented on 2023-03-22 19:05:41.000 UTC</summary>

Maybe split the logger into one for internals, one for workflows and one for activities? If none is defined, fall back to the current logger, so there's no backwards breaking changes.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-03-22 21:27:56.000 UTC</summary>

> I would prefer wrapping activities so the skip depth is the same, but I wouldn't die on that hill.

Just realized people already are setting skip-caller for their activity logger with certain expectations, so this wouldn't work.

> Maybe split the logger into one for internals, one for workflows and one for activities? If none is defined, fall back to the current logger, so there's no backwards breaking changes.

I don't think it's worth multiple entirely new options for this skip-caller use case.

I can only think of `type WithCallerSkip interface { Logger WithCallerSkip(int) }` at the moment.

</details>

<details>
<summary><strong>debuggerpk</strong> commented on 2023-08-20 10:48:03.000 UTC</summary>

> I don't think it's worth multiple entirely new options for this skip-caller use case.

The typescript sdk has multiple entry points for logging.


</details>

<details>
<summary><strong>cretz</strong> commented on 2023-08-21 13:02:58.000 UTC</summary>

> The typescript sdk has multiple entry points for logging.

Not following exactly what is meant by "entry points". TypeScript has ways to access loggers from activities and workflows same as Go, but has a global runtime set logger as opposed to per client in Go (TS also has to use sinks and other confusing concepts due to its sandbox and how it forwards Rust logs, both of which are not related to Go SDK).

You can of course use custom logging in your activities and workflows (though you should skip logging from a workflow when replaying).

</details>


---

<a id="929"></a>

### #929: Allow custom time source

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/929 |
| **State** | CLOSED |
| **Author** | mnussbaum (Michael Nussbaum) |
| **Created** | 2022-10-10 22:50:29.000 UTC (3y 3m ago) |
| **Updated** | 2024-03-07 21:36:52.000 UTC |
| **Closed** | 2024-03-07 21:36:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 11 |
| **Priority Score** | 11 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

My workflow's behavior is heavily time dependent, and I need to simulate how it will behave over dynamically sized time spans in the past and the future. To do so, I need the ability to configure Temporal to behave as if the current time is one dictated by a custom clock.

**Describe the solution you'd like**

Specifically Iâ€™d like to make sure that `temporal_workflow.Now(ctx)` returns values set by a fake clock I control, and that `workflow.Sleep` also uses the fake clock.

**Additional context**

For my full workflow, I need the ability to set the clock back to an arbitrary date, and then to have it fast-forward through workflow sleeps such that calls to get the current time return a result that look as if the sleeps took their full amount of time, but fast-forwarded so that a human can run a many-day-long process in a matter of seconds.

@mfateev suggested I open an issue in response to my question on this topic at https://community.temporal.io/t/custom-time-source-with-the-go-sdk/6174.


#### Comments (11)

<details>
<summary><strong>mfateev</strong> commented on 2022-10-10 23:55:50.000 UTC</summary>

Java supports this through `TestEnvironmentOptions.setInitialTime`.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-10-11 13:19:52.000 UTC</summary>

This is already present via [TestWorkflowEnvironment.SetStartTime](https://pkg.go.dev/go.temporal.io/sdk/internal#TestWorkflowEnvironment.SetStartTime).

@mnussbaum - To clarify, while you can set the initial time, the test suite will automatically skip time for you until the next event. So sleeps would resolve immediately (assuming nothing outstanding is also waiting for a shorter period). To set something to happen a specific time after the workflow starts, you can use [TestWorkflowEnvironment.RegisterDelayedCallback](https://pkg.go.dev/go.temporal.io/sdk/internal#TestWorkflowEnvironment.RegisterDelayedCallback). See the Godoc on that call. You should set the start time and delayed callbacks before starting the workflow.

</details>

<details>
<summary><strong>mnussbaum</strong> commented on 2022-10-11 15:58:19.000 UTC</summary>

@cretz I'd like to use this functionality outside of unit tests, in my operationally deployed software. I was under the impression that `TestWorkflowEnvironment` didn't connect to  a real temporal instance, and thus wasn't suitable for this purpose, is that right? 

My use case is that I have application users who want to perform "back testing", ie they want to test the performance of various different operational parameters of the software against historical data. The time period and parameters we'll be back testing over are driven by non-technical user input. I want to expose a user interface in front of my deployed software that lets the end user choose the time period for back testing, which the software then uses to set the Temporal clock and initiate a workflow 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-10-11 16:21:06.000 UTC</summary>

> I'd like to use this functionality outside of unit tests, in my operationally deployed software.

@mnussbaum - We provide no way to create a `workflow.Context` outside of a real worker or a test environment. That context contains many things to make workflows function. If you want to do an integration test against a real server, that works, but you don't get time skipping/management. I am afraid time-skipping unit tests or real-server actual time are all we offer in Go SDK.

> I was under the impression that TestWorkflowEnvironment didn't connect to a real temporal instance, and thus wasn't suitable for this purpose, is that right?

Suitable for which purpose? It should be suitable for all workflow testing needs.

> My use case is that I have application users who want to perform "back testing", ie they want to test the performance of various different operational parameters of the software against historical data. The time period and parameters we'll be back testing over are driven by non-technical user input. I want to expose a user interface in front of my deployed software that lets the end user choose the time period for back testing, which the software then uses to set the Temporal clock and initiate a workflow

If this is on an already-run workflow, you could use the replayer. But that's often only for catching errors, it won't run any activities and you can't really customize it.

Technically you can use the `TestWorkflowEnvironment` to test things outside of a unit test. You will get to control time and activities and other things you would normally control in a unit test. It sounds like this may be what you need since you are wanting to control the environment, even if we do call it a "test" environment. You get the added benefit of time skipping, so besides setting the start time, it will automatically skip to the next event (be it a timer or whatever). If there are any issues with using the test workflow environment for your use case, let us know and we may be able to alter it.

</details>

<details>
<summary><strong>mnussbaum</strong> commented on 2022-10-11 18:22:41.000 UTC</summary>

> If you want to do an integration test against a real server, that works, but you don't get time skipping/management. I am afraid time-skipping unit tests or real-server actual time are all we offer in Go SDK.

Yeah, the workflows we're building aren't for integration testing purposes even. I need to be able to manage time in my production deployed workflows, exposed to end users and integrated with the Temporal server. I think that's the heart of this feature request, the ability to control the workflow clock when running workflows with a real Temporal server.

> If this is on an already-run workflow, you could use the replayer. But that's often only for catching errors, it won't run any activities and you can't really customize it.

Unfortunately these workflows won't be replays of the past, they'll be first-run with a historical perspective of time.

> Technically you can use the TestWorkflowEnvironment to test things outside of a unit test.

If we use the `TestWorkflowEnvironment` like you're imagining, it wouldn't be connected to a real Temporal-server, right? So the ability to schedule activities and child-workflows on a pool of workers would not be available, and we wouldn't be able to resume a suspended workflow on a different worker then started it, right? Those would be the critical requirements for the scenarios we need to modify our clock in.


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-10-11 18:47:23.000 UTC</summary>

> I need to be able to manage time in my production deployed workflows, exposed to end users and integrated with the Temporal server.

I am afraid this is not a feature Temporal supports currently. We technically have a time-skipping Temporal server (written in Java, but we compile with Graal for use in our other SDKs as a separate time-skipping binary). However, that is also not a real Temporal server.

> If we use the TestWorkflowEnvironment like you're imagining, it wouldn't be connected to a real Temporal-server, right? So the ability to schedule activities and child-workflows on a pool of workers would not be available, and we wouldn't be able to resume a suspended workflow on a different worker then started it, right? Those would be the critical requirements for the scenarios we need to modify our clock in.

Right. Even our time-skipping server may lack some of the features you'd want in that time-skipping is global so it's not suitable for normal server use.

If you can identify exactly what calls you want to intercept to provide mock time, you might be able to use interceptors for this. Every call to `workflow.Now()` or `workflow.Sleep()` is interceptable via a `WorkflowOutboundInterceptor` and you could do whatever you wanted in there. But it isn't necessarily global time management because timeouts and other things wouldn't apply.

If you need to manage time on a production server, I am afraid this is not available. If you need to intercept certain calls you can. Otherwise, if at all possible, you'll need to solve this in user land (i.e. use your own deterministic mock clock and make your own clock invocations when you need time), but you won't get all of the server-specific timing features.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-10-11 19:41:28.000 UTC</summary>

Out of curiosity, can you clarify your use case a bit more? What do you want to mock with this clock? Just `workflow.Now()` since that is an exact time, or durations like sleep/timer also? Does this include activities? Does this include timeouts? Can you be specific on _exactly_ what you want to use the custom time source for?

</details>

<details>
<summary><strong>csuich2</strong> commented on 2024-02-22 15:04:52.000 UTC</summary>

Necroing this old issue:

We've got a use case where we want a mocked/manual clock so that we can control when each step of our mock workflow executes. This would allow us to write tests that assert expectations at various points during the workflow execution as well as verify the expected scheduling behavior by manipulating the clock before and after scheduling.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-26 15:43:30.000 UTC</summary>

Are you referring to the `testsuite`? Time automatically skips there, and you can `RegisterDelayedCallback` to do certain things at certain times. That is the only real environment where you can control time, controlling time in a non-test-environment workflow is unreasonable as many internal things such as timeouts rely on clocks you cannot substitute (e.g. server-side timings).

</details>

<details>
<summary><strong>csuich2</strong> commented on 2024-03-07 17:56:45.000 UTC</summary>

Yeah, I was. Somehow in digging through the client I missed `RegisterDelayedCallback`. That does seem to do the trick - I was just expecting/hoping for a power-user mode that allowed for full control of the fake clock.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-03-07 21:36:14.000 UTC</summary>

:+1: Yeah the delayed callback should be enough to do all that is necessary at certain times without having to manually progress a clock yourself.

(closing issue because of the previous staleness and the acknowledged delayed callback approach, but feel free to continue discussing here or in `#sdk-go` channel on https://t.mp/slack)

</details>


---

<a id="887"></a>

### #887: TestSuite: Workflow names seemingly collide with activity names in mock expectations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/887 |
| **State** | CLOSED |
| **Author** | krousey (Kris Rousey) |
| **Created** | 2022-08-22 04:19:17.000 UTC (3y 4m ago) |
| **Updated** | 2024-04-03 23:32:37.000 UTC |
| **Closed** | 2024-04-03 23:32:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 11 |
| **Priority Score** | 11 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

I have a set of workflows and activities implemented as methods on a struct. I happened to name an activity method with the same name as the workflow method. Everything actually works when running the workflow, but the test framework errors out complaining about different amount of return values. The workflow method only returns an error while the activity method returns a value and an error.

If I change the name of the activity method in all places, the tests start passing.

## Expected Behavior

Passing tests.

## Actual Behavior

```console
go test
--- FAIL: Test_Workflow (0.00s)
    workflows_test.go:20: 
        	Error Trace:	/tmp/example/workflows_test.go:20
        	Error:      	Received unexpected error:
        	            	workflow execution error (type: GenericName, workflowID: default-test-workflow-id, runID: default-test-run-id): mock of GenericName has incorrect number of returns, expected 1, but actual is 2
        	Test:       	Test_Workflow
FAIL
exit status 1
FAIL	example	0.003s
```

## Steps to Reproduce the Problem

workflows.go:
```go
package example

import (
	"context"
	"time"

	"go.temporal.io/sdk/workflow"
)

type Workflows struct{}

func (w *Workflows) GenericName(ctx workflow.Context, input string) error {
	return workflow.ExecuteActivity(
		workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
			StartToCloseTimeout: time.Minute,
		}),
		Activities{}.GenericName,
		input).Get(ctx, nil)

}

type Activities struct{}

func (a Activities) GenericName(ctx context.Context, input string) (string, error) {
	return input, nil
}
```

workflows_test.go:
```go
package example

import (
	"testing"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.temporal.io/sdk/testsuite"
)

func Test_Workflow(t *testing.T) {
	testSuite := testsuite.WorkflowTestSuite{}
	env := testSuite.NewTestWorkflowEnvironment()

	env.OnActivity(new(Activities).GenericName, mock.Anything, "input").Return("output", nil)

	env.ExecuteWorkflow(new(Workflows).GenericName, "input")

	require.True(t, env.IsWorkflowCompleted())
	require.NoError(t, env.GetWorkflowError())
}
```
  
## Specifications

 go.mod:
```go
module example

go 1.18

require (
	github.com/stretchr/testify v1.8.0
	go.temporal.io/sdk v1.16.0
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/facebookgo/clock v0.0.0-20150410010913-600d898af40a // indirect
	github.com/gogo/googleapis v1.4.1 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/gogo/status v1.1.1 // indirect
	github.com/golang/mock v1.6.0 // indirect
	github.com/golang/protobuf v1.5.2 // indirect
	github.com/google/uuid v1.3.0 // indirect
	github.com/grpc-ecosystem/go-grpc-middleware v1.3.0 // indirect
	github.com/pborman/uuid v1.2.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/robfig/cron v1.2.0 // indirect
	github.com/stretchr/objx v0.4.0 // indirect
	go.temporal.io/api v1.11.0 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	golang.org/x/net v0.0.0-20220728181054-f92ba40d432d // indirect
	golang.org/x/sys v0.0.0-20220728004956-3c1f35247d10 // indirect
	golang.org/x/text v0.3.7 // indirect
	golang.org/x/time v0.0.0-20210723032227-1f47c861a9ac // indirect
	google.golang.org/genproto v0.0.0-20220725144611-272f38e5d71b // indirect
	google.golang.org/grpc v1.48.0 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

```


#### Comments (11)

<details>
<summary><strong>cretz</strong> commented on 2022-08-25 05:14:15.000 UTC</summary>

I am not sure this is related to naming. It seems you have an activity that returns just a single `error` and a mock that is returning an actual output and a nil error. Hence the message "incorrect number of returns, expected 1, but actual is 2".

Your mock return count should match your definition's return count.

</details>

<details>
<summary><strong>krousey</strong> commented on 2022-08-25 18:28:02.000 UTC</summary>

I do not have an activity that returns a single `error`. I have an activity that returns `(string, error)`. I have a workflow with the same function name that returns just an `error`.  The most important indication that this is a naming issue is what I said in the original report:

## **If I change the name of the activity method in all places, the tests start passing.**

I think there's a general limitation in Temporal that you can't name the activity the same as the workflow.  But Temporal allows you to register workflows with well-known names not derived from the function names like:

```go
w.RegisterWorkflowWithOptions(wf.GenericName, workflow.RegisterOptions{Name: "different-wf-name"})
```

However, in the workflow testsuite, I don't register the workflow. I also don't register activities. I didn't expect this to be an issue since it doesn't appear that I'm registering either activities or workflows.

I think I've traced it down to the workflow testsuite registering workflows and activities under the hood, but not allowing registration options to prevent name collisions.

The activity is registered under the hood during `env.OnActivity` here: https://github.com/temporalio/sdk-go/blob/master/internal/workflow_testsuite.go#L334

The workflow is registered under the hood during `env.ExecuteWorkflow` here: https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_testsuite.go#L451


So the crux of this bug is "Perfectly valid workflow code can't be tested using the `TestWorkflowEnvironment`"

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-29 13:37:48.000 UTC</summary>

I see, thanks for the update. I will try to replicate shortly. It is possible we are reusing a mock somewhere.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-29 18:38:45.000 UTC</summary>

@krousey - I have replicated this and have confirmed the workflow environment uses a shared mock for its workflow and activities call ðŸ˜ž. Specifically the `OnActivity` registers the mock and the `ExecuteWorkflow` checks for mocks before running the actual method. That's where the error is happening.

I am unsure I can break these out into separate mocks at this time without breaking backwards compatibility and upsetting how things like https://pkg.go.dev/go.temporal.io/sdk/internal#TestWorkflowEnvironment.AssertNotCalled are meant to work for workflow or activity invocations.

I am thinking about just documenting this limitation. Is this acceptable for now or do you think it's worth the effort to separate the mocks?

</details>

<details>
<summary><strong>krousey</strong> commented on 2022-08-29 20:59:12.000 UTC</summary>

I'm not sure what the appropriate level of effort is here. It's an easy fix on my end, just frustrating to figure out the actual issue.

Other than splitting the mocks, allowing aliasing could work. If fixes aren't possible, documentation is fine. Detecting the situation and emitting an appropriate error message is even better.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-29 21:21:43.000 UTC</summary>

Unfortunately you can have multiple mocks of the same name I believe with different behaviors based on param matching. I will research some solutions, worst case being just documenting this limitation.

</details>

<details>
<summary><strong>netixen</strong> commented on 2023-04-14 18:25:43.000 UTC</summary>

I just stumbled on to the same bug with a twist. The collision was between two workflows in different packages.
Such as `bluepackage.Workflow` and `greenpackage.Workflow`.

</details>

<details>
<summary><strong>ignatk</strong> commented on 2023-11-23 12:55:11.000 UTC</summary>

Hit the same here. I can see we don't incorporate the type information into mock names. Perhaps if we do so it will allow the mock framework to disambiguate?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-23 15:07:52.000 UTC</summary>

Unfortunately the challenge here is not  disambiguating inside the SDK,  the challenge is doing it in  a way  that doesn't break the user facing API, which is impossible

</details>

<details>
<summary><strong>ignatk</strong> commented on 2023-11-23 15:41:00.000 UTC</summary>

I see. I must admit I'm new to temporal and not familiar with the code base, but it seems a bit weird that a change in the testing framework may break user facing API? Can, for example `TestWorkflowEnvironment` have different behaviour than "real" workflow environment?

</details>

<details>
<summary><strong>krousey</strong> commented on 2024-03-25 18:20:53.000 UTC</summary>

did https://github.com/temporalio/sdk-go/pull/1371 fix this?

</details>


---

<a id="774"></a>

### #774: Possible memory leak when loading a workflow with a query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/774 |
| **State** | CLOSED |
| **Author** | app/ |
| **Created** | 2022-04-12 17:40:21.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-26 22:21:17.000 UTC |
| **Closed** | 2022-04-26 22:21:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 11 |
| **Priority Score** | 11 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When querying a workflow, the worker should add the workflow to the internal cache.

## Actual Behavior

When the Worker starts and the first interaction with the workflow is a Query, the workflow is not cached, you can notice this behavior because the events are replayed from scratch every time.

The memory leak occurs because every time the query is handled, a new instance of the workflow is allocated by the worker. It only happens when the workflow stays awaiting new signals.

## Steps to Reproduce the Problem

Consider a workflow like

```go
package workflow

import (
	"go.temporal.io/sdk/workflow"
)

func ReproduceML(ctx workflow.Context, param string) error {
	log := workflow.GetLogger(ctx)
	log.Info("Starting new Workflow")
	defer func() {
		log.Info("Exit from workflow")
	}()
	state := param
	var receivedSignals []string

	err := workflow.SetQueryHandler(ctx, "getState", func() (string, error) {
		return state, nil
	})

	if err != nil {
		log.Error("SetQueryHandler getState failed", "Error", err)
		return err
	}

	channel := workflow.GetSignalChannel(ctx, "ml-signals")
	for {

		if state == "complete" {
			break
		}

		var signal string
		_ = channel.Receive(ctx, &signal)
		// Do something special with the signal and calculate the state
		state = signal

		// Forcing memory growing, so it can be noticed it in the metrics
		receivedSignals = append(receivedSignals, signal)
	}

	log.Info("Workflow finished")
	return nil
}

```

1. Start the worker
2. Create a workflow
3. Signal the workflow around 500 times to generate some data.
4. Restart the worker
5. ONLY query the workflow several times and notice how the memory grows.

Verifying:

- In the logs, you can notice an entry "Starting new Workflow" for every query and never the "Exit from workflow" meaning the workflow stayed allocated.
- If we disable the cache with `worker.SetStickyWorkflowCacheSize(0)`, the logs show "Starting new Workflow" and "Exit from workflow" with every query execution and the memory stops growing.
- With the cache enabled, If after the 4th step, the first interaction is a signal, the "Starting new Workflow" is shown only once, meaning the cache was properly set, and queries to that workflow will be returned faster and the memory won't grow as before.

Final note: with a workflow with a similar structure as the above, the memory increased to 6Gb+, and without modifying code after doing one of the last two bullet points the memory stays below 30 Mb.

## Specifications

- Version:
  go.temporal.io/sdk v1.14.0
  Golang 1.17.8
- Platform:
  Darwin x86_64


#### Comments (11)

<details>
<summary><strong>cretz</strong> commented on 2022-04-12 17:43:53.000 UTC</summary>

To confirm, for step #5, it is not reusing the cached workflow for each query call after the first one? If so, this does look like a bug and I will investigate.

</details>

<details>
<summary><strong>Unknown</strong> commented on 2022-04-12 18:06:29.000 UTC</summary>

I put several breakpoints in the code, and I noticed that when the Query is executed just after the worker starts, the [putWorkflowContext](https://github.com/temporalio/sdk-go/blob/v1.14.0/internal/internal_worker_cache.go#L141) function is never called, that's why I believe the cache is not set, but if later you send a signal, the cache is set, and from there the Queries reuse it.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-13 14:55:03.000 UTC</summary>

I am struggling to replicate this following the steps. In my tests, the workflow cache is reused. I am still doing some investigation and I'll try to provide a standalone runnable example soon.

> In the logs, you can notice an entry "Starting new Workflow" for every query

The "Starting new Workflow" only logs once for me when the workflow actually started because our logger doesn't log on replay. If you're seeing "Starting new Workflow" every time, that means it is not treated as a replay and is actually running the workflow as new each time.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-13 15:23:41.000 UTC</summary>

Collapsed below is a standalone set of code that sends 500 signals, restarts the worker, and sends 5 queries.

<details>
  <summary>main.go</summary>

```go
package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"github.com/uber-go/tally/v4"
	"go.temporal.io/api/serviceerror"
	"go.temporal.io/sdk/client"
	sdktally "go.temporal.io/sdk/contrib/tally"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	c, err := client.NewClient(client.Options{})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting worker 1")
	taskQueue := uuid.NewString()
	worker1 := worker.New(c, taskQueue, worker.Options{})
	worker1.RegisterWorkflow(SignalCountingWorkflow)
	if err := worker1.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer func() {
		if worker1 != nil {
			worker1.Stop()
		}
	}()

	log.Printf("Starting workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, SignalCountingWorkflow)
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}

	log.Printf("Sending 500 signals")
	for i := 0; i < 500; i++ {
		if err := c.SignalWorkflow(ctx, run.GetID(), run.GetRunID(), "my-signal", "some-arg"); err != nil {
			return fmt.Errorf("failed signalling workflow: %w", err)
		}
	}

	log.Printf("Waiting for query to show 500 signals received")
	var signalCount int
	for start := time.Now(); signalCount != 500 && time.Since(start) < 10*time.Second; {
		time.Sleep(50 * time.Millisecond)
		val, err := c.QueryWorkflow(ctx, run.GetID(), run.GetRunID(), "get-signal-count")
		// Ignore query failed because it means query may not be registered yet
		var queryFailed *serviceerror.QueryFailed
		if errors.As(err, &queryFailed) {
			continue
		} else if err != nil {
			return fmt.Errorf("failed querying: %w", err)
		} else if err := val.Get(&signalCount); err != nil {
			return fmt.Errorf("failed decoding query: %w", err)
		}
	}
	if signalCount != 500 {
		return fmt.Errorf("expected signal count never reached")
	}

	log.Printf("Stopping worker")
	worker1.Stop()
	worker1 = nil

	log.Printf("Starting worker 2")
	// Recreate client to capture metrics
	testScope := tally.NewTestScope("", nil)
	c, err = client.NewClient(client.Options{MetricsHandler: sdktally.NewMetricsHandler(testScope)})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()
	worker2 := worker.New(c, taskQueue, worker.Options{})
	worker2.RegisterWorkflow(SignalCountingWorkflow)
	if err := worker2.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer worker2.Stop()

	log.Printf("Performing several queries")
	for i := 0; i < 5; i++ {
		if _, err := c.QueryWorkflow(ctx, run.GetID(), run.GetRunID(), "get-signal-count"); err != nil {
			return fmt.Errorf("failed querying: %w", err)
		}
		// Get cache size metric
		var cacheSize float64
		for _, gauge := range testScope.Snapshot().Gauges() {
			if gauge.Name() == "temporal_sticky_cache_size" {
				cacheSize += gauge.Value()
			}
		}
		log.Printf("Query #%v complete, cache size: %v", i+1, cacheSize)
	}
	return nil
}

func SignalCountingWorkflow(ctx workflow.Context) error {
	workflow.GetLogger(ctx).Info("Starting workflow")
	log.Printf("Running workflow code (replaying? %v)", workflow.IsReplaying(ctx))
	defer workflow.GetLogger(ctx).Info("Completing workflow")
	defer func() { log.Printf("Finishing workflow code (replaying? %v)", workflow.IsReplaying(ctx)) }()

	signalCount := 0
	err := workflow.SetQueryHandler(ctx, "get-signal-count", func() (int, error) { return signalCount, nil })
	if err != nil {
		return err
	}
	signalCh := workflow.GetSignalChannel(ctx, "my-signal")
	for {
		signalCh.Receive(ctx, nil)
		signalCount++
	}
}
```

</details>

Running gives the following logs:

```
2022/04/13 10:19:11 Creating client
2022/04/13 10:19:11 INFO  No logger configured for temporal client. Created default one.
2022/04/13 10:19:11 Starting worker 1
2022/04/13 10:19:11 INFO  Started Worker Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@
2022/04/13 10:19:11 Starting workflow
2022/04/13 10:19:11 Sending 500 signals
2022/04/13 10:19:11 INFO  Starting workflow Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@ WorkflowType SignalCountingWorkflow WorkflowID 372aa87f-884a-476f-8276-a691bba62553 RunID 5136780a-cc02-47cc-ae90-37681413b0bc Attempt 1
2022/04/13 10:19:11 Running workflow code (replaying? false)
2022/04/13 10:19:15 Waiting for query to show 500 signals received
2022/04/13 10:19:15 Stopping worker
2022/04/13 10:19:15 WARN  Failed to poll for task. Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@ WorkerType WorkflowWorker Error worker stopping
2022/04/13 10:19:15 WARN  Failed to poll for task. Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@ WorkerType ActivityWorker Error worker stopping
2022/04/13 10:19:15 INFO  Stopped Worker Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@
2022/04/13 10:19:15 Starting worker 2
2022/04/13 10:19:15 INFO  No logger configured for temporal client. Created default one.
2022/04/13 10:19:15 INFO  Started Worker Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@
2022/04/13 10:19:15 Performing several queries
2022/04/13 10:19:20 Running workflow code (replaying? true)
2022/04/13 10:19:20 Query #1 complete, cache size: 1
2022/04/13 10:19:20 Running workflow code (replaying? true)
2022/04/13 10:19:20 Query #2 complete, cache size: 1
2022/04/13 10:19:20 Running workflow code (replaying? true)
2022/04/13 10:19:20 Query #3 complete, cache size: 1
2022/04/13 10:19:20 Running workflow code (replaying? true)
2022/04/13 10:19:20 Query #4 complete, cache size: 1
2022/04/13 10:19:20 Running workflow code (replaying? true)
2022/04/13 10:19:20 Query #5 complete, cache size: 1
2022/04/13 10:19:20 INFO  Stopped Worker Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@
2022/04/13 10:19:20 WARN  Failed to poll for task. Namespace default TaskQueue 559865d2-9872-48ba-a8d7-12ba77360358 WorkerID 4190@cretz-laptop@ WorkerType WorkflowWorker Error worker stopping
```

There is a lull sending the signals and a bit of a lull stopping the worker due to sticky cache being enabled by default. But this shows that the cache size is not growing and that "Starting workflow" log not happening on each query. Can you confirm and/or make changes to the standalone replication code to replicate what you are seeing?

</details>

<details>
<summary><strong>Unknown</strong> commented on 2022-04-13 17:37:40.000 UTC</summary>

@cretz thanks for watching this. 

You're right about the logs, I ended up replacing the log by simple printing to the console.

When executing only queries, you can see the "workflow start" in the console for every call and never the defer message, which it seems to me that another instance was allocated and replayed from scratch. 

If the first call to the workflow is a signal, you can see the  "workflow start" just once, and for all following query calls, the cache is reused.

In the first scenario, if you make only queries, you can notice how the memory is increased and never released. Maybe is not a memory leak per-se, but it seems that for the same workflow the listener or so is being allocated multiple times.

I have seen this behavior only after the Worker starts and until the workflow receives the first signal. 

</details>

<details>
<summary><strong>Unknown</strong> commented on 2022-04-13 18:28:49.000 UTC</summary>

I modified a bit your test to show you what I'm seeing

<details>
  <summary>main.go</summary>

```go

package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"runtime"
	"time"

	"github.com/google/uuid"
	"github.com/uber-go/tally/v4"
	"go.temporal.io/api/serviceerror"
	"go.temporal.io/sdk/client"
	sdktally "go.temporal.io/sdk/contrib/tally"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	c, err := client.NewClient(client.Options{})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting worker 1")
	taskQueue := uuid.NewString()
	worker1 := worker.New(c, taskQueue, worker.Options{})
	worker1.RegisterWorkflow(SignalCountingWorkflow)
	if err := worker1.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer func() {
		if worker1 != nil {
			worker1.Stop()
		}
	}()

	log.Printf("Starting workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, SignalCountingWorkflow)
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}

	log.Printf("Sending 500 signals")
	for i := 0; i < 500; i++ {
		if err := c.SignalWorkflow(ctx, run.GetID(), "", "my-signal", "some-arg"); err != nil {
			return fmt.Errorf("failed signalling workflow: %w", err)
		}
	}

	log.Printf("Waiting for query to show 500 signals received")
	var signalCount int
	for start := time.Now(); signalCount != 500 && time.Since(start) < 10*time.Second; {
		time.Sleep(50 * time.Millisecond)
		val, err := c.QueryWorkflow(ctx, run.GetID(), "", "get-signal-count")
		// Ignore query failed because it means query may not be registered yet
		var queryFailed *serviceerror.QueryFailed
		if errors.As(err, &queryFailed) {
			continue
		} else if err != nil {
			return fmt.Errorf("failed querying: %w", err)
		} else if err := val.Get(&signalCount); err != nil {
			return fmt.Errorf("failed decoding query: %w", err)
		}
	}
	if signalCount != 500 {
		return fmt.Errorf("expected signal count never reached")
	}

	log.Printf("Stopping worker")
	worker1.Stop()
	worker1 = nil

	log.Printf("Starting worker 2")
	// Recreate client to capture metrics
	testScope := tally.NewTestScope("", nil)
	c, err = client.NewClient(client.Options{MetricsHandler: sdktally.NewMetricsHandler(testScope)})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()
	worker2 := worker.New(c, taskQueue, worker.Options{})
	worker2.RegisterWorkflow(SignalCountingWorkflow)
	if err := worker2.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer worker2.Stop()

	log.Printf("Performing several queries")
	log.Printf("before querying")
	printMemoryUsage()
	// Test 1st with the following line commented, and then uncomment it and test again
	// Check the memory usage
	//
	// _ = c.SignalWorkflow(ctx, run.GetID(), "", "my-signal", "some-arg")
	for i := 0; i < 500; i++ {
		printMemoryUsage()
		if _, err := c.QueryWorkflow(ctx, run.GetID(), "", "get-signal-count"); err != nil {
			return fmt.Errorf("failed querying: %w", err)
		}
		// Get cache size metric
		var cacheSize float64
		for _, gauge := range testScope.Snapshot().Gauges() {
			if gauge.Name() == "temporal_sticky_cache_size" {
				cacheSize += gauge.Value()
			}
		}
		log.Printf("Query #%v complete, cache size: %v", i+1, cacheSize)
	}
	return nil
}

func printMemoryUsage() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("Alloc = %v MiB", bToMb(m.Alloc))
	fmt.Printf("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc))
	fmt.Printf("\tSys = %v MiB", bToMb(m.Sys))
	fmt.Printf("\tNumGC = %v\n", m.NumGC)
}

func SignalCountingWorkflow(ctx workflow.Context) error {
	log.Printf("Workflow starts")
	defer log.Printf("Workflow Exit")
	workflow.GetLogger(ctx).Info("Starting workflow")
	log.Printf("Running workflow code (replaying? %v)", workflow.IsReplaying(ctx))
	defer workflow.GetLogger(ctx).Info("Completing workflow")
	defer func() { log.Printf("Finishing workflow code (replaying? %v)", workflow.IsReplaying(ctx)) }()

	signalCount := 0
	err := workflow.SetQueryHandler(ctx, "get-signal-count", func() (int, error) { return signalCount, nil })
	if err != nil {
		return err
	}
	signalCh := workflow.GetSignalChannel(ctx, "my-signal")
	for {
		signalCh.Receive(ctx, nil)
		signalCount++
	}
}

func bToMb(b uint64) uint64 {
	return b / 1024 / 1024
}

```

</details>

I commented the line 107, pls test it first with that line commented and then uncomment it and test again

```go
	// _ = c.SignalWorkflow(ctx, run.GetID(), "", "my-signal", "some-arg")
```

With the line commented, you should see that after executing the last query the memory usage is like 

```
Alloc = 12 MiB  TotalAlloc = 1776 MiB   Sys = 35 MiB    NumGC = 314
```
You can also check the complete log to see how it is increased with every query.

With the line uncommented, you should see something like

```
Alloc = 4 MiB   TotalAlloc = 51 MiB     Sys = 19 MiB    NumGC = 23
```

The second test I think shows what I'm seeing, after a signal the cache is set, and from there the queries reuse it.

Also notice that executing the same 500 queries is faster.

Hope this helps.


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-13 18:39:15.000 UTC</summary>

Thanks! I will check and confirm whether we cache query-only tasks. It is quite possible that we do not because it is possible to query completed workflows and we have intentionally chosen not to fill the cache for just queries which don't actually affect workflow execution. This only becomes obvious on large history size.

I will do some investigation and confirm and see what options we have here.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-14 14:16:56.000 UTC</summary>

I have confirmed that the code intentionally does this. At https://github.com/temporalio/sdk-go/blob/706516c7077ba2e9b40304aeddbed47e25b2a68f/internal/internal_task_handlers.go#L636-L638 it intentionally does not cache tasks containing that query field (which means it's a query-only task). Also at https://github.com/temporalio/sdk-go/blob/706516c7077ba2e9b40304aeddbed47e25b2a68f/internal/internal_task_handlers.go#L606-L608 it will attempt to reuse a cached workflow if the query is present without the full history (which means the history is partial because we've cached it previously like when signal was run).

On query-only tasks we are not wanting to cache because they have no side effects. Since it's a side effect free process, it has traditionally been seen as a stateless/no-cache process. There is no advancement of workflow history/code. If this is problematic for your use cases, we can talk about potential options here to maybe expose more cache control over query-only situations.

Knowing that this is intentional behavior, the concern now is memory leak. Sure not using the cache requires all workflow steps rerun each time making queries slower and temporarily causing more mem and gc cycles. But I am showing that the memory is constantly rising with each query. I am profiling that now.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-14 19:20:28.000 UTC</summary>

I have opened a PR at #779 to fix the goroutine/mem leak that is occurring from queries over and over. If you add this to your `go.mod`:

    replace go.temporal.io/sdk => github.com/cretz/temporal-sdk-go query-goroutine-leak

And then run `go mod tidy` to turn that into a proper pseudo-version and then run the code again, you will see the memory usage now does not grow on repeated query invocations.

As for whether query-only workflow tasks should reuse a cache or not, that's a bit of a larger question and if there's a good enough use case we can look into make that opt-in.

</details>

<details>
<summary><strong>Unknown</strong> commented on 2022-04-18 17:43:14.000 UTC</summary>

@cretz Awesome, thanks a lot.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-26 22:21:17.000 UTC</summary>

This has been merged and should be released in a couple weeks. There should not be a leak anymore in this use case. I am closing the issue, but feel free to comment/reopen if it persists.

If the need to reuse a cache for query-only tasks is really necessary, which I am not sure it is, we can discuss in Slack or a new issue.

</details>


---

<a id="1687"></a>

### #1687:  undefined: nexus.HandlerErrorTypeDownstreamTimeout error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1687 |
| **State** | CLOSED |
| **Author** | Flo4604 (Flo) |
| **Created** | 2024-10-25 10:12:30.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-30 13:19:20.000 UTC |
| **Closed** | 2024-10-30 13:19:11.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 2 |
| **Priority Score** | 10 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

## Expected Behavior

To not see this error message.

## Actual Behavior
Getting the following error: 

```
# go.temporal.io/sdk/internal

../../../go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_nexus_task_handler.go:480:36: undefined: nexus.HandlerErrorTypeDownstreamTimeout
```

## Steps to Reproduce the Problem

## Specifications
  - Go Version: 1.23
  - Version: go.temporal.io/sdk v1.29.1
  - Platform: macOS 15.1 (24B83) / ubuntu github runner
  
  
 Using v1.29.0 fixes this issue.


#### Comments (2)

<details>
<summary><strong>Flo4604</strong> commented on 2024-10-29 21:29:42.000 UTC</summary>

Looks like this was fixed with the 1.30.0 updated.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-30 13:19:11.000 UTC</summary>

Yes, this was an unfortunate case where our latest Go SDK version could not depend on our latest Go API version. This should no longer be the case and we will try to prevent this issue in the future.

</details>


---

<a id="1423"></a>

### #1423: contrib/datadog/v0.3.0 release

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1423 |
| **State** | CLOSED |
| **Author** | mallsk23 (Sunil Mall) |
| **Created** | 2024-03-14 03:09:54.000 UTC (1y 10m ago) |
| **Updated** | 2024-03-18 23:25:39.000 UTC |
| **Closed** | 2024-03-18 23:10:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 10 |
| **Priority Score** | 10 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hi,

Thank you for the release https://github.com/temporalio/sdk-go/releases/tag/contrib%2Fdatadog%2Fv0.2.0 which does away with the broken dependency:

```
#25 4.314 go: go.temporal.io/sdk/contrib/datadog@v0.1.0 requires
#25 4.314 	gopkg.in/DataDog/dd-trace-go.v1@v1.42.0 requires
#25 4.314 	github.com/99designs/gqlgen@v0.14.0 requires
#25 4.314 	sourcegraph.com/sourcegraph/appdash-data@v0.0.0-20151005[221](https://github.com/myorg/myrepo/actions/runs/2257091395/job/19770439394#step:6:223)446-73f23eafcf67: unrecognized import path "sourcegraph.com/sourcegraph/appdash-data": reading https://sourcegraph.com/sourcegraph/appdash-data?go-get=1: 404 Not Found
```

The `contrib/datadog/v0.2.0` release itself does contain a reference to the retracted `go.temporal.io/api v1.26.1`:
* https://github.com/temporalio/sdk-go/blob/cb1d35e7223a608d1e083b5faf1b2e704802544e/contrib/datadog/go.mod#L40
* https://github.com/temporalio/api-go/blob/5777bb90676c125ee6e634236f86c0a14391a606/go.mod#L29

Would it be possible to release a `contrib/datadog/v0.3.0` version which no longer depends on the retracted `go.temporal.io/api v1.26.1`?

#### Comments (10)

<details>
<summary><strong>mallsk23</strong> commented on 2024-03-14 03:13:50.000 UTC</summary>

cc @Quinn-With-Two-Ns is this something you could take a look at? ðŸ™ 

</details>

<details>
<summary><strong>mallsk23</strong> commented on 2024-03-14 03:59:17.000 UTC</summary>

I see that latest contrib/datadog/go.mod uses `go.temporal.io/api v1.29.1` instead of  `go.temporal.io/api v1.26.1`:
https://github.com/temporalio/sdk-go/blame/03d7704d2975ea34f577e45d33221ab1e228be3c/contrib/datadog/go.mod#L40

</details>

<details>
<summary><strong>mallsk23</strong> commented on 2024-03-15 14:20:36.000 UTC</summary>

Or @lminaudier is this something you could help with?

(tagging folks that have tagged a release recently or contributed to `contrib/datadog`)

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-15 14:44:35.000 UTC</summary>

Hi @mallsk23, yes we can tag another release, but i'll note you can just use a later version of the `api` or use  the latest `sdk` which will do that automatically.

</details>

<details>
<summary><strong>mallsk23</strong> commented on 2024-03-15 14:55:21.000 UTC</summary>

Thank you @Quinn-With-Two-Ns - will keep an eye out for the `contrib/datadog/v0.3.0` tag

</details>

<details>
<summary><strong>mallsk23</strong> commented on 2024-03-15 16:47:46.000 UTC</summary>

Apologies for the repeat tag @Quinn-With-Two-Ns as I meant to ask previously, would you have a sense as to when the `contrib/datadog/v0.3.0` tag will be available?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-15 17:29:33.000 UTC</summary>

I would expect Monday

</details>

<details>
<summary><strong>mallsk23</strong> commented on 2024-03-18 15:37:55.000 UTC</summary>

Thank you @Quinn-With-Two-Ns - would you be able to tag a `contrib/datadog/v0.3.0` release today?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-18 23:10:20.000 UTC</summary>

Published a new release https://pkg.go.dev/go.temporal.io/sdk/contrib/datadog@v0.3.0/tracing

</details>

<details>
<summary><strong>mallsk23</strong> commented on 2024-03-18 23:25:38.000 UTC</summary>

Appreciate the release! 

</details>


---

<a id="808"></a>

### #808: Add ReplayWorkflowHistoryFromReader (or similar)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/808 |
| **State** | CLOSED |
| **Author** | gsmcwhirter (Gregory McWhirter) |
| **Created** | 2022-05-16 15:47:00.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-30 11:24:55.000 UTC |
| **Closed** | 2022-06-30 11:24:55.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 8 |
| **Priority Score** | 10 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

I'd like to use go:embed to access replay history files in the repository for testing. However, the current replay API seems to require me parsing the contents into a history object myself or not using go:embed and using a static file name instead.

**Describe the solution you'd like**

Add `ReplayWorkflowHistoryFromReader(logger log.Logger, jsonFile io.Reader) error` and `ReplayPartialWorkflowHistoryFromReader(logger log.Logger, jsonfile io.Reader, lastEventID int64) error` (or similar) to the `WorkflowReplayer` interface and implementations. 

**Describe alternatives you've considered**


**Additional context**
Adding these APIs could also enable other future uses where replay histories were stored on a remote server, or stored gzipped, etc.


#### Comments (8)

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 15:52:47.000 UTC</summary>

In retrospect I think we regret even having a file-reader call. Basically all you need is to take the JSON and `github.com/gogo/protobuf/jsonpb.Unmarshal` into a `go.temporal.io/api/history/v1.History` proto, then you can call `ReplayWorkflowHistory` directly.

Is this an acceptable solution for you?

</details>

<details>
<summary><strong>gsmcwhirter</strong> commented on 2022-05-16 15:57:48.000 UTC</summary>

From a test-writing perspective, it would be nice to not have to care about how to unmarshal the replay and just hand off the bytes to the replayer to figure out. 

As a temporary workaround, your suggestion would probably work, at least for the non-partial case. In the partial case, putting the logic around extracting the part of the history to work with outside the go sdk seems brittle.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 16:02:55.000 UTC</summary>

Would a helper `func HistoryFromJSON(b []byte) (*history.History, error)` work? I am trying not to alter the interface and were I not concerned with backwards compatibility, I would also remove the file-based functions from the replayer interface.

</details>

<details>
<summary><strong>gsmcwhirter</strong> commented on 2022-05-16 16:05:26.000 UTC</summary>

A helper that took an `io.Reader` and maybe a `lastEventID` parameter instead of just `[]byte` would be more helpful I think, but `[]byte` could be made to work as well


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 16:20:53.000 UTC</summary>

Ok, I will use reader. The amount is expected to fit in memory anyways, so a reader isn't really necessary, but anyone can do `bytes.NewReader` if they want. I will also provide a "partial" form which accepts the last event ID though it's rare for people to use that (anyone can also trim off the events slice in the result themselves).

</details>

<details>
<summary><strong>gsmcwhirter</strong> commented on 2022-05-16 16:23:25.000 UTC</summary>

I personally haven't had a need to use partial replays yet, so if they're really not common, maybe it is enough for a user to trim down on their own. I do know that looking into the code for how the current versions work, it wasn't super clear to me how to slice history structure appropriately if there wasn't that example hanging around.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>gsmcwhirter</strong> commented on 2022-05-16 16:25:41.000 UTC</summary>

Also if the data is really that small, maybe `[]byte` is fine. From my reading, histories could get to something like 50k events before there's issues, which seems like it might be a decent bit of memory, but perhaps the expansion to actual memory size isn't as large as I imagine

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 16:40:08.000 UTC</summary>

It has to sit in the actual proto object anyways, which often takes more space than the serialized form (e.g. proto integers are variable length, false bools take no space, etc). But I'll use reader anyways.

</details>


---

<a id="529"></a>

### #529: Redesign interceptors to match the Java / Node.js capabilities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/529 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2021-09-09 09:34:54.000 UTC (4y 4m ago) |
| **Updated** | 2021-11-15 17:52:25.000 UTC |
| **Closed** | 2021-11-15 17:52:25.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 2 |
| **Priority Score** | 10 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

**Is your feature request related to a problem? Please describe.**

With the current interceptors design, there's no way to change the default execution of some SDK operations.
For example, one might want to use interceptors for authz when starting / signaling / querying workflows.

Some interceptor methods do not capture the entire span of the operation and cannot be used for tracing which is one of the use-cases for interceptors.

It also looks like there [query interceptor](https://github.com/temporalio/sdk-go/blob/cc674e0e50ffe72b85694a330cb85bc9b93e29aa/internal/interceptors.go#L64) is not chainable because it states that the interceptor implementor MUST call the provided handler function.

**Describe the solution you'd like**

Interceptors should have similar capabilities across the different SDKs, they should all be chainable, capture the entires span of the operation and allow modification of the default SDK behavior.

**Additional context**

- #526 - make sure that we support tracing for queries and signals (requires server changes to add headers to the protocol)
- There's been a community request to implement authz of signals / queries using interceptors

#### Comments (2)

<details>
<summary><strong>Sushisource</strong> commented on 2021-09-27 17:07:30.000 UTC</summary>

@vitarb This task doesn't mention the activity interceptor

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-09-27 17:10:53.000 UTC</summary>

(We need to track adding headers to signal/query protobuf messages somewhere)

</details>


---

<a id="492"></a>

### #492: Cannot reuse Workflow ID immediately

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/492 |
| **State** | CLOSED |
| **Author** | si-stripe (simon) |
| **Created** | 2021-07-20 00:12:33.000 UTC (4y 5m ago) |
| **Updated** | 2022-12-02 16:23:38.000 UTC |
| **Closed** | 2022-12-02 16:23:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 10 |
| **Priority Score** | 10 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
With a `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE` reuse policy, a Workflow ID should be able to be reused as soon as the Workflow before it completes.

## Actual Behavior
If I immediately try and reuse a Workflow ID I get:

```
2021/07/19 23:53:58 ERROR Workflow panic Namespace default TaskQueue ---- WorkerID --- WorkflowType WorkflowManagerWorkflow WorkflowID someWorkflowId-manager RunID c68cd12c-3761-4e8b-9b9c-44e541216a8f Attempt 1 Error adding duplicate command CommandType: ChildWorkflow, ID: someWorkflowId, state=Created, isDone()=false, history=[Created] StackTrace coroutine root [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
        external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:393
go.temporal.io/sdk/internal.(*commandsHelper).addCommand(0xc00013f400, 0x1de05c8, 0xc000635780)
        external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:841 +0x349
go.temporal.io/sdk/internal.(*commandsHelper).startChildWorkflowExecution(0xc00013f400, 0xc000646500, 0x0, 0x0)
        external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:1021 +0x59
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).ExecuteChildWorkflow(0xc000f53680, 0xc000ec8280, 0x8, 0x0, 0x0, 0x0, 0xc000d66728, 0x7, 0xc00063e7e0, 0xe, ...)
        external/io_temporal_go_sdk/internal/internal_event_handlers.go:395 +0x2e9
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteChildWorkflow(0xc0001434a0, 0x1dd2ee8, 0xc000fb0ed0, 0x1fcee8d, 0x10, 0xc000635680, 0x1, 0x1, 0x10, 0x11b0240)
        external/io_temporal_go_sdk/internal/workflow.go:708 +0x86d
go.temporal.io/sdk/internal.ExecuteChildWorkflow(0x1dd2ee8, 0xc000fb0ed0, 0x11e6740, 0x1b86f88, 0xc000635680, 0x1, 0x1, 0x0, 0x0)
        external/io_temporal_go_sdk/internal/workflow.go:671 +0x193
go.temporal.io/sdk/workflow.ExecuteChildWorkflow(...)
        external/io_temporal_go_sdk/workflow/workflow.go:182
reflect.Value.call(0x11bab60, 0x1b86f98, 0x13, 0x135e73d, 0x4, 0xc000f0edf0, 0x1, 0x1, 0x1d97740, 0x133c320, ...)
        GOROOT/src/reflect/value.go:476 +0x8e7
reflect.Value.Call(0x11bab60, 0x1b86f98, 0x13, 0xc000f0edf0, 0x1, 0x1, 0x1d97740, 0x133c320, 0xc0001434a0)
        GOROOT/src/reflect/value.go:337 +0xb9
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0xc0001434a0, 0x1dd2d60, 0xc00013f540, 0xc000984108, 0x17, 0x0, 0x0, 0x0, 0x0, 0x0, ...)
        external/io_temporal_go_sdk/internal/workflow.go:391 +0x2cb
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0xc00013f4c0, 0x1dd2d60, 0xc00013f540, 0x0, 0xc000dcc738, 0xc8c8e5, 0x0)
        external/io_temporal_go_sdk/internal/internal_worker.go:755 +0x316
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1(0x1dd2ee8, 0xc000f4fad0)
        external/io_temporal_go_sdk/internal/internal_workflow.go:494 +0xf5
2021/07/19 23:53:58 WARN  Failed to process workflow task. Namespace default TaskQueue ---- WorkerID --- WorkflowType WorkflowManagerWorkflow WorkflowID someWorkflowId-manager RunID c68cd12c-3761-4e8b-9b9c-44e541216a8f Attempt 1 Error adding duplicate command CommandType: ChildWorkflow, ID: someWorkflowId, state=Created, isDone()=false, history=[Created]
```

## Steps to Reproduce the Problem

  1. Create a Workflow that starts a child workflow with ID `ChildWorkflow`
  2. Have ChildWorkflow return and send a signal to Parent workflow that it's done
  3. When Parent workflow receives done signal, start a new child workflow with ID `ChildWorkflow`

## Specifications

  - Version: 1.9.2
  - Platform: Go


#### Comments (10)

<details>
<summary><strong>si-stripe</strong> commented on 2021-07-20 00:13:40.000 UTC</summary>

I can get around this by adding a `workflow.Sleep(ctx, 1*time.Millisecond)`

</details>

<details>
<summary><strong>wxing1292</strong> commented on 2021-07-20 00:15:05.000 UTC</summary>

@si-stripe

workflow ID reuse policy specifies when the current workflow finishes (completed / timeout / terminated / cancelled, etc) & if caller trying to start a workflow with the same workflow ID, what is the behavior.

above meaning workflow ID reuse policy will not be even evaluated if there is a workflow with the same workflow ID running.

e.g. # 1
T = 0 workflow with workflow ID 1 is running
T = 1 caller try to start a workflow with same workflow ID, as long as above workflow is still running, this call to start will fail

e.g. # 2
T = 0 workflow with workflow ID 1 is running
T = 1 above workflow finished (completed / timeout / failed / cancelled, etc)
T = 2 caller try to start a workflow with same workflow ID, with workflow ID reuse policy, since above workflow is finished, this policy will be evaluated accordingly

</details>

<details>
<summary><strong>wxing1292</strong> commented on 2021-07-20 00:20:35.000 UTC</summary>

the error / stack trace is emitted by go SDK, probably due to child state machine invariant being broken.
@Sushisource  any suggestion?

</details>

<details>
<summary><strong>si-stripe</strong> commented on 2021-07-20 00:20:42.000 UTC</summary>

I have the signal being sent in a `defer` function, which should run just before the Workflow returns.

What ends up happening is:
T = 0: Workflow with workflow ID 1 is running
T = 1: Workflow runs the `defer` function, signaling to Parent that it's done
T = 1.5: Parent receives signal and tries to run new Workflow with same ID
T = 2: Workflow actually returns

Is there a better way for a parent workflow to know when the child finishes without blocking on a `future.Get()`?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-07-20 16:43:31.000 UTC</summary>

In your scenario, the child is not completed yet when the signal is received. So the attempt to schedule another child with the same ID fails per design.

Waiting on the child's future is the supported way to learn about a child's completion. I don't understand why you are trying to use a signal for this.

</details>

<details>
<summary><strong>si-stripe</strong> commented on 2021-07-21 00:24:45.000 UTC</summary>

I wanted to use signals/select to control my Workflow without polling. 

I can achieve this by creating a goroutine that blocks on `future.Get()` and then sends a Signal to indicate that the child is done. If you think it's a common pattern, I'm happy to add some docs for this

</details>

<details>
<summary><strong>Drahflow</strong> commented on 2022-12-02 15:44:02.000 UTC</summary>

We hit the same issue today, and I became convinced the issue has been closed in error. The internal state machine command IDs for child workflows depend only on the child's workflow ID:
https://github.com/temporalio/sdk-go/blob/a23dec9aba94a515920e3d298ce29190316b295d/internal/internal_command_state_machine.go#L429,L435
... but if the same workflow ever tries to create two children with the same ID (which is legal if it made sure that the first has completed before) it will still panic.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 16:14:26.000 UTC</summary>

@Drahflow - Reopening as I believe this issue probably does exist. In the meantime as a workaround can you use unique child workflow IDs for each child workflow invocation?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 16:17:50.000 UTC</summary>

@Drahflow - Can you provide a small standalone replication? Can you make sure you are waiting for child workflow completion in this replication?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 16:23:10.000 UTC</summary>

Ok, after attempted replication, I am able to create children with the same ID. Please make sure you confirm the previous one is complete. Here's an example of creating a child every 5 seconds:

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	c, err := client.NewClient(client.Options{})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting worker")
	taskQueue := uuid.NewString()
	worker := worker.New(c, taskQueue, worker.Options{})
	worker.RegisterWorkflow(MyWorkflow)
	worker.RegisterWorkflow(MyChildWorkflow)
	if err := worker.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}

	log.Printf("Starting workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, MyWorkflow)
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}

	return run.Get(ctx, nil)
}

func MyWorkflow(ctx workflow.Context) error {
	// Start children with the same ID over and over
	ctx = workflow.WithChildOptions(ctx, workflow.ChildWorkflowOptions{
		WorkflowID: workflow.GetInfo(ctx).WorkflowExecution.ID + "-child",
	})
	for {
		workflow.GetLogger(ctx).Info("Starting child and waiting for completion")
		if err := workflow.ExecuteChildWorkflow(ctx, MyChildWorkflow).Get(ctx, nil); err != nil {
			return err
		}
	}
}

func MyChildWorkflow(ctx workflow.Context) error {
	return workflow.Sleep(ctx, 5*time.Second)
}
```

That command is removed on child workflow complete. So the dupe command ID is acceptable.

</details>


---

<a id="313"></a>

### #313: Allow including local activity input into the history

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/313 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-12-17 19:13:15.000 UTC (5 years ago) |
| **Updated** | 2025-02-04 18:48:09.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 2 |
| **Priority Score** | 10 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

**Is your feature request related to a problem? Please describe.**
In some scenarios, a local activity is used to log the whole state of a workflow on every change. As the state is large the history becomes very big. The local activity input is included in the marker event only for human consumption and is not used by the SDK. 

**Describe the solution you'd like**
Add `LocalActivityOption.DoNotIncludeArgumentsIntoHistory` option. When set to `true` the input will not be included into the local activity marker event.



#### Comments (2)

<details>
<summary><strong>pdcalado</strong> commented on 2020-12-20 00:38:23.000 UTC</summary>

Hi @mfateev thanks for opening the issue.

I was looking at the master branch and from what I was able to understand, the input arguments don't seem to be stored in the marker event (`EVENT_TYPE_MARKER_RECORDED`).

Concretely, in `internal/internal_events_handler.go` at [ProcessLocalActivityResult](https://github.com/temporalio/sdk-go/blob/master/internal/internal_event_handlers.go#L1174), a `HistoryEvent` is filled in with `localActivityMarkerData` and `localActivityResult.result`, none of which contains nested params with `InputArgs`.
Perhaps it's in another event type ?

I'm probably missing something here, if you can point me in the right direction I'll be happy to contribute with a PR.

Thanks again, cheers

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-04-30 17:25:51.000 UTC</summary>

The relevant Java PR: https://github.com/temporalio/sdk-java/pull/441

</details>


---

<a id="1424"></a>

### #1424: Context deadline exceeded when using the context passed to the activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1424 |
| **State** | CLOSED |
| **Author** | mrkaspa (Michel Perez) |
| **Created** | 2024-03-19 21:56:41.000 UTC (1y 9m ago) |
| **Updated** | 2025-02-04 18:19:53.000 UTC |
| **Closed** | 2025-02-04 18:19:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

I should no receive the error ```context deadline exceeded``` when doing DB operations with the context passed in the Activity parameter

## Actual Behavior

I have code like this in my app

```go
func CleanupActivity(ctx context.Context) error {
	// this is a TemporalLogger (pkg/logger/temporal.go)
	log := activity.GetLogger(ctx)

	return cleanup.Cleanup(ctx, param.JobID)
}
```

```go
func Cleanup(ctx context.Context, jobID string) error {
	db := database.GetDB()

	// Fetch the job from the database.
	j := &job.Job{ID: jobID}
	err := db.NewSelect().Model(j).WherePK().Scan(ctx)
	if err != nil {
		return wferrors.NewTaskError(errors.WithStack(err), wferrors.ErrCodeDatabase, "failed to fetch job")
	}
```

and inside the cleanup.Cleanup function I do database operations with the Bun library that uses the context that is passed so when it tries to make a query I got the error:

```
DatabaseError, failed to fetch job, context deadline exceeded
```

so the database query is failing due  to  ```context deadline exceeded```

## Steps to Reproduce the Problem

  1. Use the context passed in the Activity as argument for database access
  2. Deploy on production

## Specifications

  - Version: go.temporal.io/sdk v1.25.1
  - Platform: Linux


#### Comments (9)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-19 22:05:38.000 UTC</summary>

The context passed into an activity has documentation around when users should expect it to be cancelled 

https://github.com/temporalio/sdk-go/blob/3da09e02e2d4b36d24cc52a6ef0c9c46e92b78c1/activity/doc.go#L77

I would suspect in your case the activity is timing out before the database operation is complete. 

</details>

<details>
<summary><strong>mrkaspa</strong> commented on 2024-03-20 16:47:07.000 UTC</summary>

Yes, I thought that, but the problem is that my deadline is of 1 hour per activity and when it starts failing for example failed the job 1 the subsquents jobs keep failing for the same reason, how can fail a new job for this reason if I have a deadline of  1 hour per activity.

btw, this is how I have the workflow settings

```go
activityoptions := workflow.ActivityOptions{
		// Set Activity Timeout duration
		// ScheduleToCloseTimeout: 5 * time.Second,
		StartToCloseTimeout: 60 * time.Minute,
		// ScheduleToStartTimeout: 10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, activityoptions)
	ctx = workflow.WithRetryPolicy(ctx, temporal.RetryPolicy{
		MaximumAttempts: 10,
	})
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-20 16:58:15.000 UTC</summary>

The timeouts can be shorter depending on what other activity and workflow option, it is also possible the error is coming from some internal deadline set in your database library and not the activity context. You can check the deadline of the context using `ctx.Deadline()` to see when the context would expire.

https://pkg.go.dev/context#Context

</details>

<details>
<summary><strong>mrkaspa</strong> commented on 2024-03-20 17:18:19.000 UTC</summary>

The problem is that this does not happen everytime, in our production experience we have deployed the solution and everything works fine for some executions, and after some days one workflow starts to fail and the next ones will always fail for the same reason

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-20 17:45:55.000 UTC</summary>

On one of these occurrences can you share the actual activity schedule event ? 

</details>

<details>
<summary><strong>mrkaspa</strong> commented on 2024-04-09 19:09:57.000 UTC</summary>

@Quinn-With-Two-Ns where can I see that?

</details>

<details>
<summary><strong>mrkaspa</strong> commented on 2024-04-09 19:10:58.000 UTC</summary>

rn this is failing again

```
error
activity error (type: PreprocessingActivity, scheduledEventID: 5, startedEventID: 6, identity: ): activity StartToClose timeout (type: StartToClose): activity StartToClose timeout (type: StartToClose)

Error
last connection error: connection error: desc = "error reading server preface: read tcp 172.17.0.12:39422->52.26.119.98:7233: use of closed network connection"

PanicError
runtime error: index out of range [4096] with length 4096
```

we are seeing this error, I wonder if somehow the connection with the temporal servers is lost

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-09 19:18:34.000 UTC</summary>

The last errors looks like an issue with you application and not the SDK, but just the error message  is not enough  for me to provide any insight and I cannot tell what is wrong with your application. 

To  help debug any further what I would need is a stand alone reproduction of the issue showing the SDK canceling the context outside of the documented cases where users should expect it to be cancelled https://github.com/temporalio/sdk-go/blob/3da09e02e2d4b36d24cc52a6ef0c9c46e92b78c1/activity/doc.go#L77

</details>

<details>
<summary><strong>mrkaspa</strong> commented on 2024-04-09 19:24:58.000 UTC</summary>

we are using nomad to deploy our containers and when restart them the issue is solved, this issue uses to happen everyweek, all the workflows start to throw timeouts and I think the reason is they lost connection with the temporal servers, so the temporal server can not execute the activities and time out

</details>


---

<a id="1041"></a>

### #1041: Workflow got hanged if spawn childWorkflow with same workflowId

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1041 |
| **State** | CLOSED |
| **Author** | raymondsze (Sze Ka Wai Raymond) |
| **Created** | 2023-02-16 11:45:23.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-16 20:45:18.000 UTC |
| **Closed** | 2023-03-16 20:45:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I expect the parent workflow can be run successfully and only one child workflow is executed (because same workflow id). 

## Actual Behavior
It hanged in the second child workflow `childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE)`. 

## Steps to Reproduce the Problem
I followed the documentation in https://legacy-documentation-sdks.temporal.io/go/spawn-a-child-workflow-execution.
If I spawn two childworkflow, both with the same workflowId. The second one will be hanged when calling `childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE)`. What I want to do is, if the child workflow is already registered and running, then don't do anything. If the child workflow is completed or not yet registered, then register and run the child workflow without waiting. 

## Specifications

  - Version:
  - Platform:


#### Comments (9)

<details>
<summary><strong>cretz</strong> commented on 2023-02-16 13:06:50.000 UTC</summary>

Can you provide the SDK version you are using (to see if it includes https://github.com/temporalio/sdk-go/pull/999) and if possible provide a small amount of code to demonstrate this? You should be able to respond to the duplicate error coming back from that `Get`.

</details>

<details>
<summary><strong>raymondsze</strong> commented on 2023-02-17 03:26:22.000 UTC</summary>

Sure. The sdk version is the latest,  v1.21.1
```go

func ConsumerWorkflow(ctx workflow.Context) error {
	logger := workflow.GetLogger(ctx)
	for i := 0; i < 2; i++ {
		childWorkflowOptions := workflow.ChildWorkflowOptions{
			ParentClosePolicy:     enums.PARENT_CLOSE_POLICY_ABANDON,
			WorkflowID:            fmt.Sprintf("consumer-%v-%v", workflow.GetInfo(ctx).WorkflowExecution.ID, 0),
			WorkflowIDReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE,
		}
		ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)
		logger.Info("BEFORE EXECUTE!")
		childWorkflow := workflow.ExecuteChildWorkflow(ctx, ChildWorkflow, i)
		logger.Info("AFTER EXECUTE!")
		logger.Info("BEFORE GET EXECUTION!")
		_ = childWorkflow.GetChildWorkflowExecution().Get(ctx, nil)
		logger.Info("AFTER GET EXECUTION!")
	}
	return nil
}
```

Here is the log

Worker
```bash
2023/02/17 11:22:28 INFO  No logger configured for temporal client. Created default one.
2023/02/17 11:22:28 INFO  Started Worker Namespace default TaskQueue hello-world WorkerID 4822@Raymond@
2023/02/17 11:22:39 INFO  BEFORE EXECUTE! Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1
2023/02/17 11:22:39 DEBUG ExecuteChildWorkflow Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1 ChildWorkflowID consumer-hello_world_1626421842992435200-0 WorkflowType ChildWorkflow
2023/02/17 11:22:39 INFO  AFTER EXECUTE! Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1
2023/02/17 11:22:39 INFO  BEFORE GET EXECUTION! Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1
2023/02/17 11:22:39 INFO  AFTER GET EXECUTION! Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1
2023/02/17 11:22:39 INFO  BEFORE EXECUTE! Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1
2023/02/17 11:22:39 INFO  AFTER EXECUTE! Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1
2023/02/17 11:22:39 INFO  BEFORE GET EXECUTION! Namespace default TaskQueue hello-world WorkerID 4822@Raymond@ WorkflowType ConsumerWorkflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9 Attempt 1
```
The "AFTER GET EXECUTION!" line didn't print for the 2nd child workflow that with the same workflow id. And the workflow keeps "Running" status.

Client
```
2023/02/17 11:22:39 INFO  No logger configured for temporal client. Created default one.
2023/02/17 11:22:39 Started workflow WorkflowID hello_world_1626421842992435200 RunID ea2be856-3b9d-452e-8f7d-b4b439f489b9
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-17 08:25:19.000 UTC</summary>

I can reproduce this looks like `WorkflowIDReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE` is not handled correctly

</details>

<details>
<summary><strong>raymondsze</strong> commented on 2023-02-17 09:13:09.000 UTC</summary>

@Quinn-With-Two-Ns 
Any workaround or I need wait a fix?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-17 09:19:56.000 UTC</summary>

I'll take a look, one obvious work around is to not using the same workflow ID for any child workflow.

</details>

<details>
<summary><strong>raymondsze</strong> commented on 2023-02-17 09:38:16.000 UTC</summary>

But this is what I wanna achieve.

If the child workflow does not exists --> start the child workflow
If the child workflow already exists and completed --> restart the child workflow
If the child workflow already exists and running --> do nothing

basically it is like a notifier to notify the child workflow there is a new message in something like mailbox, the child workflow is responsible to take the messages out of the mailbox. If the child is already picking message, then don't do anything to make sure only one child workflow is running.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-17 13:11:51.000 UTC</summary>

Since it's your workflow, you know whether you've started a child or not. You can maintain a set of child workflow futures keyed by their ID to get-or-create. Granted we need to fix this issue, but you still control what children you start and can easily check for your conditions.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-17 17:11:00.000 UTC</summary>

The problem appears to be from this PR https://github.com/temporalio/sdk-go/pull/999 the `ChildWorkflowExecutionAlreadyStartedError` is only set on one of the two futures child workflow use, so waiting on the execution future never unblocks. @Sushisource I can't see why we wouldn't propagate the error to both futures?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-03-09 07:09:24.000 UTC</summary>

This would break determinism if someone waited on the execution future in a selector, probably the best thing to do here is to use `SDKFlags` implemented here https://github.com/temporalio/sdk-go/pull/1056 to version the fix.

</details>


---

<a id="866"></a>

### #866: TestWorkflowEnvironment doesn't enforce WorkflowExecutionTimeout

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/866 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-07-23 17:50:03.000 UTC (3y 5m ago) |
| **Updated** | 2025-01-30 17:11:22.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 1 |
| **Priority Score** | 9 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

## Expected Behavior
Under unit test a child workflow times out if runs longer than its WorkflowExecutionTimeout.

When executing a workflow using testEnv.ExecuteWorkflow both run and execution timeouts should be enforced.

## Actual Behavior
Child workflow is allowed to run without timing out. A child workflow times out if WorkflowRunTimeout is specified and exceeded. The error message is confusing as it references an unexistent timeout:
```
workflow execution error (type: func1, workflowID: default-test-workflow-id, runID: default-test-run-id): child workflow execution error (type: Workflow, workflowID: default-test-run-id_1, runID: default-test-run-id_1_RunID, initiatedEventID: 0, startedEventID: 0): deadline exceeded (type: ScheduleToClose).

Also, none of the workflow timeouts are enforced if a workflow is executed through `testEnv.ExecuteWorkflow`.

```


#### Comments (1)

<details>
<summary><strong>kminder</strong> commented on 2025-01-30 17:07:50.000 UTC</summary>

Seems like this still an issue two years later.

go.temporal.io/api v1.43.0
go.temporal.io/sdk v1.32.1

temporal version 0.0.0-DEV (Server 1.26.2, UI 2.34.0)

</details>


---

<a id="723"></a>

### #723: Unable to reset workflow with completed childworkflow whose child workflowID is generated by SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/723 |
| **State** | CLOSED |
| **Author** | yycptt (Yichao Yang) |
| **Created** | 2022-02-10 18:31:50.000 UTC (3y 11m ago) |
| **Updated** | 2025-04-23 15:51:16.000 UTC |
| **Closed** | 2025-04-23 15:51:15.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 3 |
| **Priority Score** | 9 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 3 |

#### Description

## Expected Behavior
When reseting a workflow with no pending child execution. (Reset with pending child currently is not supported.)
After reset, parent workflow should continue execution without any error

## Actual Behavior
After reset, parent workflow will encounter a non-deterministic error during replay. The error happens when processing the child workflow init event and can't find the corresponding child workflow command/state machine.

The root cause is we use child workflow ID to find the corresponding command. However if child workflowID is not specified in child option, SDK will automatically generate one based on the workflow's runID. After reset, the workflow's runID changes but in workflow history the child workflow ID is still based on the original runID. Hence the not found and non-deterministic error.

## Steps to Reproduce the Problem

  1. Run a workflow with a child workflow. Do NOT specify the childworkflow ID in child option.
  2. Reset the workflow to an event_id after the child workflow completed event. Any workflow task close event (completed/failed/timeout) will work.
  3. Check the new workflow's history, the workflow task will fail due to non-deterministic error.

## Specifications

  - Version:
  - Platform:


#### Comments (3)

<details>
<summary><strong>yycptt</strong> commented on 2022-02-10 18:35:01.000 UTC</summary>

Server stores a workflow's original runID (in workflow start event) which won't change during reset. So one potential solution is generate child workflow ID based on this original runID. 

But this solution may conflict with some future work related to reset. 
@yiminc Would you mind provide some insights here? Thanks.

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-02-09 23:18:40.000 UTC</summary>

I hit this in #1385. I'm curious if there's any risk in using the OriginalRunId by default in the meantime.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-23 15:51:15.000 UTC</summary>

https://github.com/temporalio/sdk-go/pull/1803

</details>


---

<a id="722"></a>

### #722: CreateSession improperly retrying errors it should not

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/722 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-09 19:19:11.000 UTC (3y 11m ago) |
| **Updated** | 2022-03-07 19:32:07.000 UTC |
| **Closed** | 2022-03-07 19:32:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

At https://github.com/temporalio/sdk-go/commit/a88dec51b1767a1bab6426a602980d25a51d40eb#diff-5db8d6c4288666da4ff606f745645fe946e504370e93bbceb25402e0a520deb0 we inadvertently removed intentional retry-prevention to prevent session activity creation from retrying in all but the "too many sessions" case.

**Describe the solution you'd like**

Do not have session creation activity failure retry anything but "too many sessions".

#### Comments (9)

<details>
<summary><strong>yycptt</strong> commented on 2022-02-09 20:16:01.000 UTC</summary>

Some additional context here, one of the purposes of session creation activity is monitoring the health of worker process. If worker restarts while a session is running, the creation activity should fail and all user activities within this session will be cancelled. If the creation activity is retried for errors like timeout, workflow won't know the worker for session tasklist has already gone and continue to schedule more activities to that worker-specific tasklist which now has no poller. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-10 15:49:11.000 UTC</summary>

It appears you can't really set start-to-close or heartbeat timeouts as non-retryable. Only application failures. How should we implement "only retry a certain application error"? Should we manually loop in the workflow with out own backoff?

</details>

<details>
<summary><strong>yycptt</strong> commented on 2022-02-11 22:41:23.000 UTC</summary>

@cretz We will add support on server side for specifying timeout errors as non-retryable.

</details>

<details>
<summary><strong>yycptt</strong> commented on 2022-02-17 00:26:18.000 UTC</summary>

https://github.com/temporalio/sdk-go/blob/master/internal/session.go#L526
`errTooManySessions` is retryable so the third argument should actually `false` 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-17 13:50:20.000 UTC</summary>

@yycptt - Ok, I will make that non-retryable. I will wait on server update so that I can include in the same PR with a retry policy excluding timeouts from being retryable (please link issue here if/when available).

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-17 20:52:17.000 UTC</summary>

After discussion, we think we can solve this by just disallowing all retries on create session. As for the one case where we did want retries - max sessions reached - we think we can solve this by using max concurrent activities. Hopefully implementation on this will begin shortly.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-22 16:43:32.000 UTC</summary>

I am working to build a reproducer for this bug.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-23 19:00:31.000 UTC</summary>

Reproducer is complete, I am now implementing the fix and the tests for the fix.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-25 22:35:25.000 UTC</summary>

#739 was attempted but deemed unsafe for session recreation. Instead we will leverage https://github.com/temporalio/temporal/pull/2524 the way the older set of code once did and disable timeout retries. This means to get full session safety functionality, a server upgrade will be required (I may make a note of this point in the docs).

I will also cherry pick integration tests from #739 (that I didn't already for #741) and we will set max activity size on session creation activity worker (even though we know that is not enough to really solve the max across creation and recreation).



</details>


---

<a id="642"></a>

### #642: Inconsistent behavior when asserting invocations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/642 |
| **State** | OPEN |
| **Author** | embano1 (Michael Gasch) |
| **Created** | 2021-11-18 15:42:31.000 UTC (4y 1m ago) |
| **Updated** | 2024-03-15 05:00:05.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 7 |
| **Priority Score** | 9 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
Invocation count assertions provided by the mocking library, such as `Once()` or `Times(n)` should not show different error/panic behavior affecting test results and always fail a test if the assertion does not hold.

Either it should be documented that these methods should not be used due to this behavior or fixed, e.g. when recovering from panic and failing the test instead of passing.

## Actual Behavior
This activity is configured with retries. Under test, it throws `PanicError` in the logs when the code is executed multiple times (retries) but the **test succeeds** with `exit code 0`.

```go
env.OnActivity("MyActivity", any, any).Return(nil, errors.New("test failure")).Once() 
```

This activity is also configured with retries but since no error is returned it is only invoked once. Under test, it **fails the test** with a mocking error indicating that the function was only called once, i.e. `exit code != 0`.

```go
env.OnActivity("MyActivity", any, any).Return(nil, nil).Twice()
```

cc/ @cretz

## Steps to Reproduce the Problem
See above

## Specifications
* Version: `go.temporal.io/sdk v1.10.0`
* Platform: n/a



#### Comments (7)

<details>
<summary><strong>alfa-alex</strong> commented on 2022-08-03 10:19:17.000 UTC</summary>

Ran into the same issue (`go.temporal.io/sdk v1.15.0`).

What's your current position on this? Should the use of invocation count assertions be avoided at the moment?

</details>

<details>
<summary><strong>alfa-alex</strong> commented on 2022-08-03 10:40:57.000 UTC</summary>

Actually for my use-case there was a relatively simple fix to this: Calling `Test` on the `mock`.

So, instead of the original
```go
// NewTestWorkflowEnvironment creates a new instance of TestWorkflowEnvironment. Use the returned TestWorkflowEnvironment
// to run your workflow in the test environment.
func (s *WorkflowTestSuite) NewTestWorkflowEnvironment() *TestWorkflowEnvironment {
	return &TestWorkflowEnvironment{impl: newTestWorkflowEnvironmentImpl(s, nil)}
}
```
I'm now constructing the `TestWorkflowEnvironment` with:
```go
// NewTestWorkflowEnvironmentWithTest creates a new instance of TestWorkflowEnvironment. Use the returned TestWorkflowEnvironment
// to run your workflow in the test environment.
func (s *WorkflowTestSuite) NewTestWorkflowEnvironmentWithTest(t mock.TestingT) *TestWorkflowEnvironment {
	env := &TestWorkflowEnvironment{impl: newTestWorkflowEnvironmentImpl(s, nil)}
	env.mock.Test(t)
	return env
}
```
in the `workflow_testsuite.go`. This does actually fail the test in the above case.

Well possible this has undesired side-effects, but maybe something to consider. An alternative to having a different constructor would of course be to add a `Setter` func to the `TestWorkflowEnvironment`, but it felt quite naturally to me to construct the env with the test.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-03 13:21:53.000 UTC</summary>

> Under test, it throws PanicError in the logs when the code is executed multiple times (retries) but the test succeeds with exit code 0.

IIUC the original issue correctly, the code properly panics at call time when the invocation count is wrong, but the user is not checking `env.GetWorkflowError()` to get the actual workflow error so it doesn't fail their test.

The test environment is not just for running with the Go testing library. A panic calling the mock, whether that's for the assertion not holding or the body of the mock panicking, will follow normal panic paths. It is up to the user whether they treat a panic in a workflow as an error in their chosen environment.

Alternatively, if you can't properly assert that the panic does not occur in the workflow for whatever reason, you can just count invocations inside the body of the mock and assert later.

Does that help? Or am I misunderstanding the concern?

</details>

<details>
<summary><strong>alfa-alex</strong> commented on 2022-08-03 15:13:57.000 UTC</summary>

So you imply we should check the invocation count assertions via `env.GetWorkflowError()`? I thought that's what `env.AssertExpectations(t)` is for. The documentation reads:
```go
// AssertExpectations  asserts that everything specified with OnActivity
// in fact called as expected.  Calls may have occurred in any order.
```

To give you a minimal working example, change the `Test_Workflow` test of the `helloworld` sample in the `temporal-samples` project to:
```go
	testSuite := &testsuite.WorkflowTestSuite{}
	env := testSuite.NewTestWorkflowEnvironment()

	// Mock activity implementation
	env.OnActivity(Activity, mock.Anything, "Temporal").Return("", errors.New("some error")).Once()
	env.ExecuteWorkflow(Workflow, "Temporal")

	require.True(t, env.IsWorkflowCompleted())
	env.AssertExpectations(t)
```
Even though the output correctly indicates that `Activity` was called more than once, the test doesn't fail. And `env.AssertExpectations` returns true.

Am I misunderstanding the description of that function?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-03 15:23:04.000 UTC</summary>

> So you imply we should check the invocation count assertions via env.GetWorkflowError()? I thought that's what env.AssertExpectations(t) is for.

My mistake, yes, you can and should use that function if you want to assert the mocking expectations and you are in a test setting. I had forgotten about this helper. But you also want to check no error happened _inside_ the workflow by checking the workflow error.

The docs for https://pkg.go.dev/github.com/stretchr/testify/mock#Mock.AssertExpectations basically calls https://github.com/stretchr/testify/blob/v1.8.0/mock/mock.go#L610-L612 which seems to suggest it only fails if there were fewer calls than expected, not more. I believe this is how that mocking library works - when invoking more than expected, error at callsite, when invoking fewer than expected, error at expectation assertion site.

</details>

<details>
<summary><strong>alfa-alex</strong> commented on 2022-08-04 16:27:12.000 UTC</summary>

Yeah, it looks like a testify issue. I think it's been described here: https://github.com/stretchr/testify/issues/608.

Thank you!

---

Edit: To summarize, the invocation count assertions should probably best be avoided. Other than that you could use the following "solution" from a user side (if you need this in a test and you are testing a workflow run that is expected to fail, so you want to distinguish the errors):
```go
err := env.GetWorkflowError()
var panicErr *temporal.PanicError
if ok := errors.As(err, &panicErr); ok && strings.HasPrefix(panicErr.Error(), "\nassert: mock:") {
	assert.Fail(t, "failed mock assertion")
}
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-04 18:46:02.000 UTC</summary>

> invocation count assertions should probably best be avoided

Concur. And on a general best-practices note, the ease of adding counts can tempt one to overly assert counts leading to unnecessary expectations about the internals of the code under test. But if you had to manually count if you needed to confirm invocation counts, you'd be more willing to only do it where it was important to verify behavior.

</details>


---

<a id="636"></a>

### #636: Add WorkerOption to disable workflow worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/636 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-11-17 02:38:50.000 UTC (4y 1m ago) |
| **Updated** | 2022-01-18 19:42:36.000 UTC |
| **Closed** | 2022-01-18 19:42:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

Currently, there is no way to start worker for activity only. We need a flag in worker.Options to explicitly disable workflow worker.

#### Comments (9)

<details>
<summary><strong>mfateev</strong> commented on 2021-11-17 06:05:12.000 UTC</summary>

I don't think we need a flag. In Java SDK we don't start a workflow worker if no workflow is registered and don't start an activity worker if no activity is registered.

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-17 14:03:40.000 UTC</summary>

In Go SDK, we always start the workflow worker and we allow you to register workflows after the worker has started. Should we change this or should we accept an option that doesn't start the workflow worker and doesn't allow registering of workflows?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-11-20 01:52:32.000 UTC</summary>

What is the use case for starting workers and registering activities/workflows after the start? IMHO it adds a lot of unnecessary complexity.

</details>

<details>
<summary><strong>yiminc</strong> commented on 2021-11-20 02:06:22.000 UTC</summary>

We want the ability to start worker without workflow task poller (so it only poll for activity tasks). Currently, this is not possible because workflow worker is always started. There are 2 options we can achieve this:
1) Add an option to explicitly disable workflow worker.
2) Do not start workflow worker if there is no workflow type registered.
With option 2 combined with we allow workflow type registration after worker.Start() call, it would be very confusing.

The use case is for integration test where worker was setup by Setup() method before any workflow type is registered. With option 2, workflow worker won't be started. Then in the actual test method, workflow type is registered successfully. But since there is no workflow worker, test won't make any progress. 


</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-22 13:55:29.000 UTC</summary>

After off-issue discussion and assuming there are no caveats to doing so, we won't start the workflow worker until after the worker is started _and_ the first workflow is registered.

Reactions: â¤ï¸ 2

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-23 19:23:09.000 UTC</summary>

Thinking about the need to change the `Worker` and `Registry` interfaces to return an `error` from `RegisterX` if those calls are expected to be able to start internal workers. Will update with decision.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 21:16:46.000 UTC</summary>

@yiminc and @mfateev - Can y'all weigh in here? If we are wanting to lazily start the workflow worker until after `RegisterWorkflow` is called the first time, what do I do with the `error` if the worker fails to start? Or is there some other approach we should take?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2022-01-05 18:22:30.000 UTC</summary>

Inability to return an error on start looks really bad to me. I don't like that we can register new types after the worker has started. Maybe we should rethink the integration testing approach?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2022-01-05 18:29:36.000 UTC</summary>

After an offline discussion, it looks like the original proposal with the options flag is the best compromise which is backward compatible.

Reactions: ðŸ‘ 1

</details>


---

<a id="480"></a>

### #480: Activity result is not stored (and continued) when stopping worker gracefully

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/480 |
| **State** | CLOSED |
| **Author** | sev3ryn (Severyn Lisovskyi) |
| **Created** | 2021-06-22 19:27:55.000 UTC (4y 6m ago) |
| **Updated** | 2021-10-18 20:07:18.000 UTC |
| **Closed** | 2021-10-18 20:07:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
```
2021/06/22 10:40:46 INFO  workflow started 
2021/06/22 10:40:46 INFO  start-id id=0
2021/06/22 10:40:51 WARN  got interupt! id=5
2021/06/22 10:40:51 INFO continued activity id=5
2021/06/22 10:40:51 INFO  Stopped Worker Namespace default 
2021/06/22 10:40:51 INFO  Started Worker Namespace default 
2021/06/22 10:40:52 INFO  start-id id=5
2021/06/22 10:40:59 INFO workflow finished
```

## Actual Behavior
```
2021/06/22 10:40:46 INFO  Started Worker Namespace default TaskQueue split-merge WorkerID 5263@m1.local@
2021/06/22 10:40:46 INFO  workflow started Namespace default TaskQueue split-merge WorkerID 5263@m1.local@ WorkflowType SampleWorkflow WorkflowID bacaf3a6-c2e8-4e3f-8da8-18b138c877a3 RunID 4e8e62dc-542c-4c08-8ec3-72c07549d556 Attempt 1
2021/06/22 10:40:46 DEBUG ExecuteActivity Namespace default TaskQueue split-merge WorkerID 5263@m1.local@ WorkflowType SampleWorkflow WorkflowID bacaf3a6-c2e8-4e3f-8da8-18b138c877a3 RunID 4e8e62dc-542c-4c08-8ec3-72c07549d556 Attempt 1 ActivityID 5 ActivityType SampleActivity
2021/06/22 10:40:46 INFO  start id Namespace default TaskQueue split-merge WorkerID 5263@m1.local@ ActivityID 5 ActivityType SampleActivity Attempt 1 WorkflowType SampleWorkflow WorkflowID bacaf3a6-c2e8-4e3f-8da8-18b138c877a3 RunID 4e8e62dc-542c-4c08-8ec3-72c07549d556 id 0
2021/06/22 10:40:51 WARN  got interupt! Namespace default TaskQueue split-merge WorkerID 5263@m1.local@ ActivityID 5 ActivityType SampleActivity Attempt 1 WorkflowType SampleWorkflow WorkflowID bacaf3a6-c2e8-4e3f-8da8-18b138c877a3 RunID 4e8e62dc-542c-4c08-8ec3-72c07549d556 id 5
2021/06/22 10:40:51 INFO  Task processing failed with error Namespace default TaskQueue split-merge WorkerID 5263@m1.local@ WorkerType ActivityWorker Error worker stopping
2021/06/22 10:40:51 INFO  Stopped Worker Namespace default TaskQueue split-merge WorkerID 5263@m1.local@
2021/06/22 10:40:51 INFO  Started Worker Namespace default TaskQueue split-merge WorkerID 5263@m1.local@
```
## Steps to Reproduce the Problem

  1. See and run following [code](https://pastebin.com/1nrQ8YDN). History of such workflow can be found [here](https://pastebin.com/4jZfGs6f)

## Specifications

  - Version: 
  SDK: go.temporal.io/sdk v1.7.0
  Temporal: v1.9.0
   DB: cassandra 3.11.9
   
  - Platform:
   linux/amd64

#### Comments (9)

<details>
<summary><strong>wxing1292</strong> commented on 2021-06-22 19:38:11.000 UTC</summary>

activity heartbeat details / progress is not stored in workflow history, but within workflow itself

does `tctl --namespace <namespace> workflow describe -w <workflow ID>` shows the activity heartbeat details?

</details>

<details>
<summary><strong>sev3ryn</strong> commented on 2021-06-23 07:50:07.000 UTC</summary>

I'm not expecting heartbeat to be stored in history. Here I mean - when worker is in graceful shutdown mode (after executing worker.Stop but before exceeding WorkerStopTimeout) all the activity results that are returned in the same time are not stored anywhere, so they are not noticed by workflow execution. Workflow execution continues to expect results from activity that actually already properly ended.

Here is the the output of tctl command - lastHeartbeatTime is not updating. This workflow will fail later because of StartToClose - but at the same time it will not execute anything

<details><summary>Full command output</summary>
<p>

```
{
  "executionConfig": {
    "taskQueue": {
      "name": "split-merge",
      "kind": "Normal"
    },
    "workflowExecutionTimeout": "0s",
    "workflowRunTimeout": "0s",
    "defaultWorkflowTaskTimeout": "10s"
  },
  "workflowExecutionInfo": {
    "execution": {
      "workflowId": "1bfcba91-2bed-4677-84a7-51589037e1f6",
      "runId": "d6f4f0b4-95f0-4e71-a157-0650e9c07917"
    },
    "type": {
      "name": "SampleWorkflow"
    },
    "startTime": "2021-06-23T06:52:15.445305804Z",
    "status": "Running",
    "historyLength": "5",
    "memo": {

    },
    "searchAttributes": {
      "indexedFields": {
        "BinaryChecksums": "[\"905b1840ac923516d00b15ed1fae63a7\"]"
      }
    },
    "autoResetPoints": {
      "points": [
        {
          "binaryChecksum": "905b1840ac923516d00b15ed1fae63a7",
          "runId": "d6f4f0b4-95f0-4e71-a157-0650e9c07917",
          "firstWorkflowTaskCompletedId": "4",
          "createTime": "2021-06-23T06:52:15.773711707Z",
          "resettable": true
        }
      ]
    }
  },
  "pendingActivities": [
    {
      "activityId": "5",
      "activityType": {
        "name": "SampleActivity"
      },
      "state": "Started",
      "lastHeartbeatTime": "2021-06-23T06:52:15.789476631Z",
      "lastStartedTime": "2021-06-23T06:52:15.789476631Z",
      "attempt": 1,
      "expirationTime": "0001-01-01T00:00:00Z"
    }
  ]
}
```

</p>
</details>


</details>

<details>
<summary><strong>wxing1292</strong> commented on 2021-06-23 08:31:14.000 UTC</summary>

so let me see if i get the issue right:
activity heartbeats / completions during the worker grace shutdown period do not correctly propagated to server?

</details>

<details>
<summary><strong>wxing1292</strong> commented on 2021-06-23 08:32:06.000 UTC</summary>

@vitarb can you take a look?

</details>

<details>
<summary><strong>changwuf31</strong> commented on 2021-09-13 06:39:02.000 UTC</summary>

Hi, any ETA or any update on this issue ?

Many thanks

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-09-13 19:16:33.000 UTC</summary>

Sorry all, looks like this one slipped off the radar.

In any case, I can confirm that this looks like an SDK bug and does repro. The worker should properly complete the activity in this case when it receives the interrupt. We'll take a look at this soon.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>changwuf31</strong> commented on 2021-10-05 07:21:55.000 UTC</summary>

Hi, is the PR https://github.com/temporalio/sdk-go/pull/520 already fix this ?
Or is it not related at all with this ?

Many thanks 

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-07 20:50:44.000 UTC</summary>

Here is the Java analogue: https://github.com/temporalio/sdk-java/issues/731. We are intentionally not recording this, see https://github.com/cretz/sdk-go/blob/b52191f564572912c7835573567eb7ff7e802530/internal/internal_task_pollers.go#L884-L887

Currently reviewing the cost of this specific fix while weighing other potential approaches including suggesting using external notification mechanisms or incorporating a more two-phased stop throughout.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-08 13:36:42.000 UTC</summary>

Replicated issue and fixed in #579

Reactions: ðŸ‘ 1

</details>


---

<a id="475"></a>

### #475: Panic when querying during Workflow failure + retry 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/475 |
| **State** | OPEN |
| **Author** | leowmjw |
| **Created** | 2021-06-21 16:47:49.000 UTC (4y 6m ago) |
| **Updated** | 2022-06-01 13:34:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
No panic should occur when querying a registered QueryHandler; even when the workflow has failed and is retrying

## Actual Behavior
After max attempt for Activity has passed; the whole Workflow has failed and is restarted.

Observe the panic "Attempt to generate a command before processing WorkflowTaskStarted event" due to "WorkerType WorkflowWorker Error operation GetWorkflowExecution encounter not found"

## Logs
$ go run main.go
...
2021/06/21 23:31:45 ERROR Activity error. Namespace default TaskQueue onboarding.queue.name WorkerID 11259@Mojaves-iMac.local@ WorkflowID mleow-1 RunID a7f324da-ccf1-4f1a-97d3-f43df8af9260 ActivityType FailActivities Attempt 2 Error FAIL mleow-1 (type: TEMP, retryable: true)
WID:  mleow-1  CTX_ATTEMPT:  2

2021/06/21 23:31:45 ERROR Workflow panic Namespace default TaskQueue onboarding.queue.name WorkerID 11259@Mojaves-iMac.local@ WorkflowType RetryWorkflow WorkflowID mleow-1 RunID 07917e48-4dcf-447f-8e0c-9c55674051c5 Attempt 1 Error Attempt to generate a command before processing WorkflowTaskStarted event StackTrace coroutine root [panic]:

go.temporal.io/sdk/internal.(*commandsHelper).getNextID(...)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/internal_decision_state_machine.go:824
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GenerateSequence(...)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/internal_event_handlers.go:453
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).ExecuteActivity(0xc00018d560, 0x0, 0x0, 0x1a58fa3, 0x15, 0x0, 0x0, 0xbebc200, 0x0, 0x0, ...)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/internal_event_handlers.go:464 +0x696
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity(0xc000180c30, 0x1b5d9f8, 0xc0004b61e0, 0x1ca2c81, 0xe, 0xc000182950, 0x1, 0x1, 0x0, 0x0)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/workflow.go:491 +0x6bd
go.temporal.io/sdk/internal.ExecuteActivity(0x1b5d9f8, 0xc0004b61e0, 0x1929b60, 0x1a933b0, 0xc000182950, 0x1, 0x1, 0x0, 0x0)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/workflow.go:440 +0x128
go.temporal.io/sdk/workflow.ExecuteActivity(...)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/workflow/workflow.go:113
app/bug-wf-retry.RetryWorkflow(0x1b5d870, 0xc0001b6080, 0xc000410a20, 0x7, 0x0, 0x0)
        /Users/leow/GOMOD/testcase-temporal/bug-wf-retry/workflow.go:42 +0x487
reflect.Value.call(0x19351e0, 0x1a933b8, 0x13, 0x1a4a44d, 0x4, 0xc0004b6150, 0x2, 0x2, 0x2, 0x18, ...)
        /usr/local/Cellar/go/1.16.5/libexec/src/reflect/value.go:476 +0x8e7
reflect.Value.Call(0x19351e0, 0x1a933b8, 0x13, 0xc0004b6150, 0x2, 0x2, 0x1, 0x2, 0xc000180c30)
        /usr/local/Cellar/go/1.16.5/libexec/src/reflect/value.go:337 +0xb9
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0xc000180c30, 0x1b5d870, 0xc0001b6080, 0xc0000c0c80, 0xd, 0xc0001828f0, 0x1, 0x1, 0x0, 0x0, ...)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/workflow.go:398 +0x2cb
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0xc0001b6000, 0x1b5d870, 0xc0001b6080, 0xc000367d10, 0xc0004e5738, 0x1889225, 0x0)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/internal_worker.go:740 +0x35a
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1(0x1b5d9f8, 0xc0004b6120)
        /Users/leow/go/pkg/mod/go.temporal.io/sdk@v1.7.0/internal/internal_workflow.go:494 +0xf5

2021/06/21 23:31:45 WARN  Failed to process workflow task. Namespace default TaskQueue onboarding.queue.name WorkerID 11259@Mojaves-iMac.local@ WorkflowType RetryWorkflow WorkflowID mleow-1 RunID 07917e48-4dcf-447f-8e0c-9c55674051c5 Attempt 1 Error Attempt to generate a command before processing WorkflowTaskStarted event
2021/06/21 23:31:45 INFO  Task processing failed with error Namespace default TaskQueue onboarding.queue.name WorkerID 11259@Mojaves-iMac.local@ WorkerType WorkflowWorker Error operation GetWorkflowExecution encounter not found

==================

## Steps to Reproduce the Problem

  1. Workflow that runs activity with MaxAttempts = 2
  2. Once reach above max, activity fails and cause the workflow itself to fail and restart
  3. When above is happening, query is concurrently running

## Code Snippet

### Query
```
// Loop and query continuously ..
				time.Sleep(time.Second / 2)
				res, qerr := c.QueryWorkflow(ctx,
					fmt.Sprintf("mleow-%d", i), "",
					"CORE/current_state")
				if qerr != nil {
...
					continue
				}
				err := res.Get(&status)
				if err != nil {
					fmt.Println("GET_ERR:", err.Error())
				}
				fmt.Println("STATUS: ", status)
```
======

### Worker
```
...
			// Start workflow
			wid := fmt.Sprintf("mleow-%d", id)
			wfo := client.StartWorkflowOptions{
				ID:                       wid,
				TaskQueue:                onboarding_patient.WorkflowQueue,
				WorkflowExecutionTimeout: 2 * time.Minute,
				WorkflowRunTimeout:       time.Minute,
				WorkflowTaskTimeout:      time.Second,
				RetryPolicy: &temporal.RetryPolicy{
					InitialInterval: time.Second,
					MaximumAttempts: 2,
				},
			}
			wfr, err := c.ExecuteWorkflow(context.Background(), wfo,
				bug_wf_retry.RetryWorkflow,
				wid,
			)
			if err != nil {
				panic(err)
			}
			fmt.Println("WFIF: ", wfr.GetID(), "RID: ", wfr.GetRunID())
...
```
=======

### Workflow + Activity
```
func RetryWorkflow(ctx workflow.Context, wid string) error {
	fmt.Println("WID: ", wid, " CTX_ATTEMPT: ", workflow.GetInfo(ctx).Attempt)
	// Status to keep track; we return as we go along
	status := "Starting RetryWorkflow ..."
	herr := workflow.SetQueryHandler(ctx, "CORE/current_state", func() (string, error) {
		// Once completed/failed goes into replay state
		if workflow.IsReplaying(ctx) {
			fmt.Println("REPLAYING ...")
		}
		return status, nil
	})
	if herr != nil {
		status = "Failed to set QueryHandler!"
		return herr
	}
	// Activities
	ao := workflow.ActivityOptions{
		TaskQueue:           onboarding_patient.WorkflowQueue,
		StartToCloseTimeout: time.Millisecond * 200,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval: time.Second,
			MaximumAttempts: 2,
		},
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	f := workflow.ExecuteActivity(ctx, FailActivities, wid)
	f.Get(ctx, nil)
	status = "After failed activity .."

	return fmt.Errorf("UNKNOWN!")
}

func FailActivities(wid string) error {
	fmt.Println("WID: " + wid + " FAIL :( :(")
	return temporal.NewApplicationError(
		fmt.Sprintf("FAIL %s", wid), "TEMP",
	)
}
```
==============

## Specifications

  - Version: SDK v.1.7.0
  - Platform: Linux, docker-compose


#### Comments (9)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-23 21:51:52.000 UTC</summary>

Are you seeing this error persistently (e.g. workflow is getting blocked) or is it cleared after the retry?

</details>

<details>
<summary><strong>leowmjw</strong> commented on 2021-06-24 10:32:00.000 UTC</summary>

@vitarb The workflow is not blocked and retry happens as expected; but this is just a toy case to reproduce. 

I submitted as per requested  by @samarabbas just to make sure this is not an edge case that might affect production/more complex scenarios.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-14 14:23:05.000 UTC</summary>

I have replicated this. In cases where a query is sent to a not-yet-started workflow (can happen during restart, cron, etc), the task polled has only a history with `WorkflowExecutionStarted` with the query and the SDK expects queries to only be handled after `WorkflowTaskStarted`. I am checking with @mfateev, @yiminc, @wxing1292, and others to determine the possible route to take here.

</details>

<details>
<summary><strong>tminusplus</strong> commented on 2021-12-16 08:04:52.000 UTC</summary>

Have also experienced a similar panic. It was for a cron workflow which spawns parallel activity executions and then waits for all of them to finish. Looks like the workflow is able to retry successfully later. Here is a sample, I removed two service specific frames in this backtrace for privacy:
```
external/io_temporal_go_sdk/internal/internal_workflow.go:499 +0xd2
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1({0x2745f38, 0xc000439bc0})
	external/io_temporal_go_sdk/internal/internal_worker.go:741 +0x292
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0xc0034d6580, {0x2745de8, 0xc0034d6600}, 0x25)
	external/io_temporal_go_sdk/internal/workflow.go:415 +0x166
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0xc00b7ab9f0, {0x2745de8, 0xc0034d6600}, 0xc0045cb7e8)
	external/io_temporal_go_sdk/internal/internal_worker.go:1512 +0x136
go.temporal.io/sdk/internal.executeFunction({0x11802e0, 0xc0003f1ee0}, {0xc001471e08, 0x1, 0xc001420000})
	GOROOT/src/reflect/value.go:339 +0xc5
reflect.Value.Call({0x11802e0, 0xc0003f1ee0, 0x403c6c}, {0xc0045cb800, 0x1, 0x1})
	GOROOT/src/reflect/value.go:543 +0x814
... service backtrace for workflow ...
go.temporal.io/sdk/workflow.ExecuteActivity(...)
	external/io_temporal_go_sdk/internal/workflow.go:455 +0x185
go.temporal.io/sdk/internal.ExecuteActivity({0x2745f38, 0xc000439d70}, {0x11cb080, 0x254c158}, {0xc000474fc0, 0x1, 0x1})
	external/io_temporal_go_sdk/internal/workflow.go:511 +0x782
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity(0xc00b7ab9f0, {0x2745f38, 0xc000439dd0}, {0x29d3360, 0x6}, {0xc000474fc0, 0x1, 0x1})
	external/io_temporal_go_sdk/internal/internal_event_handlers.go:463 +0x545
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).ExecuteActivity(0xc000100e00, {{{0x0, 0x0}, {0xc00004bb00, 0xf}, 0x0, 0x0, 0x1a3185c5000, 0x0, 0x0, ...}, ...}, ...)
	external/io_temporal_go_sdk/internal/internal_event_handlers.go:452
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GenerateSequence(...)
	external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:833
go.temporal.io/sdk/internal.(*commandsHelper).getNextID(...)
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 14:31:31.000 UTC</summary>

Are you regularly querying the workflow and getting "Attempt to generate a command before processing WorkflowTaskStarted event"?

It is currently a bug in the SDK where querying a workflow while it is waiting to start (via retry, cron, etc) is causing a panic. Once https://github.com/temporalio/temporal/issues/2300 is solved, the query should fail from the server side and not reach the worker to cause this panic.

</details>

<details>
<summary><strong>tminusplus</strong> commented on 2021-12-16 20:36:05.000 UTC</summary>

We are not querying the workflow at all. Essentially the workflow is doing the same as https://github.com/temporalio/samples-go/blob/main/branch/workflow.go#L34 where it spawns multiple concurrent activities.

One potential issue that might be causing it, is that we for-loop through the futures twice. This could be improved, but the intention was that we'd potentially spawn hundreds of activities from this workflow, so we wanted to batch them and ensure we only spawn a limited number of activities per a batch. I reworked the example to replicate our workflow:
```
func SampleBranchWorkflow(ctx workflow.Context, totalBranches int) (result []string, err error) {
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

        var futures []workflow.Future
        for batch := 0; batch < 10; batch++ {
	    for i := 1; i <= totalBranches; i++ {
		future := workflow.ExecuteActivity(ctx, SampleActivity, activityInput)
		futures = append(futures, future)
	    }
 
            // Block until this batch finishes processing
            for _, future := range futures {
		err = future.Get(ctx, nil)
		if err != nil {
			return
		}
	    }
        }

	// One last sweep to ensure all scheduled activities are complete
	for _, future := range futures {
            err = future.Get(ctx, nil)
	    if err != nil {
		return
	    }
	}
}
```


</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 20:44:37.000 UTC</summary>

Ah, that may be different (this issue is for queries during retry in particular). Can you open a new issue? Also, you are looping through issues more than twice, e.g. the second batch will loop through the first batch's, etc. Also, based on that code, that last for loop provides no value since you are doing the exact same thing as the last step in the previous loop that is guaranteed to have run 10 times before it got there. Maybe you want to add `futures = futures[:0]` as the first step of your first loop and remove the last loop?

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-03-03 14:11:42.000 UTC</summary>

Update for those reading this issue. The primary issue here (last few comments a different thing) is https://github.com/temporalio/temporal/issues/2300.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-01 13:34:13.000 UTC</summary>

This may be solved with https://github.com/temporalio/temporal/pull/2826. Once released, we will write a test confirming that queries can be issued during workflow retry or cron or pending continue as new.

</details>


---

<a id="374"></a>

### #374: Workflow panic when querying a workflow using a side effect inside a versioned block

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/374 |
| **State** | CLOSED |
| **Author** | MrSaints (Ian L.) |
| **Created** | 2021-02-28 17:14:35.000 UTC (4y 10m ago) |
| **Updated** | 2021-03-11 17:26:18.000 UTC |
| **Closed** | 2021-03-11 17:26:18.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 1 |
| **Priority Score** | 9 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource, vitarb |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 4 |

#### Description

## Expected Behavior

If a workflow executes a `SideEffect` with versioning, and we then query that newly launched workflow, it should return successfully instead of timing out due to a workflow panic.

Based on my reading of https://docs.temporal.io/docs/go-versioning/, this should be an acceptable use-case, e.g. introducing a unique ID for use in an activity which previously did not take any unique ID.

## Actual Behavior

The query fails even though the workflow succeeds. This affects a newly launched workflow.

Server logs:

```
temporal                | {"level":"error","ts":"2021-02-28T17:03:09.620Z","msg":"query directly though matching on non-sticky failed","service":"history","shard-id":1,"address":"172.19.0.3:7234","shard-item":"0xc00014f480","component":"history-engine","wf-namespace":"default","wf-id":"hello_world_workflowID","wf-run-id":"4c44131e-5a12-406f-9998-c4e7a5202546","wf-query-type":"test-query","error":"context canceled","logging-call-at":"historyEngine.go:981","stacktrace":"go.temporal.io/server/common/log/loggerimpl.(*loggerImpl).Error\n\t/temporal/common/log/loggerimpl/logger.go:138\ngo.temporal.io/server/service/history.(*historyEngineImpl).queryDirectlyThroughMatching\n\t/temporal/service/history/historyEngine.go:981\ngo.temporal.io/server/service/history.(*historyEngineImpl).QueryWorkflow\n\t/temporal/service/history/historyEngine.go:830\ngo.temporal.io/server/service/history.(*Handler).QueryWorkflow\n\t/temporal/service/history/handler.go:1165\ngo.temporal.io/server/api/historyservice/v1._HistoryService_QueryWorkflow_Handler.func1\n\t/temporal/api/historyservice/v1/service.pb.go:1401\ngo.temporal.io/server/common/rpc.ServiceErrorInterceptor\n\t/temporal/common/rpc/grpc.go:100\ngo.temporal.io/server/api/historyservice/v1._HistoryService_QueryWorkflow_Handler\n\t/temporal/api/historyservice/v1/service.pb.go:1403\ngoogle.golang.org/grpc.(*Server).processUnaryRPC\n\t/go/pkg/mod/google.golang.org/grpc@v1.34.0/server.go:1210\ngoogle.golang.org/grpc.(*Server).handleStream\n\t/go/pkg/mod/google.golang.org/grpc@v1.34.0/server.go:1533\ngoogle.golang.org/grpc.(*Server).serveStreams.func1.2\n\t/go/pkg/mod/google.golang.org/grpc@v1.34.0/server.go:871"}
```

Worker logs:

```
2021/02/28 16:54:37 INFO  HelloWorld workflow completed. Namespace default TaskQueue hello-world WorkerID 46087@<omitted>@ WorkflowType Workflow WorkflowID hello_world_workflowID RunID bfcecbbe-04c9-4eef-b056-69ad5cf1e575 Attempt 1 result Hello Temporal!
2021/02/28 16:54:37 ERROR Workflow panic Namespace default TaskQueue hello-world WorkerID 46087@<omitted>@ WorkflowType Workflow WorkflowID hello_world_workflowID RunID bfcecbbe-04c9-4eef-b056-69ad5cf1e575 Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 8, activityID: 8 StackTrace process event for hello-world [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_decision_state_machine.go:393
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc000487ec0, 0x13eff00, 0x1, 0x8)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_decision_state_machine.go:878 +0x165
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc0004cf9c0, 0xc0001b0a80, 0x1, 0x0, 0x0)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_event_handlers.go:800 +0x41e
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0004c86c0, 0xc0001cb9b0, 0x1437360, 0xc0003ae8c0, 0xc0004c86c0, 0x0)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_handlers.go:876 +0x73c
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc000458210, 0xc0001cb9b0, 0xc0004d6e40, 0x0, 0x0, 0x0, 0x0)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_handlers.go:727 +0x739
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc00043e340, 0xc0001cb9b0, 0x0, 0x0)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_pollers.go:288 +0x4ae
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc00043e340, 0xce4dc0, 0xc0001cb9b0, 0xf393a0, 0xc000403bc0)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_pollers.go:259 +0x85
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc000480000, 0xce4980, 0xc0001ac710)
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_worker_base.go:343 +0xba
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
    <omitted>/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_worker_base.go:270 +0xff
2021/02/28 16:54:37 WARN  Failed to process workflow task. Namespace default TaskQueue hello-world WorkerID 46087@<omitted>@ WorkflowType Workflow WorkflowID hello_world_workflowID RunID bfcecbbe-04c9-4eef-b056-69ad5cf1e575 Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 8, activityID: 8
2021/02/28 16:54:37 INFO  Task processing failed with error Namespace default TaskQueue hello-world WorkerID 46087@<omitted>@ WorkerType WorkflowWorker Error Workflow executionsRow not found.  WorkflowId: hello-world, RunId: d9acd11a-3fdf-4afd-a79d-e9b78a81d7cb
```

For what it is worth, the workflow succeeds if running the side-effect WITHOUT versioning. And the workflow succeeds if running the version marker WITHOUT the side-effect. But together, they fail.

## Steps to Reproduce the Problem

I've modified the `helloworld` sample to reproduce the problem: https://github.com/MrSaints/samples-go/commit/8bd6f2fd890501337cb381021da10bc94be0e454

You should be able to trigger it with:

- `go run helloworld/worker/main.go`
- `go run helloworld/starter/main.go`

## Specifications

  - Version: 1.5.0 (also affects 1.4.1)
  - Platform: Linux


#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2021-03-09 23:43:35.000 UTC</summary>

@MrSaints Thanks for the really great bug report! I have created a unit test that repros this and I'm fixing it now.

Reactions: ðŸŽ‰ 2

</details>


---

<a id="1330"></a>

### #1330: Add TaskQueue to TracerStartSpanOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1330 |
| **State** | OPEN |
| **Author** | caramelomartins (Hugo Martins) |
| **Created** | 2023-12-20 09:54:24.000 UTC (2 years ago) |
| **Updated** | 2024-01-08 18:28:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hey! I'll stick to template.

**Is your feature request related to a problem? Please describe.**

OpenTelemetry allows specifying "a remote service" to which a connection is made [through a peer service name](https://opentelemetry.io/docs/instrumentation/java/automatic/agent-config/#peer-service-name). This can be helpful to determine interactions between services - namely workers - even if Temporal's architecture is asynchronous.

Currently,  none of the available options in [TracerStartSpanOptions](https://github.com/temporalio/sdk-go/blob/5fdbecc56c8cd3bab8e8e33f7073070b98cefc0c/interceptor/tracing_interceptor.go#L123) allows us to infer if a worker is making a request that will be fulfilled by another worker. This makes it impossible to add peer service information in outbound calls (e.g. `StartActivity` or `StartWorkflow`).

**Describe the solution you'd like**

One potential approach could be to share the `TaskQueue` as a `TracerStartSpanOption`, similar to what is already done with the Name and Operation being executed. This would allow developers to externally infer if a cross-service request is being made based on whether the `TaskQueue` of the outbound request is different than the `TaskQueue` where a worker is executing now.

I'm sure this isn't an appropriate solution for all situations, but that could be left to the developer to decide - depending on the architecture of their services. Just providing the `TaskQueue` there could potentially open space for attempting to infer peer services.

**Describe alternatives you've considered**

I considered using the Name as the peer service but that value changes to often to be able to provide a meaningful signal for cross-service interactions. Nonetheless, I'm very open to other suggestions about how to go about doing this.

I'm happy to open a PR and work on this, but wouldn't want to do that before opening a feature request and discussing it.

Thank you!

#### Comments (8)

<details>
<summary><strong>cretz</strong> commented on 2024-01-03 16:55:48.000 UTC</summary>

It's not just task queue, there are a lot of things people may want as tags or customize the span.

I wonder if there is a way to provide the context to `TracerStartSpanOptions` (that is probably `interface{ Value(any) any }`) so that you can extract anything out of the context. For a workflow context this would be easy enough to get the info, but for a client context, you may be expected to provide something to the context before starting.

Another approach may be to have a special context key for storing tags on the context, and you can have an outer interceptor that sets this task queue that is then read by the span starter.

</details>

<details>
<summary><strong>caramelomartins</strong> commented on 2024-01-04 18:06:54.000 UTC</summary>

@cretz I mentioned `TaskQueue` in attempt to not overload the feature request with a lot of things. Your suggestion is sensible though, I feel users will increasingly want to have more and more data - likely.

Adding more generic approaches, though, could easily complicate matters a bit, no? Adding the `TaskQueue` seems quite simple, if we do add context then there's already a divergence between `context.Context` and `workflow.Context` depending on the span that we are about to start.

I wonder if it makes sense to add the `TaskQueue` as an intermediate step, while discussing more generic approaches keeps happening?



</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-05 14:07:26.000 UTC</summary>

@Quinn-With-Two-Ns do you have an opinion here? Maybe we want `ActivityContext` and `WorkflowContext` fields? Maybe can just provide the `interface{ Value(any) any }` and ask outer interceptors to set what they may want? Or maybe we should just encourage users that need advanced tracer implementations to write their own interceptors instead of using the existing ones? Or maybe task queue is ok for now?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-05 17:42:26.000 UTC</summary>

Hm I don't think just attaching `ActivityContext` and `WorkflowContext` fields is sufficient since you may also want to have additional information on the client trace calls as well. I  guess `interface{ Value(any) any }` cannot be auto set based on what is in the calling correct?

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-05 17:58:45.000 UTC</summary>

> I guess interface{ Value(any) any } cannot be auto set based on what is in the calling correct?

It would be set by our primary tracing interceptor impl. To propagate info, you'd have to pass information through the context via an outer interceptor probably. Another approach maybe is a certain context key that contains span tags that is then extracted at span creation time. Of course this also requires an outer interceptor to take something like the task queue and put it in there.

So two questions: 1) Do we want to support generic span tag customization or just add task queue to span options? and 2) If we do want to support generic span tag customization, how do we do it reasonably?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-05 18:16:03.000 UTC</summary>

I would support generic span tag customization over adding just task queue. I am not sure any approach will really fufill the ask of this issue

>allows us to infer if a worker is making a request that will be fulfilled by another worker

Since task queue or any information added on the interceptor side is not enough to tell if a call will be fulfilled by the callers worker or a remote worker in general

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-05 18:39:24.000 UTC</summary>

I suppose it will be enough if they guarantee it's a different task queue, but for the same task queue you are correct there is no guarantee.

</details>

<details>
<summary><strong>caramelomartins</strong> commented on 2024-01-08 18:28:08.000 UTC</summary>

> I would support generic span tag customization over adding just task queue. I am not sure any approach will really fufill the ask of this issue
> 
> > allows us to infer if a worker is making a request that will be fulfilled by another worker
> 
> Since task queue or any information added on the interceptor side is not enough to tell if a call will be fulfilled by the callers worker or a remote worker in general

> I suppose it will be enough if they guarantee it's a different task queue, but for the same task queue you are correct there is no guarantee.

This is currently the architecture I'm working with, a single queue for each worker, which is why I feel having the queue in there would work out. It might not be a generic solution for all users though, as described, I understand that.

</details>


---

<a id="1137"></a>

### #1137: Support OpenTelemetry Metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1137 |
| **State** | CLOSED |
| **Author** | albertteoh (Albert) |
| **Created** | 2023-06-14 01:30:48.000 UTC (2y 7m ago) |
| **Updated** | 2024-02-02 23:32:11.000 UTC |
| **Closed** | 2023-06-14 13:30:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

We have adopted OpenTelemetry Go SDK as our primary instrumentation library; however, with Temporal requiring Tally, it means we'll have a combination of different metrics libraries which are both pull and push based, which complicates our deployment configuration.

**Describe the solution you'd like**
For Temporal to support OpenTelemetry for its metrics instrumentation.

**Describe alternatives you've considered**

- Implement the [`metrics.Handler`](https://github.com/temporalio/sdk-go/blob/master/internal/common/metrics/handler.go#L34) interface to wrap OpenTelemetry. However, one of the interface methods returns the `Handler` itself, which is in an `internal` package. So, this alternative doesn't seem to be feasible (but correct me if I'm wrong). Moreover, it's not a particularly nice solution.

**Additional context**
I have read that adopting OpenTelemetry was delayed because of its instability ([reference](https://community.temporal.io/t/opentracing-and-opentelemetry-for-temporal/3986/3)). 

It now seems that the API and protocol are now stable ([link](https://opentelemetry.io/docs/specs/status/#metrics)), and many components of the SDK are also stable ([link](https://opentelemetry.io/docs/specs/otel/metrics/sdk/#meterprovider)).


#### Comments (8)

<details>
<summary><strong>cretz</strong> commented on 2023-06-14 12:59:18.000 UTC</summary>

You linked to stability of the spec not stability of the Go SDK. Right now https://opentelemetry.io/docs/instrumentation/go/ shows metrics as beta.

> However, one of the interface methods returns the Handler itself, which is in an internal package. So, this alternative doesn't seem to be feasible (but correct me if I'm wrong). 

The handler and all types it may need are aliased and exported from the `client` package.

> Moreover, it's not a particularly nice solution.

Should be really easy and this type of solution is used by many who have other metrics implementations. Of course we would like to support it once the OTel Go metrics API is stable.

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2023-06-14 13:30:35.000 UTC</summary>

> You linked to stability of the spec not stability of the Go SDK. Right now https://opentelemetry.io/docs/instrumentation/go/ shows metrics as beta.

Ah yes, you're right! ðŸ˜„ It's fair that it's not yet supported in Temporal.

> The handler and all types it may need are aliased and exported from the client package.

Gotcha, I might give this another shot, thanks for the help!

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2024-01-16 02:28:52.000 UTC</summary>

Just thought to mention that metrics are now considered stable in OpenTelemetry.

![Screenshot 2024-01-16 at 1 28 27â€¯pm](https://github.com/temporalio/sdk-go/assets/26584478/b95aa89c-9d8e-428e-9d04-73543169d37e)


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-16 03:34:49.000 UTC</summary>

@albertteoh Otel metrics are now implemented,  because they  are stable https://github.com/temporalio/sdk-go/blob/master/contrib/opentelemetry/handler.go

Expect them to be in the next release soon

Reactions: â¤ï¸ 1

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2024-02-01 20:23:29.000 UTC</summary>

> Expect them to be in the next release soon

Thank you for adding OTEL metrics instrumentation! 
We're quite keen on this feature; when is the next release planned for @Quinn-With-Two-Ns?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-01 20:28:35.000 UTC</summary>

@albertteoh This has been release for a couple weeks now https://github.com/temporalio/sdk-go/releases/tag/contrib%2Fopentelemetry%2Fv0.4.0

Note: the open telemetry contrib package release is not tied with the SDK release

Reactions: â¤ï¸ 1

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2024-02-01 21:34:45.000 UTC</summary>

Ah, thanks so much @Quinn-With-Two-Ns! I didn't realise there was a separate release for the otel contrib package.

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2024-02-02 23:32:10.000 UTC</summary>

Hi @Quinn-With-Two-Ns, I tried upgrading the otel contrib package and it resulted in the following build error:
```
# go.temporal.io/sdk/internal/protocol
../../../../pkg/mod/go.temporal.io/sdk@v1.25.1/internal/protocol/util.go:39:40: cannot use msg.Body (variable of type *anypb.Any) as *types.Any value in argument to types.AnyMessageName
# go.temporal.io/sdk/internal/common/metrics
../../../../pkg/mod/go.temporal.io/sdk@v1.25.1/internal/common/metrics/grpc.go:120:44: cannot use s (variable of type *"github.com/gogo/status".Status) as *"google.golang.org/grpc/internal/status".Status value in argument to serviceerror.FromStatus
```

I think the problem is because, as part of the otel package upgrade, it also upgraded the `api` package from 1.24.0 -> 1.26.1. 
1.26.1 has a breaking change to switch from the deprecated gogo library to google/protobuf.

Since we're still on the latest SDK release v1.25.1, it still uses `github.com/gogo/protobuf/types.AnyMessageName` which now has an incompatible parameter `google.golang.org/protobuf/types/known/anypb.Any`.

Do you know how we can resolve this?

Reactions: ðŸ‘ 8

</details>


---

<a id="1114"></a>

### #1114: Support activity functions with variadic arguments  

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1114 |
| **State** | OPEN |
| **Author** | aryzhov (Alex Ryzhov) |
| **Created** | 2023-05-22 16:49:50.000 UTC (2y 7m ago) |
| **Updated** | 2025-04-21 07:26:30.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 6 |
| **Priority Score** | 8 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

I need to make gRPC function calls from my workflows. All gRPC client functions generated by `protoc` have the variadic  parameter `grpc.CallOption`:

```protobuf
type SomeClient interface {
	SomeMethod(ctx context.Context, in *SomeRequest, opts ...grpc.CallOption) (*SomeResponse, error)
}
```

I am able to register `SomeMethod` as an activity but when I try calling it from a workflow, passing an empty array as the last argument, I get an error:

```
reflect: cannot use []grpc.CallOption as type grpc.CallOption in Call
```

I tried different ways of passing the `opts` parameter (omitting, null, a single instance of `grpc.CallOption`) but neither of these ways have worked. 

The issue is generic and applies to all variadic functions regardless of parameter type. I was able to reproduce the problem by modifying `GreetingSample` and adding a variadic argument to the `GetGreeting` activity.

**Describe the solution you'd like**

I can see two ways of implementing this feature:

1. Pass variadic args as an array to `ExecuteActivity()`. 
2. Pass variadic args as individual parameters to `ExecuteActivity()`. 

Upon examining source code, The first option needs a change to `executeFunction()` function in `internal_worker.go` to unpack the array. The second option requires a change to `decodeArgsToRawValues()`, also in `internal_worker.go`. I am not sure which option is better. 

**Describe alternatives you've considered**

I was able to implement a workaround by creating a utility function:
```golang
func wrapGrpcActivity[P any, R any](f func(ctx context.Context, req *P, opts ...grpc.CallOption) (*R, error)) func(ctx context.Context, req *P, opts []grpc.CallOption) (*R, error) {
	return func(ctx context.Context, req *P, opts []grpc.CallOption) (*R, error) {
		return f(ctx, req, opts...)
	}
}
```

Then I use the function when registering gRPC methods:
```golang
worker.RegisterActivityWithOptions(wrapGrpcActivity(someClient.SomeMethod), activity.RegisterOptions{Name: "SomeMethod"})
```

and I can invoke the activity as follows:

```golang
err := workflow.ExecuteActivity(ctx, "SomeMethod", &some.SomeRequest{}, nil).Get(ctx, &resp)
```

**Additional context**

I would like to add that supporting variadic args would allow developers more easily integrate existing third party APIs as activities into workflows without additional wrapping.





#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2023-05-22 17:55:45.000 UTC</summary>

Variadic arguments are supported I believe if you pass the slice instead of just a single value. I think this a reasonable compromise currently.

Your code will not work anyways. `grpc.CallOption` is not a convertible/serializable value. You should use a wrapper, you cannot expose gRPC client calls directly with their non-serializable arugments as activities.

</details>

<details>
<summary><strong>aryzhov</strong> commented on 2023-05-22 18:42:58.000 UTC</summary>

@cretz Let me answer the two points you made separately. First, as I had indicated, this is a generic issue, not specific to gRPC. I was able to reproduce it with an example GreetingService. If I add a variadic parameter:
```golang
func (a *Activities) GetGreeting(p ...string) (string, error) {
```
and then change `GreetingSample` to pass this parameter:
```golang
err := workflow.ExecuteActivity(ctx, a.GetGreeting, []string{"a", "b"}).Get(ctx, &greetResult)
```
I get an error:
```
reflect: cannot use []string as type string in Call
```
There is a stack trace:
```
reflect.Value.call({0x103142400?, 0x140002a05c0?, 0x12af355e8?}, {0x102f8ba78, 0x4}, {0x140000a1428, 0x1, 0x0?})
        /opt/homebrew/opt/go/libexec/src/reflect/value.go:453 +0x13c0
reflect.Value.Call({0x103142400?, 0x140002a05c0?, 0x14000447778?}, {0x140000a1428?, 0x140000a4310?, 0x9?})
        /opt/homebrew/opt/go/libexec/src/reflect/value.go:370 +0x90
go.temporal.io/sdk/internal.executeFunction({0x103142400, 0x140002a05c0}, {0x140001e8950, 0x1, 0x103275101?})
        /Users/alex/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_worker.go:1796 +0x318
go.temporal.io/sdk/internal.executeFunctionWithContext({0x1032751b8?, 0x140004403c0}, {0x103142400, 0x140002a05c0}, {0x140001e8950, 0x1, 0x1})
        /Users/alex/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_worker.go:1780 +0x160
go.temporal.io/sdk/internal.(*activityEnvironmentInterceptor).ExecuteActivity(0x140000b6a80, {0x103275180?, 0x14000440360?}, 0x140000a1410)
```


</details>

<details>
<summary><strong>aryzhov</strong> commented on 2023-05-22 18:50:16.000 UTC</summary>

@cretz For your second point, I agree that `grpc.CallOption` is not convertible, and I would need a wrapper if I had wanted to use it. However, I don't want to pass any call options, and in many cases these call options aren't being used, in which case convertibility isn't an issue. Other gRPC parameters, as my experiment shows, are convertible just fine without wrapping, as `protoc` generates `json` annotations for each field.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-05-22 18:53:14.000 UTC</summary>

:+1: Yeah we call https://pkg.go.dev/reflect#Value.Call not https://pkg.go.dev/reflect#Value.CallSlice. I assume `workflow.ExecuteActivity(ctx, a.GetGreeting, "a", "b").Get(ctx, &greetResult)` also doesn't work. I think we can support variadic args, but I think for compatibility it may have to be with how `Call` does it (so making what I put there work).

I wouldn't count on non-convertible optional variadic options always being safe. We may have static analyzers or other things in the future that check entire signatures eagerly (e.g. at registration).

</details>

<details>
<summary><strong>aryzhov</strong> commented on 2023-05-22 18:57:29.000 UTC</summary>

Yes, the second form (`err := workflow.ExecuteActivity(ctx, a.GetGreeting, "a", "b").Get(ctx, &greetResult)`) also doesn't work. It fails with a different error:
```
Error unable to decode the activity function input payload with error: payload item 0: unable to decode: json: cannot unmarshal string into Go value of type []string for function name: GetGreeting
```


Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>mashail</strong> commented on 2025-04-21 07:24:56.000 UTC</summary>

I support @aryzhov in his quest. 
Our way is to create a wrapper around the rpcs just to have the method signature without variadic param 

</details>


---

<a id="1021"></a>

### #1021: Expose session state to users

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1021 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-31 13:21:24.000 UTC (2y 11m ago) |
| **Updated** | 2023-02-08 19:00:36.000 UTC |
| **Closed** | 2023-02-08 19:00:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

People need a way to know whether session has failed, specifically if an activity has failed due to being cancelled by session failure.

**Describe the solution you'd like**

Can expose the already-existing session state on session info. We need to make sure that it is set to failed if an activity is failed because of session failure.

#### Comments (8)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-01-31 15:15:10.000 UTC</summary>

How is this different then the error we already have in the SDK `ErrSessionFailed`?

>We need to make sure that it is set to failed if an activity is failed because of session failure.

How do you propose we tell an activity failed because it was the session that failed?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-31 15:48:12.000 UTC</summary>

> How is this different then the error we already have in the SDK ErrSessionFailed?

I believe based on docs that an already-in-progress activity on a session just gets cancelled, you can't tell from the error returned by the activity that it was due to session failure. (I could be wrong about this, did not test)

> How do you propose we tell an activity failed because it was the session that failed?

While there are technically some race conditions, if the activity failed due to cancellation the user can check if the session is failed and _may_ make reasonable a judgement that that may be the reason. It's about the best we can offer I think without changing error approaches.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-01-31 15:58:45.000 UTC</summary>

>While there are technically some race conditions, if the activity failed due to cancellation the user can check if the session is failed and may make reasonable a judgement that that may be the reason. It's about the best we can offer I think without changing error approaches.

I'd need to test but I think depending on worker and activity settings it could be pretty easy to have false positives and false negatives. I agree it is the best we can do so I am fine with this approach.

In your original comment you suggested we should mark the session failed if an activity is failed because of session failure. That I don't like because I don't think it is possible to reliably do and is a breaking change to the session API as we explicitly call out we don't fail the session on activity failure in the documentation.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-31 16:01:52.000 UTC</summary>

> In your original comment you suggested we should mark the session failed if an activity is failed because of session failure

I am not suggesting changing anything with how sessions are marked. I am just suggesting we expose session state/status. By "we need to make sure" I just mean a test to confirm that the session status is as expected when an in-flight activity cancel/failure is caused by session failure. Sorry for the wording confusion.

</details>

<details>
<summary><strong>armoona</strong> commented on 2023-01-31 17:25:28.000 UTC</summary>

From the user's perspective, it would be simplest if ExecuteActivity().Get() always returned ErrSessionFailed on session failure, whether it happened while an activity is in progress or otherwise.

Thinking out loud, I think the following hack would work now to reliably trigger session restarts in all cases. It uses a dummy activity that does nothing.

```
	err := workflow.ExecuteActivity(ctx, "RealActivity").Get(ctx, nil)
	var canceledErr *temporal.CanceledError
	if err == workflow.ErrSessionFailed {
		// restart session
	} else if errors.As(err, &canceledErr) {
		err = workflow.ExecuteActivity(ctx, "DummyActivity").Get(ctx, nil)
		if err == workflow.ErrSessionFailed {
			// restart session
		}
	}

```


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-01-31 17:34:29.000 UTC</summary>

>From the user's perspective, it would be simplest if ExecuteActivity().Get() always returned ErrSessionFailed on session failure, whether it happened while an activity is in progress or otherwise.

I agree that would be the simplest, I just don't believe it is possible for the SDK to be confident the activity failed 100% of the time because the session did/did not fail. The best we can do is expose the session state and Users can make that judgement on why the activity failed.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-31 19:03:47.000 UTC</summary>

Also, cancellation is a request not a requirement. Activities can respond to cancellations in different ways (including having already been completed when cancellation is requested). There are many reasons an activity can be cancelled (session close, workflow close, etc) and we don't expose cancellation reasons in any cases. And yes, technically an activity could be cancelled for another reason and you can't tell it was session cancel that was the real reason. All you can do is check whether the session context is closed.

And of course we can't just change existing behavior without potentially breaking people that may expect certain types of errors as they exist today.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-08 19:00:36.000 UTC</summary>

This should be exposed in the go sdk v1.21.0 under `SessionInfo.SessionState `

As noted in the PR
```
Note: Sessions have an inherently stale view of the worker they are running on. Session
	state may be stale up the the SessionOptions.HeartbeatTimeout. SessionOptions.HeartbeatTimeout
	should be less than half the activity timeout for the state to be accurate when checking after activity failure.
```

</details>


---

<a id="978"></a>

### #978: Replay results inconsistent between Go versions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/978 |
| **State** | CLOSED |
| **Author** | mattpercy-anz (Matthew Percy) |
| **Created** | 2022-12-07 10:59:38.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-30 06:52:10.000 UTC |
| **Closed** | 2023-01-30 06:52:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Running a workflow replay should succeed if there have been no workflow/activity code changes, but are run on different Go versions

## Actual Behavior
Replays can fail once the Go version changes

## Steps to Reproduce the Problem

This occurs due to the protojson serialisation of the workflow results in the payload struct:
  https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker.go#L1290
The proto equal in the replayer is comparing the byte array of the marshalled workflow result. But due to a "feature" in the protojson encoder, a random space is sometimes prepended before fields when marshalling (see [here](https://github.com/protocolbuffers/protobuf-go/commit/582ab3de426ef0758666e018b422dd20390f7f26), [here](https://github.com/protocolbuffers/protobuf-go/blob/master/internal/encoding/json/encode.go#L239) and [here](https://github.com/protocolbuffers/protobuf-go/blob/master/internal/encoding/json/encode.go#L272)). This is dependant on your Go version (see [here](https://github.com/protocolbuffers/protobuf-go/blob/master/internal/detrand/rand.go#L40)), and only occurs when the protojson output is multiline.

A workaround would be to create a custom data converter in order to ensure we had payloads encoded in a way that was consistent regardless of Go version. However, I raise this issue because this is an obscure problem that isn't made clear to the users of temporal, and we had hoped to use the replay function to help regression test our workflows and ensure backwards compatibility.

My request is that the replay code allow us to perform the final workflow result equality ourselves, that way we could pull the results out and compare the decoded data, rather than proto comparing the two payloads and potentially flagging a "failed" replay, though the results are actually the same.

For testing this, I made a small change to the helloworld sample code (I can provide my changes if need be) to return a proto struct instead of a string, and recorded the results, one replay file from a workflow ran on Go 1.18.9:
```
"result": {
          "payloads": [
            {
              "metadata": {
                "encoding": "anNvbi9wcm90b2J1Zg==",
                "messageType": "VGVzdEhvbGRlcg=="
              },
              "data": "eyJ0ZXN0cyI6W3sidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0sIHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn1dfQ=="
            }
          ]
        },
```
And the other on Go 1.19.4:
```
"result": {
          "payloads": [
            {
              "metadata": {
                "encoding": "anNvbi9wcm90b2J1Zg==",
                "messageType": "VGVzdEhvbGRlcg=="
              },
              "data": "eyJ0ZXN0cyI6W3sidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0seyJ0ZXN0SWQiOiJIZWxsbyBUZW1wb3JhbCEifSx7InRlc3RJZCI6IkhlbGxvIFRlbXBvcmFsISJ9LHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0seyJ0ZXN0SWQiOiJIZWxsbyBUZW1wb3JhbCEifSx7InRlc3RJZCI6IkhlbGxvIFRlbXBvcmFsISJ9LHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn0seyJ0ZXN0SWQiOiJIZWxsbyBUZW1wb3JhbCEifSx7InRlc3RJZCI6IkhlbGxvIFRlbXBvcmFsISJ9LHsidGVzdElkIjoiSGVsbG8gVGVtcG9yYWwhIn1dfQ=="
            }
          ]
        },
```
If you base64 decode the data, you'll see that the only difference is whitespace.

Very happy to provide any extra information for this. Thanks!

## Specifications

  - Version: go.temporal.io/sdk v1.18.1, https://hub.docker.com/r/temporalio/auto-setup 1.17.4
  - Platform: Mac OS 12.6.1


#### Comments (8)

<details>
<summary><strong>cretz</strong> commented on 2022-12-07 13:13:38.000 UTC</summary>

This is interesting! I was not aware that `protojson` was _intentionally_ made non-deterministic. We need to check other places that we do byte-for-byte payload comparison on mismatch (especially once we fix #876). Though I think that's only on workflow complete too when reading `isCommandMatchEvent`.

A custom check on workflow complete may not be robust enough. What I think we should probably do is if the payload encoding is `json/*`, we should JSON unmarshal into `interface{}` and `reflect.DeepEqual` those.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-09 17:40:14.000 UTC</summary>

@cretz I think we should also remove [this](https://github.com/temporalio/sdk-go/blob/66eb848f196bef644809a86903732762524be6e6/internal/internal_event_handlers.go#L802) use of `proto.equal` used while processing events. It shouldn't cause any non determinism as it is used today but someone could easily misuse it in the future. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-09 17:55:51.000 UTC</summary>

Note, that's only for checking against encoded `nil` which by default is encoded as `"null"`, so it's probably safe.

Concur in general, we should never compare `json/*` payloads by bytes again. We should have a helper that does a JSON equality for JSON encoding and byte comparison otherwise.

Note, technically proto binary marshalling is non-deterministic too I believe. But you have to opt-in to using proto binary conversion in our SDKs. But you can't do a structural comparison without the actual types to deserialize to like you can in JSON. So we may just need to add this as a note/caveat.

And really, we need to stop using payload comparison anyways. I don't believe we need to check input/output _data_ (replayer or during replay). And for mutable side effect, it's just for `nil` that we're using proto equality, otherwise we do use their equals checker.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-09 18:16:36.000 UTC</summary>

>And really, we need to stop using payload comparison anyways. I don't believe we need to check input/output data (replayer or during replay). 

Agreed. Other than the one posted and tests we do a lot in [isCommandMatchEvent](https://github.com/temporalio/sdk-go/blob/v1.19.0/internal/internal_task_handlers.go#L1276) they are mostly protected by `strictMode ` always being `false` (and looking back on the git history can't find when it was ever used). We should probably remove this option and any checks controlled by it OR expose it and only enable wen run from the replayer (we'd also need to fix how we compare payloads as well in this case)




</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-09 18:17:20.000 UTC</summary>

Concur on removing the strict option. Not sure why it's there either.

</details>

<details>
<summary><strong>mattpercy-anz</strong> commented on 2022-12-13 22:44:54.000 UTC</summary>

> I don't believe we need to check input/output data (replayer or during replay)

If you were to stop verifying input/output, will that also mean that the replayer won't flag a difference between a workflow returning a valid response vs one returning an error? If so, that will make using the replayer even less desirable.

We need to ensure workflow changes are deterministic, and work correctly when we use workflow versioning. Ideally we would have unit tests to cover version variations, but the test suite doesn't allow setting the workflow version.

Please correct me if i'm misunderstanding, or there's an alternate way to cover this type of workflow testing.

Thanks

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-13 23:49:11.000 UTC</summary>

> If you were to stop verifying input/output, will that also mean that the replayer won't flag a difference between a workflow returning a valid response vs one returning an error?

It's just not verifying the contents of the return. Fail and success are different commands and would mismatch properly.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-01-30 06:52:09.000 UTC</summary>

Resolved as part of https://github.com/temporalio/sdk-go/pull/990

</details>


---

<a id="928"></a>

### #928: Delay in starting a scheduled workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/928 |
| **State** | CLOSED |
| **Author** | muralisrini |
| **Created** | 2022-10-10 21:25:19.000 UTC (3y 3m ago) |
| **Updated** | 2025-02-04 18:27:26.000 UTC |
| **Closed** | 2025-02-04 18:27:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The delay between Scheduled Workflow task and actual start of the workflow should be quite small. It certainly should _not_ be order of a minute.

## Actual Behavior
When running multiple workflows in a loop see some of workflows waiting for a long time in scheduled state (order of a minute) before starting. For example from temporals Web UI:

![image](https://user-images.githubusercontent.com/14361488/194949790-58ac7409-208a-4673-90b8-b26335f38753.png)

That task was scheduled at 17:07:28:35 and ran at 17:08:28:12.

This was seen with a modified [Mutex Sample](https://github.com/temporalio/samples-go/tree/main/mutex). See Steps below for details please.

Few points:

-  As mentioned, this does not happen with all workflows
- We could not recreate with the Java SDK doing the equivalent of the Mutex Sample (in clojure actually)
- We tried to keep close to the sample to avoid introducing extraneous parameters but it is possible some tweaks to the sample are required to run correctly. Having said that, we did try adding more parameters (such as `MaxConcurrentActivityTaskPollers`) to no avail.
- While the recreate uses `temporalite`,  we first saw the problem in `temporal` service deployment.

There is also some discussion on the forum : https://community.temporal.io/t/delay-in-scheduling-a-workflow/5996

## Steps to Reproduce the Problem

Setup 
  1. Pull https://github.com/muralisrini/samples-go/tree/mutex_add_workflows
  2. cd to the `mutex/worker` directory and `go build`
  3. cd to the `mutex/starter` directory and `go build`
  4. run `./temporalite start --namespace default` 
  5. run `worker/worker`  # call this **Worker window**
  
Start

1. run `starter/starter` # call this  **Starter window**

The starter runs the original starter code with 2 workflows -  but in a loop of 8 to make 18 works in total. You should see the "Worker Window" stall for a long time for some workflows. The Web UI should show delays similar to the one in the picture above.


## Specifications

  - Version: v0.17.0
  - Platform: Ubuntu


#### Comments (8)

<details>
<summary><strong>muralisrini</strong> commented on 2022-12-13 16:17:52.000 UTC</summary>

Anyone take a look at this ?

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2022-12-13 22:29:13.000 UTC</summary>

I believe this is due to your starter explicitly waiting on workflow completion which would block on the lock:

https://github.com/muralisrini/samples-go/blob/mutex_add_workflows/mutex/starter/main.go#L52-L60

If you remove this (start executions async and dont wait for result) you should not see the delay you are explaining in this issue

</details>

<details>
<summary><strong>manetumatt</strong> commented on 2022-12-14 19:35:44.000 UTC</summary>

I am seeing this issue as well without the start executions waiting for results at all.   The worker seems to stall/stop receiving tasks under certain conditions outlined here.  I have observed the following:

- as long as a particular taskQueue is kept busy no delay will happen
- when a taskQueue becomes empty and additional workflows are then submitted, the delay will be experienced 
- nothing seems to process for approx. 1m from the time the taskQueue becomes empty
- during delay condition - If worker is stopped and restarted, workflows immediately start processing again
- if multiple workers are servicing a taskQueue, delay will not happen

I have reproduced this with simple changes to the mutex sample:

starter/main.go
[https://github.com/manetumatt/samples-go/blob/debug1/mutex/starter/main.go](url)

I also shortened the critical section delay to 500ms:

mutex_workflow.go
[https://github.com/manetumatt/samples-go/blob/debug1/mutex/mutex_workflow.go#L208](url)

This sample code executes 5 workflows which start processing immediately.  The code then sleeps for 10 seconds and then executes a second set of 5 workflows.  The second set will not start processing for nearly a minute.






</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2022-12-14 21:56:37.000 UTC</summary>

Thanks for update. Can you share the server version you are running against?

</details>

<details>
<summary><strong>manetumatt</strong> commented on 2022-12-14 22:40:02.000 UTC</summary>

Thank you for the quick reply.  First encountered the issues against v1.18.0.  Switched to Temporalite v0.3.0 (server 1.19.0 I think) for local debugging and testing.  Saw the worker stall issue against both backends.

from Temporalite:
`(base) mltmbp:samples mtaylor$ tctl adm cl d
{
  "supportedClients": {
    "temporal-cli": "\u003c2.0.0",
    "temporal-go": "\u003c2.0.0",
    "temporal-java": "\u003c2.0.0",
    "temporal-php": "\u003c2.0.0",
    "temporal-server": "\u003c2.0.0",
    "temporal-typescript": "\u003c2.0.0",
    "temporal-ui": "\u003c3.0.0"
  },
  "serverVersion": "1.19.0",
  "membershipInfo": {
    "currentHost": {
      "identity": "127.0.0.1:7233"`

</details>

<details>
<summary><strong>manetumatt</strong> commented on 2023-04-12 14:15:20.000 UTC</summary>

Still seeing this issue with latest version.  Anyone had a chance to look at this?

</details>

<details>
<summary><strong>dnr</strong> commented on 2023-07-26 06:16:48.000 UTC</summary>

I believe this is fixed by https://github.com/temporalio/temporal/pull/4562, which is included in server 1.21.1 and above. Please try the latest server version and see if you can still reproduce it.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:27:24.000 UTC</summary>

Closing as this was a support issue that appears resolved 

</details>


---

<a id="814"></a>

### #814: workflowcheck not working

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/814 |
| **State** | CLOSED |
| **Author** | gingercat-maki (maki) |
| **Created** | 2022-05-24 12:55:39.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-25 01:06:31.000 UTC |
| **Closed** | 2022-05-25 01:06:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Workflowcheck should find the deadlock here. But it doesn't. 
Non-deterministic is not found either. (I personally think this will not result in a non-deterministic error since historyMatch process does not match things not recorded in the command/event. And I think these sleep or print will not go into the command/event.

```

	// try some bad thing here
	logger.Debug("before sleep")
	// time.Sleep(1 * time.Microsecond)
	time.Sleep(2 * time.Second)
	now := time.Now()
	fmt.Printf("Now: %v\n", now)
	logger.Debug("after sleep")

```


## Actual Behavior

when time is 1*ms, everything goes well. The flow is successfully completed. 
when time is 1s, deadlock happens, and the flow failed.
But workflow checks don't show errors here.


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version: 
  - â”‚   go.temporal.io/api v1.7.1-0.20220223032354-6e6fe738916a // indirect
â”‚   go.temporal.io/sdk v1.14.0 // indirect
  - Platform: macos


#### Comments (8)

<details>
<summary><strong>cretz</strong> commented on 2022-05-24 13:00:56.000 UTC</summary>

Can you give the full code file and the full `workflowcheck` command you are running? We even have tests in `workflowcheck` that confirm things like `time.Sleep` and `fmt.Printf` are both non-deterministic.

</details>

<details>
<summary><strong>gingercat-maki</strong> commented on 2022-05-24 13:07:41.000 UTC</summary>

https://github.com/gingercat-maki/temporal-demo 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-24 14:00:51.000 UTC</summary>

This works for me. You have to make sure that you check the package where you are calling `RegisterWorkflow`. This entrypoint is the only way that the static analyzer knows your function is a workflow and not just some other code (we can't just assume every function signature containing `workflow.Context` as the first parameter is a workflow).

When I run:

    workflowcheck ./app/worker

I get:

```
tmp/workflowcheck-test/temporal-demo/app/worker/main.go:24:2: approval-workflow-demo-go.ExpenseApprovalWorkflow is non-deterministic, reason: calls non-deterministic function time.Sleep
  time.Sleep is non-deterministic, reason: declared non-deterministic
/tmp/workflowcheck-test/temporal-demo/app/worker/main.go:24:2: approval-workflow-demo-go.ExpenseApprovalWorkflow is non-deterministic, reason: calls non-deterministic function time.Now
  time.Now is non-deterministic, reason: declared non-deterministic
/tmp/workflowcheck-test/temporal-demo/app/worker/main.go:24:2: approval-workflow-demo-go.ExpenseApprovalWorkflow is non-deterministic, reason: calls non-deterministic function fmt.Printf
  fmt.Printf is non-deterministic, reason: accesses non-deterministic var os.Stdout
/tmp/workflowcheck-test/temporal-demo/app/worker/main.go:24:2: approval-workflow-demo-go.ExpenseApprovalWorkflow is non-deterministic, reason: calls non-deterministic function github.com/luci/go-render/render.Render
  github.com/luci/go-render/render.Render is non-deterministic, reason: calls non-deterministic function (*github.com/luci/go-render/render.traverseState).render
    (*github.com/luci/go-render/render.traverseState).render is non-deterministic, reason: calls non-deterministic function (reflect.Value).MapIndex
      (reflect.Value).MapIndex is non-deterministic, reason: calls non-deterministic function (reflect.Value).assignTo
        (reflect.Value).assignTo is non-deterministic, reason: calls non-deterministic function reflect.makeMethodValue
          reflect.makeMethodValue is non-deterministic, reason: calls non-deterministic function reflect.funcLayout
            reflect.funcLayout is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
              (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
        (reflect.Value).assignTo is non-deterministic, reason: calls non-deterministic function reflect.valueInterface
          reflect.valueInterface is non-deterministic, reason: calls non-deterministic function reflect.makeMethodValue
            reflect.makeMethodValue is non-deterministic, reason: calls non-deterministic function reflect.funcLayout
    (*github.com/luci/go-render/render.traverseState).render is non-deterministic, reason: calls non-deterministic function github.com/luci/go-render/render.writeType
      github.com/luci/go-render/render.writeType is non-deterministic, reason: calls non-deterministic function reflect.SliceOf
        reflect.SliceOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
          (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
        reflect.SliceOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
          (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
      github.com/luci/go-render/render.writeType is non-deterministic, reason: calls non-deterministic function reflect.MapOf
        reflect.MapOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
          (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
        reflect.MapOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
          (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
        reflect.MapOf is non-deterministic, reason: calls non-deterministic function reflect.bucketOf
          reflect.bucketOf is non-deterministic, reason: calls non-deterministic function reflect.PointerTo
            reflect.PointerTo is non-deterministic, reason: calls non-deterministic function (*reflect.rtype).ptrTo
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
/tmp/workflowcheck-test/temporal-demo/app/worker/main.go:24:2: approval-workflow-demo-go.ExpenseApprovalWorkflow is non-deterministic, reason: calls non-deterministic function go.temporal.io/sdk/workflow.AwaitWithTimeout
  go.temporal.io/sdk/workflow.AwaitWithTimeout is non-deterministic, reason: calls non-deterministic function go.temporal.io/sdk/internal.AwaitWithTimeout
    go.temporal.io/sdk/internal.AwaitWithTimeout is non-deterministic, reason: calls non-deterministic function (*go.temporal.io/sdk/internal.coroutineState).yield
      (*go.temporal.io/sdk/internal.coroutineState).yield is non-deterministic, reason: sends to channel
      (*go.temporal.io/sdk/internal.coroutineState).yield is non-deterministic, reason: calls non-deterministic function (*go.temporal.io/sdk/internal.coroutineState).initialYield
        (*go.temporal.io/sdk/internal.coroutineState).initialYield is non-deterministic, reason: receives from channel
/tmp/workflowcheck-test/temporal-demo/app/worker/main.go:24:2: approval-workflow-demo-go.ExpenseApprovalWorkflow is non-deterministic, reason: calls non-deterministic function approval-workflow-demo-go.createSubmitSelector
  approval-workflow-demo-go.createSubmitSelector is non-deterministic, reason: calls non-deterministic function github.com/luci/go-render/render.Render
    github.com/luci/go-render/render.Render is non-deterministic, reason: calls non-deterministic function (*github.com/luci/go-render/render.traverseState).render
      (*github.com/luci/go-render/render.traverseState).render is non-deterministic, reason: calls non-deterministic function (reflect.Value).MapIndex
        (reflect.Value).MapIndex is non-deterministic, reason: calls non-deterministic function (reflect.Value).assignTo
          (reflect.Value).assignTo is non-deterministic, reason: calls non-deterministic function reflect.makeMethodValue
            reflect.makeMethodValue is non-deterministic, reason: calls non-deterministic function reflect.funcLayout
              reflect.funcLayout is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                  (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
          (reflect.Value).assignTo is non-deterministic, reason: calls non-deterministic function reflect.valueInterface
            reflect.valueInterface is non-deterministic, reason: calls non-deterministic function reflect.makeMethodValue
              reflect.makeMethodValue is non-deterministic, reason: calls non-deterministic function reflect.funcLayout
      (*github.com/luci/go-render/render.traverseState).render is non-deterministic, reason: calls non-deterministic function github.com/luci/go-render/render.writeType
        github.com/luci/go-render/render.writeType is non-deterministic, reason: calls non-deterministic function reflect.SliceOf
          reflect.SliceOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
            (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
          reflect.SliceOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
            (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
        github.com/luci/go-render/render.writeType is non-deterministic, reason: calls non-deterministic function reflect.MapOf
          reflect.MapOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
            (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
          reflect.MapOf is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
            (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
          reflect.MapOf is non-deterministic, reason: calls non-deterministic function reflect.bucketOf
            reflect.bucketOf is non-deterministic, reason: calls non-deterministic function reflect.PointerTo
              reflect.PointerTo is non-deterministic, reason: calls non-deterministic function (*reflect.rtype).ptrTo
                (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                  (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                  (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
```

</details>

<details>
<summary><strong>gingercat-maki</strong> commented on 2022-05-24 14:49:11.000 UTC</summary>

I see. I just  workflowcheck workflow.go  RegisterWorkflow as the entry point for the check is a good guide for me.

</details>

<details>
<summary><strong>gingercat-maki</strong> commented on 2022-05-24 14:50:21.000 UTC</summary>

Another question here is, the workers and workflows actually run to completion without errors, and why is that?

</details>

<details>
<summary><strong>gingercat-maki</strong> commented on 2022-05-24 14:52:42.000 UTC</summary>

I personally don't think these print or sleep should cause non-deterministic errors. They are actually not in events and not seen by the workflow history.


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-24 14:58:30.000 UTC</summary>

> Another question here is, the workers and workflows actually run to completion without errors, and why is that?

Because there are no errors during run I am guessing. We can't tell you use non-deterministic code at runtime, we can only check deadlocks.

> I personally don't think these print or sleep should cause non-deterministic errors. They are actually not in events and not seen by the workflow history.

Maybe "non-deterministic" may not be the right phrasing, maybe "outside of the Temporal-controlled runtime". But it is very important for Temporal that nothing use Golang goroutines or the Go timing/sleeping system. Workflow code is expected to run until all coroutines are yielded in a couple of milliseconds. This is important to worker scaling and replaying. See https://docs.temporal.io/application-development-guide#workflow-logic-requirements.

</details>

<details>
<summary><strong>gingercat-maki</strong> commented on 2022-05-25 01:06:20.000 UTC</summary>

Yeah, I know. I just read the source code of go-SDK and find the logic of temporal non-deterministic error which seems to be a different logic. But I think "outside of the Temporal-controlled runtime" really causes less confusion and really helpful.

</details>


---

<a id="802"></a>

### #802: Logs are not added to OpenTracing Spans when tracing is enabled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/802 |
| **State** | CLOSED |
| **Author** | pimvanhespen (Pim van Hespen) |
| **Created** | 2022-05-09 09:55:15.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-17 09:09:37.000 UTC |
| **Closed** | 2022-05-17 09:09:36.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 2 |
| **Priority Score** | 8 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 3 |

#### Description

## Expected Behavior
I have enabled tracing via the OpenTracing interceptor.  I would expect logs within a tracing scope to be logged to their respective spans. 

## Actual Behavior
The logs are not propagated to the Spans. 

Within the `tracingWorkflowOutboundInterceptor` (vendor/go.temporal.io/sdk/interceptor/tracing_interceptor.go:490) a call is made to `BaseTracer.GetLogger(log.logger, TracerSpanRef)`. The TracerSpanRef is ignored and the tracing information is lost.

## Steps to Reproduce the Problem

  1. Create an empty workflow
  1. Retrieve the logger via `workflow.GetLogger(ctx)`
  1. Log a line of information
  2. check the output (in this case via the docker image jaeger-all-in-one:latest)
  3. Inspect a trace
  4. Inspect the workflow Span
  5. Check the logs related to the Span
<img width="1728" alt="image" src="https://user-images.githubusercontent.com/6585005/167386243-d84bc2cc-b2a4-4c8e-acc9-8140adfbe8d5.png">


## Specifications

  - Version: 
    - go.temporal.io/sdk v1.14.0
    - go.temporal.io/sdk/contrib/opentelemetry v0.1.0
    - go.opentelemetry.io/otel v1.6.1
    - go.opentelemetry.io/otel/exporters/jaeger v1.6.1
    - go.opentelemetry.io/otel/sdk v1.6.1
    
  - Platform:
    - macOS 12.3, Ubuntu 18.04 


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 15:10:03.000 UTC</summary>

The default implementation of `GetLogger` intentionally does not apply logs to the trace. The `GetLogger` method was added by DataDog at #655 since they want to implement their own `interceptor.Tracer` that overrides that and _does_ provide a tracing enabled logger. By default we don't want all user logs to appear in traces. But if this is important for you, you can implement your own tracer, probably wrapping/delegating to the ones that exist, but providing your own `GetLogger` impl that does attach logs to traces.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>pimvanhespen</strong> commented on 2022-05-17 09:09:36.000 UTC</summary>

Hi @cretz, thank you very much for your explanation! 

</details>


---

<a id="236"></a>

### #236: panic: proto: duplicate extension registered

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/236 |
| **State** | CLOSED |
| **Author** | hazcod (Niels Hofmans) |
| **Created** | 2020-08-24 08:00:30.000 UTC (5y 4m ago) |
| **Updated** | 2020-09-01 06:09:32.000 UTC |
| **Closed** | 2020-08-31 20:24:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | potential-bug |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

As reported on https://temporalio.slack.com/archives/CTDTU3J4T/p1597225501187900
Conflict with temporal/api/dependencies/gogo.proto

## Expected Behavior
A run works fine.

## Actual Behavior
Go code (api + worker) fails on startup with following error
```
panic: proto: duplicate extension registered: descriptor.EnumOptions 62001

goroutine 1 [running]:
github.com/gogo/protobuf/proto.RegisterExtension(0x26e8620)
        /go/src/app/vendor/github.com/gogo/protobuf/proto/extensions.go:595 +0x2cb
github.com/gogo/protobuf/gogoproto.init.0()
        /go/src/app/vendor/github.com/gogo/protobuf/gogoproto/gogo.pb.go:709 +0x31
panic: proto: duplicate extension registered: descriptor.EnumOptions 62001
```

## Steps to Reproduce the Problem
go.mod:
```
	go.temporal.io/api v0.28.0
	go.temporal.io/sdk v0.28.2
```

## Specifications

  - Version: 0.28.0
  - Platform: docker


#### Comments (8)

<details>
<summary><strong>hazcod</strong> commented on 2020-08-25 05:19:46.000 UTC</summary>

Same issue with 0.29 for SDK, API and Docker.

</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-08-25 05:29:34.000 UTC</summary>

I see the same RegisterExtension calls in `gogo/protobuf/gogoproto` and `api/dependencies/gogoproto` ?
![image](https://user-images.githubusercontent.com/5222512/91126625-b55cbc00-e6a4-11ea-8a89-6c09a101b915.png)


</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-08-25 05:42:37.000 UTC</summary>

Seems to work if I manually comment out the `RegisterExtension` calls in vendor/github.com/gogo/protobuf/gogoproro

</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-08-28 17:58:38.000 UTC</summary>

Quote from @alexshtin:

you are on latest `go 1.14`, right? Go modules is on by default there. just delete `vendor` dir and run `go mod init` and then `go mod tidy`.

</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-08-29 11:54:42.000 UTC</summary>

@alexshtin i'm actually still stuck with this; I have private go dependencies that cannot be fetched during the Docker build, since that would embed SSH keys in the eventual image. (and docker squash support isn't widespread)
Also, the path of SSH keys on systems differ.

How would I make this work with private go dependencies? I need to prevent a `go build` to check online for dependency updates, which only seems to work with `vendor/`?

</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-08-31 07:49:14.000 UTC</summary>

@alexshtin I am now doing it the recommended GOPATH/pkg/mod way, but I still receive this error, which is weird.
I have no vendor directory on my or the containers filesystem.

Dockerfile:
```docker
COPY go.mod go.sum /go/src/app/
RUN if [ -n "$GITHUB_TOKEN" ]; then git config --global url."https://$GITHUB_TOKEN@github.com".insteadOf "https://github.com"; fi \
    && go mod download

COPY . /go/src/app/
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags '-w -s -extldflags "-static"' \
    -o /go/bin/api ./cmd/api/ \
    && chmod u=rx,g=,o= /go/bin/api
```

And log:
```
api_1         | panic: proto: duplicate extension registered: descriptor.EnumOptions 62001
api_1         | 
api_1         | goroutine 1 [running]:
api_1         | github.com/gogo/protobuf/proto.RegisterExtension(0x277e240)
api_1         |         /go/pkg/mod/github.com/gogo/protobuf@v1.3.1/proto/extensions.go:595 +0x2cb
api_1         | github.com/gogo/protobuf/gogoproto.init.0()
api_1         |         /go/pkg/mod/github.com/gogo/protobuf@v1.3.1/gogoproto/gogo.pb.go:709 +0x31
```

</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-08-31 11:59:53.000 UTC</summary>

Matches for `RegisterExtension` with `EnumOptions`:
```
/go/pkg/mod/github.com/cncf/udpa/go@v0.0.0-20191209042840-269d4d468f6f/udpa/annotations/migrate.pb.go:  ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.1.0/gogoproto/gogo.pb.go:      ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.1.0/gogoproto/gogo.pb.go:      ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.1.0/gogoproto/gogo.pb.go:      ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.1.0/gogoproto/gogo.pb.go:      ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.1.0/gogoproto/gogo.pb.go:      ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/gogo/protobuf@v1.3.1/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/github.com/gogo/protobuf@v1.3.1/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/github.com/gogo/protobuf@v1.3.1/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/github.com/gogo/protobuf@v1.3.1/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/github.com/gogo/protobuf@v1.3.1/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/github.com/lyft/protoc-gen-validate@v0.0.13/gogoproto/gogo.pb.go:   ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/lyft/protoc-gen-validate@v0.0.13/gogoproto/gogo.pb.go:   ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/lyft/protoc-gen-validate@v0.0.13/gogoproto/gogo.pb.go:   ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/lyft/protoc-gen-validate@v0.0.13/gogoproto/gogo.pb.go:   ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/github.com/lyft/protoc-gen-validate@v0.0.13/gogoproto/gogo.pb.go:   ExtendedType:  (*google_protobuf.EnumOptions)(nil),
/go/pkg/mod/go.temporal.io/api@v0.29.0/dependencies/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/go.temporal.io/api@v0.29.0/dependencies/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/go.temporal.io/api@v0.29.0/dependencies/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/go.temporal.io/api@v0.29.0/dependencies/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/go.temporal.io/api@v0.29.0/dependencies/gogoproto/gogo.pb.go:       ExtendedType:  (*descriptor.EnumOptions)(nil),
/go/pkg/mod/google.golang.org/protobuf@v1.25.0/internal/filetype/build.go:                              case "EnumOptions":
```

</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-09-01 06:09:32.000 UTC</summary>

Seems to be fixed with latest master commit hash @alexshtin , thank you.
I'll keep an eye on the next release.

</details>


---

<a id="197"></a>

### #197: Go SDK does not handle two different workflows registered with same function name properly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/197 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2020-07-16 17:42:55.000 UTC (5y 5m ago) |
| **Updated** | 2023-05-24 07:44:24.000 UTC |
| **Closed** | 2023-05-24 07:44:24.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 4 |
| **Priority Score** | 8 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

Scenario: I had two Workflows in separate packages with the same Workflow entry method called "Run()". I called continueasnew with the function pointer to Workflow1's execution method, and the continueasnew operation resulted in Workflow2 kicking off (!) as a part of Workflow1's execution, which confused the heck out of me. 

I fixed this locally by referencing the friendly workflow name I registered with instead of the function pointer, but: 

1) If two separate workflows in different packages cannot have the same function name, we should ideally be crashing the worker on startup.

2) If this is supposed to be supported behavior, then there is a bug here.

Tested locally against latest Temporal and SDK bits as of 7/16/2020 and reproduces quite easily.

![image](https://user-images.githubusercontent.com/5552381/87704513-5cb70c80-c751-11ea-969d-12dd7d5d4bc4.png)

(Note lines 107 and 115 register two different workflows with same entry method name, which causes the issue)

#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2021-12-15 19:13:45.000 UTC</summary>

This is the expected behavior of the registration, though it is possible at the time of this issue it may have been broken or otherwise not implemented right. Today it is accepted that the simple function name is used as the name and you have to use the options to override it with a different name. This code should panic if a name is reused unless `DisableAlreadyRegisteredCheck` is explicitly set to true in the options.

</details>

<details>
<summary><strong>mastermanu</strong> commented on 2021-12-15 19:40:24.000 UTC</summary>

Got it. I was actually registering the workflows with custom names, but then in continue as new, I was referencing the method instead of the custom name, which is why this issue was only caught at run-time vs. panicking on startup.

We may want to document this behavior in the continue-as-new documentation

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-15 20:29:44.000 UTC</summary>

I have also opened #672 to allow disabling of the function name as an alias.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-24 07:44:24.000 UTC</summary>

closing as this looks resolved

</details>


---

<a id="1706"></a>

### #1706: ProcessWorkflowTask is not stopped on worker.Stop()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1706 |
| **State** | CLOSED |
| **Author** | ndtretyak (Nikolay Tretyak) |
| **Created** | 2024-11-08 09:38:53.000 UTC (1y 2m ago) |
| **Updated** | 2025-05-30 20:35:43.000 UTC |
| **Closed** | 2025-05-30 20:35:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘€ 1 |

#### Description

## Expected Behavior
`ProcessWorkflowTask` should stop

## Actual Behavior
A WorkflowTask started by a stopped worker continues to send heartbeats, blocking further workflow execution.

## Steps to Reproduce the Problem

The following code is based on the server's per-namespace worker [implementation](https://github.com/temporalio/temporal/blob/main/service/worker/pernamespaceworker.go). It starts the worker, stops it, and then starts it again using the same client.

The workflow executes a series of local activities, similar to the server's Scheduler workflow.

If the worker is stopped during the execution of a local activity, we will see a "canceled" error in the logs:
```
2024/11/08 10:15:49 ERROR Activity failed
```

However, this error is ignored by the workflow, which will continue processing the current WorkflowTask and will schedule another local activity. This activity will not be executed since the worker is stopped. `ProcessWorkflowTask` will remain active, though, and will keep sending heartbeats until either a network timeout occurs or the history size limit is reached.

Heartbeats can be seen in the logs:
```
2024/11/08 10:16:28 DEBUG Force RespondWorkflowTaskCompleted
```

```go
package main

import (
	"context"
	"fmt"
	"time"

	"go.temporal.io/api/enums/v1"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

const (
	hostPort   = "localhost:7233"
	namespace  = "default"
	taskQueue  = "default"
	workflowID = "test-workflow"

	sleepDuration = 100 * time.Millisecond
	nActivities   = 10
)

type Worker struct {
	parentClient client.Client
	client       client.Client
	worker       worker.Worker
}

func NewWorker(c client.Client) *Worker {
	return &Worker{parentClient: c}
}

func (w *Worker) Start() error {
	c, err := newTemporalClientFromExisting(w.parentClient)
	if err != nil {
		return fmt.Errorf("create client: %w", err)
	}
	tw := newTemporalWorker(c)
	err = tw.Start()
	if err != nil {
		return fmt.Errorf("start worker: %w", err)
	}
	w.client = c
	w.worker = tw
	return nil
}

func (w *Worker) Stop() {
	w.worker.Stop()
	w.client.Close()
}

func newTemporalClient() (client.Client, error) {
	return client.Dial(client.Options{
		HostPort:  hostPort,
		Namespace: namespace,
	})
}

func newTemporalClientFromExisting(c client.Client) (client.Client, error) {
	return client.NewClientFromExisting(c, client.Options{})
}

func newTemporalWorker(c client.Client) worker.Worker {
	w := worker.New(c, taskQueue, worker.Options{})
	w.RegisterWorkflow(Workflow)
	w.RegisterActivity(Activity)
	return w
}

func Workflow(ctx workflow.Context) error {
	for {
		for range nActivities {
			ctx := workflow.WithLocalActivityOptions(ctx, workflow.LocalActivityOptions{
				StartToCloseTimeout: time.Minute,
			})
			err := workflow.ExecuteLocalActivity(ctx, Activity).Get(ctx, nil)
			if err != nil {
				workflow.GetLogger(ctx).Error("Activity failed.", "Error", err)
			}
		}
		workflow.Sleep(ctx, sleepDuration)
		if workflow.GetInfo(ctx).GetContinueAsNewSuggested() {
			return workflow.NewContinueAsNewError(ctx, Workflow)
		}
	}
}

func Activity(ctx context.Context) error {
	time.Sleep(sleepDuration)
	return ctx.Err()
}

func startWorkflow(ctx context.Context, c client.Client) error {
	opts := client.StartWorkflowOptions{
		ID:                    workflowID,
		TaskQueue:             taskQueue,
		WorkflowIDReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING,
	}
	_, err := c.ExecuteWorkflow(ctx, opts, Workflow)
	return err
}

func main() {
	ctx := context.Background()
	c, err := newTemporalClient()
	if err != nil {
		fmt.Printf("Error creating client: %v\n", err)
	}

	err = startWorkflow(ctx, c)
	if err != nil {
		fmt.Printf("Error starting workflow: %v\n", err)
		return
	}
	fmt.Println("Workflow started.")

	w := NewWorker(c)
	for {
		err = w.Start()
		if err != nil {
			fmt.Println("Error starting worker:", err)
			return
		}
		time.Sleep(33 * sleepDuration)
		w.Stop()
	}
}
```

## Specifications

  - Version:
  - Platform:


#### Comments (7)

<details>
<summary><strong>cretz</strong> commented on 2024-11-12 13:56:27.000 UTC</summary>

I am not sure we want workflow heartbeating to stop just because poller stopped. This is used by long-running local activities. Just because poller stopped doesn't mean we want to interrupt existing tasks (which can include local activity retries if the policy wants it). A worker stopping still allows all workflow and activity tasks to complete.

If the local activity worker is already stopped, then yes there may be some other issue concerning not properly waiting for local activity to complete on worker shutdown.

</details>

<details>
<summary><strong>ndtretyak</strong> commented on 2024-11-12 15:03:21.000 UTC</summary>

As I understand, there are at least three ways for the local activity task to "hang forever"

1. If the task is created after `laTunnel` (which uses the same stop channel as the worker) has already closed, then `sendTask` will return false, leaving the local activity task unstarted.

https://github.com/temporalio/sdk-go/blob/9d74a905fc3602dfa9dddf114087c43a1b64e6b8/internal/internal_task_handlers.go#L1366

2. If the task is created before `laTunnel` closes, but after the local activity worker has already stopped, the task is sent to `taskCh`, but no one is listening. Additionally, this `select` might choose to send even if `stopCh` has already closed.

https://github.com/temporalio/sdk-go/blob/9d74a905fc3602dfa9dddf114087c43a1b64e6b8/internal/internal_task_pollers.go#L220-L227

3. If the task is polled by the local activity worker just before `worker.Stop()` is called, it will be dropped.

https://github.com/temporalio/sdk-go/blob/9d74a905fc3602dfa9dddf114087c43a1b64e6b8/internal/internal_task_pollers.go#L606-L609

Since the local activity worker is stopped first, I thought it would be fine to simply stop sending heartbeats.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-11-12 15:20:11.000 UTC</summary>

Hrmm, I suspect we may be prematurely stopping the local activity worker before its tasks are done. Let me confer with team, but I agree if there's no need to continue to do workflow task heartbeating if the local activity is not running.

</details>

<details>
<summary><strong>ndtretyak</strong> commented on 2024-12-17 10:22:26.000 UTC</summary>

@cretz Hi! Any updates on this issue?

I wanted to highlight that it affects server's scheduler because of [this code section](https://github.com/temporalio/temporal/blob/436c3437771cf9832e99fb6f9569d005b69f93e7/service/worker/scheduler/workflow.go#L1241-L1262).

Here, the local activity `StartWorkflow` is executed in a loop, and errors are only logged. If the error is "context canceled" (due to the worker being stopped) and there are still more items in `allStarts`, another local activity will be scheduled, essentially blocking the workflow because there are no local activity pollers available anymore.

 

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-12-17 16:42:38.000 UTC</summary>

Sorry, the primary maintainers of the Go SDK have limited availability this time of year. I will see if I can increase the priority of this issue.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-01-06 15:27:40.000 UTC</summary>

Note, we will be looking into and tackling this hopefully soon. We will update when we have more details.

Reactions: ðŸŽ‰ 3

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-03-28 19:24:25.000 UTC</summary>

Looks like #1875 solved a different issue with graceful shutdown, WorkerStopTimeout, looking into a fix for this heartbeating issue

</details>


---

<a id="1672"></a>

### #1672: AssertNumberOfCalls on an Activity succeeds even if the Activity is not called the asserted number of times.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1672 |
| **State** | CLOSED |
| **Author** | ClairePhi (Claire Philippe) |
| **Created** | 2024-10-15 09:21:50.000 UTC (1y 2m ago) |
| **Updated** | 2025-01-21 18:55:47.000 UTC |
| **Closed** | 2025-01-21 18:55:45.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 5 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

I expect `AssertNumberOfCalls` to succeed only with one given â€œexpectedCallsâ€ value.

In the â€œSteps to reproduceâ€ section below, there are two assertions to assert the number of times the Activity is Called: 0 and 1. I expect that: 
- At least one of the two assertions fails.
- In particular, the first assertion fails.

## Actual Behavior

It is possible for `AssertNumberOfCalls` to succeed with two â€œexpectedCallsâ€ values.

In the â€œSteps to reproduceâ€ section below, the two assertions succeed and the test succeeds.

## Steps to Reproduce the Problem

main.go:

```
package main

import (
   "context"
   "time"

   "go.temporal.io/sdk/workflow"
)

func MyWorkflow(ctx workflow.Context, input string) error {
   return workflow.ExecuteActivity(
      workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
         StartToCloseTimeout: time.Minute,
      }),
      MyActivity,
      input).Get(ctx, nil)

}

func MyActivity(ctx context.Context, input string) (string, error) {
   return input, nil
}

```

main_test.go:

```
import (
	"testing"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.temporal.io/sdk/testsuite"
)

func Test_Workflow(t *testing.T) {
	testSuite := testsuite.WorkflowTestSuite{}
	env := testSuite.NewTestWorkflowEnvironment()

	env.OnActivity(MyActivity, mock.Anything, "input").Return("output", nil)

	env.ExecuteWorkflow(MyWorkflow, "input")

	require.True(t, env.IsWorkflowCompleted())
	require.NoError(t, env.GetWorkflowError())

	env.AssertNumberOfCalls(t, "MyActivity", 0)
	env.AssertNumberOfCalls(t, "MyActivity", 1)
}
```
## Specifications

go.mod

```
module sandbox.com


go 1.22.3


require (
   github.com/stretchr/testify v1.9.0
   go.temporal.io/sdk v1.29.1
)


require (
   github.com/davecgh/go-spew v1.1.1 // indirect
   github.com/facebookgo/clock v0.0.0-20150410010913-600d898af40a // indirect
   github.com/gogo/protobuf v1.3.2 // indirect
   github.com/golang/mock v1.6.0 // indirect
   github.com/google/uuid v1.6.0 // indirect
   github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 // indirect
   github.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0 // indirect
   github.com/nexus-rpc/sdk-go v0.0.10 // indirect
   github.com/pborman/uuid v1.2.1 // indirect
   github.com/pmezard/go-difflib v1.0.0 // indirect
   github.com/robfig/cron v1.2.0 // indirect
   github.com/stretchr/objx v0.5.2 // indirect
   go.temporal.io/api v1.38.0 // indirect
   golang.org/x/exp v0.0.0-20240525044651-4c93da0ed11d // indirect
   golang.org/x/net v0.28.0 // indirect
   golang.org/x/sync v0.8.0 // indirect
   golang.org/x/sys v0.24.0 // indirect
   golang.org/x/text v0.17.0 // indirect
   golang.org/x/time v0.3.0 // indirect
   google.golang.org/genproto/googleapis/api v0.0.0-20240822170219-fc7c04adadcd // indirect
   google.golang.org/genproto/googleapis/rpc v0.0.0-20240822170219-fc7c04adadcd // indirect
   google.golang.org/grpc v1.65.0 // indirect
   google.golang.org/protobuf v1.34.2 // indirect
   gopkg.in/yaml.v3 v3.0.1 // indirect
)
```

## Additional comments

### Impact

I think that testing that an Activity or a Workflow is Called once is a common use case. I also think that it is a common use case that Activities and Workflows are not named the same (see Additional comments section below).

Users of this function might incorrectly see their tests passing when they should not.

### Possible fix

My understanding is that the behavior was introduced by [that PR](https://github.com/temporalio/sdk-go/pull/1371), which makes the assertion check if the number of Activities OR the number of Workflows were called N times. Here as we have 0 workflows named MyActivity, they were never called. Hence the assertion `env.AssertNumberOfCalls(t, "MyActivity", 0)` succeeds.

Here is an idea to fix that. This is only an attempt - Iâ€™m not familiar with the repo: 
- Revert [that PR](https://github.com/temporalio/sdk-go/pull/1371) -> the bug will be fixed. It will assert that nbWorkflows + nbActivities == N
- In order to take into account [that issue](https://github.com/temporalio/sdk-go/issues/887) -> create two methods:
```
func (e *TestWorkflowEnvironment) AssertNumberOfCallsActivity(t mock.TestingT, methodName string, expectedCalls int) bool
func (e *TestWorkflowEnvironment) AssertNumberOfCallsWorkflow(t mock.TestingT, methodName string, expectedCalls int) bool
```

If you agree on the principle, I can open a PR.

#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2024-10-15 13:06:24.000 UTC</summary>

> create two methods:

The linked PR at https://github.com/temporalio/sdk-go/pull/1371 created `AssertActivityNumberOfCalls` and `AssertWorkflowNumberOfCalls`, can you confirm they work for your use case?

</details>

<details>
<summary><strong>ClairePhi</strong> commented on 2024-10-16 08:49:56.000 UTC</summary>

> can you confirm they work for your use case?

Yes I think they would fit well for my second bullet point, thank you.

I still believe that `env.AssertNumberOfCalls` behavior could introduce errors in user tests. According to the method naming, if someone asserts that an Activity was called once, then they would expect the test to fail if the Activity was never called, and it doesn't.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-16 15:30:03.000 UTC</summary>

https://github.com/temporalio/sdk-go/pull/1371 was maybe developed wrong. @Quinn-With-Two-Ns - thoughts?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-16 19:09:10.000 UTC</summary>

`AssertNumberOfCalls ` is inherently ambiguous since it doesn't differentiate between workflow, activity or nexus calls. If you are trying to assert on the number of activity calls you should use `AssertActivityNumberOfCalls` .

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-01-21 18:55:45.000 UTC</summary>

New method were added in https://github.com/temporalio/sdk-go/commit/e2bec163bb792071556cedae4d0590a14fc8ee9d

</details>


---

<a id="1651"></a>

### #1651: Running activities in separate processes 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1651 |
| **State** | CLOSED |
| **Author** | giuliohome (Giulio) |
| **Created** | 2024-09-26 14:09:51.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-27 10:50:30.000 UTC |
| **Closed** | 2024-09-26 17:37:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The Python SDK for Temporal allows running activities in separate processes via ProcessPoolExecutor. 

**This architecture ensures that each activity runs in isolation, including environment variables.**

[Here is the reference sample](https://github.com/temporalio/samples-python/blob/main/hello/hello_activity_multiprocess.py#L48C1-L67C7).


```py
    # Run a worker for the workflow
    async with Worker(
        client,
        task_queue="hello-activity-multiprocess-task-queue",
        workflows=[GreetingWorkflow],
        activities=[compose_greeting],
        # Synchronous activities are not allowed unless we provide some kind of
        # executor. Here we are giving a process pool executor which means the
        # activity will actually run in a separate process. This same executor
        # could be passed to multiple workers if desired.
        activity_executor=ProcessPoolExecutor(5),
        # Since we are using an executor that is not a thread pool executor,
        # Temporal needs some kind of manager to share state such as
        # cancellation info and heartbeat info between the host and the
        # activity. Therefore, we must provide a shared_state_manager here. A
        # helper is provided to create it from a multiprocessing manager.
        shared_state_manager=SharedStateManager.create_from_multiprocessing(
            multiprocessing.Manager()
        ),
    ):
```


Which is the equivalent way to do this in Go SDK?



#### Comments (7)

<details>
<summary><strong>giuliohome</strong> commented on 2024-09-26 14:58:46.000 UTC</summary>

Or maybe - as a **practical workaround** - could we leverage Cross-Language Execution for this as well?

Temporal supports running activities in a different language from the worker, so could we write the activity in Go while keeping the worker in Python, using the Python workerâ€™s `ProcessPoolExecutor` to guarantee process-level isolation for each activity?

Will the Python workerâ€™s architecture ensure process isolation, even for activities written in a different language like Go?

Will each Go activity execution have its own environment, **ensuring the isolation weâ€™re seeking for environment variables**, or what am I missing?


</details>

<details>
<summary><strong>cretz</strong> commented on 2024-09-26 15:18:22.000 UTC</summary>

Activities are any code you want, so you can use `exec.Command` in your Go activity. It is not comparable to Python which has a built-in concept of remote function invocation and serialization (pickling). There is no concept of multiprocess functions/code in Go, so it is up to the user to implement multiprocessing as they see fit.

Setup your Go activities to be multiprocess (or even multisystem with RPC or whatever), and make sure you heartbeat while waiting for their results and can provide cancellation to them.

Feel free to join us on the community Slack or forums for general questions about Go activities.

</details>

<details>
<summary><strong>giuliohome</strong> commented on 2024-09-26 15:29:11.000 UTC</summary>


Isn't the Golang activity already running in a separate process when the worker is written in Python?

Thank you.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-09-26 16:54:51.000 UTC</summary>

Yes, but not one process per activity like Python multiprocessing

</details>

<details>
<summary><strong>giuliohome</strong> commented on 2024-09-26 17:04:50.000 UTC</summary>

Understood. If there is no possibility for an enhancement, we can proceed to close this issue.

Please consider also that, while each language has its own strengths, consistency in SDK behavior should be a goal for better usability across different languages.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-09-26 17:37:48.000 UTC</summary>

:+1: There is no native Go multiprocessing for functions and we do try to be native to the language without adding dependencies. But this is why we give the freedom to users in activities. So they can choose to do which approach they prefer in situations where there is no standard.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>giuliohome</strong> commented on 2024-09-27 10:50:29.000 UTC</summary>

For my reference, I see that in [Python SDK](https://github.com/temporalio/sdk-python/blob/main/temporalio/worker/_activity.py#L705) you use `loop.run_in_executor`. I have translated this concept from Python to Go based on the [example in the asyncio event loop library](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor). This includes handling environment variables and nested JSON data, which are the basic elements we actually need.

As far as I can see, I can use Go's standard `Marshal`/`Unmarshal` from `encoding/json`.

```go
package main

import (
	"fmt"
	"math"
	"crypto/rand"
	"os"
	"os/exec"
	"sync"
	"encoding/json"
)

func blockingIO() ([]byte, error) {
	data := make([]byte, 100)
	_, err := rand.Read(data)  // This fills the data with random bytes
	if err != nil {
		return nil, err
	}
	return data, nil
}

// cpuBound performs a CPU-intensive task
func cpuBound() int {
	sum := 0
	for i := 0; i < int(math.Pow(10, 7)); i++ {
		sum += i * i
	}
	return sum
}

// runCpuBoundInSubprocess runs the cpuBound function in a separate subprocess with isolated environment variables
func runCpuBoundInSubprocess() error {
	// Create a nested map (equivalent to a complex JSON structure)
	data := map[string]interface{}{
		"task": "example",
		"details": map[string]interface{}{
			"user":  "Giulio",
			"items": []string{"item1", "item2", "item3"},
		},
	}

	// Serialize the data to JSON
	jsonData, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("Serialization error: %v", err)
	}

	cmd := exec.Command(os.Args[0], string(jsonData)) // Run the same program and pass the JSON data as an argument
	cmd.Env = append(os.Environ(), "CUSTOM_ENV_VAR=custom_value") // Set custom environment variables

	output, err := cmd.CombinedOutput() // Capture output from the subprocess
	if err != nil {
		return fmt.Errorf("subprocess error: %v, output: %s", err, string(output))
	}
	fmt.Println("Subprocess output:", string(output))
	return nil
}

func main() {
	var wg sync.WaitGroup

	// 1. Run blockingIO in a goroutine (default thread pool equivalent)
	wg.Add(1)
	go func() {
		defer wg.Done()
		result, err := blockingIO()
		if err != nil {
			fmt.Println("Error:", err)
			return
		}
		fmt.Println("Default thread pool:", result)
	}()

	// 2. Run blockingIO in a custom thread pool (simulated using goroutines and sync.WaitGroup)
	wg.Add(1)
	go func() {
		defer wg.Done()
		result, err := blockingIO()
		if err != nil {
			fmt.Println("Error:", err)
			return
		}
		fmt.Println("Custom thread pool:", result)
	}()

	// 3. Run cpuBound in a separate subprocess with isolated environment
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := runCpuBoundInSubprocess()
		if err != nil {
			fmt.Println("Error:", err)
		}
	}()

	// Wait for all goroutines to finish
	wg.Wait()
	// Get the value of the environment variable
	customEnvVar := os.Getenv("CUSTOM_ENV_VAR")

	// Check if the environment variable is set
	if customEnvVar == "" {
		fmt.Println("In Main => CUSTOM_ENV_VAR is not set")
	} else {
		fmt.Println("In Main => CUSTOM_ENV_VAR:", customEnvVar)
	}
}

// cpu function is executed when the subprocess runs the "cpu" argument
func cpu() {
	result := cpuBound()
	fmt.Printf("CPU-bound result: %d\n", result)

	// Get the value of the environment variable
	customEnvVar := os.Getenv("CUSTOM_ENV_VAR")

	// Check if the environment variable is set
	if customEnvVar == "" {
		fmt.Println("In Subprocess => CUSTOM_ENV_VAR is not set")
	} else {
		fmt.Println("In Subprocess => CUSTOM_ENV_VAR:", customEnvVar)
	}

	// Deserialize the JSON passed as an argument
	var receivedData map[string]interface{}
	err := json.Unmarshal([]byte(os.Args[1]), &receivedData)
	if err != nil {
		fmt.Println("Error parsing JSON:", err)
		return
	}

	// Process the data
	fmt.Println("Received data in child process:", receivedData)

	fmt.Println("User: ", receivedData["details"].(map[string]interface{})["user"].(string))

	// Perform some operation and print a result
	fmt.Println("Processing complete")

}

// Entry point - checks if we are in subprocess mode
func init() {
	if len(os.Args) > 1  { //&& os.Args[1] == "cpu" {
		cpu() // Execute CPU-bound task in subprocess
		os.Exit(0) // Ensure the subprocess exits after completing its work
	}
}

```


</details>


---

<a id="1525"></a>

### #1525: Go SDK 1.26.0+ cannot deserialize `go.temporal.io/api` proto messages originally serialized as `gogoproto` messages   

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1525 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-06-20 21:47:57.000 UTC (1y 6m ago) |
| **Updated** | 2024-07-02 16:01:31.000 UTC |
| **Closed** | 2024-07-02 16:01:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Users using our api protos may hit issues upgrading to `1.26.1`  since our proto message will change type from `gogoproto.message` to `proto.Message`. For example, if `ListWorkflowExecutionsResponse`Â  is the response to an activity and it was serialized with `gogoproto`Â  as it was a `gogoproto.message`,  by updating  `go.temporal.io`Â  `ListWorkflowExecutionsResponse` would now be a normal `proto.Message`Â  so it would not use the `gogoproto` deserializer and fail.

#### Comments (7)

<details>
<summary><strong>cretz</strong> commented on 2024-06-21 15:12:12.000 UTC</summary>

:+1: I wonder if there is somewhere we can discourage assuming Temporal models have stable JSON

</details>

<details>
<summary><strong>afallah-sc</strong> commented on 2024-06-21 15:59:01.000 UTC</summary>

It's not about stable JSON, if you query a workflow, this results in non-determinism. This is not regarding replay tests from serialized JSON histories.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-21 16:29:15.000 UTC</summary>

The non determinism is because the payload in history was JSON encoded (specifically `proto/json`) and that encoding changed due to moving off `gogoproto` 

</details>

<details>
<summary><strong>afallah-sc</strong> commented on 2024-06-21 16:40:21.000 UTC</summary>

I understand, my point was more in regards to @cretz and to "discourage assuming Temporal models have stable JSON". 

If an end-user is storing and serializing the state (like in a replay test), I think it absolutely makes sense to make that opaque to the end-user and tell them they cannot depend on stable JSON state...that upgrades might break things...or require changes to your tests.

However, if the actual history itself is serialized as JSON and Temporal uses that itself during queries, replay, etc...it has to either be stable or the team should make it so that changes are backwards and forwards compatible. Breaking this compatibility between different versions for serialized state, that is used internally, not just externally is dangerous.

</details>

<details>
<summary><strong>afallah-sc</strong> commented on 2024-06-21 16:42:38.000 UTC</summary>

I may be particularly sensitive to breaking changes in clients, but we support about 50 different teams...and there will be a drift in client versions over time. While there may be breaking changes between those clients, something as fundamental as the history itself...even if it is not stable...should be backwards compatible. If changing proto serializers without any underlying schema changes breaks clients, then that is an impl detail that leaks to clients that really should not.

</details>

<details>
<summary><strong>afallah-sc</strong> commented on 2024-06-21 16:47:53.000 UTC</summary>

It's one thing to say we added this field in Temporal, it is fundamental to X, Y, Z feature and we consider it a core part of our offering, as a result...we added the following enum, attribute, or field...and as a result, the history will change and not be backwards compatible.

It is another to say, we moved from one proto serializer to another, the enum serialization and casing is different. As a result, it will break. History is a core, central, critical component of Temporal. If it is unstable, it should be backwards compatible unless it is intentional.

I understand this is a likely bug, no one was deliberately breaking anyone. From a end-user standpoint, it shouldn't matter if the internal representations of histories (JSON or otherwise) are stable as long as the impl detail does not leak.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-06-21 18:15:02.000 UTC</summary>

> if the actual history itself is serialized as JSON and Temporal uses that itself during queries, replay, etc

This is why where history is used in JSON form we had to make special code so that it could work with old-form JSON _and_ new-form JSON. So history JSON is compatible in both ways with the history JSON readers because that's the only place we expect stable JSON for Temporal models. We ensure history JSON format stability with the readers. Other use of Temporal models as JSON we did not expect to have to be stable. In fact, their JSON format violated proto specification. `ListWorkflowExecutionsResponse` is unrelated to history.

Having said that, the converter can be altered to use our accept-both-forms proto marshaler. That's probably the easiest solution for those using Temporal API models in their params/returns.

</details>


---

<a id="1375"></a>

### #1375: Data race due to missing lock/unlock

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1375 |
| **State** | CLOSED |
| **Author** | nghiant3223 (Nguyen Trong Nghia) |
| **Created** | 2024-02-02 04:19:53.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-06 04:14:33.000 UTC |
| **Closed** | 2024-02-06 04:14:33.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 3 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

## Expected Behavior
No data race in writing/reading stick cache size.

## Actual Behavior
Data race sometimes happens. This behavior is flaky.

```
==================
WARNING: DATA RACE
Read at 0x0001043c4998 by goroutine 8:
  go.temporal.io/sdk/internal.NewWorkerCache()
      /Users/nghianguyen/go/pkg/mod/go.temporal.io/sdk@v1.20.0/internal/internal_worker_cache.go:86 +0x3d8
  go.temporal.io/sdk/internal.NewAggregatedWorker()
      /Users/nghianguyen/go/pkg/mod/go.temporal.io/sdk@v1.20.0/internal/internal_worker.go:1426 +0x3b0
  go.temporal.io/sdk/internal.NewWorker()
      /Users/nghianguyen/go/pkg/mod/go.temporal.io/sdk@v1.20.0/internal/worker.go:275 +0x80
  go.temporal.io/sdk/worker.New()
      /Users/nghianguyen/go/pkg/mod/go.temporal.io/sdk@v1.20.0/worker/worker.go:245 +0x9c
  github.com/temporal/test.TestTemporal.func2()
      /Users/nghianguyen/Desktop/tsworkspace/temporal/test/temporal_test.go:32 +0x3c
  testing.tRunner()
      /usr/local/go/src/testing/testing.go:1576 +0x188
  testing.(*T).Run.func1()
      /usr/local/go/src/testing/testing.go:1629 +0x40

Previous write at 0x0001043c4998 by goroutine 7:
  go.temporal.io/sdk/internal.SetStickyWorkflowCacheSize()
      /Users/nghianguyen/go/pkg/mod/go.temporal.io/sdk@v1.20.0/internal/internal_worker_cache.go:69 +0x6c
  go.temporal.io/sdk/worker.SetStickyWorkflowCacheSize()
      /Users/nghianguyen/go/pkg/mod/go.temporal.io/sdk@v1.20.0/worker/worker.go:276 +0x40
  github.com/temporal/test.TestTemporal.func1()
      /Users/nghianguyen/Desktop/tsworkspace/temporal/test/temporal_test.go:15 +0x38
  testing.tRunner()
      /usr/local/go/src/testing/testing.go:1576 +0x188
  testing.(*T).Run.func1()
      /usr/local/go/src/testing/testing.go:1629 +0x40

Goroutine 8 (running) created at:
  testing.(*T).Run()
      /usr/local/go/src/testing/testing.go:1629 +0x5e4
  github.com/temporal/test.TestTemporal()
      /Users/nghianguyen/Desktop/tsworkspace/tenporal/test/temporal_test.go:19 +0x58
  testing.tRunner()
      /usr/local/go/src/testing/testing.go:1576 +0x188
  testing.(*T).Run.func1()
      /usr/local/go/src/testing/testing.go:1629 +0x40

Goroutine 7 (running) created at:
  testing.(*T).Run()
      /usr/local/go/src/testing/testing.go:1629 +0x5e4
  github.com/temporal/test.TestTemporal()
      /Users/nghianguyen/Desktop/tsworkspace/temporal/test/temporal_test.go:11 +0x3c
  testing.tRunner()
      /usr/local/go/src/testing/testing.go:1576 +0x188
  testing.(*T).Run.func1()
      /usr/local/go/src/testing/testing.go:1629 +0x40
==================
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
2024/02/02 11:06:23 INFO  No logger configured for temporal client. Created default one.
--- FAIL: TestTemporal (0.00s)
    --- FAIL: TestTemporal/read (0.07s)
        testing.go:1446: race detected during execution of test
    --- FAIL: TestTemporal/write (0.25s)
        testing.go:1446: race detected during execution of test
FAIL
FAIL	github.com/temporal/test	0.840s
FAIL
```

## Steps to Reproduce the Problem

1. Write a test file:
```go
// File: main_test.go

package temporal

import (
	"testing"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

func TestTemporal(t *testing.T) {
	t.Run("write", func(t *testing.T) {
		t.Parallel()

		for i := 0; i < 1_000_000; i++ {
			worker.SetStickyWorkflowCacheSize(100)
		}
	})

	t.Run("read", func(t *testing.T) {
		t.Parallel()

		for i := 0; i < 100; i++ {
			temporalClient, err := client.Dial(client.Options{
				HostPort:  "localhost:7233",
				Namespace: "default",
			},
			)
			if err != nil {
				panic(err)
			}

			worker.New(temporalClient, "default", worker.Options{})
		}
	})
}
```

2. Run the test file with `-race` flag

```
$ go test -race .
```

## Root Cause Analysis

The sticky cache size is set with lock [here](https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker_cache.go#L61-L70), but it is read without lock [here](https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker_cache.go#L82-L87).

## Specifications

  - Version:
    - Go version: v1.20.11
    - Temporal SDK: v1.20.0
  - Platform: darwin/arm64


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2024-02-02 13:27:50.000 UTC</summary>

Thanks, we do need to fix this.

Note, the reason most have not hit this is because `SetStickyWorkflowCacheSize` needs to be called before it ever can be used (so before all workers and replayers). It has no effect if called after first use. If you're in a situation where you are calling `SetStickyWorkflowCacheSize` after it is first accessed, it won't work.

</details>

<details>
<summary><strong>nghiant3223</strong> commented on 2024-02-03 05:52:51.000 UTC</summary>

Yes. Can I make a contribution? @cretz 

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-05 13:38:18.000 UTC</summary>

Yes, thanks! Remember though, do not try to update this cache setting after already creating workers. It won't work. So whatever you're doing to hit this race signifies a bigger problem.

</details>


---

<a id="1355"></a>

### #1355: support generic functions for activites

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1355 |
| **State** | CLOSED |
| **Author** | valentin-krasontovitsch (Valentin Krasontovitsch) |
| **Created** | 2024-01-15 10:02:49.000 UTC (1y 12m ago) |
| **Updated** | 2024-01-17 18:20:11.000 UTC |
| **Closed** | 2024-01-17 18:20:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I'm always frustrated when I want to use a (specific instance of a) generic
function for an activity, and I have to register it using a specific name I
pass in `activity.RegisterOptions` when calling `RegisterActivityWithOptions`.

For when I just use the function name, as in
```
    my_worker = worker.New(my_client, myQueue, worker.Options{})
    my_worker.RegisterActivity(publishEvent[OrderEvent])
    my_worker.RegisterActivity(publishEvent[ArchiveEvent])
```

I get an error on the second invaction:

```
panic: activity type "]" is already registered
```

I've traced the source to the `get_function_name` function in
`internal/internal_worker.go` - the string returned by
`runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()` replaces the concrete
type in the generic function by `...`, resulting e.g. in `publishEvent[...]` -
the subsequent splitting on `.` and picking the last element results in a
function name of `"]"`, which is of course non-sensical.

**Describe the solution you'd like**
Improve the parsing of function names to support generics, so generic functions
can be registered directly.

**Describe alternatives you've considered**
A functioning workaround is, as alluded above, to just use the following:
```
    my_worker.RegisterActivityWithOptions(
      publishEvent[OrderEvent],
      activity.RegisterOptions{Name: "publishOrderEvent"},
    )
    my_worker.RegisterActivityWithOptions(
      publishEvent[ArchiveEvent],
      activity.RegisterOptions{Name: "publishArchiveEvent"},
    )
```
So if you say this is a no-fix, and a note in the docs about this, I'll be
happy, too : )

If that's an option, I am also willing to try and contribute an MR.

#### Comments (7)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-15 17:37:16.000 UTC</summary>

We should definitely do better then registering the activity as "]"

What would be the new proposed way to get the name of a function be? Since the current method `runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()`   lacks the generic parameters in the output no amount of improved parsing of that result would let you register `publishEvent[OrderEvent]`  and `publishEvent[OrderEvent]` since they both output `publishEvent[...]` if I understand the issue.

</details>

<details>
<summary><strong>valentin-krasontovitsch</strong> commented on 2024-01-16 13:28:09.000 UTC</summary>

hey, and thanks for the response : )

yaa you're right on spot - that function is not good enough.
i've never tried to look into behind the scenes of go, i.e. use runtime or reflect package, so this is all very new territory for me.

i tried experimenting around a bit, and i got as far as looking at the type of the function pointer - that contains the types of the input arguments.

i have a [little script for experimenting](https://gist.github.com/valentin-krasontovitsch/dc3786551cd2c85fb64ab845d76f05fb) that i uploaded as a gist. it produces for a function with one concrete and two generic inputs the following output consisting of
- type
- full name
- return values of get function name func

```
type of i: func(int, main.OrderEvent, string)
fullName: main.Echo[...]
] false
```

so this could be used to create a hereustic for making a function name that reflects the concrete types for generic functions.
but i see that the get function name for concrete functions doesn't take into account input types in general, which makes sense, as you cannot have two functions with same name but different input types.

so maybe we just need to fix the get function name function to return what we would expect for a generic function, namely the function name, instead of `]`, and think about how to attack the issue of registering generic functions in general. and for that I have some vague ideas based on heuristics, but not enough experience with generics or typing in general (not a computer science major) to be confident to come up with a working strategy.

what do SDKs for other languages do, in particular languages that perhaps allow overloading? maybe we can find some inspiration there?

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-16 13:36:08.000 UTC</summary>

> what do SDKs for other languages do, in particular languages that perhaps allow overloading?

No SDKs allow generics in functions that they must reflectively call (e.g. workflows and activities) from what I'm aware of. As for overloading, depending on the SDK, actual functions are marked for use so concerns about overloading don't apply (though if you mark two things of the same name as activities, you'll surely get a duplicate-activity error upon registration).

I would strongly suggest making a concrete non-generic function as your activity. If it needs to be a one-liner to a generic form, so be it.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-16 16:50:29.000 UTC</summary>

Yeah as fair as I am aware there isn't a good way for the SDK to create a unique name at runtime for each instance of a generic function.

</details>

<details>
<summary><strong>valentin-krasontovitsch</strong> commented on 2024-01-17 07:40:06.000 UTC</summary>

alright, so i'm gonna close this as won't fix as there is a work-around (or even two! hadn't thought of making a one-liner concrete function that wraps an instance of the generic one)) with reasonably small overhead for developers. thanks for the discussion!

</details>

<details>
<summary><strong>valentin-krasontovitsch</strong> commented on 2024-01-17 14:18:14.000 UTC</summary>

argh i was too fast - how do you feel about adding a note about (one of the) workarounds in the docs?

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-17 18:20:11.000 UTC</summary>

I will bring up to the docs team internally

Reactions: â¤ï¸ 1

</details>


---

<a id="1084"></a>

### #1084: Bug with version go.temporal.io/api v1.19

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1084 |
| **State** | CLOSED |
| **Author** | Tarang (Tarang) |
| **Created** | 2023-04-13 02:45:28.000 UTC (2y 9m ago) |
| **Updated** | 2023-07-18 22:48:01.000 UTC |
| **Closed** | 2023-07-18 22:48:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
A replay runs

## Actual Behavior
A replay immediately exits without running code

## Steps to Reproduce the Problem

  1. Create a workflow
  1. Download replay
  1. Replay with replayer.ReplayWorkflowHistoryFromJSONFile

Used to work with version go.temporal.io/api v1.18.1.

## Specifications

  - Version: Ventura 13.1
  - Platform: Mac


#### Comments (7)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-04-13 05:16:58.000 UTC</summary>

`go.temporal.io/api` is not related to workflow replay. Can you please clarify the steps to reproduce the problem you saw and confirm you are running on the latest sdk-go version `1.22.x`?

</details>

<details>
<summary><strong>Tarang</strong> commented on 2023-04-14 20:33:26.000 UTC</summary>

Hi

I am running `go.temporal.io/sdk v1.21.1`. If I alter my go mod file to use `go.temporal.io/api v1.19` it wont work, if I use `go.temporal.io/api v1.18.1` it works. So it is very clear it's related to that.

Note sdk/v1.22 needs api/1.19.1 I believe so it can't work, but with v21.1 its quite clear. As a result replays don't work on 1.22.x either.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-04-19 16:50:27.000 UTC</summary>

Can you please clarify the steps to reproduce the problem you saw? for example a short reproduction and history that fails to replay in the latest SDK release

</details>

<details>
<summary><strong>Tarang</strong> commented on 2023-04-23 10:32:48.000 UTC</summary>

What is the best way to create a reproduction since it requires a running temporal and the history file

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-04-23 17:18:02.000 UTC</summary>

could you please test replay again with the latest version of the SDK  `go get go.temporal.io/sdk@master` we recently fixed a bug that could be related.

</details>

<details>
<summary><strong>hlthung</strong> commented on 2023-05-05 10:06:12.000 UTC</summary>

Came across this thread, I'd like to apply the fix, but when I do `go get go.temporal.io/sdk@master` or use [v1.22.1](https://github.com/temporalio/sdk-go/releases/tag/v1.22.1), seems like I'm facing a bunch of issues with server/api/persistence:
```
# go.temporal.io/server/api/persistence/v1
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:307:22: undefined: taskqueue.VersionIdNode
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:311:26: undefined: taskqueue.VersionIdNode
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:346:51: undefined: taskqueue.VersionIdNode
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:353:55: undefined: taskqueue.VersionIdNode
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:722:28: invalid operation: this.CurrentDefault != nil (operator != not defined on untyped nil)
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:989:25: invalid operation: m.CurrentDefault != nil (operator != not defined on untyped nil)
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:1149:25: invalid operation: m.CurrentDefault != nil (operator != not defined on untyped nil)
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:1987:27: invalid operation: m.CurrentDefault == nil (operator == not defined on untyped nil)
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:1988:29: undefined: taskqueue.VersionIdNode
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:2023:57: undefined: taskqueue.VersionIdNode
../../../../go/pkg/mod/go.temporal.io/server@v1.20.2/api/persistence/v1/tasks.pb.go:2023:57: too many errors
```
Unable to find a version I can use for go.temporal.io/server as no matter which version I will get the errors. 
v1.19.X, v1.20.X, 1.21.X are fine I believe. May I know how to resolve this? Thank you!

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-18 22:48:01.000 UTC</summary>

Likely related to https://github.com/temporalio/sdk-go/issues/1091

</details>


---

<a id="1043"></a>

### #1043: [question] Is there any way to get the task queue size (backlog)?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1043 |
| **State** | CLOSED |
| **Author** | tarampampam (PÐ°ramtamtÄm) |
| **Created** | 2023-02-16 14:51:01.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-01 04:30:10.000 UTC |
| **Closed** | 2023-03-01 04:30:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hi there and thank you so much for the great service!

My question may be a bit stupid, but anyway - is there any legal way to get the task queue size? I mean: "How many tasks in the task queue named `%name%` are scheduled for processing, but have not been processed yet?".

This is necessary to implement the autoscaling mechanism (more tasks in queue for processing - more workers, and vice versa) on my side. And yes, I know about the "[custom workers metrics](https://github.com/temporalio/samples-go/tree/main/metrics)", but I am looking for a better (read - simpler) way.

I use the latest version of Temporal with PostgreSQL as storage.

#### Comments (7)

<details>
<summary><strong>cretz</strong> commented on 2023-02-16 16:03:35.000 UTC</summary>

You can use `Client.DescribeTaskQueue` which is a low-level call that returns https://pkg.go.dev/go.temporal.io/api/workflowservice/v1#DescribeTaskQueueResponse that contains a status with a backlog count hint, but it may be a fuzzy number. You can do the same via tctl: https://docs.temporal.io/tctl-v1/taskqueue/#describe.

> This is necessary to implement the autoscaling mechanism

I am not sure that is the best way to scale workers. A better way is to check whether the workers have slots of work available to still perform. If they don't, you need more workers usually. See https://docs.temporal.io/application-development/worker-performance.

You can also feel free to come join us on the forums or public Slack to discuss worker tuning.

</details>

<details>
<summary><strong>dnr</strong> commented on 2023-02-16 19:39:04.000 UTC</summary>

Take a look at these docs also: https://docs.temporal.io/server/production-deployment#faqs
In general we recommend scaling workers based on `schedule_to_start_latency`.

</details>

<details>
<summary><strong>tarampampam</strong> commented on 2023-02-17 07:13:33.000 UTC</summary>

```go
// I have tried with `video_transcoding` too with different types of taskqueueType
resp, rErr := temporal.Client().DescribeTaskQueue(ctx, "video-transcoding", enums.TASK_QUEUE_TYPE_ACTIVITY)
if rErr != nil {
	return rErr
}

fmt.Println(resp.TaskQueueStatus)
```

Is always `nil`, but... Why? A tasks queue exists (I have workers on it when I execute `DescribeTaskQueue`).

And about the `schedule_to_start_latency` metric:

```txt
task_schedule_to_start_latency_sum{namespace="default",operation="RecordActivityTaskStarted",service_name="history",task_type="Activity",taskqueue="default"} 4.012997128000003
task_schedule_to_start_latency_count{namespace="default",operation="RecordActivityTaskStarted",service_name="history",task_type="Activity",taskqueue="default"} 314
task_schedule_to_start_latency_sum{namespace="default",operation="RecordActivityTaskStarted",service_name="history",task_type="Activity",taskqueue="video_transcoding"} 421589.4196587619
task_schedule_to_start_latency_count{namespace="default",operation="RecordActivityTaskStarted",service_name="history",task_type="Activity",taskqueue="video_transcoding"} 75
task_schedule_to_start_latency_sum{namespace="default",operation="RecordWorkflowTaskStarted",service_name="history",task_type="Workflow",taskqueue="__sticky__"} 4.952772867000001
task_schedule_to_start_latency_count{namespace="default",operation="RecordWorkflowTaskStarted",service_name="history",task_type="Workflow",taskqueue="__sticky__"} 362
temporal_activity_schedule_to_start_latency_sum{activity_type="temporal_sys_tq_scanner_scvg_activity",client_name="temporal_go",namespace="temporal_system",service_name="worker",task_queue="temporal_sys_tq_scanner_taskqueue_0",worker_type="none",workflow_type="temporal_sys_tq_scanner_workflow"} 0.008792396
temporal_activity_schedule_to_start_latency_count{activity_type="temporal_sys_tq_scanner_scvg_activity",client_name="temporal_go",namespace="temporal_system",service_name="worker",task_queue="temporal_sys_tq_scanner_taskqueue_0",worker_type="none",workflow_type="temporal_sys_tq_scanner_workflow"} 1
```

> Full diff you can find here: https://www.diffchecker.com/YvohbHiY/ (TTL 1 week). On the left side, tasks were scheduled, but workers were not started. On the right side - I ran the workers, and when ~80% of the activities were processed - I captured the metrics again

It looks like static, because when I have ~10 scheduled activities on the `video-transcoding` without workers on it, and when workers are started to process those jobs - nothing was changed :(

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-17 13:18:54.000 UTC</summary>

> Is always nil, but... Why?

I think you'll have to call `Client.WorkflowService().DescribeTaskQueue(` with a full https://pkg.go.dev/go.temporal.io/api/workflowservice/v1#DescribeTaskQueueRequest that has `IncludeTaskQueueStatus` as `true` to get status. I had forgotten about that flag. Usually doing a low-level task queue describe is not used for scaling, there are other methods. See the worker tuning guide I mentioned.

> It looks like static, because when I have ~10 scheduled activities on the video-transcoding without workers on it

If activities don't start the metric won't have value. It is a measurement of the difference between scheduled and start, not scheduled and current time if never started.

</details>

<details>
<summary><strong>tarampampam</strong> commented on 2023-02-17 14:09:13.000 UTC</summary>

@cretz Thanks for your answer! But it still doesn't work for me :( At this moment I have many scheduled activities in the task queue named `video-transcoding`:

![image](https://user-images.githubusercontent.com/7326800/219673769-5dd99cdd-d737-4702-ab6b-d4c658c71e68.png)

![image](https://user-images.githubusercontent.com/7326800/219675015-4b4e2015-f4d5-4566-b8ea-1fe5b3681903.png)

But without running workers for these activities - they should be in the backlog, right? To make a decision to up or downscale the workers (attached to this task queue) I read the server metrics, and as said in the documentation:

> Poll Success Rate = (poll_success + poll_success_sync) / (poll_success + poll_success_sync + poll_timeouts)
>
> Poll Success Rate should be >90% in most cases of systems with a steady load. For high volume and low latency, try to target >95%.

I got: `{PollSuccess:72 PollSuccessSync:50 PollTimeouts:16}; Poll Success Rate: 88.40579710144928`. After a set of experiments, I noticed this value does not depend on the actual workers' count (all tests were made on my laptop).

An attempt to get the backlog size is also failed:

```go
resp, tErr := temporal.Client().WorkflowService().DescribeTaskQueue(ctx, &workflowservice.DescribeTaskQueueRequest{
  Namespace: opt.temporal.namespace,
  TaskQueue: &v14.TaskQueue{
    Name: "video-transcoding",
  },
  TaskQueueType: enums.TASK_QUEUE_TYPE_ACTIVITY,
  IncludeTaskQueueStatus: true,
})

if tErr != nil {
  return tErr
}

log.Info("Task queue", zap.Any("resp", resp))
```

In the logs:

```
Task queue      {"resp": "&DescribeTaskQueueResponse{Pollers:[]*PollerInfo{},TaskQueueStatus:&v14.TaskQueueStatus{BacklogCountHint:0,ReadLevel:700000,AckLevel:700000,RatePerSecond:1000,TaskIdBlock:&TaskIdBlock{StartId:800001,EndId:900000,},},}"}
```

As you can see `BacklogCountHint` is `0` (always). What am I doing wrong? ðŸ˜ž 

</details>

<details>
<summary><strong>tarampampam</strong> commented on 2023-02-24 07:49:35.000 UTC</summary>

Guys?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-24 15:15:10.000 UTC</summary>

> But without running workers for these activities - they should be in the backlog, right?

Yes, but the hint may not reflect that value. I am getting details on that value now, but it is a mostly internal value that you should not use for scaling workers. Please do not use this for scaling and ignore this low-level API task queue status hint for your use case.

> To make a decision to up or downscale the workers (attached to this task queue) I read the server metrics, and as said in the documentation

I think that part of the documentation you were looking at is only for downscaling (i.e. having too many workers). To know whether to scale up, you should use the available slots metric for knowing when to scale up (or change options).

Simply put - you can use server-side poll metrics to see if there are more workers polling than there are tasks to be given. This will let you know you have too many (which is mostly harmless). You can use SDK-side slot metrics to know whether the slots are being all used up. This will let you know you need to scale up (or increase some of the max-concurrent metrics).

If this is unclear in https://docs.temporal.io/application-development/worker-performance, can we improve it in some way?

Also, for more back-and-forth communication like questions, feel free to ask in our forums or Slack.

</details>


---

<a id="986"></a>

### #986: AwaitWithTimeout does not cancel its timer when condition is satisfied

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/986 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-12-22 19:57:28.000 UTC (3 years ago) |
| **Updated** | 2025-01-22 13:23:00.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 5 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now the timer in `AwaitWithTimeout` does not get cancelled when it's no longer needed. This means an erroneous workflow task is created when timer does fire.

**Describe the solution you'd like**

See if we can compatibly start cancelling these timers. @mfateev has suggested we add a SDK version marker to the beginning of all workflows to be able to make these kinds of changes henceforth. Should be discussed.

#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-22 20:17:40.000 UTC</summary>

Is there any consequences to an erroneous workflow task being created? Just me being lazy, but do we have short example that triggers this already? 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-22 20:35:14.000 UTC</summary>

> Is there any consequences to an erroneous workflow task being created?

Yes, lots. An otherwise idle workflow is now woken up to run. It'll be put to the top of LRU cache, replay itself, etc. We should reduce workflow tasks as much as is reasonable.

> Just me being lazy, but do we have short example that triggers this already?

We don't, but it'd be easy to do, just `workflow.AwaitWithTimeout(ctx, 5 * time.Second, func() bool { return true })` then sleep for 10 seconds and confirm via history your now-not-needed timer was fired at 5 seconds.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-01-04 14:05:47.000 UTC</summary>

After discussion, we are going to look into a way to set some kind of SDK version on the first wft completed that works like a version marker which will let us make going-forward-only fixes to things like this.

</details>

<details>
<summary><strong>captchanjack-anzx</strong> commented on 2025-01-22 12:17:08.000 UTC</summary>

Any update on this? With the new UI it's pretty clear timers are still not being cancelled from signals are received

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/6d3c965c-8565-40d0-9b80-41612817ab91" />

my implementation:
```
	exit := false
	for !exit {
		var got SignalPayload[T]
		ok, more := s.receiveChannel.ReceiveWithTimeout(ctx, s.timeout, &got)
		if !ok {
			return ErrSignalReceiverTimeout
		}

		exit = signalCallback(got)
		if exit || !more {
			break
		}
	}

	return nil
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-01-22 13:22:58.000 UTC</summary>

This seems to be a duplicate post that was also made at https://github.com/temporalio/sdk-go/issues/1125#issuecomment-2607097161, answering there.

</details>


---

<a id="983"></a>

### #983: Replaying non deterministic workflows that use local activities can give false negatives

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/983 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2022-12-13 23:06:21.000 UTC (3 years ago) |
| **Updated** | 2023-01-04 21:27:37.000 UTC |
| **Closed** | 2023-01-04 21:27:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Removing/adding a local activity should fail with a nondeterminism error

## Actual Behavior

Workflow succeeds 

## Steps to Reproduce the Problem

If you save a history for the following workflow, add or remove calls to `helloworldActivity`, and replay the replay does not error
```
func LocalActivityWorkflow(ctx workflow.Context, name string) error {
	ao := workflow.LocalActivityOptions{
		ScheduleToCloseTimeout: time.Minute,
	}
	ctx = workflow.WithLocalActivityOptions(ctx, ao)
	var helloworldResult string
         workflow.ExecuteLocalActivity(ctx, helloworldActivity, name).Get(ctx, &helloworldResult)
         workflow.ExecuteLocalActivity(ctx, helloworldActivity, name).Get(ctx, &helloworldResult)
	return workflow.ExecuteLocalActivity(ctx, helloworldActivity, name).Get(ctx, &helloworldResult)
}
```

Note: assuming https://github.com/temporalio/sdk-go/issues/876 is already resolved

This seems to be due to https://github.com/temporalio/sdk-go/blob/38b2b69f18bdc3bcaf1b4e48f940d1c60b5f9253/internal/internal_task_handlers.go#L919 when the workflow returns we skip adding to the replay commands https://github.com/temporalio/sdk-go/blob/38b2b69f18bdc3bcaf1b4e48f940d1c60b5f9253/internal/internal_task_handlers.go#L928

This issue probably effects more commands than just local activities. 

#### Comments (7)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-13 23:57:18.000 UTC</summary>

I tried just removing these breaks and it seems to cause false positives with other commands like `UpsertMemo`

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-13 23:59:26.000 UTC</summary>

Ug, was introduced at the same as the other workflow completed ignoring stuff. Does it seem like too much of a burden to change to `w.isWorkflowCompleted && !w.isInReplayer {` on these and get the matcher working? We can discuss half-impl alternatives that at least solves matching completed workflows if not very well.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-14 00:25:21.000 UTC</summary>

Looking at the error more closely the actual issue is the workflow execution commands are not in the replay history, but are in the real history causing a mismatch. hmm

```
--- FAIL: TestReplayTestSuite (0.00s)
    --- FAIL: TestReplayTestSuite/TestContinueAsNewWorkflow (0.00s)
        /Users/quinnklassen/Documents/Code/sdk-go/test/replaytests/replay_test.go:172: 
            	Error Trace:	/Users/quinnklassen/Documents/Code/sdk-go/test/replaytests/replay_test.go:172
            	Error:      	Received unexpected error:
            	            	nondeterministic workflow: missing replay command for WorkflowExecutionContinuedAsNew: (EventId:5, EventTime:(), EventType:WorkflowExecutionContinuedAsNew, Version:0, TaskId:7343443, WorkerMayIgnore:false, Attributes:&HistoryEvent_WorkflowExecutionContinuedAsNewEventAttributes{WorkflowExecutionContinuedAsNewEventAttributes:&WorkflowExecutionContinuedAsNewEventAttributes{NewExecutionRunId:74f38af0-7c7d-4aae-bc10-6c34ba946693,WorkflowType:&v1.WorkflowType{Name:ContinueAsNewWorkflow,},TaskQueue:&v11.TaskQueue{Name:replay-test,Kind:Normal,},Input:&v1.Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[102 97 108 115 101],},},},WorkflowRunTimeout:0s,WorkflowTaskTimeout:10s,WorkflowTaskCompletedEventId:4,BackoffStartInterval:<nil>,Initiator:Unspecified,Failure:nil,LastCompletionResult:nil,Header:&v1.Header{Fields:map[string]*Payload{},},Memo:nil,SearchAttributes:nil,},})
            	Test:       	TestReplayTestSuite/TestContinueAsNewWorkflow
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-14 00:32:29.000 UTC</summary>

possibly we could add all the the workflow execution commands to `skipDeterministicCheckForEvent` as the execution result mismatch would get caught by the replayer at a higher level, thoughts @cretz ? 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-14 13:36:02.000 UTC</summary>

Not following exactly as the original description was saying "the replay does not error" was the issue but this is showing an error.

Regardless, can you replicate this error in replay today? Even without the replayer (i.e. unfinished workflow on another worker or a zero-cache setup)? What _exactly_ is the problem here? (sorry for not understanding) I want to be _very_ cautious about doing anything but fixing something that may already be broken and even then be very cautious there.

The goal was to get replayer working with no effect to existing workflows, but if existing workflow replay checks are broken giving false mismatches, we should probably fix that. I'd be hesitant to add more mismatch check possibilities to non-replayer workflow checks today.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-14 17:32:49.000 UTC</summary>

The error I posted is the error we get if we remove the breaks in other words making the change you suggested `w.isWorkflowCompleted && !w.isInReplayer {` .

>Regardless, can you replicate this error in replay today? Even without the replayer (i.e. unfinished workflow on another worker or a zero-cache setup)? 

No it requires making the above code changes.

>I want to be very cautious about doing anything but fixing something that may already be broken and even then be very cautious there.

completely agree, the original issue is as I described in this issue. That issue could be solved by removing the `break` statements on workflow complete. Removing those breaks causes the `WorkflowExecution...` events to end up in the his `respondEvents` but not the `replayEvents`

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-14 18:18:36.000 UTC</summary>

Now I definitely admit ignorance wrt respond vs replay, etc. I'm on board w/ any solution that lets most non-determinisms get caught by the replayer for a complete workflow _and_, most importantly, has no impact on non-replayer code today from a user POV. If that means fixing this or ignoring it, your call.

</details>


---

<a id="957"></a>

### #957: ScheduleOptions.ID says optional, but runtime requires it

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/957 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-11-15 14:47:53.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-15 23:24:13.000 UTC |
| **Closed** | 2022-11-15 23:24:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

ScheduleOptions.ID says optional and will default with UUID, but runtime errors with "no schedule ID in options". Need to decide whether docs are wrong or runtime is wrong.

Also, please document that this may not be the actual workflow ID, it may have the timestamp appended.


#### Comments (7)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-11-15 16:10:29.000 UTC</summary>

Typescript requires the ID, I think Go should be the same https://github.com/temporalio/sdk-typescript/blob/main/packages/client/src/schedule-client.ts#L139

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-11-15 16:22:41.000 UTC</summary>

>Also, please document that this may not be the actual workflow ID, it may have the timestamp appended.

The schedule ID is not related to the workflow ID?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-11-15 16:31:36.000 UTC</summary>

> Typescript requires the ID, I think Go should be the same

Works for me, but it means https://github.com/temporalio/sdk-go/blob/v1.18.1/internal/schedule_client.go#L270 is wrong and needs to be updated.

> The schedule ID is not related to the workflow ID?

The schedule ID is related but not the same. I ran into this writing tests just now. From https://github.com/temporalio/api/blob/v1.12.0/temporal/api/schedule/v1/message.proto#L252-L253:

> The workflow id of the started workflow may not match this exactly, it may have a timestamp appended for uniqueness.

When I was trying to look up a scheduled workflow by the ID I put in the scheduled workflow action, it failed because there was a timestamp appended.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-11-15 16:38:09.000 UTC</summary>

yeah I can update the comment. 

>The schedule ID is related but not the same. I ran into this writing tests just now. From https://github.com/temporalio/api/blob/v1.12.0/temporal/api/schedule/v1/message.proto#L252-L253:

that's the ID of the schedule workflow action, not the schedule, but I agree we should clarify it won't be used verbatim. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-11-15 16:45:01.000 UTC</summary>

From the API there is no such thing as a schedule workflow action ID, only a `start_workflow` options for a workflow action. But the comment makes clear that ID may have something appended. We can make the same comment - meaning don't say "it won't be used verbatim", but rather "it may have timestamp appended". My tests at https://github.com/temporalio/sdk-features/pull/158 for instance rely on the prefix to disambiguate across runs.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-11-15 16:57:57.000 UTC</summary>

yeah I agree we should have the same comment ðŸ‘ 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-11-15 23:24:12.000 UTC</summary>

closed in https://github.com/temporalio/sdk-go/pull/959

</details>


---

<a id="937"></a>

### #937: Add ability to keep session open in case of a worker restart.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/937 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-10-21 01:00:29.000 UTC (3y 2m ago) |
| **Updated** | 2024-12-16 20:49:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When a worker that owns a session is restarted, the session fails and returns an error to the workflow that created the session.
This creates a problem. For many use cases, a restart of a worker is not a problem as the shared state is cached on the host disk, and the session should continue as if nothing happened. For these use cases, the session should fail only if the worker is down for a while, which indicates the host failure.

**Describe the solution you'd like**
Support special worker id that is durable across restarts and can be used to re-establish a session.
Introduce a timeout that would support automatic session reestablishing in case of worker restarts. 



#### Comments (7)

<details>
<summary><strong>AhmedMozaly</strong> commented on 2022-10-23 20:36:50.000 UTC</summary>

The current session implementation assumes that the state is temporarily preserved in the worker. Causing the session to fail when the worker restart.

In real-life scenarios, I think the common usage of sessions is just to route workflow activities to the same worker. As the state is mostly persisted on worker disk. So, I would vote for splitting the session concept into two concepts:

* `Session` which keeps the currently implemented behavior
* `DurableSession` Should NOT fail on worker restart. just retry activities on the same worker after restart. (I claim that this is the more common usage for sessions)

These two concepts can also be just an option passed to the session when being created.

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>F1bonacc1</strong> commented on 2023-07-12 12:01:25.000 UTC</summary>

Hi,

As part of my workflow in kubernetes, I need to drain all the nodes one by one.
There is no way to avoid the worker pod being restarted.
Is there any update on this issue?

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-13 14:55:12.000 UTC</summary>

Hi @F1bonacc1 ,

There is no update on this issue. The best way to achieve similar behaviour is to create a task queue per worker. Then you assign consistent task queue across restarts.

We show how to create per task queue workers [here](https://github.com/temporalio/samples-go/tree/main/activities-sticky-queues)

</details>

<details>
<summary><strong>AhmedMozaly</strong> commented on 2023-07-13 17:12:55.000 UTC</summary>

Using `a task queue per worker` won't be the best solution when `retry on another worker if the current one dies`
What we came up with. Is to use mix of both session & task queue per worker:
* Each worker would listen on two task queues `public-queue` & `unique-queue-per-worker` 
* Use a session for the whole workflow
* The first activity in the workflow would choose the right task queue to use for all following activities 
* If the worker dies, the whole workflow would be retried
* When a retries happens, the first activity would choose a task queue for a healthy worker 


</details>

<details>
<summary><strong>mohamedazouz</strong> commented on 2023-11-15 14:02:40.000 UTC</summary>

@AhmedMozaly I think this example of [session-failure](https://github.com/temporalio/samples-go/tree/main/session-failure) by @Quinn-With-Two-Ns, is much much easier and straight forward than having a workaround task queues.

</details>

<details>
<summary><strong>AhmedMozaly</strong> commented on 2023-11-19 08:28:04.000 UTC</summary>

@mohamedazouz [session-failure](https://github.com/temporalio/samples-go/tree/main/session-failure) by @Quinn-With-Two-Ns, is easier for simpler requirements.

We had a scenario with more requirements:
*  if the worker is restarted (for example due to new version release) we need to fail the session but retry **on the same** worker
* if the worker dies, fail the session and retry on any other worker

It would be great to see this scenario has built-in support in Temporal 

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>mohamedazouz</strong> commented on 2023-11-20 09:33:52.000 UTC</summary>

@AhmedMozaly I agree, I think this should come as native functionality when a session failed should be restarted as a whole in new or previous worker based on options

</details>


---

<a id="884"></a>

### #884: [Feature Request] Add ability to support passing sessions from parent to child wf

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/884 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-08-17 23:04:27.000 UTC (3y 4m ago) |
| **Updated** | 2024-12-16 20:49:53.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 3 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

Feature request is to add ability to support passing sessions from parent to child workflow.
The sessions should still be opened and closed by the parent. Asking just for ability to pass them to child while open.

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-08-29 19:52:09.000 UTC</summary>

I just realized you can do this with recreate session. So in the parent workflow you call `token := workflow.GetSessionInfo(sessionCtx).GetRecreateToken()`, then pass that token to the child, which can then call `workflow.RecreateSession` with that token.

@tsurdilo - Do you believe this solves the use case?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2022-08-29 21:21:49.000 UTC</summary>

Recreate session solves a different use case of opening a new session on the same computer. This feature request is to give ability to share session among multiple workflows while it is still open.


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-29 21:22:54.000 UTC</summary>

Ah, true, ok that is not reuse but an actual recreation.

</details>


---

<a id="825"></a>

### #825: attributes.GetNamespace undefined (type *command.ScheduleActivityTaskCommandAttributes has no field or method GetNamespace) (compile)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/825 |
| **State** | CLOSED |
| **Author** | Delicious-Bacon |
| **Created** | 2022-06-05 07:59:13.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-10 07:36:36.000 UTC |
| **Closed** | 2022-06-10 07:36:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Should compile.

## Actual Behavior
Doesn't compile.

## Steps to Reproduce the Problem

  1. Update the go.temporal.io/api to the latest version (v1.8.0)

## Specifications

  - Version: v1.14.0
  - Platform: N/A

## Notes
A mismatch with api and sdk versions?

![image](https://user-images.githubusercontent.com/78080236/172041261-d11ddfcb-4557-4f6c-820c-c82568a321f6.png)



#### Comments (7)

<details>
<summary><strong>cretz</strong> commented on 2022-06-06 12:36:35.000 UTC</summary>

The SDK is building in CI and I have personally confirmed it is building from a fresh clone. Can you give the _exact_ steps to replicate your issue?

</details>

<details>
<summary><strong>TohChunKiat</strong> commented on 2022-06-07 02:58:59.000 UTC</summary>

I'm encountering this issue too. Using 	go.temporal.io/sdk v1.14.0 . I ran go get + go mod vendor and build failed

</details>

<details>
<summary><strong>slaskis</strong> commented on 2022-06-07 10:41:18.000 UTC</summary>

Field number 3 (`Namespace`) is missing: https://github.com/temporalio/api-go/blob/master/command/v1/message.pb.go#L62-L63

I guess it was removed... https://github.com/temporalio/api/commit/507f88f257496a321fc26013d6f2ae0e72375aa4

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-07 12:48:58.000 UTC</summary>

Ah, I think Go defaults to updating to the latest `go.temporal.io/api`. I think you may have to, after go-get'ing the SDK, get the exact `go.temporal.io/api` version as in `go.mod` in that tag.

I am releasing a new Go SDK version today or tomorrow that works properly with 1.8.0 of that library. I will update soon.

Reactions: ðŸš€ 1

</details>

<details>
<summary><strong>Delicious-Bacon</strong> commented on 2022-06-07 16:42:54.000 UTC</summary>

> The SDK is building in CI and I have personally confirmed it is building from a fresh clone. Can you give the _exact_ steps to replicate your issue?

I had `go.temporal.io/api v1.7.1` and `go.temporal.io/sdk v1.14.0`. There was an update for `/api` to `v1.8.0` so I downloaded it. After that, I had an error as shown in the original issue post.

>Ah, I think Go defaults to updating to the latest go.temporal.io/api. I think you may have to, after go-get'ing the SDK, get the exact go.temporal.io/api version as in go.mod in that tag.
>
> I am releasing a new Go SDK version today or tomorrow that works properly with 1.8.0 of that library. I will update soon.

Well, yes, just like I asked in the original post, `A mismatch with api and sdk versions?` ðŸ™ƒ

In any case, you know the dependencies better than me.

Also, thank you for looking into it! â¤ï¸ 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-07 16:59:25.000 UTC</summary>

I have released SDK v1.15.0. Please see upgrading to that version solves your issues.

</details>

<details>
<summary><strong>Delicious-Bacon</strong> commented on 2022-06-10 07:36:24.000 UTC</summary>

> I have released SDK v1.15.0. Please see upgrading to that version solves your issues.

Confirmed, upgrading the api to `v.1.8.0` and sdk to `v.1.15.0` solves the problem.

Thank you @cretz ! ðŸ’¯ 

</details>


---

<a id="586"></a>

### #586: Activity mocking in test framework not able to do exact match of arguments

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/586 |
| **State** | CLOSED |
| **Author** | roselander (Jason Roselander) |
| **Created** | 2021-10-13 20:23:45.000 UTC (4y 2m ago) |
| **Updated** | 2022-04-22 20:56:13.000 UTC |
| **Closed** | 2021-11-01 17:54:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Should be able to specify exact input struct to match when calling `OnActivity`.

## Actual Behavior

Error: `Unexpected Metho
[delete_role.txt](https://github.com/temporalio/
[delete_role_activities.txt](https://github.com/temporalio/sdk-go/files/7341180/delete_role_activities.txt)
sdk-go/files/7341171/delete_role.txt)
d Call`, and actual activity input observed by test environment is missing field which I know is set by the workflow. Output:

```
	mock: Unexpected Method Call
	-----------------------------
	DeleteRole2(*auth0.DeleteRoleActivities,<nil>,auth0.DeleteRoleActivityInput)
			0: &auth0.DeleteRoleActivities{auth0:auth0.Auth0(nil)}
			1: <nil>
			2: auth0.DeleteRoleActivityInput{RoleName:""}
	The closest call I have is:
	DeleteRole2(string,string,auth0.DeleteRoleActivityInput)
			0: "mock.Anything"
			1: "mock.Anything"
			2: auth0.DeleteRoleActivityInput{RoleName:"test-role"}
```
[delete_role_test.txt](https://github.com/temporalio/sdk-go/files/7341185/delete_role_test.txt)

## Steps to Reproduce the Problem

See attached WF, Activity, and Unit Test.


#### Comments (7)

<details>
<summary><strong>roselander</strong> commented on 2021-10-13 20:24:23.000 UTC</summary>

[delete_role_activities.txt](https://github.com/temporalio/sdk-go/files/7341191/delete_role_activities.txt)
[delete_role.txt](https://github.com/temporalio/sdk-go/files/7341192/delete_role.txt)


</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-18 14:52:08.000 UTC</summary>

@roselander - The issue here is you are using a function pointer on the type instead of an instance of the type. Activity function references are expected to be already associated with an instance.

If you changed:

```go
	s.env.OnActivity(
		(*DeleteRoleActivities).DeleteRole2,
		mock.Anything,
		mock.Anything,
		DeleteRoleActivityInput{"test-role"},
	).Return(
		DeleteRoleActivityOutput{},
		nil,
	)
```

to

```go
	s.env.OnActivity(
		new(DeleteRoleActivities).DeleteRole2,
		mock.Anything,
		DeleteRoleActivityInput{"test-role"},
	).Return(
		DeleteRoleActivityOutput{},
		nil,
	)
```

Then it would work. Also, you should change your invocation of `ExecuteActivity` _inside_ the workflow to use an instance of the `DeleteRoleActivities` instead of a reference to the function without an instance of the receiver, but that's not required.

The reason this is allowed to be registered and in general works at runtime is because both `new(DeleteRoleActivities).DeleteRole2` and `(*DeleteRoleActivities).DeleteRole2` resolve to the same activity name of `DeleteRole2`, but to the mocking engine, the former looks like `DeleteRole2(context, param)` and the latter looks like `DeleteRole2(*DeleteRoleActivities, context, param)` which messes up the param deserializer.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-01 17:54:51.000 UTC</summary>

Please feel free to reopen if your issue remains unresolved. Thanks!

</details>

<details>
<summary><strong>laniehei</strong> commented on 2022-04-15 20:44:17.000 UTC</summary>

How do I mock an activity input that involves a pointer? e.g. 

```
type DeleteRoleActivityInput struct {
     Role *string 
}
testRole := "testRole"
s.env.OnActivity(
		new(DeleteRoleActivities).DeleteRole2,
		mock.Anything,
		DeleteRoleActivityInput{Role: &testRole},
	).Return(
		DeleteRoleActivityOutput{},
		nil,
	)
```

It fails when I test the given workflow because 'testRole' is a different spot in memory. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-15 21:19:24.000 UTC</summary>

The mocking library is https://pkg.go.dev/github.com/stretchr/testify/mock so the parameter matching is done via https://pkg.go.dev/github.com/stretchr/testify/mock#Mock.On. I am not an expert on that mocking library, but it seems that except for some special cases, it just does equality check. In Go, equality check on pointers means they must point to the same thing (so that literal `testRole` variable, ref https://go.dev/ref/spec#Comparison_operators).

Usually though, when you mock, you don't need to be so specific on the argument types to do your assertion. Per https://pkg.go.dev/go.temporal.io/sdk/internal#TestWorkflowEnvironment.OnActivity we made a special case where you can provide a callback here, and in there you can assert exact data. If you _really_ wanted to have advanced matching though, you could do something like (untested):

```go
s.env.OnActivity(
  new(DeleteRoleActivities).DeleteRole2,
  mock.Anything,
  mock.MatchedBy(func(in *DeleteRoleActivityInput) bool { return *in.Role == "testRole" }),
)
```

(Also note, in Go pointers to primitives are usually discouraged if just using for knowing `nil` vs value. If the difference between empty string and `nil` is significant it can make sense, but otherwise treating an empty string as unset is clearer.)

</details>

<details>
<summary><strong>roselander</strong> commented on 2022-04-22 20:50:42.000 UTC</summary>

Is there any reason not to throw a descriptive error if someone uses the `(*Activities).Activity` invocation? 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-22 20:56:13.000 UTC</summary>

Kinda. In Go, `(*SomeStruct).Function(string)` and `Function(*SomeStruct, string)` look the same at runtime. Technically I can do some advanced things to confirm whether that first param is a receiver or not maybe, but I think it's technically ok to register `(*SomeStruct).Function(string)` and accept `*SomeStruct` as the first param, so not sure we should explicitly prevent it.

</details>


---

<a id="577"></a>

### #577: Distribute pollers to multiple frontend servers.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/577 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-10-07 16:56:49.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-14 00:59:13.000 UTC |
| **Closed** | 2021-10-13 13:55:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When worker configured to have multiple pollers, all pollers share one connection and will poll from only one frontend server. This does not work well when worker count is the same or smaller than frontend server count.

**Describe the solution you'd like**
There should have an option to be able to specify how many connections you want for one worker so the load is more evenly distributed among frontend servers. 

**Describe alternatives you've considered**
User has to start more workers to have the load more evenly distributed across all frontend servers.



#### Comments (7)

<details>
<summary><strong>cretz</strong> commented on 2021-10-07 18:44:58.000 UTC</summary>

For some context, gRPC provides most of this out of the box. The address provided to the client can be a comma-delimited set of addresses or `dns://someaddr:1234` for `A` record-based discovery (can even use your own resolver, e.g. `dns://myconsulserver.local/someaddr:1234`), see [docs](https://github.com/grpc/grpc/blob/master/doc/naming.md)

That resolves the set of hosts. As for load balancing, default is "pick first" which would only do the first address. gRPC does have a built-in round robin load balancer, but you have to opt-in by setting service config to `{"loadBalancingPolicy":"round_robin"}`.  See [load balancing docs](https://github.com/grpc/grpc/blob/master/doc/load-balancing.md). Otherwise, both resolvers and load balancers are easy to write custom versions of if necessary.

If those ways of providing sets of hosts (comma-delimited or dns discovery) are acceptable and round robin is good enough for these needs, to keep from having to expose too many gRPC internals, I think a load balancer connection config with just round robin support at first would be fine to start. I would have to investigate Java and Node SDKs to see if they already have similar solutions and/or if they'd need to have this feature.

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-10-08 21:32:15.000 UTC</summary>

We will definitely want parity in all SDKs if we do this. Good news is pollers are in core, so for core/node/other future core SDKs we need only do it once.

I like the idea of leaning on this being built in and just exposing a flag to opt in to round-robin if you pass multiple addresses.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-11 17:17:59.000 UTC</summary>

After a bit more research, we already default to round robin in Go, see https://github.com/temporalio/sdk-go/blob/662d4c6ea1519a5ca1401ab3fbf886b555f2a71d/internal/grpc_dialer.go#L59-L60

However, we don't support multiple addresses, only DNS resolution that can provide multiple addresses. So DNS round-robin works already today, and I can add a small resolver to work with multiple addresses.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-11 18:08:35.000 UTC</summary>

> There should have an option to be able to specify how many connections you want for one worker so the load is more evenly distributed among frontend servers.

@yiminc - Can you clarify this statement? Are you saying we should support weights? Or is the ability to provide a set of addresses to round-robin amongst acceptable? (note, DNS-based round-robin is already supported)

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-12 16:20:53.000 UTC</summary>

After further discussion, the use case originally presented by @yiminc only needed to use `dns:///` to solve their problem. However the PR at #582 still has value because one may want to provide multiple addresses explicitly instead of using DNS discovery.

It should be noted this is not the ideal way to scale gRPC. This has client-side HA benefits, but scaling gRPC is best done at the request level on the server side.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-13 13:55:15.000 UTC</summary>

The immediate use case for this issue has been solved using the `dns:///` prefix.

For general-purpose use, instead of supporting an explicit option to provide multiple addresses in #582, we have decided to simple document how users can do it in #585.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2021-10-14 00:59:13.000 UTC</summary>

As discussed with the team today, in the future we might want to support multiple DNS hosts with a fallback based connection strategy as opposed to round-robin.

We will also want to make sure that other SDKs can support multiple addresses in the same way @cretz solved this for go.
@Spikhalskiy will verify this can be done in Java.
As for Core based SDKs, the solution is much more complex due to the mixed language environment and we decided that it's not a high priority for us yet.

We already have issues tracking this in Java and Node.
@wolfy-j FYI for the PHP SDK.

</details>


---

<a id="518"></a>

### #518: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE will replace a running workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/518 |
| **State** | CLOSED |
| **Author** | shiyao-afterpay |
| **Created** | 2021-08-16 09:49:41.000 UTC (4y 4m ago) |
| **Updated** | 2021-10-06 21:07:23.000 UTC |
| **Closed** | 2021-10-06 21:07:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The doc: https://github.com/temporalio/api/blob/4c2f6a281fa3fde8b0a24447de3e0d0f47d230b4/temporal/api/enums/v1/workflow.proto#L37
indicates when we create a workflow where there is already a workflow with the same id running, nothing will happen.

However, the current logic is: The new created workflow will REPLACE the current running workflow with the same id.












#### Comments (7)

<details>
<summary><strong>wxing1292</strong> commented on 2021-08-16 17:28:49.000 UTC</summary>

@shiyao-afterpay 

according to my memory (conversation with you), the workflow ID reuse policy works as expected if running the SDK against a real server, but cannot work well if using the SDK test framework? 

Is above statement correct?

</details>

<details>
<summary><strong>shiyao-afterpay</strong> commented on 2021-08-17 04:08:17.000 UTC</summary>

This is from real server verification.

This only occurs with the latest version.

</details>

<details>
<summary><strong>wxing1292</strong> commented on 2021-08-17 04:28:40.000 UTC</summary>

the code block below are testing the signal with start API, but the workflow ID reuse policy evaluation logic are the same (vs start workflow API)

https://github.com/temporalio/temporal/blob/b3f10a7dfbd07a05fe0dbbc3a457668eb6acf0e0/host/signal_workflow_test.go#L1497-L1532

</details>

<details>
<summary><strong>shiyao-afterpay</strong> commented on 2021-08-17 04:39:41.000 UTC</summary>

Dunno how to label it as SDK issue. @wxing1292 

</details>

<details>
<summary><strong>wxing1292</strong> commented on 2021-08-17 04:58:29.000 UTC</summary>

go SDK ExecuteWorkflow API seems to have a bug, related to workflow ID reuse policy

![image](https://user-images.githubusercontent.com/8762893/129666098-9f25dfb3-82cc-4faa-93fd-9d263e00ebf6.png)
![image (1)](https://user-images.githubusercontent.com/8762893/129666097-e6488c19-d1b7-4cd8-8476-5238d16982cf.png)


</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-06 19:55:46.000 UTC</summary>

Does this issue still exist? My testing is showing that with allow-duplicate (the default), the same workflow ID and run ID are returned from `ExecuteWorkflow` when executing for the same ID while it is still running. Is this not expected behavior?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-06 21:07:11.000 UTC</summary>

Merged test confirming duplicate ID behavior while workflow is running and while it is not. Closing issue, reopen if issue still exists and/or I am misunderstanding it.

</details>


---

<a id="329"></a>

### #329: Potential deadlock detected: workflow goroutine "root" didn't yield for over a second

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/329 |
| **State** | CLOSED |
| **Author** | shaunco (Shaun) |
| **Created** | 2021-01-08 01:04:56.000 UTC (5 years ago) |
| **Updated** | 2023-03-11 11:49:05.000 UTC |
| **Closed** | 2021-01-12 20:34:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
After switching to v1.3.0 of the sdk-go package, we started getting `Potential deadlock detected: workflow goroutine "root" didn't yield for over a second` panics on `ExecuteLocalActivity()` calls. Happens about 9 out of 10 times, but seems to randomly succeed that 10th time. All is good if I switch back to v1.2.0.

```
4:57PM INF Started Worker%!(EXTRA string=Namespace, string=default, string=TaskQueue, string=MY_TASK_QUEUE, string=WorkerID, string=48528@MYMACHINE@)
4:57PM ERR Workflow panic%!(EXTRA string=Namespace, string=default, string=TaskQueue, string=MY_TASK_QUEUE, string=WorkerID, string=48528@MYMACHINE@, string=WorkflowType, string=MyService.Create, string=WorkflowID, string=MyService.Create-workflow-1f309338-a827-4f34-8035-efc22fdd8fa5, string=RunID, string=bb53d3e1-9ba4-447f-825f-4f0eeb3ad2e1, string=Attempt, int32=5, string=Error, *internal.workflowPanicError=Potential deadlock detected: workflow goroutine "root" didn't yield for over a second, string=StackTrace, string=process event for MY_TASK_QUEUE [panic]:
go.temporal.io/sdk/internal.(*coroutineState).call(0xc00059b270)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_workflow.go:874 +0x35e
go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked(0xc00059b220, 0x0, 0x0)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_workflow.go:959 +0x53f
go.temporal.io/sdk/internal.executeDispatcher(0x2044d60, 0xc00059cec0, 0x20490a0, 0xc00059b220)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_workflow.go:566 +0x87
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted(0xc00059ce80)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_workflow.go:539 +0x78
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc000700460, 0xc00055a4c0, 0x26b0100, 0x0, 0x0)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_event_handlers.go:791 +0x60e
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0005ab170, 0xc000453d70, 0x0, 0x0, 0x0, 0x0)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_task_handlers.go:876 +0xcb2
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc000332fd0, 0xc000453d70, 0xc000694330, 0x0, 0x0, 0x0, 0x0)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_task_handlers.go:727 +0x6bf
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc000092750, 0xc000453d70, 0x0, 0x0)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_task_pollers.go:288 +0x36e
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc000092750, 0x1cb6040, 0xc000453d70, 0x0, 0x0)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_task_pollers.go:259 +0x10b
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc0002bc000, 0x1cb6040, 0xc000453d70)
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_worker_base.go:343 +0x1a2
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
	/go/pkg/mod/go.temporal.io/sdk@v1.3.0/internal/internal_worker_base.go:270 +0x3ac)
4:57PM WRN Failed to process workflow task.%!(EXTRA string=Namespace, string=default, string=TaskQueue, string=MY_TASK_QUEUE, string=WorkerID, string=48528@MYMACHINE@, string=WorkflowType, string=MyService.Create, string=WorkflowID, string=MyService.Create-workflow-1f309338-a827-4f34-8035-efc22fdd8fa5, string=RunID, string=bb53d3e1-9ba4-447f-825f-4f0eeb3ad2e1, string=Attempt, int32=5, string=Error, *internal.workflowPanicError=Potential deadlock detected: workflow goroutine "root" didn't yield for over a second)
```

## Actual Behavior
`ExecuteLocalActivity()` should consistently work

## Steps to Reproduce the Problem

1. Execute a workflow that executes a local activity

(will add more details if discovered)

## Specifications

  - Version: SDK 1.3.0, Temporal Server 1.5.1
  - Platform: Ubuntu


#### Comments (7)

<details>
<summary><strong>mfateev</strong> commented on 2021-01-12 03:12:30.000 UTC</summary>

This is thrown when a workflow thread is blocked for over a second. Workflow threads are not allowed to do any RPC and use any Go language synchronization primitives. So it usually indicates the problem in the workflow code. Are you making any RPC calls from the workflow or use any other primitives that are not allowed?

I believe just executing a local activity is not enough to cause this issue.


</details>

<details>
<summary><strong>shaunco</strong> commented on 2021-01-12 18:16:42.000 UTC</summary>

The workflow had no code prior to executing the local activity. A previous execution of the workflow had failed (debugger stopped the process), and the workflow was being re-executed by Temporal.

</details>

<details>
<summary><strong>shaunco</strong> commented on 2021-01-12 18:17:47.000 UTC</summary>

Perhaps the workflow thread was blocked by Delve, via a breakpoint that had been set? Was this blocked thread detection newly added in 1.3.0?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-01-12 18:57:44.000 UTC</summary>

Yes, blocking the workflow thread on breakpoint would cause the deadlock detector to fire. The https://github.com/temporalio/sdk-go/pull/330 introduced the TEMPORAL_DEBUG environment variable that can be used to disable the deadlock detector for debugging purposes. 

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>shaunco</strong> commented on 2021-01-12 19:44:13.000 UTC</summary>

Great! We'll stay with 1.2.0 until #330 makes it in to a future release.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-01-12 20:34:48.000 UTC</summary>

Resolving as #330 provides a solution for debugging.

</details>

<details>
<summary><strong>jatins</strong> commented on 2023-03-11 11:49:04.000 UTC</summary>

If you, like me, are using temporal with Bazel and passing `--test_env=TEMPORAL_DEBUG=true` basel flag, or `os.Setenv('TEMPORAL_DEBUG', true)` aren't working, then this is for you


```diff
s.env = s.NewTestWorkflowEnvironment() // s is testify suite

+ workerOptions := worker.Options{DeadlockDetectionTimeout: 5 * time.Minute}
+ s.env.SetWorkerOptions(workerOptions)
```

</details>


---

<a id="167"></a>

### #167: Activity times out in test environment with child workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/167 |
| **State** | OPEN |
| **Author** | nirshirion (Nir Shirion) |
| **Created** | 2020-06-21 16:51:16.000 UTC (5y 6m ago) |
| **Updated** | 2024-03-15 22:58:51.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 3 |
| **Priority Score** | 7 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 ðŸ‘€ 1 |

#### Description

## Expected Behavior
GetWorkflowError() should not return an error.

## Actual Behavior
GetWorkflowError() returns an error:
TimeoutType: StartToClose, Cause: context deadline exceeded

## Steps to Reproduce the Problem

  1. Create a workflow that calls an activity with ScheduleToStartTimeout and StartToCloseTimeout initialized (in my case, it was 1 minute), and ScheduleToCloseTimeout uninitialized. If ScheduleToCloseTimeout is initialized, the problem doesn't happen.
  2. Create a parent workflow that calls the child workflow from part 1.
  3. Create a TestWorkflowEnvironment and execute the parent workflow.

## Specifications

  - Version: 0.24.4


#### Comments (3)

<details>
<summary><strong>cowell21</strong> commented on 2020-08-28 02:45:25.000 UTC</summary>

I'm experiencing the same issue with 0.28.1.

</details>

<details>
<summary><strong>bradleymcallister97</strong> commented on 2020-09-30 20:47:20.000 UTC</summary>

Has there been any progress on this? I am also having this issue with version `0.28.1`

</details>

<details>
<summary><strong>yeshwanthPentakota</strong> commented on 2021-08-14 00:46:45.000 UTC</summary>

Any progress on this? i am seeing the same error in `1.9.0`

</details>


---

<a id="129"></a>

### #129: Support passing activityId to an activity invocation 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/129 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-12 18:34:24.000 UTC (5y 8m ago) |
| **Updated** | 2020-07-24 17:31:59.000 UTC |
| **Closed** | 2020-07-24 17:31:59.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 5 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | samarabbas |
| **Milestone** | Code Complete |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
It is not possible to specify a business level ID for an activity during its invocation. This is a problem for completing activities asynchronously by ID.

**Describe the solution you'd like**
Provide a way to specify the ID when invoking an activity.


**Additional context**
[Similar Java SDK issue](https://github.com/temporalio/temporal-java-sdk/issues/86)

#### Comments (5)

<details>
<summary><strong>kkcmadhu</strong> commented on 2020-05-13 02:47:44.000 UTC</summary>

may i propose to use "domain:runid:activityId" ?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-05-13 04:43:04.000 UTC</summary>

@kkcmadhu I don't understand your proposal. Do you propose to use them where?

</details>

<details>
<summary><strong>kkcmadhu</strong> commented on 2020-05-13 05:32:14.000 UTC</summary>

@mfateev  i meant, why cant task tokens be human readable string of format <domain>:<runid>:<activityId>,  it wont be gibberish and will be unique too.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-05-13 16:29:08.000 UTC</summary>

@kkcmadhu For these use cases we already have CompleteActivityById. The token is expected to be fully opaque to be able to add additional info to it without breaking compatibility. 
The information that you want to embed in it is already available through [Activity.getActivityTask()](https://github.com/temporalio/temporal-java-sdk/blob/0e0316bbd07e479d28e4e6ac1c4cd6cacfd10f3f/src/main/java/io/temporal/activity/Activity.java#L229).

</details>

<details>
<summary><strong>samarabbas</strong> commented on 2020-07-23 21:52:38.000 UTC</summary>

Looks like go-sdk already supports passing in ActivityID:
https://github.com/temporalio/go-sdk/blob/master/internal/internal_activity.go#L64
```
        // ExecuteActivityOptions option for executing an activity
	ExecuteActivityOptions struct {
		ActivityID                    string // Users can choose IDs but our framework makes it optional to decrease the crust.
		TaskQueueName                 string
		ScheduleToCloseTimeoutSeconds int32
		ScheduleToStartTimeoutSeconds int32
		StartToCloseTimeoutSeconds    int32
		HeartbeatTimeoutSeconds       int32
		WaitForCancellation           bool
		OriginalTaskQueueName         string
		RetryPolicy                   *commonpb.RetryPolicy
	}
```

Am I missing something?

</details>


---

<a id="1834"></a>

### #1834: SDK client connection Issue on localhost 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1834 |
| **State** | CLOSED |
| **Author** | spy16 (Shivaprasad Bhat) |
| **Created** | 2025-02-19 14:47:04.000 UTC (10 months ago) |
| **Updated** | 2025-02-20 16:13:29.000 UTC |
| **Closed** | 2025-02-20 16:13:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

With the following snippet, the SDK should connect to the server:

```golang
	c, err := client.Dial(client.Options{
		HostPort: "localhost:7233",
	})
	if err != nil {
		panic(err)
	}
	defer c.Close()
```

## Actual Behavior

The connection times-outs with a 

```
panic: failed reaching server: context deadline exceeded

goroutine 1 [running]:
main.main()
	/Users/spy16/labs/temporalplay/main.go:13 +0xac
exit status 2
```

## Steps to Reproduce the Problem

  1. Run the server with `temporal server start-dev` 
  2. Run the client code shown above

> Might be intermittent as reported in this discussion as well https://github.com/grpc/grpc-go/issues/7429#issuecomment-2559404107

## Specifications

  - Version: SDK 1.32.1
  - Platform: Darwin FeatherBox.local 23.1.0 Darwin Kernel Version 23.1.0: Mon Oct  9 21:28:31 PDT 2023; root:xnu-10002.41.9~6/RELEASE_ARM64_T8112 arm64


#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2025-02-19 14:51:27.000 UTC</summary>

Does the same happen with `127.0.0.1:7233`? If so, it sounds like the default of `localhost` DNS lookup does not work on your setup for whatever reason.

</details>

<details>
<summary><strong>spy16</strong> commented on 2025-02-20 03:38:25.000 UTC</summary>

I should've mentioned. It works with `127.0.0.1:7233` just fine. It is a known issue with the `dns` resolver in the gRPC Go client.. The link to the whole discussion is mentioned above. The solution for `NewClient()` usage suggested is to use `passthrough://` as the schema but in the Temporal SDK, clients can't control the schema since it's accepting `hostname:port` format only.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-02-20 13:22:13.000 UTC</summary>

> The solution for `NewClient()` usage suggested is to use `passthrough://` as the schema but in the Temporal SDK, clients can't control the schema since it's accepting `hostname:port` format only.

Per the documentation on `HostPort`, I think `passthrough://` should work, have you tried? Does it give an error?

</details>

<details>
<summary><strong>spy16</strong> commented on 2025-02-20 14:50:20.000 UTC</summary>

with this:

```golang
	c, err := client.Dial(client.Options{
		HostPort: "passthrough://localhost:7233",
	})
```

I get this:

```
2025/02/20 20:19:23 INFO  No logger configured for temporal client. Created default one.
2025/02/20 20:19:23 [Err] failed: failed reaching server: failed to exit idle mode: passthrough: received empty target in Build()
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x2 addr=0x0 pc=0x10542db08]

goroutine 1 [running]:
main.main()
```

But for me `127.0.0.1` solution is good enough. I just wanted to report for others benefit if they get stuck due to this issue.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-20 16:10:49.000 UTC</summary>

Per the [issue](https://github.com/grpc/grpc-go/issues/7429#issuecomment-2559404107) you linked it should be `passthrough:///localhost:7233`

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-20 16:13:08.000 UTC</summary>

Marking as closed since this is a grpc go behaviour 

Reactions: ðŸ‘ 1

</details>


---

<a id="1808"></a>

### #1808: Configure extra log fields for SDK workflow and activity logs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1808 |
| **State** | CLOSED |
| **Author** | timofurrer (Timo Furrer) |
| **Created** | 2025-02-10 13:43:01.000 UTC (11 months ago) |
| **Updated** | 2025-10-01 16:45:50.000 UTC |
| **Closed** | 2025-10-01 16:45:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

I want to be able to easily attach business-related log fields to the log messages the SDK logs internally for workflows and activities.

One of such logs is 

https://github.com/temporalio/sdk-go/blob/6e75f6d1f22170f2aa3f89348a237955f6a28e96/internal/internal_task_handlers.go#L2271

The business-related values I want to attach are only known during workflow and activity creation and NOT during worker initialization. 

**Describe the solution you'd like**

Configuring them via `StartWorkflowOptions` and `ActivityOptions` seems desirable. 

**Describe alternatives you've considered**

I've looked into using Interceptors, but the problem with them is that I have to register them at worker initialization and don't know the values at that point. I've looked into using custom search attributes or memos - which both would work but only exist of Workflows and not Activities. I also haven't found a way to easily retrieve the search attributes / memos of the workflow given an activity context. 

The elaborate on the search attributes / memos approach: I basically would register an interceptor that reads the search attributes / memos from the workflow context and create a new logger with them that is returned.

What I want to avoid is having to query that data from within the activity interceptor from an "external" system.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2025-02-10 14:45:41.000 UTC</summary>

> but the problem with them is that I have to register them at worker initialization and don't know the values at that point

You don't need to know the values at that point, both activity and workflow outbound interceptors have `GetLogger` you can customize when called. https://github.com/temporalio/samples-go/tree/main/interceptor shows how to write the interceptor, but you can use the workflow/activity context in the interceptor to get workflow/activity-specific things like memo (or values via context propagation which may make more sense).

Does this help?

</details>

<details>
<summary><strong>timofurrer</strong> commented on 2025-02-10 15:42:17.000 UTC</summary>

> You don't need to know the values at that point, both activity and workflow outbound interceptors have `GetLogger` you can customize when called. https://github.com/temporalio/samples-go/tree/main/interceptor shows how to write the interceptor, but you can use the workflow/activity context in the interceptor to get workflow/activity-specific things like memo (or values via context propagation which may make more sense).

Are context values being persisted across activity / workflow retries
and such?


</details>

<details>
<summary><strong>timofurrer</strong> commented on 2025-02-14 11:44:33.000 UTC</summary>

@cretz while working on tracing for the SDK I implemented a context propagator - is that would I can use to persist the context values and use it for the logger? 

</details>

<details>
<summary><strong>timofurrer</strong> commented on 2025-02-14 14:56:08.000 UTC</summary>

@cretz I'm still struggling to get this working with what you suggested. I've implemented a context propagator that records my "values" into the contexts. I've also implemented a worker interceptor that, through the chain of the other interceptor implements `GetLogger()`. Something along the lines of this:

```go
package server

import (
	"context"

	"gitlab.com/gitlab-org/cluster-integration/gitlab-agent/v17/internal/tool/logz"
	"go.temporal.io/sdk/interceptor"
	tlog "go.temporal.io/sdk/log"
	"go.temporal.io/sdk/workflow"
)

type loggerInterceptor struct {
	interceptor.WorkerInterceptorBase
}

func newLoggerInterceptor() *loggerInterceptor {
	return &loggerInterceptor{}
}

func (w *loggerInterceptor) InterceptActivity(ctx context.Context, next interceptor.ActivityInboundInterceptor) interceptor.ActivityInboundInterceptor {
	i := &loggerActivityInboundInterceptor{root: w}
	i.Next = next
	return i
}

type loggerActivityInboundInterceptor struct {
	interceptor.ActivityInboundInterceptorBase
	root *loggerInterceptor
}

func (a *loggerActivityInboundInterceptor) Init(outbound interceptor.ActivityOutboundInterceptor) error {
	i := &loggerActivityOutboundInterceptor{root: a.root}
	i.Next = outbound
	return a.Next.Init(i)
}

type loggerActivityOutboundInterceptor struct {
	interceptor.ActivityOutboundInterceptorBase
	root *loggerInterceptor
}

func (a *loggerActivityOutboundInterceptor) GetLogger(ctx context.Context) tlog.Logger {
	logger := a.Next.GetLogger(ctx)

	values, ok := ctx.Value(contextPropagatorKey).(contextPropagatorValues)
	if !ok {
		logger.Warn("the passed context to the interceptor didn't contain the expected context propagator values")
		return logger
	}

	logger = tlog.With(logger,
		logz.ProjectIDN(values.ProjectID), logz.EventID(values.EventID), logz.EventType(values.EventType))
	return logger
}

func (w *loggerInterceptor) InterceptWorkflow(ctx workflow.Context, next interceptor.WorkflowInboundInterceptor) interceptor.WorkflowInboundInterceptor {
	i := &loggerWorkflowInboundInterceptor{root: w}
	i.Next = next
	return i
}

type loggerWorkflowInboundInterceptor struct {
	interceptor.WorkflowInboundInterceptorBase
	root *loggerInterceptor
}

func (w *loggerWorkflowInboundInterceptor) Init(outbound interceptor.WorkflowOutboundInterceptor) error {
	i := &loggerWorkflowOutboundInterceptor{root: w.root}
	i.Next = outbound
	return w.Next.Init(i)
}

type loggerWorkflowOutboundInterceptor struct {
	interceptor.WorkflowOutboundInterceptorBase
	root *loggerInterceptor
}

func (w *loggerWorkflowOutboundInterceptor) GetLogger(ctx workflow.Context) tlog.Logger {
	logger := w.Next.GetLogger(ctx)

	values, ok := ctx.Value(contextPropagatorKey).(contextPropagatorValues)
	if !ok {
		logger.Warn("the passed context to the interceptor didn't contain the expected context propagator values")
		return logger
	}

	logger = tlog.With(logger,
		logz.ProjectIDN(values.ProjectID), logz.EventID(values.EventID), logz.EventType(values.EventType))
	return logger
}
```

However, I'm only seeing "my" logger, with my fields for the logs I'm doing in the workflows and activities. That's desired, but all SDK internal logs are missing these fields - it's seems like it's not getting the logger through my `GetLogger()` implementations.

Some example log calls I expect to have my fields:

- https://github.com/temporalio/sdk-go/blob/4fb50dc4729f6dbd41874a8e303b5246f912b244/internal/internal_event_handlers.go#L775
- https://github.com/temporalio/sdk-go/blob/4fb50dc4729f6dbd41874a8e303b5246f912b244/internal/internal_event_handlers.go#L625

@cretz are we facing some variation of https://github.com/temporalio/sdk-go/issues/829 ?

cc @ktenzer

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-02-14 15:38:30.000 UTC</summary>

Ah, the interceptor and customizations are for when you call `GetLogger` in your activity or workflow. Yes, this is a duplicate of #829 if you're trying to customize internal logger use on a per-workflow basis. For those two log situations, you should consider using your own log statements in your own interceptor instead of relying on debug logs from the internals of the SDK.

</details>

<details>
<summary><strong>timofurrer</strong> commented on 2025-02-17 08:22:24.000 UTC</summary>

> For those two log situations, you should consider using your own log statements in your own interceptor instead of relying on debug logs from the internals of the SDK.

@cretz the two last examples I've referenced were indeed `Debug` logs, but the one I've referenced initially is an error log. (https://github.com/temporalio/sdk-go/blob/6e75f6d1f22170f2aa3f89348a237955f6a28e96/internal/internal_task_handlers.go#L2271) Those are especially useful if they would have the proper log fields. Yes, I may be able to use an interceptor to also log my own message on errors or maybe even just log the errors in the Workflows / Activities before returning one - but then we always have duplicate error logs which is not optimal. In addition, you may just introduce more logs to the SDK with different levels and "pollute" the app logs. 

Having a solution for https://github.com/temporalio/sdk-go/issues/829 would help I suppose.


Reactions: ðŸ‘ 1

</details>


---

<a id="1752"></a>

### #1752: unsuccessfulOperationErr.Failure undefined

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1752 |
| **State** | CLOSED |
| **Author** | hazcod (Niels Hofmans) |
| **Created** | 2024-12-10 02:38:07.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-10 21:19:02.000 UTC |
| **Closed** | 2024-12-10 21:19:02.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 2 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

## Expected Behavior
SDK compiles.

## Actual Behavior
```
8.960 # go.temporal.io/sdk/internal
8.960 /cache/go.temporal.io/sdk@v1.30.1/internal/internal_nexus_task_handler.go:66:16: handlerErr.Failure undefined (type *"github.com/nexus-rpc/sdk-go/nexus".HandlerError has no field or method Failure)
8.960 /cache/go.temporal.io/sdk@v1.30.1/internal/internal_nexus_task_handler.go:68:25: handlerErr.Failure undefined (type *"github.com/nexus-rpc/sdk-go/nexus".HandlerError has no field or method Failure)
8.960 /cache/go.temporal.io/sdk@v1.30.1/internal/internal_nexus_task_handler.go:69:25: handlerErr.Failure undefined (type *"github.com/nexus-rpc/sdk-go/nexus".HandlerError has no field or method Failure)
8.960 /cache/go.temporal.io/sdk@v1.30.1/internal/internal_nexus_task_handler.go:70:25: handlerErr.Failure undefined (type *"github.com/nexus-rpc/sdk-go/nexus".HandlerError has no field or method Failure)
8.960 /cache/go.temporal.io/sdk@v1.30.1/internal/internal_nexus_task_handler.go:231:45: unsuccessfulOperationErr.Failure undefined (type *"github.com/nexus-rpc/sdk-go/nexus".UnsuccessfulOperationError has no field or method Failure)
8.960 /cache/go.temporal.io/sdk@v1.30.1/internal/internal_nexus_task_handler.go:232:45: unsuccessfulOperationErr.Failure undefined (type *"github.com/nexus-rpc/sdk-go/nexus".UnsuccessfulOperationError has no field or method Failure)
8.960 /cache/go.temporal.io/sdk@v1.30.1/internal/internal_nexus_task_handler.go:233:45: unsuccessfulOperationErr.Failure undefined (type *"github.com/nexus-rpc/sdk-go/nexus".UnsuccessfulOperationError has no field or method Failure)
```

## Steps to Reproduce the Problem

  1. Use `	go.temporal.io/sdk v1.30.1` in go.mod.  Sums:
  ```
go.temporal.io/api v1.43.0 h1:lBhq+u5qFJqGMXwWsmg/i8qn1UA/3LCwVc88l2xUMHg=
go.temporal.io/api v1.43.0/go.mod h1:1WwYUMo6lao8yl0371xWUm13paHExN5ATYT/B7QtFis=
go.temporal.io/sdk v1.30.1 h1:4wgfSjwuaayQl9Q0mUzpNV6w55TPAESSroR6Z5lE49o=
go.temporal.io/sdk v1.30.1/go.mod h1:hNCZzd6dt7bxD9B4AECQgjHTd2NrzjdmGDbbv4xHuFU=
```
  2. Try compile the code
  3. Get the error

## Specifications

  - Version: 1.30.1
  - Platform: arm64 linux


#### Comments (2)

<details>
<summary><strong>thecampagnards</strong> commented on 2024-12-10 14:14:15.000 UTC</summary>

Hello, you can fix it using
```bash
go get github.com/nexus-rpc/sdk-go@v0.0.12
```
until an update that fix the dep breaking changes

</details>

<details>
<summary><strong>bergundy</strong> commented on 2024-12-10 21:19:02.000 UTC</summary>

Go SDK 1.31.0 was just released which fixes this complication issue.

Reactions: â¤ï¸ 1

</details>


---

<a id="1450"></a>

### #1450: Metric `workflow_task_execution_failed` is used with different sets of labels causing errors with Prometheus

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1450 |
| **State** | CLOSED |
| **Author** | wsny (William Snyders) |
| **Created** | 2024-04-25 03:19:40.000 UTC (1y 8m ago) |
| **Updated** | 2024-10-29 18:38:37.000 UTC |
| **Closed** | 2024-10-04 20:33:01.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
Should not receive errors about metrics being registered incorrectly.

## Actual Behavior
Receiving a Prometheus error about the workflow_task_execution_failed metric being registered with different labels.

```
a previously registered descriptor with the same fully-qualified name as Desc{fqName: "temporal_workflow_task_execution_failed_total", help: "temporal_workflow_task_execution_failed_total counter", constLabels: {}, variableLabels: {app,client_name,namespace,environment,workflow_type,failure_reason,task_queue,worker_type,deployment,activity_type,env}} has different label names or a different help string
```

## Steps to Reproduce the Problem

I am still working on STR's (don't know how to break all the below with test code yet), but I can see that this metric is being used with different tags in different places.

#1295 added a tag here
https://github.com/temporalio/sdk-go/blob/69bc6c3a19cdb21d5252c3ad4a490109b9a2f39c/internal/internal_task_pollers.go#L421

But it is not being added in these uses of the metric.
https://github.com/temporalio/sdk-go/blob/69bc6c3a19cdb21d5252c3ad4a490109b9a2f39c/internal/internal_event_handlers.go#L1108
https://github.com/temporalio/sdk-go/blob/69bc6c3a19cdb21d5252c3ad4a490109b9a2f39c/internal/internal_event_handlers.go#L1298

And that will cause issues with Prometheus, as shown in this example.

```go
package main

import (
	"fmt"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/uber-go/tally/v4"
	tallyprom "github.com/uber-go/tally/v4/prometheus"

	"go.temporal.io/sdk/client"
	sdktally "go.temporal.io/sdk/contrib/tally"
)

func main() {
	metricsHandler := setupPrometheus()
	// These lines in any order will cause an error where the metrics have different labels
	metricsHandler.Counter("testing").Inc(1)
	metricsHandler.WithTags(map[string]string{"someName": "someValue"}).Counter("testing").Inc(1)
}

// Just setup stuff for Prometheus below here
var PrometheusSanitizeOptions = tally.SanitizeOptions{
	NameCharacters:       tally.ValidCharacters{Ranges: tally.AlphanumericRange, Characters: []rune{'_'}},
	KeyCharacters:        tally.ValidCharacters{Ranges: tally.AlphanumericRange, Characters: []rune{'_'}},
	ValueCharacters:      tally.ValidCharacters{Ranges: tally.AlphanumericRange, Characters: []rune{'_'}},
	ReplacementCharacter: tally.DefaultReplacementCharacter,
}

func setupPrometheus() client.MetricsHandler {
	cfg := tallyprom.Configuration{
		ListenAddress: "localhost:9090",
	}
	reporter, _ := cfg.NewReporter(tallyprom.ConfigurationOptions{
		Registry: prometheus.NewRegistry(),
		OnError: func(err error) {
			fmt.Printf("BOOM: %+v\n", err)
		},
	})
	scopeOpts := tally.ScopeOptions{CachedReporter: reporter, SanitizeOptions: &PrometheusSanitizeOptions}
	scope, _ := tally.NewRootScope(scopeOpts, time.Second)
	scope = sdktally.NewPrometheusNamingScope(scope)
	return sdktally.NewMetricsHandler(scope)
}
```

Which causes this error
```
a previously registered descriptor with the same fully-qualified name as Desc{fqName: "testing_total", help: "testing_total counter", constLabels: {}, variableLabels: {someName}} has different label names or a different help string
```

## Specifications

  - Version: sdk-go@v1.26.1


#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2024-04-25 12:46:51.000 UTC</summary>

:+1: We should ideally only be recording this metric in one place and it should always contain the same tag/label set. Thanks for reporting! This is on our backlog and we will see about fixing.

Reactions: ðŸ‘ 5

</details>

<details>
<summary><strong>AmirSoleimani</strong> commented on 2024-10-11 12:59:14.000 UTC</summary>

I noticed that the issue has been closed and addressed. I've been facing the same issue and the merged changes addressed it (I had to pull the master branch to test). However, I haven't seen a new release with the fix yet. Can you provide any updates on when the fix might be included in a release? Thank you for your help! - cc @yuandrew 

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2024-10-22 17:37:55.000 UTC</summary>

Hey Amir, sorry for the delay, there are a few more changes we are hoping to get into the next release, I am hoping we can cut a new release in the next 2 weeks!

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2024-10-29 18:38:35.000 UTC</summary>

v1.30.0 has just been released

</details>


---

<a id="1331"></a>

### #1331: Temporal Go SDK can not be used with bazel_gazelle 0.32+

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1331 |
| **State** | CLOSED |
| **Author** | saumitrabhave (Saumitra Bhave) |
| **Created** | 2023-12-23 05:58:08.000 UTC (2 years ago) |
| **Updated** | 2024-03-13 15:26:11.000 UTC |
| **Closed** | 2024-03-13 15:26:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The prject should build fine

## Actual Behavior
Error is produced is bazel build like

/external/com_github_grpc_ecosystem_grpc_gateway/runtime/BUILD.bazel:5:11: no such package '@go_googleapis//google/api': The repository '@go_googleapis' could not be resolved: Repository '@go_googleapis' is not defined and referenced by '@com_github_grpc_ecosystem_grpc_gateway//runtime:go_default_library'


## Steps to Reproduce the Problem

  1. go get go.temporal.io/sdk  [ this gets v1.25.1  which also adds github.com/grpc-ecosystem/grpc-gateway v1.16.0  as dependency]
  2. bazel run //:gazelle-update-repos
  3. bazel build the project

## Specifications

Errors:
  - io_bazel_rules_go: 0.42
  - bazel_gazelle: 0.33

Works Fine with 
  - io_bazel_rules_go: 0.40
  - bazel_gazelle: 0.31.1

## Additional Details

I am a noob in bazel and go build tool chains in general but with whatever I could see there might be multiple issues at play. even to build with older versions(as mentioned above) I had to add `build_naming_convention = "go_default_library",  #keep` to the `com_github_grpc_ecosystem_grpc_gateway` dependency.

Even after adding this, if I increase the bazelle_gazelle version, it still errors out with error above. I think it has something to do with the fact that bazelle_gazelle stopped resolving go and proto imports to @go_googleapis since 0.32 as per https://github.com/bazelbuild/bazel-gazelle/releases. and that is where the injection point is for the error I am facing.

#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-01 23:06:09.000 UTC</summary>

I am not super familiar with bazel, but is the problem really with `github.com/grpc-ecosystem/grpc-gateway`  does the same issue exist with `github.com/grpc-ecosystem/grpc-gateway/v2`? Since that is what the head of the repo uses.

</details>

<details>
<summary><strong>SpencerC</strong> commented on 2024-01-23 17:45:53.000 UTC</summary>

Slightly different problem with Bzlmod, but also traces back to `grpc-gateway`:
```
ERROR: /private/var/tmp/_bazel_spencerconnaughton/9b09d78e8f2190e9af61aa37bcab571e/external/gazelle~0.35.0~go_deps~io_temporal_go_api/internal/temporalgateway/BUILD.bazel:3:11: no such target '@gazelle~0.35.0~go_deps~com_github_grpc_ecosystem_grpc_gateway//runtime:runtime': target 'runtime' not declared in package 'runtime' defined by /private/var/tmp/_bazel_spencerconnaughton/9b09d78e8f2190e9af61aa37bcab571e/external/gazelle~0.35.0~go_deps~com_github_grpc_ecosystem_grpc_gateway/runtime/BUILD.bazel (Tip: use `query "@@gazelle~0.35.0~go_deps~com_github_grpc_ecosystem_grpc_gateway//runtime:*"` to see all the targets in that package) and referenced by '@gazelle~0.35.0~go_deps~io_temporal_go_api//internal/temporalgateway:temporalgateway'
```
Hopefully will be fixed by #1365

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-23 17:54:28.000 UTC</summary>

@SpencerC I am not sure how your PR is related to this issue.

Note: `grpc-gateway` is already updated to v2 on the head of the repo

</details>

<details>
<summary><strong>SpencerC</strong> commented on 2024-01-23 18:08:02.000 UTC</summary>

@Quinn-With-Two-Ns oops, got my gRPC packages mixed up! It works on HEAD. @saumitrabhave try `go get go.temporal.io/sdk@94a5f5f81f98b9351a0df0dd6833582e83052a0e`.


</details>

<details>
<summary><strong>saumitrabhave</strong> commented on 2024-01-23 20:26:11.000 UTC</summary>

Thanks @Quinn-With-Two-Ns and @SpencerC ... let me check and get back

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-13 15:26:05.000 UTC</summary>

Closing since the Go SDK now uses `grpc-gateway v2`

</details>


---

<a id="1310"></a>

### #1310: Unable to compile using v1.26.1

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1310 |
| **State** | CLOSED |
| **Author** | skandragon (Michael Graff) |
| **Created** | 2023-11-30 17:49:20.000 UTC (2y 1m ago) |
| **Updated** | 2024-02-05 21:41:17.000 UTC |
| **Closed** | 2023-12-01 15:44:55.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
It to just work :)

## Actual Behavior

After a `go get -u ./...` to update dependencies, 

```
# go.temporal.io/sdk/internal/protocol
../../../../../go/pkg/mod/go.temporal.io/sdk@v1.25.1/internal/protocol/util.go:39:40: cannot use msg.Body (variable of type *anypb.Any) as *types.Any value in argument to types.AnyMessageName
# go.temporal.io/sdk/internal/common/metrics
../../../../../go/pkg/mod/go.temporal.io/sdk@v1.25.1/internal/common/metrics/grpc.go:120:44: cannot use s (variable of type *"github.com/gogo/status".Status) as *"google.golang.org/grpc/internal/status".Status value in argument to serviceerror.FromStatus
```

## Steps to Reproduce the Problem

Apparently, updating from temporal SDK 1.26.0 to 1.26.1.  Minimal change:

```
% go get -u go.temporal.io/api <--- becomes 1.26.1
```

This also changes this dependency:

```
-       go.temporal.io/api v1.26.0 // indirect
+       go.temporal.io/api v1.26.1 // indirect
-       github.com/grpc-ecosystem/grpc-gateway v1.16.0 // indirect
+       github.com/grpc-ecosystem/grpc-gateway/v2 v2.18.1 // indirect
```

## Details

go.mod:

```
require (
	github.com/Khan/genqlient v0.6.0
	github.com/aws/aws-sdk-go-v2 v1.23.4
	github.com/aws/aws-sdk-go-v2/config v1.25.10
	github.com/aws/aws-sdk-go-v2/feature/s3/manager v1.15.3
	github.com/aws/aws-sdk-go-v2/service/s3 v1.47.1
	github.com/aws/smithy-go v1.18.1
	github.com/google/go-containerregistry v0.17.0
	github.com/google/uuid v1.4.0
	github.com/oklog/ulid/v2 v2.1.0
	github.com/pborman/uuid v1.2.1
	github.com/redis/go-redis/v9 v9.3.0
	github.com/spf13/cobra v1.8.0
	github.com/spf13/viper v1.17.0
	go.temporal.io/sdk v1.25.1
)

require (
	github.com/agnivade/levenshtein v1.1.1 // indirect
	github.com/alexflint/go-arg v1.4.3 // indirect
	github.com/alexflint/go-scalar v1.2.0 // indirect
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.5.3 // indirect
	github.com/aws/aws-sdk-go-v2/credentials v1.16.8 // indirect
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.14.8 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.2.7 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.5.7 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.7.1 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.2.7 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.10.3 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.2.7 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.10.7 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.16.7 // indirect
	github.com/aws/aws-sdk-go-v2/service/sso v1.18.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.21.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.26.1 // indirect
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/containerd/stargz-snapshotter/estargz v0.15.1 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/docker/cli v24.0.7+incompatible // indirect
	github.com/docker/distribution v2.8.3+incompatible // indirect
	github.com/docker/docker v24.0.7+incompatible // indirect
	github.com/docker/docker-credential-helpers v0.8.0 // indirect
	github.com/facebookgo/clock v0.0.0-20150410010913-600d898af40a // indirect
	github.com/fsnotify/fsnotify v1.7.0 // indirect
	github.com/gogo/googleapis v1.4.1 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/gogo/status v1.1.1 // indirect
	github.com/golang/mock v1.6.0 // indirect
	github.com/golang/protobuf v1.5.3 // indirect
	github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.18.1 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/jmespath/go-jmespath v0.4.0 // indirect
	github.com/klauspost/compress v1.17.3 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mitchellh/go-homedir v1.1.0 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.1.0-rc5 // indirect
	github.com/pelletier/go-toml/v2 v2.1.0 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/robfig/cron v1.2.0 // indirect
	github.com/sagikazarmark/locafero v0.4.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.11.0 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/stretchr/objx v0.5.1 // indirect
	github.com/stretchr/testify v1.8.4 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/vbatts/tar-split v0.11.5 // indirect
	github.com/vektah/gqlparser/v2 v2.5.10 // indirect
	go.temporal.io/api v1.26.1 // indirect
	go.uber.org/atomic v1.11.0 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	golang.org/x/exp v0.0.0-20231127185646-65229373498e // indirect
	golang.org/x/mod v0.14.0 // indirect
	golang.org/x/net v0.19.0 // indirect
	golang.org/x/sync v0.5.0 // indirect
	golang.org/x/sys v0.15.0 // indirect
	golang.org/x/text v0.14.0 // indirect
	golang.org/x/time v0.5.0 // indirect
	golang.org/x/tools v0.16.0 // indirect
	google.golang.org/genproto v0.0.0-20231127180814-3a041ad873d4 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20231127180814-3a041ad873d4 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20231127180814-3a041ad873d4 // indirect
	google.golang.org/grpc v1.59.0 // indirect
	google.golang.org/protobuf v1.31.0 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

```

## Specifications

  - Version: sdk 1.26.1
  - Platform: go 1.21



#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-30 18:09:59.000 UTC</summary>

Due to work to deprecate `gogoproto` `go.temporal.io/api v1.26.1 ` is not compatible with `go.temporal.io/sdk v1.25.1`. The SDK only is compatible with the version in its go.mod

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-01 15:44:55.000 UTC</summary>

`go.temporal.io/api 1.26.1` has been retracted

https://github.com/temporalio/api-go/commit/b175d7eddedb89516a569ac6c5e2e837b02d0f9c

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>chriscerk</strong> commented on 2024-02-05 21:00:35.000 UTC</summary>

**Problem**

>  The SDK only is compatible with the version in its go.mod

â­ For orgs using dependabot, this presents a problem based on the way that temporal is releasing their versions.

Reasoning being that we are running into compile issues from the following step of events:

1.  Using `go.temporal.io/sdk@v1.25.1`
2. `go.temporal.io/api@v1.27.0` released 
3. Dependabot opens a PR for `go.temporal.io/api@v1.27.0` released, **_without_** a dependabot PR for `go.temporal.io/sdk@1.26.0-rc2` since it is a release candidate
4. Builds fail due to compile issues.
 
**Proposal**

>  The SDK only is compatible with the version in its go.mod

â­ @Quinn-With-Two-Ns if that is true - should `go.temporal.io/api@v1.27.0` been a pre-release / release-candidate?

A release candidate would ensure that dependabots would occur at the appropriate time to avoid incompatibility issues.

Thoughts?

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-05 21:41:15.000 UTC</summary>

>should go.temporal.io/api@v1.27.0 been a pre-release / release-candidate?

No, The Go SDK is not the only consumer of `go.temporal.io/api` and their releases are not coupled in general.

I don't really see the problem with dependabot, the build failed as it should as you should not be updating the `api` by updating the `go-sdk`

Reactions: ðŸ‘ 1

</details>


---

<a id="1208"></a>

### #1208: Canceling a context with multiple child contexts can be non deterministic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1208 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-08-24 15:41:36.000 UTC (2y 4m ago) |
| **Updated** | 2024-03-04 18:55:53.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 2 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

## Expected Behavior
Child context cancellation propagates in a deterministic order 

## Actual Behavior
Child context cancellation does not propagates in a deterministic order.

When a parent context cancels its' children it loops [through a map](https://github.com/temporalio/sdk-go/blob/b9e5e241869fdb39b03ef8b6ef043ce75c78344e/internal/context.go#L338). Map order in Go is not deterministic so the order child contexts are canceled is not deterministic.

## Steps to Reproduce the Problem
```
func TestContextCancellationOrderDeterminism(t *testing.T) {
	/*
		Previously, child-contexts were stored in a map, preventing deterministic order when propagating cancellation.
		The order of branches being selected in this test was random, both for the first event and in following ones.

		In principle this should be fine, but it's possible for the effects of cancellation to trigger a selector's
		future-done callback, which currently records the *real-time*-first event as the branch to unblock, rather than
		doing something more safe by design (e.g. choosing based on state when the selector's goroutine is unblocked).

		Unfortunately, we cannot change the selector's behavior without introducing non-backwards-compatible changes to
		currently-working workflows.

		So the workaround for now is to maintain child-context order, so they are canceled in a consistent order.
		As this order was not controlled before, and Go does a pretty good job at randomizing map iteration order,
		converting non-determinism to determinism should be strictly no worse for backwards compatibility, and it
		fixes the issue for future executions.
	*/
	check := func(t *testing.T, separateStart, separateSelect bool) {
		env := newTestWorkflowEnv(t)
		act := func(ctx context.Context) error {
			return nil // will be mocked
		}
		wf := func(ctx Context) ([]int, error) {
			ctx, cancel := WithCancel(ctx)
			Go(ctx, func(ctx Context) {
				_ = Sleep(ctx, time.Minute)
				cancel()
			})

			// start some activities, which will not complete before the timeout cancels them
			ctx = WithActivityOptions(ctx, ActivityOptions{
				TaskQueue:              "",
				ScheduleToCloseTimeout: time.Hour,
				ScheduleToStartTimeout: time.Hour,
				StartToCloseTimeout:    time.Hour,
			})
			s := NewSelector(ctx)
			var result []int
			for i := 0; i < 10; i++ {
				i := i
				// need a child context, a future alone is not enough as it does not become a child
				cctx, ccancel := WithCancel(ctx)

				s.AddFuture(ExecuteActivity(cctx, act), func(f Future) {
					ccancel() // TODO: is this necessary to prevent leaks?  if it is, how can we make it not?
					err := f.Get(ctx, nil)
					if err == nil || !IsCanceledError(err) {
						// fail the test, this should not happen - activities must be canceled or it's not valid.
						t.Errorf("activity completion or failure for some reason other than cancel: %v", err)
					}
					result = append(result, i)
				})

				if separateStart {
					// yield so they are submitted one at a time, in case that matters
					_ = Sleep(ctx, time.Second)
				}
			}
			for i := 0; i < 10; i++ {
				if separateSelect {
					// yield so they are selected one at a time, in case that matters
					_ = Sleep(ctx, time.Second)
				}
				s.Select(ctx)
			}

			return result, nil
		}
		env.RegisterWorkflow(wf)
		env.RegisterActivity(act)

		// activities must not complete in time
		env.OnActivity(act, mock.Anything).After(5 * time.Minute).Return(nil)

		env.ExecuteWorkflow(wf)
		require.NoError(t, env.GetWorkflowError())
		var result []int
		require.NoError(t, env.GetWorkflowResult(&result))
		require.NotEmpty(t, result)
		assert.Equal(t, 0, result[0], "first activity to be created should be the first one canceled")
		assert.Equal(t, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}, result[1:], "other activities should finish in a consistent (but undefined) order")
	}

	type variant struct {
		name           string
		separateStart  bool
		separateSelect bool
	}
	// all variants expose this behavior, but being a bit more exhaustive in the face
	// of decision-scheduling differences seems good.
	for _, test := range []variant{
		{"many in one decision", false, false},
		{"many started at once, selected slowly", false, true},
		{"started slowly, selected quickly", true, false},
		{"started and selected slowly", true, true},
	} {
		t.Run(test.name, func(t *testing.T) {
			check(t, test.separateStart, test.separateSelect)
		})
	}
}

```

Note: this test came from [cadence go client ](https://github.com/uber-go/cadence-client) where I noticed they had fixed this bug.



#### Comments (2)

<details>
<summary><strong>throwaway58383958484</strong> commented on 2024-03-04 16:33:24.000 UTC</summary>

Could this be fixed now using the new helper? https://github.com/temporalio/sdk-go/pull/1340

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-04 18:55:52.000 UTC</summary>

No since the keys of the map cannot be sorted. Likely we would just copy what `Cadence` did to resolve this problem https://github.com/uber-go/cadence-client/commit/dcaec7737070ebe0889f1c9bb57c2552c8bd7d86

</details>


---

<a id="1125"></a>

### #1125: ReceiveWithTimeout should cancel outstanding timers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1125 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2023-06-02 15:01:16.000 UTC (2y 7m ago) |
| **Updated** | 2025-02-04 18:09:11.000 UTC |
| **Closed** | 2025-02-04 18:09:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | bug, enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
ReceiveWithTimeout doesn't cancel outstanding timers.

**Describe the solution you'd like**
Cancel outstanding timers.


#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2023-06-02 15:11:48.000 UTC</summary>

This will be implicitly solved if/when https://github.com/temporalio/sdk-go/issues/986 is.

</details>

<details>
<summary><strong>captchanjack-anzx</strong> commented on 2025-01-22 12:17:20.000 UTC</summary>

Any update on this? With the new UI it's pretty clear timers are still not being cancelled from signals are received

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/6d3c965c-8565-40d0-9b80-41612817ab91" />

my implementation:
```
	exit := false
	for !exit {
		var got SignalPayload[T]
		ok, more := s.receiveChannel.ReceiveWithTimeout(ctx, s.timeout, &got)
		if !ok {
			return ErrSignalReceiverTimeout
		}

		exit = signalCallback(got)
		if exit || !more {
			break
		}
	}

	return nil
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-01-22 13:23:35.000 UTC</summary>

No update at this time (same as #986). This is something we may prioritize, but can we get an idea of your impact? While a timer that is no longer listened to does fire and cause the workflow to potentially replay, there should be no user-visible effects of this.

</details>

<details>
<summary><strong>captchanjack-anzx</strong> commented on 2025-01-22 13:33:25.000 UTC</summary>

All good just wanted to check. I am wondering though what would happen when the timers do timeout while ReceiveWithTimeout loop is still active?

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-01-22 15:34:51.000 UTC</summary>

Each call to `ReceiveWithTimeout` makes its own timer, so it's not about the loop, it's about the `ReceiveWithTimeout` call. Today if the `ReceiveWithTimeout` call completes successfully before timeout, then the timer fires in the background but has no visible effect because nothing is listening to it anymore.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:09:10.000 UTC</summary>

Consolidating this with https://github.com/temporalio/sdk-go/issues/986

</details>


---

<a id="1103"></a>

### #1103: workflow.UpsertSearchAttributes sdk function doesn't return error but fails the workflow task.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1103 |
| **State** | CLOSED |
| **Author** | ObedImmanuel |
| **Created** | 2023-05-12 07:40:56.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-15 06:25:31.000 UTC |
| **Closed** | 2023-05-15 06:05:26.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
[workflow.UpsertSearchAttributes](https://legacy-documentation-sdks.temporal.io/go/search-apis?_ga=2.126147917.1174630429.1683809094-671880620.1679381320#upsert-search-attributes-during-workflow-execution) sdk function returns a nil error but fails the workflow.
We would need to just log the error and not break the workflow's execution.
Looking at the implementation, the function generates a command and upserts search attribute in background. And fails the workflow on `BadSearchAttribute` or other failures.

**Describe the solution you'd like**
We would want the sdk to not fail the workflow on failure during upsertion. some configuration or env variable to control this behaviour would help.

**Describe alternatives you've considered**


**Additional context**


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-12 08:10:07.000 UTC</summary>

Are you seeing the workflow task fail or the workflow fail?

</details>

<details>
<summary><strong>ObedImmanuel</strong> commented on 2023-05-12 08:26:45.000 UTC</summary>

Workflow task fail.
<img width="1603" alt="Screenshot 2023-05-12 at 1 55 28 PM" src="https://github.com/temporalio/sdk-go/assets/49405785/23e27a0b-3398-4f6d-bfd5-ae8781335d12">


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-12 08:36:12.000 UTC</summary>

I believe this is the Temporal server failing the workflow task because the search attribute is invalid. There is nothing the SDK can do if the server fails the workflow task.

</details>

<details>
<summary><strong>ObedImmanuel</strong> commented on 2023-05-15 06:05:26.000 UTC</summary>

Makes sense, Thanks.

</details>


---

<a id="1049"></a>

### #1049: All workflow gorounies should never run after workflow method returns.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1049 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2023-02-20 19:45:25.000 UTC (2y 10m ago) |
| **Updated** | 2024-08-31 02:05:15.000 UTC |
| **Closed** | 2024-08-31 02:05:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Workflow goroutines are never scheduled to run after the main workflow function returns.

## Actual Behavior

Other goroutines are given chance to execute after the main workflow function returns.


## Steps to Reproduce the Problem

See https://github.com/temporalio/samples-go/pull/255

#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-20 23:17:31.000 UTC</summary>

I wonder if we should consider it an error to have unfinished workflow goroutines once the main workflow function returns? 

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-21 13:15:28.000 UTC</summary>

> I wonder if we should consider it an error to have unfinished workflow goroutines once the main workflow function returns?

Nah, shouldn't even warn IMO. An unawaited promise/task in other languages make sense, but quite often Goroutines are fire-and-forget and/or just run forever waiting on a signal that will never come.

Note, technically this may be a backwards incompatible change if a post-return coroutine updates a value a query may use.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-21 16:55:34.000 UTC</summary>

>Goroutines are fire-and-forget and/or just run forever waiting on a signal that will never come

Writing fire and forget goroutines is not safe, you have no guarantee it will run. you need something like a `waitgroup`. Also that sounds like a memory leak?

Yeah this does seem backwards incompatible. Currently we say our workflow goroutines have similar semantics to normal goroutines. normal goroutines do not stop executing if the parent stops.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-21 17:28:34.000 UTC</summary>

> Writing fire and forget goroutines is not safe, you have no guarantee it will run

That may be ok with me as a user

> Also that sounds like a memory leak?

Nah, IIRC we `runtime.Goexit` all goroutines belonging to a workflow.

> Yeah this does seem backwards incompatible. Currently we say our workflow goroutines have similar semantics to normal goroutines. normal goroutines do not stop executing if the parent stops.

If you're looking for an analogy, it's not like a "parent" and more like a "process" IMO. I think workflow completion is like `os.Exit()`. But yes, if today we run coroutines after workflow complete we probably can't change without that SDK version marker thing.

I think other SDKs may have this same "problem" (if we decide this is wrong behavior; starting to wonder). In Python I don't think I immediately stop all coroutines on the primary one completing. I just collect commands until all yielded/complete and send them back. I wonder how core reacts to a command coming after workflow completion. Will bring up at standup.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-21 17:52:51.000 UTC</summary>

>Nah, IIRC we runtime.Goexit all goroutines belonging to a workflow.

I'll have to look at the code, but if we do that means `defer` will still run.

>If you're looking for an analogy, it's not like a "parent" and more like a "process" IMO. I think workflow completion is like os.Exit(). But yes, if today we run coroutines after workflow complete we probably can't change without that SDK version marker thing.

hhm yeah if those are the semantics then nothing should be run after the workflow exit including `defer` statements. 


Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-31 02:05:15.000 UTC</summary>

Going to mark this as closed as with the addition of workflow update the current behaviour is desirable

https://github.com/temporalio/features/issues/481 

</details>


---

<a id="1042"></a>

### #1042: How can I test Temporal code that uses `activity.GetLogger(ctx)`?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1042 |
| **State** | CLOSED |
| **Author** | zoltanmaric (ZoltÃ¡n MariÄ‡) |
| **Created** | 2023-02-16 14:07:18.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-21 18:27:48.000 UTC |
| **Closed** | 2023-03-21 18:27:47.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

Say I have a function in an activity that looks like this:

```golang
func logSomething(ctx context.Context) {
  log := activity.GetLogger(ctx)
  log.Info("logging something")
}
```

Now if I want to call that function from a test like this:
```golang
logSomething(context.Background())
```

It will fail with:
```
test panicked: getActivityOutboundInterceptor: Not an activity context
```

How do I get a proper activity context in a test? I tried tacking on an activity interceptor onto the context like this:
```golang
var Logger logger.Logger = logger.NewLogger(zapcore.DebugLevel)
var TemporalLogger = logur.LoggerToKV(Logger)

type fakeTemporalActivityOutBoundInterceptor struct {
	interceptor.ActivityOutboundInterceptorBase
}

func (f *fakeTemporalActivityOutBoundInterceptor) GetLogger(_ temporal_workflow.Context) temporal_log.Logger {
	return TemporalLogger
}


ctx := context.WithValue(
	context.Background(),
	"activityInterceptor",
	&fakeTemporalActivityOutBoundInterceptor{},
)
```

But `"activityInterceptor"` is not recognized as equal to [`activityInterceptorContextKey`](https://github.com/temporalio/sdk-go/blob/v1.17.0/internal/internal_activity.go#L155), so I still get the same error :/

I'm using [`temporalio v1.17.0`](https://github.com/temporalio/sdk-go/tree/v1.17.0)


#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2023-02-16 14:14:41.000 UTC</summary>

For running activity tests with a properly setup context, you should use the `testsuite.WorkflowTestSuite` which can give you a `testsuite.ActivityTestEnvironment`. https://github.com/temporalio/samples-go/blob/86f65121e4fee9d4d32fccf05d342d7d372c66c1/helloworld/helloworld_test.go#L28-L39 is an example of testing an activity.

</details>

<details>
<summary><strong>zoltanmaric</strong> commented on 2023-02-16 14:27:16.000 UTC</summary>

Thanks for the quick answer @cretz! In this case, I wanted to only test a function that's called inside the activity, which gets an activity context passed to it - not the full blown activity. Is there any way to carve out the activity context from a `testsuite.ActivityTestEnvironment`?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-16 14:58:42.000 UTC</summary>

To the environment, there is (mostly) no difference between a "full blown activity" and "a function that's called inside the activity". That test environment is for all functions that accept an activity context. If there are issues with argument serialization or some other reason you can't invoke that function via the environment directly, you can make a simple activity-like function in your test case that just delegates to that function.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-03-21 18:27:47.000 UTC</summary>

Closing since there has been no activity

</details>


---

<a id="1003"></a>

### #1003: Setting MaxConcurrentWorkflowTaskExecutionSize to 1 results in worker not executing any tasks

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1003 |
| **State** | CLOSED |
| **Author** | phudtran (Phu Tran) |
| **Created** | 2023-01-06 23:31:36.000 UTC (3 years ago) |
| **Updated** | 2023-01-16 11:34:47.000 UTC |
| **Closed** | 2023-01-16 11:34:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Worker executes 1 workflow at a time.

## Actual Behavior

Worker does nothing

## Steps to Reproduce the Problem

  1. Create a new worker
  1. Set MaxConcurrentWorkflowTaskExecutionSize to 1 in the worker options

## Specifications

  - Version: v1.19.0
  - Platform: Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-1026-aws x86_64)


#### Comments (6)

<details>
<summary><strong>yiminc</strong> commented on 2023-01-13 22:43:45.000 UTC</summary>

The minimal size is 2 for it to work. This is known behavior and is documented. 
For SDK to consider better handle this case either by automatically promote to 2 or error out.

</details>

<details>
<summary><strong>dnr</strong> commented on 2023-01-14 02:14:27.000 UTC</summary>

Sorry, I confused this setting with workflow task _pollers_ (which does have min 2) and mentioned it to Yimin, so that was my mistake. As far as I know this limitation is not documented or known.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>phudtran</strong> commented on 2023-01-14 02:23:35.000 UTC</summary>

I noticed the other documented settings had this limitation so I tried setting MaxConcurrentWorkflowTaskExecutionSize to 2. It seems to do the correct behavior in my tests last week :grinning:


</details>

<details>
<summary><strong>dnr</strong> commented on 2023-01-14 02:33:16.000 UTC</summary>

(Btw limiting concurrent workflow task execution is probably not the right solution for anything. If you share why you wanted to do this you might get a better alternative.)

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-01-14 03:23:36.000 UTC</summary>

Looks like we limit the number of pollers to `MaxConcurrentWorkflowTaskExecutionSize ` so the worker will only be polling on the sticky queue, so it will never pick up work. So the root cause is the same reason we need 2 workflow task pollers

Note: Technically we do create `maxConcurrentWorkflowTaskPollers ` number of pollers , but only really start `MaxConcurrentWorkflowTaskExecutionSize `

`MaxConcurrentWorkflowTaskExecutionSize` should never be less than `MaxConcurrentWorkflowTaskPollers `

We call this out here https://docs.temporal.io/application-development/worker-performance#invariants but say it only applies to java which is not true it also applies to the go sdk from reading the code.

Basically we need to document this and probably force `MaxConcurrentWorkflowTaskExecutionSize` to be greater than `MaxConcurrentWorkflowTaskPollers `

</details>

<details>
<summary><strong>phudtran</strong> commented on 2023-01-14 04:15:09.000 UTC</summary>

> (Btw limiting concurrent workflow task execution is probably not the right solution for anything. If you share why you wanted to do this you might get a better alternative.)

We're in the early stages of using Temporal for a cloud simulation project.
In our case, we're using workflows to represent a _set of VMs_ to be created on a Node, and activities representing each of the VMs to be created. I only stumbled upon this MaxConcurrentWorkflowTaskExecutionSize behavior because of a temporary accommodation for an upstream service in test. 

</details>


---

<a id="982"></a>

### #982: Cannot register mock activity with string name on test workflow environment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/982 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-12-13 15:07:46.000 UTC (3 years ago) |
| **Updated** | 2025-01-12 12:32:11.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

Should be able to call `OnActivity("string-name"` without having registered it first

## Actual Behavior

We check whether it was registered first. There are activities defined in different languages that do not have a Go function to have been registered.

Stop requiring activities to be registered before mocking them.

#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2023-03-02 15:00:24.000 UTC</summary>

We may have to require registration first, but we should at least document that we require registration first.

</details>

<details>
<summary><strong>Turao</strong> commented on 2024-12-29 14:41:15.000 UTC</summary>

I also bumped into this issue while learning how to use the SDK.

I don't understand why registration is even required in the first place, since `OnActivity` aims to override the function's behavior - the original function is completely ignored: https://github.com/temporalio/sdk-go/blob/master/internal/workflow_testsuite.go#L413

To make matters worse, it looks like we cannot even register the activities before calling `OnActivity`, since:
- `RegisterActivity` expects a function (or struct?)
- `RegisterActivityWithOptions` expects an internal struct (and we cannot use internal packages, else we get "use of internal package go.temporal.io/sdk/internal not allowed")

Example: https://github.com/Turao/temporal-study/blob/main/src/temporal/workflows/start-new-project/workflow_test.go

Could this assertion be dropped? It feels quite unnecessary.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-01-06 15:42:05.000 UTC</summary>

> RegisterActivity expects a function (or struct?)

A dummy function works fine

> RegisterActivityWithOptions expects an internal struct (and we cannot use internal packages, else we get "use of internal package go.temporal.io/sdk/internal not allowed")

Use `go.temporal.io/sdk/activity.RegisterOptions` which is an alias to that internal type

> Could this assertion be dropped? It feels quite unnecessary.

I think the issue is that local activities expect to validate the argument types before dispatching to the actual activity, which the mock can provide. It may be possible for us to relax this requirement since it is local activity only, which is the reason we created this issue. In the meantime, just register a dummy function that has the proper argument types.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Turao</strong> commented on 2025-01-12 12:32:05.000 UTC</summary>

> In the meantime, just register a dummy function that has the proper argument types.

That works! Thanks for the explanation :)

</details>


---

<a id="926"></a>

### #926: Unable to reproduce `workflow.ErrSessionFailed`, session gets recreated with same ID after process restarts

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/926 |
| **State** | CLOSED |
| **Author** | subhan-nadeem (Subhan Nadeem) |
| **Created** | 2022-10-01 03:54:29.000 UTC (3y 3m ago) |
| **Updated** | 2025-02-04 18:26:35.000 UTC |
| **Closed** | 2025-02-04 18:26:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

## Expected Behavior

- `workflow.ErrSessionFailed` is returned when attempting to reschedule an activity after the process on which a session exists is restarted.

## Actual Behavior

- After process restarts, session is recreated with the same ID and workflows are scheduled on the same task queue as the previous session.

## Steps to Reproduce the Problem

  1. Start a local worker that executes below workflow, make note of the session ID logged to screen
  1. Kill the local worker, wait ~1 minute (default session heartbeat timeout is 20 seconds, at which point the session should be marked as 'failed')
  1. Restart the local worker. The session is recreated with the same ID and `workflow.ErrSessionFailed` is not returned.

```
 func MyWorkflow(
	ctx workflow.Context,
) (error) {
	ctx = workflow.WithActivityOptions(
		ctx,
		workflow.ActivityOptions{
			StartToCloseTimeout: 10 * time.Minute,
			HeartbeatTimeout:    1 * time.Minute,
			RetryPolicy: &temporal.RetryPolicy{
				MaximumAttempts: 1,
			},
		},
	)

	ctx, err := workflow.CreateSession(ctx, &workflow.SessionOptions{
		ExecutionTimeout: math.MaxInt64,
		CreationTimeout:  1 * time.Minute,
	})
	if err != nil {
		return errors.Wrap(err, "creating session context")
	}

	fmt.Println("SESSION ID: " + workflow.GetSessionInfo(ctx).SessionID)

	err = workflow.ExecuteActivity(
		ctx,
		MyActivity,
	).Get(ctx, nil)
	if err == nil {
		return errors.Wrap(err, "no error found")
	}
// kill the worker while first activity is in progress, then spin worker back up. this should cause second activity to execute
	err = workflow.ExecuteActivity(
		ctx,
		MyActivity,
	).Get(ctx, nil)
	if errors.Is(err, workflow.ErrSessionFailed) {
		return errors.Wrap(err, "found session failure error")
	} else {
		return errors.Wrap(err, "did not find session failure error")
	}
}

func MyActivity(ctx context.Context) error {
	time.Sleep(1 * time.Minute)
	return nil
}
```



## Specifications

  - Version: v1.13.0
  - Platform: M1 MacOS


#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2022-10-03 14:12:17.000 UTC</summary>

> Version: v1.13.0

@subhan-nadeem - We have made a lot of improvements since this version, most importantly #746. Can you upgrade and confirm that this issue persists? 

</details>

<details>
<summary><strong>subhan-nadeem</strong> commented on 2022-10-04 19:17:18.000 UTC</summary>

> > Version: v1.13.0
> 
> @subhan-nadeem - We have made a lot of improvements since this version, most importantly #746. Can you upgrade and confirm that this issue persists?

I ran the above test on v1.18.0. 

After killing the worker, the workflow event history reported an `ActivityTaskTimedOut` failure for `internalSessionCreationActivity` with message: `activity ScheduleToStart timeout
Caused By: activity Heartbeat timeout` (this seems like the intended behaviour)

After restarting the worker, the worker immediately reported a session failure, cancelled the hanging activity, and then the entire workflow (see logs below). This part I'm now confused about; is this intended behaviour? I would ideally like to catch the session failure in the workflow somehow and restart the workflow, rather than having it be cancelled.

```
12:11:34.508 Session failed                                                        log/with_logger.go:56                                                           
{
  "Attempt": 1,
  "Error": "activity error (type: internalSessionCreationActivity, scheduledEventID: 6, startedEventID: 0, identity: ): activity ScheduleToStart timeout (type: ScheduleToStart): activity Heartbeat timeout (type: Heartbeat)",
  "Namespace": "default",
  "RunID": "be99c277-f66e-4551-ad2e-829422505b09",
  "TaskQueue": "TASK_QUEUE",
  "WorkerID": "76929@LUSJCRXV6CV6K@",
  "WorkflowID": "0bb2c03d-c02a-4cec-bd95-9aeb3ef03109",
  "WorkflowType": "MyWorkflow",
  "sessionID": "cc31806d-4f10-42df-9da1-3e03078d41b6"
}

12:11:34.508 RequestCancelActivity                                                 log/with_logger.go:56                                                           
{
  "ActivityID": "11",
  "Attempt": 1,
  "Namespace": "default",
  "RunID": "be99c277-f66e-4551-ad2e-829422505b09",
  "TaskQueue": "TASK_QUEUE",
  "WorkerID": "76929@LUSJCRXV6CV6K@",
  "WorkflowID": "0bb2c03d-c02a-4cec-bd95-9aeb3ef03109",
  "WorkflowType": "Myworkflow"
}
```

</details>

<details>
<summary><strong>subhan-nadeem</strong> commented on 2022-10-04 19:40:18.000 UTC</summary>


I did notice this however on v1.18.0:

- If I kill the worker with the session and start it back up after its `HeartbeatTimeout` and before its `CreationTimeout`, the session gets recreated with the same ID without any session failures reported (this seems like a bug?)
- The activity I run reports a heartbeat error during the time the worker is down, and reschedules itself for retry on the same task queue it was scheduled on initially. Because the original session worker died, I believe that task queue disappears and the activity hangs in the "Scheduled" state forever, even after I restart the session worker

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-10-10 15:29:11.000 UTC</summary>

> After restarting the worker, the worker immediately reported a session failure, cancelled the hanging activity, and then the entire workflow (see logs below). This part I'm now confused about; is this intended behaviour? I would ideally like to catch the session failure in the workflow somehow and restart the workflow, rather than having it be cancelled.

Yes, I believe this is the intended behavior and you would setup workflow retry policy to retry the workflow since your session failed. Or you can react to the session failure explicitly.

> If I kill the worker with the session and start it back up after its HeartbeatTimeout and before its CreationTimeout, the session gets recreated with the same ID without any session failures reported (this seems like a bug?)

Is this after the session has started? Heartbeat timeout only applies after session start.

> activity hangs in the "Scheduled" state forever, even after I restart the session worker

This may be a bug. The activity should be marked cancelled. I will check on this.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-10-21 22:27:34.000 UTC</summary>

> The activity I run reports a heartbeat error during the time the worker is down, and reschedules itself for retry on the same task queue it was scheduled on initially. Because the original session worker died, I believe that task queue disappears and the activity hangs in the "Scheduled" state forever, even after I restart the session worker

What steps did you take to cause this behavior?  I was not able to reproduce this, but maybe I need to kill the worker at a specific time.

For the original issue, along with the suggestion @cretz made we have an open feature to make sessions handle worker restart smoother https://github.com/temporalio/sdk-go/issues/937.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:26:33.000 UTC</summary>

Closing due to lack of reproduction, can reopen if there is more information

</details>


---

<a id="868"></a>

### #868: panic if `Run` and `Stop` race

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/868 |
| **State** | CLOSED |
| **Author** | twmb (Travis Bischel) |
| **Created** | 2022-07-26 21:35:38.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-10 18:48:26.000 UTC |
| **Closed** | 2022-08-10 18:48:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`internal_worker.AggregatedWorker#Run` calls `aw.Start`, which asserts that the worker has not yet been stopped.

`Run` is a blocking function, it must be executed in a goroutine if the user wants to stop the worker independently. The user may then wait for an input signal and `Stop` the worker. It is possible that `Run` has not yet started and `Stop` executes before `Run`. In this tight sequence of events, the code will panic: https://github.com/temporalio/sdk-go/blob/dea0cfa509b981c05ea4e9c9ad2f841845997574/internal/internal_worker.go#L955

Since `Run` returns an error, I'd expect this code to just return `ErrClosed` or something similar.

#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2022-07-27 00:52:12.000 UTC</summary>

For users who cannot be sure that `worker.Stop()` will be called after `worker.Run()` has had enough chance to get started, they may find it better to instead use `worker.Start()` in the same goroutine they may later call `Stop()`. This is one reason we provide both `Start()` and `Run()`, for those that need to now when started (which `Run()` cannot tell them).

Having said that, yes, we can return an error for `Start()` and `Run()` if they are called on a stopped worker. Still, most people should tailor their code to avoid this possibility.

</details>

<details>
<summary><strong>twmb</strong> commented on 2022-07-27 01:05:45.000 UTC</summary>

Is the point of `Run` to not ever be shutdown? The theoretical race exists in any model of using `Run` in tandem with `Close` _unless_ some activity that is being signals readiness such that the worker can be stopped -- but this relies on input.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-07-27 15:13:15.000 UTC</summary>

Definitely can shutdown. The point of Run is as a helper for people that want to block until shutdown, but Start is better for those concerned that they need to know when start completed because they may immediately shutdown.

Yes, the race exists between Run and Stop. Users concerned about this race should use Start and Stop.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-08 13:31:30.000 UTC</summary>

Closing, in favor of using `Start`. Users should not use `Run` if they're concerned they may shutdown before running. Reopen if needed.

</details>

<details>
<summary><strong>twmb</strong> commented on 2022-08-08 14:16:18.000 UTC</summary>

At a minimum, the panic should be noted in docs on Run. The safest way to
program around the panic right now is to only allow Close to occur in an
activity that is ran at least once. This is the only way for a user to
_know_ that the temporal client has started.

Without this, users have to rely on heuristics and hope. Any proper
shutdown path that triggers a more immediate exit can panic if an interrupt
is received while things are starting up.

On Mon, Aug 8, 2022 at 07:31 Chad Retz ***@***.***> wrote:

> Closed #868 <https://github.com/temporalio/sdk-go/issues/868> as
> completed.
>
> â€”
> Reply to this email directly, view it on GitHub
> <https://github.com/temporalio/sdk-go/issues/868#event-7147135358>, or
> unsubscribe
> <https://github.com/notifications/unsubscribe-auth/AAJZIJNIYQSJTCXFCTN4Q3LVYED35ANCNFSM54XNBYJA>
> .
> You are receiving this because you authored the thread.Message ID:
> ***@***.***>
>


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-08 14:30:44.000 UTC</summary>

> At a minimum, the panic should be noted in docs on Run. 

Ok, I will add docs.

> The safest way to program around the panic right now is to only allow Close to occur in an activity that is ran at least once

The safest way is to use `Start`. Users can rely on this `Start` instead of heuristics and hope. This is a way for users to _know_ Temporal client has started. In retrospect, maybe we should have never had the `Run` helper since its utility seems confusing and is easy to build yourself using `Start`.

Just use `Start`.

Reactions: ðŸ‘ 1

</details>


---

<a id="858"></a>

### #858: Record Reason Code for RPC Failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/858 |
| **State** | CLOSED |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2022-07-19 22:02:32.000 UTC (3y 5m ago) |
| **Updated** | 2022-07-22 17:19:37.000 UTC |
| **Closed** | 2022-07-22 17:19:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We have a dashboard and metrics on RPC failures for monitoring our connectivity and requests to the Temporal Cloud service. Right now, our RPC failure percentage monitor triggers due to failures to DescribeWorkflowExecution, which we use to check if there's a running workflow.

It would be beneficial to include a reason code/error type for these RPC failures so that we're able to dive into them better.

Logs would also be helpful (or an alternative).

**Describe the solution you'd like**
Reason code to be included alongside relevant operations, such as DescribeWorkflowExecution

**Describe alternatives you've considered**
Logs, but those don't appear to be printed either.

I'm also open to altering my approach to check if a workflow is running if there's a way to do so.

**Additional context**
I use Temporal Cloud.


#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2022-07-19 22:07:09.000 UTC</summary>

> It would be beneficial to include a reason code/error type for these RPC failures so that we're able to dive into them better.

Can you clarify? Are you talking about gRPC error codes? Or something like adding custom error codes for all errors that come from the server? You can of course write a gRPC interceptor to do anything with any response, increment any metrics, etc.

> Logs would also be helpful (or an alternative).

Can you clarify here? The error is returned to you so you can log whatever you want. Or do you mean server-side logs somehow?

It might help if you could provide a specific error you are receiving and what information is not present that we could make available.

</details>

<details>
<summary><strong>sjmtan</strong> commented on 2022-07-19 22:30:36.000 UTC</summary>

Thank you for following up! I definitely omitted some additional details haha.

> Can you clarify? Are you talking about gRPC error codes? Or something like adding custom error codes for all errors that come from the server?

We use `temporal_request_failure` as the metric to monitor RPC calls to the server. I was thinking in the context of DescribeWorkflowExecution for example that a tag that could be added is the "NotFound" response. I suppose the "real" reason we have an alarm on this metric is for connectivity/service failures as opposed to business failures like "NotFound" errors.

> You can of course write a gRPC interceptor to do anything with any response, increment any metrics, etc.

I didn't think about this, good point :p 

> Can you clarify here? The error is returned to you so you can log whatever you want. Or do you mean server-side logs somehow?

SDK-side logs I suppose. Right now, the SDK logs like "Activity error" or "Workflow processing..." In the case of failing RPCs, it would be good to have context to debug that. You are probably right though that the returned error should be our responsibility to log.

------------------------------------------

Semi-related context: Since I sit on a Platforms team just managing the overall usage of Temporal as opposed to any single use case, my goals are a bit different than other teams at my company. My goal is to make sure I know when Temporal is up/down, what may have caused that, and what my team needs to do to mitigate the issue. Therefore, I don't explicitly control whether something is logged, but I still would like to determine if the issue is just business logic vs server errors (like 404 vs 500s).

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-07-20 14:28:14.000 UTC</summary>

I don't think we really want to add a tag on the existing metric that others are using and thereby increase their metric cardinality unexpectedly. Instead I think we should encourage users to intercept/record alternative metrics whichever way they prefer. That way for another user who may want to add a "target host" tag, they can, or another user may want to add a tag based on a gRPC header or context value, they can.

Same with the logging client errors. We'd prefer to leave error handling to the caller and if they want to log, no problem. Many errors are not things you'd want to log. Quite often for example, people use "describe" to determine if a workflow exists, using `NotFound` to mean "false", so they wouldn't want their logs to suddenly starting showing that.

> Therefore, I don't explicitly control whether something is logged, but I still would like to determine if the issue is just business logic vs server errors (like 404 vs 500s).

That may be better as a discussion with who does control client error handling/reporting instead of altering it for all Temporal users.

</details>

<details>
<summary><strong>sjmtan</strong> commented on 2022-07-22 06:33:50.000 UTC</summary>

> another user may want to add a tag based on a gRPC header or context value, they can.

Do you know of any example I can refer to that would intercept it for a specific call and increment metrics?

> people use "describe" to determine if a workflow exists, using `NotFound` to mean "false", so they wouldn't want their logs to suddenly starting showing that.

This is the exact problem â€” I think the problem here is that because it shows up under `temporal_request_failure`, it isn't clear what this metric should be used to represent. I could imagine one using it to determine validity of requests/connectivity to the server, but DescribeWorkflowExecution is going to always make it challenging to use that metric for that. Wouldn't this necessitate that most adopters would have to write their own interceptor for this same use case?

Nit: One oddity of DescribeWorkflowExecution is that it also doesn't have the workflow_type whereas other operations do.

I understand and respect your point though â€” any examples on how to implement this interceptor would be helpful. I would love your guidance too, if possible, on what one should use `temporal_request_failure` metric for too.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-07-22 12:55:18.000 UTC</summary>

> Do you know of any example I can refer to that would intercept it for a specific call and increment metrics?

This is a general gRPC feature. See https://github.com/grpc/grpc-go. Basically you use `grpc.WithUnaryInterceptor` (or `grpc.WithChainUnaryInterceptor` if you want to be called including automatic retries) and set it on `client.Options.ConnectionOptions.DialOptions`.

> it isn't clear what this metric should be used to represent

This metric is very clear/simple: Any gRPC failure. What may be unclear is what the user considers a failure or not. But that doesn't affect a low-level metric.

> I could imagine one using it to determine validity of requests/connectivity to the server, but DescribeWorkflowExecution is going to always make it challenging to use that metric for that. Wouldn't this necessitate that most adopters would have to write their own interceptor for this same use case?

Or they don't use the same metric handlers for clients that they are giving to workers and clients that they are expecting errors from. Or they exclude metrics with the describe `operation` tag. Or, yes, they use their metric system the same way they might with the rest of their application to record their errors that are important to them.

> I would love your guidance too, if possible, on what one should use temporal_request_failure metric for too.

I think many use it to see large changes in error reports and may only use it on clients given to workers instead of ones they are making client calls on. Many may not use it at all, preferring their own metrics for what they consider errors.

</details>

<details>
<summary><strong>sjmtan</strong> commented on 2022-07-22 17:19:37.000 UTC</summary>

Thanks!

</details>


---

<a id="778"></a>

### #778: Potential issue with activity mocking and cancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/778 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-04-13 21:54:10.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-25 17:45:18.000 UTC |
| **Closed** | 2022-04-25 17:42:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

A couple of issues have potentially been observed with the workflow/activity test env:

1. A mocked activity may not return a value if the context is cancelled
2. An activity called on the cancelled context for cleanup is immediately returning and still running the activity

Need standalone replication, then debugging/fix if applicable.

#### Comments (6)

<details>
<summary><strong>awsaba</strong> commented on 2022-04-13 23:33:04.000 UTC</summary>


> 2. An activity called on the cancelled context for cleanup is immediately returning and still running the activity

Our use case is not so much clean up as multiple steps of bookeeping. Putting a `switch` after every return to distinguish between an `ActivityError` and cancellation seems like the obvious but wrong solution since it would have to added after most activities.

The workflows and test:
```go
package cancelwork

import (
	"context"
	"fmt"
	"time"

	"go.temporal.io/sdk/activity"
	"go.temporal.io/sdk/workflow"
)

// CancelMe is long-running activity that is the most likely to be running
// when a cancel is received
func CancelMe(ctx context.Context, _ string) (string, error) {
	time.Sleep(1 * time.Second)
	return "long-running-result", nil
}

// SaveStatus just logs the status, but could do some database operation
func SaveStatus(ctx context.Context, value string) error {
	logger := activity.GetLogger(ctx)
	time.Sleep(3 * time.Second)
	logger.Error(fmt.Sprintf("from SaveStatus, value is: \"%s\"", value))
	return nil
}

// SomeWorkflow calls a long running op to do something
func SomeWorkflow(ctx workflow.Context) error {
	logger := workflow.GetLogger(ctx)
	ao := workflow.ActivityOptions{
		StartToCloseTimeout:    10 * time.Minute,
		ScheduleToCloseTimeout: 24 * time.Hour,
		WaitForCancellation:    true,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	defer func() {
		logger.Error("some other log before return")
	}()

	var val string
	err := workflow.ExecuteActivity(ctx, CancelMe, "").Get(ctx, &val)
	if err != nil {
		logger.Error(fmt.Sprintf("error in CancelMe: %s, is there a way to get val: \"%s\"", err.Error(), val))
		perr := workflow.ExecuteActivity(ctx, SaveStatus, val).Get(ctx, nil)
		if perr != nil {
			logger.Error(fmt.Sprintf("if cancelled, this should fail with cancel and not execute SaveStatus: \"%s\"", perr.Error()))
		}
		return err
	}

	return nil
}
```

```
import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/testsuite"
)

type CancelMeSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
}

func TestCancel(t *testing.T) {
	suite.Run(t, &CancelMeSuite{})
}

func (s *CancelMeSuite) TestCancel() {
	env := s.NewTestWorkflowEnvironment()
	env.OnActivity(CancelMe, mock.AnythingOfType("*context.timerCtx"), "").
		Return(func(ctx context.Context, _ string) (string, error) {
			env.CancelWorkflow()
			return "mocked-return", nil
		}).After(time.Minute)

	env.RegisterWorkflow(SomeWorkflow)
	env.RegisterActivity(CancelMe)
	env.RegisterActivity(SaveStatus)

	env.ExecuteWorkflow(SomeWorkflow)
	s.True(env.IsWorkflowCompleted())
	s.Error(env.GetWorkflowError())

	env.AssertExpectations(s.T())
        // sleep to see the output from SaveStatus
	time.Sleep(5 * time.Second)
}
```
 
The log output will log the error, and then eventually print out the log message from the 2nd activity (`SaveStatus`) called with the already cancelled context.


</details>

<details>
<summary><strong>awsaba</strong> commented on 2022-04-14 13:34:51.000 UTC</summary>

Follow up from Slack thread:

> A couple of issues have potentially been observed with the workflow/activity test env:
> 
>     1. A mocked activity may not return a value if the context is cancelled
> 
Based on Maxim's responses in the Slack thread, this is expected. For our use case that would need the returned `&val` for a cleanup activity using a disconnected context, we are going to think about how else we can structure that.

>     2. An activity called on the cancelled context for cleanup is immediately returning and still running the activity
> 
>> The call is going to fail immediately without ever generating a ScheduleActivityTask command.

I think this means that `ExecuteActivity` with a cancelled context in a workflow test should _not_ be executing the activity, WDYT?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-14 21:07:04.000 UTC</summary>

To clarify here... Based on my tests, if you don't respect cancellation in the activity, you won't return from `ExecuteActivity` here. You must heartbeat in activities to receive cancellation and you'll probably want a `HeartbeatTimeout` so you don't have to wait 15 seconds.

So basically if your activity was:

```go
func CancelMe(ctx context.Context, _ string) (string, error) {
	for {
		activity.RecordHeartbeat(ctx)
		select {
		case <-ctx.Done():
			return "long-running-result", nil
		case <-time.After(1 * time.Second):
		}
	}
}
```

Then `ExecuteActivity` would not return an error on cancel, it'd return the expected value. If you didn't have that mechanism but instead ignored the concept of heartbeat and cancellation, your activity could run until the end of time and cancellation would have no affect on it.

> I think this means that `ExecuteActivity` with a cancelled context in a workflow test should _not_ be executing the activity, WDYT?

Agreed. I will open a PR for this.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-18 17:04:32.000 UTC</summary>

I have opened #780 to make sure activities invoked with a cancelled context are not started.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-25 17:42:55.000 UTC</summary>

We have merged #780 which has some fixes for this area. The next release may be in ~2 weeks. I am closing now, but reopen or comment if you think the PR doesn't address any specific activity + cancellation + test suite issues.

</details>

<details>
<summary><strong>awsaba</strong> commented on 2022-04-25 17:45:18.000 UTC</summary>

@cretz Thanks!

Reactions: ðŸ‘ 1

</details>


---

<a id="736"></a>

### #736: Cannot use SignalWithStartWorkflow in tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/736 |
| **State** | CLOSED |
| **Author** | nicolaferraro (Nicola Ferraro) |
| **Created** | 2022-02-23 08:09:51.000 UTC (3y 10m ago) |
| **Updated** | 2022-03-01 14:40:23.000 UTC |
| **Closed** | 2022-03-01 14:40:23.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

Trying to test a scenario that uses "SignalWithStartWorkflow" available in the client, I've found out there's no equivalent method in the testsuite, neither that function is available to workflows for sending signals to other workflows in standby.

**Describe the solution you'd like**
SignalWithStartWorkflow should be included in the testsuite. Ideally I should able to create a standard client for a unit test environment.

**Describe alternatives you've considered**
Doing integration tests instead of unit tests.


#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2022-02-23 14:49:32.000 UTC</summary>

Sending signals is done with `testsuite.TestWorkflowEnvironment.RegisterDelayedCallback`. From the docs there:

> Use 0 delayDuration to send a signal to simulate SignalWithStart.

This is not clear from our public docs, so I have opened https://github.com/temporalio/documentation/issues/939.

</details>

<details>
<summary><strong>nicolaferraro</strong> commented on 2022-02-23 15:30:59.000 UTC</summary>

> Sending signals is done with `testsuite.TestWorkflowEnvironment.RegisterDelayedCallback`. From the docs there:
> 
> > Use 0 delayDuration to send a signal to simulate SignalWithStart.
> 
> This is not clear from our public docs, so I have opened [temporalio/documentation#939](https://github.com/temporalio/documentation/issues/939).

Thanks! Yeah, I've seen the comment in the source code. But it seems it cannot pass data to the workflow being started, right?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-23 16:18:26.000 UTC</summary>

> But it seems it cannot pass data to the workflow being started, right?

Can your clarify what you mean by passing data? You can of course pass params to the workflow and of course pass params to the signal. (also, if easier, feel free to join us in https://temporal.io/slack or https://community.temporal.io).

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-03-01 14:40:23.000 UTC</summary>

Closing issue. Feel free to respond with additional questions and/or reopen if you feel the issue persists.

</details>


---

<a id="679"></a>

### #679: GetWorkflowError() does not yield stack trace for a panic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/679 |
| **State** | CLOSED |
| **Author** | modernplumbing |
| **Created** | 2021-12-27 21:31:02.000 UTC (4 years ago) |
| **Updated** | 2023-02-24 13:43:42.000 UTC |
| **Closed** | 2023-02-24 13:43:42.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 2 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

In a test like the following

```
type UnitTestSuite struct {
	suite.Suite # From github.com/stretchr/testify/suite | v1.7.0
	testsuite.WorkflowTestSuite # From go.temporal.io/sdk/testsuite | v1.12.0
	workflowEnvironment *testsuite.TestWorkflowEnvironment 
}

func (s *UnitTestSuite) Test_MyWorkflow() {
	s.workflowEnvironment.ExecuteWorkflow(MyWorkflow(), "test_success")
	s.NoError(s.workflowEnvironment.GetWorkflowError())
}
```

I would get output like the following: 
```
--- FAIL: TestUnitTestSuite (0.01s)
    --- FAIL: TestUnitTestSuite/Test_MyWorkflow (0.00s)
        myTestFile_test.go:84:  
        Error Trace:    myTestFile_test.go:84
        Error:          Received unexpected error:
                   workflow execution error (type: MyWorkflowType, workflowID: default-test-workflow-id, runID: default-test-run-id): runtime error: invalid memory address or nil pointer dereference
```
The way to print the stack trace is by doing the following `s.workflowEnvironment.GetWorkflowError().(*temporal.WorkflowExecutionError).Unwrap().(*temporal.PanicError).StackTrace()` which is undocumented and took a lot of searching the repo for potential solutions.

**Describe the solution you'd like**
Something like 
```
func (e *PanicError) StackTrace() string
```
but for Workflow errors instead of just Activity errors would be great. `s.workflowEnvironment.GetWorkflowError().(*temporal.WorkflowExecutionError).Unwrap().(*temporal.PanicError).StackTrace()` is not great UX.


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-01-03 14:58:19.000 UTC</summary>

Can you use `errors.As` instead, e.g.:

```
var panicErr *temporal.PanicError
if errors.As(err, &panicErr) {
  fmt.Printf("Got panic error, trace: %v", panicErr.StackTrace())
}
```

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>BruceShenC</strong> commented on 2023-02-24 01:43:41.000 UTC</summary>

> > Can you use `errors.As` instead, e.g.:

> 
> ```
> var panicErr *temporal.PanicError
> if errors.As(err, &panicErr) {
>   fmt.Printf("Got panic error, trace: %v", panicErr.StackTrace())
> }
> ```
For me , it works. Thanks a lot!

```
var panicErr *temporal.PanicError
if errors.As(s.env.GetWorkflowError(), &panicErr) {
        fmt.Printf("Got panic error, trace: %v", panicErr.StackTrace())
}
```



Reactions: ðŸ‘ 3

</details>


---

<a id="678"></a>

### #678: Worker panics while executing activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/678 |
| **State** | CLOSED |
| **Author** | tminusplus (Travis) |
| **Created** | 2021-12-22 23:11:21.000 UTC (4 years ago) |
| **Updated** | 2022-06-01 13:31:11.000 UTC |
| **Closed** | 2022-06-01 13:31:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

No panic should occur while the worker is executing an activity.

## Actual Behavior

Worker panics intermittently while executing an activity.

Stack Trace:
```
external/io_temporal_go_sdk/internal/internal_workflow.go:499 +0xd2
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1({0x2745f38, 0xc000439bc0})
	external/io_temporal_go_sdk/internal/internal_worker.go:741 +0x292
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0xc0034d6580, {0x2745de8, 0xc0034d6600}, 0x25)
	external/io_temporal_go_sdk/internal/workflow.go:415 +0x166
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0xc00b7ab9f0, {0x2745de8, 0xc0034d6600}, 0xc0045cb7e8)
	external/io_temporal_go_sdk/internal/internal_worker.go:1512 +0x136
go.temporal.io/sdk/internal.executeFunction({0x11802e0, 0xc0003f1ee0}, {0xc001471e08, 0x1, 0xc001420000})
	GOROOT/src/reflect/value.go:339 +0xc5
reflect.Value.Call({0x11802e0, 0xc0003f1ee0, 0x403c6c}, {0xc0045cb800, 0x1, 0x1})
	GOROOT/src/reflect/value.go:543 +0x814
... service backtrace for workflow ...
go.temporal.io/sdk/workflow.ExecuteActivity(...)
	external/io_temporal_go_sdk/internal/workflow.go:455 +0x185
go.temporal.io/sdk/internal.ExecuteActivity({0x2745f38, 0xc000439d70}, {0x11cb080, 0x254c158}, {0xc000474fc0, 0x1, 0x1})
	external/io_temporal_go_sdk/internal/workflow.go:511 +0x782
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity(0xc00b7ab9f0, {0x2745f38, 0xc000439dd0}, {0x29d3360, 0x6}, {0xc000474fc0, 0x1, 0x1})
	external/io_temporal_go_sdk/internal/internal_event_handlers.go:463 +0x545
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).ExecuteActivity(0xc000100e00, {{{0x0, 0x0}, {0xc00004bb00, 0xf}, 0x0, 0x0, 0x1a3185c5000, 0x0, 0x0, ...}, ...}, ...)
	external/io_temporal_go_sdk/internal/internal_event_handlers.go:452
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GenerateSequence(...)
	external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:833
go.temporal.io/sdk/internal.(*commandsHelper).getNextID(...)
```

## Steps to Reproduce the Problem

We haven't been able to reproduce this, as it infrequently occurs. The workflow we are running is on a cron schedule and I've edited one of the example workflows to match its behavior:
```
func SampleBranchWorkflow(ctx workflow.Context, totalBranches int) (result []string, err error) {
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

        var futures []workflow.Future
        for batch := 0; batch < 10; batch++ {
	    for i := 1; i <= totalBranches; i++ {
		future := workflow.ExecuteActivity(ctx, SampleActivity, activityInput)
		futures = append(futures, future)
	    }
 
            // Block until this batch finishes processing
            for _, future := range futures {
		err = future.Get(ctx, nil)
		if err != nil {
			return
		}
	    }
        }

	// One last sweep to ensure all scheduled activities are complete
	for _, future := range futures {
            err = future.Get(ctx, nil)
	    if err != nil {
		return
	    }
	}
}
```

The activity we run downloads an archive, processes files within it, and then uploads the result.

I am keeping an eye on our workers for this, to see if I can provide more information and figure out steps to reproduce the issue. 

I will also make the recommended changes in https://github.com/temporalio/sdk-go/issues/475 to only check the futures once, and see if the issue still occurs like that.

## Specifications

  - Version: SDK v1.11.1 and Temporal v1.12.3
  - Platform: Linux


#### Comments (6)

<details>
<summary><strong>tminusplus</strong> commented on 2021-12-22 23:31:48.000 UTC</summary>

We had this happen on another workflow which has a cron schedule. This one basically the sample cron workflow, and the activity uses a heartbeat:
```
// SampleCronWorkflow executes on the given schedule
// The schedule is provided when starting the Workflow
func SampleCronWorkflow(ctx workflow.Context) (*CronResult, error) {

	workflow.GetLogger(ctx).Info("Cron workflow started.", "StartTime", workflow.Now(ctx))

	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
	}
	ctx1 := workflow.WithActivityOptions(ctx, ao)

	// Start from 0 for first cron job
	lastRunTime := time.Time{}
	// Check to see if there was a previous cron job
	if workflow.HasLastCompletionResult(ctx) {
		var lastResult CronResult
		if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {
			lastRunTime = lastResult.RunTime
		}
	}
	thisRunTime := workflow.Now(ctx)

	err := workflow.ExecuteActivity(ctx1, DoSomething, lastRunTime, thisRunTime).Get(ctx, nil)
	if err != nil {
		// Cron job failed
		// Next cron will still be scheduled by the Server
		workflow.GetLogger(ctx).Error("Cron job failed.", "Error", err)
		return nil, err
	}

	return &CronResult{RunTime: thisRunTime}, nil
}
```

The error logs are as follows, had to redact sensitive information but the workflow IDs are the same for all the log lines:
```
18:22:33 DEBUG ExecuteActivity â€¦redactedâ€¦ RunID f4c08e61-65c8-4e9a-88a4-3300bed6cafd Attempt 1 â€¦redactedâ€¦
18:15:06 INFO  Task processing failed with error WorkerType WorkflowWorker Error Workflow executionsRow not found.  â€¦redactedâ€¦ RunId: 2c879b3e-45bd-4532-9542-1fb888677a9b
18:15:06 WARN  Failed to process workflow task. â€¦redactedâ€¦ RunID f4c08e61-65c8-4e9a-88a4-3300bed6cafd Attempt 1 Error Attempt to generate a command before processing WorkflowTaskStarted event
	external/io_temporal_go_sdk/internal/internal_workflow.go:499 +0xd2
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1({0x276a398, 0xc0004a18f0})
	external/io_temporal_go_sdk/internal/internal_worker.go:741 +0x292
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0xc000be4580, {0x276a248, 0xc000be4600}, 0x25)
	external/io_temporal_go_sdk/internal/workflow.go:415 +0x166
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0xc001373ea0, {0x276a248, 0xc000be4600}, 0xc0012fbb48)
	external/io_temporal_go_sdk/internal/internal_worker.go:1512 +0x136
go.temporal.io/sdk/internal.executeFunction({0x11c8fe0, 0xc0014ef430}, {0xc001088e08, 0x1, 0xc00005e400})
	GOROOT/src/reflect/value.go:339 +0xc5
reflect.Value.Call({0x11c8fe0, 0xc0014ef430, 0x403c6c}, {0xc0012fbb60, 0x1, 0x1})
	GOROOT/src/reflect/value.go:543 +0x814
reflect.Value.call({0x11c8fe0, 0xc0014ef430, 0x7f15f77fb5b8}, {0x13e726c, 0x4}, {0xc0012fbb60, 0x1, 0xa})
... service backtrace for workflow ...
	external/io_temporal_go_sdk/workflow/workflow.go:113
go.temporal.io/sdk/workflow.ExecuteActivity(...)
	external/io_temporal_go_sdk/internal/workflow.go:455 +0x185
go.temporal.io/sdk/internal.ExecuteActivity({0x276a398, 0xc0004a19e0}, {0x11ea880, 0xc000ba46d0}, {0xc000ba46e0, 0x1, 0x1})
	external/io_temporal_go_sdk/internal/workflow.go:511 +0x782
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity(0xc001373ea0, {0x276a398, 0xc0004a1a70}, {0x297b409, 0x11}, {0xc000ba46e0, 0x1, 0x1})
	external/io_temporal_go_sdk/internal/internal_event_handlers.go:463 +0x545
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).ExecuteActivity(0xc000d07600, {{{0x0, 0x0}, {0xc0000b99a0, 0xf}, 0x0, 0x0, 0x6fc23ac00, 0x2540be400, 0x0, ...}, ...}, ...)
	external/io_temporal_go_sdk/internal/internal_event_handlers.go:452
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GenerateSequence(...)
	external/io_temporal_go_sdk/internal/internal_decision_state_machine.go:833
go.temporal.io/sdk/internal.(*commandsHelper).getNextID(...)
```

The run 2c879b3e-45bd-4532-9542-1fb888677a9b ID does not exist in our logs and within the namespace history, the only mention of it anywhere is in that error message.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-30 20:19:17.000 UTC</summary>

Sorry it took me a bit to get to this.

Do you do anything besides heartbeat to affect the workflow externally? I know you mentioned no queries, but maybe signals? I wonder if there is an activity cancel or a heartbeat or something that is trying to run on the newly scheduled workflow before it starts.

I do think this may be related #475 (which is pending https://github.com/temporalio/temporal/issues/2300) but may not be specifically concerning queries. Basically it seems something is trying to be processed on the newly-scheduled-but-not-yet-started workflow causing this issue. Have you been able to somewhat-reliably replicate yet? I will attempt to do so as well.

</details>

<details>
<summary><strong>tminusplus</strong> commented on 2022-02-04 20:26:51.000 UTC</summary>

@cretz likewise, apologies on the delayed response. 

We do not have any queries or signals running on the workflow, other than the web UI.

We updated our Temporal server from v1.12.3 to v1.14.2 a month ago and haven't seen the issue again. I looked through the release notes for the server and was unable to find anything that sounds directly related to this. Will keep an eye on our logs and see if it appears again.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-04 21:53:48.000 UTC</summary>

:+1: I will leave this open for a bit to see if you can replicate.

</details>

<details>
<summary><strong>tminusplus</strong> commented on 2022-02-07 21:46:33.000 UTC</summary>

Awesome thanks, will continue slow rolling this. if you ever want to clear this out of the issue board no worries, I can open a new one too and refer back to this. 

Also I confirmed on another server that this occurs on server v1.13.1. So perhaps something in the upgrade from v1.13 to v1.14 either made this less common or fixed it.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-01 13:31:11.000 UTC</summary>

Clearing out to defer to #475 

</details>


---

<a id="570"></a>

### #570: Temporal Client send signal to different namespace

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/570 |
| **State** | CLOSED |
| **Author** | elb3k (Elbek Khoshimjonov) |
| **Created** | 2021-10-02 12:03:36.000 UTC (4y 3m ago) |
| **Updated** | 2021-12-17 07:27:30.000 UTC |
| **Closed** | 2021-12-17 07:27:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I have to send signal to different namespaces, but temporal client only allows to send signal to workflows in same namespace

**Describe the solution you'd like**
[SignalWorkflow](https://github.com/temporalio/sdk-go/blob/6580cbe0aa41a8b515791f95c2c15bb37db1dab1/internal/internal_workflow_client.go#L341-L365) just passes the namespace of client. May be we can encode the namespace to context (WtihWorkflowNamespace, just like workflow version), and use namespace in SignalWorkflow function (if exists).


**Describe alternatives you've considered**
Current solution to send signal to different namespace using custom workflow, where I send the signal to different namespace.

**Additional context**
It is possible to send the signal to different namespaces within workflow, using [WithWorkflowNamespace](https://github.com/temporalio/sdk-go/blob/6580cbe0aa41a8b515791f95c2c15bb37db1dab1/workflow/workflow_options.go#L39-L42). We could have same functionality for client.


#### Comments (6)

<details>
<summary><strong>cretz</strong> commented on 2021-10-12 13:54:11.000 UTC</summary>

The current suggested approach is to create a separate client for the separate namespace.

This becomes a larger question of whether a client should be able to make calls to multiple namespaces. Right now they can't and it is fairly harmless to create a client per namespace in most namespace scenarios. Is creating separate clients per namespace a concern for your use case?

</details>

<details>
<summary><strong>elb3k</strong> commented on 2021-10-12 17:26:27.000 UTC</summary>

My use case was for the service, which sends back signal to given input (with namespace, workflowID) .
I would have on client with default namespace, and send signal according to input namespace.

</details>

<details>
<summary><strong>elb3k</strong> commented on 2021-10-12 17:27:03.000 UTC</summary>

One simple function to change namespace property of `Client` would be just fine too.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:27:56.000 UTC</summary>

With #641, you will be able to use the gRPC service directly to send signals in any way to any namespace. I will update when implemented.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 21:18:18.000 UTC</summary>

This has been implemented. You can now use the gRPC service directly to make whatever calls you want. Does this solve your need?

</details>

<details>
<summary><strong>elb3k</strong> commented on 2021-12-17 07:27:30.000 UTC</summary>

Yes @cretz.

</details>


---

<a id="404"></a>

### #404: Setting deadlock detection timeouts?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/404 |
| **State** | CLOSED |
| **Author** | shaunco (Shaun) |
| **Created** | 2021-04-12 16:37:39.000 UTC (4y 9m ago) |
| **Updated** | 2021-06-23 04:21:56.000 UTC |
| **Closed** | 2021-06-23 04:21:56.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 2 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

**Is your feature request related to a problem? Please describe.**
We had code that was calling `rsa.GenerateKey(rand.Reader, 4096)` in a `workflow.SideEffect` call. Generating a 4096 RSA key sometimes takes >1 second, so the deadlock detection kills the workflow and starts it over.

**Describe the solution you'd like**
It would be great to have a few functions to give hints to the deadlock detection so that I could do something like this before calling an API that takes a bit longer than a second:
```go
  ctx.SetDeadlockTimeout(seconds)
  defer ctx.ResetDeadlockTimeout()
  rsa.GenerateKey(rand.Reader, 4096)
```

Similarly, something like `ctx.Alive()` might be helpful in loops.

**Describe alternatives you've considered**
Currently we just use TEMPORAL_DEBUG for the service that makes this `rsa.GenerateKey` call... obviously this is not ideal.



#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2021-04-13 23:53:39.000 UTC</summary>

I would recommend using local activities for such expensive operations.

</details>

<details>
<summary><strong>shaunco</strong> commented on 2021-04-24 23:21:25.000 UTC</summary>

> I would recommend using local activities for such expensive operations.

Even in a local activity, the `GenerateKey` function takes long enough to trigger the deadlock detection. We still need a way to give Temporal a hint to extend the deadlock timeout in some scenarios.

</details>


---

<a id="284"></a>

### #284: Add the ability to register local activities only

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/284 |
| **State** | CLOSED |
| **Author** | wolfy-j (Anton Tsitou) |
| **Created** | 2020-11-09 16:52:42.000 UTC (5y 2m ago) |
| **Updated** | 2020-12-22 04:01:43.000 UTC |
| **Closed** | 2020-12-22 04:01:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Sometimes it makes sense to isolate workflow workers from the rest of business logic. However, local activites do not fit this mix. It will be useful to be able to register local activities only without enabling task queue activity consumption.

**Describe the solution you'd like**
It will be useful to be able to register local activities only without enabling task queue activity consumption.

**Describe alternatives you've considered**
none


#### Comments (6)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-11 04:11:37.000 UTC</summary>

From what I understand your concern is that in order to invoke a local activity you have to register activity with the worker and that would result in worker polling on activity task queue? What problems do you see with the current approach? Can you provide a use case where existing behavior would be problematic?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-11-11 04:23:00.000 UTC</summary>

@vitarb It is needed for PHP SDK worker.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2020-11-11 04:35:49.000 UTC</summary>

Makes sense, we can add an option, something like `worker.Options.DisableActivityPoller` which, if set, would override our default logic and disable activity poller.

</details>

<details>
<summary><strong>wolfy-j</strong> commented on 2020-11-11 06:40:49.000 UTC</summary>

That will work!

</details>

<details>
<summary><strong>vitarb</strong> commented on 2020-11-12 03:55:04.000 UTC</summary>

We should be able to do this in the next few weeks, stay tuned.

Reactions: â¤ï¸ 2

</details>

<details>
<summary><strong>vitarb</strong> commented on 2020-12-22 04:01:43.000 UTC</summary>

Addressed in both go and java SDKs, new `LocalActivityWorkerOnly` worker option is available, which if set to true would turn off regular activity polling.

</details>


---

<a id="2109"></a>

### #2109: MutableSideEffect in test framework ignores cmp function

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2109 |
| **State** | OPEN |
| **Author** | no-life |
| **Created** | 2025-11-13 17:35:49.000 UTC (1 months ago) |
| **Updated** | 2025-11-13 20:20:54.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 1 |
| **Priority Score** | 5 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

In this line cmp is ignored
https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_testsuite.go#L2875

## Expected Behavior
In test framework MutableSideEffect with cmp `func(a, b any) bool { return true }` should not update value, even if value is different by any means.

## Actual Behavior
In test framework MutableSideEffect with cmp `func(a, b any) bool { return true }` updates value

## Steps to Reproduce the Problem

run
```
func WF(ctx workflow.Context) error {
	var out1 bool
	err := workflow.MutableSideEffect(ctx, "key",
		func(workflow.Context) any { return true }, 
		nil,
	).Get(&out1)
	if err != nil {
		panic(err)
	}

	var out2 bool
	err = workflow.MutableSideEffect(ctx, "key",
		func(workflow.Context) any { return false },
		func(a, b any) bool { return true },
	).Get(&out2)
	if err != nil {
		panic(err)
	}
	
	if out1 != out2 {
		return fmt.Errorf("side effect values are inconsistent: %v vs %v", out1, out2)
	}

	return nil
}
```
in test framework, error happens

## Specifications

  - Version: 1.26.0

upd: fixed typo "you are putting the result into out1, which I believe should be out2"

#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-11-13 20:12:06.000 UTC</summary>

Thanks for the bug report, this is indeed something that wasn't implemented properly in the workflow testsuite. 

A small note, from your second call to `MutableSideEffect`, you are putting the result into `out1`, which I believe should be`out2`. Guesing it's a copy-paste error. 

</details>


---

<a id="1935"></a>

### #1935: client.Dial HostPort does not resolve Docker container DNS names

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1935 |
| **State** | CLOSED |
| **Author** | aentwist (Anderson Entwistle) |
| **Created** | 2025-04-26 23:38:52.000 UTC (8 months ago) |
| **Updated** | 2025-04-29 15:27:47.000 UTC |
| **Closed** | 2025-04-29 15:27:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

```go
c, err := client.Dial(client.Options{
    HostPort: "temporal:7233",
})
```

## Actual Behavior

`context deadline exceeded`

## Workaround

-> `nslookup temporal`
-> gives IP
-> using that IP directly works

```go
c, err := client.Dial(client.Options{
    HostPort: "172.21.0.4:7233",
})
```

## Steps to Reproduce the Problem

  1. Create Docker network `docker network create temporal-network`
  1. Spin up official Docker Compose with `driver: bridge` changed to `external: true`. `docker compose -f docker-compose.yml up -d`
  1. Create a minimal Go app that connects
  1. Build that using the Go Docker image
  1. Put it on the same network as the official Docker Compose example
  1. `docker compose -f compose-app.yml up --build`

<details>
<summary>Go app</summary>
<pre>
package main

import (
	"log"

	"go.temporal.io/sdk/client"
)

func main() {
	c, err := client.Dial(client.Options{
		// HostPort: client.DefaultHostPort,
		HostPort: "temporal:7233",
		// HostPort: "172.21.0.4:7233",
	})
	if err != nil {
		log.Fatalf("Unable to create Temporal client: %v", err)
	}
	defer c.Close()

	log.Println("Successfully connected to Temporal server")
}

</pre>
</details>

<details>
<summary>Dockerfile</summary>
<pre>
FROM golang:1.24

WORKDIR /usr/src/app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -v -o /usr/local/bin/app ./...

\# If you are spinning all up at once, app needs to wait
\# CMD sleep 15 && app
\# Otherwise this
CMD ["app"]
</pre>
</details>

<details>
<summary>Docker Compose for the app compose-app.yml</summary>
Put the app on the same network as the official example.
<pre>
services:
  app:
    build: .
    # network_mode: host
    networks:
      - temporal-network
networks:
  temporal-network:
    external: true
    name: temporal-network
</pre>
</details>

## Specifications

  - Version: 1.27.2
  - Platform: linux/amd64, linux/arm64

## See Also

- https://community.temporal.io/t/does-this-project-run-can-i-get-paid-support-to-set-up-self-hosted/17240
- https://github.com/temporalio/docker-compose/issues/225


#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-27 01:10:38.000 UTC</summary>

First I would recommend updating your SDK `v1.27.2` is very out of date. The latest is [v1.34.0](https://github.com/temporalio/sdk-go/releases/tag/v1.34.0)

`client.Dial` passes `HostPort` directly to [grpc-go](https://github.com/grpc/grpc-go) which follows [grpcs](https://grpc.io/docs/guides/custom-name-resolution/) , the standard grpc namespace resolution rules . To bypass name resolution you can set `passthrough:target` per the `grpc-go` docs

</details>

<details>
<summary><strong>aentwist</strong> commented on 2025-04-27 03:14:52.000 UTC</summary>

Yeah so that's actually the Temporal version, my bad. I'm on SDK 1.33.1+.

---

I'm not sure how I would know to go read that docs page, but let's assume I knew.

> When making a request with a gRPC client, by default, DNS name resolution is used.

OK, it should be using DNS, great.

> Name resolution is often thought to be the same as [DNS](https://www.ietf.org/rfc/rfc1035.txt). In practice however, DNS is usually augmented with extensions or completely replaced to enable name resolution.

Hm. Maybe this tells us that it won't work as expected? Since Docker could easily be 'augmenting it with an extension' or something.

---

All I'm saying is, and here is my official workaround using [`net.LookupHost`](https://pkg.go.dev/net#LookupHost),

This doesn't work

```go
c, err := client.Dial(client.Options{
	HostPort: "temporal:7233",
})
```

But this works

```go
addrs, err := net.LookupHost("temporal")
if err != nil || len(addrs) != 1 {
	log.Fatal("Unable to lookup temporal address")
}
c, err := client.Dial(client.Options{
	HostPort: addrs[0] + ":7233",
})
```

And figuring that out cost me a LOT of time.

</details>

<details>
<summary><strong>aentwist</strong> commented on 2025-04-27 03:25:59.000 UTC</summary>

OK it seems you're correct that buried in the grpc-go docs there is a passthrough option, so this is what it should look like instead:

```go
c, err := client.Dial(client.Options{
	HostPort: "passthrough:///temporal:7233",
})
```

I have no idea how I would have ever gotten there on my own. Thanks.

This cost me such an absurd amount of resources and made me hate Temporal so much. Is there ANYWHERE in the docs or API docs that says 'resolved using grpc-go'?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-27 06:48:27.000 UTC</summary>

>This cost me such an absurd amount of resources and made me hate Temporal so much. Is there ANYWHERE in the docs or API docs that says 'resolved using grpc-go'?

I am sorry you had a bad experience here. Temporal uses grpc as a transport between server and client. The Go SDK uses `grpc-go` for this, that is a dependency of the Go SDK. The documentation for [Hostport](https://github.com/temporalio/sdk-go/blob/ee78d25974654b5132b08cb466a8d776d99d64a9/internal/client.go#L479) specifies it is a `grpc` address and that `dns` is the resolver. It also calls out specifying a customer `grpc-go` resolver. A quick look at the grpc go source code suggest it is using `net` for its DNS lookup as well.

We could add a note here calling out that `pasthrough:///` is a valid option as well.

</details>

<details>
<summary><strong>aentwist</strong> commented on 2025-04-27 23:40:35.000 UTC</summary>

Well, you're right. Probably I saw that not knowing gRPC

https://github.com/temporalio/sdk-go/blob/ee78d25974654b5132b08cb466a8d776d99d64a9/internal/client.go#L469-L473

and literally thought 'I don't need to do anything custom, no custom resolvers, there is nothing unusual or custom going on here'. I suppose this is fine. If anything, I'd really like more documentation on the Docker side, probably. Docker is a common use case that is worthy of a special note, but Go doesn't deserve to cover it. It's gotta be the same in the other SDKs too right? So I think it is fine to close this issue.

Sometimes in software things just have it out for you. In reflection I don't think I could have done anything differently to avoid what happened. It just kinda majorly sucked. That's ok. Huge props to you and forum member [tihomir](https://community.temporal.io/u/tihomir) for the excellent assistance with this.

Note that this converged with the CLI being bugged to absolutely screw me over. I went to the CLI pretty fast to debug the connection, but when the debug tool is bugged, it's bad news. Without that happening this would have taken me 1/4 the time, but with both converging at once, I was pretty doomed.

</details>


---

<a id="1805"></a>

### #1805: Current "latest" sdk-go incompatible with just-released api-go v1.44.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1805 |
| **State** | CLOSED |
| **Author** | dotwaffle (Matthew Walster) |
| **Created** | 2025-02-07 08:06:03.000 UTC (11 months ago) |
| **Updated** | 2025-08-25 15:12:00.000 UTC |
| **Closed** | 2025-08-25 15:11:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

In the last few hours, https://github.com/temporalio/api-go had a new release: v1.44.0

The current released version of sdk-go, v1.32.1, does not work with it. Specifically, the removal of "ById" of the `*ByIdRequest` and `*ByIdResponse` within [this commit](https://github.com/temporalio/api-go/commit/c83bb3e830970bec60f0a8b89b0d4137b0c6a411) and the file `workflowservice/v1/request_response.go-helpers.pb.go`.


## Expected Behavior
Existing code compiles after upgrading all libraries to the latest versions.

## Actual Behavior
Compilation failures due to missing symbols, which have been renamed.


## Steps to Reproduce the Problem

  1. Use sdk-go v1.32.1 and api-go v1.43.2, in my case I was reading history events.
  1. Upgrade to api-go@latest (i.e. v1.44.0).
  1. Code no longer compiles.

## Specifications

  - Version: sdk-go v1.32.1 (latest) + api-go v1.44.0 (latest)
  - Platform: all


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2025-02-07 13:43:50.000 UTC</summary>

I am struggling to replicate this. I have a `go.mod` with:

```
	go.temporal.io/api v1.44.0
	go.temporal.io/sdk v1.32.1
```

And I am able to compile a simple Go SDK app. The Go SDK doesn't use the API that was removed/changed. Can you give an example of code/project unable to compile with just these dependencies? Can you show the exact compilation error?

</details>

<details>
<summary><strong>dotwaffle</strong> commented on 2025-02-10 05:10:07.000 UTC</summary>

Sorry, I think I was confused, it's not sdk-go, it's go.temporal.io/server/API

The errors I'm seeing are about v1.PauseActivityByIdRequest etc, and the path shown with "go mod why" is:

```
go.temporal.io/server/common/authorisation
go.temporal.io/server/common/namespace
go.temporal.io/server/common
go.temporal.io/server/api/historyservice/v1
```

If I move go.temporal.io/API from v1.44.0 to v1.43.2 then the error goes away.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-02-10 14:48:06.000 UTC</summary>

If you are using the server programmatically as a library, you must have the _exact_ versions of SDK and API that are in the server's `go.mod`. The server is a very large application and including it programmatically has a few more limitations. You cannot upgrade the server's API beyond the version it is written for. We generally discourage using the server as a library, but if you must, we recommend not doing it in the same project where the rest of your Temporal SDK work is done (e.g. if you use an auth plugin or something, don't put that alongside your workflows).

</details>

<details>
<summary><strong>dotwaffle</strong> commented on 2025-02-10 15:29:27.000 UTC</summary>

It's related to the OIDC code for the codecserver in your sample, at: https://github.com/temporalio/samples-go/blob/main/codec-server/codec-server/oidc.go

Is there an alternative method I can use to provide the same functionality?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-25 15:11:47.000 UTC</summary>

> Is there an alternative method I can use to provide the same functionality?

You would need to implement your OIDC logic without using the Temporal Server, or reuse some OSS solution.

</details>


---

<a id="1691"></a>

### #1691: Auto propagate context value to activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1691 |
| **State** | CLOSED |
| **Author** | afifurrohman-id (Afif) |
| **Created** | 2024-10-28 04:48:36.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-29 02:58:33.000 UTC |
| **Closed** | 2024-10-29 02:58:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
we really need this feature since trace, logs, request data etc.. in our app is passing through context, change this behaviour is really error prone and breaking changes,
because some context key are dynamic based on requests.

**Describe the solution you'd like**
auto propagate each value in parent std lib context.

**Describe alternatives you've considered**
none

**Additional context**
none


#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-28 04:53:08.000 UTC</summary>

Can you please clarify what the feature request here? What do you mean by  "auto propagate each value in parent std lib context."? 

</details>

<details>
<summary><strong>afifurrohman-id</strong> commented on 2024-10-28 06:41:03.000 UTC</summary>

> Can you please clarify what the feature request here? What do you mean by "auto propagate each value in parent std lib context."?

i mean:
```go
func main() {
  ctx := context.WithValue(context.Background(), "key", "value")
  c, _ := client.Dial(client.Options{})

  c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: "FOO"}, workflow)

}
func workflow(ctx workflow.Context) error {
 
  workflow.ExecuteActivity(ctx, activity)
}

func activity(ctx context.Context) error {
 v := ctx.Value("key") // should return "value"
}
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-28 15:52:25.000 UTC</summary>

Context proportion is supported, please have a look at our samples https://github.com/temporalio/samples-go/tree/main/ctxpropagation and accompanying docs https://docs.temporal.io/develop/go/observability#tracing-and-context-propogation

</details>

<details>
<summary><strong>afifurrohman-id</strong> commented on 2024-10-29 02:32:51.000 UTC</summary>

> Context proportion is supported, please have a look at our samples https://github.com/temporalio/samples-go/tree/main/ctxpropagation and accompanying docs https://docs.temporal.io/develop/go/observability#tracing-and-context-propogation

yes, but still we need manually defined key and type of value.

but, in our usecase we have dynamic key based on request and we can't change the app behaviour to not use context.

why not automatically have each `context.Value()` when invoke activity? does the workflow use `context.Context` too right?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-29 02:58:33.000 UTC</summary>

Yes you would need to manually define each key and make sure the value is serializable. Defining each key is Go language requirement there is nothing the Temporal SDK can do about that. Go's `context` package chose not to expose a way to iterate through all values.

workflows do not use `context.Context`, they use `workflow.Context` 

Marking as closed as there is nothing more in the SDK we can add.

</details>


---

<a id="1351"></a>

### #1351: Support interceptor on WorkflowRun.Get

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1351 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-14 01:14:54.000 UTC (1y 12m ago) |
| **Updated** | 2024-01-16 15:28:06.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
When using a context aware data converter that uses the workflow ID (or any workflow options), the workflows result will be encoded using the workflow ID. When reading the workflow result the data converter must also have the workflow ID passed. With every other client call to a workflow execution this can be set in the interceptor, except for getting the workflow result because there is no interceptor.

**Describe the solution you'd like**
Support interceptor on `WorkflowRun.Get`

Java SDK Also supports it:

https://javadoc.io/static/io.temporal/temporal-sdk/1.22.3/io/temporal/common/interceptors/WorkflowClientCallsInterceptor.html#getResult(io.temporal.common.interceptors.WorkflowClientCallsInterceptor.GetResultInput)


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-14 01:15:33.000 UTC</summary>

related: https://github.com/temporalio/sdk-go/issues/1349

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-16 14:02:39.000 UTC</summary>

Note, many other SDKs (TS, Python, and .NET) do not support intercepting result fetching. Java is unique here. Most, including Go, support wrapping the result from start to customize result fetching. But as for manually getting a workflow run/handle, only Java seems to be able to do this. If we agree we need this functionality generally we can create a general purpose feature for it so those SDKs can add it too. 

I am not sure SDKs are usually expected to be able to use workflow-specific information in all ways a data converter is invoked by a client. They can just use contextual information set by the caller (so #1349 does make sense).

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-16 15:28:05.000 UTC</summary>

> Most, including Go, support wrapping the result from start to customize result fetching

Go does not support intercepting `client.GetWorkflow` so you cannot always wrap automatically wrap `WorkflowResult`. If we have to add an interceptor for `client.GetWorkflow` might as well just add the interceptor to get a result

>I am not sure SDKs are usually expected to be able to use workflow-specific information in all ways a data converter is invoked by a client.

Maybe not every call, but any call specifically to a workflow execution should be able to access workflow specific information. For client calls the interceptor injecting those values is a suitable solution for all client calls 



</details>


---

<a id="1207"></a>

### #1207: Handle interfaces in workflowcheck

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1207 |
| **State** | CLOSED |
| **Author** | ndtretyak (Nikolay Tretyak) |
| **Created** | 2023-08-24 11:47:04.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-30 16:14:51.000 UTC |
| **Closed** | 2023-08-30 16:14:51.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
In the following example I use `time.Now()`, but `workflowcheck` does not report this problem because `RegisterWorflow` is called with `Handler.BadWorkflow` rather than `handlerImpl.BadWorkflow`.

```go
type HandlerInterface interface {
	BadWorkflow(ctx workflow.Context) (int64, error)
}

type handlerImpl struct{}

func (w handlerImpl) BadWorkflow(ctx workflow.Context) (int64, error) {
	return time.Now().Unix(), nil
}

func CreateWorker(c client.Client, h HandlerInterface) worker.Worker {
	w := worker.New(c, "example", worker.Options{})
	w.RegisterWorkflow(h.BadWorkflow)
	return w
}

func main() {
	....
	w := CreateWorker(c, handlerImpl{})
}
```

**Describe the solution you'd like**
I'd like `workflowcheck` to match the interface passed to `RegisterWorkflow` with its implementations.

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2023-08-24 12:00:44.000 UTC</summary>

A static analyzer is not going to be able to follow implementations of interfaces because Go does not have a way to define which types are meant to implement an interface at compile time. It would be non-trivial to walk the control graph backwards from `RegisterWorkflow` to fine what was really used. If at all possible, consider registering functions on concrete types. If you must use an interface, maybe have a `Register(worker.WorkflowRegistry)` method on it that each implementation implements and you call generally.

We may be able to, for every `SomeInterface`, look for `var _ SomeInterface = (*SomeType)(nil)` to find all `SomeType`s that implement it. We may also be able to have a way for you to mark workflow entry points when they couldn't otherwise be discovered at compile time. But both options are more brittle than registering functions/methods on the type that implements them.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-24 13:33:07.000 UTC</summary>

@cretz Do we need users to mark workflow entry points? Can't we assume any function that takes a `ctx workflow.Context` as the first parameter is a workflow and analyze it?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-08-24 13:48:36.000 UTC</summary>

> Can't we assume any function that takes a ctx workflow.Context as the first parameter is a workflow and analyze it?

We can probably do this, though the existing behavior of bubbling up to top-level workflow call would be lost. But maybe that is preferred?

</details>


---

<a id="1156"></a>

### #1156: Activity cancel error returned when not initiated server side is rejected by server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1156 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-07-06 19:23:50.000 UTC (2y 6m ago) |
| **Updated** | 2025-06-04 18:52:04.000 UTC |
| **Closed** | 2025-06-04 18:52:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When a worker stops while an activity is running and that context is cancelled and bubbled out as an activity error, that activity attempt should be recorded as failed server side. This is how it works in most SDKs today.

## Actual Behavior

Today if you stop a worker, the activity tries to return to the server the cancelled error but the server fails the activity task completion with:

> unable to mark activity as canceled without activity being request canceled first

I think we need to send 1) only send activity cancelled if the server requested cancel (otherwise wrap as application error if canceled error received), and 2) write a test proving that worker stop during a non-heartbeating activity does the next attempt on the next worker.

#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2023-07-06 19:24:35.000 UTC</summary>

This maybe could be done at the same time as #1086

</details>

<details>
<summary><strong>josh-berry</strong> commented on 2023-12-26 19:38:52.000 UTC</summary>

Am I correct in thinking the impact of this is just performanceâ€”that is, it takes longer overall to successfully complete the activity than it otherwise might?

My mental model of this is:

1. Activity cancellation error gets sent to server
2. Server fails the task completion, and therefore doesn't realize the activity was canceled
3. Eventually the activity times out server-side (<-- this is where the extra time goes)
4. Server retries the activity (hopefully on a new worker since the old one died)
5. Eventually the activity completes (if nothing else goes wrong)

lmk what I got wrong. :)

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-03 16:33:06.000 UTC</summary>

Yes, that seems correct. I think in most Core-based SDKs, we already convert non-server-requested-activity-cancellation errors (i.e. worker shutdown) to activity errors. I think we probably just confirm and do this in all SDKs.

</details>

<details>
<summary><strong>dmateusp</strong> commented on 2024-11-19 10:53:50.000 UTC</summary>

I've just hit the same behavior. I'm cancelling the activity context in an interceptor when the graceful shutdown of workers is initiated, but then I see the same `unable to mark activity as canceled without activity being request canceled first` and Temporal waits for the `StartToCloseTimeout` before attempting the activity again.

Ideally we'd like the next attempt to start as soon as a new worker has rolled out.

This is a snippet from my interceptor code for reference:

```go
	gracefulShutdownChan := activity.GetWorkerStopChannel(ctx)

	activityCtx, activityCtxCancelFunc := context.WithCancel(ctx)
	defer activityCtxCancelFunc()

	go func() {
		<-gracefulShutdownChan
		time.Sleep(10 * time.Second) // Give the running activities some time to finish
		activityCtxCancelFunc()
	}()
	result, err := a.Next.ExecuteActivity(activityCtx, in)
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-19 15:16:43.000 UTC</summary>

@dmateusp I don't believe this issue would help achieve your desired behaviour

>Ideally we'd like the next attempt to start as soon as a new worker has rolled out.

If you want that your activity to immediately run again, your interceptor should return a [custom error](https://pkg.go.dev/go.temporal.io/sdk/temporal#NewApplicationErrorWithOptions) with a very small `NextRetryDelay`

</details>


---

<a id="1048"></a>

### #1048: Channel.Receive consumes message before goroutine is woken up

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1048 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2023-02-19 22:15:06.000 UTC (2y 10m ago) |
| **Updated** | 2023-02-23 02:03:39.000 UTC |
| **Closed** | 2023-02-23 02:03:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`Channel.ReceiveAsync` should be able to receive all pending messages in a Channel.

## Actual Behavior
1. A goroutine blocked on `Channel.Receive` and then a message is sent to the channel. 
2. `Channel.ReceiveAsync` from a different goroutine will not receive the message.

This behavior is problematic as we say that draining all signal messages through `Channel.ReceiveAsync` before completing a workflow is enough to ensure that there is no signal loss.

## Steps to Reproduce the Problem

This problem manifests itself when the goroutine that is blocked on `Channel.Receive` doesn't get a chance to wake up. This happens when a workflow task fails with UNHANDLED_COMMAND due to a new signal received during the workflow task that tried to complete the workflow.

## Notes

I believe that fix to this issue might be backward incompatible as it potentially can change the order of execution of goroutines. The probability of this affecting any workflow is very low, but it should be considered.


#### Comments (5)

<details>
<summary><strong>mfateev</strong> commented on 2023-02-19 23:56:40.000 UTC</summary>

I'm able to reproduce the problem when using a Selector to receive the signal. So the Selector has the same issue.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2023-02-20 00:22:07.000 UTC</summary>

I see two solutions:
1. AsyncReceive always takes precedence
2. A main workflow goroutine has the lowest precedence. This is the path all other SDKs took.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-20 18:14:05.000 UTC</summary>

We are adding the ability for internal SDK patches https://github.com/temporalio/api/pull/259 this could be a candidate.

Can you post an example workflow that causes this? I am not able to replicate the signal getting dropped. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-21 13:28:06.000 UTC</summary>

Not understanding this issue exactly but haven't done a deep read on the reproduction (I may have to make a more simplified reproduction). If a user has `Receive` and `ReceiveAsync` I would think there are no guarantees which will win (even if the winner is deterministic). If a user has a non-primary coroutine that they need to ensure finishes before primary coroutine completion (e.g. one with a `Receive`), they are required to make that assurance in code.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2023-02-23 02:03:39.000 UTC</summary>

After thinking about this I kind of agree that requiring the clean goroutine exit is the way to go. Closing the issue.

</details>


---

<a id="1007"></a>

### #1007: Temporal breaks context error handling

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1007 |
| **State** | CLOSED |
| **Author** | Hades32 (Martin Rauscher) |
| **Created** | 2023-01-19 14:00:00.000 UTC (2y 11m ago) |
| **Updated** | 2025-09-26 21:45:12.000 UTC |
| **Closed** | 2025-09-26 21:45:12.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

```Go
ctx, cancel := context.WithTimeout(cctx, 2*time.Second)
defer cancel()
wf := tClient.GetWorkflow(ctx, wfID, "")
err := wf.Get(ctx, &res)
if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {
	fmt.Println("timeout")
} else {
	fmt.Println("no timeout")
}
```
## Expected Behavior
Should print "timeout"

## Actual Behavior
Prints "no timeout"


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2023-01-19 15:31:53.000 UTC</summary>

Will have to investigate. With gRPC, our underlying protocol, often the context deadline is relayed server side and IIRC it's actually gRPC that chooses to "break context error handling" by returning a failed gRPC status with `DeadlineExceeded`.

If that is indeed the case, I am not sure us changing gRPC native behavior is best for users who already rely on gRPC errors (both in the high level client and in the low level direct gRPC service client that is also made available).

</details>

<details>
<summary><strong>Hades32</strong> commented on 2023-01-19 15:35:05.000 UTC</summary>

That sounds plausible, as when I dumped the error I got some status fields.

I don't think it's a good idea to expose those gRPC details though. I shouldn't have to care about the underlying protocol if I don't use the service interfaces directly.

In my workaround code I'm now using https://github.com/uber-go/multierr to ensure both, the original error as well as a proper `context.DeadlineExceeded` are contained in the `err`

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-26 21:45:12.000 UTC</summary>

Closing since returning gRPC errors is part of our API contract, and we have no plans to break existing error handling 

</details>


---

<a id="942"></a>

### #942: SearchAttribute from DescribeWorkflowExecution return wrong type for Integer 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/942 |
| **State** | CLOSED |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2022-11-01 16:15:24.000 UTC (3y 2m ago) |
| **Updated** | 2022-12-02 20:45:00.000 UTC |
| **Closed** | 2022-12-02 20:44:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Return the integer type

## Actual Behavior
Return the float64 type

## Steps to Reproduce the Problem
see https://github.com/temporalio/samples-go/pull/228

## Specifications

  - Version:  go.temporal.io/sdk v1.17.0
  - Platform: MacOS


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2022-11-01 16:19:26.000 UTC</summary>

This is because you are choosing to use `interface{}` and `converter.GetDefaultDataConverter().FromPayload` which uses default Go JSON semantics which _never_ assumes integer for `interface{}`. From https://pkg.go.dev/encoding/json#Unmarshal:

> float64, for JSON numbers

If this is an issue, you can either: 1) pass in the type you want JSON to unmarshal to, or 2) you can create your own converter that leverages https://pkg.go.dev/encoding/json#Decoder.UseNumber and changes to int if needed.

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2022-11-01 16:22:18.000 UTC</summary>

interesting...
But it will be tedious to pass in the type because my code have to know it in advance. 
I think Temporal should have all the information to convert it correctly, isn't it? If so I would still consider it as a bug in Temporal.

(But anyway, I am going to use UseNumber for my code for now. Thanks for the explanation)

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-11-01 16:24:24.000 UTC</summary>

>  But it will be tedious to pass in the type because my code have to know it in advance.

Not necessarily. You can either have a custom converter or confirm that float64 will work for your needs.

> I think Temporal should have all the information to convert it correctly, isn't it? If so I would still consider it as a bug in Temporal.

It could if we treated search attributes as different than any other integer in the system, but we do not. Same thing with memo. If you call `converter.GetDefaultDataConverter().FromPayload(value, &object)` like your example, and `value` is a numeric payload, you will be subject to default conversion rules. This goes for all of our payloads and is not unique to search attributes.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 18:57:50.000 UTC</summary>

@cretz can we close this? This seems like the intended behavior

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 20:44:59.000 UTC</summary>

Correct, closing.

</details>


---

<a id="938"></a>

### #938: Multi-history replay support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/938 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2022-10-24 21:48:51.000 UTC (3y 2m ago) |
| **Updated** | 2022-12-02 13:07:43.000 UTC |
| **Closed** | 2022-12-01 21:25:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

Like what's already been done in TS/Python

#### Comments (5)

<details>
<summary><strong>bergundy</strong> commented on 2022-12-01 13:16:40.000 UTC</summary>

@Sushisource what's the status of this?

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2022-12-01 21:25:42.000 UTC</summary>

@cretz and I agree it's easy (and performant) enough to call `ReplayWorkflowHistory` in a loop, so we probably don't need this. Maybe a separate item for list API.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-12-01 23:44:13.000 UTC</summary>

Yeah, let's make sure we have the list API for Go following the same rough API we have in other SDKs (list, into histories + concurrency)

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-12-02 01:18:50.000 UTC</summary>

Opened a separate issue #972 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 13:07:43.000 UTC</summary>

I think we won't need concurrency and we won't need an explicit into histories there. Go people are used to looping, they are not used to functional APIs.

</details>


---

<a id="828"></a>

### #828: Replay of Local Activities Executed by an Interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/828 |
| **State** | CLOSED |
| **Author** | grantfuhr (Grant Fuhr) |
| **Created** | 2022-06-07 19:16:49.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-30 12:08:20.000 UTC |
| **Closed** | 2022-06-30 12:08:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Workflows replayed on the same version of a worker should not panic.

## Actual Behavior
When replaying a workflow that contains a local activity called by an interceptor, the replay panics. This occurs when replaying on the same worker, or a copy of the worker on a different task queue. 

## Steps to Reproduce the Problem
[Here is a gist](https://gist.github.com/grantfuhr/972db470d98763a59541968329b2e532) with a test case that demonstrates the error.

Sample error output from running the test:
```
2022/06/07 15:12:49 ERROR Workflow panic WorkflowType Greet WorkflowID ReplayId RunID 0dfd038d-a331-40e1-b0c2-a583785ab439 Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 8, activityID: 8 StackTrace process event for hello_world [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
	/Users/grant.fuhr/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_decision_state_machine.go:409
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc004304870, {0x7248e80, 0x1}, 0xc0035ccec0?)
	/Users/grant.fuhr/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_decision_state_machine.go:973 +0x109
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc003874780, 0xc0021815c0, 0xf0?, 0x0)
	/Users/grant.fuhr/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_event_handlers.go:824 +0x27e
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc00370a380, 0xc0035ad470)
	/Users/grant.fuhr/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_task_handlers.go:878 +0xca8
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc000e95760, 0xc0035ad470, 0x0)
	/Users/grant.fuhr/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_task_handlers.go:727 +0x485
go.temporal.io/sdk/internal.(*WorkflowReplayer).replayWorkflowHistory(0xc003874720, {0x62bba78, 0xc003874738}, {0x62cd4f8?, 0xc0040008c0}, {0x5e32369, 0xf}, 0xc002f13890)
	/Users/grant.fuhr/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_worker.go:1197 +0x64e
go.temporal.io/sdk/internal.(*WorkflowReplayer).ReplayWorkflowHistory(0xc00348fe60?, {0x0?, 0x0?}, 0x5e2160f?)
	/Users/grant.fuhr/go/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_worker.go:1080 +0x205
github.com/DataDog/temporalite/temporaltest_test.TestReplayInterceptor(0xc0033564e0)
	/Users/grant.fuhr/open-source/temporalite/temporaltest/server_test.go:220 +0x876
testing.tRunner(0xc0033564e0, 0x5ef5f58)
	/usr/local/Cellar/go/1.18.2/libexec/src/testing/testing.go:1439 +0x102
created by testing.(*T).Run
	/usr/local/Cellar/go/1.18.2/libexec/src/testing/testing.go:1486 +0x35f
    server_test.go:222: lookup failed for scheduledEventID to activityID: scheduleEventID: 8, activityID: 8
```

## Specifications

  - Go-SDK Version: 1.14.0
  - Server Version: 1.16.2


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2022-06-08 11:17:07.000 UTC</summary>

Thanks for the report! At first glance I agree, this should not error. I will investigate.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-08 11:51:12.000 UTC</summary>

Ok, I believe I see the problem here. The replayer does not run interceptors. I will add `worker.WorkflowReplayer.SetWorkerInterceptors([]WorkerInterceptor)` which should be fairly easy.

Reactions: ðŸ‘ 4

</details>

<details>
<summary><strong>Lercher</strong> commented on 2022-06-15 12:08:49.000 UTC</summary>

I'm getting apparently the same panic with Go SDK 1.14.1. The ambient situation is different from the original report. I can't reconstruct it properly from the logs, but I guess some workflow instance was re-hydrated from scratch (i.e. from the recorded events) in a plain worker process. However, I can't guarantee that the (interpreted) workflow code is indeed identical to the original one which created the event stream.

```log
2022/06/14 16:44:36 ERROR Workflow panic 
Namespace default 
TaskQueue fse 
WorkerID 4644@some-server@ 
WorkflowType TRU-vt100-inmietsetzung@v100 
WorkflowID TRU-vt100-inmietsetzung.VTVertrag.7CVT01UDO4FGHU291MKNKNF5TKAS39 
RunID d7dd6ea4-b974-40f5-b192-e9eb634bb4cf 
Attempt 1 
Error lookup failed for scheduledEventID to activityID: scheduleEventID: 29, activityID: 29 StackTrace process event for fse [panic]:

go.temporal.io/sdk/internal.panicIllegalState(...)
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_decision_state_machine.go:409
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc00008e140, {0xc000719778, 0x2}, 0x0?)
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_decision_state_machine.go:973 +0x109
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc0003cc4b0, 0xc0002fb740, 0xd8?, 0x0)
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_event_handlers.go:824 +0x27e
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0002589a0, 0xc00018d380)
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_task_handlers.go:878 +0xca8
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc0005b6000, 0xc00018d380, 0xc00018dcb0)
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_task_handlers.go:727 +0x485
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc0005b00d0, 0xc00018d380)
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_task_pollers.go:284 +0x2cd
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc0005b00d0, {0xddb860?, 0xc00018d380?})
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_task_pollers.go:255 +0x6c
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc0000d6140, {0xddb420?,0xc0000b9e90})
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_worker_base.go:398 +0x167
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
        go.temporal.io/sdk@v1.14.1-0.20220322131744-55cf584de5c7/internal/internal_worker_base.go:302 +0xb5

2022/06/14 16:44:36 WARN  Failed to process workflow task. Namespace default TaskQueue fse WorkerID 4644@some-server@ WorkflowType TRU-vt100-inmietsetzung@v100 WorkflowID TRU-vt100-inmietsetzung.VTVertrag.7CVT01UDO4FGHU291MKNKNF5TKAS39 RunID d7dd6ea4-b974-40f5-b192-e9eb634bb4cf Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 29, activityID: 29
2022/06/14 16:44:36 INFO  Task processing failed with error Namespace default TaskQueue fse WorkerID 4644@some-server@ WorkerType WorkflowWorker Error Workflow executionsRow not found.  WorkflowId: fse, RunId: 34ba3ca7-4886-4157-aabe-65e2f3366761
```

(slightly formatted for better readability)

Sorry @cretz, I don't understand your last comment: Is it something I can investigate/change myself or is it about some possible SDK or temporal-server change? Regarding missing interceptors in the _replayer_: does such a change also affect re-hydration of ordinary workflow execution state or only the replays for tests and debugging?

Thanks, Martin.

PS: looking at the gist above, interceptors seem to be some user extensibility points as they are added to the options struct. I'm pretty sure that my worker code won't add such interceptors.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-15 12:43:04.000 UTC</summary>

The error you received commonly occurs if you have non-determinism. See https://community.temporal.io/t/go-sdk-troubleshooting. This issue just happens to share that same stack trace because it appears non-deterministic due to a replayer issue.

</details>

<details>
<summary><strong>Lercher</strong> commented on 2022-06-15 16:08:23.000 UTC</summary>

> The error you received commonly occurs if you have non-determinism.

Yes, I see: It's indeed the best explanation as we are working on implementations currently. I just was distracted by the nearly identical stack trace and no one mentioning non-determinism in this ticket. Sorry, my bad, and thank you very much.


Reactions: ðŸ‘ 1

</details>


---

<a id="821"></a>

### #821: Workflow executionsRow not found

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/821 |
| **State** | CLOSED |
| **Author** | CarlosEssun |
| **Created** | 2022-06-01 15:53:40.000 UTC (3y 7m ago) |
| **Updated** | 2025-02-04 18:29:28.000 UTC |
| **Closed** | 2025-02-04 18:29:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I want to use cron scheduler executing activity
> this my demo can you give me advice.  thx !!

## Actual Behavior
1. when I executed command ï¼š
```
tctl --namespace test  workflow  start    --cron "28 22 * * *"  --wt "InstanceWorkflow"  --taskqueue "test"    --execution_timeout 1200 --wtt  1200
```
2. Stack Trace:
```
2022/06/01 22:28:56 ERROR Workflow panic Namespace test TaskQueue test WorkerID 23934@mydb-ops-test-hb2e-1-152@ WorkflowType InstanceWorkflow WorkflowID 
ddf67b41-883e-47c9-b206-8d41d3661c9f RunID 85909ddf-9913-4651-b3ef-395fd23b72a6 Attempt 1 Error Attempt to generate a command before processing WorkflowTaskStarted event StackTrace coroutine root [panic]:
go.temporal.io/sdk/internal.(*commandsHelper).getNextID(...)
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_decision_state_machine.go:858
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GenerateSequence(...)
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_event_handlers.go:464
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).ExecuteActivity(0xc0000f1100, {{{0x0, 0x0}, {0xc0004eb790, 0x4}, 0x1a3185c5000, 0x0, 0x0, 0x12a05f200, 0x0, ...}, ...}, ...)
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_event_handlers.go:475 +0x574
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteActivity(0xc0002d9130, {0x1489550?, 0xc0006e8270}, {0x1685d60, 0x12}, {0xc0005324a0, 0x2, 0x2})
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/workflow.go:515 +0x782
go.temporal.io/sdk/internal.ExecuteActivity({0x1489550, 0xc0006e8210}, {0x10b5260, 0x12b6fc0}, {0xc0005324a0, 0x2, 0x2})
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/workflow.go:459 +0x185
go.temporal.io/sdk/workflow.ExecuteActivity(...)
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/workflow/workflow.go:114
inspection/activity.InstanceWorkflow({0x1489550, 0xc0006e8150})
        /opt/dev/inspection/activity/instace_workflow.go:74 +0x691
reflect.Value.call({0x10b11e0?, 0x12b6fb0?, 0x7f36d9937108?}, {0x123e12c, 0x4}, {0xc0006e0330, 0x1, 0x3?})
        /usr/local/go/src/reflect/value.go:585 +0x845
reflect.Value.Call({0x10b11e0?, 0x12b6fb0?, 0x404eac?}, {0xc0006e0330?, 0x0?, 0x1111440?})
        /usr/local/go/src/reflect/value.go:368 +0xbc
go.temporal.io/sdk/internal.executeFunction({0x10b11e0, 0x12b6fb0}, {0xc00006de08, 0x1, 0xc000435800?})
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_worker.go:1553 +0x136
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0xc0002d9130, {0x1489400?, 0xc0002d7920}, 0xc0006e0318)
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/workflow.go:419 +0x15d
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0xc000287640, {0x1489400, 0xc0002d7920}, 0x25?)
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_worker.go:753 +0x292
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1({0x1489550, 0xc0006e8030})
        /opt/dev/golang/pkg/mod/go.temporal.io/sdk@v1.14.0/internal/internal_workflow.go:500 +0xcd
2022/06/01 22:28:56 WARN  Failed to process workflow task. Namespace test TaskQueue test WorkerID 23934@mydb-ops-test-hb2e-1-152@ WorkflowType InstanceWorkflow WorkflowID ddf67b41-883e-47c9-b206-8d41d3661c9f RunID 85909ddf-9913-4651-b3ef-395fd23b72a6 Attempt 1 Error Attempt to generate a command before processing WorkflowTaskStarted event
```
## Steps to Reproduce the Problem

  1. instanceWorkflow
  >  I borrowed `samples-go` for example `cron` 
  ```
func Tint(v con.InstanceDecodeQuery) {
	var cache_conn = con.GetCacheConn()
	var req = config.BAPI
	err := req.Endpoint.DecodeInstanceAccout(&v, &req.TokenReq, &req.Encrypt, cache_conn)
	if err != nil {
		logger.SugaredLogger.Errorf("errorï¼š%+v", &v)
	}
}

func InstanceWorkflow(ctx workflow.Context) (*CronResult, error) {
	l, _ := time.LoadLocation("Asia/Shanghai")
	lastRunTime := time.Now().In(l)
	workflow.GetLogger(ctx).Info("StartTime", lastRunTime)

	ao := workflow.ActivityOptions{
		// StartToCloseTimeout:    30 * time.Minute,
		ScheduleToCloseTimeout: 30 * time.Minute,
		HeartbeatTimeout:       5 * time.Second,
	}
	ctx1 := workflow.WithActivityOptions(ctx, ao)
	lastRunTime = time.Now().In(l)
	if workflow.HasLastCompletionResult(ctx1) {
		var lastResult CronResult
		if err := workflow.GetLastCompletionResult(ctx1, &lastResult); err == nil {
			lastRunTime = lastResult.RunTime
		}
	}
	thisRunTime := time.Now().In(l)

	logger.Infof("lastRunTime:%+v, thisRunTime:%+v", lastRunTime.Format("2006-01-02 03:04:05 PM"), thisRunTime.Format("2006-01-02 03:04:05 PM"))


	err := workflow.ExecuteActivity(ctx1, NotPRIWithBigTable, lastRunTime, thisRunTime).Get(ctx, nil)
	if err != nil {
		// Cron job failed
		// Next cron will still be scheduled by the Server
		workflow.GetLogger(ctx).Error("Cron job failed.", "Error", err)
		return nil, err
	}

	return &CronResult{RunTime: thisRunTime}, nil
}

func NotPRIWithBigTable(lastRunTime, thisRunTime time.Time) error {
	var (
		action ARE
	)
	ins, err := action.GetInstanceList()
	if err != nil {
		logger.SugaredLogger.Error(err.Error())
		return err
	}
	for _, v := range ins {
		go func(item con.InstanceDecodeQuery) {
			Tint(item)

		}(v)
	}
	return nil
}
```

  2. i found same issue [#678 ](https://github.com/temporalio/sdk-go/issues/678),but can not solve it ã€‚i try them: 1.140ï¼Œ1.14.2  1.16.2 
  
  3.   I try to use  `tctl`  command  it run normally.
```
tctl --namespace test  workflow  start    --wt "InstanceWorkflow"  --taskqueue "test" --execution_timeout 2000 --wtt  2000   --wid "inspection_0003"
```

## Specifications

  - Version: SDK v1.14.0ï¼Œtctl v1.16.1
  - installed method :docker-compose   temporalio/admin-tools:1.16.2  temporalio/auto-setup:1.16.2 
  - Platform: Linux


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2022-06-01 16:00:01.000 UTC</summary>

If possible, can you reduce the snippet to standalone runnable code to replicate? Also, are you trying to issue a query to the workflow?

</details>

<details>
<summary><strong>CarlosEssun</strong> commented on 2022-06-08 01:47:29.000 UTC</summary>

I changed the code a bit, the general logic is as follows:
I did not execute related queries during schedulingï¼
```
type CronResult struct {
	RunTime time.Time
	Result  []string
}



func InstanceWorkflow(ctx workflow.Context) (*CronResult, error) {
	l, _ := time.LoadLocation("Asia/Shanghai")
	// lastRunTime := time.Now().In(l)
	lastRunTime := workflow.Now(ctx).Local().In(l)
	workflow.GetLogger(ctx).Info("mysql check bigTable.", "StartTime", lastRunTime)

	ao := workflow.ActivityOptions{
		// StartToCloseTimeout:    30 * time.Minute,
		ScheduleToCloseTimeout: 30 * time.Minute,
		HeartbeatTimeout:       10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	thisRunTime := workflow.Now(ctx).Local().In(l)

	logger.Infof("start Mysql lastRunTime :%+v, thisRunTime:%+v", lastRunTime.Format("2006-01-02 03:04:05 PM"), thisRunTime.Format("2006-01-02 03:04:05 PM"))
	future, settable := workflow.NewFuture(ctx)
	workflow.Go(ctx, func(ctx workflow.Context) {
		defer workflow.GetLogger(ctx).Info("check done.")
		var result string
		err := workflow.ExecuteActivity(ctx, NotPRIWithBigTable, lastRunTime, thisRunTime).Get(ctx, &result)
		if err != nil {
			workflow.GetLogger(ctx).Error("check failed.", "Error", err)
			settable.SetError(err)
			return
		}
		settable.SetValue(result)
	})
	var results []string
	var result string
	err := future.Get(ctx, &result)
	if err != nil {
		return nil, err
	}
	results = append(results, result)
	return &CronResult{RunTime: thisRunTime, Result: results}, nil
}


func NotPRIWithBigTable(lastRunTime, thisRunTime time.Time) (result string, err error) {
	var (
		action ARE
	)
	// get db qeruy results
	ins, err := action.GetInstanceList()
	if err != nil {
		logger.SugaredLogger.Error("get  instances faild ", err.Error())
		return "err...", err
	}
	for idx, v := range ins {
		// fmt.Println(idx, v.Engine)
		logger.SugaredLogger.Infof("index:%v,instance:%v", idx, v.Instance_name)
		instacen_obj := &tunnel.InstanceResponse{
			Instance_name: v.Instance_name,
			Uuid:          v.Uuid,
			Auth:          v.Auth,
			Engine:        v.Engine,
			User:          v.User,
			Password:      v.Password,
			Host:          v.Host,
			Port:          v.Port,
			Tunnel: tunnel.Tunnel{
				Host:     v.Addr.Host.String,
				User:     v.Addr.User.String,
				Password: v.Addr.Password.String,
				Port:     int(v.Addr.Port.Int64)},
		}
		fmt.Println(126, instacen_obj, len(instacen_obj.Tunnel.Host), instacen_obj.Tunnel.Host)
		// if len(instacen_obj.Tunnel.Host) > 0 {
		// 	instacen_obj.SetupTunnel()
		// } else {
		// 	instacen_obj.SetupDirect()
		// }

	}
	return "ok", nil
}
```
and workflow history details:
```json
[
  {
    "eventTime": "2022-06-08T01:28:35.000Z",
    "eventType": "WorkflowExecutionStarted",
    "eventId": "1",
    "details": {
      "workflowType": {
        "name": "InstanceWorkflow"
      },
      "parentWorkflowNamespace": "",
      "parentWorkflowExecution": null,
      "parentInitiatedEventId": "0",
      "taskQueue": {
        "name": "test",
        "kind": "Normal"
      },
      "input": null,
      "workflowExecutionTimeout": {
        "duration": 2000
      },
      "workflowRunTimeout": {
        "duration": 2000
      },
      "workflowTaskTimeout": {
        "duration": 120
      },
      "continuedExecutionRunId": "",
      "initiator": "CronSchedule",
      "continuedFailure": null,
      "lastCompletionResult": null,
      "originalExecutionRunId": "a5906592-c4f3-4b98-8ce3-ae8c6af12327",
      "identity": "tctl@master",
      "firstExecutionRunId": "a5906592-c4f3-4b98-8ce3-ae8c6af12327",
      "retryPolicy": null,
      "attempt": 1,
      "workflowExecutionExpirationTime": "2022-06-08T02:01:55.000Z",
      "cronSchedule": "29 09 * * *",
      "firstWorkflowTaskBackoff": {
        "duration": 28825
      },
      "memo": null,
      "searchAttributes": null,
      "prevAutoResetPoints": null,
      "header": {
        "fields": {}
      },
      "eventId": "1",
      "eventType": "WorkflowExecutionStarted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Jun 8th 9:28:35 am"
        },
        {
          "key": "eventId",
          "value": "1"
        },
        {
          "key": "workflowType.name",
          "value": "InstanceWorkflow"
        },
        {
          "key": "parentWorkflowNamespace",
          "value": ""
        },
        {
          "key": "parentInitiatedEventId",
          "value": "0"
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "test"
            }
          },
          "value": "test"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "workflowExecutionTimeout",
          "value": "33m 20s"
        },
        {
          "key": "workflowRunTimeout",
          "value": "33m 20s"
        },
        {
          "key": "workflowTaskTimeout",
          "value": "2m"
        },
        {
          "key": "continuedExecutionRunId",
          "value": ""
        },
        {
          "key": "initiator",
          "value": "CronSchedule"
        },
        {
          "key": "originalExecutionRunId",
          "value": "a5906592-c4f3-4b98-8ce3-ae8c6af12327"
        },
        {
          "key": "identity",
          "value": "tctl@master"
        },
        {
          "key": "firstExecutionRunId",
          "value": "a5906592-c4f3-4b98-8ce3-ae8c6af12327"
        },
        {
          "key": "attempt",
          "value": 1
        },
        {
          "key": "workflowExecutionExpirationTime",
          "value": "2022-06-08T02:01:55.000Z"
        },
        {
          "key": "cronSchedule",
          "value": "29 09 * * *"
        },
        {
          "key": "firstWorkflowTaskBackoff",
          "value": "8h 25s"
        }
      ],
      "eventTime": "Jun 8th 9:28:35 am"
    },
    "eventTimeDisplay": "Jun 8th 9:28:35 am",
    "timeElapsedDisplay": "Jun 8th 9:28:35 am",
    "eventSummary": {
      "Close Timeout": "33m 20s",
      "identity": "tctl@master",
      "input": null,
      "Workflow": "InstanceWorkflow",
      "eventId": "1",
      "eventType": "WorkflowExecutionStarted",
      "kvps": [
        {
          "key": "Close Timeout",
          "value": "33m 20s"
        },
        {
          "key": "identity",
          "value": "tctl@master"
        },
        {
          "key": "Workflow",
          "value": "InstanceWorkflow"
        }
      ]
    },
    "eventFullDetails": {
      "workflowType": {
        "name": "InstanceWorkflow"
      },
      "parentWorkflowNamespace": "",
      "parentWorkflowExecution": null,
      "parentInitiatedEventId": "0",
      "taskQueue": {
        "name": "test",
        "kind": "Normal"
      },
      "input": null,
      "workflowExecutionTimeout": {
        "duration": 2000
      },
      "workflowRunTimeout": {
        "duration": 2000
      },
      "workflowTaskTimeout": {
        "duration": 120
      },
      "continuedExecutionRunId": "",
      "initiator": "CronSchedule",
      "continuedFailure": null,
      "lastCompletionResult": null,
      "originalExecutionRunId": "a5906592-c4f3-4b98-8ce3-ae8c6af12327",
      "identity": "tctl@master",
      "firstExecutionRunId": "a5906592-c4f3-4b98-8ce3-ae8c6af12327",
      "retryPolicy": null,
      "attempt": 1,
      "workflowExecutionExpirationTime": "2022-06-08T02:01:55.000Z",
      "cronSchedule": "29 09 * * *",
      "firstWorkflowTaskBackoff": {
        "duration": 28825
      },
      "memo": null,
      "searchAttributes": null,
      "prevAutoResetPoints": null,
      "header": {
        "fields": {}
      },
      "eventId": "1",
      "eventType": "WorkflowExecutionStarted",
      "kvps": [
        {
          "key": "workflowType.name",
          "value": "InstanceWorkflow"
        },
        {
          "key": "parentWorkflowNamespace",
          "value": ""
        },
        {
          "key": "parentInitiatedEventId",
          "value": "0"
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "test"
            }
          },
          "value": "test"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "workflowExecutionTimeout",
          "value": "33m 20s"
        },
        {
          "key": "workflowRunTimeout",
          "value": "33m 20s"
        },
        {
          "key": "workflowTaskTimeout",
          "value": "2m"
        },
        {
          "key": "continuedExecutionRunId",
          "value": ""
        },
        {
          "key": "initiator",
          "value": "CronSchedule"
        },
        {
          "key": "originalExecutionRunId",
          "value": "a5906592-c4f3-4b98-8ce3-ae8c6af12327"
        },
        {
          "key": "identity",
          "value": "tctl@master"
        },
        {
          "key": "firstExecutionRunId",
          "value": "a5906592-c4f3-4b98-8ce3-ae8c6af12327"
        },
        {
          "key": "attempt",
          "value": 1
        },
        {
          "key": "workflowExecutionExpirationTime",
          "value": "2022-06-08T02:01:55.000Z"
        },
        {
          "key": "cronSchedule",
          "value": "29 09 * * *"
        },
        {
          "key": "firstWorkflowTaskBackoff",
          "value": "8h 25s"
        }
      ]
    }
  }
]
```

</details>

<details>
<summary><strong>CarlosEssun</strong> commented on 2022-06-08 04:11:51.000 UTC</summary>

I may have found the cause of this problem, but I don't know how to deal with it.
The scheduled task function inside the service may be calculated based on UTC time, when I use the CST time zone, the task will not be scheduled all the time. how should i deal with it 


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-08 11:20:04.000 UTC</summary>

Thanks for the workflow code. Can you also provide the calling code that replicates the error if possible? Any code that I can run to literally cause the error will greatly help me debug. I don't see where you are starting the workflow and making a call to cause the error.

> The scheduled task function inside the service may be calculated based on UTC time, when I use the CST time zone, the task will not be scheduled all the time. how should i deal with it

I need more details here. What do you mean "when I use CST time zone"? The server should schedule the tasks for you even if UTC.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:29:27.000 UTC</summary>

Closing due to lack of reproduction, can reopen if there is more information

</details>


---

<a id="803"></a>

### #803: MutableSideEffect doesn't seem to work

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/803 |
| **State** | CLOSED |
| **Author** | dnr (David Reiss) |
| **Created** | 2022-05-10 01:37:24.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-25 14:08:20.000 UTC |
| **Closed** | 2022-05-25 14:08:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
MutableSideEffect works as described in the docs.

## Actual Behavior
This code:
```
	// load default number
	get := func(ctx workflow.Context) interface{} { return defaultNumber }
	eq := func(a, b interface{}) bool { return a.(int) == b.(int) }
	var number int
	if err := workflow.MutableSideEffect(ctx, "defaultNumber", get, eq).Get(&number); err != nil {
		panic("can't decode number:" + err.Error())
	}
```
works at first, but if I kill and restart the worker to force replay, I get:
```
2022/05/09 18:16:00 ERROR Workflow panic Namespace default TaskQueue hello-world WorkerID 2450384@pinglin@ WorkflowType Workflow WorkflowID hello_world_workflowID RunID 408db9e3-7885-4ca5-be59-0bce212c08eb Attempt 1 Error can't decode number:payload item 0: unable to decode: json: cannot unmarshal string into Go value of type int StackTrace coroutine root [panic]:
github.com/temporalio/samples-go/helloworld.Workflow({0xdfce40, 0xc00043a580}, {0xc0004360f8, 0x8})
        /home/dnr/t/samples-go/helloworld/helloworld.go:21 +0x23d
reflect.Value.call({0xbe9b60?, 0xd38768?, 0x30?}, {0xcd73c3, 0x4}, {0xc00040d1d0, 0x2, 0x18?})
        /nix/store/f2n8g9nbrxaqwyd9b3grynvwhyz3qlrw-go-1.18/share/go/src/reflect/value.go:556 +0x845
reflect.Value.Call({0xbe9b60?, 0xd38768?, 0xc000407d28?}, {0xc00040d1d0, 0x2, 0x2})
        /nix/store/f2n8g9nbrxaqwyd9b3grynvwhyz3qlrw-go-1.18/share/go/src/reflect/value.go:339 +0xbf
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0xc00042a730?, {0xdfce40?, 0xc00043a580?}, {0xc00042e490?, 0xc0005a86c0?}, {0xc00042e4a0?, 0x1?, 0xc0001030c8?})
        /home/dnr/t/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/workflow.go:393 +0x1e5
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0xc00043a500, {0xdfce40, 0xc00043a580}, 0x25?)
        /home/dnr/t/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_worker.go:762 +0x2c3
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1({0xdfcfc8, 0xc00040d170})
        /home/dnr/t/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_workflow.go:494 +0xcd

```

Another weird thing I noticed was what was encoded in the marker:

```
{
  "data": {
    "payloads": [
      {
        "metadata": {"encoding": "anNvbi9wbGFpbg=="},
        "data": "ImRlZmF1bHROdW1iZXIi"
      },
      {
        "metadata": {"encoding": "anNvbi9wcm90b2J1Zg=="},
        "data": "eyJwYXlsb2FkcyI6W3sibWV0YWRhdGEiOnsiZW5jb2RpbmciOiJhbk52Ymk5d2JHRnBiZz09In0sImRhdGEiOiJNVGs9In1dfQ=="
      }
    ]
  },
  "side-effect-id": {
    "payloads": [
      {
        "metadata": {"encoding": "anNvbi9wbGFpbg=="},
        "data": "ImRlZmF1bHROdW1iZXIi"
      }
    ]
  }
}
```
Decoding all of that base64 to strings just to make things clear (pseudo-json):
```
{
  "data": {
    "payloads": [
      {
        "metadata": {"encoding": "json/plain"},
        "data": `"defaultNumber"`
      },
      {
        "metadata": {"encoding": "json/protobuf"},
        "data": `{"payloads":[{"metadata":{"encoding":"anNvbi9wbGFpbg=="},"data":"MTk="}]}`
      }
    ]
  },
  "side-effect-id": {
    "payloads": [
      {
        "metadata": {"encoding": "json/plain"},
        "data": `"defaultNumber"`
      }
    ]
  }
}
```
That is, the actual data is double-base64-encoded.

## Steps to Reproduce the Problem

Repro here: https://github.com/dnr/samples-go/tree/mutablesideeffect/helloworld

1. Run the worker
2. Run the starter
3. Kill the worker
4. Start the worker again

## Specifications

  - Version: tested go sdk 1.6.0 and also 1.14.0. server is a branch somewhere near 1.16.0. go 1.18
  - Platform: linux


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 15:04:30.000 UTC</summary>

@dnr - Thanks for the report! Can you give a bit more to your snippet? Specifically I am looking to see the `defaultNumber` variable and where it's defined.

I will attempt to replicate and fix shortly.

</details>

<details>
<summary><strong>dnr</strong> commented on 2022-05-16 17:36:30.000 UTC</summary>

It's all in here: https://github.com/dnr/samples-go/tree/mutablesideeffect/helloworld

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 21:09:50.000 UTC</summary>

Ok, I have replicated this issue. It seems we have no good tests for mutable side effects :-( I have found two issues:

1. We do not properly unwrap the payloads from history that we wrap. It seems #151 wrapped them but didn't unwrap them on replay/history properly and there was no test to confirm it does
2. We are not recording a command during replay so there is a command mismatch

I am working on a fix

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-17 14:11:45.000 UTC</summary>

This is a much harder problem than it seems, and mutable side effects have never worker properly during replay.

Basically, the Go SDK maintains a counter so it can re-obtain things deterministically. This counter, which is incremented each command, is used for command IDs, timer IDs, cancellation IDs, signal IDs, upsert search attr IDs, etc.

When mutable side effect callback result _is not equal_ to the previous one during normal run, we record a marker command which increments the counter for all other commands. But we don't record a command if it _is equal_. During replay however, we can never know it is or isn't equal because we are not allowed to invoke the callback. So, do we record a command or not? If we don't get it right, the command counter mismatches causing non-determinism issues.

So, given a Go workflow that does:

1. WFT start (counter 5)
1. Mutable side effect not equal - record marker command (++counter)
1. Start a timer with ID 7 (++counter)
1. WFT end
1. Marker recorded
1. Timer 7 started
1. WFT start (counter 7)
1. Mutable side effect equal - *do not* record marker command
1. Start a timer with ID 8 (++counter)
1. WFT end
1. Timer 8 started

This is how replay looks if we _always_ record marker during replay

1. WFT start (counter 5)
1. Mutable side effect - record marker command (++counter)
1. Start a timer with ID 7 (++counter)
1. WFT end
1. Marker recorded
1. Timer 7 started
1. WFT start (counter 7)
1. Mutable side effect - record marker command (++counter) - note, we don't know equal vs not-equal here
1. Start a timer with ID 9 (++counter)
1. WFT end
1. Timer 8 started

That last step causes an error because timer 8 does not exist.

This is how replay looks if we _never_ record marker during replay (what the code does today):

1. WFT start (counter 5)
1. Mutable side effect - *do not* record marker command
1. Start a timer with ID 6 (++counter)
1. WFT end
1. Marker recorded (we don't error today if we don't know about the marker)
1. Timer 7 started

That last step causes an error because timer 7 does not exist.

So, what do we do here? Java seems to use a "fake" marker on every replay and just skips it when checking, but Go is not that fortunate because it has a counter that affects all things after it. Right now, here is the best solution I can think of:

* Track all replay markers recorded last WFT
* For every replay marker not recorded in history by the next WFT start, undo everything it did, which means I have to change past-recorded counter uses which includes:
  * Cancellation IDs for all pending cancel-external-workflow commands
  * Signal IDs for all pending signal-external-workflow commands
  * Upsert IDs for all pending upsert-search-attribute commands
  * Child workflow IDs for all pending execute-child-workflow commands. This is a bit complicated, because it only applies if they didn't provide their own workflow ID. When they don't provide it, it is `<parent-run-id>_<++counter>`. So I have to either check that it matches that pattern or maintain some state saying whether I auto-generated the ID so I can alter the generated value
  * Timer IDs for all pending timer commands
  * Schedule activity IDs for all pending execute-activity commands

Is there a better option here I am missing? cc @Sushisource, @mfateev, @yiminc, @alexshtin

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-17 19:21:33.000 UTC</summary>

OK, I have been able to use marker lookahead here. PR incoming...

</details>


---

<a id="747"></a>

### #747: lookup failed for scheduledEventID to activityID since 1.13.1

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/747 |
| **State** | CLOSED |
| **Author** | kevinzhu-sa |
| **Created** | 2022-03-07 17:02:24.000 UTC (3y 10m ago) |
| **Updated** | 2022-07-08 12:58:20.000 UTC |
| **Closed** | 2022-03-28 15:38:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Getting issues since upgrading to 1.13.1. No issues in 1.13.0


## Expected Behavior

Cancel activity should not panic the workflow 

## Actual Behavior

```
PanicError: lookup failed for scheduledEventID to activityID: scheduleEventID: 197, activityID: 196
```


## Steps to Reproduce the Problem

omitted details but main structure as below

```go
func workflow() error {
	var runningActivities ActivityResults

	activityCtx, cancelActivity := workflow.WithCancel(ctx)

	s.AddReceive(signalChan, func(c workflow.ReceiveChannel, more bool) {
		...
		if shouldCancel {
			cancelActivity()

			if len(runningActivities) > 0 {
				// get results of all the running activities to ensure they are cancelled
				runningActivities = ActivityResults{}
			}
			_ = workflow.Sleep(ctx, 15*time.Second)

			return
		}


		// Do not block workflow thread.
		workflow.Go(activityCtx, func(activityCtx workflow.Context) {
			// run activities with `activityCtx`
			// update runningActivities array
		})
	})
}

```



## Specifications

  - Version: 1.13.1
  - Platform: kubernetes


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2022-03-07 17:03:48.000 UTC</summary>

We have noticed a similar issue here and fixed it with https://github.com/temporalio/sdk-go/pull/741 and are about to release it. Can you try with `master` and see if you can still replicate?

</details>

<details>
<summary><strong>kevinzhu-sa</strong> commented on 2022-03-07 17:17:47.000 UTC</summary>

> 

Thanks! Will give it a try

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-03-28 15:38:06.000 UTC</summary>

Closing. Reopen if this issue persists.

</details>

<details>
<summary><strong>choo-stripe</strong> commented on 2022-07-08 00:44:03.000 UTC</summary>

We hit this cancelling a workflow on 1.14.1. Let me know what details I can provide to help.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-07-08 12:58:20.000 UTC</summary>

This is often caused by non-determinism. See https://community.temporal.io/t/go-sdk-troubleshooting/4440#workflow-non-determinism-5.

</details>


---

<a id="718"></a>

### #718: Add metric for time passed from the activity scheduling to the last attempt

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/718 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-08 17:57:26.000 UTC (3y 11m ago) |
| **Updated** | 2022-04-07 10:46:03.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 1 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

**Is your feature request related to a problem? Please describe.**
If users want to set an alert for activities that keep retrying and failing, there is no appropriate metric to handle that.
`activity_succeed_endtoend_latency` includes only successful executions.
`activity_execution_latency` handles the execution of a single activity task only.

**Describe the solution you'd like**
We should add a metric reporting how much time passed from an activity schedule to the last activity attempt. This metric should have an activity type as a tag and be SDK side.

**Describe alternatives you've considered**
Users can produce their own custom metrics. But it looks like such a common concern, that Temporal SDK should provide a built-in way to detect it.

JavaSDK issue: https://github.com/temporalio/sdk-java/issues/1035

#### Comments (1)

<details>
<summary><strong>olegsu</strong> commented on 2022-04-07 10:46:03.000 UTC</summary>

Like the alternative solution you suggested.
In case I want to add additional tags to metric.

</details>


---

<a id="659"></a>

### #659: Possibility to deprecate attribute `Control`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/659 |
| **State** | OPEN |
| **Author** | wxing1292 (Wenquan Xing) |
| **Created** | 2021-12-02 23:53:07.000 UTC (4y 1m ago) |
| **Updated** | 2024-03-15 05:00:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | next-gen |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Is go SDK still using `Control` for the following cases?

* [signal external workflow](https://github.com/temporalio/sdk-go/blob/960d3e909f0ea1d1cf4675f6797a61e3edd51162/internal/internal_decision_state_machine.go#L1183)
* [request cancel external workflow](https://github.com/temporalio/sdk-go/blob/960d3e909f0ea1d1cf4675f6797a61e3edd51162/internal/internal_decision_state_machine.go#L1122)

can we deprecate above 2 attributes?



#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2021-12-03 14:33:16.000 UTC</summary>

Yes, they are used at https://github.com/temporalio/sdk-go/blob/v1.11.1/internal/internal_event_handlers.go#L869 and https://github.com/temporalio/sdk-go/blob/v1.11.1/internal/internal_event_handlers.go#L1390 respectively.

We can look into deprecating and/or using alternative approaches if necessary. Can you explain the reasoning for deprecation?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 21:12:44.000 UTC</summary>

@wxing1292 - Bump

</details>

<details>
<summary><strong>wxing1292</strong> commented on 2021-12-16 21:32:51.000 UTC</summary>

previously the `control` (cadence SDK) contains the auto-incremented ID for in mem state machine
* request cancel external workflow
* signal external workflow
* child workflow?
* activity
* timer

i am checking if it is easy to deprecate this `control` variable since it is easy to break 

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 21:33:48.000 UTC</summary>

I am afraid it is not easy to deprecate since it is in active use and could affect compatibility if changed.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 21:45:49.000 UTC</summary>

Marking this as something for the next-gen SDK.

</details>


---

<a id="630"></a>

### #630: Concurrent ExecuteWorkflow will gen same RunId

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/630 |
| **State** | CLOSED |
| **Author** | franktz |
| **Created** | 2021-11-10 09:58:17.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-16 14:14:41.000 UTC |
| **Closed** | 2021-11-16 14:14:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Concurrent ExecuteWorkflow will gen different RunId

## Actual Behavior
Concurrent ExecuteWorkflow will gen same RunId

## Steps to Reproduce the Problem
  1.git clone https://github.com/temporalio/money-transfer-project-template-go
  2.modify start/main.go, add 'for range' contain "options := client.StartWorkflowOptions{" and "printResults(transferDetails, we.GetID(), we.GetRunID())"
  3.go run start/main.go
  4.see stdout, "we.GetID()" is the same.

## Specifications

  - Version:
  - Platform:


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2021-11-12 23:16:20.000 UTC</summary>

`GetID` is the workflow ID, `GetRunID` is the run ID. Regardless, running that way reuses the ID, which is supposed to be unique. The default ID reuse policy (see start workflow options) does not error by intention.

Multiple workflow runs should use unique workflow IDs. Of course reusing an ID on a failed workflow by default creates a new run ID.

</details>

<details>
<summary><strong>franktz</strong> commented on 2021-11-15 15:54:11.000 UTC</summary>

> `GetID` is the workflow ID, `GetRunID` is the run ID. Regardless, running that way reuses the ID, which is supposed to be unique. The default ID reuse policy (see start workflow options) does not error by intention.
> 
> Multiple workflow runs should use unique workflow IDs. Of course reusing an ID on a failed workflow by default creates a new run ID.

Got it! Thank you very much.

</details>

<details>
<summary><strong>franktz</strong> commented on 2021-11-15 15:58:48.000 UTC</summary>

BTW, another question:
The effect I want is: each worker gets only one workflow execution at a time, and then goes to the queue to get another one after the execution. How can I configure ?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-15 18:14:35.000 UTC</summary>

The `worker.Options` (aliased to https://pkg.go.dev/go.temporal.io/sdk/internal#WorkerOptions) have options for max concurrent executions. You can probably set `MaxConcurrentWorkflowTaskExecutionSize` for one workflow at a time (but would still need to set the same for activities if you want to limit those).

Limiting workflow execution count may not always be the best way. All real work happens in activities so most of the time it would be there you'd want to limit.

Also if it's easier, feel free to ask questions in our forum at https://community.temporal.io/ or slack at https://temporal.io/slack.

</details>

<details>
<summary><strong>franktz</strong> commented on 2021-11-16 01:51:06.000 UTC</summary>

> The `worker.Options` (aliased to https://pkg.go.dev/go.temporal.io/sdk/internal#WorkerOptions) have options for max concurrent executions. You can probably set `MaxConcurrentWorkflowTaskExecutionSize` for one workflow at a time (but would still need to set the same for activities if you want to limit those).
> 
> Limiting workflow execution count may not always be the best way. All real work happens in activities so most of the time it would be there you'd want to limit.
> 
> Also if it's easier, feel free to ask questions in our forum at https://community.temporal.io/ or slack at https://temporal.io/slack.

Thank you. I have no question now.

</details>


---

<a id="614"></a>

### #614: Testing cron child workflow with parent policy abandon runs forever

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/614 |
| **State** | CLOSED |
| **Author** | tminusplus (Travis) |
| **Created** | 2021-11-02 06:19:24.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-19 18:11:01.000 UTC |
| **Closed** | 2021-11-19 18:11:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Testing a cron child workflow with PARENT_CLOSE_POLICY_ABANDON should either close with the parent workflow for testsuite or have a method to shutdown the child workflow for the test.

## Actual Behavior
The cron child workflow runs forever due to the auto-fire timer and then panics when the test times out.


## Steps to Reproduce the Problem

Originally produced while updating go-sdk in a repo. There is a test below for internal_workflow_testsuite_test.go which can reproduce the issue
```
func (s *WorkflowTestSuiteUnitTest) Test_CronChildWorkflowWithParentPolicyAbandon() {
	failedCount, successCount, lastCompletionResult := 0, 0, 0
	cronWorkflow := func(ctx Context) (int, error) {
		info := GetWorkflowInfo(ctx)
		var result int
		if HasLastCompletionResult(ctx) {
			_ = GetLastCompletionResult(ctx, &result)
		}
		_ = Sleep(ctx, time.Second*3)
		if info.Attempt == 1 {
			failedCount++
			return 0, errors.New("please-retry")
		}

		successCount++
		result++
		lastCompletionResult = result
		return result, nil
	}

	testWorkflow := func(ctx Context) error {
		ctx1 := WithChildWorkflowOptions(ctx, ChildWorkflowOptions{
			WorkflowRunTimeout: time.Minute * 10,
			RetryPolicy: &RetryPolicy{
				MaximumAttempts:        5,
				InitialInterval:        time.Second,
				MaximumInterval:        time.Second * 10,
				BackoffCoefficient:     2,
				NonRetryableErrorTypes: []string{"bad-bug"},
			},
			ParentClosePolicy: enumspb.PARENT_CLOSE_POLICY_ABANDON,
			CronSchedule:      "0 * * * *", // hourly
		})

		cronFuture := ExecuteChildWorkflow(ctx1, cronWorkflow) // cron never stop so this future won't return

		timeoutTimer := NewTimer(ctx, time.Hour*3)
		selector := NewSelector(ctx)
		var err error
		selector.AddFuture(cronFuture, func(f Future) {
			err = errors.New("cron workflow returns, this is not expected")
		}).AddFuture(timeoutTimer, func(f Future) {
			// err will be nil
		}).Select(ctx)

		return err
	}

	env := s.NewTestWorkflowEnvironment()
	env.RegisterWorkflow(cronWorkflow)
	env.RegisterWorkflow(testWorkflow)

	startTime, _ := time.Parse(time.RFC3339, "2018-12-20T16:30:00+08:00")
	env.SetStartTime(startTime)
	env.ExecuteWorkflow(testWorkflow)

	s.True(env.IsWorkflowCompleted())
	err := env.GetWorkflowError()
	s.NoError(err)

	s.Equal(4, failedCount)
	s.Equal(4, successCount)
	s.Equal(4, lastCompletionResult)
}
```

Then you can run it with `go test -run "TestUnitTestSuite/Test_CronChildWorkflowWithParentPolicyAbandon"` in `sdk-go/internal`

## Specifications

  - Version: v1.11.0
  - Platform: Mac v11.6


#### Comments (5)

<details>
<summary><strong>cretz</strong> commented on 2021-11-02 12:59:45.000 UTC</summary>

To clarify, you are saying that when using abandon in a non-test it is expected to wait until fired and not be related to parent closing, but in a test scenario it should relate to parent closing? How would the child be closed in a non-test scenario? Maybe there should be some way to terminate all workflows started by the test suite? Sorry if I am misunderstanding.

</details>

<details>
<summary><strong>tminusplus</strong> commented on 2021-11-02 16:16:45.000 UTC</summary>

For the non-test, yes that is my understanding. But to be clear, the main issue I am reporting is that within testsuite, if you run a child cron-job with PARENT_CLOSE_POLICY_ABANDON the test will run forever until it hits a time-out, in which case it panics.

I'm not sure what the best or intended behavior should be for testsuite, but I am hoping that we can find some method so that child cron-jobs with PARENT_CLOSE_POLICY_ABANDON can be tested without running forever.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-02 16:33:17.000 UTC</summary>

> but I am hoping that we can find some method so that child cron-jobs with PARENT_CLOSE_POLICY_ABANDON can be tested without running forever.

How about some kind of "close" or "terminate all" that will stop all workflows for the test environment regardless of how they were started?

</details>

<details>
<summary><strong>tszucs-stripe</strong> commented on 2021-11-08 23:17:43.000 UTC</summary>

That would be great, the only issue is that the blocking happens on `env.ExecuteWorkflow(testWorkflow)`. So maybe it would have to be done in a callback, or even some config to specify how many times a workflow may run.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-16 14:36:51.000 UTC</summary>

Note, this was introduced by https://github.com/temporalio/sdk-go/pull/471.

</details>


---

<a id="596"></a>

### #596: Compression data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/596 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-10-21 16:45:33.000 UTC (4y 2m ago) |
| **Updated** | 2021-10-26 17:17:09.000 UTC |
| **Closed** | 2021-10-26 16:57:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

Features required:

* Wraps an existing converter
* Customizable algorithm (even if we only support one at first)...pending sensible default
* Ability to set a min size at which, if the data is under that size, the compression will not occur (0 meaning always compress)...pending sensible default
* Must be able to just pass through data that was not compressed previously by the converter

#### Comments (5)

<details>
<summary><strong>bergundy</strong> commented on 2021-10-21 16:50:29.000 UTC</summary>

Should this compress the entire `Payloads` object or just a single `Payload`?
In the future we'll want to use custom data converters in places where we only accept a single `Payload`, a feature that's missing from the go SDK.
Let's take this into account.

@robholland can you please provide more information here, I know you've given this some thought.

</details>

<details>
<summary><strong>robholland</strong> commented on 2021-10-21 16:53:25.000 UTC</summary>

We can't easily use `Payloads` right now because we currently have no metadata for them, so we can't mark that it is compressed. For now it's best to use `Payload`. I'll be writing up my proposal for changes to these APIs soon.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2021-10-21 19:31:15.000 UTC</summary>

We could compress all of the separate `Payload`s into a single `Payload` and do the reverse when we decompress.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-21 19:49:39.000 UTC</summary>

We could do this (many to one, then one to many) if desired...I can even make that configurable, the question is whether there are commonly multiple payloads at once and whether that harms debugging since now the stored payload count won't match expected.

Also, this can be implemented generically/separately so that anyone can do the many-to-one/one-to-many wrapping.

Just let me know.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2021-10-22 14:07:20.000 UTC</summary>

Sure there are tradeoffs with either approach.
With the many to one approach we _might_ get better compression rates, depending on the payload data.

</details>


---

<a id="595"></a>

### #595: Expose health check on WorkflowClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/595 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-19 16:55:31.000 UTC (4y 2m ago) |
| **Updated** | 2022-05-06 14:58:35.000 UTC |
| **Closed** | 2022-05-06 14:58:35.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | enhancement, external dependency |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

Temporal SDK should expose a method like WorkflowServiceStubs#healthCheck or WorkflowServiceStubs#isHealthy that allows users to check if the WorkflowClient/WorkflowServiceStubs underlying channel / connection to Temporal server is healthy.
There were quite a bit of user requests for such a method from users for all SDKs.
Having this method on Stubs is preferable over WorkflowClient, because it's the lowest level abstraction on top of the channel and WorkflowClient can just fall back on the WorkflowServiceStubs method. But if the language doesn't have a wrapper for stubs (like Java does), this method may be on WorkflowClient.

Issues for other SDKs:
https://github.com/temporalio/sdk-java/issues/828
https://github.com/temporalio/sdk-node/issues/312

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-11-17 14:41:33.000 UTC</summary>

Waiting on SDK consensus here.

</details>

<details>
<summary><strong>guptamridul1809</strong> commented on 2022-03-29 12:15:20.000 UTC</summary>

 `// checkHealth checks service health using gRPC health check:
// https://github.com/grpc/grpc/blob/master/doc/health-checking.md
func checkHealth(connection grpc.ClientConnInterface, options ConnectionOptions) error {`

There is **checkHealth** method which is invoked at the time of client creation, but it is private (go.temporal.io/sdk@v1.12.0/internal/client.go)
It would be great if we can expose this method to public interface
will be helpful in observability and auto-recovery use-cases

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-03-29 14:37:40.000 UTC</summary>

@guptamridul1809 - This is no longer invoked on client creation in the current version (we invoke another call). But yes, this issue is for exposing that call to be called explicitly.

</details>


---

<a id="495"></a>

### #495: Calling `GetChildWorkflowExecution` for a mocked workflow in a test causes the runner to complete the child workflow.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/495 |
| **State** | OPEN |
| **Author** | jmoseley (Jeremy Moseley) |
| **Created** | 2021-07-23 18:29:45.000 UTC (4y 5m ago) |
| **Updated** | 2025-02-26 14:49:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

* Have a child and a parent workflow. The parent workflow does something interesting while the child is executing
* Inside the parent workflow, call `GetChildWorkflowExecution` to obtain the `runID` for the child
* Inside the parent sleep for some amount of time
* Inside of the parent workflow, after the sleep, use `.IsReady()` to determine if the child has completed or not
* In tests, use `OnWorkflow` to mock a child workflow, and use `.After` to delay completion some amount of time

## Expected Behavior

* The parent workflow should do the interesting work while the child is executing, and `IsReady == false` until the appropriate amount of time has elapsed.

## Actual Behavior

* The parent sees `IsReady() == true` immediately after calling `GetChildWorkflowExecution` and sleeping

## Steps to Reproduce the Problem

Here is a sample the reproduces the issue. The first test (without mocking the child) passes, the second does not.

```
package workflows_test

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/workflow"
)

func Workflow(ctx workflow.Context) (string, error) {
	logger := workflow.GetLogger(ctx)
	childWorkflowContext := workflow.WithChildOptions(ctx, workflow.ChildWorkflowOptions{
		WorkflowID: "child_workflow",
	})
	childWorkflowFuture := workflow.ExecuteChildWorkflow(childWorkflowContext, ChildWorkflow)

	var childWorkflowExecution workflow.Execution
	err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWorkflowExecution)
	if err != nil {
		logger.Error("Error getting child workflow execution")
		return "FAILURE", err
	}

	logger.Info("Got child workflow execution", "WorkflowID", childWorkflowExecution.ID, "RunID", childWorkflowExecution.RunID)

	workflow.Sleep(ctx, time.Minute*5)

	if childWorkflowFuture.IsReady() {
		logger.Error("Child workflow finished before activity")
		return "FAILURE", nil
	}

	activityContext := workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		ScheduleToCloseTimeout: time.Minute,
		StartToCloseTimeout:    time.Minute,
	})
	workflow.ExecuteActivity(activityContext, MyCoolActivity, childWorkflowExecution.RunID).Get(ctx, nil)
	logger.Info("Finished activity, waiting for child to finish.")

	err = childWorkflowFuture.Get(ctx, nil)
	if err != nil {
		logger.Error("Child workflow failed")
		return "FAILURE", err
	}

	logger.Info("Child workflow complete")

	return "SUCCESS", nil
}

func ChildWorkflow(ctx workflow.Context) (string, error) {
	workflow.Sleep(ctx, time.Hour*2)

	return "", nil
}

func MyCoolActivity(ctx context.Context, childWorkflowRunID string) error {
	fmt.Printf("Child Workflow: %s\n", childWorkflowRunID)

	return nil
}

type UnitTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite

	env *testsuite.TestWorkflowEnvironment
}

func (s *UnitTestSuite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()
}

func (s *UnitTestSuite) AfterTest(suiteName, testName string) {
	s.env.AssertExpectations(s.T())
}

// Test without mocking the child workflow.
func (s *UnitTestSuite) Test_SampleWorkflow_NoMockChild() {
	s.env.RegisterWorkflow(Workflow)
	s.env.RegisterWorkflow(ChildWorkflow)

	s.env.OnActivity(MyCoolActivity, mock.Anything, mock.Anything).Return(nil)

	s.env.ExecuteWorkflow(Workflow)

	s.True(s.env.IsWorkflowCompleted())
	s.NoError(s.env.GetWorkflowError())

	var result string
	s.env.GetWorkflowResult(&result)

	s.Equal(result, "SUCCESS")

	s.env.AssertExpectations(s.T())
}

// Test with mocking the child workflow.
func (s *UnitTestSuite) Test_SampleWorkflow_MockChild() {
	s.env.RegisterWorkflow(Workflow)
	s.env.RegisterWorkflow(ChildWorkflow)

	s.env.OnActivity(MyCoolActivity, mock.Anything, mock.Anything).Return(nil)
	s.env.OnWorkflow(ChildWorkflow, mock.Anything).After(time.Hour).Return(
		func(ctx workflow.Context) (string, error) {
			return "SUCCESS", nil
		},
	)

	s.env.ExecuteWorkflow(Workflow)

	s.True(s.env.IsWorkflowCompleted())
	s.NoError(s.env.GetWorkflowError())

	var result string
	s.env.GetWorkflowResult(&result)

	s.Equal(result, "SUCCESS")

	s.env.AssertExpectations(s.T())
}

func TestUnitTestSuite(t *testing.T) {
	suite.Run(t, new(UnitTestSuite))
}
```

## Specifications

  - Version: v1.8.0
  - Platform: go-sdk


#### Comments (5)

<details>
<summary><strong>jmoseley</strong> commented on 2021-07-23 19:38:48.000 UTC</summary>

Just made a small update, the reproduction was not quite right.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-07-26 05:38:36.000 UTC</summary>

Thanks for reporting the issue and including a repro, we are going to look at it soon.

</details>

<details>
<summary><strong>rupalivohra</strong> commented on 2021-10-22 16:40:19.000 UTC</summary>

Hey @vitarb - Is there an eta for this to be addressed?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-09-25 18:30:18.000 UTC</summary>

I'll note this issue can be worked around by not using `OnWorkflow`, instead register your own "mock" workflow

instead of this
```
s.env.RegisterWorkflow(ChildWorkflow)
s.env.OnWorkflow(ChildWorkflow, mock.Anything).After(time.Hour).Return(
  func(ctx workflow.Context) (string, error) {
	  return "SUCCESS", nil
  },
)
```

register your own
```
env.RegisterWorkflowWithOptions(func(ctx workflow.Context) (string, error) {
	workflow.Sleep(ctx, time.Hour)
         return "SUCCESS", nil
}, workflow.RegisterOptions{
  Name: "ChildWorkflow",
})
```




</details>

<details>
<summary><strong>dibrito</strong> commented on 2025-02-26 14:49:12.000 UTC</summary>

Try something like:

`    s.env.OnWorkflow(ChildWorkflow, mock.Anything).Return(testsuite.ErrMockStartChildWorkflowFailed)`

to simulate a failure in starting the child workflow.

RegisterWorkflowWithOptions didn't work for me.


</details>


---

<a id="433"></a>

### #433: Test environment `RegisterDelayedCallback()` with 0 duration which performs a query crashes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/433 |
| **State** | CLOSED |
| **Author** | vkarpov15 (Valeri Karpov) |
| **Created** | 2021-05-06 18:45:30.000 UTC (4y 8m ago) |
| **Updated** | 2021-07-02 16:34:28.000 UTC |
| **Closed** | 2021-07-02 16:34:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior

Consider the below test:

```javascript
func (s *UnitTestSuite) Test_AddToCart() {
	cart := CartState{Items: make([]CartItem, 0)}

	s.env.RegisterDelayedCallback(func() {
		// suite.go:63: test panicked: runtime error: invalid memory address or nil pointer dereference
		res, err := s.env.QueryWorkflow("getCart")
		s.NoError(err)
		err = res.Get(&cart)
		s.NoError(err)
		s.Equal(len(cart.Items), 0)

		update := AddToCartSignal{
			Route: RouteTypes.ADD_TO_CART,
			Item: CartItem{ProductId: 1, Quantity: 1},
		}
		s.env.SignalWorkflow("cartMessages", update)
		fmt.Println(cart.Items)
	}, time.Millisecond*0)

	s.env.ExecuteWorkflow(CartWorkflow, cart)

	res, err := s.env.QueryWorkflow("getCart")
	s.NoError(err)
	err = res.Get(&cart)
	s.NoError(err)
	s.Equal(1, len(cart.Items))

	s.True(s.env.IsWorkflowCompleted())
}
```

I expect this test to succeed. Full code is available in this PR: https://github.com/temporalio/temporal-ecommerce/pull/5

## Actual Behavior

I get a runtime error that points to what looks like [this line](https://github.com/temporalio/sdk-go/blob/3b9239055da4692f37fb16351c924217a688a489/internal/internal_workflow_testsuite.go#L2217). Below is the full stack trace:

```
$ go test
2021/05/06 14:36:04 DEBUG Auto fire timer TimerID 0 TimerDuration 87600h0m0s TimeSkipped 87600h0m0s
--- FAIL: TestUnitTestSuite (0.00s)
    --- FAIL: TestUnitTestSuite/Test_AddToCart (0.00s)
        suite.go:63: test panicked: runtime error: invalid memory address or nil pointer dereference
            goroutine 21 [running]:
            runtime/debug.Stack(0xc000213400, 0xedf4a0, 0x16f65b0)
            	/usr/local/go/src/runtime/debug/stack.go:24 +0x9f
            github.com/stretchr/testify/suite.failOnPanic(0xc000103380)
            	/home/val/go/pkg/mod/github.com/stretchr/testify@v1.7.0/suite/suite.go:63 +0x57
            panic(0xedf4a0, 0x16f65b0)
            	/usr/local/go/src/runtime/panic.go:969 +0x1b9
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).queryWorkflow(0xc000103680, 0x101d289, 0x7, 0x0, 0x0, 0x0, 0xc00049c000, 0xc00049c000, 0x203000, 0x20)
            	/home/val/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_workflow_testsuite.go:2211 +0x9d
            go.temporal.io/sdk/internal.(*TestWorkflowEnvironment).QueryWorkflow(...)
            	/home/val/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/workflow_testsuite.go:714
            temporal-ecommerce/app.(*UnitTestSuite).Test_AddToCart.func1()
            	/home/val/Workspace/meanIT/temporal-ecommerce/workflow_test.go:38 +0x78
            go.temporal.io/sdk/internal.(*testCallbackHandle).processCallback(0xc0002137a0)
            	/home/val/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_workflow_testsuite.go:691 +0x77
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).startMainLoop(0xc000103680)
            	/home/val/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_workflow_testsuite.go:650 +0xd9
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal(0xc000103680, 0x0, 0x168af3f, 0xc, 0xc000471720)
            	/home/val/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_workflow_testsuite.go:493 +0x21a
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflow(0xc000103680, 0xeb9440, 0x106aa50, 0xc0004378d0, 0x1, 0x1)
            	/home/val/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_workflow_testsuite.go:437 +0x119
            go.temporal.io/sdk/internal.(*TestWorkflowEnvironment).ExecuteWorkflow(...)
            	/home/val/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/workflow_testsuite.go:487
            temporal-ecommerce/app.(*UnitTestSuite).Test_AddToCart(0xc0001290e0)
            	/home/val/Workspace/meanIT/temporal-ecommerce/workflow_test.go:55 +0x20a
            reflect.Value.call(0xc000483620, 0xc0001270e8, 0x13, 0x101a265, 0x4, 0xc00006ce30, 0x1, 0x1, 0xc00006ccf8, 0x40d34a, ...)
            	/usr/local/go/src/reflect/value.go:476 +0x8c7
            reflect.Value.Call(0xc000483620, 0xc0001270e8, 0x13, 0xc00006ce30, 0x1, 0x1, 0x24, 0xc00005ae50, 0x456354)
            	/usr/local/go/src/reflect/value.go:337 +0xb9
            github.com/stretchr/testify/suite.Run.func1(0xc000103380)
            	/home/val/go/pkg/mod/github.com/stretchr/testify@v1.7.0/suite/suite.go:158 +0x379
            testing.tRunner(0xc000103380, 0xc00020ad80)
            	/usr/local/go/src/testing/testing.go:1123 +0xef
            created by testing.(*T).Run
            	/usr/local/go/src/testing/testing.go:1168 +0x2b3
FAIL
exit status 1
FAIL	temporal-ecommerce/app	0.005s
```

If I remove the `Select()` call from the workflow, I don't get this error. I also don't get this error if I query the workflow outside of `RegisterDelayedCallback()`

## Steps to Reproduce the Problem

  1. Clone https://github.com/temporalio/temporal-ecommerce
  1. `cd temporal-ecommerce`
  1. `go test`

## Specifications

  - Version: 1.6.0
  - Platform: Xubuntu 18.04


#### Comments (5)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-10 07:21:24.000 UTC</summary>

Thanks for the report. I'm a little confused, I don't see Select in your code, neither in the sample you've provided in the description nor in your PR. Could you clarify please?

</details>

<details>
<summary><strong>vkarpov15</strong> commented on 2021-05-10 18:57:49.000 UTC</summary>

Yeah,  the `Select()` call is in [`workflow.go`](https://github.com/temporalio/temporal-ecommerce/blob/75637b7478b27018a8dfa766945b29f1710ee656/workflow.go#L132), the file that's being tested. Below is a simplified version:

```go
func CartWorkflow(ctx workflow.Context, state CartState) error {
	logger := workflow.GetLogger(ctx)

	err := workflow.SetQueryHandler(ctx, "getCart", func(input []byte) (CartState, error) {
		return state, nil
	})
	if err != nil {
		logger.Info("SetQueryHandler failed.", "Error", err)
		return err
	}

	channel := workflow.GetSignalChannel(ctx, SignalChannelName)
	checkedOut := false
	sentAbandonedCartEmail := false

	for {
		selector := workflow.NewSelector(ctx)
		selector.AddReceive(channel, func(c workflow.ReceiveChannel, _ bool) {
			var signal interface{}
			c.Receive(ctx, &signal)

			var routeSignal RouteSignal
			err := mapstructure.Decode(signal, &routeSignal)
			if err != nil {
				logger.Error("Invalid signal type %v", err)
				return
			}

			// Handle routeSignal
		})

		if !sentAbandonedCartEmail && len(state.Items) > 0 {
			selector.AddFuture(workflow.NewTimer(ctx, abandonedCartTimeout), func(f workflow.Future) {
				sentAbandonedCartEmail = true
				ao := workflow.ActivityOptions{
					ScheduleToStartTimeout: time.Minute,
					StartToCloseTimeout:    time.Minute,
				}

				ctx = workflow.WithActivityOptions(ctx, ao)

				err := workflow.ExecuteActivity(ctx, SendAbandonedCartEmail, state.Email).Get(ctx, nil)
				if err != nil {
					logger.Error("Error sending email %v", err)
					return
				}
			})
		}

		selector.Select(ctx) // <-- `Select()` here

		if checkedOut {
			break
		}
	}

	return nil
}
```

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-05-17 22:31:42.000 UTC</summary>

@vkarpov15 Dug into this and it is a bug with the test environment for sure. 0 duration on `RegisterDelayedCallback` will always break if you try to query inside of it because of a bug where the query handler isn't registered yet. I'll fix this. In the meantime, using any nonzero duration unblocks you.

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-05-17 23:22:15.000 UTC</summary>

@vkarpov15 Spoke with Max, we decided to update the docstring - supporting this in the test framework would require significant change and it's not really something you could do in the real world in any case, since there's no `QueryWithStart` sort of functionality (which probably wouldn't be very useful anyway).

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-07-02 16:34:27.000 UTC</summary>

Think we can close this now

</details>


---

<a id="421"></a>

### #421: [Bug] 13 INTERNAL: Failed to parse server response when local activity has only error return parameter and returns nil

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/421 |
| **State** | CLOSED |
| **Author** | nirshirion (Nir Shirion) |
| **Created** | 2021-03-11 11:08:21.000 UTC (4y 10m ago) |
| **Updated** | 2021-05-07 07:09:05.000 UTC |
| **Closed** | 2021-05-07 07:09:05.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Describe the bug**
When running a workflow with a local activity that has only an error return parameter, and the local activity returns nil, the web UI can't show the workflow and shows this error:
13 INTERNAL: Failed to parse server response

When using the cli to show to show the workflow history, it shows it properly.

**To Reproduce**
Steps to reproduce the behavior:
1. Run a workflow with the above conditions:

```
func Workflow(ctx workflow.Context, name string) (string, error) {
	ao := workflow.LocalActivityOptions{
		ScheduleToCloseTimeout: time.Minute,
		StartToCloseTimeout:    time.Minute,
	}
	ctx = workflow.WithLocalActivityOptions(ctx, ao)

	err := workflow.ExecuteLocalActivity(ctx, Activity).Get(ctx, nil)
	if err != nil {
		return "", err
	}

	return "", nil
}

func Activity(ctx context.Context) error {
	return nil
}
```

2. Go to web UI, open workflow and see the error.

**Expected behavior**
The workflow history should be presented in the UI

**Screenshots**
<img width="1422" alt="Screen Shot 2021-03-11 at 12 58 49" src="https://user-images.githubusercontent.com/10175874/110777501-da440580-8269-11eb-83d8-d76d0edacdcb.png">

 - Browser: Chrome
 - Temporal Web Version: 1.7.0
 - Tctl Version: 1.7.0


#### Comments (3)

<details>
<summary><strong>feedmeapples</strong> commented on 2021-04-29 21:49:39.000 UTC</summary>

thanks for filing,
There was a similar issue filed before https://github.com/temporalio/web/issues/306

To fix this, i made a change in sdk-go to address it. It was released in sdk-go v1.5.0 addressed this

We are also discussing  server side approach to address this

</details>

<details>
<summary><strong>samarabbas</strong> commented on 2021-04-29 21:55:37.000 UTC</summary>

We need to revisit the fix we made in https://github.com/temporalio/sdk-go/pull/367/files

</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-04-29 22:52:05.000 UTC</summary>

for ref, here is the original same issue #365 

</details>


---

<a id="61"></a>

### #61: Remove mocks package

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/61 |
| **State** | OPEN |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-03-13 19:43:07.000 UTC (5y 10m ago) |
| **Updated** | 2024-12-17 21:17:40.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 1 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

`mocks` package uses `mockery` and we are using `gomocks` everywhere else. Mocks can be easily generated by customers using `mockgen` tool from `gomocks` framework.



#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2020-03-21 01:49:45.000 UTC</summary>

Apparently this is not as easy as it looks. Good issues to start with:
https://github.com/uber-go/cadence-client/pull/929
https://github.com/uber-go/cadence-client/issues/928

</details>


---

<a id="2065"></a>

### #2065: NewTestActivityEnvironment no longer implements worker.ActivityRegistry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2065 |
| **State** | OPEN |
| **Author** | kylelemons (Kyle Lemons) |
| **Created** | 2025-10-02 21:31:26.000 UTC (3 months ago) |
| **Updated** | 2025-10-03 23:16:41.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Example code:

```go
	suite := testsuite.WorkflowTestSuite{}

	act := suite.NewTestActivityEnvironment()

	// This used to work:
	var reg worker.ActivityRegistry = act
	// Now it gets:
	//	 Cannot use act (type *TestActivityEnvironment) as the type worker.ActivityRegistry
	//	 Type does not implement worker.ActivityRegistry as some methods are missing:
	//	   RegisterDynamicActivity(a interface{}, options activity.DynamicRegisterOptions)

	var myActivity any
	reg.RegisterActivity(myActivity)

	res, err := act.ExecuteActivity(myActivity, "input")
	if err != nil {
		t.Fatalf("ExecuteActivity: %s", err)
	}

	var output any
	if err := res.Get(&output); err != nil {
		t.Fatalf("Getting result %T: %s", output, err)
	}
```

## Expected Behavior

This code should compile and execute.  Obviously nobody would write the code above, but we have our own abstractions that make use of the `worker.ActivityRegistry` interface, and the `NewTestActivityEnvironment` no longer implements it.  `NewTestWorkflowEnvironment` does, but that doesn't have the `ExecuteActivity` functionality.

## Actual Behavior

This works with `go.temporal.io/sdk v1.34.0` but breaks with `v1.35.0` and `v1.36.0`.  This was a breaking change to the `ActivityRegistry` interface (and I suspect to the `WorkerRegistry` interface as well).

## Steps to Reproduce the Problem

  1. Add the code above to a unit test
  1. `go get go.temporal.io/sdk@v1.34.0` and observe that it compiles
  1. `go get go.temporal.io/sdk@v1.35.0` (or later) and observe that it fails to compile

## Specifications

  - Version: `go.temporal.io/sdk@v1.36.0`
  - Platform: Mac OS, Linux


#### Comments (2)

<details>
<summary><strong>yuandrew</strong> commented on 2025-10-02 22:16:10.000 UTC</summary>

Thanks for the GH issue! Like you mentioned, this is similar to #2006. A compile check can be added to keep this relationship. Marking this as an enhancement, since I don't think we originally intended on having `NewTestActivityEnvironment` implement the `ActivityRegistry` interface, but might as well keep it now that it does.

</details>

<details>
<summary><strong>kylelemons</strong> commented on 2025-10-03 22:59:41.000 UTC</summary>

Something similar came up in
* https://github.com/temporalio/sdk-go/issues/1610

I think the root cause of all three issues is [returning interfaces, not concrete types](https://google.github.io/styleguide/go/decisions#interfaces), since it is [considered a breaking change](https://go.dev/blog/module-compatibility#working-with-interfaces) to add a method to a public interface.  If you are ever planning a v2 of this module (or if it's better to make "just one more" breaking change to prevent accidentally making many more), I think switching to concrete types would help avoid this class of problems.

More generally, I think I would recommend classing "breaking changes" as bugs, since they (can) manifest downstream as compile errors.

There is a tool that you can use in CI to detect incompatible changes:

<details>
<summary>gorelease output</summary>

```
â¯ go run golang.org/x/exp/cmd/gorelease@latest -base=v1.34.0
# go.temporal.io/sdk/activity
## compatible changes
DynamicRegisterOptions: added
ErrActivityReset: added

# go.temporal.io/sdk/client
## incompatible changes
Client.DescribeWorkflow: added
## compatible changes
AutoUpgradeVersioningOverride: added
PinnedVersioningOverride: added
VersioningOverrideChange: added
WorkflowExecutionDescription: added
WorkflowExecutionMetadata: added

# go.temporal.io/sdk/interceptor
## compatible changes
ClientDescribeWorkflowInput: added
ClientDescribeWorkflowOutput: added

# go.temporal.io/sdk/mocks
## compatible changes
(*Client).DescribeWorkflow: added

# go.temporal.io/sdk/temporal
## incompatible changes
SDKVersion: value changed from "1.34.0" to "1.36.0"
## compatible changes
ApplicationErrorCategory: added
ApplicationErrorCategoryBenign: added
ApplicationErrorCategoryUnspecified: added

# go.temporal.io/sdk/temporalnexus
## incompatible changes
NewSyncOperation: removed
## compatible changes
GetOperationInfo: added
IsNexusOperation: added
OperationInfo: added

# go.temporal.io/sdk/testsuite
## compatible changes
DevServerOptions.SearchAttributes: added

# go.temporal.io/sdk/worker
## incompatible changes
ActivityRegistry.RegisterDynamicActivity: added
WorkflowRegistry.RegisterDynamicWorkflow: added
WorkflowReplayer.RegisterDynamicWorkflow: added
## compatible changes
NewPollerBehaviorAutoscaling: added
NewPollerBehaviorSimpleMaximum: added
PollerBehavior: added
PollerBehaviorAutoscalingOptions: added
PollerBehaviorSimpleMaximumOptions: added
WorkerDeploymentVersion: added

# go.temporal.io/sdk/workflow
## compatible changes
DynamicRegisterOptions: added
DynamicRuntimeOptions: added
LoadDynamicRuntimeOptionsDetails: added
NexusOperationCancellationType: added
NexusOperationCancellationTypeAbandon: added
NexusOperationCancellationTypeTryCancel: added
NexusOperationCancellationTypeUnspecified: added
NexusOperationCancellationTypeWaitCompleted: added
NexusOperationCancellationTypeWaitRequested: added

# summary
Cannot suggest a release version.
Incompatible changes were detected.

exit status 1
```

</details>

</details>


---

<a id="2027"></a>

### #2027: Workflowcheck does not compile with go1.25.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2027 |
| **State** | CLOSED |
| **Author** | azdagron (Andrew Harding) |
| **Created** | 2025-08-21 19:10:55.000 UTC (4 months ago) |
| **Updated** | 2025-08-27 18:46:36.000 UTC |
| **Closed** | 2025-08-27 18:46:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Installation instructions work with `go1.25.0`, e.g. `go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest`

## Actual Behavior

```
$ go version
go version go1.25.0 darwin/arm64

$ go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest
# golang.org/x/tools/internal/tokeninternal
../../go/pkg/mod/golang.org/x/tools@v0.25.0/internal/tokeninternal/tokeninternal.go:64:9: invalid array length -delta * delta (constant -256 of type int64)
```


## Steps to Reproduce the Problem

  1. Install go1.25
  1. Run `go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest

## Specifications

  - Version: 0.3.0 and latest
  - Platform: darwin/arm64


#### Comments (4)

<details>
<summary><strong>yuandrew</strong> commented on 2025-08-21 21:07:34.000 UTC</summary>

Thanks for the report! Looks like we're hitting https://github.com/golang/go/issues/74462. Will need to bump up our version of golang.org/x/tools

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-08-21 21:54:19.000 UTC</summary>

Looks like `master` already has this resolved, once the next Go release happens, `go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest` should be fixed

</details>

<details>
<summary><strong>azdagron</strong> commented on 2025-08-27 14:07:04.000 UTC</summary>

Thanks! When will the next workflowcheck release happen? It is its own go module, so a new contrib/tools/workflowcheck tag needs to be created. The last one was around 7 months ago.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-27 18:46:36.000 UTC</summary>

Pushed a new version of `workflowcheck` that uses an updated version of `x/tools` https://github.com/temporalio/sdk-go/releases/tag/contrib%2Ftools%2Fworkflowcheck%2Fv0.4.0

</details>


---

<a id="1976"></a>

### #1976: ContinueAsNew should create new root span

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1976 |
| **State** | OPEN |
| **Author** | bincyber (Ali) |
| **Created** | 2025-06-17 12:57:32.000 UTC (6 months ago) |
| **Updated** | 2025-07-20 06:02:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Currently, when tracing is enabled on a workflow that ends as ContinueAsNew, the new workflow is attached to the existing trace:

![Image](https://github.com/user-attachments/assets/484f2596-a3dc-4717-8f44-8b1f2ffeccda)

![Image](https://github.com/user-attachments/assets/6cb593ad-e99f-4af1-b5bd-85852b4ec4c7)

The total number of spans can become extremely large and overwhelm the tracing backend (eg, Grafana Tempo, Jaeger, etc.).

**Describe the solution you'd like**

It would be better if the new workflow was created as a new, disconnected trace and linked to the existing trace:

![Image](https://github.com/user-attachments/assets/467ba69e-7f02-4c19-b0df-df5153efe6c5)

![Image](https://github.com/user-attachments/assets/6fa06466-f1e6-4a98-a425-ecd6be927eb2)

This idea can be extended to disconnecting Child Workflows as well.

**Additional context**

Slack: https://temporalio.slack.com/archives/CTDTU3J4T/p1702921125553459

#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-17 14:55:44.000 UTC</summary>

Added a note to discuss this internally across the other SDKs to see what/if they do to support this

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-25 18:11:46.000 UTC</summary>

Looking at some other SDKs they don't provide any convenient option for this. There are a lot of reasons we could want to create a disconnected span , like continue as new, or as you said a child workflow. Some other reasons brought up are Cron and schedules. A user may also only want to disconnect them if the size if growing particularly large or for certain workflow types. These are to many options to support simple booleans for.

For the most flexibility I wonder if we should just expose the ability to get the otel span from the workflow context, then users can interact with the span like they do outside of workflow code.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-25 18:12:39.000 UTC</summary>

Users can then develop their own interceptors for common cases like disconnect spans on continue as new

</details>

<details>
<summary><strong>ohad83</strong> commented on 2025-07-20 06:02:39.000 UTC</summary>

I encountered a similar error (in my case for child workflows). If using the otel tracing interceptor you could pass a custom`SpanStarter` to do that. This is the one I created:
```
	if strings.HasPrefix(spanName, "RunWorkflow:") && trace.SpanFromContext(ctx).SpanContext().IsValid() {
		opts = append(opts,
			trace.WithNewRoot(), trace.WithLinks(trace.LinkFromContext(ctx)),
		)
	}
	_, span := t.Start(ctx, spanName, opts...)
	return span
```

It's not perfect since the link is unidirectional, so the child is linked to the parent but the parent isn't linked to the child (afaik it can't be, since the `ExecuteChildWorkflow` span finishes before the `RunWorkflow` one starts). It also means you won't see the duration of the child workflow in the parent trace, since the `ExecuteChildWorkflow` is short.

It might be possible to wrap each `RunWorkflow` in 2 spans, one in the parent trace and one as the root span of a child trace, and link them, and also only finish the one in the parent when the child finishes. It requires a bit more tinkering but I think it's possible without fully implementing a new interceptor.

</details>


---

<a id="1895"></a>

### #1895: Support simulating race conditions during signal draining

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1895 |
| **State** | OPEN |
| **Author** | joshmsmith (Joshua Smith) |
| **Created** | 2025-03-27 21:30:21.000 UTC (9 months ago) |
| **Updated** | 2025-05-07 13:01:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I was helping a customer writing tests for go workflows processing signals - I didn't know how to get complete test coverage to ensure the signal draining code gets covered tested. 
Asked @mfateev: he suggested creating this feature request to support simulating race conditions during signal draining.

**Describe the solution you'd like**
Would love a way for Go SDK to support simulating race conditions during signal draining. Perhaps useful for other SDKs.

**Describe alternatives you've considered**
Skipping testing this race condition is probably good enough for now.




#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-27 21:43:33.000 UTC</summary>

Can you elaborate what you mean by a "race condition" during signal draining? Also why is this only specific to the Go SDK?

</details>

<details>
<summary><strong>joshmsmith</strong> commented on 2025-03-28 14:05:50.000 UTC</summary>

I can share what I know, hoping Max can share more context.
The struggle I was having with the customer was that trying to get 100% code coverage - including the signal draining part - is hard to do because it's a tight time window that the signal drain needs to run, and hard at least for me to get signals in to trigger the draining in a test. I think the goal here is to be able to send signals to be drained in a test. I think that's why it's harder in the go SDK, in other SDKs signals work differently. Does that help?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-28 15:08:35.000 UTC</summary>

>it's a tight time window that the signal drain needs to run, and hard at least for me to get signals in to trigger the draining in a test.

In the test environment you have full control over the timing and when things advance so if you know the workflow code you should be able to cause a race. Maybe an example workflow you had difficulty testing would help illustrate the problem? I am not sure how the test environment could know when to inject a signal to cause a race since it can't read your workflow code or predicted how it will execute.


>I think the goal here is to be able to send signals to be drained in a test. I think that's why it's harder in the go SDK, in other SDKs signals work differently. Does that help?

They are a bit different, but I don't know if that really matters here. Signals are sent by a queue in Go, but the race condition exists in all SDKs and is not easily testable in any SDK so I don't think this is Go specific problem or harder in Go then other SDKs. Might be easier in Go since the test environment in Go gives more control over execution then other SDKs do.


One idea is maybe the SDK can warn you if you do not check any signal channel in the last workflow task? If you are not checking a signal channel in the last workflow task you risk dropping a signal. How does that sound?

</details>

<details>
<summary><strong>joshmsmith</strong> commented on 2025-05-07 13:01:18.000 UTC</summary>

I think @mfateev had some other ideas, maybe he can share them here?

> One idea is maybe the SDK can warn you if you do not check any signal channel in the last workflow task? If you are not checking a signal channel in the last workflow task you risk dropping a signal. How does that sound?

I like that idea a lot actually.


</details>


---

<a id="1840"></a>

### #1840: Activities with the same name from different struct methods are treated and handled as the same.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1840 |
| **State** | CLOSED |
| **Author** | adetunjii (Samuel Adetunji) |
| **Created** | 2025-02-16 13:53:58.000 UTC (10 months ago) |
| **Updated** | 2025-02-20 23:42:53.000 UTC |
| **Closed** | 2025-02-20 23:42:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The different methods mapped to different activities should be triggered when their corresponding activities are triggered.

## Actual Behavior
When an activity is triggered, the first registered activity with the same name is triggered as opposed to the one registered with the activity.

## Steps to Reproduce the Problem
```go
package main

import (
	"log"

	"github.com/playground/temporal/activityA"
	"github.com/playground/temporal/activityB"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

func main() {
	c, err := client.Dial(client.Options{})
	if err != nil {
		log.Fatal("Failed to create Temporal client:", err)
	}
	defer c.Close()

	w := worker.New(c, "task-queue", worker.Options{})
	w.RegisterWorkflow(UserWorkflow)
	w.RegisterActivity(activityA.PerformActivity)
	w.RegisterActivity(activityB.PerformActivity)
}

## Specifications
  - Version: 1.2.0
  - Platform: Linux/amd64


#### Comments (4)

<details>
<summary><strong>peixotoleonardo</strong> commented on 2025-02-16 16:10:41.000 UTC</summary>

![Image](https://github.com/user-attachments/assets/8465fafa-e8ea-4fba-8d0b-0e6ab412e233)

I believe this is not a bug, as the comments for the [RegisterActivity ](https://github.com/temporalio/sdk-go/blob/f22335976ca6a58d75196d464a4ee083bfece3ff/worker/worker.go#L109) method state that the default name of the activity will be the name of the method. What you can do is either set the name of the activity manually or change the method name so that it does not match the activity name.



</details>

<details>
<summary><strong>peixotoleonardo</strong> commented on 2025-02-16 16:15:59.000 UTC</summary>

To improve DevEx we can validate if the name has already been registered and report this as a [panic](https://github.com/temporalio/sdk-go/blob/f22335976ca6a58d75196d464a4ee083bfece3ff/internal/internal_worker.go#L620) as is done when you pass a name option with an empty string


</details>

<details>
<summary><strong>adetunjii</strong> commented on 2025-02-17 15:17:52.000 UTC</summary>

> To improve DevEx we can validate if the name has already been registered and report this as a [panic](https://github.com/temporalio/sdk-go/blob/f22335976ca6a58d75196d464a4ee083bfece3ff/internal/internal_worker.go#L620) as is done when you pass a name option with an empty string

This would be good for DevEx. I spent hours trying to figure out what the issue might be as a newbie to temporal. I can raise a PR for this if the issue would be assigned to me. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-20 23:42:52.000 UTC</summary>

Yes this is all intentional the default name of the activity will be the name of the method and the default behaviour is to ignore duplication. Changing the default behaviour is not a backwards compatible change. If you want to disable it you can set `RegisterActivityOptions.DisableAlreadyRegisteredCheck`

</details>


---

<a id="1716"></a>

### #1716: Make it possible to keep workflows in worker cache also if they're only queried

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1716 |
| **State** | OPEN |
| **Author** | recht (Joakim Recht) |
| **Created** | 2024-11-19 22:15:46.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-02 23:02:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Currently, when sending a query to a workflow that is in running state but not active on any worker, a worker will receive the request, replay history, process the query, and forget everything again. On next query the same thing happens. This is in contrast to starting the workflow from scratch without restarting the worker. Then the workflow is in the worker cache, ready to serve queries. Same if the worker has restarted, but workflow state has changed so that the workflow got loaded into the cache.

Because replays can get a bit expensive, especially if encryption/offloading codecs are used (which we do), it would be nice if querying a workflow would add it to the worker sticky cache.

**Describe the solution you'd like**
A config property that allows us to specify that workflows that are queried should also be inserted into the cache.

While debugging locally I did this:
```
diff --git a/internal/internal_task_handlers.go b/internal/internal_task_handlers.go
index 8312587..342f7f4 100644
--- a/internal/internal_task_handlers.go
+++ b/internal/internal_task_handlers.go
@@ -812,7 +812,7 @@ func (wth *workflowTaskHandlerImpl) GetOrCreateWorkflowContext(
                        return
                }
 
-               if wth.cache.MaxWorkflowCacheSize() > 0 && task.Query == nil {
+               if wth.cache.MaxWorkflowCacheSize() > 0 {
                        workflowContext, _ = wth.cache.putWorkflowContext(runID, workflowContext)
                        workflowContext.Lock()
                        workflowContext.cached = true
```

It's unclear if that's the right solution or if that has other unintended consequences, but at least it keeps the workflow in the sticky worker cache, making queries much faster.

**Describe alternatives you've considered**
Doing less queries, or faster codecs. Regardless, it seems wasteful to have to replay on every single query.


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-20 16:36:55.000 UTC</summary>

I believe this is a limitation on the server. Query only tasks cannot set the sticky cache attribute so the worker cache would not actually be used even if the SDK did keep it in cache. There is an [issue](https://github.com/temporalio/temporal/issues/4463) to add this feature on the server side, once this is closed the SDK could keep the workflow in cache.

</details>

<details>
<summary><strong>recht</strong> commented on 2024-11-20 18:23:08.000 UTC</summary>

Ok, thanks - so I guess the only reason why it made any difference for me was that I was only running a single worker so queries always went to that worker?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-02 15:30:25.000 UTC</summary>

There are multiple ways a query can be delivered to a workflow, if the worker was already in the cache it will be used. The problem is direct queries cannot add the workflow to the sticky task queue so the server would always send the whole history down again causing a replay.

</details>

<details>
<summary><strong>recht</strong> commented on 2024-12-02 23:02:02.000 UTC</summary>

Ok, but with the change I tried there was no replay after the first query - it's possible that the worker receives all the data, but it doesn't actually replay (checked by adding print statements in the workflow code and observing with and without the change)

</details>


---

<a id="1701"></a>

### #1701: go.temporal.io/sdk/contrib/datadog to provide way to access DataDog spans from within a workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1701 |
| **State** | CLOSED |
| **Author** | cdimitroulas (Christos Dimitroulas) |
| **Created** | 2024-11-04 17:03:02.000 UTC (1y 2m ago) |
| **Updated** | 2024-11-22 14:47:40.000 UTC |
| **Closed** | 2024-11-22 14:47:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
In order to be able to access spans from `workflow.Context` to be able to do things like add custom tags, it would be helpful if the `go.temporal.io/sdk/contrib/datadog/tracing` package exported `TracerSpan` and allowed setting a custom `SpanContextKey` in the tracer options.

This would enable code like the following to be written:
```go
// Assuming the following import:
// import 	"go.temporal.io/sdk/contrib/datadog/tracing"

val := ctx.Value("my_custom_context_key")
if val == nil {
	return
}

span := *val.(*tracing.TracerSpan)
span.SetTag("myCustomTag", myCustomValue)
```

**Describe the solution you'd like**
go.temporal.io/sdk/contrib/datadog to export the TracerSpan struct (currently named `tracerSpan` so it isn't exported) and allow custom SpanContextKey in the `TracerOptions` struct.

I have prepared some changes that solve this for my particular use-case which you can see here. Happy to open a PR if you agree that this feature makes sense for the library:
https://github.com/temporalio/sdk-go/compare/master...cdimitroulas:temporal-sdk-go:christos/export-datadog-tracer-span-struct?expand=1

The customization of the context key is the same as what the OpenTelemetry tracing interceptor provides:
- https://github.com/temporalio/sdk-go/blob/master/contrib/opentelemetry/tracing_interceptor.go#L80

**Describe alternatives you've considered**
I was not able to find an alternative solution that supports this use-case.

**Additional context**
N/A


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-13 00:06:17.000 UTC</summary>

I think the feature ask here is totally resonable, I am not sure I agree with the approach. `tracerSpan` is an internal struct an not intended to be exposed. Really want you want to access is the underlying `ddtrace.Span`. The `datadog` API allows extracting the span from the `context` by calling `tracer.SpanFromContext`, the Temporal datadog interceptor could provide a similar API to extract the span from a `workflow.Context`. 

That approach would make supporting a custom `SpanContextKey` difficult/impossible so the Temporal team still needs to discuss these tradeoffs.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-13 22:43:09.000 UTC</summary>

Discussion it seems like the preferred option is to add a function like `func SpanFromWorkflowContext(ctx workflow.Context) (Span, bool)` to https://github.com/temporalio/sdk-go/tree/master/contrib/datadog. That would allow you to get the datadog `Span` from a workflow function using a similar API to the activity.

</details>

<details>
<summary><strong>cdimitroulas</strong> commented on 2024-11-15 10:55:50.000 UTC</summary>

That makes sense, thanks for getting back to me and discussing with the team. Would you like me to take a stab at implementing this `SpanFromWorkflowContext` function @Quinn-With-Two-Ns?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-15 15:45:31.000 UTC</summary>

Sure, contributions always welcome!

</details>


---

<a id="1689"></a>

### #1689: TestWorkflowEnvironment has non-standard RunID "default-test-run-id"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1689 |
| **State** | CLOSED |
| **Author** | askreet (Kyle Smith) |
| **Created** | 2024-10-27 10:53:07.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-30 16:55:41.000 UTC |
| **Closed** | 2024-10-30 16:55:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The below is based on an assumption I have that Run IDs are expected to always be UUIDs provided by the Temporal engine. We've recently been storing records in our database using the Run ID of workflows and our RDBMS's native UUID column type.

Note that I poked around and couldn't find an easy way to override this value in my test case, but if I've missed it please let me know!

## Expected Behavior

The Workflow object obtainable from within an Activity via `activity.GetInfo(ctx)` should return values that reasonably simulate a production Temporal system.

## Actual Behavior

The `info.WorkflowExecution.RunID` field is set to `default-test-run-id`, a non-UUID string.

## Steps to Reproduce the Problem

  1. Create a workflow with one activity, importing the `github.com/google/uuid` package, defined as:

```go
func (a *Activities) MyActivity(ctx context.Context) error {
	info := activity.GetInfo(ctx)

	_, err := uuid.Parse(info.WorkflowExecution.RunID)
	if err != nil {
		return err
	}

	return nil
}
```

  2. Execute the workflow in a TestWorkflowEnvironment.
  3. Observe that the workflow times out as the activity above retries forever with an error about not being able to parse a UUID.

## Specifications

  - Version: SDK v1.25.1
  - Platform: Go v1.22.6 darwin/arm64


#### Comments (4)

<details>
<summary><strong>askreet</strong> commented on 2024-10-27 10:56:28.000 UTC</summary>

If I can get some validation of this bug, I'd be willing to contribute one or both of the following fixes:

1. Set this default value to a valid UUID, such as `00000000-0000-0000-0000-000000000000`.
2. Expose a function `SetExecutionRunID` that mutates the workflowInfo similar to [SetContinuedExecutionRunID](https://github.com/temporalio/sdk-go/blob/master/internal/workflow_testsuite.go#L337-L339) ([impl](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_testsuite.go#L384-L386)).

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-28 13:30:44.000 UTC</summary>

I am not sure there is a "standard" run ID and I'm not sure it's safe to assume the format of the run ID set by the server (that they happen to use a UUID is an implementation detail, not guaranteed). Having said that, we could consider the ability to customize it, but I don't think it's safe to have your activity assume it's a UUID even though the server happens to use that format today.

</details>

<details>
<summary><strong>askreet</strong> commented on 2024-10-30 15:42:25.000 UTC</summary>

I'm more than happy to consider this a bug in my application that I'm storing this as a UUID at all, if that's the consensus.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-30 16:39:26.000 UTC</summary>

Yes, we do not guarantee the format of a run ID

</details>


---

<a id="1643"></a>

### #1643: Ignore search attributes from GetVersion in mocks

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1643 |
| **State** | CLOSED |
| **Author** | ndtretyak (Nikolay Tretyak) |
| **Created** | 2024-09-19 13:06:59.000 UTC (1y 3m ago) |
| **Updated** | 2025-01-21 19:00:19.000 UTC |
| **Closed** | 2025-01-21 19:00:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Search attributes from `GetVersion` does not affect `OnUpsertSearchAttributes` mock

## Actual Behavior
Tests fail if `UpsertSearchAttributes` calls from versioning are not mocked explicitly

## Steps to Reproduce the Problem

  1. Use `GetVersion` and `UpsertSearchAttribute` in your workflow
  1. Use `env.OnUpsertSearchAttribute` in a test to validate the arguments of `UpsertSearchAttributes`
  1. Test will fail on unexpected calls to `UpsertSearchAttributes` made from `GetVersion`



#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-19 14:23:06.000 UTC</summary>

Search attributes from `GetVersion` is intended to affect `OnUpsertSearchAttributes`. `OnUpsertSearchAttributes` is intended to be called on any upsert search attribute, which includes `GetVersion`. We should clarify in the docs that `OnUpsertSearchAttributes` will be used used for `GetVersion`

</details>

<details>
<summary><strong>ndtretyak</strong> commented on 2024-09-19 16:15:54.000 UTC</summary>

When multiple `GetVersion` calls are present across different branches of a workflow, mocking each `OnUpsertSearchAttributes` becomes challenging due to the accumulation of all previous `changeID`s in an unpredictable order.

Additionally, `getChangeVersions` is non-deterministic because it iterates over a map, and its result is used in the `UpsertSearchAttributes` call.
https://github.com/temporalio/sdk-go/blob/82836041f24dca3bcc5b7de9973dcbd340602de4/internal/internal_event_handlers.go#L926

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-24 15:17:30.000 UTC</summary>

You shouldn't need to assert the exact value of `changeID` if you are not interested in it. You should be able to use something like [MatchedBy](https://pkg.go.dev/github.com/stretchr/testify/mock#MatchedBy) to just match the key in the map.

```
env.OnUpsertSearchAttributes(mock.MatchedBy(func(attr map[string]interface{}) bool {
```

</details>

<details>
<summary><strong>ndtretyak</strong> commented on 2024-09-24 16:19:08.000 UTC</summary>

Thanks! This is exactly what I needed.

</details>


---

<a id="1638"></a>

### #1638: Workflow Update in Test Environment should dedup updates by ID

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1638 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-17 04:45:49.000 UTC (1y 3m ago) |
| **Updated** | 2024-11-26 02:31:54.000 UTC |
| **Closed** | 2024-11-26 02:31:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Workflow Updates in Test Environment behave like Updates against a real server and either dupes for fails if an update with a duplicate ID is sent

## Actual Behavior
Test Environment accepts update with duplicate ID


#### Comments (4)

<details>
<summary><strong>yuandrew</strong> commented on 2024-10-10 15:52:20.000 UTC</summary>

Is the ID here referring to `UpdateID` from the `UpdateClientWorkflow` options? I'm working through some other failures in setting up this workflow, want to double check I'm going down the right path.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-10 16:37:11.000 UTC</summary>

>Is the ID here referring to UpdateID from the UpdateClientWorkflow options

Conceptually yes, but the test environment does not use a client since it is all in memory in the same process

Here is an example of sending an update with the test environment https://github.com/temporalio/samples-go/blob/main/reqrespupdate/workflow_test.go#L41, here "test id" is the `UpdateID`

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2024-10-10 18:44:01.000 UTC</summary>

I'm playing around with the [update go sample](https://github.com/temporalio/samples-go/tree/main/update), and when I add `UpdateID: we.GetID()` to the `UpdateWorkflowOptions`, I'm not seeing the real server throw any error. Shouldn't this update fail?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-10 18:55:10.000 UTC</summary>

> Shouldn't this update fail?

No, the real server will dedup the update request by the update ID

</details>


---

<a id="1627"></a>

### #1627: workflowcheck built on 1.23 does not find any findings

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1627 |
| **State** | CLOSED |
| **Author** | aaomidi (Amir Omidi) |
| **Created** | 2024-09-09 23:27:07.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-24 15:10:02.000 UTC |
| **Closed** | 2024-09-24 14:57:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We use this method for managing tools: https://marcofranssen.nl/manage-go-tools-via-go-modules

We've updated that go.mod to 1.23.0, and now when we run `workflowcheck` it has no findings. This is pretty easy to replicate, you can update the `go.mod` file in https://github.com/temporalio/sdk-go/blob/master/contrib/tools/workflowcheck/go.mod and see that workflowcheck isn't able to do proper analysis.

This code works properly up until 1.22.7.


#### Comments (4)

<details>
<summary><strong>aaomidi</strong> commented on 2024-09-10 01:25:22.000 UTC</summary>

I think this also shows a potential need for more test cases for the workflowcheck code, as updating the go sdk does not recognize that the analyzer itself actually stops working.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-12 04:35:18.000 UTC</summary>

I tried updating the `workflowcheck` to `1.23.0` and see no test failure. Can you provided an example of something that was detected as none deterministic before but is no longer being properly detected?

Note the `workflowcheck` has no dependency on the Go SDK so an upgrade to the SDK would not impact `workflowcheck`

</details>

<details>
<summary><strong>aaomidi</strong> commented on 2024-09-13 15:17:12.000 UTC</summary>

```
package workflows

import (
	"time"

	"go.temporal.io/sdk/workflow"
)

type SomeInterestingWorkInput struct{}

type SomeInterestingWorkOutput struct {
	HappenedAt int64
}

func SomeInterestingWork(ctx workflow.Context, input SomeInterestingWorkInput) (SomeInterestingWorkOutput, error) {
	// Do some interesting work here
	return SomeInterestingWorkOutput{
		HappenedAt: time.Now().Unix(),
	}, nil
}
```

If I install workflowcheck using `go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest`, which I believe respects the go.mod file that workflowcheck has, it finds the time.Now() issue. If I clone the repo myself, change the go version, and do a `go install .` on it, then it stops being able to find them.

</details>

<details>
<summary><strong>aaomidi</strong> commented on 2024-09-24 15:10:00.000 UTC</summary>

Thank you for finding this. Seems like quite a breaking change from Go! 

Link to the PR: https://github.com/temporalio/sdk-go/pull/1642

</details>


---

<a id="1582"></a>

### #1582: Updated context functions to match context library

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1582 |
| **State** | OPEN |
| **Author** | nishkrishnan (Nish Krishnan) |
| **Created** | 2024-08-08 16:52:28.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-08 16:52:47.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

Would be awesome to update the go sdk to have `workflow.WithCancelCause(..)` to match the updated context function `context.WithCancelCause(...)`

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="1570"></a>

### #1570: Suppor Temporal Cloud API Keys in Go SDK client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1570 |
| **State** | CLOSED |
| **Author** | tomahawk28 (Jihyuk Bok) |
| **Created** | 2024-07-29 03:49:30.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-29 14:30:49.000 UTC |
| **Closed** | 2024-07-29 03:52:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Is it possible to use API keys in Temporal Cloud to use in Go SDK client? https://docs.temporal.io/cloud/api-keys

Currently, you are only supporting mTLS connection from Go SDK client. 

> When you connect to [Temporal Cloud](https://docs.temporal.io/cloud), you need to provide additional connection and client options that include the following:
> - The [Temporal Cloud Namespace Id](https://docs.temporal.io/cloud/namespaces#temporal-cloud-namespace-id).
> - The [Namespace's gRPC endpoint](https://docs.temporal.io/cloud/namespaces#temporal-cloud-grpc-endpoint). An endpoint listing is available at the [Temporal Cloud Website](https://cloud.temporal.io/namespaces) on each Namespace detail page. The endpoint contains the Namespace Id and port.
> - mTLS CA certificate.
> - mTLS private key.

https://docs.temporal.io/develop/go/temporal-clients#connect-to-temporal-cloud


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-29 03:52:52.000 UTC</summary>

API keys are supported by the Go SDK [NewAPIKeyStaticCredentials](https://pkg.go.dev/go.temporal.io/sdk@v1.28.1/internal#NewAPIKeyStaticCredentials) can be passed to `Credentials` in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk@v1.28.1/internal#ClientOptions)

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-29 03:59:16.000 UTC</summary>

For cloud API keys your connection options would be something like this.
```
clientOptions := client.Options{
		HostPort:  <endpoint>,
		Namespace: <namespace.accountid>,
		Credentials: client.NewAPIKeyStaticCredentials(<APIKey>),
		ConnectionOptions: client.ConnectionOptions{
			DialOptions: []grpc.DialOption{
				grpc.WithUnaryInterceptor(
					func(ctx context.Context, method string, req any, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
						return invoker(
							metadata.AppendToOutgoingContext(ctx, "temporal-namespace", <namespace.accountid>),
							method,
							req,
							reply,
							cc,
							opts...,
						)
					},
				),
			},
		},
	}

	c, err := client.Dial(clientOptions)
```

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>tomahawk28</strong> commented on 2024-07-29 09:37:38.000 UTC</summary>

Thanks, I tried your suggestion with the temporal namespace `https://cloud.temporal.io/namespaces/molen-dev.l2c4n/workflows`. 
However, I still get this message. 
```
2024/07/29 17:35:55 Unable to create client failed reaching server: last connection error: connection error: desc = "error reading server preface: read tcp 172.20.10.2:62658->52.14.206.101:7233: read: connection reset by peer"
```

Perhaps I need to change the auth type for this namespace? 

```
 tcld n am get -n molen-dev.l2c4n                                                                                                                                [17:36:54]
mtls
```

If I need to ask temporal cloud directly, please let me know!

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-07-29 14:30:49.000 UTC</summary>

API keys are still experimental for cloud and most cloud namespaces still use mTLS based authentication. If you want to enable API key support for your cloud account, please open a cloud ticket.

</details>


---

<a id="1554"></a>

### #1554: Unknown NonDeterministicError

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1554 |
| **State** | CLOSED |
| **Author** | vl4deee11 (vl4deee11) |
| **Created** | 2024-07-19 09:15:48.000 UTC (1y 5m ago) |
| **Updated** | 2024-09-01 23:36:21.000 UTC |
| **Closed** | 2024-09-01 23:36:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

 No NonDeterministicError 

## Actual Behavior

 NonDeterministicError


I have a workflow that works great and at the end of the workflow there is a timer that does a simple thing, look at the code below:

```
func CourierWorkflow(ctx workflow.Context, order *models.Order) error {
	wg := workflow.NewWaitGroup(ctx)

	// ....
	var statusUpdatedChan = workflow.NewChannel(ctx)
	err = workflow.SetUpdateHandler(ctx, StatusUpdateHandler, onStatusUpdate(ctx, order, wg, statusUpdatedChan))
	if err != nil {
		logger.Error("SetUpdateHandler failed", "Error", err)
		return err
	}

	// ....

	selector.AddReceive(statusUpdatedChan, func(c workflow.ReceiveChannel, _ bool) { c.Receive(ctx, &err) })

	doneTimeFuture := workflow.NewTimer(ctx, 48*time.Hour)
	selector.AddFuture(doneTimeFuture, func(_ workflow.Future) {
		order.Status = models.StatusDone
	})

	for {
		selector.Select(ctx)
		if order.Status == models.StatusDone {
			break
		}
		// another actions
	}
}

func onStatusUpdate(ctx workflow.Context, order *models.Order, wg workflow.WaitGroup, statusUpdatedChan workflow.Channel) func(ctx workflow.Context, signal models.OrderSignal) (*models.Order, error) {
	logger := workflow.GetLogger(ctx)
	return func(ctx workflow.Context, signal models.OrderSignal) (*models.Order, error) {
		logger.Info("onStatusUpdate: got new update", "Status", signal.Status, "PrevStatus", order.Status)
		orderStatus := order.Status
		switch orderStatus {
		//... update order data
		default:
			return order, nil
		}

		statusUpdatedChan.Send(ctx, afterStatusUpdate(ctx, order, wg, nil))
		return order, nil
	}
}

func afterStatusUpdate(ctx workflow.Context, order *models.Order, wg workflow.WaitGroup, canceledStatus *models.Status) error {
	switch order.Status {
	case models.StatusAtVendor, models.StatusInDelivery, models.StatusAtClient, models.StatusDelivered:
		// -> PANIC HERE, code works from 2023 with no problem
		err := activities.FinishCourierStepForOrderExecute(ctx, order)
		if err != nil {
			return err
		}
	case models.StatusCanceled:
		activities.SkipCourierStepsForOrderExecute(ctx, order)
	}
	return nil
}
```


And with this timer, everything is fine in 99.9% of cases, but sometimes a non-determinism error crashes, and the replays go normal on the same workflow on which the non-determinism error occurs

Replay works great, no problem with workflows

Stack trace:

```
process event for courier [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_command_state_machine.go:455
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc009dfc3c0, {0xc00d45cbfc, 0x3}, 0x0?)
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_command_state_machine.go:1038 +0x109
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc00cf42d98, 0xc00de35400, 0x0?, 0x0)
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_event_handlers.go:1031 +0x24a
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0098de900, 0xc00b29f170)
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:960 +0x11bf
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc000166340, 0xc00b29f170, 0xc006727740)
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:778 +0x4f6
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc000984400, 0xc00b29f170)
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:329 +0x2dd
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc000984400, {0x157ff00?, 0xc00b29f170})
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:302 +0x6c
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc0001ba280, {0x157fa80?, 0xc0081f2330})
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:440 +0x167
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
	/go/src/git.uzum.io/foodtech/develop/operations/logistics-orders/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:334 +0xb5
```

## Steps to Reproduce the Problem

  1.  -

## Specifications

  - Version: 
```

        go.temporal.io/api v1.19.1-0.20230322213042-07fb271d475b
	go.temporal.io/sdk v1.22.1
	go.temporal.io/sdk/contrib/tally v0.2.0

 ```
  - Platform: temporal 1.22.1




#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-19 17:42:27.000 UTC</summary>

Can you try downloading the history for these failing workflows and testing with the replayer and see if the error reproduces?

https://docs.temporal.io/develop/go/testing-suite#replay

I also notice you using `SetUpdateHandler`  on a vey old SDK and an older Server release, Workflow Update is an experimental feature and numerous bug fixes and API changes have been made since that release so it is possible it is related to workflow update and upgrading would fix it.

</details>

<details>
<summary><strong>vl4deee11</strong> commented on 2024-07-21 11:42:47.000 UTC</summary>

@Quinn-With-Two-Ns Hello, as I wrote earlier, the replay is successful, without errors, and the only version that I can update the sdk to is 1.24.1. `SetUpdateHandler` I took from the documentation here https://docs.temporal.io/develop/go/message-passing#handle-update

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-23 21:37:33.000 UTC</summary>

The latest Go SDK is [v1.28.1](https://github.com/temporalio/sdk-go/releases/tag/v1.28.1) there are multiple bugs on fixed on the Server and SDK that could cause this behaviour your seeing. I would recommend upgrading your SDK and Server to the latest stable release.

</details>

<details>
<summary><strong>vl4deee11</strong> commented on 2024-07-24 04:28:29.000 UTC</summary>

I found one bug in sdk in version 1.24.1, now I will fix it at the level of my code, because it is very difficult to update the sdk and the temporal version in the prod, given that the latest updates did not go very smoothly



</details>


---

<a id="1550"></a>

### #1550: After upgrading to 1.27.0 we get a context deadline exceeded

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1550 |
| **State** | CLOSED |
| **Author** | donchev7 (Bobby Donchev) |
| **Created** | 2024-07-17 10:04:49.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-23 21:22:09.000 UTC |
| **Closed** | 2024-07-19 18:56:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Be able to connect to temporal server

## Actual Behavior
2024/07/17 14:00:20 Unable to create client failed reaching server: context deadline exceeded

## Steps to Reproduce the Problem

  1. temporal server start-dev
  1. Run this main.go file with go run main.go
```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/pborman/uuid"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/workflow"
)

type Activities struct {
	Name     string
	Greeting string
}

// GetGreeting Activity.
func (a *Activities) GetGreeting() (string, error) {
	return a.Greeting, nil
}

// @@@SNIPEND

// GetName Activity.
func (a *Activities) GetName() (string, error) {
	return a.Name, nil
}

func GreetingSample(ctx workflow.Context) (string, error) {
	logger := workflow.GetLogger(ctx)

	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// @@@SNIPSTART samples-go-dependency-sharing-workflow
	var a *Activities // use a nil struct pointer to call activities that are part of a structure

	var greetResult string
	err := workflow.ExecuteActivity(ctx, a.GetGreeting).Get(ctx, &greetResult)
	if err != nil {
		logger.Error("Get greeting failed.", "Error", err)
		return "", err
	}
	// @@@SNIPEND

	// Get Name.
	var nameResult string
	err = workflow.ExecuteActivity(ctx, a.GetName).Get(ctx, &nameResult)
	if err != nil {
		logger.Error("Get name failed.", "Error", err)
		return "", err
	}

	// Say Greeting.
	var sayResult string
	err = workflow.ExecuteActivity(ctx, a.SayGreeting, greetResult, nameResult).Get(ctx, &sayResult)
	if err != nil {
		logger.Error("Marshalling failed with error.", "Error", err)
		return "", err
	}

	logger.Info("GreetingSample completed.", "Result", sayResult)
	return sayResult, nil
}

// SayGreeting Activity.
func (a *Activities) SayGreeting(greeting string, name string) (string, error) {
	result := fmt.Sprintf("Greeting: %s %s!\n", greeting, name)
	return result, nil
}

func main() {
	// The client is a heavyweight object that should be created once per process.
	c, err := client.Dial(client.Options{
		HostPort: client.DefaultHostPort,
	})
	if err != nil {
		log.Fatalln("Unable to create client", err)
	}
	defer c.Close()

	workflowOptions := client.StartWorkflowOptions{
		ID:        "greetings_" + uuid.New(),
		TaskQueue: "greetings",
	}

	we, err := c.ExecuteWorkflow(context.Background(), workflowOptions, GreetingSample)
	if err != nil {
		log.Fatalln("Unable to execute workflow", err)
	}
	log.Println("Started workflow", "WorkflowID", we.GetID(), "RunID", we.GetRunID())

	// Synchronously wait for the workflow completion.
	var result string
	err = we.Get(context.Background(), &result)
	if err != nil {
		log.Fatalln("Unable get workflow result", err)
	}
	log.Println("Workflow result:", result)
}
```

  1. go run main.go
2024/07/17 14:02:06 INFO  No logger configured for temporal client. Created default one.
2024/07/17 14:02:11 Unable to create client failed reaching server: context deadline exceeded
exit status 1


If I change in go.mod the sdk version from:
	go.temporal.io/sdk v1.27.0

to

	go.temporal.io/sdk v1.26.1

everything works:
```
âžœ go run main.go
2024/07/17 14:04:16 INFO  No logger configured for temporal client. Created default one.
2024/07/17 14:04:16 Started workflow WorkflowID greetings_dcf4cf08-cb31-4460-ac0d-cddb7e2f164d RunID 2f4a0e00-7fa9-4bb2-bd64-5f12473cc5c8
```

## Specifications

  - Version: goSDK: 1.27.0 go version go1.22.5 darwin/arm64
  - Platform: Mac


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-17 15:22:52.000 UTC</summary>

On Mac with the same Go Version I am not able to reproduce this at least with
```
temporal --version
temporal version 0.13.2 (server 1.24.1) (ui 2.28.0)
```

My only idea would be something interfering with resolving `localhost`. Could try using the IP of your server or try `passthrough:///localhost:7233`?

</details>

<details>
<summary><strong>donchev7</strong> commented on 2024-07-17 17:55:07.000 UTC</summary>

do you mind trying with:
```
temporal --version
temporal version 0.13.1 (server 1.24.1) (ui 2.27.3)
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-17 20:39:05.000 UTC</summary>

No issue with `temporal version 0.13.1 `

</details>

<details>
<summary><strong>donchev7</strong> commented on 2024-07-19 18:56:14.000 UTC</summary>

You were right. Now at my hotel I can't reproduce the issue. It must have been a networking issue at the client. Closing for now.

Thank you.

</details>


---

<a id="1410"></a>

### #1410: Consider migrating away from golang/mock

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1410 |
| **State** | OPEN |
| **Author** | abhinav (Abhinav Gupta) |
| **Created** | 2024-03-04 18:50:07.000 UTC (1y 10m ago) |
| **Updated** | 2024-03-04 18:50:07.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

Hello! It appears that temporal/sdk-go uses golang/mock for mocking in its own tests. (The public mocks package uses mockery.)
This includes one reference to gomock in internal/internal_worker.go.

The upstream github.com/golang/mock project has been deprecated and archive.
As of June 2023, [their README recommends](https://github.com/golang/mock?tab=readme-ov-file#gomock) using go.uber.org/mock instead.

Please consider porting your uses of golang/mock to the maintained fork.
The change is entirely a search-and-replace at the code level.


---

<a id="1397"></a>

### #1397: Add Support for `ReplayWorkflowHistoryOptions` to `ReplayWorkflowHistoryFromJSONFile` & `ReplayPartialWorkflowHistoryFromJSONFile`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1397 |
| **State** | OPEN |
| **Author** | dhang-sc |
| **Created** | 2024-02-25 23:45:49.000 UTC (1y 10m ago) |
| **Updated** | 2025-03-03 18:27:56.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently `replayer.ReplayPartialWorkflowHistoryFromJSONFile` or `ReplayWorkflowHistoryFromJSONFile` ( doesnâ€™t allow you to pass in ReplayWorkflowHistoryOptions.  This is desirable if your replay requires you to specify the workflow id and workflow run id.
With  `ReplayWorkflowHistoryWithOptions` requires you to pass in the history payload.  This requires you to convert from json to the history payload.

In addition, It would be nice if https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker.go#L1432-L1501 these functions were made available as well.  

It would also be nice if the sdk exposed a logger that can be used in the unit test setting.  Example I wanted to pass a logger into `ReplayWorkflowHistoryFromJSONFile`, but I have to implement any interface that implemented the iLog interface.  I wanted get a defaultLogger but it seems to only be accessible from workflow internal pkg



#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-02-26 14:49:42.000 UTC</summary>

We have to be careful continually adding methods to this interface. Having said that, I think ideally we'd want a separate `LoadWorkflowHistoryFromJSONFile` that you can then use the result of in `ReplayWorkflowHistoryWithOptions`. Of course such a function is only a few lines to read a file and serialize to proto for you to write yourself in the meantime.

</details>

<details>
<summary><strong>kp-eugene-kulabuhovs</strong> commented on 2025-03-03 18:27:55.000 UTC</summary>

Example workflow_test.go:

```golang
import (
	"os"

	"github.com/stretchr/testify/assert"
	"go.temporal.io/api/history/v1"
	"go.temporal.io/api/temporalproto"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func LoadWorkflowHistoryFromJSONFile(jsonfileName string) (hist *history.History, err error) {
	opts := temporalproto.CustomJSONUnmarshalOptions{
		DiscardUnknown: true,
	}

	bs, err := os.ReadFile(jsonfileName)
	if err != nil {
		return nil, err
	}

	hist = &history.History{}
	if err := opts.Unmarshal(bs, hist); err != nil {
		return nil, err
	}

	return hist, err
}

func TestExampleWorkflow_UsingHistory(t *testing.T) {
	// JSON generated using:
	// temporal workflow show --workflow-id <workflow-id> --output json > successful_run.json
	history, err := LoadWorkflowHistoryFromJSONFile("testdata/successful_run.json")
	assert.NoError(t, err)

	replayer := worker.NewWorkflowReplayer()
	replayer.RegisterWorkflow(ExampleWorkflow)
	err = replayer.ReplayWorkflowHistoryWithOptions(nil, history, worker.ReplayWorkflowHistoryOptions{
		OriginalExecution: workflow.Execution{
			ID: <workflow-id>,
		},
	})

	assert.NoError(t, err)
}
```

</details>


---

<a id="1380"></a>

### #1380: The timeout is triggered twice earlier than ScheduleToCloseTimeout is set

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1380 |
| **State** | CLOSED |
| **Author** | sosnovski (Anatoliy Sosnovsky) |
| **Created** | 2024-02-07 19:37:41.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-08 09:10:03.000 UTC |
| **Closed** | 2024-02-08 09:10:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | question, potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I expect the workflow to fail after 1 minute
<img width="758" alt="Ð¡Ð½Ð¸Ð¼Ð¾Ðº ÑÐºÑ€Ð°Ð½Ð° 2024-02-07 Ð² 22 38 37" src="https://github.com/temporalio/sdk-go/assets/6298668/e26242fe-c8ea-4b80-9dfc-31e291c143a5">

## Actual Behavior
Workflow completes exactly twice as fast, in about 30 seconds.
<img width="1866" alt="Ð¡Ð½Ð¸Ð¼Ð¾Ðº ÑÐºÑ€Ð°Ð½Ð° 2024-02-07 Ð² 22 39 37" src="https://github.com/temporalio/sdk-go/assets/6298668/2312cb65-f409-4e31-a3f8-9674c4c82056">


I noticed that the timeout is triggered twice as early as set in the ScheduleToCloseTimeout timeout. 
I tried to specify 10 minutes and the timeout worked after 5.

## Steps to Reproduce the Problem

Run this workflow without any timeouts:
```golang
func SampleWorkflow(ctx workflow.Context) error {
	ao := workflow.ActivityOptions{
		ScheduleToCloseTimeout: time.Minute,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	err := workflow.ExecuteActivity(ctx, SampleActivity).Get(ctx, nil)
	if err != nil {
		return err
	}

	return nil
}

func SampleActivity() error {
	return errors.New("some error")
}
```

## Specifications

  - Version: v1.25.1
  - Platform: Mac OS 14.2 ARM 


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-07 20:40:44.000 UTC</summary>

Could you share the history of this workflow?

</details>

<details>
<summary><strong>sosnovski</strong> commented on 2024-02-07 23:13:06.000 UTC</summary>

@Quinn-With-Two-Ns In what form should you provide the data?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-08 01:27:05.000 UTC</summary>

@sosnovski On further research this is expected, Since your activity always fails the backoff time will grow exponentially from 1s doubling every retry until the next attempt time is after the activity timeout. If the next schedule time is after the `schedule_to_close` time, we skip the attempt and fail the activity. 

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>sosnovski</strong> commented on 2024-02-08 09:09:54.000 UTC</summary>

@Quinn-With-Two-Ns Now everything is clear, thank you!

</details>


---

<a id="1364"></a>

### #1364:  Move SDK Errors Out of Internal Package for Enhanced Usability

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1364 |
| **State** | CLOSED |
| **Author** | pantafive |
| **Created** | 2024-01-22 18:17:56.000 UTC (1y 11m ago) |
| **Updated** | 2024-01-22 21:10:48.000 UTC |
| **Closed** | 2024-01-22 18:35:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hi Temporal Team,

I've been looking at the Temporal Go SDK and I noticed that the errors for the SDK are kept in the internal package (see [internal/error.go, lines 261-283](https://github.com/temporalio/sdk-go/blob/171504d947f447e5981b794b79abbb5fe0e9374b/internal/error.go#L261-L283)). Keeping these errors inside internal makes it hard for developers to use them directly. This can lead to clunky ways of dealing with errors, like having to match error messages as strings.

In Go, we usually put stuff in internal when we don't want others to use it directly. But errors from an SDK are something developers often need to work with. If these errors were in a package that's easier to access, it would make more sense and help developers handle errors more easily.

I suggest moving these SDK errors to a package that's not internal. This would make things easier for developers using the SDK and fit better with how we usually organize packages in Go.

Thanks for considering this. Looking forward to hearing what you think.

#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-22 18:21:44.000 UTC</summary>

Errors a users is expected to need are aliased in other packages for example  `ErrActivityResultPending` is aliased here https://github.com/temporalio/sdk-go/blob/master/activity/activity.go#L51. If there is any specific error you encountered that is not aliased we can add an alias for it specifically .

</details>

<details>
<summary><strong>pantafive</strong> commented on 2024-01-22 18:29:41.000 UTC</summary>

Thank you for quick answer. I want to handle `ErrScheduleAlreadyRunning` when I create a new scheduler. In this case, it's more convenient to "ask for forgiveness than permission".

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-22 18:31:43.000 UTC</summary>

`ErrScheduleAlreadyRunning` is already exposed https://github.com/temporalio/sdk-go/blob/171504d947f447e5981b794b79abbb5fe0e9374b/temporal/error.go#L163

Reactions: â¤ï¸ 1

</details>

<details>
<summary><strong>pantafive</strong> commented on 2024-01-22 18:35:56.000 UTC</summary>

Thank you very much!

</details>


---

<a id="1339"></a>

### #1339: workflow.CreateSession create more sessions than MaxConcurrentSessionExecutionSize

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1339 |
| **State** | CLOSED |
| **Author** | avarabyeu (Andrei Varabyeu) |
| **Created** | 2024-01-08 15:43:35.000 UTC (2 years ago) |
| **Updated** | 2024-01-08 20:13:19.000 UTC |
| **Closed** | 2024-01-08 20:13:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Worker does not create more sessions than defined in MaxConcurrentSessionExecutionSize. Workflow tasks are queued until worker is ready to accept new one. 

## Actual Behavior
More sessions than defined in MaxConcurrentSessionExecutionSize are created

## Steps to Reproduce the Problem
I've got quite unusual use case when i need a worker to handle only one session. Workflow itself is quite basic - when session is started, workflow waits for external signal for a while (some sort of approval), than executes single activity. The activity uses serial port, so running two activities / sessions in parallel is prohibited. Normally, there are 2-3 workers are running in parallel. 
 
From time to time i see some workers starting 2 sessions in parallel which seems to be a bug since MaxConcurrentSessionExecutionSize=1 is set to all workers.  

## Specifications
Temporal CLI server
  - Version: 1.22.2 server, 1.25.1 go SDK
  - Platform: Linux


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-08 17:39:30.000 UTC</summary>

Can you share some more details around this scenario? Ideally some minimal example that reproduces this issue

</details>

<details>
<summary><strong>avarabyeu</strong> commented on 2024-01-08 19:01:13.000 UTC</summary>

Unfortunately, i won't be able to share the complete example, but here are some pieces. Hope it makes sense:
So, the workflow is basically executor of 3D-printer. That's why i can't have two workflows/sessions running in parallel for the same worker instance. 
There is root workflow that handles pre-processing and other stuff. When the image is ready for print, root workflow creates child workflow that runs on the worker physically connected to the printer. 
This is how printer worker is created:
```go
                        w := worker.New(c, "printers-queue", worker.Options{
				Identity:                           fmt.Sprintf("printer-queue-%s", cfg.PrinterName),
				MaxConcurrentSessionExecutionSize:  1,
				EnableSessionWorker:                true,
			})
			pq := printerqueue.NewPrinterWorkflow(cfg.PrinterName)
			w.RegisterWorkflow(pq.PrinterQueue)
                         w.RegisterActivityWithOptions(printActivity.Run, activity.RegisterOptions{
				Name: "PrinterActivity",
			})			
```
I've got at least two workers, running as docker containers. 

This is how workflow looks like:

```go
func (wfl *PrinterWorkflow) PrinterQueue(ctx workflow.Context, input string) error {
	sessionOptions := &workflow.SessionOptions{
		CreationTimeout:  1 * time.Hour,
		ExecutionTimeout: 1 * time.Hour,
	}
	// Create a Session with the Worker so that all Activities execute with the same Worker.
	sessionCtx, err := workflow.CreateSession(ctx, sessionOptions)
	if err != nil {
		return err
	}
	defer workflow.CompleteSession(sessionCtx)

        // let parent workflow that printer is assigned and ready to print
	parent := workflow.GetInfo(ctx).ParentWorkflowExecution
	if err := workflow.SignalExternalWorkflow(ctx,
		parent.ID,
		parent.RunID, SignalNameAssigned, wfl.printer).Get(ctx, nil); err != nil {
		return err
	}

	approved, err := wfl.waitForApproval(ctx)
	if err != nil {
		return err
	}
	if !approved {
		return errors.New("printing isn't approved")
	}
        // once approved, start printing
	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		StartToCloseTimeout: 1 * time.Hour,
		TaskQueue:           workflow.GetInfo(ctx).TaskQueueName,
	})
	err = workflow.ExecuteActivity(ctx, "PrinterActivity", activities.PrintActivityInput{
		Filename: input,
	}).Get(ctx, nil)
	if err != nil {
		return err
	}

	return nil
}
```

What i see is that there are two workflows at the same worker stuck at 'waitingForApproval' line, which basically means that there are two parallel sessions are created 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-08 19:05:58.000 UTC</summary>

>What i see is that there are two workflows at the same worker stuck at 'waitingForApproval' line, which basically means that there are two parallel sessions are created

Sessions do not control what workers workflow tasks run on, only what worker activities run on. If you approve both those workflows the activities should run on separate workers.

</details>

<details>
<summary><strong>avarabyeu</strong> commented on 2024-01-08 20:13:19.000 UTC</summary>

That makes perfect sense and explains the problem i have. 
Thanks a lot for prompt replies @Quinn-With-Two-Ns 
Closing this one since it's not a bug

</details>


---

<a id="1274"></a>

### #1274: schedule not working as expected

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1274 |
| **State** | CLOSED |
| **Author** | ljx0520 (Joseph) |
| **Created** | 2023-10-21 11:25:18.000 UTC (2y 2m ago) |
| **Updated** | 2023-10-22 02:44:28.000 UTC |
| **Closed** | 2023-10-22 02:44:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Runs should be scheduled on the weekday, from 9am to 5pm

## Actual Behavior

Runs are not scheduled on the weekday, from 9am to 5pm

As per below screenshot, runs are scheduled immediately but it is on a Saturday and outside 9 to 5.

<img width="943" alt="image" src="https://github.com/temporalio/sdk-go/assets/10672189/9b68808a-9ace-42fa-84a8-2e3ba0e60dfd">


## Steps to Reproduce the Problem

```
scheduleHandle, err := c.ScheduleClient().Create(ctx, client.ScheduleOptions{
		ID: schedule.WorkflowName,
		Spec: client.ScheduleSpec{
			// schedule on weekday 9am to 5pm
			Calendars: []client.ScheduleCalendarSpec{
				{
					Second: []client.ScheduleRange{{}},
					Minute: []client.ScheduleRange{{}},
					Hour: []client.ScheduleRange{
						{
							Start: 9,
							End:   17,
						},
					},
					DayOfWeek: []client.ScheduleRange{
						{
							Start: 1,
							End:   5,
						},
					},
				},
			},

			Intervals: []client.ScheduleIntervalSpec{
				{
					Every: schedule.WorkflowInterval,
				},
			},

			Jitter: time.Second * 30,

			TimeZoneName: "Australia/Sydney",
		},
		Action: &client.ScheduleWorkflowAction{
			ID:        workflowID,
			Workflow:  schedule.Workflow,
			TaskQueue: schedule.TaskQueue,
		},
	})
```

## Specifications

  - Version: 
  go.temporal.io/sdk v1.25.1
  TEMPORAL_VERSION=1.22.0
  - Platform: Mac M1 


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-21 14:49:21.000 UTC</summary>

What is `schedule.WorkflowInterval` in  your code?

</details>

<details>
<summary><strong>ljx0520</strong> commented on 2023-10-21 21:47:42.000 UTC</summary>

> What is `schedule.WorkflowInterval` in your code?

it is `const WorkflowInterval = 60 * time.Second * 4`

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-21 22:13:53.000 UTC</summary>

Then the schedule is working as I would expect. From the docs
```
ScheduleSpec is a complete description of a set of absolute times (possibly infinite) that a action should occur at. The times are the union of Calendars, Intervals, and CronExpressions, minus the Skip times. 
```

So your current spec says it should  run every hour on the weekday from 9am to 5pm and every 4 minutes.

I am not sure exactly what schedule you want. I presume you want it to run every 4 min on the weekday from 9am to 5pm.
```
		Spec: client.ScheduleSpec{
			// schedule on weekday 9am to 5pm
			Calendars: []client.ScheduleCalendarSpec{
				{
					Second: []client.ScheduleRange{{}},
					Minute: []client.ScheduleRange{
						{
							Start: 0,
							End:   59,
                                                        Step: 4,
						},
					},
					Hour: []client.ScheduleRange{
						{
							Start: 9,
							End:   17,
						},
					},
					DayOfWeek: []client.ScheduleRange{
						{
							Start: 1,
							End:   5,
						},
					},
				},
			},
			Jitter: time.Second * 30,

			TimeZoneName: "Australia/Sydney",
		},
```

</details>

<details>
<summary><strong>ljx0520</strong> commented on 2023-10-22 02:44:28.000 UTC</summary>

thanks, that is exactly what I want!

</details>


---

<a id="1229"></a>

### #1229: Workflowchecker - override the entry point for the linter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1229 |
| **State** | CLOSED |
| **Author** | HeatherLemieux (Heather Lemieux) |
| **Created** | 2023-09-08 15:56:04.000 UTC (2y 4m ago) |
| **Updated** | 2023-09-08 18:09:58.000 UTC |
| **Closed** | 2023-09-08 18:09:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We use a helper function to set up additional logging for our workflows, 
```
func (w *Workflow) Run(ctx workflow.Context, wfInput *Input) error {
	return logger.WorkflowRun(ctx, wfInput, w.Execute)
}
```

which uses generics and looks like this
```
func WorkflowRun[I any](ctx workflow.Context, input I, runner WorkflowRunner[I]) error {
	l, onComplete := workflowRunBefore(ctx)
	defer onComplete()

	err := runner(ctx, l, input)

	workflowRunAfter(l, err)

	return err
}
```

since we're using generics the workflow checker doesn't know that the main body of the workflow is actually the `w.Execute` function. 

**Describe the solution you'd like**
Ideally we could change the entry point to be the `(w *Workflow) Execute` method instead of the `(w *Workflow) Run` method since we don't actually need any of the methods our logging package utilizes checked for determinism. 


#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2023-09-08 15:59:20.000 UTC</summary>

We have made a recent change in #1215 where we now check all functions that accept a `workflow.Context` as their first parameter. Can you check against `master` and see if this helps?

Reactions: ðŸ‘€ 1

</details>

<details>
<summary><strong>HeatherLemieux</strong> commented on 2023-09-08 17:32:34.000 UTC</summary>

I reinstalled the latest using `go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest`
the output of `workflowcheck -V=full` is now `workflowcheck version devel comments-go-here buildID=de6a0b6fc69b7e711aee1bdf538832594e1e1993ef17d03bdb6506aa31c4436f` 

and I modified the first line of a workflow to be 
```
func (w *Workflow) Execute(ctx workflow.Context, l logger.Log, wfInput *Input) (*Input, error) {
	fmt.Println(time.Now())
    ...
```

and when I run the workflowcheck it does not return any results.  I am not passing a config file in, so nothing is whitelisted

Should I try and install workflowcheck in a different way? 

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-09-08 18:03:24.000 UTC</summary>

Try `go install go.temporal.io/sdk/contrib/tools/workflowcheck@master` or build yourself

</details>

<details>
<summary><strong>HeatherLemieux</strong> commented on 2023-09-08 18:09:58.000 UTC</summary>

Thanks! After trying master, I get the expected output. 

</details>


---

<a id="1174"></a>

### #1174: Allow ignoring invalid SpanContext in OpenTelemetry TracingInterceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1174 |
| **State** | CLOSED |
| **Author** | cdavis-joy |
| **Created** | 2023-07-26 20:28:05.000 UTC (2y 5m ago) |
| **Updated** | 2023-08-07 18:15:51.000 UTC |
| **Closed** | 2023-08-07 18:15:51.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
We recently moved from OpenTracing to OpenTelemetry. Upon deploying, we found a long running workflow failed because it was trying to start a span from an OpenTracing parent span, so an error was returned here: https://github.com/temporalio/sdk-go/blob/master/contrib/opentelemetry/tracing_interceptor.go#L137

**Describe the solution you'd like**
Failures to trace should have the option to do so silently. Adding an option to the TracingInterceptor to ignore the invalid SpanContext would allow us to keep this long running workflow alive when the new version of the worker deploys. It's acceptable for spans to not connect to their parents for a short time; it is not acceptable for a critical workflow to fail because of a failure to trace. 

**Describe alternatives you've considered**
The DataDog interceptor seems to handle this gracefully already. OpenTelemetry does not return any error when getting a SpanContext. 

**Additional context**
I've added a commit [on my fork](https://github.com/cdavis-joy/sdk-go/commit/9fc81c3847d4b19d126e9dfc040b5859f3970773) that attempts to address this. I feel like this is likely a common thing that people might run into; running workflows that straddle two tracing implementations. 


#### Comments (2)

<details>
<summary><strong>cdavis-joy</strong> commented on 2023-07-26 21:18:05.000 UTC</summary>

To zoom out a bit, the SDK is enforcing tracing to operate without error, and if it does not, workflows/activities cannot run. (see https://github.com/temporalio/sdk-go/blob/master/interceptor/tracing_interceptor.go#L375)

Maybe I'm totally off base here in thinking that workflows/activities should not function if tracing is not functioning, but I'm happy to hear any other thoughts. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-27 05:05:05.000 UTC</summary>

Yeah I think adding an option to ignore errors this case seems very reasonable

</details>


---

<a id="1167"></a>

### #1167: Allow setting activity timeouts in TestActivityEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1167 |
| **State** | OPEN |
| **Author** | ohad83 (Ohad Abarbanel) |
| **Created** | 2023-07-19 18:36:10.000 UTC (2y 5m ago) |
| **Updated** | 2023-10-09 12:42:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘€ 1 |

#### Description

Currently, the TestActivityEnvironment has a hard-coded 10 minute timeout. If I want to use the test suite to run an activity which takes longer than that, it fails with a timeout error.

Adding the ability to run the activity with options like timeout values in the test environment would help a lot in testing and debugging long activities.

Thanks!

#### Comments (4)

<details>
<summary><strong>Delicious-Bacon</strong> commented on 2023-08-05 12:51:26.000 UTC</summary>

+1 to this.

Activity test times out at 10 minute point, which is too short for some of my activities.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-08-07 13:39:49.000 UTC</summary>

> If I want to use the test suite to run an activity which takes longer than that, it fails with a timeout error.

While supporting an override is fine, in general I think you should use a real server if you are running such tests (you can easily start a dev server using the `testsuite` package).

</details>

<details>
<summary><strong>Delicious-Bacon</strong> commented on 2023-10-09 10:58:42.000 UTC</summary>

> you can easily start a dev server using the `testsuite` package

Which is extra boilerplate code just to execute an Activity, isn't it?

I already have loads of test Workflows that bloat my project and bring confusion by decoupling the Go's `testing` tools from those "tests". I end up saving results of those Workflows to a file and then manually check the results instead of implementing `testing` package.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-10-09 12:42:10.000 UTC</summary>

> Which is extra boilerplate code just to execute an Activity, isn't it?

Not sure about "boilerplate". It starts a real server you can do real integration tests on. There's a lot of value in running against a real server.

</details>


---

<a id="1138"></a>

### #1138: Auto instrument Activities if enabled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1138 |
| **State** | CLOSED |
| **Author** | albertteoh (Albert) |
| **Created** | 2023-06-14 01:38:30.000 UTC (2y 7m ago) |
| **Updated** | 2023-06-14 16:11:01.000 UTC |
| **Closed** | 2023-06-14 13:29:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Generically instrument Activities. That is, avoid the need to manually instrument each activity as illustrated in [this example](https://github.com/temporalio/samples-go/blob/main/metrics/workflow.go#L32), because we have a lot of Activities defined and would be tedious to instrument.

**Describe the solution you'd like**
Have Activities automatically instrumented, if enabled via configuration/options. Propose to wrap instrumentation before and after [`ExecuteActivity`](https://github.com/temporalio/sdk-go/blob/master/internal/workflow.go#L555), following a similar approach to [the existing Go metrics instrumentation example](https://github.com/temporalio/samples-go/blob/main/metrics/workflow.go#L32)

**Describe alternatives you've considered**
- Manually instrument each Activity: works but tedious
- [Cluster metrics setup](https://docs.temporal.io/kb/prometheus-grafana-setup#cluster-metrics-setup): does not contain Activity-specific metrics.

**Additional context**
Happy to put together a PR as an upstream contribution, if the community is happy with this proposal.


#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2023-06-14 12:57:31.000 UTC</summary>

What metric are you looking for? We already have [`temporal_activity_execution_latency`](https://docs.temporal.io/references/sdk-metrics#activity_execution_latency). That sample in your link is just for demonstrating how to make custom metric with your own name, but a metric for activity execution already exists.

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2023-06-14 13:20:36.000 UTC</summary>

> What metric are you looking for?

At the very least, success/failure counts from activity executions grouped by activity name; latency is a bonus.

> We already have [temporal_activity_execution_latency](https://docs.temporal.io/references/sdk-metrics#activity_execution_latency).

Is this metric surfaced after enabling cluster level metrics as described [here](https://docs.temporal.io/kb/prometheus-grafana-setup#cluster-metrics-setup)?

If so, I gave that a go, and eyeballed some metrics but couldn't find labels that contained the Activity name. But if that particular metric does have it, then it meets our requirements.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-06-14 13:22:18.000 UTC</summary>

> At the very least, success/failure counts from activity executions grouped by activity name; latency is a bonus.

You won't get all success/failure counts technically because a server-side could timeout. But yes there is a failure counter (`temporal_activity_execution_failed`) and others.

> Is this metric surfaced after enabling cluster level metrics as described [here](https://docs.temporal.io/kb/prometheus-grafana-setup#cluster-metrics-setup)?

This is a worker-side metric not a server-side one. Enable metrics as shown in the previously-linked sample.

(also feel free to join us on forums and `#go-sdk` on Slack)

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2023-06-14 13:29:13.000 UTC</summary>

> This is a worker-side metric not a server-side one. Enable metrics as shown in the previously-linked sample.

Oh yes, I should have checked the title of the page. ðŸ˜… 

> (also feel free to join us on forums and #go-sdk on Slack)

Thank you, will do! And also thank you for the amazingly fast and helpful responses. ðŸ‘ðŸ¼ 


Reactions: ðŸ‘ 1

</details>


---

<a id="1100"></a>

### #1100: TestWorkflowEnvironment should surface errors and respect failure signal surfaced by underlying mock

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1100 |
| **State** | OPEN |
| **Author** | qiuyijie-stripe |
| **Created** | 2023-05-06 01:37:30.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-08 16:12:35.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
Say I expect `testWorkflow` to invoke `testActivity` twice with certain arguments
```
env.OnActivity(testActivity, mock.Anything, testActivityParams{...}).Return(...).Times(2) 
req := testWorkflowRequest{...}

// Workflow actually invokes testActivity three times. Expect to see a test failure here due to the extra unexpected invocation.
env.ExecuteWorkflow(testWorkflow, req)
``` 

## Actual Behavior
* Test passes, but seeing the following error message from test output:
```
assert: mock: The method has been called over 2 times.
	Either do one more Mock.On(testActivity).Return(...), or remove extra call.
	This call was unexpected: ...
```
* `env.AssertExpectations` doesn't catch the extra invocation, as it delegates to testify's `mock.AssertExpectations`, which only verifies that all configured invocations have been satisfied.
* `env.AssertNumberOfCalls` doesn't catch the extra invocation either. Instead this happens:
```
env.OnActivity(testActivity, mock.Anything, testActivityParams{...}).Return(...).Times(2) 
req := testWorkflowRequest{...}

// Workflow actually invokes testActivity three times but test doesn't fail
env.ExecuteWorkflow(testWorkflow, req)

// Expect this assertion to fail but it passes
env.AssertNumberOfCalls("testActivity", 2)
// Expect this assertion to succeed but it fails
env.AssertNumberOfCalls("testActivity", 3)
```

I think this behavior has to do with the fact that `env.AssertNumberOfCalls` delegates to testify's `mock.AssertNumberOfCalls`. However, testify expects the test to have [already failed](https://github.com/stretchr/testify/blob/437071b948cd89bdbaaf43a41f19fbe1a0945f6f/mock/mock.go#L468) early when the extra invocation occurred, and therefore does not increment its invocation counter. As a result, when the test unexpectedly continues on, the actual invocation counter remains at 2 even though there have been 3 calls to the activity.

testify's behavior seems correct and reasonable in this case. However, I'd expect `TestWorkflowEnvironment` to surface and respect the error and failure surfaced by testfify, and mark the test case as failed.

## Steps to Reproduce the Problem
See above

## Specifications

  - Version: v1.18.1
  - Platform: macOS Ventura 13.3.1

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-05-08 12:13:26.000 UTC</summary>

I admit to not looking into this, but just curious if you can confirm that `env.GetWorkflowError()` is `nil`?

</details>

<details>
<summary><strong>qiuyijie-stripe</strong> commented on 2023-05-08 16:11:02.000 UTC</summary>

Yes. I assert `env.GetWorkflowError()` is nil in all my test cases, and invoke `AssertExpectations` as part of `AfterTest`. 

Reactions: ðŸ‘ 1

</details>


---

<a id="1063"></a>

### #1063: workflowcheck is failing non-deterministic checks when code is wrapped with SideEffect

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1063 |
| **State** | CLOSED |
| **Author** | mindaugasrukas (Mind.R.) |
| **Created** | 2023-03-15 18:02:05.000 UTC (2y 10m ago) |
| **Updated** | 2024-01-21 05:30:16.000 UTC |
| **Closed** | 2024-01-21 05:30:15.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
`workflowcheck` ignores `SideEffect` block.

## Actual Behavior
`workflowcheck` is failing `non-deterministic` check.

## Steps to Reproduce the Problem

  1. In a Workflow, add any non-deterministic code and wrap it with the SideEffect.
  1. run `workflowcheck -show-pos ./...`

## Specifications

  - Version: `go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest`
  - Platform:
```
% uname -v
Darwin Kernel Version 22.3.0: Mon Jan 30 20:38:37 PST 2023; root:xnu-8792.81.3~2/RELEASE_ARM64_T6000
```


#### Comments (2)

<details>
<summary><strong>edmondop</strong> commented on 2023-06-10 23:40:53.000 UTC</summary>

Could have been fixed?  Using the latest I couldn't trigger the problem

```
package my_stuff

import (
	"go.temporal.io/sdk/workflow"
	"math/rand"
)

func MyWorkflow(context workflow.Context) {
	encodedRandom := workflow.SideEffect(context, func(ctx workflow.Context) interface{} {
		return rand.Intn(100)
	})
	var random int
	encodedRandom.Get(&random)
}

```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-21 05:30:15.000 UTC</summary>

Closing as this is resolved by https://github.com/temporalio/sdk-go/pull/1230

</details>


---

<a id="1016"></a>

### #1016: Provide a mechanism to version in a long running loop

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1016 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-01-30 04:56:06.000 UTC (2y 11m ago) |
| **Updated** | 2025-01-29 23:30:16.000 UTC |
| **Closed** | 2025-01-21 18:40:17.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Provide a mechanism to update workflow code running in a long running loop such that new iterations of the loop will use the new workflow logic, while still being deterministic on replay. A current[ proposed workaround](https://stackoverflow.com/questions/74143884/how-to-use-cadence-temporal-versioning-api-workflow-getversion-in-a-loop) does not work well as it is unintuitive and for long running loops can actually fail as the search attribute appended for each version grows to large.

Taken from slack: https://temporalio.slack.com/archives/CTRCR8RBP/p1674236715491629
```
// use to upgrade old long running workflows and introduce new code
func getGlobalVersionExample(ctx workflow.Context, iteration int) workflow.Version {
	// if max version then just use g since we are already running latest code
	initialVersion := workflow.GetVersion(ctx, "g", workflow.DefaultVersion, MaxVersion)
	if initialVersion == MaxVersion {
		return initialVersion
	}

	// if workflow version is not max version then we are running old code and we need to version on each iteration
	v := workflow.GetVersion(ctx, fmt.Sprintf("g%d", iteration), initialVersion, MaxVersion)
	return v
}

func LongRunningWorkflow(ctx workflow.Context) {
	iteration := 0
	for {
		selector := workflow.NewSelector(ctx)
		signalName := "mysignal"
		signalChannel := workflow.GetSignalChannel(ctx, signalName)
		selector.AddReceive(signalChannel, func(c workflow.ReceiveChannel, _ bool) {
			dispatchCommand(ctx, iteration)
		})

		selector.Select(ctx)

		iteration++
	}
}

func dispatchCommand(ctx workflow.Context, iteration int) {
	if getGlobalVersionExample(ctx, iteration) != workflow.DefaultVersion {
		// do something new
	}
	// do something old
}
```

**Describe the solution you'd like**
Provide a  non memorized version of the `GetVersion` API that can be used in a loop like the typescipt [patched API](https://legacy-documentation-sdks.temporal.io/typescript/patching#typescript-sdk-patching-api)

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-01-21 18:39:51.000 UTC</summary>

Marking as a duplicate of https://github.com/temporalio/features/issues/518

</details>

<details>
<summary><strong>mjameswh</strong> commented on 2025-01-29 23:30:15.000 UTC</summary>

This is now tracked as temporalio/features#591.

</details>


---

<a id="984"></a>

### #984: No error will be thrown if WorkflowRunTimeout is reached

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/984 |
| **State** | CLOSED |
| **Author** | chunming-c (chunming, chen) |
| **Created** | 2022-12-22 01:32:04.000 UTC (3 years ago) |
| **Updated** | 2022-12-22 05:40:46.000 UTC |
| **Closed** | 2022-12-22 05:40:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Hi forks, thank you for the great work. I faced a difficulty which might not be a bug but I couldn't find relative solution anywhere. In our case I would like to know how should we detect workflow has timeout or how should we catch the timeout error when `WorkflowRunTimeout` is reached. For example, the following set the `WorkflowRunTimeout` to 1 second which should enter workflow `defer` function once timeout is reached. 

**main.go**
```go
func main() {
	...
	workflowOptions := client.StartWorkflowOptions{
		ID:        workflowID,
		TaskQueue: "",
                 // Set workflow timeout to one second.
		WorkflowRunTimeout: 1 * time.Second,
	}

	we, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflow)
}
```


**workflow.go**
```go
func YourWorkflow(ctx workflow.Context) error {
	defer func() {
                 // Ideally the defer function should be called once one second passed. The fact is the temporal will terminate 
                 // the workflow without entering the the defer function.
		if !errors.Is(ctx.Err(), workflow.ErrCanceled) {
			return
		}
	}()

        time.Sleep(5 * time.Second)

	return nil
}

```

## Actual Behavior

The fact is the temporal will terminate the workflow without entering the the `defer` function.


## Specifications

  - Version: `v1.18.4`
  - Platform: OSX


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-22 02:32:34.000 UTC</summary>

Hi @chunming-c , I believe this is the intended behaviour. Per our documentation on [WorkflowRunTimeout](https://docs.temporal.io/concepts/what-is-a-workflow-run-timeout) it will terminate the workflow execution so no other workflow tasks should be run. 

We don't recommend putting any business logic on workflow timeouts. Why exactly are you setting `WorkflowRunTimeout ` 

</details>

<details>
<summary><strong>chunming-c</strong> commented on 2022-12-22 03:45:50.000 UTC</summary>

`WorkflowRunTimeout` is the minimum hard deadline because we don't want workflow would run forever

Our workflow is long-running process which contains couples of activities might last one or two hours. It's a big deal for us if one of them is delayed and make the entire workflow not able to finish on time, especially the last few activities. Therefore, once the workflow exceed the timeout, an alert will be sent. It would be ideal if we could get a either event or error when the workflow timeouts

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-22 04:39:27.000 UTC</summary>

As I said we don't recommend using workflow timeout for any business logic. If you did really want to go with that approach then you could have a parent workflow that's job is to supervise the child workflow and wait for the child workflow to complete/fail and react accordingly. Another approach would be to create a timer at the start of your workflow and if that timer expires cancel the workflow and do any cleanup

 [Child workflow example](https://github.com/temporalio/samples-go/tree/main/child-workflow)
 
 [timer example](https://github.com/temporalio/samples-go/blob/main/timer/workflow.go)

</details>

<details>
<summary><strong>chunming-c</strong> commented on 2022-12-22 05:40:46.000 UTC</summary>

okay, thank you for your advices. Will figure out an alternative to fit our own logic. Thanks!

</details>


---

<a id="949"></a>

### #949: Allow user to override default maximum activity attempts in test suite

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/949 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-11-07 13:42:36.000 UTC (3y 2m ago) |
| **Updated** | 2022-12-02 20:46:54.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now we fix it at 10 if a user doesn't set it. A user shouldn't have to be forced to set maximum attempts in their workflow because the test suite has a hidden default. We should allow this default to be overridden.

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 18:52:39.000 UTC</summary>

>  A user shouldn't have to be forced to set maximum attempts in their workflow because the test suite has a hidden default.

Why shouldn't they be? If they don't set one on a workflow run on a real server it will retry infinite times. If the max number of retries matters in a workflow to a customer shouldn't they set it in the workflow? I worry adding something like this could allow bugs in users code to slip through because the testing environment is different than production.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 20:46:53.000 UTC</summary>

> Why shouldn't they be?

Because you shouldn't have to alter your workflow code for our test environment.

> If the max number of retries matters in a workflow to a customer shouldn't they set it in the workflow?

Yes, but what if it's 15 and not 10?

> I worry adding something like this could allow bugs in users code to slip through because the testing environment is different than production.

I am just suggesting allowing it to be configurable from the default of 10 instead of forcing 10. I don't think it should be removed of course.

</details>


---

<a id="927"></a>

### #927: built-in query for waiting signals to go-sdk

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/927 |
| **State** | CLOSED |
| **Author** | zengzilu |
| **Created** | 2022-10-09 02:55:20.000 UTC (3y 3m ago) |
| **Updated** | 2022-12-03 00:10:25.000 UTC |
| **Closed** | 2022-12-03 00:10:24.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
I need to known what signal can I send to a running flow, some signal might block the flow, some might change the flow running. when the flow doesn't behave as I supposed, I need to check the signals

so there is the issue:  request a built-in query for waiting signals

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
mark all signal with `workflowOutboundInterceptor GetSignalChannel` and query it, but it's not exactly what I need, because the signal might has been signed, it is not a "waiting signal". it means all signals that happened to the flow. what I exactly need is "waiting signals" which means what can I send to the flow now

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-10-10 13:33:14.000 UTC</summary>

This is something we're planning on doing one day, see https://github.com/temporalio/sdk-features/issues/51.

In the meantime, you can provide your own query to provide your own information to your caller.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-03 00:10:24.000 UTC</summary>

closing as it is effectively a duplicate of https://github.com/temporalio/sdk-features/issues/51

</details>


---

<a id="805"></a>

### #805: testsuite support restarting workflow if returned `NewContinueAsNewError`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/805 |
| **State** | CLOSED |
| **Author** | jackielii (Jackie Li) |
| **Created** | 2022-05-13 16:03:53.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-16 15:45:30.000 UTC |
| **Closed** | 2022-05-16 15:40:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I have a workflow that relies on child workflow to run many times. And I need to test the behaviour of this behaviour.

E.g. in the [child-workflow-continue-as-new](https://github.com/temporalio/samples-go/tree/main/child-workflow-continue-as-new) example, we want to test the the child workflow is executed exactly _5_ times.

**Describe the solution you'd like**
In order to keep compatibility, I propose adding an method in `TestWorkflowEnvironment` called `EnableRunContinueAsNew`. 

If this option is enabled, the `ContinueAsNewError` won't be returned, but workflow will be executed instead.

**Describe alternatives you've considered**
There is no easy alternatives. The only one I can think of is an integration testing with full temporal + workflow worker setup.



#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 14:47:56.000 UTC</summary>

The workflow unit test represents a single run, not multiple (be it by retry, continue as new, cron, etc). Are you trying to test that the continue as new error is as you expect, or that the Temporal server reacts to continue as new as expected? The former is best as a unit test, the latter as an integration test, but I am afraid using the unit test suite for multi-workflow-run integration testing is a bit out of scope.

</details>

<details>
<summary><strong>jackielii</strong> commented on 2022-05-16 15:40:37.000 UTC</summary>

Good point, I tend to agree with you. Also I found that I should probably mock the child workflow using `env.OnWorkflow`.

Closing...

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 15:42:09.000 UTC</summary>

By the way, for integration testing, have a look at this package: https://pkg.go.dev/github.com/DataDog/temporalite/temporaltest

</details>

<details>
<summary><strong>jackielii</strong> commented on 2022-05-16 15:45:30.000 UTC</summary>

> By the way, for integration testing, have a look at this package: https://pkg.go.dev/github.com/DataDog/temporalite/temporaltest

Nice! I'm using temporalite for local dev, didn't realise it has a testserver impl as well. Will be using this one.

FWIW, my workflow is a recursive one, so `OnWorkflow` probably won't work in this case, but the integration test feels the right way to go.

Thanks again.

</details>


---

<a id="797"></a>

### #797: Access raw error message

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/797 |
| **State** | CLOSED |
| **Author** | guptamridul1809 (Mridul Gupta) |
| **Created** | 2022-04-29 13:37:11.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-29 18:53:03.000 UTC |
| **Closed** | 2022-04-29 18:53:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The various error types exposed in the temporal workflows do not provide access to the raw error message.
The .Error() method on these error types adds a bunch of details along with the error message.

The .message() method on them is private as well.

Is there a way to access the raw error message from these error structs?

#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2022-04-29 13:39:04.000 UTC</summary>

Can you give the specific errors you cannot get the underlying errors out of via `errors.Unwrap()`? We try to stick to proper `Unwrap()` convention but we miss some.

</details>

<details>
<summary><strong>guptamridul1809</strong> commented on 2022-04-29 17:53:58.000 UTC</summary>

<img width="698" alt="image" src="https://user-images.githubusercontent.com/97242793/165996687-d55205a9-1e6f-42db-851e-f89221e224ee.png">

We're passing a custom error type from worker which gets wrapped inside a ApplicationError.
When trying to get the error message from the ApplicationError it formats the string with error type and non-retryable bool. I need the raw error message from the Application Error to pass it on to the UI.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-29 18:09:55.000 UTC</summary>

Ah, the raw message. We have just solved this in #766 and it is in master and will be released with the next release (a week or two).

Reactions: ðŸŽ‰ 1

</details>

<details>
<summary><strong>guptamridul1809</strong> commented on 2022-04-29 18:53:03.000 UTC</summary>

Awesome! thanks @cretz 

</details>


---

<a id="732"></a>

### #732: lookup failed for scheduledEventID to activityID

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/732 |
| **State** | CLOSED |
| **Author** | alenkacz (Alena Varkockova) |
| **Created** | 2022-02-17 16:43:23.000 UTC (3y 10m ago) |
| **Updated** | 2022-04-13 15:24:52.000 UTC |
| **Closed** | 2022-04-13 15:24:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Workflow will finish

## Actual Behavior
```
{"level":"warn","ts":1645115845.2496362,"caller":"log/zap_logger.go:134","msg":"Failed to process workflow task.","Namespace":"default","TaskQueue":"provisioner","WorkerID":"1@ring0-provisioner-684cdd5678-mdgzw@","WorkflowType":"UpsertDataClusterWorkflow","WorkflowID":"CreateDataCluster_org2ctr909","RunID":"4bd28470-fe4b-453d-8d26-d83c64ca318c","Attempt":46,"Error":"lookup failed for scheduledEventID to activityID: scheduleEventID: 35, activityID: 35","logging-call-at":"internal_task_pollers.go:308"}
{"level":"error","ts":1645115875.377161,"caller":"log/zap_logger.go:142","msg":"Workflow panic","Namespace":"default","TaskQueue":"provisioner","WorkerID":"1@ring0-provisioner-684cdd5678-mdgzw@","WorkflowType":"UpsertDataClusterWorkflow","WorkflowID":"CreateDataCluster_org2ctr909","RunID":"4bd28470-fe4b-453d-8d26-d83c64ca318c","Attempt":49,"Error":"lookup failed for scheduledEventID to activityID: scheduleEventID: 35, activityID: 35","StackTrace":"process event for provisioner [panic]:\ngo.temporal.io/sdk/internal.panicIllegalState(...)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_decision_state_machine.go:395\ngo.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc00049f720, 0xc000022540, 0x2, 0x23)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_decision_state_machine.go:928 +0x165\ngo.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc0006352c0, 0xc0007febc0, 0x1, 0x0, 0x0)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_event_handlers.go:824 +0x45b\ngo.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0003e81c0, 0xc0006bb140, 0x4514520, 0xc0003f3570, 0xc0003e81c0, 0x0)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_handlers.go:878 +0x7a5\ngo.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc0001aa370, 0xc0006bb140, 0xc0005d3e30, 0x0, 0x0, 0x0, 0x0)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_handlers.go:727 +0x6d9\ngo.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc00065d930, 0xc0006bb140, 0x0, 0x0)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_pollers.go:284 +0x4ae\ngo.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc00065d930, 0x2582ac0, 0xc0006bb140, 0x0, 0x10000c00074b500)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_pollers.go:255 +0x85\ngo.temporal.io/sdk/internal.(*baseWorker).processTask(0xc000418140, 0x2582680, 0xc000287d60)\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_worker_base.go:398 +0x115\ncreated by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_worker_base.go:302 +0xff","logging-call-at":"internal_task_handlers.go:928","stacktrace":"go.temporal.io/server/common/log.(*zapLogger).Error\n\t/go/pkg/mod/go.temporal.io/server@v1.14.5/common/log/zap_logger.go:142\ngo.temporal.io/server/common/log.(*SdkLogger).Error\n\t/go/pkg/mod/go.temporal.io/server@v1.14.5/common/log/sdk_logger.go:83\ngo.temporal.io/sdk/internal.(*workflowExecutionContextImpl).applyWorkflowPanicPolicy\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_handlers.go:950\ngo.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_handlers.go:928\ngo.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_handlers.go:727\ngo.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_pollers.go:284\ngo.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_task_pollers.go:255\ngo.temporal.io/sdk/internal.(*baseWorker).processTask\n\t/go/pkg/mod/go.temporal.io/sdk@v1.13.0/internal/internal_worker_base.go:398"}
```

## Steps to Reproduce the Problem

  1. Start a workflow with session
  1. in the middle of session, kill the worker pod
  1. the workflow never finishes and yields the mentioned error

## Specifications

  - Version: 1.14.5 of server, 1.13.0 SDK
  - Platform: kubernetes


#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2022-02-17 16:45:00.000 UTC</summary>

I believe this is an offshoot of https://github.com/temporalio/sdk-go/issues/722. Basically if your worker stops mid-session your workflow won't properly work. We are actively addressing.

</details>

<details>
<summary><strong>simon0191</strong> commented on 2022-03-07 22:01:01.000 UTC</summary>

Is this fixed by https://github.com/temporalio/sdk-go/pull/746?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-03-08 14:51:57.000 UTC</summary>

I do believe it is yes (sorry, forgot to update this when I updated #722). I will leave open until I make a release w/ that fix.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-13 15:24:52.000 UTC</summary>

This has since been released.

</details>


---

<a id="703"></a>

### #703: Heartbeat timeout failure for async waiting activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/703 |
| **State** | CLOSED |
| **Author** | zhishi |
| **Created** | 2022-01-21 19:28:50.000 UTC (3y 11m ago) |
| **Updated** | 2022-12-02 21:41:21.000 UTC |
| **Closed** | 2022-12-02 21:41:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When I use an async activity to wait for manual input, it returned a heartbeat failure after long enough time, which is not expected. I think temporal server should either auto generate heartbeat or just check the activity status if it's in activity.ErrResultPending status then never timeout heartbeat.

Since async activity is not really running, we can't implement any heartbeat for it. Although I can just fully disable heartbeat check, but it's useful for other long running activity. 

#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2022-01-21 19:56:41.000 UTC</summary>

> Since async activity is not really running, we can't implement any heartbeat for it

From the Temporal server perspective it is running. Whatever external activity completion method you are using, `CompleteActivity` or `CompleteActivityByID`, there is an equivalent external activity heartbeating mechanism - `RecordActivityHeartbeat` or `RecordActivityHeartbeatByID` respectively. You'll need to continue to send heartbeats within the heartbeat timeout while the activity is considered running from the server POV.

</details>

<details>
<summary><strong>zhishi</strong> commented on 2022-01-21 20:50:26.000 UTC</summary>

That sounds a solution, thanks. But usually the external input come from another service which usually don't have logic to update periodically when waiting for a user input. 

Since temporal server already know the activity is waiting for async completion (based on the ErrResultPending return), it's not hard to handle this case specially. I think the purpose of heartbeat is really to detect worker deadlock or hanging problem rather than this case, while async completion is designed for long time waiting should handle the heartbeat problem.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-01-21 21:07:53.000 UTC</summary>

It is by intention that starting an activity with a heartbeat timeout must have heartbeats within that timeout occur until it is completed/failed. The purpose of the heartbeat is to ensure the activity execution hasn't gone away, potentially store state to be used by retried activities, and to check whether the activity was cancelled.

Your use case sounds like it may work better with a signal response or child workflow which don't require heartbeats. Or otherwise not requiring a heartbeat when you start the activity if you cannot always provide it for the life of the activity (not recommended though).

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 21:41:20.000 UTC</summary>

Closing as this is the intended behavior  

</details>


---

<a id="671"></a>

### #671: How to provide an Authorization Token in Golang

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/671 |
| **State** | CLOSED |
| **Author** | app/ |
| **Created** | 2021-12-14 06:40:19.000 UTC (4 years ago) |
| **Updated** | 2022-05-06 13:14:54.000 UTC |
| **Closed** | 2022-01-18 15:23:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

the golang sdk doc dose not talk about any possible way how a user can provide authorization token, just like in java sdk theres a separate doc for authorization. can we have a similar doc, and i would like to know how it can be done.

https://docs.temporal.io/docs/content/how-to-provide-an-authorization-token-in-java

#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2021-12-14 17:14:15.000 UTC</summary>

I have opened https://github.com/temporalio/samples-go/issues/160 to address this.

There are two ways, you can set `client.Options.HeadersProvider` with an instance that returns a map with `Authorization` as the key and `Bearer <mytoken>` as the value.

The other way is only on the newest SDK. You can set gRPC dial options directly on `client.Options.ConnectionOptions.DialOptions` which could have an interceptor where you can set the header via gRPC metadata. This is basically how the first way is implemented.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-01-18 15:23:10.000 UTC</summary>

Sample PR merged

</details>

<details>
<summary><strong>AbhayP-22</strong> commented on 2022-05-06 11:56:22.000 UTC</summary>

Do we have the sample to add token in go lang SDK

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-06 13:14:53.000 UTC</summary>

The sample at https://github.com/temporalio/samples-go/tree/main/serverjwtauth shows how to make a custom header provider at https://github.com/temporalio/samples-go/blob/b49280daa78f354036d7d749157252369bca9b89/serverjwtauth/keyutil.go#L135 to set headers with a token.

</details>


---

<a id="654"></a>

### #654: Mocked version of `ExecuteWorkflow` doesn't accept a custom Context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/654 |
| **State** | CLOSED |
| **Author** | dorsec (Dor Fire) |
| **Created** | 2021-11-29 09:34:10.000 UTC (4y 1m ago) |
| **Updated** | 2025-09-26 21:55:58.000 UTC |
| **Closed** | 2025-09-26 21:55:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
In our tests, we need to jump through hoops and provide a custom Context Propagator, because the mock version
of `ExecuteWorkflow` doesn't take in a context.Context param.
The regular (production) version of `ExecuteWorkflow` DOES accept such a parameter.

**Describe the solution you'd like**
Add a ctx param to the mock variant of `ExecuteWorkflow` and propagate it.



#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2021-11-29 18:06:04.000 UTC</summary>

@dorsec - I am assuming you're talking about `testsuite.TestWorkflowEnvironment.ExecuteWorkflow` and not `mocks.Client.ExecuteWorkflow`, correct?

Can you provide more information on how you are using the context to `Client.ExecuteWorkflow`? The context is for client calls only (and there is no client for the testsuite) and doesn't really affect the running of the workflow.

Also, in the master branch and soon to be released, if it helps you, there are now `Interceptors` on the worker options which support intercepting both outbound (i.e. client call) and inbound (i.e. workflow invocation request) `ExecuteWorkflow` calls. They can perform similar functions to context propagators though, so likely unrelated to the root of this problem.

</details>

<details>
<summary><strong>dorsec</strong> commented on 2021-12-05 18:19:13.000 UTC</summary>

The code in my workflows/activities may rely on context information (e.g. user ID).
So, in tests, it needs to be passed from somewhere - and `testsuite.TestWorkflowEnvironment.ExecuteWorkflow` doesn't allow for it :)

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-06 14:03:34.000 UTC</summary>

> The code in my workflows/activities may rely on context information (e.g. user ID).

But you can't inject user values into the context that is given to your workflow (unless you're using interceptors or context propagators). The internal system creates the `workflow.Context`. Same for activities and `context.Context`. If you have multiple workers, sometimes the workers/activities run on completely different machines than where they were executed.

Can you give me an example of what you're doing without the test environment and maybe I can show how you can do it with the test environment?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-26 21:55:58.000 UTC</summary>

Closing due to lack of concrete use case, if a use case does come up we can consider reopening this issue.  

</details>


---

<a id="628"></a>

### #628: Workflow API to check if ContinueAsNew is required

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/628 |
| **State** | CLOSED |
| **Author** | rylandg (Ryland Goldstein) |
| **Created** | 2021-11-11 21:11:32.000 UTC (4y 1m ago) |
| **Updated** | 2023-08-19 17:16:00.000 UTC |
| **Closed** | 2023-08-19 17:16:00.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement, external dependency |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

When writing infinitely running Workflows, handling ContinueAsNew becomes an immediate requirement in the design. For applications that have multiple infinitely running Workflow types, managing the correct ContinueAsNew timing/behavior becomes tedious and frustrating. 

To solve this problem, I personally resorted to wrapping the Workflow API in a struct. This essentially functions as an unofficial interceptor and maintains a counter of "actions" (transitions basically) by incrementing the count each time a stateful API is called (ExecuteActivity, SignalWorkflow etc). Then each infinitely running Workflow is required to regularly check the counter and see if its exceeded the safe threshold. If it has, we then ContinueAsNew.

It would be ideal if this was provided out of the box. Ideally on the Client it would be possible to specify the safe limits for a given Workflow type such that the API can be dynamically configured for each specific case. At minimum it would be great to know the number of events and history size for a Workflow. 



#### Comments (2)

<details>
<summary><strong>bergundy</strong> commented on 2021-11-11 22:28:20.000 UTC</summary>

This was already requested for TS https://github.com/temporalio/sdk-typescript/issues/357.
Once we implement it there we'll port to the other SDKs.

</details>

<details>
<summary><strong>robholland</strong> commented on 2022-01-29 20:32:12.000 UTC</summary>

The history size is now available in WorkflowInfo protobuf so this should be easy to add.

</details>


---

<a id="618"></a>

### #618: Fix worker.New docs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/618 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-05 14:06:33.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-23 17:33:30.000 UTC |
| **Closed** | 2021-11-23 17:33:30.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

`worker.New` has docs that refer to a non-existent `namespace` param (also check other docs for the same bad params).

#### Comments (2)

<details>
<summary><strong>ibeckermayer</strong> commented on 2021-11-11 23:48:32.000 UTC</summary>

Specifically [here](https://github.com/temporalio/sdk-go/blob/v1.11.0/worker/worker.go#L209). I was also confused by this, and remain confused as to why `worker.New` requires a `client.Client`. 

Shouldn't it be possible to create a `Worker` without a `Client`? I was studying the hello world example, and was thrown for a loop by the fact that you need to [create a client to create a worker](https://github.com/temporalio/samples-go/blob/main/helloworld/worker/main.go), but then that client is effectively ignored afterwards, and another client is created and used separately [to actually invoke the workflow](https://github.com/temporalio/samples-go/blob/main/helloworld/starter/main.go).

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-12 15:22:48.000 UTC</summary>

@ibeckermayer - There may be a bit of confusion. A worker needs a client _and_ you need one to start a workflow. A worker processes server events and therefore needs a client to communicate with the server. To start a workflow is an API call and therefore needs a client to communicate with the server.

I will clarify the worker.New docs soon.

</details>


---

<a id="594"></a>

### #594: Metric for determining task pool status

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/594 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-10-18 19:21:06.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-23 17:28:02.000 UTC |
| **Closed** | 2021-11-23 17:28:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

No way to determine via metrics alone that all internal workers are busy and therefore not accepting new tasks.

**Describe the solution you'd like**

Need at least a metric showing how many workers are busy/running (consider a label per worker type). If possible, include a metric showing that the system is blocked.

**Additional context**

Note, while a deadlock error does exist for workflows at https://github.com/temporalio/sdk-go/blob/6bbdd9eeef901bf5b7782114724d5ad906ba7f2e/internal/internal_workflow.go#L890 with a timeout, there may not be one for activities and we can consider such an option (keeping in mind that activity tasks are known to be potentially long running).


#### Comments (4)

<details>
<summary><strong>jmoseley</strong> commented on 2021-10-18 19:27:55.000 UTC</summary>

This is great. I think another useful metric would be a measure of how much of the thread pool is available. This would let us dynamically scale our fleet when we reach X% capacity.

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-10-19 16:29:07.000 UTC</summary>

> Need at least a metric showing how many workers are busy/running (consider a label per worker type). If possible, include a metric showing that the system is blocked.

FYI workers isn't the relevant metric here (users almost never will have more than one worker per process, they can, but it's unusual). The thing we're really looking for here is number of active workflows & activities, as in the options you can specify a max number of concurrent workflows/activities you'll allow (per worker). Possibly better is to actually report the number of currently free slots, rather than number used.

As for the deadlock, I don't think there's anything to be done automatically for activities. Heartbeating is the mechanism for ensuring running activities are making progress.


</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-19 16:42:49.000 UTC</summary>

> FYI workers isn't the relevant metric here (users almost never will have more than one worker per process, they can, but it's unusual).

Yes, sorry, I meant the internal worker concept in the Go SDK, not Temporal workers. I should call this "concurrent tasks" or something.

> As for the deadlock, I don't think there's anything to be done automatically for activities. Heartbeating is the mechanism for ensuring running activities are making progress.

Agreed, I can't think of anything to do here to report activity blocking. I think all we can really do is have a gauge for running tasks and a fixed metric for max tasks (or maybe not so fixed once #569 is done).

</details>

<details>
<summary><strong>jmoseley</strong> commented on 2021-10-19 16:44:55.000 UTC</summary>

> a gauge for running tasks and a fixed metric for max tasks

That would let me determine if my fleet of workers is large enough for the workload or not, which would be very useful.

</details>


---

<a id="533"></a>

### #533: ContinueAsNew which transfers all unprocessed signals to new run

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/533 |
| **State** | OPEN |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2021-09-14 18:52:03.000 UTC (4y 3m ago) |
| **Updated** | 2021-12-30 20:01:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
If a developer fails to drain signal channel before calling ContinueAsNew then it might result in
loosing important signals without processing them.

**Describe the solution you'd like**
Add ability to transfer all unprocessed Signals to new run after ContinueAsNew


#### Comments (4)

<details>
<summary><strong>mytototo</strong> commented on 2021-12-22 14:09:37.000 UTC</summary>

Currently, what is the best approach to _transfer_ signals from a workflow to a continue as new?

What's the best way to deal with:
```go
for signalChan.ReceiveAsync(&val) {
  // ...
}
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-28 17:33:55.000 UTC</summary>

There is no transferring of signals today. You have to wait until all signals are drained. So that loop will exit when `signalChan` is drained and you can return continue-as-new after that.

</details>

<details>
<summary><strong>mytototo</strong> commented on 2021-12-28 18:57:49.000 UTC</summary>

I understand. As of today, what is the best workaround to achieve something like this? How can we ensure to process all signals in a new workflow so none are lost? In other words, what would be the idiomatic way to transfer signals or execute a new workflow within the loop?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-30 20:01:32.000 UTC</summary>

If you are using a selector for receiving signals, the best way is to continually `selector.Select` until `selector.HasPending()` is false. If you are just operating on that signal directly, you can continually `ReceiveAsync` until its return value is false.

</details>


---

<a id="463"></a>

### #463: Retry Policy Loglevel

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/463 |
| **State** | CLOSED |
| **Author** | lunne (Mathias Ehrlin) |
| **Created** | 2021-06-13 18:18:36.000 UTC (4y 7m ago) |
| **Updated** | 2025-08-25 15:24:05.000 UTC |
| **Closed** | 2025-08-25 15:24:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When you use temporal retry in a way that a retry is expected and not a error it would be good to be able to set the level for the event.

maybe pass something in the activity options?



#### Comments (4)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-21 16:47:32.000 UTC</summary>

Can you explain your use case better? Is it possible that we need to permanently adjust log levels for some messages?

</details>

<details>
<summary><strong>lunne</strong> commented on 2021-07-05 10:32:07.000 UTC</summary>

We send a message to a external API to check the status of a object. One status returns a non-retryable error and all other will return a retryable application error.

this way we can poll the api until we get one of the two statuses. We expect it to retry a couple of times each time before the activity completes.  

So maybe if we could specify in the Golang application error that it should not log it would be good?

</details>

<details>
<summary><strong>KrzysztofJopek</strong> commented on 2024-07-26 07:47:20.000 UTC</summary>

I am experiencing the same issue. Polling using activity retries works great, but logs get spammed by expected "errors".
I was able to hack a workaround by implementing a custom logger and filtering logs with "Activty Error." message and specific error in "Error" keyval. However, that's a terrible solution. I would prefer to not rely on internal temporal log, which may change anytime, to handle such issues.

One simple solution would be to add a new "log-level" field in [ApplicationErrorOptions](https://github.com/temporalio/sdk-go/blob/master/internal/error.go#L124) which can be checked before executing the [Activity Failed log](https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L2223).

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-25 15:24:05.000 UTC</summary>

This is now resolved by the new `ApplicationErrorCategory` field 

</details>


---

<a id="444"></a>

### #444: maxRPCTimeout value is too long

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/444 |
| **State** | OPEN |
| **Author** | mastermanu |
| **Created** | 2021-05-14 19:44:53.000 UTC (4y 8m ago) |
| **Updated** | 2025-04-09 12:26:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When creating a gRPC context for a call, we take the existing context deadline, calculate the remaining time, divide by two, and then either round up the RPC timeout to a minimum (currently 1 second) or round it down to a maximum (currently 10 seconds).

The problem here is that with a 10 second timeout, if the gRPC connection is uncleanly severed with a request is in flight, then it will take the full 10 seconds before the call is failed and then retried. For long polls requests, this is even worse with a 70 second time out. As a result, SDK users can see spikes in overall latencies if they Temporal Cluster they are connecting to is undergoing an upgrade or recycling.

We should do a few things to enable the user to minimize the exposure here depending on their scenario. Options include (but are not limited to):

1) reduce the maximum gRPC timeout from 10 seconds to something smaller (of course, this could impact scenarios where the customer is sending/receiving large payloads on a low-bandwidth connection).
2) Enable the user to specify what the maximum gRPC request timeout should be so that they can make the decision for themselves.
3) Have more intelligently calculated timeouts or consider decoupling timeout from the context timeout on the request.

#### Comments (4)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-27 05:54:41.000 UTC</summary>

Do we know what is our p99.9 for the cloud service calls (excluding long poll)? Maybe we should adjust the default and set it to a multiple of that as an upper limit for all non long-poll calls? But then as you've mentioned we may start timing out calls with larger payloads. 
I'm not a big fan of being too smart with timeouts and trying to calculate them on the fly based on payload sizes or things alike as it may result in unexpected behavior that can be difficult to debug.
On one hand I think making maxRPCTimeout configurable could solve the problem of large payloads, allowing us to have lower the default, but on the other if users are going to hit the limit often enough they would start overriding it back to higher values, which would bring us back to the square one.
For long polls I don't think we can do much better besides keepalive check as we want those timeouts to be as long as they are.
Better question, I think, is why would we abruptly drop connections during maintenance on the server? Isn't it possible to do a graceful shutdown of a node instead? Then we would avoid this problem in a first place.

</details>

<details>
<summary><strong>mastermanu</strong> commented on 2021-05-27 23:34:53.000 UTC</summary>

agree that we should try our best to make sure node shutdowns are graceful. but that can never truly be guaranteed. also agree that smart logic for timeouts is ugly. Will get back to you on P99 latency, but at least letting maxRPCTimeout be configurable (w/o changing current default) might be an okay option for now?

</details>

<details>
<summary><strong>antmendoza</strong> commented on 2025-04-08 14:37:13.000 UTC</summary>

>  letting maxRPCTimeout be configurable (w/o changing current default) might be an okay option for now?

+1 

Some customers would like to set the RPC timeout > 10 seconds (specifically for StartWorkflowExecution), and [the current implementation doesn't allow it](https://github.com/temporalio/sdk-go/blob/729bc240a1004e1a897c4144bed5489e61a6b768/internal/internal_utils.go#L132-L138). 

I think this should be configurable in the Go SDK, as it is in other SDKs like Java and TypeScript 

Related issue: https://github.com/temporalio/sdk-go/issues/1104 





</details>

<details>
<summary><strong>cretz</strong> commented on 2025-04-09 12:26:13.000 UTC</summary>

@antmendoza - Not that we disagree, but can you share the use case for having a call that should complete in milliseconds have its timeout over 10s?

</details>


---

<a id="429"></a>

### #429: Activity RetryPolicy MaximumAttempts behaves differently in workflow unit test compared to executing same workflow against real temporal server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/429 |
| **State** | CLOSED |
| **Author** | anz-rfc |
| **Created** | 2021-05-05 06:31:31.000 UTC (4y 8m ago) |
| **Updated** | 2022-07-08 13:58:58.000 UTC |
| **Closed** | 2022-07-08 13:58:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

If a workflow sets Activity RetryPolicy with MaximumAttempts=1 then corresponding activity execution will not be attempted more than 1 time.

This expectation is based on interpretation of MaximumAttempts parameter as documented in [temporal-v0.28.0-changelog](https://docs.temporal.io/blog/temporal-v0.28.0-changelog/#what-has-changed):

> Activity retry refactors ðŸ” :
> To disable Activity retries, configure Activities with RetryOptions that set maximumAttempts to 1.

The number of retry attempts when running against real temporal server (temporalio/auto-setup:1.7.0 ) and running the workflow using the temporal go SDK workflow unit test framework will be the same.

## Actual Behavior

When running the workflow using the temporal go sdk workflow unit test framework, if a workflow sets a Activity RetryPolicy with MaximumAttempts=1 then corresponding activity execution is attempted _twice_ (one more time than expected).

Similiar pattern observed if MaximumAttempts is set to some value n > 1  During unit tests the activity is executed n+1 times, one more time than expected.

The same behaviour is not observed when the workflow is run against a real temporal server outside of the temporal go sdk unit test framework

## Steps to Reproduce the Problem

### unit test `retry_test.go` reproduces this behaviour

```
package main

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/workflow"
)

const MaximumActivityExecutionAttempts = 1

var NoRetryPolicy = temporal.RetryPolicy{
	InitialInterval:        time.Second * 1,
	BackoffCoefficient:     2.0,
	MaximumInterval:        time.Second * 60,
	MaximumAttempts:        MaximumActivityExecutionAttempts,
	NonRetryableErrorTypes: []string{},
}

var StandardActivityOptions = workflow.ActivityOptions{
	TaskQueue:              "test",
	ScheduleToCloseTimeout: time.Hour * 24 * 3,
	ScheduleToStartTimeout: time.Hour * 24 * 3,
	StartToCloseTimeout:    time.Hour * 24 * 3,
	WaitForCancellation:    false,
	RetryPolicy:            &NoRetryPolicy,
}

func Foo(ctx workflow.Context) error {
	ctx = workflow.WithActivityOptions(ctx, StandardActivityOptions)
	err := workflow.ExecuteActivity(ctx, Bar).Get(ctx, nil)
	return err
}

func Bar(ctx context.Context) error {
	return nil
}

type RetryActivitySuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite

	env *testsuite.TestWorkflowEnvironment
}

func (s *RetryActivitySuite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()
	s.env.SetStartWorkflowOptions(client.StartWorkflowOptions{RetryPolicy: nil})
	s.env.RegisterWorkflow(Foo)
}

func (s *RetryActivitySuite) AfterTest(suiteName, testName string) {
	s.env.AssertExpectations(s.T())
}

func (s *RetryActivitySuite) TestActivityRetryPolicyMaximumOneAttempt() {

	var count int = 0

	s.env.OnActivity(Bar, mock.Anything).Return(
		func(ctx context.Context) error {
			count += 1
			err := fmt.Errorf("simulated Bar activity failure (mock has been called %d time(s))", count)
			return err
		},
	)

	s.env.ExecuteWorkflow(Foo)
	s.True(s.env.IsWorkflowCompleted())
	s.Error(s.env.GetWorkflowError())

	// We expect the mock Bar activity to be called
	// the same number of times as the activity retry policy's
	// MaximumAttempts parameter
	s.Equal(MaximumActivityExecutionAttempts, count)
}

func TestRetryActivitySuite(t *testing.T) {
	suite.Run(t, new(RetryActivitySuite))
}
```


```
mkdir -p temporal_retry_in_test_harness && cd temporal_retry_in_test_harness
go mod init example.com/temporal_retry_in_test_harness
# <save copy of above test as retry_test.go in working dir>
go test -v ./...
```

the test will fail and the following output will be visible


```
$ go test -v ./...
=== RUN   TestRetryActivitySuite
=== RUN   TestRetryActivitySuite/TestActivityRetryPolicyMaximumOneAttempt
2021/05/05 16:27:13 ERROR Activity error. WorkflowID default-test-workflow-id RunID default-test-run-id ActivityType Bar Attempt 1 Error simulated Bar activity failure (mock has been called 1 time(s))
2021/05/05 16:27:13 DEBUG Auto fire timer TimerID 2 TimerDuration 2s TimeSkipped 2s
2021/05/05 16:27:13 ERROR Activity error. WorkflowID default-test-workflow-id RunID default-test-run-id ActivityType Bar Attempt 2 Error simulated Bar activity failure (mock has been called 2 time(s))
2021/05/05 16:27:13 DEBUG handleActivityResult: *workflowservice.RespondActivityTaskFailedRequest. ActivityID 1 ActivityType Bar
    retry_test.go:80: 
        	Error Trace:	retry_test.go:80
        	Error:      	Not equal: 
        	            	expected: 1
        	            	actual  : 2
        	Test:       	TestRetryActivitySuite/TestActivityRetryPolicyMaximumOneAttempt
    workflow_testsuite.go:771: PASS:	Bar(string)
--- FAIL: TestRetryActivitySuite (0.00s)
    --- FAIL: TestRetryActivitySuite/TestActivityRetryPolicyMaximumOneAttempt (0.00s)
FAIL
FAIL	example.com/temporal_retry_in_test_harness	1.054s
FAIL
```

## Specifications

  - Version: go.temporal.io/sdk v1.6.0
  - Platform: macOS catalina

`cat go.mod`

```
$ cat go.mod 
module example.com/temporal_retry_in_test_harness

go 1.14

require (
	github.com/stretchr/testify v1.7.0
	go.temporal.io/sdk v1.6.0
)
```

`cat go.sum | grep -i temporal`

```
go.temporal.io/api v1.4.1-0.20210318194442-3f93fcec559f h1:TuHm1nX42+u7/5j9N9Mg3eX4jsri7mrpd0FivOciBH0=
go.temporal.io/api v1.4.1-0.20210318194442-3f93fcec559f/go.mod h1:c2dcPOVyWUq3IH9RIzfmKkKNSfHotYcfNzJOW+demW8=
go.temporal.io/sdk v1.6.0 h1:uVbyCd6Rs77rk5ohhWRYtPnQ7STZD2xLDAkJn8JnbaQ=
go.temporal.io/sdk v1.6.0/go.mod h1:7vODGLBoovAW72JxeMq4jENWmEkzKceNVTiIEOF5xJY=
```

#### Comments (4)

<details>
<summary><strong>anz-rfc</strong> commented on 2021-05-05 06:53:11.000 UTC</summary>

From debugging the temporal go SDK during unit testing, the logic that defines how many retry attempts happen during workflow unit testing using go SDK appears to be here: 

https://github.com/temporalio/sdk-go/blob/fc2850edf7102469b569a274a3b6f4d5ac24db50/internal/internal_task_handlers.go#L1019-L1021

it is called from `go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeActivityWithRetryForTest`

In contrast, look at the handling of maximum attempts inside the actual temporal server:

https://github.com/temporalio/temporal/blob/30c89b9f91dafc13d2d75fda266d81ce8bc72f3e/service/history/retry.go#L59-L68

Related to temporal server PR "Start attempts with 1 instead of 0" https://github.com/temporalio/temporal/pull/554 , related to issue https://github.com/temporalio/temporal/issues/232


Looks perhaps like the temporal go SDK used for unit testing workflow disagrees with temporal server about 1-based vs 0-based activity execution attempt numbering.

</details>

<details>
<summary><strong>fauzymk</strong> commented on 2022-06-06 17:35:15.000 UTC</summary>

Hi, I also run into the same problem. Any solution or workaround?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-06 19:25:09.000 UTC</summary>

I will try to investigate this shortly...

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-07-08 13:58:58.000 UTC</summary>

I have confirmed that this does not occur any longer (it appears to have been fixed a while back). Pasting the exact same replication code does pass the test suite. I am closing, but please update or create a new issue if you have a test case that can replicate.

</details>


---

<a id="425"></a>

### #425: Workflow and activity with same name seems to confuse SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/425 |
| **State** | CLOSED |
| **Author** | laniehei (Lanie Hei) |
| **Created** | 2021-05-03 21:41:33.000 UTC (4y 8m ago) |
| **Updated** | 2021-08-18 05:36:43.000 UTC |
| **Closed** | 2021-08-18 05:36:43.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 ðŸ‘€ 1 |

#### Description

## Expected Behavior
If the workflow and activity are named the same thing, say `RegisterUser`, I would expect that the SDK would still choose the `RegisterUser` activity method to run.


## Actual Behavior
The test ran revealed that it was finding the Workflow `RegisterUser` function and attempting to use that signature as the activity, giving us `RegisterUserWorkflowOuput` instead of `RegisterUserActivityOutput`


## Steps to Reproduce the Problem

  1. Create a dependency and a workflow both with the same name. 
  1. Create a test expecting the unique activity output
  1. Run the test, and see that it gives you the workflow output


#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-22 02:05:45.000 UTC</summary>

I'm unable to repro this issue.
Workflow and activity code:
```
func FooBar(ctx workflow.Context, name string) error {
	ao := workflow.ActivityOptions{
		ScheduleToStartTimeout: time.Minute,
		StartToCloseTimeout:    time.Minute,
		HeartbeatTimeout:       time.Second * 20,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	logger := workflow.GetLogger(ctx)
	logger.Info("helloworld workflow started")
	var result string
	err := workflow.ExecuteActivity(ctx, "FooBar", name).Get(ctx, &result)
	if err != nil {
		logger.Error("Activity failed.", "Error", err)
		return err
	}

	logger.Info("Workflow completed.", "Result", result)

	return nil
}

func HelloWorld(ctx context.Context, name string) (string, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("hello world activity started")
	return "Hello " + name + "!", nil
}
```

Registration and worker code:
```
...
	w.RegisterWorkflowWithOptions(versioning.FooBar, workflow.RegisterOptions{Name: "FooBar"})
	w.RegisterActivityWithOptions(versioning.HelloWorld, activity.RegisterOptions{Name: "FooBar"})
...
```
As you can see I have a workflow and activity named "FooBar" and I'm able to start a workflow that runs activity using a name alias. 
```
...
	we, err := c.ExecuteWorkflow(context.Background(), workflowOptions, "FooBar", "blah")
...
```
Is there a repro that you can share?

</details>

<details>
<summary><strong>laniehei</strong> commented on 2021-08-18 05:36:43.000 UTC</summary>

Closing for now until I can repro 

</details>


---

<a id="403"></a>

### #403: Can't use `errors.Is` to check a returned error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/403 |
| **State** | CLOSED |
| **Author** | esdrasbeleza (Esdras Beleza) |
| **Created** | 2021-04-12 15:05:50.000 UTC (4y 9m ago) |
| **Updated** | 2021-09-09 17:21:35.000 UTC |
| **Closed** | 2021-09-08 21:46:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

(Moving https://github.com/temporalio/temporal/issues/1453 here, as I think I created it in the wrong place)

## Expected Behavior

If an activity returns an error from some custom error from my system, it's wrapped and I can check it using `errors.Is`.

## Actual Behavior

My error message is wrapped there, but I can't compare/check it.

## Steps to Reproduce the Problem

```golang
var ErrNotFound = errors.New("not found!")

func TestWorkflowTestSuite(t *testing.T) {
	suite.Run(t, new(WorkflowTestSuite))
}

type WorkflowTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
	env *testsuite.TestWorkflowEnvironment
}

func (s *WorkflowTestSuite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()
}

func (s *WorkflowTestSuite) TearDownTestSuite() {
	s.env.AssertExpectations(s.T())
}

func (s *WorkflowTestSuite) Test_WorkflowErrorHandling() {
	activity := func(number int) error {
		return fmt.Errorf("error: %w", ErrNotFound)
	}
	s.env.RegisterActivity(activity)

	workflow := func(ctx workflow.Context, number int) error {
		ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
			StartToCloseTimeout: time.Minute,
			RetryPolicy: &temporal.RetryPolicy{
				MaximumAttempts:    3,
				BackoffCoefficient: 2,
			},
		})

		if err := workflow.ExecuteActivity(ctx, activity, number).Get(ctx, nil); err != nil {
			return err
		}

		return nil
	}
	s.env.RegisterWorkflow(workflow)
	s.env.ExecuteWorkflow(workflow, 123)

	s.True(s.env.IsWorkflowCompleted())
	err := s.env.GetWorkflowError()
	s.ErrorIs(err, ErrNotFound)
}
```

The result will be:

```
Error:      	Target error should be in err chain:
                    expected: "not found!"
                    in chain: "workflow execution error (type: func2, workflowID: default-test-workflow-id, runID: default-test-run-id): activity error (type: func1, scheduledEventID: 0, startedEventID: 0, identity: ): error: not found! (type: wrapError, retryable: true): not found!"
                        "activity error (type: func1, scheduledEventID: 0, startedEventID: 0, identity: ): error: not found! (type: wrapError, retryable: true): not found!"
                        "error: not found! (type: wrapError, retryable: true): not found!"
                        "not found!"
```

## Specifications

  - Version: v1.5.0; 1.6.0
  - Platform: macOS


#### Comments (4)

<details>
<summary><strong>mfateev</strong> commented on 2021-04-29 21:59:20.000 UTC</summary>

TLDR; This is by design. 

The reason is that the process that called an activity and the process that implements the activity are frequently not the same. The workflow process, the activity implementation, and the process that initiated workflow can be even in different languages. For example in Go, Java, PHP, Typescript. 

So it not really possible to return a Go error across process boundaries. That's why any error which is not explicitly created as ApplicationError is converted to an ApplicationError. The error message becomes the `ApplicationError` message and the type of the original error becomes the `ApplicationError` type.

The following unit test passes:
```go
var ErrNotFound = errors.New("not found!")

func TestWorkflowTestSuite(t *testing.T) {
	suite.Run(t, new(WorkflowTestSuite))
}

type WorkflowTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
	env *testsuite.TestWorkflowEnvironment
}

func (s *WorkflowTestSuite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()
}

func (s *WorkflowTestSuite) TearDownTestSuite() {
	s.env.AssertExpectations(s.T())
}

func (s *WorkflowTestSuite) Test_WorkflowErrorHandling() {
	activity := func(number int) error {
		return fmt.Errorf("error: %w", ErrNotFound)
	}
	s.env.RegisterActivity(activity)

	workflow := func(ctx workflow.Context, number int) error {
		ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
			StartToCloseTimeout: time.Minute,
			RetryPolicy: &temporal.RetryPolicy{
				MaximumAttempts:    3,
				BackoffCoefficient: 2,
			},
		})

		if err := workflow.ExecuteActivity(ctx, activity, number).Get(ctx, nil); err != nil {
			return err
		}

		return nil
	}
	s.env.RegisterWorkflow(workflow)
	s.env.ExecuteWorkflow(workflow, 123)

	s.True(s.env.IsWorkflowCompleted())
	err := s.env.GetWorkflowError()
	var appErr *temporal.ApplicationError
	s.ErrorAs(err, &appErr)
	s.Equal(ErrNotFound.Error(), appErr.Unwrap().Error())
}
```
If you really want full control over error return ApplicationError from an activity. It also allows adding any serializable structure as details to it. Use [NewApplicationError](https://github.com/temporalio/sdk-go/blob/a39bbe82b2bab1281d24d7f18a93a9813e0e622b/temporal/error.go#L157) to create one.

</details>

<details>
<summary><strong>daveworth</strong> commented on 2021-06-03 14:30:05.000 UTC</summary>

Adding a note here after a conversation in the [Temporal Slack #go-sdk channel](https://temporalio.slack.com/archives/CTDTU3J4T/p1622670551047200).  In addition to the issue raised here, though by design, the documentation both on the website and in the code imply three different methods for getting the original error, none of which are implemented:

1. The documentation on [Go Error Handling](https://docs.temporal.io/docs/go/error-handling/) states that there is an `err.OriginalType()` method which can be used to get the original error either as a string or as an actual error type.
2. The code comments in `internal/error.go` also have two different documented methods in the same block:  [here](https://github.com/temporalio/sdk-go/blob/master/internal/error.go#L50) it states that there is `err.GetOriginalType()` while [here](https://github.com/temporalio/sdk-go/blob/master/internal/error.go#L78) it states that there is `err.Type()`. The latter _does_ exist and returns a string.

In general I wonder if a documentation improvement may be in order to capture the contents of this issue and make the calls more consistent in their usage in those three places?

Thank you!

Reactions: ðŸ‘ 3

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-08-28 19:53:30.000 UTC</summary>

We certainly need to add `Is` method to all Temporal returned errors. For example, the following code doesn't work:
```
	s.True(errors.Is(workflowErr, &temporal.CanceledError{})
```
as `CanceledError` doesn't implement the `Is` method.

</details>

<details>
<summary><strong>alexshtin</strong> commented on 2021-09-09 17:19:12.000 UTC</summary>

It doesn't work and it shouldn't. `errors.Is` is equality function, i.e. it checks if returned error chain contains exactly the same error object. And by default it compares pointers which doesn't work in our case at all, because we reconstruct errors every time they cross process boundaries. We can override `Is` method for our errors, but it should do deep compare of every field, not only type assertion because empty `CanceledError` and `CanceledError` with details are not equal. And `ApplicationError` with different message or `errType` are also not the same and checking them with `errors.Is` should return false.

There is `errors.As` also which works as type assertion. So if you want to check if `workflowErr` contains any`CanceledError` in error chain you should do:
```go
var canceledErr *temporal.CanceledError
s.True(errors.As(workflowErr, &canceledErr))
```
I agree, this is little bit cumbersome but it is what it is in the Go world. And this perfectly works with all Temporal errors because they all has `Unwrap` method.


Reactions: ðŸ‘ 2

</details>


---

<a id="395"></a>

### #395: CancelWorkflow() should return EntityNotExistsError error if workflow does not exist

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/395 |
| **State** | CLOSED |
| **Author** | ingyamilmolinar (ymolinar) |
| **Created** | 2021-03-31 16:43:31.000 UTC (4y 9m ago) |
| **Updated** | 2022-12-13 13:21:27.000 UTC |
| **Closed** | 2022-12-13 13:21:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Running CancelWorkflow(ctx, workflowID, "") by using an ID of a workflow that does not exist or that has no execution instances should return EntityNotExistsError error that is friendly with the standard `errors` package.

## Actual Behavior
The function is returning:
```
reflect.TypeOf(err) = *serviceerror.NotFound
err.Error() = sql: no rows in result set
```

So far, to distinguish this error from the rest, I need to assert the error: `_, isNotFound := err.(*serviceerror.NotFound)` which works but it's a non standard way to verify error types. I am unable to use the errors package `Is()` function.

## Steps to Reproduce the Problem

  1. Use CancelWorkflow with a non existent or terminated workflow ID and get the error
  2. errors.Is(err, &serviceerror.NotFound{}) will be false.

## Specifications

  - SDK Version: 1.5.0
  - Platform: Linux Debian 5.7.10 x86_64 GNU/Linux



#### Comments (4)

<details>
<summary><strong>Gibstick</strong> commented on 2022-12-13 12:49:17.000 UTC</summary>

I think this is still happening. The issue also occurs with `GetWorkflow`. I'm on SDK Version 1.15.0.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-13 12:58:10.000 UTC</summary>

> which works but it's a non standard way to verify error types. 

This is not true. It _is_ the standard way to verify error types. `errors.Is` is the standard way to verify _equality_. But this is a server error and you don't want to verify equality (the message the server may relay for not-found is not known), you want to verify that it is not found for any reason.

@Gibstick - Is this the problem you are having? That you are using `errors.Is` to assert type instead of using a type assertion? You should use a type assertion to assert error type.

</details>

<details>
<summary><strong>Gibstick</strong> commented on 2022-12-13 13:16:13.000 UTC</summary>

Thanks for clearing it up. To be precise I was calling `Get()` on the result of `GetWorkflow`. Indeed I had gotten error handling wrong, and looking at [`error.go`](https://github.com/temporalio/sdk-go/blob/8e0a97274eb32f7c5a637df9f0cf84a55deeb890/temporal/error.go#L205) makes it clear how I should be doing it in the cases where that file doesn't provide a nice helper for me.

With that understood, there's no bug here.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-13 13:21:27.000 UTC</summary>

:+1: Closing issue. Original report was incorrect in assuming how you check for error types in Go.

</details>


---

<a id="379"></a>

### #379: Registering activities by struct is weird in 1.5.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/379 |
| **State** | CLOSED |
| **Author** | shaunco (Shaun) |
| **Created** | 2021-03-08 21:55:27.000 UTC (4y 10m ago) |
| **Updated** | 2021-10-07 19:47:32.000 UTC |
| **Closed** | 2021-10-07 19:47:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Calling `RegisterActivity` or `RegisterActivityWithOptions` with a struct instance as the input should scope all struct methods in the Temporal registrations. That is:
```go
type MyStruct struct {
}

func (m *MyStruct) Activity1(ctx context.Context, bla string) error {
	return nil
}

func (m *MyStruct) Activity2(ctx context.Context, bla string) error {
	return nil
}

type MyOtherStruct struct {
}

func (m *MyOtherStruct) Activity1(ctx context.Context, bla string) error {
	return nil
}

func (m *MyOtherStruct) Activity2(ctx context.Context, bla string) error {
	return nil
}

...
worker.RegisterActivity(&MyStruct{})
worker.RegisterActivity(&MyOtherStruct{})
```

Should produce registrations for:
- `MyStruct.Activity1`
- `MyStruct.Activity2`
- `MyOtherStruct.Activity1`
- `MyOtherStruct.Activity2`

And similarly, calling `ExecuteActivity` or `ExecuteLocalActivity` with a struct instance:
```go
    x := &MyStruct{}
    ExecuteActivity(ctx, x.Activity1, "test")
```

should similarly scope the activity with the reflected struct name (`MyStruct.Activity1`).

## Actual Behavior
As on 1.5.0, this no longer works. When registering, `MyStruct` and `MyOtherStruct` produce naming conflicts. If I then add my own wrapper:
```go
		// If this is a struct, we have to pass the struct type name
		fnType := reflect.TypeOf(act)
		if fnType.Kind() == reflect.Ptr && fnType.Elem().Kind() == reflect.Struct {
			// Struct
			opts := activity.RegisterOptions{Name: fnType.Elem().Name()}
			worker.RegisterActivityWithOptions(act, opts)
		} else {
			// Regular function
			worker.RegisterActivity(act)
		}
```
Then the naming conflicts go away during registration, but the activities only work with `ExecuteLocalActivity` and not with `ExecuteActivity` (_unable to find activity_).

## Steps to Reproduce the Problem

1. Try with the 1.4.1 SDK - all is good
2. Try with the 1.5.0 SDK - broken

## Specifications

  - Version: 1.5.0
  - Platform: linux


#### Comments (4)

<details>
<summary><strong>shaunco</strong> commented on 2021-03-08 22:40:08.000 UTC</summary>

Although this all worked great for us (across about 12 workers) pre 1.5.0, I can't find any changes in sdk-go that would have caused this...

</details>

<details>
<summary><strong>optiman</strong> commented on 2021-03-14 00:20:06.000 UTC</summary>

Probably, this is the reason, but it was much earlier:
https://github.com/temporalio/sdk-go/pull/92/files#diff-81f3fd107107ea44dc42925f83354a318280b38ddb7223548848cfc436c1da58

If you register activities as struct methods with `Name`, it will be used as prefix for all method names:
```
worker.RegisterActivityWithOptions(&MyStruct{}, activity.RegisterOptions{Name: "MyStruct"})
```
But then you will need to pass string name to `ExecuteActivity`, not method itself:
```
workflow.ExecuteActivity(ctx, "MyStruct" + "Activity1", "test")
```

</details>

<details>
<summary><strong>shaunco</strong> commented on 2021-03-16 15:17:05.000 UTC</summary>

Thanks. Could be losing my mind, but we almost exclusively use struct methods for activities and never had to set the Name prefix, 
 pass a string name to ExecuteActivity, or had any method name conflicts until 1.5.0. The change you referenced looks pretty relevant, but we didn't start using Temporal until July of 2020, so not sure we would have ever seen the old version of that.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-07 19:47:32.000 UTC</summary>

I have confirmed, even in a fresh 1.4.1 clone, that activities are registered based on their non-qualified method name and to prevent ambiguity for the same method names on different structs a name prefix must be used. I am closing this issue as expected behavior, but please reopen if you feel this is in error. Thanks.

</details>


---

<a id="365"></a>

### #365: [Bug] Local Activities fail to deserialize at gRPC if return type is error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/365 |
| **State** | CLOSED |
| **Author** | vavsab (Ivan Sabelnikov) |
| **Created** | 2021-02-09 15:35:03.000 UTC (4y 11m ago) |
| **Updated** | 2021-02-23 06:07:25.000 UTC |
| **Closed** | 2021-02-23 06:07:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | feedmeapples |
| **Milestone** | None |

#### Description

**Describe the bug**
I'm getting error in temporal-web while trying to view workflow that contains local activities without return parameters.

**To Reproduce**
Steps to reproduce the behavior:
1. I took an example from the [Go getting started guide](https://docs.temporal.io/docs/go-run-your-first-app?_ga=2.131416204.2088473206.1612883624-657308480.1606319036) and changed it to use Local Activities.
![image](https://user-images.githubusercontent.com/10233442/107386506-96d86900-6afc-11eb-954c-9a0b54d58b83.png)
2. After I run this sample, I get â€œ13 INTERNAL: Failed to parse server responseâ€ while viewing the workflow inside of temporal-web
![image](https://user-images.githubusercontent.com/10233442/107386586-a9eb3900-6afc-11eb-8c7d-ca1f04d4b549.png)
3. I also get this error inside of temporal-web docker container
![image](https://user-images.githubusercontent.com/10233442/107386633-b66f9180-6afc-11eb-8ec0-188f95082004.png)

**Expected behavior**
I can view such workflows without getting an error

**Desktop**
 - OS: Windows
 - Browser: Chrome
 - Temporal Web Version: 1.5.2 (Docker) 
 - Temporal Version: 1.6.0 (Docker)
 
 **Additional details**
1. I also noticed that as soon as I add at least an empty return result to the activities, it starts to open without any error
 
![image](https://user-images.githubusercontent.com/10233442/107386949-077f8580-6afd-11eb-99a3-76a0ec3cb4fa.png)
2. I have started a [discussion in community](https://community.temporal.io/t/error-while-viewing-workflow-that-contains-local-activities-13-internal-failed-to-parse-server-response/1378)


#### Comments (4)

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-12 11:35:29.000 UTC</summary>

Seems node grpc is failing at parsing MarkerRecordEvent when the `result` key is set to null (which corresponds to returning nil error in activity implementation)
![image](https://user-images.githubusercontent.com/11838981/107762995-b8934500-6ce2-11eb-97b4-2101cd9bc2b4.png)

In case of returning `(interface {}, error)`, the result payload is filled:
![image](https://user-images.githubusercontent.com/11838981/107763339-58e96980-6ce3-11eb-800e-72cac8b90af3.png)


</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-17 06:28:38.000 UTC</summary>

I'm considering changing the `result` key's value in map<string, Payloads> from nil to empty array. Asked the temporal server side of the team whether this would be a backwards compatible change

Some details:
on temporal server side, when we add Marker Recorded event, we populate the `details` field with `map<string, Payloads>`
Then the `result` key value may be set to nil if activity's return type is error (set to nil). Empty payloads instead of nil could solve the issue with node grpc

![image](https://user-images.githubusercontent.com/11838981/108164770-4df95500-70a6-11eb-9650-14001ddfacfb.png)

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-18 22:37:06.000 UTC</summary>

we've discussed with the SDK team: there is no value from having empty result in the `MarkerRecordedEventAttributes.details` of type `map<string, Payloads>`. Both old [grpc](https://www.npmjs.com/package/grpc) and new [@grpc/grpc-js](https://www.npmjs.com/package/@grpc/grpc-js) libs fail to process such payload. The easiest is to fix this in go SDK itself

The issue didn't repro with sdk-java as it doesn't set `null` value in details of type `map<string, Payloads>`

</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-19 00:26:09.000 UTC</summary>

- for quick fix: Addressing this in sdk-go
- additional fix to prevent similar cases in future: Filing a bug to @grpc/grpc-js

Reactions: ðŸ‘ 1

</details>


---

<a id="353"></a>

### #353: Allow the injection of additional grpc client interceptors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/353 |
| **State** | CLOSED |
| **Author** | jmcnevin (Jeremy McNevin) |
| **Created** | 2021-02-01 21:36:45.000 UTC (4y 11m ago) |
| **Updated** | 2021-02-24 00:21:21.000 UTC |
| **Closed** | 2021-02-24 00:21:21.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | vitarb |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

This may be related to https://github.com/temporalio/sdk-go/issues/277.

In order to use a custom claims mapper / authorizer in the server, we need to be able to inject authorization metadata into the client request, but this isn't currently possible with the sdk.  I've been able to fork SDK to allow for the injection of a ` grpc.UnaryClientInterceptor` via the `ConnectionOptions` struct in order to do this, but I would like to see what the Temporal team's strategy is for doing this.

**Describe the solution you'd like**

Anything that will allow the injection of authorization metadata into the outgoing grpc context.

**Describe alternatives you've considered**

There are probably more elegant solutions than I've put together, including the creation of some sort of AuthTokenGetter interface.

#### Comments (2)

<details>
<summary><strong>jmcnevin</strong> commented on 2021-02-01 21:38:06.000 UTC</summary>

FWIW: this is the entirety of my current solution:

```diff
diff --git a/internal/client.go b/internal/client.go
index 58c4fa6..6bfbcee 100644
--- a/internal/client.go
+++ b/internal/client.go
@@ -393,9 +393,10 @@ type (

        // ConnectionOptions is provided by SDK consumers to control optional connection params.
        ConnectionOptions struct {
-               TLS                *tls.Config
-               DisableHealthCheck bool
-               HealthCheckTimeout time.Duration
+               TLS                    *tls.Config
+               DisableHealthCheck     bool
+               HealthCheckTimeout     time.Duration
+               CredentialsInterceptor grpc.UnaryClientInterceptor
        }

        // StartWorkflowOptions configuration parameters for starting a workflow execution.
diff --git a/internal/grpc_dialer.go b/internal/grpc_dialer.go
index bf23eb7..382701a 100644
--- a/internal/grpc_dialer.go
+++ b/internal/grpc_dialer.go
@@ -64,7 +64,6 @@ func dial(params dialParameters) (*grpc.ClientConn, error) {
        if params.UserConnectionOptions.TLS != nil {
@@ -64,7 +64,6 @@ func dial(params dialParameters) (*grpc.ClientConn, error) {
        if params.UserConnectionOptions.TLS != nil {
                grpcSecurityOptions = grpc.WithTransportCredentials(credentials.NewTLS(params.UserConnectionOptions.TLS))
        }
-
        // gRPC maintains connection pool inside grpc.ClientConn.
        // This connection pool has auto reconnect feature.
        // If connection goes down, gRPC will try to reconnect using exponential backoff strategy:
@@ -78,12 +77,19 @@ func dial(params dialParameters) (*grpc.ClientConn, error) {
        cp.Backoff.BaseDelay = retryPollOperationInitialInterval
        cp.Backoff.MaxDelay = retryPollOperationMaxInterval

-       return grpc.Dial(params.HostPort,
+       interceptors := params.RequiredInterceptors
+       if i := params.UserConnectionOptions.CredentialsInterceptor; i != nil {
+               interceptors = append(interceptors, i)
+       }
+
+       dialOptions := []grpc.DialOption{
                grpcSecurityOptions,
-               grpc.WithChainUnaryInterceptor(params.RequiredInterceptors...),
+               grpc.WithChainUnaryInterceptor(interceptors...),
                grpc.WithDefaultServiceConfig(params.DefaultServiceConfig),
                grpc.WithConnectParams(cp),
-       )
+       }
+
+       return grpc.Dial(params.HostPort, dialOptions...)
 }

 func requiredInterceptors(metricScope tally.Scope) []grpc.UnaryClientInterceptor {
```

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-02-23 03:08:35.000 UTC</summary>

#368 should address this issue.

</details>


---

<a id="351"></a>

### #351: [Testing] Cancellation of Parent Workflow with Child Workflow Panics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/351 |
| **State** | OPEN |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2021-01-26 19:45:01.000 UTC (4y 11m ago) |
| **Updated** | 2021-01-26 19:51:31.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 2 |

#### Description

Issue mentioned here: 

https://community.temporal.io/t/should-cancellation-termination-of-workflows-be-tested/1299

## Expected Behavior
When mocking a child workflow to run a function that cancels the parent workflow, it should return that the parent workflow was cancelled. This should be in line with how one tests cancellation on activity transitions (not cancelling activities).

## Actual Behavior
Panics/ChildWorkflowExecutionError results instead of cancellation error being returned.


## Steps to Reproduce the Problem

Parent workflow with child workflow:
```
ctx = workflow.WithChildOptions(ctx, workflow.ChildWorkflowOptions{
		ParentClosePolicy: enums.PARENT_CLOSE_POLICY_REQUEST_CANCEL,
	})
recurringWorkflowErr := workflow.ExecuteChildWorkflow(ctx, RecurringSubscription).Get(ctx, nil)
```

```
       env.OnWorkflow(subscriptions.RecurringSubscription, mock.Anything).Run(func(args mock.Arguments) {
					env.CancelWorkflow()
				})
	env.ExecuteWorkflow(subscriptions.Subscription)
	Expect(env.IsWorkflowCompleted()).To(BeTrue())
	Expect(env.GetWorkflowError()).To(HaveOccurred())
	Expect(temporal.IsCanceledError(env.GetWorkflowError())).To(BeTrue()) // Fails here
```

This results in a panic because there's no `Return` for the mock. Changing the mock to:

```
				env.OnWorkflow(subscriptions.RecurringSubscription, mock.Anything).Run(func(args mock.Arguments) {
					env.CancelWorkflow()
				}).Return(func(ctx workflow.Context) error {
					return nil
				})
				```
				
This results in no error, and the workflow isn't canceled.

## Specifications

  - Version: SDK 1.4.0
  - Platform: Testing



---

<a id="328"></a>

### #328: Registering workflows by struct

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/328 |
| **State** | CLOSED |
| **Author** | shaunco (Shaun) |
| **Created** | 2021-01-07 18:16:01.000 UTC (5 years ago) |
| **Updated** | 2021-01-12 21:51:42.000 UTC |
| **Closed** | 2021-01-12 21:51:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
For projects that have a large number of workflows, especially for CRUD-like functions across multiple topics, name collisions start to happen quickly. To work around this, we scope functions in go packages, such as `mypackage1.Create` and `mypackage2.Create`, but when we call `RegisterWorkflow`, the [internal code](https://github.com/temporalio/sdk-go/blob/ca9a4c12b25cc23546b9876b4a86acaf024df81c/internal/internal_worker.go#L495) only uses the function name with none of the package name pieces included, and those the two are both stored as `Create` and the SDK panics with `workflow name "Create" is already registered`.

**Describe the solution you'd like**
It would be really nice if we could register structs that contain exported workflow functions, in the same manner that we can currently register a collection of activities via a struct pointer.

**Describe alternatives you've considered**
While I know we can use aliases, doing so complicates executing workflows.



#### Comments (4)

<details>
<summary><strong>shaunco</strong> commented on 2021-01-07 18:50:25.000 UTC</summary>

I went down the alias path. Would still be nice to have workflow registration by struct, but no rush.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-01-12 04:14:59.000 UTC</summary>

The recommended solution is to use `worker.RegisterWorkflowWithOptions` It allows to specify the name  through `RegisterWorkflowOptions.Name`.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-01-12 04:17:51.000 UTC</summary>

Registering workflows by struct is not something we plan to support as it can be very confusing to the new users. The reason is that workflows are expected to be stateless. 

</details>

<details>
<summary><strong>shaunco</strong> commented on 2021-01-12 18:14:09.000 UTC</summary>

Fair enough.

</details>


---

<a id="239"></a>

### #239: Tracer property in WorkerOptions is missing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/239 |
| **State** | CLOSED |
| **Author** | 0x5487 |
| **Created** | 2020-08-26 06:01:55.000 UTC (5y 4m ago) |
| **Updated** | 2021-02-12 18:44:49.000 UTC |
| **Closed** | 2021-02-12 18:44:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | flossypurse |
| **Milestone** | None |

#### Description

## Expected Behavior
According to document (https://docs.temporal.io/docs/go-tracing), I am looking for `Tracer` property in WorkerOptions.  However, I can't find it.  Is that correct behavior?

 

=== from document ===
The Go client provides distributed tracing support through OpenTracing. Tracing can be configured by providing an opentracing.Tracer implementation in ClientOptions and **WorkerOptions** during client and worker instantiation, respectively. 

## Actual Behavior
No `Tracer` property in `WorkOptions`

https://pkg.go.dev/go.temporal.io/sdk/internal?tab=doc#WorkerOptions

## Specifications

  - Version: 0.29.0
  - Platform:


I am trying to use tracer feature with opentelemetry now.  It seems to me that every span is independent.  I expected all spans should have relationship in one trace.  I was wondering if there was a trace example.  thank you

#### Comments (4)

<details>
<summary><strong>alexshtin</strong> commented on 2020-08-26 17:11:54.000 UTC</summary>

Thanks for reporting this, @jasonsoft. Doc is outdated and @cullywakelin will fix it soon. I removed all duplicate options from `WorkerOptions` and move few of them to `ClientOptions`. Now `WorkerOptions` contain only worker specific options and all the rest goes to `ClientOptions`.
It seems we don't have example for tracing in our [samples repo](https://github.com/temporalio/go-samples) and there are no integration tests neither (it would be great if you contribute). For now, I can only suggest you to check [implementation](https://github.com/temporalio/go-sdk/blob/master/internal/tracer.go) and unit tests (https://github.com/temporalio/go-sdk/blob/master/internal/tracer_test.go).

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>nicolasgere</strong> commented on 2021-02-11 14:56:18.000 UTC</summary>


> 
> I am trying to use tracer feature with opentelemetry now. It seems to me that every span is independent. I expected all spans should have relationship in one trace. I was wondering if there was a trace example. thank you

I think I'm getting the same issue and if there is a bug, is still there


</details>

<details>
<summary><strong>swyxio</strong> commented on 2021-02-12 07:48:39.000 UTC</summary>

@flossypurse should we move this to docs repo?

</details>

<details>
<summary><strong>alexshtin</strong> commented on 2021-02-12 18:44:49.000 UTC</summary>

Doc at https://docs.temporal.io/docs/go-tracing/ is updated and correct.
There is integration test for context propagators at https://github.com/temporalio/sdk-go/blob/1c882f768532af62cb44e7aad66d156fd46d0724/test/integration_test.go#L777

And I also added end to end sample at https://github.com/temporalio/samples-go/blob/master/ctxpropagation/ with instructions on how to test it locally.

Don't forget to set tracer on all workers and starters (`tctl` doesn't support it).

</details>


---

<a id="178"></a>

### #178: Accept a Logger interface instead of *zap.Logger

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/178 |
| **State** | CLOSED |
| **Author** | amitmahbubani (Amit Mahbubani) |
| **Created** | 2020-07-01 13:57:33.000 UTC (5y 6m ago) |
| **Updated** | 2021-08-13 15:32:15.000 UTC |
| **Closed** | 2020-07-23 16:26:50.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | alexshtin |
| **Milestone** | Code Complete |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
I'd like to pass in a custom Logger instance when instantiating a temporal client. Expecting a `*zap.Logger` instance forces consumers to use zap. Not ideal, in my opinion.

**Describe the solution you'd like**
Consider defining a Logger interface and accepting the interface in [ClientOptions](https://github.com/temporalio/temporal-go-sdk/blob/f4d1bd21e660277c6a118325adb085cc50f98104/internal/client.go#L329). A blocker to attempting this change is that temporal-go-sdk makes use of zap's strongly-typed structured log fields, [here](https://github.com/temporalio/temporal-go-sdk/blob/f4d1bd21e660277c6a118325adb085cc50f98104/internal/internal_task_handlers.go#L1805) for example. 


**Additional context**
1. Go does not provide a standard interface. This is being discussed, [here](https://github.com/golang/go/issues/28412) and now [here](https://github.com/golang/go/issues/13182).
2. A variety of logger interfaces exist in the wild: [aws-sdk-go](https://github.com/aws/aws-sdk-go/blob/f26268b77ea9619d95b1d04b6f3e3c5a03b61110/aws/logger.go#L84), [go-redis](https://github.com/go-redis/redis/blob/dc52593c8c63bc2a05796ec44efd317fd3e14b64/internal/log.go#L8), [shopify/Sarama](https://github.com/Shopify/sarama/blob/f4f562ee274a988f02379521370ca7be8d998d98/sarama.go#L106)


#### Comments (2)

<details>
<summary><strong>sagikazarmark</strong> commented on 2020-07-16 13:09:30.000 UTC</summary>

Adding logur to the list: https://github.com/logur/logur (Full disclosure: I authored it)

I totally agree with this and I recall talking about this around January regarding workflow and activity loggers.

Go's overly simplified builtin logger caused a massive proliferation of logging libraries out there. Everyone has one, everyone use different things and having to use two or three different libraries for the same thing often causes headaches.

Generics might allow using tupple-like, strongly typed key-value pairs independently from the actual logging library, but that's waaaay down the line.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>peitili</strong> commented on 2021-08-13 15:32:15.000 UTC</summary>

I have another question, since it changed to interface, it makes the user who uses zap logger hard to pass in a zap logger to the client, is there an example of how to write zap logger adaptor and pass that to the client?

Reactions: ðŸ‘ 7

</details>


---

<a id="163"></a>

### #163: Namespace registration returns: unknown service

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/163 |
| **State** | CLOSED |
| **Author** | hazcod (Niels Hofmans) |
| **Created** | 2020-06-17 09:36:16.000 UTC (5y 6m ago) |
| **Updated** | 2020-07-08 14:29:59.000 UTC |
| **Closed** | 2020-07-08 14:29:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Successfully register a new temporal namespace.

## Actual Behavior
client.Register returns error `unknown service temporal.workflowservice.v1.WorkflowService`

## Steps to Reproduce the Problem
```go
func (b *WorkflowClientBuilder) CreateNamespace(logger *zap.Logger, namespace string, wfRetention uint32) error {
	client, err := client.NewNamespaceClient(client.Options{HostPort: b.hostPort})
	if err != nil {
		logger.Error("failed to create Namespace Client", zap.Error(err))
		return err
	}
	defer client.Close()
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	err = client.Register(ctx, &workflowservice.RegisterNamespaceRequest{
		Name: namespace,
		WorkflowExecutionRetentionPeriodInDays: int32(wfRetention),
	})
	if err == nil {
		logger.Info("Namespace created")
		return nil
	}
	if _, ok := err.(*serviceerror.NamespaceAlreadyExists); ok {
		logger.Info("Namespace already exists")
		return nil
	}
	return err
}
```

## Specifications
```
	go.temporal.io/temporal v0.24.4
	go.temporal.io/temporal-proto v0.24.4
```

temporalio/auto-setup:0.23.1

#### Comments (4)

<details>
<summary><strong>hazcod</strong> commented on 2020-06-17 09:59:36.000 UTC</summary>

I have the same issue when creating a new workflow.

</details>

<details>
<summary><strong>plaisted</strong> commented on 2020-06-20 00:47:30.000 UTC</summary>

I had this issue using mismatched versions as well, there must have been some breaking changes.  If you downgrade your go libraries to match the docker images (0.23.1) it worked as expected for me.

</details>

<details>
<summary><strong>hazcod</strong> commented on 2020-06-20 08:30:50.000 UTC</summary>

@plaisted indeed! I used :latest Docker tag & Go .24 and things seemed to magically work..

</details>

<details>
<summary><strong>ringods</strong> commented on 2020-07-08 13:46:19.000 UTC</summary>

For other people bumping into this, it could also mean that it just can't connect to the Temporal frontend service. Check the value of host and port your client or worker connects to if this error occurs.

My encounter with this error:
https://community.temporal.io/t/error-unknown-service-workflowservice-workflowservice/103/2

</details>


---

<a id="70"></a>

### #70: Refactor NewWorker and remove downcast

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/70 |
| **State** | OPEN |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-03-18 22:37:16.000 UTC (5y 9m ago) |
| **Updated** | 2025-02-07 03:06:35.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

#69 added downcast and panic to `NewWorker` in `internal/worker.go`. This needs to be refactored and removed.



#### Comments (2)

<details>
<summary><strong>jinhong-</strong> commented on 2021-05-18 13:47:39.000 UTC</summary>

I am facing an issue with this at the moment when i attempt to wrap temporal client with my own implementation. Will this eventually be removed, and what is the reason for this explicit check?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-19 19:28:38.000 UTC</summary>

As part of the new interceptors proposal at https://github.com/temporalio/proposals/pull/45 client interceptors are supported to allow interception. However, due to the worker still needing internal things from the client, it can't be wrapped, but all functionality should be available via interceptors.

</details>


---

<a id="2103"></a>

### #2103: Cosmetic bug in logger

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2103 |
| **State** | OPEN |
| **Author** | billrich2001 (Bill Richards) |
| **Created** | 2025-11-07 19:48:17.000 UTC (2 months ago) |
| **Updated** | 2025-11-19 23:02:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Issue
The logger in lines [225-228](https://github.com/temporalio/sdk-go/blob/a451bef0b7c99092974ac3d58311532d4c244896/contrib/opentelemetry/tracing_interceptor.go#L225-L228) has a bug where the TraceID and SpanID are not converted to string which is causing a cosmetic bug when log gets printed, we see the byte array instead

example:
```
{
"time": "2025-11-03T12:43:20.743360843Z",
"level": "WARN",
"msg": "RecordActivityHeartbeat with error",
"Namespace": "bluesteel-test2.bm3o6",
"TaskQueue": "bluesteel-sync",
"WorkerID": "syncWorker",
"ActivityID": "11",
"ActivityType": "rlCheckIsWorkflowFinished",
"Attempt": "1",
"WorkflowType": "rlResourceLock",
"WorkflowID": "sync-service:019a496b-4aa7-77b2-8c46-524efaeb7b1d",
"RunID": "507113fe-60ba-44c0-ad1e-c15d8ef4f45b",
"TraceID": "[52, 93, 200, 50, 90, 70, 237, 164, 31, 63, 215, 229, 177, 194, 174, 221]",
"SpanID": "[96, 239, 131, 244, 197, 70, 240, 14]",
"Error": "workflow execution already completed"
}
```

## Specifications

Bug is cosmetic, byte array isn't human readable


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2025-11-07 20:58:12.000 UTC</summary>

Mentioned internally, but will also mention here, most loggers, including Go's built-in `log` package (which our default logger uses), are expected to use `String()` on values that implement `GoStringer`. Which logger is being used in this case? I have not checked `slog` expectations compared to `fmt` and `log`.

</details>

<details>
<summary><strong>billrich2001</strong> commented on 2025-11-19 22:36:45.000 UTC</summary>

Added note.

Was able to recreate using slog and otel traceid on Go 1.21

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-11-19 23:02:36.000 UTC</summary>

For otel + slog a user should be using https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/bridges/otelslog 

</details>


---

<a id="2097"></a>

### #2097: Feature Request: Add Context to MetricsHandler for Exemplar Support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2097 |
| **State** | OPEN |
| **Author** | VinayBhupelliAPT (Vinay Bhupelli) |
| **Created** | 2025-11-05 17:07:18.000 UTC (2 months ago) |
| **Updated** | 2025-12-19 06:19:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ˜• 1 â¤ï¸ 1 |

#### Description

## The Problem

I'm using Temporal with the OpenTelemetry MetricsHandler, and I've noticed that my custom activity metrics work great with exemplars (I can click from a metric spike in Grafana directly to the trace), but the built-in Temporal SDK metrics don't have this feature.

Here's what I mean:

**My custom metrics (working great):**
```go
func ProcessPaymentActivity(ctx context.Context, orderID string) error {
    // ctx contains active span with trace_id and span_id
    // When I pass ctx to the metric, OpenTelemetry extracts these IDs
    // and attaches them as an exemplar
    paymentCounter.Add(ctx, 1, metric.WithAttributes(...))
}
```
When I look at this in Grafana, I see little dots on the graph. Each dot has the trace_id and span_id embedded. Click a dot, boom - I'm looking at the exact trace for that metric point.

**SDK metrics (not working):**
```go
// Inside Temporal SDK - internal/internal_task_handlers.go:1906
func (wth *workflowTaskHandlerImpl) completeWorkflow(...) {
    // Workflow completion
    metricsHandler.Counter(metrics.WorkflowCompletedCounter).Inc(1)
    // âŒ No context passed - can't create exemplar
}
```
([See actual code](https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L1906))

No dots. Can't click through to traces. Have to manually hunt for the trace by timestamp.

## Why This Happens

I dug into the code and found the issue. The `MetricsHandler` interface doesn't have a context parameter:

```go
// From internal/common/metrics/handler.go
type CounterIface interface {
    Inc(value int64)  // No way to pass context!
}
```

This means the OpenTelemetry bridge has no choice but to use an empty context:

```go
// From contrib/opentelemetry/metricshandler.go
func (c *counter) Inc(value int64) {
    // Can't pass the actual context, so using background
    c.otelCounter.Add(context.Background(), value)
    // context.Background() has no trace info
    // â†’ OpenTelemetry can't extract trace_id and span_id
    // â†’ No exemplar created
}
```

Without the context containing trace information, OpenTelemetry can't extract the trace_id and span_id needed to create the exemplar that links the metric to the trace.

**References in SDK code where metrics are recorded without context:**
- [internal/internal_task_handlers.go:1906](https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L1906) - `WorkflowCompletedCounter`
- [internal/internal_task_handlers.go:1916](https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L1916) - `WorkflowEndToEndLatency`
- [internal/internal_task_handlers.go:1897](https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L1897) - `WorkflowFailedCounter`
- [internal/internal_task_handlers.go:1863](https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L1863) - `WorkflowCanceledCounter`
- [internal/internal_worker_base.go:379](https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker_base.go#L379) - `WorkerStartCounter`
- [internal/internal_worker_base.go:426](https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker_base.go#L426) - `PollerStartCounter`
- Many more throughout the SDK
## Why This Matters (Real Production Scenario)

Last week we had an incident where `temporal_activity_execution_latency` spiked to 5 seconds at 2:32 PM.

**Without exemplars (current experience):**
1. Notice the spike in Grafana
2. Write down the timestamp
3. Open Tempo/Jaeger in another tab
4. Search for traces in that time window
5. Filter by activity type
6. Click through 20+ traces to find the slow one
7. Finally find it after 5-10 minutes

**With exemplars (what I want):**
1. Notice the spike in Grafana
2. Click the exemplar dot on the graph (which contains trace_id and span_id)
3. Grafana uses the trace_id to instantly open the exact trace in Tempo
4. See the root cause immediately (database timeout on retry )

This difference is huge for production debugging. The exemplar acts as a direct link from the metric data point to the specific trace execution.

## Current Workaround (Not Ideal)

Right now I have to add custom metrics in my activity code to get exemplars:

```go
func ProcessPaymentActivity(ctx context.Context, orderID string) (string, error) {
    startTime := time.Now()

    // ... payment processing logic ...

    // Custom metric WITH exemplar - works because I pass ctx
    // ctx contains active span â†’ has trace_id and span_id
    // OpenTelemetry extracts these and creates exemplar automatically
    duration := time.Since(startTime).Milliseconds()
    paymentCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("status", "success"),
            attribute.String("gateway", "stripe"),
        ),
    )
    paymentDuration.Record(ctx, float64(duration),
        metric.WithAttributes(
            attribute.String("status", "success"),
        ),
    )
    // Result: Metric stored with exemplar containing trace_id and span_id

    return result, nil
}
```

This works great for my custom metrics, but:
- The built-in Temporal SDK metrics like `temporal_workflow_completed`, `temporal_activity_execution_latency`, etc. still don't have exemplars
- I can see exemplars (with trace_id/span_id) on my custom counters, but not on the SDK's metrics
- Inconsistent experience - some metrics are clickable, some aren't
## Proposed Solution

The fix is pretty straightforward - add a context parameter to the metrics interface:

**Change the interface:**
```go
// Current
type CounterIface interface {
    Inc(value int64)
}

// Proposed
type CounterIface interface {
    Inc(ctx context.Context, value int64)
}
```

**Update SDK calls** (context is already available):
```go
// Current
a.metricsHandler.Counter(metrics.ActivityTaskError).Inc(1)

// Proposed
a.metricsHandler.Counter(metrics.ActivityTaskError).Inc(ctx, 1)
```

**OpenTelemetry bridge can now pass context:**
```go
// Current (forced to use empty context)
func (c *counter) Inc(value int64) {
    c.otelCounter.Add(context.Background(), value)
    // No trace_id or span_id â†’ no exemplar
}

// After change
func (c *counter) Inc(ctx context.Context, value int64) {
    c.otelCounter.Add(ctx, value)
    // OpenTelemetry extracts trace_id and span_id from ctx
    // Creates exemplar: {trace_id: "abc...", span_id: "123...", value: 1}
    // Metric exported with exemplar attached
}
```

Once the context is passed through, OpenTelemetry handles the rest automatically - it extracts the trace_id and span_id from the active span in the context and creates an exemplar that links the metric data point to the trace.

## Why This Would Be Awesome

**Faster debugging:** Click from metric â†’ trace in seconds instead of manually hunting for 5-10 minutes

**Better observability:** All metrics (not just custom ones) would link to traces

**Industry standard:** Prometheus, Grafana, and all major observability vendors support this pattern

## Backward Compatibility

I know this is an interface change, but there are ways to keep it backward compatible:

**Option 1:** Add a new method alongside the old one
```go
type CounterIface interface {
    Inc(value int64)  // Keep for compatibility
    IncWithContext(ctx context.Context, value int64)  // New, preferred
}
```

**Option 2:** Check if the handler supports the new interface
```go
if counter, ok := handler.Counter(name).(CounterIfaceV2); ok {
    counter.Inc(ctx, 1)  // New way
} else {
    handler.Counter(name).Inc(1)  // Old way still works
}
```

Either way, existing code keeps working, but new deployments get exemplar support automatically.

## My Setup (What's Working vs Not Working)

**Environment:**
- Temporal Go SDK with OpenTelemetry MetricsHandler
- Prometheus with exemplar storage enabled
- Tempo for traces
- Grafana for visualization

**Custom metrics (working perfectly):**
```promql
rate(payments_processed_total{status="failed"}[5m])
```
âœ… See exemplar dots on the graph
âœ… Click â†’ instant jump to trace (using trace_id from exemplar)
âœ… See exact failure reason in seconds

**SDK metrics (missing exemplars):**
```promql
rate(temporal_activity_execution_latency_count{activity_type="ProcessPayment"}[5m])
```
âŒ No exemplar dots
âŒ Can't jump to traces (no trace_id/span_id attached)
âŒ Manual correlation required

You can verify this yourself by querying Prometheus:
```bash
# Custom metric - has exemplar with trace_id and span_id
curl 'http://localhost:9090/api/v1/query_exemplars?query=payments_processed_total'
# Returns: {
#   "labels": {
#     "trace_id": "5d228c40d1fdce780dbe98fc3bd0c635",
#     "span_id": "6b70a14bf880cf66"
#   },
#   "value": "1",
#   "timestamp": 1762203470.707
# }

# SDK metric - no exemplar (empty array)
curl 'http://localhost:9090/api/v1/query_exemplars?query=temporal_activity_execution_latency'
# Returns: [] (empty - no trace_id or span_id available)
```

---

Would you consider this feature? I think it would significantly improve production debugging for anyone using OpenTelemetry.

Thanks for reading!

#### Comments (3)

<details>
<summary><strong>greatdaveo</strong> commented on 2025-12-10 08:16:32.000 UTC</summary>

Hello @Quinn-With-Two-Ns & @THardy98 , I would like to work on this. Could you please assign it to me? Thank you

Reactions: â¤ï¸ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-18 00:22:20.000 UTC</summary>

@greatdaveo We have not decided to accept this feature yet or any implementation so please do not do any work on this feature.

If a user does want to use some OTEL specific API, in this case context, the recommend approach is to use `opentelemetry.ExtractMetricsHandler` to get the actual otel metric handler from the Temporal API.

</details>

<details>
<summary><strong>greatdaveo</strong> commented on 2025-12-19 06:19:56.000 UTC</summary>

@Quinn-With-Two-Ns well noted, thank you! 
Please is there any issue at hand that you would like me to contribute then? I would like to make my first contribution, but it seems most of the issues raised are still yet to be decided on. Thanks

</details>


---

<a id="2066"></a>

### #2066: Lost messages from workflow.NewChannel(ctx)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2066 |
| **State** | OPEN |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-10-02 22:19:14.000 UTC (3 months ago) |
| **Updated** | 2025-12-10 17:57:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

No messages get lost

## Actual Behavior

Messages are getting lost. This bug was introduced in 1.35.0, from #1762


## Steps to Reproduce the Problem
Setting `unblockSelectorSignal` to `true` causes the lost items 

```
func (s *WorkflowTestSuiteUnitTest) TestChannelWorkerPattern() {
	unblockSelectorSignal = true // test passes when set to false

	assert := s.Assert()
	require := s.Require()

	// Test configuration
	numWorkers := 10
	numItems := 50
	items := make([]int, numItems)
	for i := 0; i < numItems; i++ {
		items[i] = i
	}
	// Track which items were processed
	processedItems := make(map[int]int) // maps input -> output
	// Simple workflow that mimics the channel worker pattern
	workflowFn := func(ctx Context) error {
		// Create input channel and feed items
		inputCh := NewChannel(ctx)
		Go(ctx, func(ctx Context) {
			for _, item := range items {
				inputCh.Send(ctx, item)
			}
			inputCh.Close()
		})

		// Start workers
		outputCh := NewChannel(ctx)
		wg := NewWaitGroup(ctx)
		wg.Add(numWorkers)
		// Wait group cleanup goroutine
		Go(ctx, func(ctx Context) {
			wg.Wait(ctx)
			outputCh.Close()
		})
		// Start worker goroutines
		for i := 0; i < numWorkers; i++ {
			Go(ctx, func(ctx Context) {
				defer wg.Done()
				stop := false
				selector := NewSelector(ctx)
				// Stop worker if workflow is cancelled
				selector.AddReceive(ctx.Done(), func(c ReceiveChannel, more bool) {
					stop = true
				})
				// Receive items from input channel
				selector.AddReceive(inputCh, func(ch ReceiveChannel, more bool) {
					stop = !more
					var input int
					if ch.Receive(ctx, &input) {
						output := input * 2
						outputCh.Send(ctx, output)
					}
				})
				// Worker loop
				for !stop {
					selector.Select(ctx)
				}
			})
		}
		// Collect outputs
		for i := 0; i < numItems; i++ {
			var output int
			if outputCh.Receive(ctx, &output) {
				// output = input * 2, so input = output / 2
				processedItems[output/2] = output
			}
		}
		return nil
	}
	env := s.NewTestWorkflowEnvironment()
	env.RegisterWorkflow(workflowFn)
	env.ExecuteWorkflow(workflowFn)

	require.True(env.IsWorkflowCompleted())
	require.NoError(env.GetWorkflowError())

	// Verify all items were processed exactly once
	require.Len(processedItems, numItems, "Not all items were processed")
	for i := 0; i < numItems; i++ {
		output, ok := processedItems[i]
		assert.True(ok, "Item %d was not processed", i)
		assert.Equal(i*2, output, "Item %d was not processed correctly", i)
	}
}
```

## Specifications

  - Version: 1.35.0
  - Platform:


#### Comments (3)

<details>
<summary><strong>yuandrew</strong> commented on 2025-10-07 21:20:51.000 UTC</summary>

Looks like Test_SignalNotLost did not start failing when reverting the default SDK flag. Either something might be wrong with the test or the test itself may not be useful

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-11-12 16:49:40.000 UTC</summary>

Technically not an issue anymore, due to us reverting the SDK flag, but this will need to be addressed when re-enabling the flag

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-12-10 17:57:22.000 UTC</summary>

This turns out to be a new bug created from my fixing of the linked bug.

</details>


---

<a id="2049"></a>

### #2049: Support `fmt.Stringer` in `ExecuteActivity`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2049 |
| **State** | CLOSED |
| **Author** | LukaGiorgadze (Luka Giorgadze) |
| **Created** | 2025-09-11 12:02:50.000 UTC (4 months ago) |
| **Updated** | 2025-11-17 17:30:01.000 UTC |
| **Closed** | 2025-11-17 17:30:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

PR: https://github.com/temporalio/sdk-go/pull/2050

# Support `fmt.Stringer` in `getFunctionName`

## Description
Currently, `getFunctionName` only supports raw strings or function pointers.  
If a caller passes a custom type that implements `fmt.Stringer` (e.g. a named type alias), it is treated as a function and causes error and hard to get the idea why:

```bash
INF log/with_logger.go:45 Task processing failed with error Namespace=default TaskQueue=chat-agent WorkerID=28030@Lukas-MacBook-Pro-M4.local@ WorkerType=WorkflowWorker Error="BadScheduleActivityAttributes: ActivityType is not set on ScheduleActivityTaskCommand. ActivityID=15"
```

### Example

```go
type ActivityName string

func (a ActivityName) String() string {
	return string(a)
}

var agentPlannerActivity ActivityName = "AgentPlannerActivity"

fut := workflow.ExecuteActivity(ctx, agentPlannerActivity, inputs{})
```


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-11 15:41:03.000 UTC</summary>

Hmm, so why are you not calling your activity by the function type? and why create a type alias to the activity name?

per the docs

```
Input activity is either an activity name (string) or a function representing an activity that is getting scheduled.
```

So `ExecuteActivity ` is only expected to be given a string of function. I agree the error your seeing is not great, we should probably fail sooner if we can't find an activity name.

</details>

<details>
<summary><strong>LukaGiorgadze</strong> commented on 2025-09-11 15:58:28.000 UTC</summary>

> Hmm, so why are you not calling your activity by the function type? and why create a type alias to the activity name?
> 
> per the docs
> 
> ```
> Input activity is either an activity name (string) or a function representing an activity that is getting scheduled.
> ```
> 
> So `ExecuteActivity ` is only expected to be given a string of function. I agree the error your seeing is not great, we should probably fail sooner if we can't find an activity name.

Good question. I need to run activities dynamically (doing some DSL stuff). That means I canâ€™t always call them by function pointer. I could pass plain strings or use `any`, but both lose type safety. Defining `ActivityName` gives me a safe, explicit way to pass activity names without raw strings.

Question is more like if we accept raw "string", then why not `Stringer()`?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-11 16:26:29.000 UTC</summary>

Defining your activity name as a constant makes sense, the constant just needs to be of the right type. Activity name is expected to be a string everywhere else in the SDK, the only reason we take the empty interface in execute is because Go doesn't support variant types

</details>


---

<a id="2046"></a>

### #2046: Make Deadlock Converter Configurable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2046 |
| **State** | CLOSED |
| **Author** | jonmorehouse (Jon Morehouse) |
| **Created** | 2025-09-08 17:58:36.000 UTC (4 months ago) |
| **Updated** | 2025-09-08 18:21:14.000 UTC |
| **Closed** | 2025-09-08 18:21:14.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Problem

We currently run into issues where our temporal workflows will panic with the "Potential Deadlock Detected: workflow did not yield for over 1 second" issue. This can happen for many different reasons, and does not always imply a deadlock. 

In our case, we have some large JSON and other payloads that we are fetching via activities and doing things in our native workflow code with. Obviously, this can be moved into activities which we do, but the failure mode for this is extremely destructive and causes customer facing issues for us.

## Solution

We would like to make the deadlock converter configurable, so that we can do two things:
1. add a callback for "warnings", so we can emit a metric or other data versus just failing the workflow.
2. make the warning and error thresholds configurable.

By making these two changes we could instrument when our workflows are not yielding and have visibility _Before_ workflows panic/fail, so we can fix issues before they become customer facing.

We are happy to make these changes, if this is is something that you would be okay with being contributed.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-08 18:21:14.000 UTC</summary>

Long running actions cannot be done in workflow code, workflow tasks have a strict timeout so long running actions need to be done in either and activity or local activity you can't ignore the timeout. Long running computational, even deterministic ones need to be done in activities/local acitivities. If you need to run long running operations in your data converter you can look at `DataConverterWithoutDeadlockDetection` to disable the deadlock detector just for data converters.

</details>


---

<a id="2044"></a>

### #2044: AssertActivityCalled does not capture calls or/and argument being passed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2044 |
| **State** | CLOSED |
| **Author** | ebrard (Emmanuel) |
| **Created** | 2025-09-02 14:03:44.000 UTC (4 months ago) |
| **Updated** | 2025-09-02 14:24:40.000 UTC |
| **Closed** | 2025-09-02 14:24:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Given the following workflow definition:

```go
import (
	"time"

	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/workflow"
)

func Act(input string) (output string, err error) {
	output = input
	return
}

func DummyWorkFlow(ctx workflow.Context, input string) (string, error) {

	retrypolicy := &temporal.RetryPolicy{
		InitialInterval:    time.Second,
		BackoffCoefficient: 2.0,
		MaximumInterval:    15 * time.Minute,
		MaximumAttempts:    500,
	}

	options := workflow.ActivityOptions{
		StartToCloseTimeout: 3 * time.Hour,
		RetryPolicy:         retrypolicy,
		HeartbeatTimeout:    30 * time.Second,
	}

	var result string
	if err := workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, options), Act, input).Get(ctx, &result); err != nil {
		return "", err
	}

	return result, nil

}
```

and the following test:

```go
type UnitTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
	env *testsuite.TestWorkflowEnvironment
}

func (s *UnitTestSuite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()
	s.env.SetTestTimeout(15 * time.Second)
	s.env.SetWorkflowRunTimeout(15 * time.Second)

}

func (s *UnitTestSuite) AfterTest(suiteName, testName string) {
	s.env.AssertExpectations(s.T())
}

func TestUnitTestSuite(t *testing.T) {
	suite.Run(t, new(UnitTestSuite))
}

func (s *UnitTestSuite) Test_Dummy_Workflow_Succeeds() {

	actHandler := make(map[string]string)

	s.env.SetOnActivityStartedListener(func(activityInfo *activity.Info, ctx context.Context, args converter.EncodedValues) {
		slog.Info("activity started", "activity", activityInfo.ActivityType.Name)
		var val string
		args.Get(&val)
		actHandler[activityInfo.ActivityType.Name] = val
	})

	s.env.RegisterActivity(Act)
	s.env.ExecuteWorkflow(DummyWorkFlow, "hello")
	s.env.AssertActivityCalled(s.T(), "Act", "hello")
	s.True(s.env.IsWorkflowCompleted())
	s.NoError(s.env.GetWorkflowError())
	var result string
	s.env.GetWorkflowResult(&result)
	s.Assertions.Equal("hello", result)
	s.Assertions.Equal("hello", actHandler["Act"])
}
```

## Actual Behavior

I would expect the assertion `s.env.AssertActivityCalled(s.T(), "Act", "hello")` to pass but it fails with:

```
               Error:          Should have called with given arguments
                Test:           TestUnitTestSuite/Test_Dummy_Workflow_Succeeds
                Messages:       Expected "Act" to have been called with:
                                [hello]
                                but no actual calls happened
```

Interestingly the `s.Assertions.Equal("hello", actHandler["Act"])` call passes.

## Steps to Reproduce the Problem

See code provided

## Specifications

  - Version: go 1.25, temporal go.temporal.io/sdk v1.36.0
  - Platform: macos


#### Comments (3)

<details>
<summary><strong>ebrard</strong> commented on 2025-09-02 14:13:27.000 UTC</summary>

If I mock the activity with:
```go
	s.env.OnActivity(Act, mock.Anything).Return(func(input string) (string, error) {
		return input, nil
	})
```
then both assertions passes.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-02 14:24:05.000 UTC</summary>

This is expected `AssertActivityCalled` is for asserting activity mocks are called

</details>

<details>
<summary><strong>ebrard</strong> commented on 2025-09-02 14:24:40.000 UTC</summary>

That's fair, but the documentation is not clear enough about it, IMHO.

</details>


---

<a id="1986"></a>

### #1986: SDK should warn when using structures to define a workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1986 |
| **State** | CLOSED |
| **Author** | iwittkau |
| **Created** | 2025-06-30 15:16:26.000 UTC (6 months ago) |
| **Updated** | 2025-07-16 16:57:15.000 UTC |
| **Closed** | 2025-07-16 16:57:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

I've implemented my workflows on a struct and the workflow funcs have a pointer receiver. This may have lead to errors and it's possible to detect this with static code analysis to avoid this programming error in the future.

**Describe the solution you'd like**

The `workflowcheck` command should report this.

**Describe alternatives you've considered**

Implementing a custom linter seems unnecessary since `workflowcheck` already exists. Its name also leaves room for analysis beyond determinism.

**Additional context**

As discussed here https://community.temporal.io/t/go-sdk-non-deterministic-error/12393


#### Comments (3)

<details>
<summary><strong>yuandrew</strong> commented on 2025-06-30 19:36:30.000 UTC</summary>

Thanks for opening this issue! `workflowcheck` is a tool that's used to check for non-deterministic code, and we don't plan on expanding that scope today.

After discussing with the team, we decided it makes sense to add a warn log here, so at least at registration time users will receive a log about this issue. 

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-06-30 19:36:42.000 UTC</summary>

And thank you for using workflowcheck, not everyone does :) 

Reactions: ðŸŽ‰ 1

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-07-16 16:57:05.000 UTC</summary>

From the PR I linked and closed 

> Decided internally that since this spams our test logs (our test workflows are all methods under the same struct), for now we'll add something in the documentation warning against this.

> Our tests can be changed to not share the same struct, but that's a rather large refactor.

Reactions: ðŸ˜• 1

</details>


---

<a id="1961"></a>

### #1961: Getting a strange error when writing tests which does not occur in real temporal deployment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1961 |
| **State** | OPEN |
| **Author** | josvegit (Johan Svedlund NordstrÃ¶m) |
| **Created** | 2025-05-29 09:24:37.000 UTC (7 months ago) |
| **Updated** | 2025-10-09 16:02:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

should not get the illegalContext error


## Actual Behavior
```
Running tool: /opt/homebrew/bin/go test -timeout 30s -run ^Test_Subscription_Workflow_Tests$ -testify.m ^(Test_ExampleWorkflow)$ example.com -timeout=5m

2025/05/29 11:13:56 INFO  Received activation signal
2025/05/29 11:13:56 INFO  ExecuteChildWorkflow WorkflowType ActivationWorkflow
2025/05/29 11:13:56 INFO  Activation workflow started
2025/05/29 11:13:56 DEBUG Auto fire timer TimerID 0 TimerDuration 1s TimeSkipped 1s
2025/05/29 11:13:56 INFO  Received activation signal
2025/05/29 11:13:56 INFO  ExecuteChildWorkflow WorkflowType ActivationWorkflow
--- FAIL: Test_Subscription_Workflow_Tests (0.00s)
    --- FAIL: Test_Subscription_Workflow_Tests/Test_ExampleWorkflow (0.00s)
        /Users/johansvedlundnordstrom/dev/reproduce/workflow_testsuite.go:1236: FAIL:	DummyActivity(string,workflows.DummyActivityInput)
            		at: [/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/workflow_testsuite.go:414 /Users/johansvedlundnordstrom/dev/reproduce/some_test.go:110]
        /Users/johansvedlundnordstrom/dev/reproduce/workflow_testsuite.go:1236: FAIL: 0 out of 1 expectation(s) were met.
            	The code you are testing needs to make 1 more call(s).
            	at: [/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/workflow_testsuite.go:1236 /Users/johansvedlundnordstrom/dev/reproduce/some_test.go:27 /Users/johansvedlundnordstrom/go/pkg/mod/github.com/stretchr/testify@v1.10.0/suite/suite.go:180 /opt/homebrew/Cellar/go/1.24.1/libexec/src/runtime/panic.go:792 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow.go:782 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/workflow.go:1490 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow.go:1029 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/context.go:336 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/context.go:206 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow.go:593 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:2288 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:2921 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:896 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:836 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:626 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:570 /Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/workflow_testsuite.go:832 /Users/johansvedlundnordstrom/dev/reproduce/some_test.go:119]
        /Users/johansvedlundnordstrom/dev/reproduce/internal_workflow.go:782: test panicked: getState: illegal access from outside of workflow context
            goroutine 36 [running]:
            runtime/debug.Stack()
            	/opt/homebrew/Cellar/go/1.24.1/libexec/src/runtime/debug/stack.go:26 +0x64
            github.com/stretchr/testify/suite.failOnPanic(0x1400047c540, {0x104d33640, 0x104f15540})
            	/Users/johansvedlundnordstrom/go/pkg/mod/github.com/stretchr/testify@v1.10.0/suite/suite.go:89 +0x38
            github.com/stretchr/testify/suite.Run.func1.1()
            	/Users/johansvedlundnordstrom/go/pkg/mod/github.com/stretchr/testify@v1.10.0/suite/suite.go:188 +0x22c
            panic({0x104d33640?, 0x104f15540?})
            	/opt/homebrew/Cellar/go/1.24.1/libexec/src/runtime/panic.go:792 +0x124
            go.temporal.io/sdk/internal.assertNotInReadOnlyStateCancellation({0x104f23af0?, 0x140000a2060?})
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow.go:782 +0xa4
            go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).NewTimerWithOptions.func2({0x1400007c018?, 0x104a6fdd8?}, 0xb8?)
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/workflow.go:1490 +0x44
            go.temporal.io/sdk/internal.(*channelImpl).Close(0x140001141c0?)
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow.go:1029 +0xb4
            go.temporal.io/sdk/internal.(*cancelCtx).cancel(0x14000114180, 0x1, {0x104f18580, 0x1400035d470})
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/context.go:336 +0xb0
            go.temporal.io/sdk/internal.WithCancel.func1()
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/context.go:206 +0x34
            go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func2()
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow.go:593 +0x28
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).RequestCancelExternalWorkflow(0x14000146008, {0x104b6e6fd, 0x16}, {0x14000152000, 0x15}, {0x14000130060, 0x1b}, 0x1400000c180)
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:2288 +0x2c8
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).RequestCancelExternalWorkflow.(*testWorkflowEnvironmentImpl).cancelWorkflow.(*testWorkflowEnvironmentImpl).cancelWorkflowByID.func4()
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:2921 +0x40
            go.temporal.io/sdk/internal.(*testCallbackHandle).processCallback(0x140000e7448)
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:896 +0xc4
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).startMainLoop(0x14000291188)
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:836 +0x110
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal(0x14000291188, 0x0, {0x1050e298c, 0xe}, 0x0)
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:626 +0x3a8
            go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflow(0x14000291188, {0x104d4f880, 0x104f10748}, {0x0, 0x0, 0x0})
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/internal_workflow_testsuite.go:570 +0x118
            go.temporal.io/sdk/internal.(*TestWorkflowEnvironment).ExecuteWorkflow(0x14000409960?, {0x104d4f880?, 0x104f10748?}, {0x0?, 0x2?, 0x2?})
            	/Users/johansvedlundnordstrom/go/pkg/mod/go.temporal.io/sdk@v1.34.0/internal/workflow_testsuite.go:832 +0xb8
            example%2ecom.(*WorkflowTestSuite).Test_ExampleWorkflow(0x140002b05a0)
            	/Users/johansvedlundnordstrom/dev/reproduce/some_test.go:119 +0x194
            reflect.Value.call({0x14000444800?, 0x1400018f328?, 0x14000471001?}, {0x104b5e4cd, 0x4}, {0x1400018af20, 0x1, 0x104714b44?})
            	/opt/homebrew/Cellar/go/1.24.1/libexec/src/reflect/value.go:584 +0x978
            reflect.Value.Call({0x14000444800?, 0x1400018f328?, 0x66a?}, {0x1400018af20?, 0x105375c88?, 0x105578e40?})
            	/opt/homebrew/Cellar/go/1.24.1/libexec/src/reflect/value.go:368 +0x94
            github.com/stretchr/testify/suite.Run.func1(0x1400047c540)
            	/Users/johansvedlundnordstrom/go/pkg/mod/github.com/stretchr/testify@v1.10.0/suite/suite.go:202 +0x394
            testing.tRunner(0x1400047c540, 0x140002b06c0)
            	/opt/homebrew/Cellar/go/1.24.1/libexec/src/testing/testing.go:1792 +0xe4
            created by testing.(*T).Run in goroutine 35
            	/opt/homebrew/Cellar/go/1.24.1/libexec/src/testing/testing.go:1851 +0x374
FAIL
exit status 1
FAIL	example.com	0.208s
```


## Steps to Reproduce the Problem

run the following test

```
package workflows

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/workflow"
)

type WorkflowTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite

	testEnv *testsuite.TestWorkflowEnvironment
}

func (s *WorkflowTestSuite) SetupTest() {
	s.testEnv = s.NewTestWorkflowEnvironment()
}

func (s *WorkflowTestSuite) AfterTest(suiteName, testName string) {
	s.testEnv.AssertExpectations(s.T())
}

func Test_Subscription_Workflow_Tests(t *testing.T) {
	suite.Run(t, new(WorkflowTestSuite))
}

func MyCoolWorkflow(ctx workflow.Context) error {
	selector := workflow.NewSelector(ctx)
	var activationWorkflow *workflow.Execution
	selector.AddReceive(workflow.GetSignalChannel(ctx, "activate"), func(c workflow.ReceiveChannel, more bool) {
		c.Receive(ctx, nil)
		workflow.GetLogger(ctx).Info("Received activation signal")
		if activationWorkflow != nil {
			workflow.RequestCancelExternalWorkflow(ctx, activationWorkflow.ID, activationWorkflow.RunID)
		}

		cwf := workflow.ExecuteChildWorkflow(
			ctx,
			ActivationWorkflow,
		)

		var res workflow.Execution
		if err := cwf.GetChildWorkflowExecution().Get(ctx, &res); err != nil {
			workflow.GetLogger(ctx).Error("Failed to start child workflow", "error", err)
			return
		}
		activationWorkflow = &res

		selector.AddFuture(cwf, func(f workflow.Future) {
			if err := f.Get(ctx, nil); err != nil {
				workflow.GetLogger(ctx).Error("Child workflow failed", "error", err)
			} else {
				workflow.GetLogger(ctx).Info("Child workflow completed successfully")
			}
			activationWorkflow = nil
		})
	})

	for selector.HasPending() || activationWorkflow != nil {
		selector.Select(ctx)
	}
	return nil
}

type DummyActivityInput struct{}

func DummyActivity(ctx context.Context, d DummyActivityInput) error {
	return nil
}

func ActivationWorkflow(ctx workflow.Context) error {
	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		StartToCloseTimeout: time.Minute,
	})
	workflow.GetLogger(ctx).Info("Activation workflow started")
	if err := workflow.Sleep(ctx, time.Hour); err != nil {
		workflow.GetLogger(ctx).Error("Activation workflow failed", "error", err)
		return err
	}
	workflow.GetLogger(ctx).Info("Activation workflow completed")

	var err error
	if errors.Is(ctx.Err(), workflow.ErrCanceled) {
		newCtx, _ := workflow.NewDisconnectedContext(ctx)
		err = workflow.ExecuteActivity(newCtx, DummyActivity, DummyActivityInput{}).Get(newCtx, nil)
		workflow.GetLogger(ctx).Info("Activation workflow canceled, running dummy activity in disconnected context")
	} else {
		err = workflow.ExecuteActivity(ctx, DummyActivity, DummyActivityInput{}).Get(ctx, nil)
	}

	return err
}

func (s *WorkflowTestSuite) Test_ExampleWorkflow() {
	s.testEnv.OnActivity(DummyActivity, mock.Anything, DummyActivityInput{}).Return(nil).Once()
	s.testEnv.RegisterWorkflow(ActivationWorkflow)

	s.testEnv.RegisterDelayedCallback(func() {
		s.testEnv.SignalWorkflow("activate", nil)
	}, 0)
	s.testEnv.RegisterDelayedCallback(func() {
		s.testEnv.SignalWorkflow("activate", nil)
	}, time.Second)
	s.testEnv.ExecuteWorkflow(MyCoolWorkflow)
	s.NoError(s.testEnv.GetWorkflowError())
	s.testEnv.IsWorkflowCompleted()
}

```




## Specifications

running on Mac silicon but it does not really matter where you run it


#### Comments (3)

<details>
<summary><strong>yuandrew</strong> commented on 2025-05-30 21:09:59.000 UTC</summary>

Thanks for the bug report! Looks like there's an issue with the test environment propagating `ctx` from inside the `selector.AddReceive`

</details>

<details>
<summary><strong>josvegit</strong> commented on 2025-10-08 20:51:57.000 UTC</summary>

I think this is still an issue

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-10-09 16:02:34.000 UTC</summary>

Yes, I unfortunately haven't been able to prioritize this issue, hoping I can get to it soon

</details>


---

<a id="1942"></a>

### #1942: CLI supports redrive task queue and start workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1942 |
| **State** | CLOSED |
| **Author** | yinsidij (Yinsidi) |
| **Created** | 2025-04-30 04:29:16.000 UTC (8 months ago) |
| **Updated** | 2025-04-30 05:42:00.000 UTC |
| **Closed** | 2025-04-30 04:33:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

Reset button is gray out with message
"Cannot reset workflows without WorkflowTaskStarted, WorkflowTaskCompleted, or WorkflowTaskTimedOut events"

It's known that reset won't work if the workflow is not dispatched to worker.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

have a solution (like CLI) to redrive workflows in task queue and rerun them.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

![Image](https://github.com/user-attachments/assets/e4d9ff44-499b-4e47-ba04-4d21dabf5bd6)
![Image](https://github.com/user-attachments/assets/c6e43079-4247-4bd6-9cc9-cd37b63efae0)

Slack Channel:
https://temporalio.slack.com/archives/CTTJCPZQE/p1745895607250489

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-30 04:33:29.000 UTC</summary>

Temporal has a CLI that you can use to start workflows https://github.com/temporalio/cli, for install instructions and command reference see https://docs.temporal.io/cli

</details>

<details>
<summary><strong>yinsidij</strong> commented on 2025-04-30 05:18:49.000 UTC</summary>

> Temporal has a CLI that you can use to start workflows https://github.com/temporalio/cli, for install instructions and command reference see https://docs.temporal.io/cli

@Quinn-With-Two-Ns there is no good way that allows me do a batch start by reusing the input payload. (no query params)
I can get the list of workflow-ids by `--query`, but no good way for me to retrieve the payload.


`show` returns encoded payload.
```
bash-5.2$ temporal workflow show --address cc-temporal-frontend:7233 --namespace default --workflow-id "update-support|17c19b37-ca06-4d1f-b8b3-8b2f72652649"
Progress:
  ID           Time                     Type                   Details       
    1  2025-04-27T22:26:07Z  WorkflowExecutionStarted    {"workflowType":{"name":"update-support-workflow-v1"}, "taskQueue":{"name":"data-sync-general-worker", "kind":"TASK_QUEUE_KIND_NORMAL"}, "input":{"payloads":[{"metadata":{"encoding":"anNvbi9wbGFpbg=="}, "data":"eyJFdmVudFRpbWVOYW5vcyI6MTc0NTc5Mjc2NzU1OTc5MTc1NCwiU2NoZWR1bGVkVGltZU5hbm9zIjoxNzQ1NzkyNzY3NTU5NzkxODMxLCJvcmdfcmVzb3VyY2VfaWQiOiIxN2MxOWIzNy1jYTA2LTRkMWYtYjhiMy04YjJmNzI2NTI2NDkiLCJtZXRyb25vbWVfY3VzdG9tZXJfaWQiOiIiLCJzdXBwb3J0X3BsYW4iOiJmcmVlIiwic3RhcnRpbmdfYXQiOiIyMDI1LTA0LTI3VDIzOjAwOjAwWiJ9"}]}, "workflowExecutionTimeout":"86400s", "workflowRunTimeout":"86400s", "workflowTaskTimeout":"10s", "originalExecutionRunId":"769879bc-d613-41f3-883c-b0133b0283f2", "identity":"1@cc-support-service-7ffc6cb8b6-wkg2m@10.200.57.237", "firstExecutionRunId":"769879bc-d613-41f3-883c-b0133b0283f2", "attempt":1, "workflowExecutionExpirationTime":"2025-04-28T22:26:07.840Z", "firstWorkflowTaskBackoff":"0s", "searchAttributes":{"indexedFields":{"OrgResourceId":{"metadata":{"encoding":"anNvbi9wbGFpbg==", "type":"S2V5d29yZA=="}, "data":"IjE3YzE5YjM3LWNhMDYtNGQxZi1iOGIzLThiMmY3MjY1MjY0OSI="}}}, "header":{}, "workflowId":"update-support|17c19b37-ca06-4d1f-b8b3-8b2f72652649"}
    2  2025-04-27T22:26:07Z  WorkflowTaskScheduled       {"taskQueue":{"name":"data-sync-general-worker", "kind":"TASK_QUEUE_KIND_NORMAL"}, "startToCloseTimeout":"10s", "attempt":1}
    3  2025-04-28T22:26:07Z  WorkflowExecutionTimedOut   {"retryState":"RETRY_STATE_TIMEOUT"}
Results:
  Status  TIMEOUT
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-30 05:41:59.000 UTC</summary>

Unfortunately Temporal has no support to batch start workflows. You would need to list all workflows, describe each one and a start a new one. If you are using the UI you can also use "Start a workflow like this one" for an individual workflow

<img width="468" alt="Image" src="https://github.com/user-attachments/assets/a60e347a-e2a1-4233-a337-473ab12c0670" />

For user support please use our slack channel or forum. We use github for Go SDK issues. Thanks!

Reactions: ðŸ‘ 1

</details>


---

<a id="1936"></a>

### #1936: `workflowcheck` invalidly assumes `reflect.New` is non-deterministic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1936 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-28 14:01:00.000 UTC (8 months ago) |
| **Updated** | 2025-06-02 17:20:43.000 UTC |
| **Closed** | 2025-06-02 17:20:42.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

`reflect.New` should work in workflows with `workflowcheck`

## Actual Behavior

It seems there is a `sync.Map` operation in Go that is causing this to appear non-deterministic. We should exempt `reflect.New` the same way we do `reflect.Value.Interface` at https://github.com/temporalio/sdk-go/blob/ee78d25974654b5132b08cb466a8d776d99d64a9/contrib/tools/workflowcheck/determinism/ident_refs.go#L39

#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-06-02 17:20:42.000 UTC</summary>

not able to repro the issue, please re-open with a repro if anyone runs into this again

</details>


---

<a id="1912"></a>

### #1912: activity Schedule To Close timeoutï¼ˆActivity complete after timeoutï¼‰

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1912 |
| **State** | CLOSED |
| **Author** | Pharaohsk (Su) |
| **Created** | 2025-04-13 14:02:40.000 UTC (9 months ago) |
| **Updated** | 2025-04-23 13:12:42.000 UTC |
| **Closed** | 2025-04-23 13:12:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
In a three-node cluster using Temporal, the time on each node is not synchronized. The Temporal server is deployed on the main control node, where Service A starts a workflow and sets configurations such as ScheduleToCloseTimeout and other timeout settings. When the task is scheduled to execute on Service B on node B, the local time on node B is later than that on node A. As a result, when Service B executes the task, its local time has already exceeded the timeout. It is expected that no error will be reported.

## Actual Behavior
return err : Activity complete after timeout..
File : internal/internal_task_handlers.go
```go
	info := getActivityEnv(ctx)
	ctx, dlCancelFunc := context.WithDeadline(ctx, info.deadline)
	defer dlCancelFunc()

	output, err := activityImplementation.Execute(ctx, t.Input)
	// Check if context canceled at a higher level before we cancel it ourselves
	isActivityCancel := ctx.Err() == context.Canceled

	dlCancelFunc()
	if <-ctx.Done(); ctx.Err() == context.DeadlineExceeded {
		ath.logger.Info("Activity complete after timeout.",
			tagWorkflowID, t.WorkflowExecution.GetWorkflowId(),
			tagRunID, t.WorkflowExecution.GetRunId(),
			tagActivityType, activityType,
			tagAttempt, t.Attempt,
			tagResult, output,
			tagError, err,
		)
		return nil, ctx.Err()
	}
```
I think the code should use context.WithTimeout instead of context.WithDeadline(ctx, info.deadline).

## Steps to Reproduce the Problem

  1.Use Temporal in a cluster with two or more nodes, with the Temporal server running on the main control node.
  2.Configure the task timeout and allow the task to be scheduled for execution on another node.
  3.Modify the time on all hosts in the cluster to be unsynchronized, with the time difference exceeding the configured task timeout.

## Specifications

  - Version: v1.22.0
  - Platform: go version go1.18 linux


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2025-04-14 14:24:41.000 UTC</summary>

Interesting. The deadline calculated on the worker is based on the server start-time of the task because that's how server uses it. The server will timeout the activity for the same period of time, this is just a worker-side to keep activities from running forever. The time is started when the server starts the task, not when the worker starts the task. I am not sure we support situations of significant clock skew. I think there is an expectation that server and worker clocks must be reasonably accurate and that timeouts should be set high enough to not be hit except in rare/failure scenarios.

I will confer with the team, but we'd strongly recommend clock accuracy and timeouts high enough to overcome and skew difference.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-04-18 21:38:38.000 UTC</summary>

After conferring with team, we may be able to make deadline relative for start to close timeout, but we cannot for schedule to close.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-04-23 13:12:41.000 UTC</summary>

We have opened #1926 to warn when SDK and server clocks vary significantly, and we have opened #1930 to have start-to-close timeout be relative to local time instead of server time. We cannot do this with schedule to close, because there is no local-time equivalent of when first scheduled to base the timeout off of so we have to use the server time.

(closing issue in favor of those two issues, but feel free to keep commenting)

</details>


---

<a id="1906"></a>

### #1906: workflowcheck crash (index out of range)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1906 |
| **State** | OPEN |
| **Author** | Bysmyyr (Olli Raula) |
| **Created** | 2025-04-07 06:57:09.000 UTC (9 months ago) |
| **Updated** | 2025-04-07 13:00:38.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
No crash when running with `-debug=f` or through golangci-lint

## Actual Behavior
It crashes: (happens with other codebases too but for the simplicity, running it with this codebase)

```
contrib/tools/workflowcheck on î‚  master
â¯ go run main.go -debug=f ./...
panic: runtime error: index out of range [0] with length 0

goroutine 2756 [running]:
golang.org/x/tools/go/analysis/internal/checker.(*action).exportPackageFact(0xc01346ed20, {0x849a88, 0xc010375d40})
	/home/olli/go/pkg/mod/golang.org/x/tools@v0.25.0/go/analysis/internal/checker/checker.go:963 +0x309
go.temporal.io/sdk/contrib/tools/workflowcheck/determinism.(*collector).applyFacts(0xc00ca16e40)
	/home/olli/Downloads/sdk-go/contrib/tools/workflowcheck/determinism/checker.go:427 +0x3ec
go.temporal.io/sdk/contrib/tools/workflowcheck/determinism.(*Checker).Run(0xc0000b51c0, 0xc0057ea460)
	/home/olli/Downloads/sdk-go/contrib/tools/workflowcheck/determinism/checker.go:202 +0x646
go.temporal.io/sdk/contrib/tools/workflowcheck/workflow.(*Checker).Run(0xc0000906c0, 0xc0057ea460)
	/home/olli/Downloads/sdk-go/contrib/tools/workflowcheck/workflow/checker.go:157 +0x117
go.temporal.io/sdk/contrib/tools/workflowcheck/workflow.(*Checker).NewAnalyzer.func1(0x7fffc5da3579?)
	/home/olli/Downloads/sdk-go/contrib/tools/workflowcheck/workflow/checker.go:129 +0x1d
golang.org/x/tools/go/analysis/internal/checker.(*action).execOnce(0xc01346ed20)
	/home/olli/go/pkg/mod/golang.org/x/tools@v0.25.0/go/analysis/internal/checker/checker.go:759 +0xad0
sync.(*Once).doSlow(0xc006b70030?, 0xc007fb04b0?)
	/home/olli/go/go1.24.1/src/sync/once.go:78 +0xab
sync.(*Once).Do(...)
	/home/olli/go/go1.24.1/src/sync/once.go:69
golang.org/x/tools/go/analysis/internal/checker.(*action).exec(...)
	/home/olli/go/pkg/mod/golang.org/x/tools@v0.25.0/go/analysis/internal/checker/checker.go:666
golang.org/x/tools/go/analysis/internal/checker.execAll.func1(0x0?)
	/home/olli/go/pkg/mod/golang.org/x/tools@v0.25.0/go/analysis/internal/checker/checker.go:654 +0x3b
created by golang.org/x/tools/go/analysis/internal/checker.execAll in goroutine 2747
	/home/olli/go/pkg/mod/golang.org/x/tools@v0.25.0/go/analysis/internal/checker/checker.go:660 +0x191
exit status 2

```

We found the issue when integrating the check for golangci-lint.  With golangci-lint it crash always.

golangCI-lint has its own pass which does this always:
```
    act.Err = errorutil.NewPanicError(fmt.Sprintf("%s: package %q (isInitialPkg: %t, needAnalyzeSource: %t): %s",
       act.Analyzer.Name, act.Package.Name, act.isInitialPkg, act.needAnalyzeSource, p), debug.Stack())
}
```
when run on its own, it uses go standard reporter which does that only when debug flag is on, with it it fails:
```
if dbg('f') {
    fmt.Fprintf(os.Stderr, "%s: package %s has fact %s\n",
       act.pkg.Fset.Position(act.pass.Files[0].Pos()), act.pass.Pkg.Path(), fact)
}
```
Somehow the `act.pass.Files` is empty slice. In this case the key is `package unsafe ("unsafe")`.


## Steps to Reproduce the Problem

  1. cd contrib/tools/workflowcheck
  1. go run main.go -debug=f ./...
  1.

## Specifications

  - Version: master (b9afba98719cdf39b158dd0cfb05c9d422f477f4)
  - Platform: go version go1.24.1 linux/amd64



#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-04-07 13:00:23.000 UTC</summary>

Looks like this may be a bug in the Golang repo on code that assumes a file is present in that slice (and still exists despite being moved to https://github.com/golang/tools/blob/3e7f74d009150bf5e66483f3759d8c59f50e873d/go/analysis/checker/checker.go#L591).

</details>


---

<a id="1890"></a>

### #1890: Context is mutated between interceptors and activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1890 |
| **State** | CLOSED |
| **Author** | stan-stately |
| **Created** | 2025-03-26 22:52:49.000 UTC (9 months ago) |
| **Updated** | 2025-03-26 23:03:37.000 UTC |
| **Closed** | 2025-03-26 22:59:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
- Ideally the context would not be mutated between the interceptor and the activity. If you need to strip headers you should probably do that before the interceptor


## Actual Behavior
- A header is removed using `context.WithValue()` [here](https://github.com/temporalio/sdk-go/blob/master/internal/workflow.go#L793)
- This is a problem for my usecase because I want to create a custom context and pass it in to my activity:
```go
func (a *activityInboundInterceptor) ExecuteActivity(
	ctx context.Context,
	in *interceptor.ExecuteActivityInput,
) (any, error) {
	mCtx := NewCustomContext(ctx)
    return a.Next.ExecuteActivity(mCtx, in)
}

...

func MyActivity(ctx contet.Context) (any, error) {
    mCtx := ctx.(CustomContext)
    mCtx.Log(...) // or whatever else mCtx can do
}
```
- Because you're doing a `context.WithValue()` i still end up with a `context.Context` in the activity and I cannot retrieve the parent context. Right now I am working around by "smuggling" in my context using `a.Next.ExecuteActivity(context.WithValue(ctx, CustomContextKey{}, mCtx), in)` but this is bad too because I have access to the headers that you stripped out lol. I assume you don't want this
## Steps to Reproduce the Problem
- Create inbound activity interceptor
- Mutate context in the interceptor before `ExecuteActivity`
- Try and read the mutated context inside the activity

## Specifications

  - Version: v1.33.0
  - Platform: go


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-26 22:56:18.000 UTC</summary>

The SDK does not make any guarantee that the context is not mutated between interceptors and activity. If you want to pass a custom value into the context with a `https://pkg.go.dev/context#WithValue`

</details>

<details>
<summary><strong>stan-stately</strong> commented on 2025-03-26 22:59:19.000 UTC</summary>

ok i will close

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-26 23:03:36.000 UTC</summary>

If you do want to implement a custom context, I would encourage you to look at the Go source code for how their contexts are implemented https://cs.opensource.google/go/go/+/refs/tags/go1.24.1:src/context/context.go 

</details>


---

<a id="1759"></a>

### #1759: Change activity error to warn, or allow it to be configurable 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1759 |
| **State** | OPEN |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2024-12-19 19:54:37.000 UTC (1 years ago) |
| **Updated** | 2025-10-15 13:43:29.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

https://github.com/temporalio/sdk-go/blob/ccb28ef56de83e34c5b8482ebcd4c41fd26b8fcd/internal/internal_task_handlers.go#L2246


In my company, we are default monitors on errors that are expected to be more critical cases. But many errors in activity are retryable that are not too critical for us. 

If you want to keep it error, can we make it configuable on SDK that we can change to other level like "Warn"?

Thanks

#### Comments (1)

<details>
<summary><strong>LarsAlmgren</strong> commented on 2025-10-15 13:42:25.000 UTC</summary>

We have the same issue. I saw that since `v1.35` it's possible to mark the `ApplicationError` with Category `ApplicationErrorCategoryBenign` to downgrade the log severity to `DEBUG`.

https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L2326-L2338

</details>


---

<a id="1703"></a>

### #1703: fatal error: concurrent map writes when u

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1703 |
| **State** | CLOSED |
| **Author** | delanne (Xavier Delannoy) |
| **Created** | 2024-11-05 00:49:24.000 UTC (1y 2m ago) |
| **Updated** | 2025-01-28 15:35:41.000 UTC |
| **Closed** | 2025-01-28 15:35:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

 - no crash

## Actual Behavior

when testing several Activities with t.Parallel, the test framework crash with "fatal error: concurrent map writes"

```
fatal error: concurrent map writes
...
goroutine 129 [running]:
go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).setActivityHandle(...)
	/Users/xavier.delannoy/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/internal_workflow_testsuite.go:1415
go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeActivity(0x140000e4488, {0x10304e900?, 0x1031d92a8?}, {0x14000513020, 0x1, 0x1})
	/Users/xavier.delannoy/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/internal_workflow_testsuite.go:703 +0x524
go.temporal.io/sdk/internal.(*TestActivityEnvironment).ExecuteActivity(0x1030c99a0?, {0x10304e900?, 0x1031d92a8?}, {0x14000513020?, 0x140004d1f38?, 0x1028bb6a0?})
	/Users/xavier.delannoy/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/workflow_testsuite.go:195 +0x2c
github.com/strangebee/godsl/flow/activities/strings.Test_Activity_TrimRight.func1(0x140004c36c0)
	/Users/xavier.delannoy/go/src/github.com/strangebee/Delannoy/godsl/flow/activities/strings/trimright_test.go:150 +0xac
testing.tRunner(0x140004c36c0, 0x14000494390)
	/usr/local/go/src/testing/testing.go:1690 +0xe4
created by testing.(*T).Run in goroutine 24
	/usr/local/go/src/testing/testing.go:1743 +0x314
```

## Steps to Reproduce the Problem

  1. write some activities
  2. write tests for these activities with t.Parallel
  3. run tests in a loop in order to reproduce the race conditions

## Specifications

  - Version: SDK 1.30
  - Platform: Darwin 

## Investigation

code: 
```
func (env *testWorkflowEnvironmentImpl) setActivityHandle(activityID, runID string, handle *testActivityHandle) {
	env.activities[env.makeUniqueActivityID(activityID, runID)] = handle
}
```

```
		activities             map[string]*testActivityHandle
```

as several go routines can write in the map 'activities', the type of activities should be a [sync.Map](https://pkg.go.dev/sync#Map) or use a mutex to protect the write 

## Potential fix

internal/internal_workflow_testsuite.go:1415
```
func (env *testWorkflowEnvironmentImpl) setActivityHandle(activityID, runID string, handle *testActivityHandle) {
	env.locker.Lock()
	defer env.locker.Unlock()
	env.activities[env.makeUniqueActivityID(activityID, runID)] = handle
}
```

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-05 16:09:26.000 UTC</summary>

To clarify, are you seeing this data race when the same test environment being shared by multiple tests?

</details>

<details>
<summary><strong>delanne</strong> commented on 2024-11-07 20:14:59.000 UTC</summary>

> To clarify, are you seeing this data race when the same test environment being shared by multiple tests?

all tests are run in parallel. Here is an example of how I write a test

```
func Test_Activity_FooBar(t *testing.T) {
	testSuite := &testsuite.WorkflowTestSuite{}
	env := testSuite.NewTestActivityEnvironment()

	env.RegisterActivity(FooBar)

	t.Parallel()
	tests := []struct {
		name     string
		p        *FooBarParams
		expected internal.Return
	}{
		{
			name: "foobar test1",
			p: &FooBarParams{
				String1: "foobar",
				String2: "foobar",
			},
			expected: internal.Return{Value: float64(0)},
		},
     .....
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			val, err := env.ExecuteActivity(FooBar,
				tt.p,
			)
			require.NoError(t, err)
			res := &internal.Return{}
			err = val.Get(res)
			require.NoError(t, err)
			require.Equal(t, &tt.expected, res)
		})
	}
}
```

Do you mean that the line `env := testSuite.NewTestActivityEnvironment()` should be after the line `t.Parallel()` ?  (make sense to me) 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-01-28 15:35:39.000 UTC</summary>

Sorry for the late reply this slipped through the cracks , 

> Do you mean that the line env := testSuite.NewTestActivityEnvironment() should be after the line t.Parallel() ? (make sense to me)


Yes, The test environment should not be shared for multiple tests. Each test should have its own environment 

</details>


---

<a id="1681"></a>

### #1681: Update Godoc for `internal` structs/funcs to clarify the package they are exposed under

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1681 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-10-21 15:51:15.000 UTC (1y 2m ago) |
| **Updated** | 2024-12-06 19:30:39.000 UTC |
| **Closed** | 2024-12-06 19:30:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

At least for all non-obvious `internal` structs/funcs, mention in their Godoc the package they are exposed/aliased at.

#### Comments (3)

<details>
<summary><strong>yuandrew</strong> commented on 2024-11-25 21:45:14.000 UTC</summary>

@cretz what's considered "non-obvious"? i.e. GetActivityInfo -> GetInfo obvious enough?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-25 21:50:41.000 UTC</summary>

We should probably just document where every exported `internal` structs/funcs is exposed.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-11-25 22:01:26.000 UTC</summary>

Yeah, if that's not too much work, that would be ideal. This can probably be done in an automated way via a cmd to the build tooling (e.g. parsing the whole project for aliases that point to internal and confirming the Godoc of internal), but if it is automated, need a check in CI to confirm it was since rerun if something is added.

</details>


---

<a id="1670"></a>

### #1670: Erroneous extra replay command when replaying mid-workflow tasks

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1670 |
| **State** | CLOSED |
| **Author** | RamyElkest (Ramy Elkest) |
| **Created** | 2024-10-14 10:44:33.000 UTC (1y 2m ago) |
| **Updated** | 2025-02-03 21:32:24.000 UTC |
| **Closed** | 2025-02-03 21:32:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This is more of a request for information than a bug.

## Expected Behavior
Replaying a downloaded workflow history ending with workflow task (started) should not fail with a [[TMPRL1100] nondeterministic workflow: extra replay command](https://github.com/DataDog/sdk-go/blob/6580cbe0aa41a8b515791f95c2c15bb37db1dab1/internal/internal_task_handlers.go#L1200)

## Actual Behavior
Replaying a downloaded workflow history ending with workflow task (started) fails with an [[TMPRL1100] nondeterministic workflow: extra replay command](https://github.com/DataDog/sdk-go/blob/6580cbe0aa41a8b515791f95c2c15bb37db1dab1/internal/internal_task_handlers.go#L1200)

## Steps to Reproduce the Problem
Reproducing test and detailed explanation: https://github.com/RamyElkest/sdk-go/pull/1

## Specifications
  - Version: `v1.26.0`
  - Platform: `v1.23.1`


#### Comments (3)

<details>
<summary><strong>RamyElkest</strong> commented on 2024-10-14 10:48:18.000 UTC</summary>

> Solution
The proposed solution here is to trim scheduled/started/completed workflow tasks with no follow-up events, this guarantees the workflow history is in a safely replayable state. For this there are three approaches:
> 1. Trim the history in GetWorkflowHistory (to be discussed with upstream)
> 2. Trim the history in our code before passing it to the Replayer
> 3. Trim the history in the Replayer (to be discussed with upstream)

Curious if you have any thoughts / preferences here.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-15 13:56:32.000 UTC</summary>

Thanks for the report! Will confer with the team on replaying of mid-task history captures. While it makes sense to only replay up to the last completed or failed task, we may need to double check that people aren't running replays on the active task without the task failure to replicate failures (e.g. to replicate deadlock detection).

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-16 20:32:04.000 UTC</summary>

Conferred with team, we consider this a bug. If we are in fact failing a replay with history that should succeed, we need to fix. It is likely we should not be performing history matching for non-determinism checks after the last task start (that doesn't have an end). This issue will be updated when we have a solution.

Reactions: ðŸ‘ 1

</details>


---

<a id="1609"></a>

### #1609: Support ContextAware for failure converters

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1609 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-08-27 14:42:09.000 UTC (1y 4m ago) |
| **Updated** | 2025-09-09 14:21:36.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Support the https://pkg.go.dev/go.temporal.io/sdk@v1.28.1/internal#ContextAware interface for failure converters so failure converters can access information like headers from the workflow/activity context



#### Comments (1)

<details>
<summary><strong>doreshnikov</strong> commented on 2025-09-09 14:21:35.000 UTC</summary>

Hi! Are there any plans on implementing this (and if there are, is there an approximate ETA for it) or is this issue left for outside developers to contribute?

In our project we use custom errors and error marshalling from https://github.com/cockroachdb/errors. Right now we are managing with a custom FailureConverter but lacking context stands in a way of, for example, logging the problems with marshalling/unmarshalling using the right logger.

Thank you!

</details>


---

<a id="1576"></a>

### #1576: Workflow-init support docs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1576 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-08-02 04:06:17.000 UTC (1y 5m ago) |
| **Updated** | 2024-11-19 17:21:43.000 UTC |
| **Closed** | 2024-11-19 17:21:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We should have a method that's guaranteed to initialize before signals and updates come in so handlers can use initialized values.

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-06 23:19:24.000 UTC</summary>

@cretz Can we close this issue? I don't think Go SDK needs any changes here if we want to support struct based workflows or improve docs I think those should be tracked separately 

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-08-07 14:09:19.000 UTC</summary>

I do think we can, let's confirm with team first though (same for TypeScript). Starting internal discussion...

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>drewhoskins-temporal</strong> commented on 2024-10-22 17:07:38.000 UTC</summary>

Just docs, we decided.

Reactions: ðŸ‘ 1

</details>


---

<a id="1458"></a>

### #1458: Set Temporal-Namespace header on every namespace-specific gRPC request

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1458 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-09 13:06:57.000 UTC (1y 8m ago) |
| **Updated** | 2025-06-13 20:11:39.000 UTC |
| **Closed** | 2025-02-04 17:11:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/475. This can be done with an interceptor that type asserts to `interface { GetNamespace() string }` (we've confirmed this works and will continue to work because that field will be present).

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2025-02-03 15:32:03.000 UTC</summary>

Note, once this is released, any samples/docs that reference explicit namespace setting we can probably alter

</details>

<details>
<summary><strong>GSmithApps</strong> commented on 2025-06-13 20:09:08.000 UTC</summary>

Hey @cretz and @Quinn-With-Two-Ns ðŸ‘‹  This change removes the need to have the `DialOptions` shown on line 407 of [this commit](https://github.com/temporalio/documentation/commit/b87eab2c9914e62ed8868fb3e111e4e223c904aa#diff-a5e4c731af1568fb94988abc664627a9d778fe28bcfab17c0e6b482705234102L411), correct? Meaning in the interval [1.26.0, 1.33.0), it needed to be there, and in [1.33.0,  TBD), it doesnâ€™t need to be there, correct?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-13 20:11:39.000 UTC</summary>

Yep 

Reactions: â¤ï¸ 1

</details>


---

<a id="1406"></a>

### #1406: Calls to worfklowService.GetSystemInfo are not included in the distrubuted trace.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1406 |
| **State** | CLOSED |
| **Author** | burnaevk |
| **Created** | 2024-02-29 23:49:32.000 UTC (1y 10m ago) |
| **Updated** | 2024-06-27 17:45:11.000 UTC |
| **Closed** | 2024-06-27 17:44:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

We run distributed tracing with OTel and `go.temporal.io/sdk/contrib/opentelemetry` trace / span propagator. We expect to see calls to `worfklowService.GetSystemInfo` made by `loadCapabilities` (https://github.com/temporalio/sdk-go/blob/d9a574d4ffa4f43e4a9ea4e133feeb5fedb0392c/internal/internal_workflow_client.go#L1151) in our distributed trace, as sometimes intermittent network failures may result in this call failing. If this call is not included in the trace, the reason of the failure is not obvious. 

## Actual Behavior

`worfklowService.GetSystemInfo` call is not visible in the parent trace; instead, a new trace is created for this individual call. 

## Cause

https://github.com/temporalio/sdk-go/blob/d9a574d4ffa4f43e4a9ea4e133feeb5fedb0392c/internal/internal_workflow_client.go#L1165 creates a new background context; parent context is not passed to `loadCapabilities` or `ensureInitialized. 

All callers of ensureInitialized have parent context available, except worker (which might've used context.Background() explicitly) 

## Steps to Reproduce the Problem

  1. Set up Temporal SDK client with tracing interceptor

```
	opts := opentelemetry.TracerOptions{}
	tracingInterceptor, err := opentelemetry.NewTracingInterceptor(opts)
	if err != nil {
		return nil, ErrTracing
	}
	c, err := client.NewLazyClient(client.Options{
...
		Interceptors:       []interceptor.ClientInterceptor{tracingInterceptor}
,...
	})
```

  1. Start a new trace in your business logic code and execute an arbitrary SDK call
  1. Check logs / traces for presence of the `worfklowService.GetSystemInfo` call

## Specifications

  - Version: v1.25.1
  - Platform: go sdk


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2024-03-01 15:01:10.000 UTC</summary>

:+1: Yes, we should plumb the context through the capabilities loader (it also will allow it to be subject to proper cancellation and such). It probably wasn't originally set because it is a lazy/memoized call so only the first context matters, but we still should I believe.

Note, you may consider using `ConnectionOptions.DialOptions` with a gRPC stats handler (or gRPC interceptor) from https://pkg.go.dev/go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc if you really want to trace all gRPC calls. The Temporal interceptor is only for a select few high-level operations. But that doesn't change the fact that we should use the outer context when calling get-system-info.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-27 16:54:16.000 UTC</summary>

@cretz I believe this is resolved now since [loadCapabilities](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_client.go#L1216) now takes the context and it is wired up in all possible locations we could.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-06-27 17:44:56.000 UTC</summary>

Concur. Closing. @burnaevk - let us know if you still get issues (of course `go.temporal.io/sdk/contrib/opentelemetry` does not instrument the client, but `go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc` can as mentioned above).

</details>


---

<a id="1405"></a>

### #1405: PR 1404 breaks workflowcheck

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1405 |
| **State** | CLOSED |
| **Author** | aaomidi (Amir Omidi) |
| **Created** | 2024-02-29 20:44:24.000 UTC (1y 10m ago) |
| **Updated** | 2024-02-29 22:02:47.000 UTC |
| **Closed** | 2024-02-29 21:58:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

              This PR breaks workflow check.

```
workflowcheck ./...
panic: runtime error: invalid memory address or nil pointer dereference [recovered]
        panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x2 addr=0x0 pc=0x104880200]

goroutine 1015 [running]:
go/types.(*Checker).handleBailout(0x140022fa200, 0x14002407b98)
        /nix/store/2022s0jnrn2iyxjaikfy51w5fvifp38b-go-1.22.0/share/go/src/go/types/check.go:367 +0x9c
panic({0x104a82be0?, 0x104c9fde0?})
        /nix/store/2022s0jnrn2iyxjaikfy51w5fvifp38b-go-1.22.0/share/go/src/runtime/panic.go:770 +0x124
 ```

_Originally posted by @aaomidi in https://github.com/temporalio/sdk-go/issues/1403#issuecomment-1971924339_
            
            
 Made a new issue for visibility since I know closed PRs sometimes don't send notifications

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2024-02-29 21:05:27.000 UTC</summary>

This looks like #1382, can you confirm it is because of #1403? Can you try `workflowcheck` from `master` and see if it still occurs?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-29 21:22:34.000 UTC</summary>

Pulling the latest workflow check
```
samples-go git:(async-update-sample) âœ— go install go.temporal.io/sdk/contrib/tools/workflowcheck@master           
go: downloading go.temporal.io/sdk/contrib/tools/workflowcheck v0.1.1-0.20240229191239-d9a574d4ffa4
go: downloading go.temporal.io/sdk v1.26.0-rc.3.0.20240229191239-d9a574d4ffa4
```

and running in samples gave no error so I suspect it is https://github.com/temporalio/sdk-go/issues/1382

</details>

<details>
<summary><strong>aaomidi</strong> commented on 2024-02-29 21:58:05.000 UTC</summary>

Ooops, looks like initially go pulled the wrong versions for me. Sorry `master` works fine!

</details>


---

<a id="1316"></a>

### #1316: Add support for GetUnhandledUpdateNames

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1316 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2023-12-07 02:01:23.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-07 14:04:58.000 UTC |
| **Closed** | 2023-12-07 14:04:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

With signals we can define a catch-all handler by using `GetUnhandledSignalNames`, which will be called if there are no specific handlers registered for a signal name. 

There is no equivalent for updates at this point, so the proposal is to create a `GetUnhandledUpdateNames` that mimics the signals implementation.


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-07 02:32:11.000 UTC</summary>

I agree we should have a way to add a catch all,  I don't think we should mimic the signal approach since updates and signal have 
 very different APIs and behavior in the Go SDK.  One example is we say we want update handlers to run before the main workflow function, with `GetUnhandledUpdateNames` that is not possible
 
 I think we should allow registering a catch all handler. In other SDKs we call these dynamic handlers.

</details>

<details>
<summary><strong>antlai-temporal</strong> commented on 2023-12-07 03:11:47.000 UTC</summary>

Makes sense, shall we close this one and open a more generic catch all for update?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-12-07 14:04:58.000 UTC</summary>

Per https://github.com/temporalio/features/issues/201, I made this part of https://github.com/temporalio/sdk-go/issues/997.

</details>


---

<a id="1287"></a>

### #1287: Error "getState: illegal access from outside of workflow context" after sdk update  1.22.1 -> 1.25.1

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1287 |
| **State** | CLOSED |
| **Author** | vmalyavin (Vasiliy Malyavin) |
| **Created** | 2023-11-03 22:38:37.000 UTC (2y 2m ago) |
| **Updated** | 2023-12-01 16:15:10.000 UTC |
| **Closed** | 2023-12-01 16:15:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

[You can view full workflow code of reproduction in repo](https://github.com/vmalyavin/temporalissue)

We have a simple workflow cycle with select
- pereodic polling(payment status from activity every 2-3min)
- workflow-cancel signal receive
- timeout
```go
package testflow

import (
	"time"

	"go.temporal.io/sdk/workflow"

	"temporalissue/models"
	"temporalissue/workflows/testflow/signals"
)

func PollPaymentStatus20MinOrReceiveCancel(
	ctx workflow.Context, order *models.Order,
) models.PaymentStatus {
	var status models.PaymentStatus

	// cycle over timer - 20min
	itsOver := false
	overTimer := workflow.NewTimer(ctx, 20*time.Minute)
	overCallback := func(_ workflow.Future) { itsOver = true }

	for !itsOver {
		pollTimer, pollCallback := pollPaymentStatus(
			ctx, 3*time.Minute, &status, order,
		)
		selector := workflow.NewSelector(ctx).
			AddFuture(pollTimer, pollCallback).
			AddFuture(overTimer, overCallback).
			AddReceive(signals.CancellationReceive(ctx, order))
		selector.Select(ctx)

		// end cycle if paymentstatus is changed from new; or order is cancelled
		if status == models.PaymentStatusNew || order.Status == models.OrderStatusCancel {
			break
		}
	}

	return status
}
```

then after end of the cycle we 
- complete workflow

or  
- cancel it(by signal) and poll payment status for 10min after cancel:
```go
func PollPaymentStatus10Min(
	ctx workflow.Context, order *models.Order,
) models.PaymentStatus {
	var status models.PaymentStatus

	// cycle over timer - 10min
	itsOver := false
	overTimer := workflow.NewTimer(ctx, 10*time.Minute)
	overCallback := func(_ workflow.Future) { itsOver = true }

	for !itsOver {
		pollTimer, pollCallback := pollPaymentStatus(
			ctx, 2*time.Minute, &status, order,
		)
		selector := workflow.NewSelector(ctx).
			AddFuture(pollTimer, pollCallback).
			AddFuture(overTimer, overCallback)
		// no cancel receive
		selector.Select(ctx)

		// end cycle if paymentstatus is changed from new
		if status != models.PaymentStatusNew {
			break
		}
	}

	return status
}
```
## Expected Behavior
Workflow is gracefully cancelled and all timers is cancelled by workflow context

## Actual Behavior
panic with events outside workflow context:
_"test panicked: getState: illegal access from outside of workflow context"_

## Steps to Reproduce the Problem
Example of workflow with error reproduction available
[in repo](https://github.com/vmalyavin/temporalissue)
you can pull it and try

## Specifications
  - Version: 1.25.1


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-04 17:12:34.000 UTC</summary>

The issue appears to be that return a cancelled error from a workflow in the test suite causes the test suite to call the [cancel callback ](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_testsuite.go#L876). This is not allowed as at this point the workflow execution is finished.

</details>

<details>
<summary><strong>vmalyavin</strong> commented on 2023-11-06 12:41:20.000 UTC</summary>

It means - this is testsuite-only problem?


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-06 16:05:19.000 UTC</summary>

Yes this would only effect the testsuite, not the devserver or a normal temporal cluster

</details>


---

<a id="1280"></a>

### #1280: Requesting a way to expose workflow IDs from relevant worker request response protos

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1280 |
| **State** | CLOSED |
| **Author** | emmaCullen (Emma Cullen) |
| **Created** | 2023-10-26 04:37:53.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-01 12:39:30.000 UTC |
| **Closed** | 2023-11-01 12:39:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We would like a way to add the workflow ID as an attribute to spans generated by our GRPC client interceptor. The ID is present in the proto, but we do not always know where it will be and what all of the types are.

At the moment we are doing this using a switch as follows. This is brittle as we dont have internal knowledge and if the API changes.

```
	switch v := req.(type) {
	case *proto.GetSystemInfoRequest:
	case *proto.RegisterNamespaceRequest:
	case *proto.ListNamespacesRequest:
	case *proto.UpdateNamespaceRequest:
	case *proto.DeprecateNamespaceRequest:
	case *proto.PollWorkflowTaskQueueRequest:
	case *proto.RespondWorkflowTaskCompletedRequest:
	case *proto.RespondWorkflowTaskFailedRequest:
	case *proto.PollActivityTaskQueueRequest:
	case *proto.DescribeNamespaceRequest:
	case *proto.RespondActivityTaskCompletedRequest:
	case *proto.RequestCancelWorkflowExecutionRequest:
		if v.GetWorkflowExecution() != nil {
			id = v.GetWorkflowExecution().WorkflowId
		}
	case *proto.SignalWorkflowExecutionRequest:
		if v.GetWorkflowExecution() != nil {
			id = v.GetWorkflowExecution().WorkflowId
		}
	case *proto.ResetWorkflowExecutionRequest:
		if v.GetWorkflowExecution() != nil {
			id = v.GetWorkflowExecution().WorkflowId
		}
	case *proto.UpdateWorkflowExecutionRequest:
		if v.GetWorkflowExecution() != nil {
			id = v.GetWorkflowExecution().WorkflowId
		}
	case *proto.TerminateWorkflowExecutionRequest:
		if v.GetWorkflowExecution() != nil {
			id = v.GetWorkflowExecution().WorkflowId
		}
	case *proto.DeleteWorkflowExecutionRequest:
		if v.GetWorkflowExecution() != nil {
			id = v.GetWorkflowExecution().WorkflowId
		}
	case *proto.QueryWorkflowRequest:
		if v.GetExecution() != nil {
			id = v.GetExecution().WorkflowId
		}
	case *proto.ResetStickyTaskQueueRequest:
		if v.GetExecution() != nil {
			id = v.GetExecution().WorkflowId
		}
	case *proto.DescribeWorkflowExecutionRequest:
		if v.GetExecution() != nil {
			id = v.GetExecution().WorkflowId
		}
	case *proto.GetWorkflowExecutionHistoryReverseRequest:
		if v.GetExecution() != nil {
			id = v.GetExecution().WorkflowId
		}
	case *proto.GetWorkflowExecutionHistoryRequest:
		if v.GetExecution() != nil {
			id = v.GetExecution().WorkflowId
		}
	case *proto.StartBatchOperationRequest:
		if v.GetExecutions() != nil {
			execution := v.GetExecutions()
			id = execution[0].WorkflowId
		}
	case *proto.StartWorkflowExecutionRequest:
		id = v.GetWorkflowId()
	case *proto.RecordActivityTaskHeartbeatByIdRequest:
		id = v.GetWorkflowId()
	case *proto.RespondActivityTaskCanceledByIdRequest:
		id = v.GetWorkflowId()
	case *proto.RespondActivityTaskFailedByIdRequest:
		id = v.GetWorkflowId()
	case *proto.RespondActivityTaskCompletedByIdRequest:
		id = v.GetWorkflowId()
	case *proto.SignalWithStartWorkflowExecutionRequest:
		id = v.GetWorkflowId()
	default:
		log.Debug(ctx, fmt.Sprintf("Temporal Workflow Service Unknown request. %v\n", req))
	}
```

**Describe the solution you'd like**
A function that we can use to pass a request/response and get the workflow ID

**Describe alternatives you've considered**
The alternative is not to be able to attach workflow ID to these grpc client spans. Or we can continue to use the above switch statement.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2023-10-26 12:22:39.000 UTC</summary>

> This is brittle as we dont have internal knowledge and if the API changes.

The API is public, not internal, and doesn't upgrade unless you upgrade the SDK. The SDK, like anyone, consumes https://github.com/temporalio/api/tree/master/temporal/api/workflowservice/v1 (via https://github.com/temporalio/api-go) and may be upgraded when you upgrade the SDK. I am not sure us taking this same switch statement and putting it in the SDK for this specific use case has enough general-purpose value.

I think the approach you are taking here makes sense, and we don't really change existing API (or even add workflow ID somewhere it wasn't before), though we may add some entirely new API with workflow ID upon creation.

What many users do in situations where they need to future proof themselves on new API additions is just have a unit test which reflectively goes over the workflow service interface calling their function with an instantiated version of every request type and asserting none fail (i.e. have your method return false that you can ignore in prod but assert against during test). This way you can catch new API additions that are not accounted for.

</details>

<details>
<summary><strong>emmaCullen</strong> commented on 2023-10-31 22:25:18.000 UTC</summary>

Hi @cretz, yes true you make a good point. If you think our current approach is fine, then we will continue to do that switch ourselves and add that unit test.  

Thanks again for the suggestions.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-11-01 12:39:22.000 UTC</summary>

:+1: I do think it is best as opposed to us exposing an extract-workflow-id-from-grpc-request in our public library API

</details>


---

<a id="1279"></a>

### #1279: Requesting a way to expose Opentelemetry trace parent information from worker request response protos

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1279 |
| **State** | CLOSED |
| **Author** | emmaCullen (Emma Cullen) |
| **Created** | 2023-10-26 02:51:33.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-01 12:42:26.000 UTC |
| **Closed** | 2023-11-01 12:42:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We would like a way to link spans generated by our worker GRPC client interceptor, to the underlying temporal workflow spans. This way we can see what the grpc request was that led to a particular workflow execution span.

The plan is currently to add an attribute to our worker GRPC client span, something like `temporal.traceID`, or if it makes sense we can add an array of trace IDs as an attribute on the span.

In order to do this ^, we need a way to get the trace parent information out of the workflow proto request/response payloads. I noticed that this is usually stored in the Header field, although I am not familiar enough to know which types have this header and where the header will be nested for different types.

For example for one of the response type `PollWorkflowTaskQueueResponse`, an example of a trace parents we are interested in is under 

```
WorkflowExecution.History.Events[0].Attributes.HistoryEvent_WorkflowExecutionStartedEventAttributes.Header.Fields[defaultHeaderKey].GetData()
```


**Describe the solution you'd like**
A way for us to access the trace parent data from the GRPC client interceptor on the worker, for requests/responses where the tracer_data header is present.

Suggestion: a function that we can use to pass a request/response interface{} and get the traceparent data returned?

**Describe alternatives you've considered**
Not having it. With this approach we would have no way to link the grpc span to the subsequent workflow spans.

**Additional context**

Example full payload, we are interested in the `tracer_data` in bold:

&PollWorkflowTaskQueueResponse{TaskToken:[10 36 56 54 50 57 54 50 99 50 45 101 99 101 57 45 52 97 54 57 45 56 55 102 57 45 102 100 55 57 50 50 50 97 53 55 101 57 18 37 101 50 101 95 102 97 107 101 114 111 99 107 95 97 117 116 104 95 49 54 57 56 50 56 56 50 57 53 49 57 54 51 48 52 48 48 48 26 36 49 97 98 52 99 97 50 99 45 54 50 50 51 45 52 54 57 53 45 57 99 100 51 45 55 102 102 97 97 53 102 51 50 53 98 48 32 2 40 1 74 11 8 205 11 16 168 165 149 6 24 203 8 80 3 88 203 8 98 11 8 176 165 231 169 6 16 183 241 129 26],WorkflowExecution:&v13.WorkflowExecution{WorkflowId:e2e_fakerock_auth_1698288295196304000,RunId:1ab4ca2c-6223-4695-9cd3-7ffaa5f325b0,},WorkflowType:&v13.WorkflowType{Name:HelloWorkflow,},PreviousStartedEventId:0,StartedEventId:3,Attempt:1,BacklogCountHint:0,History:&v16.History{Events:[]*HistoryEvent{&HistoryEvent{EventId:1,EventTime:2023-10-26 02:45:04.043561034 +0000 UTC,EventType:WorkflowExecutionStarted,Version:1099,TaskId:12931743,Attributes:&HistoryEvent_WorkflowExecutionStartedEventAttributes{WorkflowExecutionStartedEventAttributes:&WorkflowExecutionStartedEventAttributes{WorkflowType:&v1.WorkflowType{Name:HelloWorkflow,},ParentWorkflowNamespace:,ParentWorkflowExecution:nil,ParentInitiatedEventId:0,TaskQueue:&v11.TaskQueue{Name:default-queue,Kind:Normal,NormalName:,},Input:&v1.Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[34 70 111 111 98 97 114 34],},},},WorkflowExecutionTimeout:0s,WorkflowRunTimeout:0s,WorkflowTaskTimeout:10s,ContinuedExecutionRunId:,Initiator:Unspecified,ContinuedFailure:nil,LastCompletionResult:nil,OriginalExecutionRunId:1ab4ca2c-6223-4695-9cd3-7ffaa5f325b0,Identity:e2e-starter,FirstExecutionRunId:1ab4ca2c-6223-4695-9cd3-7ffaa5f325b0,RetryPolicy:nil,Attempt:1,WorkflowExecutionExpirationTime:<nil>,CronSchedule:,FirstWorkflowTaskBackoff:0s,Memo:nil,SearchAttributes:nil,PrevAutoResetPoints:nil,Header:&v1.Header{Fields:map[string]*Payload{**_tracer-data: &Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[123 34 116 114 97 99 101 112 97 114 101 110 116 34 58 34 48 48 45 97 55 57 102 56 49 53 55 101 52 53 102 54 102 54 48 56 53 53 99 55 54 50 97 102 56 102 99 52 99 50 48 45 52 48 55 51 55 50 50 51 50 54 57 48 49 53 100 50 45 48 49 34 125]**,},},},ParentInitiatedEventVersion:0,ParentWorkflowNamespaceId:,WorkflowId:e2e_fakerock_auth_1698288295196304000,SourceVersionStamp:nil,},},WorkerMayIgnore:false,},&HistoryEvent{EventId:2,EventTime:2023-10-26 02:45:04.043607004 +0000 UTC,EventType:WorkflowTaskScheduled,Version:1099,TaskId:12931744,Attributes:&HistoryEvent_WorkflowTaskScheduledEventAttributes{WorkflowTaskScheduledEventAttributes:&WorkflowTaskScheduledEventAttributes{TaskQueue:&v11.TaskQueue{Name:default-queue,Kind:Normal,NormalName:,},StartToCloseTimeout:10s,Attempt:1,},},WorkerMayIgnore:false,},&HistoryEvent{EventId:3,EventTime:2023-10-26 02:45:04.054556855 +0000 UTC,EventType:WorkflowTaskStarted,Version:1099,TaskId:12931749,Attributes:&HistoryEvent_WorkflowTaskStartedEventAttributes{WorkflowTaskStartedEventAttributes:&WorkflowTaskStartedEventAttributes{ScheduledEventId:2,Identity:e2e-fakerock-worker,RequestId:75b36cc7-b33f-4248-b757-dcb2007ce316,SuggestContinueAsNew:false,HistorySizeBytes:972,},},WorkerMayIgnore:false,},},},NextPageToken:[],Query:nil,WorkflowExecutionTaskQueue:&v14.TaskQueue{Name:default-queue,Kind:Normal,NormalName:,},ScheduledTime:2023-10-26 02:45:04.043607004 +0000 UTC,StartedTime:2023-10-26 02:45:04.054556855 +0000 UTC,Queries:map[string]*v17.WorkflowQuery{},Messages:[]*Message{},}




#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2023-10-26 12:28:21.000 UTC</summary>

The OpenTelemetry interceptor doesn't add spans on every call, only some workflow calls. Assuming you're talking about grabbing the span on outbound client calls, you can add your own `ClientInterceptor` after the OpenTelemetry interceptor in the client-configured list and use regular span context extraction. We just call https://pkg.go.dev/go.opentelemetry.io/otel/trace#ContextWithSpan in the interceptor, so you can call https://pkg.go.dev/go.opentelemetry.io/otel/trace#SpanFromContext in your later interceptor to get it out.

Does this help? Or might you need the span at another time instead of outbound client calls?

</details>

<details>
<summary><strong>emmaCullen</strong> commented on 2023-10-31 22:19:59.000 UTC</summary>

Hi @cretz , thanks for your response. I will give that a try, the thing we want is to add the workflow traceID to the grpc client span, we need to start that span in our grpc interceptor as we need access to various grpc-specific values for other opentelemetry attributes. 

I will try and see  what happens if I use a `ClientInterceptor` to add an attribute to that parent span ðŸ¤ž  

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-11-01 12:42:26.000 UTC</summary>

:+1: Note the spans we start in interceptors are not the same as spans that a gRPC client may start. The spans in the interceptors are deserialized and used by other worker processes to re-parent their spans. That's why we only create spans specifically on things like start workflow.

Feel free to reopen (or join us on Slack or forums) if you need help with your use case here.

</details>


---

<a id="1177"></a>

### #1177: Switch to a new clock library

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1177 |
| **State** | OPEN |
| **Author** | albertteoh (Albert) |
| **Created** | 2023-07-27 07:41:40.000 UTC (2y 5m ago) |
| **Updated** | 2023-08-04 14:13:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The Temporal go SDK uses the archived https://github.com/facebookarchive/clock.

Reference: https://github.com/temporalio/sdk-go/blob/master/go.mod#L6

**Describe the solution you'd like**
Switch to an actively maintained clock. E.g. github.com/jonboulle/clockwork

**Describe alternatives you've considered**
I've often used https://github.com/benbjohnson/clock in the past, but
that appears to be archived as well.

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-01 18:45:00.000 UTC</summary>

Being archived is not a strong reason to migrate off of by itself

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2023-08-02 13:58:10.000 UTC</summary>

> Being archived is not a strong reason to migrate off of by itself

I appreciate the response @Quinn-With-Two-Ns and yes, I agree, it's not a strong reason to migrate off by itself.

For context, the primary reason is usability.

Mocking `time.Now()` with https://github.com/facebookarchive/clock requires a bit more effort. An [example in this codebase](https://github.com/temporalio/sdk-go/blob/930cc2b106ffce2f8659b65a66fac03cd5b1fc3d/internal/internal_workflow_testsuite.go#L340) is:

```go
env.mockClock.Add(startTime.Sub(env.mockClock.Now()))
```

With github.com/jonboulle/clockwork, it feels a bit more intuitive and readable:
```go
env.mockClock = clockwork.NewFakeClockAt(startTime)
```

On top of that, I see that `"github.com/facebookgo/clock"` is only imported in [a single test file](https://github.com/temporalio/sdk-go/blob/930cc2b106ffce2f8659b65a66fac03cd5b1fc3d/internal/internal_workflow_testsuite.go#L36), so migrating over should be fairly trivial.

It may even be a reason for mocking out other unit tests that are sleeping on a real clock.

Finally, the reason for reaching out was because we are using the temporalio/sdk-go which has an indirect dependency on github.com/facebookarchive/clock but, due to the usability issue mentioned above and it being archived, we decided to go for another clock implementation for our unit tests. So it's a bit of a shame that we can't just have the one clock dependency.

Again, not a pressing matter, just thought to discuss this to see if there's interest in the Temporal community, and happy to contribute a change too. I can also close this issue if there's no interest/appetite. ðŸ˜„ 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-04 14:13:33.000 UTC</summary>

>So it's a bit of a shame that we can't just have the one clock dependency.

while I understand, moving to different clock dependency could cause the same issue for other users currently using https://github.com/facebookarchive/clock

Given the simplicity of these mocks, I'd rather just get rid of the dependency and write some code in the SDK to replace it .

Reactions: ðŸ‘ 1

</details>


---

<a id="1176"></a>

### #1176: [Bug] BadRequestCancelActivityAttributes invalid history builder state for action

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1176 |
| **State** | CLOSED |
| **Author** | Tarang (Tarang) |
| **Created** | 2023-07-22 13:04:59.000 UTC (2y 5m ago) |
| **Updated** | 2023-09-20 13:12:35.000 UTC |
| **Closed** | 2023-09-20 13:12:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

### What are you really trying to do?

I am trying to create a workflow that can respond to cancellations gracefully, by waiting for either a timeout or cancellation, whichever is first. Afterwards if there is a cancellation to skip the last activity. I use a disconnected context to allow the timer to continue despite the cancellation, since it has to wait on additional work first.

### Describe the bug

The workflow fails with 
`BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event`

### Minimal Reproduction

Use temporalite as a server

Use the `cancellation` example from samples-go with the following workflow code instead

1. Start worker
2. Run starter
3. Run cancellation

The key thing is using a disconnected context to control the timer.

Workflow.go


```
package cancellation

import (
	"errors"
	"fmt"
	"time"

	"go.temporal.io/sdk/workflow"
)

// @@@SNIPSTART samples-go-cancellation-workflow-definition
// YourWorkflow is a Workflow Definition that shows how it can be canceled.
func YourWorkflow(ctx workflow.Context) error {
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 30 * time.Minute,
		HeartbeatTimeout:    5 * time.Second,
		WaitForCancellation: true,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	logger := workflow.GetLogger(ctx)
	logger.Info("cancel workflow started")
	defer func() {

		if !errors.Is(ctx.Err(), workflow.ErrCanceled) {
			return
		}

		// When the Workflow is canceled, it has to get a new disconnected context to execute any Activities
		newCtx, _ := workflow.NewDisconnectedContext(ctx)
		err := workflow.ExecuteActivity(newCtx, CleanupActivity).Get(ctx, nil)
		if err != nil {
			logger.Error("CleanupActivity failed", "Error", err)
		}
	}()

	//Create selector
	s := workflow.NewSelector(ctx)

	newCtx, _ := workflow.NewDisconnectedContext(ctx)
	newCtx, cancel := workflow.WithCancel(newCtx)

	timer1 := workflow.NewTimer(newCtx, 5*time.Minute)

	s.AddFuture(timer1, func(f workflow.Future) {
		fmt.Println("Timer Cancelled")
	})

	s.AddReceive(ctx.Done(), func(c workflow.ReceiveChannel, more bool) {
		c.Receive(ctx, nil)
		cancel()
		s.Select(ctx)
	})

	s.Select(ctx)

	var result string
	err := workflow.ExecuteActivity(ctx, ActivityToBeCanceled).Get(ctx, &result)
	logger.Info(fmt.Sprintf("ActivityToBeCanceled returns %v, %v", result, err))

	return nil
}

```

main.go
```
package main

import (
	"log"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"

	"github.com/temporalio/samples-go/cancellation"
)

// @@@SNIPSTART samples-go-cancellation-worker-starter
func main() {
	// The client and worker are heavyweight objects that should be created once per process.
	c, err := client.Dial(client.Options{
		HostPort: client.DefaultHostPort,
	})
	if err != nil {
		log.Fatalln("Unable to create client", err)
	}
	defer c.Close()

	w := worker.New(c, "cancel-activity", worker.Options{})

	w.RegisterWorkflow(cancellation.YourWorkflow)
	w.RegisterActivity(cancellation.ActivityToBeSkipped)
	w.RegisterActivity(cancellation.ActivityToBeCanceled)
	w.RegisterActivity(cancellation.CleanupActivity)

	err = w.Run(worker.InterruptCh())
	if err != nil {
		log.Fatalln("Unable to start worker", err)
	}
}

// @@@SNIPEND

```

activity.go
```
package cancellation

import (
	"context"
	"time"

	"go.temporal.io/sdk/activity"
)

// @@@SNIPSTART samples-go-cancellation-activity-definition

func ActivityToBeCanceled(ctx context.Context) (string, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("activity started, to cancel the Workflow Execution, use 'go run cancellation/cancel/main.go " +
		"-w <WorkflowID>' or use the CLI: 'tctl wf cancel -w <WorkflowID>'")
	for {
		select {
		case <-time.After(1 * time.Second):
			logger.Info("heartbeating...")
			activity.RecordHeartbeat(ctx, "")
		case <-ctx.Done():
			logger.Info("context is cancelled")
			return "I am canceled by Done", nil
		}
	}
}

func CleanupActivity(ctx context.Context) error {
	logger := activity.GetLogger(ctx)
	logger.Info("Cleanup Activity started")
	return nil
}

func ActivityToBeSkipped(ctx context.Context) error {
	logger := activity.GetLogger(ctx)
	logger.Info("this Activity will be skipped due to cancellation")
	return nil
}

// @@@SNIPEND

```

### Environment/Versions

<!-- Please complete the following information where relevant. -->

- OS and processor: M1 Mac
- Temporal Version: Temporalite with temporalite version (devel) (server 1.19.1)

### Additional context

<img width="1613" alt="Screenshot 2023-07-22 at 11 03 21â€¯pm" src="https://github.com/temporalio/samples-go/assets/1616628/74b758ea-0f5d-452e-ac89-d1ce8fd2d9bb">


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-24 05:36:40.000 UTC</summary>

I am not able to reproduce `BadRequestCancelActivityAttributes invalid history builder state for action` with the latest server, however I do get the same error I see in your screenshot. Looks to be related to the use of a disconnected context and `WaitForCancellation: true`

</details>

<details>
<summary><strong>Tarang</strong> commented on 2023-07-25 10:13:11.000 UTC</summary>

I think the exact error depends on how many activities you have after the timer that was cancelled. In this case 1, if you have 2 i think you get the other one. I can't remember exactly but this one was the simplified base case

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-09-20 13:12:34.000 UTC</summary>

Fixed in https://github.com/temporalio/sdk-go/pull/1181

</details>


---

<a id="1153"></a>

### #1153: type ScheduleWorkflowAction(ScheduleClient) is expecting Args field value as []interface{} rather than interface{}

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1153 |
| **State** | CLOSED |
| **Author** | Praveen156 |
| **Created** | 2023-07-05 05:32:09.000 UTC (2y 6m ago) |
| **Updated** | 2023-07-05 13:20:36.000 UTC |
| **Closed** | 2023-07-05 13:20:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Hi, I am trying to pass arguments to Action field of ScheduleOptions type(Create Schedule method). I am expecting to pass args of any type of my choice, like it used to be in traditional workflow execution methods.

## Actual Behavior
I am using the **ScheduleWorkflowAction** type to pass in the values to the Action field, where the **Args** field in ScheduleWorkflowAction is expecting []interface{}. I would like to know if it is intended to be this way, if it is then I would like to know if I should convert all my defined types to []interface and then pass it through.

## Steps to Reproduce the Problem

Here is an Example payload that i have used
`client.ScheduleOptions{
		Spec: client.ScheduleSpec{
			CronExpressions: []string{"* * * * *"},
		},
		Action: &client.ScheduleWorkflowAction{
			Workflow:    SampleWorkflow,
			TaskQueue:   "",
			Args:        workflowArgs,
		},
	}`

I am expecting **workflowArgs** to be of any type that I define rather than to convert it into []interface{} everytime I decide to pass arguments.

**MethodUsed** - `ScheduleClient.Create()`

## Reference Links
https://pkg.go.dev/go.temporal.io/sdk/internal#ScheduleWorkflowAction
## Specifications

  - Version: v1.23.1
  - Platform: GoSDK


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-05 06:13:04.000 UTC</summary>

Yes it is expected. You should not need to convert any types, just pass your arguments in as a list

</details>

<details>
<summary><strong>Praveen156</strong> commented on 2023-07-05 06:40:17.000 UTC</summary>

Thanks @Quinn-With-Two-Ns 

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-07-05 13:20:36.000 UTC</summary>

Also feel free to use forums or Slack for general questions.

</details>


---

<a id="1133"></a>

### #1133: Workflow deadlock when having a timer in the root scope and a timer in a coroutine

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1133 |
| **State** | CLOSED |
| **Author** | maxtwardowski (Max Twardowski) |
| **Created** | 2023-06-09 14:01:29.000 UTC (2y 7m ago) |
| **Updated** | 2023-06-11 18:00:50.000 UTC |
| **Closed** | 2023-06-11 18:00:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

A workflow with two timers: one in its root scope and one inside of a coroutine (`workflow.Go(...)`) makes the workflow fail with a `WorkflowTaskFailed` event and a `Potential deadlock detected: workflow goroutine "2" didn't yield for over a second` error message.

## Expected Behavior
I expect the workflow to behave just like its "plain Go code" equivalent in the snippet below:
```go
package main

import (
	"log"
	"time"
)

func main() {
	go func() {
		t := time.NewTicker(time.Second * 3) // coroutine ticker
		for {
			select {
			case <-t.C:
				log.Println("gofunc tick")
			}
		}
	}()

	t := time.NewTicker(time.Second * 10) // main scope ticker
	for i := 0; i < 1000; i++ {
		select {
		case <-t.C:
			log.Println("main tick")
		}
	}
}
```

## Actual Behavior
The workflow execution fails with a deadlock error

## Steps to Reproduce the Problem
1. Execute the workflow implemented in the snippet below:
```go
package main

import (
	"log"
	"sync"
	"time"

	"go.temporal.io/sdk/workflow"
)

func TestWorkflow(ctx workflow.Context) error {
	workflow.Go(ctx, func(ctx workflow.Context) {
		for {
			sel := workflow.NewSelector(ctx)
			t := workflow.NewTimer(ctx, 10*time.Second) // coroutine ticker
			sel.AddFuture(t, func(f workflow.Future) {
				log.Println("coroutine tick")
			})
		}
	})

	for i := 0; i < 1000; i++ {
		t := workflow.NewTimer(ctx, 30*time.Second) // main scope ticker
		if err := t.Get(ctx, nil); err != nil {
			log.Println("ERROR", err.Error())
			continue
		}
		log.Println("main scope tick")
	}

	return workflow.NewContinueAsNewError(ctx, ExecuteScheduledOperations)
}
```
2. Wait a bit, note that none of the `log.Println(...)` logs are present in the output and observe the following error (I used [temporalio/ui](https://github.com/temporalio/ui)):
```json
{
  "message": "Potential deadlock detected: workflow goroutine \"2\" didn't yield for over a second",
  "source": "GoSDK",
  "stackTrace": "process event for wf-interactive [panic]:\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*coroutineState).call(0xc0007f8ff0, 0x3b9aca00)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:925 +0x19e\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked(0xc0007f8af0, 0x1e7c580?)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:1014 +0x1a5\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.executeDispatcher({0x2762ce8, 0xc0004fc300}, {0x27660c0, 0xc0007f8af0}, 0x0?)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:602 +0x9f\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted(0xc000142400?, 0xc000142100?)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_workflow.go:575 +0x32\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc0004f7008, 0xc000735600, 0xd8?, 0x0)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_event_handlers.go:815 +0x203\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0006143f0, 0xc0005e6420)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:878 +0xca8\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc0004b0630, 0xc0005e6420, 0xc0004f2c00)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:727 +0x485\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc0003488f0, 0xc0005e6420)\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:284 +0x2cd\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc0003488f0, {0x1e31ec0?, 0xc0005e6420?})\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:255 +0x6c\ngithub.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc00060c3c0, {0x1e31a80?, 0xc000429600})\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:398 +0x167\ncreated by github.com/my_projectpath/vendor/go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher\n\t/go/src/github.com/my_projectpath/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:302 +0xb5",
  "encodedAttributes": null,
  "cause": null,
  "applicationFailureInfo": {
    "type": "PanicError",
    "nonRetryable": true,
    "details": null
  }
}
```

![image](https://github.com/temporalio/temporal/assets/5285849/0e77bb12-d556-41d9-8252-edfbf42321f8)


## Specifications

  - Version: 1.20.3.2 (also tested on 1.19.0)
  - Platform: Ubuntu 22.04.2 LTS (x86-64)


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-10 05:01:47.000 UTC</summary>

Looking at your workflow code I would expect this to deadlock. 

Your  workflow code is not equivalent to the Go code above because in your workflow code you never actually block on the selector. You just keep adding futures into the selector and never actually wait on any.

I'd recommend you have a look at  our [documentation ](https://legacy-documentation-sdks.temporal.io/go/selectors#full-api-example) on  the `selector`. I'll note there also isn't a benefit to using a selector on only one future.




</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-10 05:03:31.000 UTC</summary>

To wait until a future is ready you need to call `Select`, See this take from the documentation I linked above.
```
    // API Example: block until the next Future is ready to run
    // important! none of the deferred code runs until you call selector.Select
    selector.Select(ctx)
```

</details>

<details>
<summary><strong>maxtwardowski</strong> commented on 2023-06-11 18:00:50.000 UTC</summary>

@Quinn-With-Two-Ns Right, I forgot about the `.Select(...)` call... Closing the issue, the workflow behaves as expected.

</details>


---

<a id="1044"></a>

### #1044: SDK updates not being properly run

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1044 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-02-16 22:41:13.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-09 21:53:44.000 UTC |
| **Closed** | 2023-03-09 21:53:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | mmcshane, alexshtin |
| **Milestone** | None |

#### Description

## Steps to Reproduce the Problem

Here are two standalone examples that cause context deadline results for update.

Gets some proper events:
<details><summary>Replication 1</summary><p>

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

// Scenario:
// * Workflow waits for activity inside update
// * Workflow worker stops after activity started
// * Update sent
// * Activity completed
// * Workflow worker started back up

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	c, err := client.Dial(client.Options{})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting workflow worker")
	taskQueue := uuid.NewString()
	workflowWorker := worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})
	workflowWorker.RegisterWorkflow(MyWorkflow)
	if err := workflowWorker.Start(); err != nil {
		return fmt.Errorf("failed starting worker: %w", err)
	}

	log.Printf("Starting activity worker")
	activityWorker := worker.New(c, taskQueue, worker.Options{DisableWorkflowWorker: true})
	activityWorker.RegisterActivity(MyActivity)
	if err := activityWorker.Start(); err != nil {
		return fmt.Errorf("failed starting worker: %w", err)
	}
	defer activityWorker.Stop()

	log.Printf("Starting workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, MyWorkflow)
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}

	log.Printf("Waiting for activity to show as started")
	<-activityWaiting

	log.Printf("Starting update")
	// Send update in background
	updateResultCh := make(chan string, 1)
	updateErrCh := make(chan error, 1)
	go func() {
		var updateResult string
		handle, err := c.UpdateWorkflow(ctx, run.GetID(), run.GetRunID(), "MyUpdate")
		if err != nil {
			updateErrCh <- err
		} else if err := handle.Get(ctx, &updateResult); err != nil {
			updateErrCh <- err
		} else {
			updateResultCh <- updateResult
		}
	}()

	log.Printf("Waiting two seconds then shutting down workflow worker")
	time.Sleep(2 * time.Second)
	workflowWorker.Stop()

	log.Printf("Completing activity")
	close(activityShouldComplete)

	log.Printf("Waiting two seconds and starting up workflow worker again")
	time.Sleep(2 * time.Second)
	workflowWorker = worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})
	workflowWorker.RegisterWorkflow(MyWorkflow)
	if err := workflowWorker.Start(); err != nil {
		return fmt.Errorf("failed starting worker: %w", err)
	}
	defer workflowWorker.Stop()

	select {
	case res := <-updateResultCh:
		log.Printf("Got update result: %v", res)
		return nil
	case err := <-updateErrCh:
		return fmt.Errorf("got update error: %w", err)
	}
}

var activityWaiting = make(chan struct{})
var activityShouldComplete = make(chan struct{})

func MyActivity(ctx context.Context) (string, error) {
	select {
	case <-activityWaiting:
	default:
		close(activityWaiting)
	}
	<-activityShouldComplete
	return "some string", nil
}

func MyWorkflow(ctx workflow.Context) error {
	// Start activity
	fut := workflow.ExecuteActivity(
		workflow.WithActivityOptions(ctx, workflow.ActivityOptions{ScheduleToCloseTimeout: 30 * time.Hour}),
		MyActivity,
	)

	// Set update handler that only completes after activity completes
	err := workflow.SetUpdateHandler(
		ctx,
		"MyUpdate",
		func(ctx workflow.Context) (s string, err error) {
			err = fut.Get(ctx, &s)
			return
		},
	)
	if err != nil {
		return fmt.Errorf("failed setting update handler: %w", err)
	}

	// Wait around
	return workflow.Sleep(ctx, 30*time.Hour)
}

```

</p></details>

History doesn't even acknowledge update accepted:

<details><summary>Replication 2</summary><p>

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

// Scenario:
// * Workflow has simple update handler and starts activity
// * Workflow worker stops after activity started
// * Update sent, activity completed, another update sent
// * Workflow worker started back up

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	c, err := client.Dial(client.Options{})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting workflow worker")
	taskQueue := uuid.NewString()
	workflowWorker := worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})
	workflowWorker.RegisterWorkflow(MyWorkflow)
	if err := workflowWorker.Start(); err != nil {
		return fmt.Errorf("failed starting worker: %w", err)
	}

	log.Printf("Starting activity worker")
	activityWorker := worker.New(c, taskQueue, worker.Options{DisableWorkflowWorker: true})
	activityWorker.RegisterActivity(MyActivity)
	if err := activityWorker.Start(); err != nil {
		return fmt.Errorf("failed starting worker: %w", err)
	}
	defer activityWorker.Stop()

	log.Printf("Starting workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, MyWorkflow)
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}

	log.Printf("Waiting for activity to show as started")
	<-activityWaiting

	log.Printf("Shutting down workflow worker")
	time.Sleep(2 * time.Second)
	workflowWorker.Stop()

	// Updater
	updateResultCh := make(chan string, 2)
	updateErrCh := make(chan error, 2)
	doUpdate := func() {
		var updateResult string
		if handle, err := c.UpdateWorkflow(ctx, run.GetID(), run.GetRunID(), "MyUpdate"); err != nil {
			updateErrCh <- err
		} else if err := handle.Get(ctx, &updateResult); err != nil {
			updateErrCh <- err
		} else {
			updateResultCh <- updateResult
		}
	}

	log.Printf("Sending first update")
	go doUpdate()

	log.Printf("Waiting two seconds then completing activity")
	time.Sleep(2 * time.Second)
	close(activityShouldComplete)

	log.Printf("Waiting two seconds and sending second update")
	time.Sleep(2 * time.Second)
	go doUpdate()

	log.Printf("Waiting two seconds and starting up workflow worker again")
	time.Sleep(2 * time.Second)
	workflowWorker = worker.New(c, taskQueue, worker.Options{LocalActivityWorkerOnly: true})
	workflowWorker.RegisterWorkflow(MyWorkflow)
	if err := workflowWorker.Start(); err != nil {
		return fmt.Errorf("failed starting worker: %w", err)
	}
	defer workflowWorker.Stop()

	for i := 0; i < 2; i++ {
		select {
		case res := <-updateResultCh:
			log.Printf("Got update result: %v", res)
		case err := <-updateErrCh:
			return fmt.Errorf("got update error: %w", err)
		}
	}

	log.Printf("Replaying workflow")
	replayer := worker.NewWorkflowReplayer()
	replayer.RegisterWorkflow(MyWorkflow)
	err = replayer.ReplayWorkflowExecution(ctx, c.WorkflowService(), nil, "default", workflow.Execution{
		ID:    run.GetID(),
		RunID: run.GetRunID(),
	})
	if err != nil {
		return fmt.Errorf("replay failed: %w", err)
	}
	return nil
}

var activityWaiting = make(chan struct{})
var activityShouldComplete = make(chan struct{})

func MyActivity(ctx context.Context) (string, error) {
	select {
	case <-activityWaiting:
	default:
		close(activityWaiting)
	}
	<-activityShouldComplete
	return "some string", nil
}

func MyWorkflow(ctx workflow.Context) error {
	var updateResponse string

	// Set update handler that only completes after activity completes
	err := workflow.SetUpdateHandlerWithOptions(
		ctx,
		"MyUpdate",
		func(ctx workflow.Context) (string, error) {
			return updateResponse, nil
		},
		workflow.UpdateHandlerOptions{
			Validator: func() error {
				if updateResponse == "" {
					return fmt.Errorf("update response unset")
				}
				return nil
			},
		},
	)
	if err != nil {
		return fmt.Errorf("failed setting update handler: %w", err)
	}

	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		ScheduleToCloseTimeout: 30 * time.Hour,
	})
	if err = workflow.ExecuteActivity(ctx, MyActivity).Get(ctx, &updateResponse); err != nil {
		return fmt.Errorf("failed executing activity: %w", err)
	}

	// Wait around
	return workflow.Sleep(ctx, 30*time.Hour)
}
```
</p></details>

Can run with Temporal CLI upgraded to latest server `master` using:

> temporal server start-dev --dynamic-config-value frontend.enableUpdateWorkflowExecution=true

#### Comments (3)

<details>
<summary><strong>mmcshane</strong> commented on 2023-03-03 19:28:42.000 UTC</summary>

First one is a bug. Didn't realize that when we replay history to catch a WF context up after a crash (or as here, an intentional worker exit), we don't actually use the replayer. The same inferMessages call that is used by the replayer can be used in this additional code path to suss out messages via readahead.

Moving on to investigating the second.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>mmcshane</strong> commented on 2023-03-06 18:22:48.000 UTC</summary>

Second one is a consequence of not yet having retry for speculative tasks. The first update goes into the sticky queue for the first incarnation of the workflow worker. Once the worker starts with a different sticky queue, there is no upstream retry on the WFT to re-send it. Disabling sticky queues yields the expected execution*.

\* Actually it triggers a different bug, but with _that_ bug fixed we see the expected execution

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>mmcshane</strong> commented on 2023-03-09 21:53:36.000 UTC</summary>

Closed with #1055 

Related is #1057 and https://github.com/temporalio/temporal/issues/4018 

Reactions: ðŸ‘ 1

</details>


---

<a id="1037"></a>

### #1037: Calling a value receiver method with a pointer type causes a panic when used through `ExecuteActivity`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1037 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-02-13 16:21:14.000 UTC (2y 11m ago) |
| **Updated** | 2023-02-13 17:02:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The call to work like it does in usual go code. The inverse does work in temporal ie calling a pointer receiver with a value type does work.

## Actual Behavior
Panic in the workflow
```
2023/02/13 08:16:28 ERROR Workflow panic Namespace default TaskQueue hello-world WorkerID 10319@Quinn-Klassens-MacBook-Pro.local@ WorkflowType Workflow WorkflowID hello_world_workflowID RunID 70d34349-a651-4924-b780-855af0c9ca6a Attempt 2 Error runtime error: invalid memory address or nil pointer dereference StackTrace coroutine root [panic]:
github.com/temporalio/samples-go/helloworld.Workflow({0x1038a6860?, 0x14000362a50?}, {0x140000b0050, 0x8})
        /Users/quinnklassen/Documents/Code/samples-go/helloworld/helloworld.go:23 +0xc4
reflect.Value.call({0x1037740a0?, 0x103896c28?, 0x104398108?}, {0x10357a176, 0x4}, {0x14000362a80, 0x2, 0x10?})
        /opt/homebrew/Cellar/go/1.19.3/libexec/src/reflect/value.go:584 +0x688
reflect.Value.Call({0x1037740a0?, 0x103896c28?, 0x1400016fd18?}, {0x14000362a80?, 0x140001fa1c0?, 0x20?})
        /opt/homebrew/Cellar/go/1.19.3/libexec/src/reflect/value.go:368 +0x90
go.temporal.io/sdk/internal.executeFunction({0x1037740a0, 0x103896c28}, {0x140001fa1c0, 0x2, 0x103e9faa0?})
        /Users/quinnklassen/go/pkg/mod/go.temporal.io/sdk@v1.21.1/internal/internal_worker.go:1729 +0x140
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0x140003a8320, {0x1038a66d8?, 0x14000374300}, 0x1400019c600)
        /Users/quinnklassen/go/pkg/mod/go.temporal.io/sdk@v1.21.1/internal/workflow.go:506 +0x14c
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0x1400029abc0, {0x1038a66d8, 0x14000374300}, 0x25?)
        /Users/quinnklassen/go/pkg/mod/go.temporal.io/sdk@v1.21.1/internal/internal_worker.go:780 +0x238
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1({0x1038a6860, 0x140003628d0})
        /Users/quinnklassen/go/pkg/mod/go.temporal.io/sdk@v1.21.1/internal/internal_workflow.go:507 +0xd0
```


## Steps to Reproduce the Problem
```
func Workflow(ctx workflow.Context, name string) (string, error) {
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	var result string
	var a *ActivityStruct
	_ = workflow.ExecuteActivity(ctx, a.Activity, name).Get(ctx, &result)
	return result, nil
}

type ActivityStruct struct {
}

func (a ActivityStruct) Activity(ctx context.Context, name string) (string, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("Activity", "name", name)
	return "Hello " + name + "!", nil
}

```
## Specifications

  - Version: 1.21
  - Platform: M1 Mac


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2023-02-13 16:32:06.000 UTC</summary>

I don't think you can fix this. That panic occurs before you have access. From spec at https://go.dev/ref/spec#Method_values:

> As with [selectors](https://go.dev/ref/spec#Selectors), a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: pt.Mv is equivalent to (*pt).Mv.

Which of course is what causes the panic. There is an alternative in that we may be able to support `ActivityStruct.Activity` but that basically uncurries the first arg as the receiver which has other implications.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-13 16:40:06.000 UTC</summary>

Yeah I agree we can't fix it, the best we can do is add a check to the workflow checker for this. 

>There is an alternative in that we may be able to support ActivityStruct.Activity 

I actually like this approach because I see a lot users get confused about why they need to declare this empty struct when calling activities in a workflow. What are the other implications?

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-13 16:59:36.000 UTC</summary>

> What are the other implications?

It is just a bit less clear to do with a pointer receiver. So we'll either have:

> Use `var a *ActivityStruct` + `a.Activity` approach for pointer methods and `ActivityStruct.Activity` for non-pointer methods

or

> Use `(*ActivityStruct).Activity` for pointer methods or `ActivityStruct.Activity` for non-pointer methods

But it's probably OK. Also, you'll have to make some assumptions or do advanced checks, because reflection won't be able to tell the difference between: `func (ActivityStruct) Activity(context.Context)` and `func Activity(ActivityStruct, context.Context)` naively. You'll have to take the first param if it's not a context, check if there's a method of the same name, and maybe even use function pointer equality check to ensure it's a method and not a top-level function. But maybe you don't need to over-validate.

</details>


---

<a id="1035"></a>

### #1035: Workflowcheck should check that serialized objects do not have unexported, non-json-ignored fields

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1035 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-02-10 19:18:08.000 UTC (2y 11m ago) |
| **Updated** | 2025-02-04 18:25:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

People make this mistake plenty. There's rarely value for an unexported field on a serialized struct. But sometimes there (kinda) is when, say, you want to have something lazily cached in there for just local use so if JSON omit tag is there we won't error.



#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-13 16:08:19.000 UTC</summary>

An unexported field may still be being serialized if a struct implements a custom `MarshalJSON`. So we should probably check for this case and not error on types that do this.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>iwittkau</strong> commented on 2024-05-30 09:21:05.000 UTC</summary>

This would be really nice to have because I see this is a common mistake developers make when implementing their first workflow.

</details>

<details>
<summary><strong>iwittkau</strong> commented on 2024-05-30 09:35:01.000 UTC</summary>

[Go's `vet` command](https://pkg.go.dev/cmd/vet) provides a `structtag` check. But that only works if you add `json` tags to the struct fields. Maybe someone finds this useful or it can be used to enhance `workflowcheck`.

```go
type Args struct {
    name string `json:"name"`
}
```

```sh
$ go vet .
./args.go:4:2: struct field name has json tag but is not exported
```

</details>


---

<a id="1008"></a>

### #1008: Not able to execute activity which is on another service.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1008 |
| **State** | CLOSED |
| **Author** | VAIBHAV7500 (VAIBHAV SOLANKI) |
| **Created** | 2023-01-20 12:02:29.000 UTC (2y 11m ago) |
| **Updated** | 2023-01-21 06:26:17.000 UTC |
| **Closed** | 2023-01-21 06:26:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
https://community.temporal.io/t/not-able-to-call-activity-on-another-service/6992

Iâ€™m calling activity in my nodejs service from my golang workflow.
The name of the activity is same as what error is suggesting but still not able to pass through.



#### Comments (3)

<details>
<summary><strong>giautm</strong> commented on 2023-01-20 12:13:34.000 UTC</summary>

Do you try `nodeActivity` yet?

</details>

<details>
<summary><strong>VAIBHAV7500</strong> commented on 2023-01-20 12:20:17.000 UTC</summary>

When I tried executing it from the workflow within the same service, the activity ran fine.

</details>

<details>
<summary><strong>VAIBHAV7500</strong> commented on 2023-01-21 06:26:16.000 UTC</summary>

This issue got resolved by just passing the activity name.
```
err := workflow.ExecuteActivity(ctx, "nodeActivity").Get(ctx, nil)
```

</details>


---

<a id="972"></a>

### #972: Programatic list API with intoHistories iterator

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/972 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-12-02 00:59:19.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-02 20:29:25.000 UTC |
| **Closed** | 2022-12-02 20:29:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

*No description provided.*

#### Comments (3)

<details>
<summary><strong>bergundy</strong> commented on 2022-12-02 00:59:57.000 UTC</summary>

See https://github.com/temporalio/sdk-java/issues/1552 for reference

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 13:06:42.000 UTC</summary>

To follow Java, you need to:

* Add `client.WorkflowExecution` that wraps a raw execution info proto
* Add a `client.WorkflowExecutionDescription` that embeds the workflow execution and wraps raw description response
* Deprecate `Client.DescribeWorkflowExecution`
* Add `Client.DescribeWorkflow`
* Deprecate `Client.List*Workflow`
* Add `Client.ListWorkflows`
  * Accepts a `ListWorkflowsOptions` which right now only contains a `Query string`
  * Returns a `WorkflowExecutionIterator`
* Add a `client.WorkflowHistory` that wraps raw workflow history
  * Have marshal/unmarshal JSON that is just protojson
  * Consider a JSON marshal form/option that puts our enums back as they should be
* Add `WorkflowExecutionIterator`
  * Easiest way to turn this into histories for replaying? Let them just do it themselves?
* Add `HistoryEventIterator` method to just return a `client.WorkflowHistory`
  * Or add a workflow history constructor that accepts it
* Support `client.WorkflowHistory` in the `worker.WorkflowReplayer`

All of these client changes make me nervous. Do we need to stop and think about this? There are a lot of things wrong with the client interface, and just bolting more things on it may not be the solution. Maybe we only want the list part and not the describe part?

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-12-02 20:29:25.000 UTC</summary>

Closing this.
We'll need to have discussion of the future of the Go client API and whether we want to deprecate the APIs @cretz listed above.

</details>


---

<a id="964"></a>

### #964: Export asyncFuture interface 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/964 |
| **State** | CLOSED |
| **Author** | nitesh237 (Nitesh Gupta) |
| **Created** | 2022-11-23 08:05:52.000 UTC (3y 1m ago) |
| **Updated** | 2023-03-02 03:03:44.000 UTC |
| **Closed** | 2022-11-29 18:24:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We have a use-case to add some validation on the request and response getting passed in the activity. The validations can be like the response must be a proto message. The response must have a specific header field, etc.

The preferred way to solve this is using a future wrapper that has validation added before invoking the original methods. Basically, using the composition as shown below:

```
type wfProtoFuture struct {
	workflowFuture workflow.Future
}

var _ workflow.Future = &wfProtoFuture{}

func WrapProtoFuture(future workflow.Future) workflow.Future {
	return &wfProtoFuture{workflowFuture: future}
}

func (p *wfProtoFuture) Get(ctx workflow.Context, valuePtr interface{}) error {
	if res, ok := valuePtr.(proto.Message); !ok {
		return fmt.Errorf("value ptr passed must be a proto.Message")
	} else if !isValidActivityResponse(res) {
		return fmt.Errorf("missing response headers in activity response")
	}

	return p.workflowFuture.Get(ctx, valuePtr)
}

func (p *wfProtoFuture) IsReady() bool {
	return p.workflowFuture.IsReady()
}
```
This way we would be able to fail fast in the workflow code itself while blocking the workflow on the future objects. However, the SDK right now doesn't expose `asyncFuture` interface. This restricts wrapper usage. When we pass the wrapped future to a selector we get an error because of this line [here](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow.go#L1192).


```
asyncF, ok := future.(asyncFuture)
if !ok {
panic("cannot chain Future that wasn't created with workflow.NewFuture")
}
```

**Describe the solution you'd like**
* Make `asyncFuture` interface exported.

**Describe alternatives you've considered**
The other alternative is to add the validation workflow and activity interceptor. 



#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-11-23 19:01:08.000 UTC</summary>

Futures passed back into helpers like selector are meant to be the unwrapped future that was created by Temporal. This is because some internal aspects of the future are relied on. If you must wrap the future, you should unwrap it when calling select instead of trying to reuse the Temporal future interface. Since you're already wrapping, there's no reason to reuse the Temporal interface, use your own type (you can be even stricter on your `Get` type, use generics, etc).

Why not have just your `wfProtoFuture` just have the future in it and unwrap at selector time? There's no reason to match the Temporal interface. Can make your own helper, e.g.

```go
func (p *wfProtoFuture) AddToSelector(sel workflow.Selector, fn func(*wfProtoFuture)) workflow.Selector {
  return sel.AddFuture(p.future, func(workflow.Future) { fn(p) })
}
```

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-11-29 18:24:09.000 UTC</summary>

Closing, but if there is more to add here, feel free to comment.

</details>

<details>
<summary><strong>nitesh-epifi</strong> commented on 2023-03-02 03:03:43.000 UTC</summary>

> Futures passed back into helpers like selector are meant to be the unwrapped future that was created by Temporal. This is because some internal aspects of the future are relied on. If you must wrap the future, you should unwrap it when calling select instead of trying to reuse the Temporal future interface. Since you're already wrapping, there's no reason to reuse the Temporal interface, use your own type (you can be even stricter on your `Get` type, use generics, etc).
> 
> Why not have just your `wfProtoFuture` just have the future in it and unwrap at selector time? There's no reason to match the Temporal interface. Can make your own helper, e.g.
> 
> ```go
> func (p *wfProtoFuture) AddToSelector(sel workflow.Selector, fn func(*wfProtoFuture)) workflow.Selector {
>   return sel.AddFuture(p.future, func(workflow.Future) { fn(p) })
> }
> ```

@cretz sorry for the delayed response. Thanks for your suggestion. We went ahead with your suggestion here.

</details>


---

<a id="962"></a>

### #962: "workflowcheck" fails to detect argument type

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/962 |
| **State** | CLOSED |
| **Author** | mindaugasrukas (Mind.R.) |
| **Created** | 2022-11-18 22:12:36.000 UTC (3y 1m ago) |
| **Updated** | 2023-10-12 17:22:27.000 UTC |
| **Closed** | 2023-10-12 17:22:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`workflowcheck` fails to detect the argument type when referenced as an empty interface type (I.e., `any`).

## Expected Behavior
It detects the type correctly.

## Actual Behavior
Having this code snippet:
```
for name, workflowFunc := range map[string]any{
    "my-workflow"-1: Workflow1,
    "my-workflow-2": Workflow2,
} {
    w.RegisterWorkflowWithOptions(workflowFunc, workflow.RegisterOptions{Name: name})
}
```

Running a check, it fails with:
```
% workflowcheck -show-pos ./...
/workflows/sandbox/workflow.go:18:33: unrecognized function reference format
```

## Specifications

  - Version:
```
% go version
go version go1.19.2 darwin/arm64
```

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-11-18 22:41:58.000 UTC</summary>

The Go static analyzer is not going to be able to know the runtime types of your map values. It's the same reason the map's value is `any`. That's the type and it's concrete type is only detectable at runtime.

However, we should probably make a way for you to ignore this error. In the meantime, you should probably try not to lose the compile-time type before the register call by converting it to `any` in another statement. Maybe we can make some other way for you to mark a function subject to workflow static analysis. Open to ideas here.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 18:38:16.000 UTC</summary>

@cretz This is basically a feature request not a bug correct?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-02 20:48:26.000 UTC</summary>

Yes. We should let people ignore the workflowcheck registration-time analysis if the registration code is too dynamic for static analysis to discover.

Reactions: ðŸ‘ 1

</details>


---

<a id="955"></a>

### #955: Suppress "worker stopping" polling errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/955 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-11-14 14:23:50.000 UTC (3y 1m ago) |
| **Updated** | 2023-10-12 22:57:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Today when stopping a worker, this error is logged to `WARN` (shown with Zap adapter):

> 2022-11-14T08:20:43.634-0600    WARN    harness/log.go:50       Failed to poll for task.        {"Namespace": "sdk-features-ns-ae5b6b4a-9ecd-48f6-a6cc-ef9bac2aea25", "TaskQueue": "sdk-features-data_converter/binary-86bf92b7-a1e0-4508-9584-ddc274948245", "WorkerID": "21004@cretz-laptop@", "WorkerType": "WorkflowWorker", "Error": "worker stopping"}

**Describe the solution you'd like**

Move that to debug level or suppress it entirely. It's not really a poll "failure" if the worker is stopping.

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 23:43:08.000 UTC</summary>

@cretz didn't you fix this here https://github.com/temporalio/sdk-go/issues/882?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-05 13:09:24.000 UTC</summary>

Hrmm, I still see these logs when I stop a worker. I guess I didn't fix it well enough or maybe there's something else I missed.

</details>

<details>
<summary><strong>Tadimsky</strong> commented on 2023-10-12 22:57:16.000 UTC</summary>

Any updates on this one? I see this still when stopping a worker (or using the SIGTERM channel).

> 2023-10-12T15:55:39.881-0700    WARN    temporal        internal/internal_worker_base.go:374    Failed to poll for task.        {"Namespace": "default", "TaskQueue": "LOW_PRI", "WorkerID": "43751@Jonnos-Laptop@", "WorkerType": "WorkflowWorker", "Error": "worker stopping"}


</details>


---

<a id="945"></a>

### #945: golang.org/x/tools-v0.1.12: 3 vulnerabilities (highest severity is: 6.1) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/945 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-11-03 13:49:09.000 UTC (3y 2m ago) |
| **Updated** | 2023-06-27 20:59:48.000 UTC |
| **Closed** | 2023-06-27 20:59:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>golang.org/x/tools-v0.1.12</b></p></summary>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip</a></p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (golang.org/x/tools-v0.1.12 version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2020-11022](https://www.mend.io/vulnerability-database/CVE-2020-11022) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.1 | golang.org/x/tools-v0.1.12 | Direct | jQuery - 3.5.0 | &#10060; |
| [CVE-2015-9251](https://www.mend.io/vulnerability-database/CVE-2015-9251) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.1 | golang.org/x/tools-v0.1.12 | Direct | jQuery - 3.0.0 | &#10060; |
| [CVE-2012-6708](https://www.mend.io/vulnerability-database/CVE-2012-6708) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.1 | golang.org/x/tools-v0.1.12 | Direct | jQuery - v1.9.0 | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2020-11022</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.12</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.12** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In jQuery versions greater than or equal to 1.2 and before 3.5.0, passing HTML from untrusted sources - even after sanitizing it - to one of jQuery's DOM manipulation methods (i.e. .html(), .append(), and others) may execute untrusted code. This problem is patched in jQuery 3.5.0.

<p>Publish Date: 2020-04-29
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2020-11022>CVE-2020-11022</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11022">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11022</a></p>
<p>Release Date: 2020-04-29</p>
<p>Fix Resolution: jQuery - 3.5.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2015-9251</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.12</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.12** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 3.0.0 is vulnerable to Cross-site Scripting (XSS) attacks when a cross-domain Ajax request is performed without the dataType option, causing text/javascript responses to be executed.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2015-9251>CVE-2015-9251</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2015-9251">https://nvd.nist.gov/vuln/detail/CVE-2015-9251</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - 3.0.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2012-6708</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.12</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.12.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.12** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 1.9.0 is vulnerable to Cross-site Scripting (XSS) attacks. The jQuery(strInput) function does not differentiate selectors from HTML in a reliable fashion. In vulnerable versions, jQuery determined whether the input was HTML by looking for the '<' character anywhere in the string, giving attackers more flexibility when attempting to construct a malicious payload. In fixed versions, jQuery only deems the input to be HTML if it explicitly starts with the '<' character, limiting exploitability only to attackers who can control the beginning of a string, which is far less common.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2012-6708>CVE-2012-6708</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-6708">https://nvd.nist.gov/vuln/detail/CVE-2012-6708</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - v1.9.0</p>

</p>

<p></p>

</details>

#### Comments (3)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-08 03:13:12.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-25 02:00:24.000 UTC</summary>

:information_source: This issue was automatically re-opened by Mend because the vulnerable library in the specific branch(es) has been detected in the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-06-27 20:59:48.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="897"></a>

### #897: golang.org/x/tools-v0.1.8: 4 vulnerabilities (highest severity is: 6.1) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/897 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-08-30 17:58:22.000 UTC (3y 4m ago) |
| **Updated** | 2023-01-25 02:00:27.000 UTC |
| **Closed** | 2023-01-25 02:00:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>golang.org/x/tools-v0.1.8</b></p></summary>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip</a></p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (golang.org/x/tools-v0.1.8 version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2020-11022](https://www.mend.io/vulnerability-database/CVE-2020-11022) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | golang.org/x/tools-v0.1.8 | Direct | jQuery - 3.5.0 | &#10060; |
| [CVE-2015-9251](https://www.mend.io/vulnerability-database/CVE-2015-9251) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | golang.org/x/tools-v0.1.8 | Direct | jQuery - 3.0.0 | &#10060; |
| [CVE-2012-6708](https://www.mend.io/vulnerability-database/CVE-2012-6708) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | golang.org/x/tools-v0.1.8 | Direct | jQuery - v1.9.0 | &#10060; |
| [CVE-2022-29526](https://www.mend.io/vulnerability-database/CVE-2022-29526) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.3 | golang.org/x/sys-v0.0.0-20211019181941-9d821ace8654 | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the section "Details" below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2020-11022</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.8</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.8** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In jQuery versions greater than or equal to 1.2 and before 3.5.0, passing HTML from untrusted sources - even after sanitizing it - to one of jQuery's DOM manipulation methods (i.e. .html(), .append(), and others) may execute untrusted code. This problem is patched in jQuery 3.5.0.

<p>Publish Date: 2020-04-29
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2020-11022>CVE-2020-11022</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11022">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11022</a></p>
<p>Release Date: 2020-04-29</p>
<p>Fix Resolution: jQuery - 3.5.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2015-9251</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.8</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.8** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 3.0.0 is vulnerable to Cross-site Scripting (XSS) attacks when a cross-domain Ajax request is performed without the dataType option, causing text/javascript responses to be executed.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2015-9251>CVE-2015-9251</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2015-9251">https://nvd.nist.gov/vuln/detail/CVE-2015-9251</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - 3.0.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2012-6708</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.8</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.8.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.8** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 1.9.0 is vulnerable to Cross-site Scripting (XSS) attacks. The jQuery(strInput) function does not differentiate selectors from HTML in a reliable fashion. In vulnerable versions, jQuery determined whether the input was HTML by looking for the '<' character anywhere in the string, giving attackers more flexibility when attempting to construct a malicious payload. In fixed versions, jQuery only deems the input to be HTML if it explicitly starts with the '<' character, limiting exploitability only to attackers who can control the beginning of a string, which is far less common.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2012-6708>CVE-2012-6708</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-6708">https://nvd.nist.gov/vuln/detail/CVE-2012-6708</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - v1.9.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-29526</summary>


###  Vulnerable Library - <b>golang.org/x/sys-v0.0.0-20211019181941-9d821ace8654</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/sys/@v/v0.0.0-20211019181941-9d821ace8654.zip">https://proxy.golang.org/golang.org/x/sys/@v/v0.0.0-20211019181941-9d821ace8654.zip</a></p>
<p>

Dependency Hierarchy:
  - golang.org/x/tools-v0.1.8 (Root Library)
    - :x: **golang.org/x/sys-v0.0.0-20211019181941-9d821ace8654** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Go before 1.17.10 and 1.18.x before 1.18.2 has Incorrect Privilege Assignment. When called with a non-zero flags parameter, the Faccessat function could incorrectly report that a file is accessible.

<p>Publish Date: 2022-06-23
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-29526>CVE-2022-29526</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: None
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://security-tracker.debian.org/tracker/CVE-2022-29526">https://security-tracker.debian.org/tracker/CVE-2022-29526</a></p>
<p>Release Date: 2022-06-23</p>
<p>Fix Resolution: go1.17.10,go1.18.2,go1.19</p>

</p>

<p></p>

</details>

#### Comments (3)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-08 03:13:09.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-09 10:51:06.000 UTC</summary>

:information_source: This issue was automatically re-opened by Mend because the vulnerable library in the specific branch(es) has been detected in the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-25 02:00:26.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="875"></a>

### #875: Safer queries (and update validators)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/875 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-02 18:28:24.000 UTC (3y 5m ago) |
| **Updated** | 2023-07-19 16:50:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Queries can start activities and such and they shouldn't

**Describe the solution you'd like**

* Allow query handlers to accept a context as the first parameter in a backwards compatible way
* Disallow that context to be used for execute activity
* Add `workflowcheck` static analyzer check to ensure query handlers do not do anything they aren't supposed to

This is obviously a non-trivial amount of work and low priority

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 21:23:27.000 UTC</summary>

This same restrictions should also apply to `SideEffects` as well

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 22:04:53.000 UTC</summary>

see also https://github.com/temporalio/sdk-features/issues/177

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-19 16:50:02.000 UTC</summary>

Queries, and other read only contexts can no longer perform any mutating operations. Leaving this open because we could still add support for the static analyzer

</details>


---

<a id="874"></a>

### #874: Accept <- chan struct{} in Worker.Run

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/874 |
| **State** | CLOSED |
| **Author** | alfa-alex |
| **Created** | 2022-08-02 09:35:44.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-02 14:24:02.000 UTC |
| **Closed** | 2022-08-02 14:22:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The `worker.Run()` function accepts a `<- chan interface{}` parameter. This makes it impossible to directly pass, e.g., `ctx.Done()` (which seems to me is the most common use case besides `internal.InterruptCh()`).

**Describe the solution you'd like**
It'd be great if the `worker.Run()` function accepted a `<- chan struct{}` instead. The `internal.InterruptCh` should then also return a `<- chan struct{}`.

**Describe alternatives you've considered**
Since this would be a breaking change, a viable alternative would be to add a `RunCtx(context.Context)` function to the `worker` interface that you directly pass a context. Would also be idiomatic.

**Additional context**
- Since it's irrelevant what you pass to the channel, a `<- chan struct{}` might also more clearly express that this channel is just used for signalling *that* some event happened.
- If you decided to change the signature of `internal.InterruptCh`, that func could then be implemented as a two-liner by utilizing `signal.NotifyCtx(...)`.

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-08-02 12:42:38.000 UTC</summary>

I am afraid we cannot make a breaking change here.

</details>

<details>
<summary><strong>alfa-alex</strong> commented on 2022-08-02 13:35:01.000 UTC</summary>

It's a pity, but understandable. So the provided alternative is also not an option, I suppose?

Then maybe something to keep in mind for `v2` of the SDK. :wink: 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-02 14:22:53.000 UTC</summary>

> So the provided alternative is also not an option, I suppose?

Unfortunately adding helpers/shortcuts on the worker interface is probably not the best thing. But they could be added top level. For instance, anyone could do (untested, just typed here in GH):

```go
func RunWorker(ctx context.Context, worker worker.Worker) error {
  doneCh := make(chan interface{})
  errCh := make(chan error, 1)
  go func() { errCh <- worker.Run(doneCh) }()
  select {
    case <-ctx.Done():
      close(doneCh)
    case err := <-errCh:
      return err
  }
  return <-errCh
}
```

Or you could use `Start()` + `Stop()` for more fine-grained control.

> Then maybe something to keep in mind for v2 of the SDK.

For sure

</details>


---

<a id="842"></a>

### #842: Support custom object processing in codec gRPC interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/842 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-06-28 21:56:12.000 UTC (3y 6m ago) |
| **Updated** | 2022-06-29 13:27:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Today we process _all_ (non-search-attribute) payloads but user may not want to process some like headers

**Describe the solution you'd like**

Accept a new `PayloadCodecGRPCClientInterceptorOptions` option that has a field like:

```go
CustomProcessor: func(processContext *ProcessContext) error
```

With a context of:

```go
type ProcessContext struct {
  Stack: []interface{}
  Current: interface{}
  Encode: bool
  Next: func(processContext *ProcessContext) error
}
```

Of course this object would be mutated during processing so it shouldn't be stored. This would allow a custom processor to check if `processContext.Current` was `*commonpb.Header` and just not call `processContext.Next()` like it would for the others.

#### Comments (3)

<details>
<summary><strong>robholland</strong> commented on 2022-06-29 07:52:08.000 UTC</summary>

Can you give some example consumers for this API?

</details>

<details>
<summary><strong>robholland</strong> commented on 2022-06-29 07:53:53.000 UTC</summary>

I guess I'm wondering why not just pass a list of types to skip?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-06-29 13:27:58.000 UTC</summary>

> Can you give some example consumers for this API?

Users who want to only skip tracing headers

> I guess I'm wondering why not just pass a list of types to skip?

No reason to make it purposefully less flexible. For example, what if you wanted to conditionally skip processing an object?

</details>


---

<a id="815"></a>

### #815: Terminated workflow fails replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/815 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-05-26 16:57:22.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-31 17:24:18.000 UTC |
| **Closed** | 2022-05-31 17:24:18.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

Should be able to handle terminated workflow event same as it does continue as new

## Actual Behavior

We don't have a switch case for `EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED` so running in replayer causes failure

Also, make sure we check for any other missing enums

#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2022-05-26 16:58:35.000 UTC</summary>

`switch` is here: https://github.com/temporalio/sdk-go/blob/master/internal/internal_event_handlers.go#L810

</details>


---

<a id="813"></a>

### #813: Weird workflow task failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/813 |
| **State** | OPEN |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2022-05-23 19:57:06.000 UTC (3y 7m ago) |
| **Updated** | 2022-07-08 14:00:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We see one weird workflow task failure from SDK that keeps retrying and eventually succeed after 13K retry attempts. 
The workflow logic is it schedules 16 activities and wait for all of them to complete. 
The history shows one of the workflow task timeout due to start_to_schedule timeout (the 5s sticky timeout). After that, a new workflow task is scheduled but it failed with SDK panic complaining activity ID not found. After about 13K retry attempts, it magically succeed eventually. The binary checksum is the same before and after the failure. 


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-05-23 19:59:07.000 UTC</summary>

Have you been able to replicate this? I am afraid the information given is not enough to go on. I can write a workflow that schedules 16 activities and waits for them to complete. I can simulate a workflow task timeout. But I fear those won't replicate. It is really important we replicate the bug to confirm it exists.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-31 16:43:20.000 UTC</summary>

The internal situation where this happened was due to a workflow task timeout before even started (schedule-to-start sticky timeout), but the workflow task failure continually failed _across multiple workers_ which makes it unlikely to be caused by cached workflow issues.

Also, an attempted replay with the history on the workflow did not replicate. this was with trimmed history and advanced logs to confirm that the activity ID was found.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-07-08 14:00:50.000 UTC</summary>

Still unable to replicate, can anyone else?

</details>


---

<a id="764"></a>

### #764: Add built-ins for workflow.NewUUID() and workflow.NewRandom()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/764 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2022-03-25 17:35:32.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-25 13:57:07.000 UTC |
| **Closed** | 2022-04-25 13:56:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Will just make it slightly more convenient for a workflow developer vs having to do their own sideeffect or local activity

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-03-28 15:11:37.000 UTC</summary>

Can you clarify what `workflow.NewRandom()` might do? Anyone can of course just `math/rand.NewRandom(math/rand.NewSource(123))` to have deterministic random given a fixed seed, no side effect needed.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-11 14:01:38.000 UTC</summary>

@mastermanu - We closed #765 because this one-line helper doesn't really add anything. Also, randomness and UUIDs created in other SDKs like TypeScript do not use side effect or local activity, they use deterministic pseudorandom from a deterministic seed. So we don't want to make utilities that make Go obviously different here.

We have long since documented at https://pkg.go.dev/go.temporal.io/sdk/workflow#hdr-SideEffect_API on how to call random. Is this good enough without the utility?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-25 13:56:33.000 UTC</summary>

@mastermanu - Bump. Gonna close this, but feel free to comment/reopen w/ more discussion.

Basically we encourage use of side effects for "new UUID" and similar randomness, but this isn't what we're doing in other SDKs (they use run-specific seeded pseudorandom to get deterministic UUIDs) and we fear codifying the difference in API.

If we do want that kind of random/uuid API, we need to remove the recommendation to use side effects and then add the API. Just would require consensus.

</details>


---

<a id="740"></a>

### #740: Execute local activity by string name fails during replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/740 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-24 19:29:07.000 UTC (3y 10m ago) |
| **Updated** | 2022-03-01 15:05:56.000 UTC |
| **Closed** | 2022-03-01 15:05:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Replay should only care about events in history

## Actual Behavior

There is a report of replay breaking due to missing local activity

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-02-25 12:47:51.000 UTC</summary>

I am not able to replicate this. My replication attempt is collapsed below:

<details><summary>main.go</summary>

```go
package main

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/google/uuid"
	enumspb "go.temporal.io/api/enums/v1"
	historypb "go.temporal.io/api/history/v1"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	c, err := client.NewClient(client.Options{})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting worker")
	taskQueue := uuid.NewString()
	w := worker.New(c, taskQueue, worker.Options{})
	w.RegisterWorkflow(HelloWorkflow)
	w.RegisterActivity(HelloActivity)
	if err := w.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer w.Stop()

	log.Printf("Running workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, HelloWorkflow, "Temporal")
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	} else if err = run.Get(ctx, nil); err != nil {
		return fmt.Errorf("workflow failed: %w", err)
	}

	log.Printf("Loading history")
	var history historypb.History
	iter := c.GetWorkflowHistory(ctx, run.GetID(), run.GetRunID(), false, enumspb.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)
	for iter.HasNext() {
		event, err := iter.Next()
		if err != nil {
			return fmt.Errorf("failed getting history: %w", err)
		}
		history.Events = append(history.Events, event)
	}
	var buf strings.Builder
	if err := (&jsonpb.Marshaler{Indent: "  "}).Marshal(&buf, &history); err != nil {
		return fmt.Errorf("failed dumping history: %w", err)
	}
	log.Printf("History:\n%v", buf.String())

	log.Printf("Running replayer")
	replayer := worker.NewWorkflowReplayer()
	replayer.RegisterWorkflow(HelloWorkflow)
	if err := replayer.ReplayWorkflowHistory(nil, &history); err != nil {
		return fmt.Errorf("failed replaying history: %w", err)
	}
	log.Printf("Replay completed successfully")

	return nil
}

func HelloWorkflow(ctx workflow.Context, name string) (string, error) {
	ctx = workflow.WithLocalActivityOptions(ctx, workflow.LocalActivityOptions{ScheduleToCloseTimeout: 2 * time.Second})
	var res string
	err := workflow.ExecuteLocalActivity(ctx, HelloActivity, name).Get(ctx, &res)
	return res, err
}

func HelloActivity(ctx context.Context, name string) (string, error) {
	return "Hello, " + name + "!", nil
}
```
</details>

The replayer works well with local activities as expected.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-25 12:49:34.000 UTC</summary>

I will leave this open a bit so others can read before closing.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-25 19:46:13.000 UTC</summary>

The issue seems to be specific to local activities registered by name. I will confirm replication and provide fix.

</details>


---

<a id="737"></a>

### #737: Confirm that temporal_workflow_task_execution_failed is updated on data conversion failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/737 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-23 21:33:41.000 UTC (3y 10m ago) |
| **Updated** | 2022-03-01 14:40:47.000 UTC |
| **Closed** | 2022-03-01 14:40:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

We may not be updating `temporal_workflow_task_execution_failed` when a data converter fails to convert workflow input.

**Describe the solution you'd like**

Make sure we are updating that metric in that situation.

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-02-24 21:12:46.000 UTC</summary>

Also confirm that `temporal_activity_execution_failed` is properly incremented on activity failure.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-25 12:35:35.000 UTC</summary>

See the collapsed script below:

<details>
  <summary>main.go</summary>
  
```go
package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/uber-go/tally/v4"
	tallyprometheus "github.com/uber-go/tally/v4/prometheus"
	commonpb "go.temporal.io/api/common/v1"
	"go.temporal.io/sdk/client"
	sdktally "go.temporal.io/sdk/contrib/tally"
	"go.temporal.io/sdk/converter"
	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client with Prometheus metrics server and failable data converter")
	failableConverter := newFailableConverter()
	c, err := client.NewClient(client.Options{
		DataConverter: failableConverter,
		MetricsHandler: sdktally.NewMetricsHandler(newPrometheusScope(tallyprometheus.Configuration{
			ListenAddress: "127.0.0.1:9090",
			TimerType:     "histogram",
		})),
	})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting worker")
	taskQueue := uuid.NewString()
	w := worker.New(c, taskQueue, worker.Options{})
	w.RegisterWorkflow(HelloWorkflow)
	w.RegisterActivity(HelloActivity)
	if err := w.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer w.Stop()

	// Test that a workflow decoder failure appears in metrics
	log.Printf("Starting workflow with bad value")
	failableConverter.shouldFailFromPayload = true
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, HelloWorkflow, "Temporal")
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}
	err = run.Get(ctx, nil)
	// We expect an error here for decoding
	if err == nil || !strings.Contains(err.Error(), "unable to decode the workflow function input") {
		return fmt.Errorf("expected decode error, got: %w", err)
	}
	log.Printf("Got expected error: %v", err)

	// Check the Prometheus metrics
	log.Printf("Waiting 3 seconds, then checking metrics")
	time.Sleep(3 * time.Second)
	metricLines, err := getMetricLines()
	if err != nil {
		return fmt.Errorf("failed getting metrics: %v", err)
	}
	for _, line := range metricLines {
		if !strings.HasPrefix(line, "#") && strings.Contains(line, "temporal_workflow_failed") {
			log.Printf("Found metric line: %v", line)
		}
	}

	// Test that an activity failure appears in metrics
	log.Printf("Starting workflow with failing activity")
	failableConverter.shouldFailFromPayload = false
	helloActivityShouldFail = true
	run, err = c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, HelloWorkflow, "Temporal")
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}
	err = run.Get(ctx, nil)
	// We expect an error here for activity
	if err == nil || !strings.Contains(err.Error(), "intentionally failing activity") {
		return fmt.Errorf("expected decode error, got: %w", err)
	}
	log.Printf("Got expected error: %v", err)

	// Check the Prometheus metrics
	log.Printf("Waiting 3 seconds, then checking metrics")
	time.Sleep(3 * time.Second)
	metricLines, err = getMetricLines()
	if err != nil {
		return fmt.Errorf("failed getting metrics: %v", err)
	}
	for _, line := range metricLines {
		if !strings.HasPrefix(line, "#") && strings.Contains(line, "temporal_samples_temporal_activity_execution_failed") {
			log.Printf("Found metric line: %v", line)
		}
	}

	return nil
}

func getMetricLines() ([]string, error) {
	resp, err := http.Get("http://127.0.0.1:9090/metrics")
	if err != nil {
		return nil, fmt.Errorf("failed getting metrics: %w", err)
	}
	body, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("failed reading response body: %w", err)
	} else if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("expected metrics 200 status, got: %v, body: %s", resp.StatusCode, body)
	}
	return strings.Split(string(body), "\n"), nil
}

func HelloWorkflow(ctx workflow.Context, name string) (string, error) {
	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		ScheduleToCloseTimeout: 2 * time.Second,
		// No retry
		RetryPolicy: &temporal.RetryPolicy{MaximumAttempts: 1},
	})
	var res string
	err := workflow.ExecuteActivity(ctx, HelloActivity, name).Get(ctx, &res)
	return res, err
}

var helloActivityShouldFail = false

func HelloActivity(ctx context.Context, name string) (string, error) {
	if helloActivityShouldFail {
		return "", fmt.Errorf("intentionally failing activity")
	}
	return "Hello, " + name + "!", nil
}

type failableConverter struct {
	converter.DataConverter
	shouldFailFromPayload bool
}

func newFailableConverter() *failableConverter {
	return &failableConverter{DataConverter: converter.GetDefaultDataConverter()}
}

func (f *failableConverter) FromPayload(payload *commonpb.Payload, valuePtr interface{}) error {
	if f.shouldFailFromPayload {
		return fmt.Errorf("intentionally failing conversion")
	}
	return f.DataConverter.FromPayload(payload, valuePtr)
}

func (f *failableConverter) FromPayloads(payloads *commonpb.Payloads, valuePtrs ...interface{}) error {
	if f.shouldFailFromPayload {
		return fmt.Errorf("intentionally failing conversion")
	}
	return f.DataConverter.FromPayloads(payloads, valuePtrs...)
}

// Taken from https://github.com/temporalio/samples-go/blob/main/metrics/worker/main.go
func newPrometheusScope(c tallyprometheus.Configuration) tally.Scope {
	reporter, err := c.NewReporter(
		tallyprometheus.ConfigurationOptions{
			Registry: prometheus.NewRegistry(),
			OnError: func(err error) {
				log.Println("error in prometheus reporter", err)
			},
		},
	)
	if err != nil {
		log.Fatalln("error creating prometheus reporter", err)
	}
	scopeOpts := tally.ScopeOptions{
		CachedReporter:  reporter,
		Separator:       tallyprometheus.DefaultSeparator,
		SanitizeOptions: &sanitizeOptions,
		Prefix:          "temporal_samples",
	}
	scope, _ := tally.NewRootScope(scopeOpts, time.Second)

	log.Println("prometheus metrics scope created")
	return scope
}

// Taken from https://github.com/temporalio/samples-go/blob/main/metrics/worker/main.go
var (
	safeCharacters = []rune{'_'}

	sanitizeOptions = tally.SanitizeOptions{
		NameCharacters: tally.ValidCharacters{
			Ranges:     tally.AlphanumericRange,
			Characters: safeCharacters,
		},
		KeyCharacters: tally.ValidCharacters{
			Ranges:     tally.AlphanumericRange,
			Characters: safeCharacters,
		},
		ValueCharacters: tally.ValidCharacters{
			Ranges:     tally.AlphanumericRange,
			Characters: safeCharacters,
		},
		ReplacementCharacter: tally.DefaultReplacementCharacter,
	}
)
```
</details>

For bad data converter, the following logs appear:

    Starting workflow with bad value
    ...
    Found metric line: temporal_workflow_failed{activity_type="none",client_name="temporal_go",namespace="default",task_queue="none",worker_type="none",workflow_type="HelloWorkflow"} 1
    
This shows that a bad data conversion results in a `temporal_workflow_failed` Prometheus metric.

For activity failure, the following logs appear:

    Starting workflow with failing activity
    ...
    Found metric line: temporal_activity_execution_failed{activity_type="HelloActivity",client_name="temporal_go",namespace="default",task_queue="fc69a0a4_8b94_48d4_85d6_948d7b75e928",worker_type="none",workflow_type="HelloWorkflow"} 1

This shows that a failed activity results in a `temporal_activity_execution_failed` Prometheus metric.

Leaving open for people to see before closing.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-03-01 14:40:47.000 UTC</summary>

Closing as metric updates confirmed. Anyone can reopen if issue persists.

</details>


---

<a id="704"></a>

### #704: Add zap implementation of logger in contrib

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/704 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-22 03:06:45.000 UTC (3y 11m ago) |
| **Updated** | 2025-08-25 15:43:11.000 UTC |
| **Closed** | 2025-08-25 15:43:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Lots of people are manually implementing `log.Logger` using Zap.

**Describe the solution you'd like**

* Add a `zap` child module to the `contrib` folder.
* It should rely on the `*zap.S`'s `<Level>W` calls which are higher performing than you see from other people's adapters
* Fix up https://github.com/temporalio/samples-go/tree/main/zapadapter to use it
* Update the vanity URL at `go.temporal.io/sdk/contrib/zap` and tag a release for `contrib/zap/v0.1.0`


#### Comments (3)

<details>
<summary><strong>ianthpun</strong> commented on 2022-05-19 04:15:23.000 UTC</summary>

> It should rely on the *zap.S's <Level>W calls which are higher performing than you see from other people's adapters

shouldn't the warning level calls just be mapped to the `Warn` call that satisfies the `log.Logger` interface and not to any other calls? 
https://github.com/temporalio/samples-go/blob/main/zapadapter/zap_adapter.go#L71-L73

`Warn` would call zaploggers `Warn` while `Info` should call `Info`, etc

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-19 12:59:39.000 UTC</summary>

Correct. When I said "It should rely on the *zap.S's W", what I mean is it should use `zap.SugaredLogger.<level>W` calls which are equivalent to our key-value varargs.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-07-10 15:28:26.000 UTC</summary>

Note, `slog` is now coming, see #1158

Reactions: â¤ï¸ 2

</details>


---

<a id="697"></a>

### #697: Context aware data converter not getting context on local activity response

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/697 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-14 18:09:38.000 UTC (3y 12m ago) |
| **Updated** | 2022-01-19 14:23:43.000 UTC |
| **Closed** | 2022-01-19 14:23:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Data converter `WithContext` should be called for local activity response

## Actual Behavior

It wasn't in the version I just debugged. I am doing deeper investigations.

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2022-01-14 20:12:41.000 UTC</summary>

This has become a much more challenging issue than originally anticipated. Specifically:

* On local activity completion, we record three pieces of data - the results, the error, and marker details
* Today we use the context-aware converter for the results, but for the error and marker details we use the custom-but-not-context-aware converter
* For the marker details, we accept that we need to use the default converter and not the custom one
* But what do we do about errors? The bug surfaces because not all invocations of the converter are given the context information, and error is one of those cases.
  * Even though we have the context when the error is serialized so we can use a context-aware converter, we don't have such a context when we are extracting the error back out...so we'll have to create such a header-infused context on every single replay for every local activity just so we can deserialize the error :-(


</details>

<details>
<summary><strong>cretz</strong> commented on 2022-01-14 20:39:53.000 UTC</summary>

I have just learned errors are not subject to custom data conversion.

Still, we may not be able to change the fact that the marker metadata and errors use the custom data converters without breaking people. We might instead have to ask custom converter creators who rely on context-aware pieces to passthrough data when they don't have context-specific info. Still researching...

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-01-19 14:23:43.000 UTC</summary>

I have confirmed we use custom converters without a context in places where we shouldn't such as local activity markers. We cannot move back to default converters due compatibility issues. I have opened #699 to make a note that context-aware data converters should not rely on being given a context.

</details>


---

<a id="688"></a>

### #688: Support receiver-less method refs in OnActivity mocks

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/688 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-06 15:58:17.000 UTC (4 years ago) |
| **Updated** | 2022-01-07 17:40:06.000 UTC |
| **Closed** | 2022-01-07 17:40:06.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

Problem best described in #586, but basically the incorrect `OnActivity((*myStruct).MyFunc)` in Go makes the receiver the first arg, whereas `OnActivity(new(myStruct).MyFunc)` has a receiver instance and therefore works as expected.

**Describe the solution you'd like**

Try to determine that it's a function of a method and that the receiver is the first param (i.e. param count is actual param count + 1), then remove the receiver. It is possible Go may not make this easy enough to determine reflectively and this issue may not work (sure you can check the runtime function pointer name for `-fm`, but is that enough to get the type reflectively?).

At the very least, document the behavior.


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-01-07 15:33:36.000 UTC</summary>

After investigation, I have confirmed we cannot really do anything here at runtime because we also don't support registration of activities this way (i.e. `RegisterActivity((*myStruct).MyFunc)` would not work right either). I will clarify in the docs.

</details>


---

<a id="675"></a>

### #675: Specifying StartToCloseTimeout but no ScheduleToStartTimeout or ScheduleToCloseTimeout does not return an error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/675 |
| **State** | CLOSED |
| **Author** | tminusplus (Travis) |
| **Created** | 2021-12-11 00:39:50.000 UTC (4y 1m ago) |
| **Updated** | 2023-07-31 13:09:54.000 UTC |
| **Closed** | 2023-07-31 13:09:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Executing an activity with a defined StartToCloseTimeout, an undefined ScheduleToStartTimeout, and an undefined ScheduleToCloseTimeout raises an error.

Originally, we expected the workflow to continue retrying forever - but closer reading of the docs revealed that you must set either ScheduleToStartTimeout or ScheduleToCloseTimeout [here](https://pkg.go.dev/go.temporal.io/sdk@v1.12.0/internal#ActivityOptions). The doc can be confusing, because you have to read all three timeouts to know what must be set, if I understand it correctly.

It is possible that this behavior is expected, and just not clearly defined within the docs. I tried looking in the Go SDK docs and on temporal.io. Please let me know if that is the case! The fix is easy on our side but I wanted to report a bug as the behaviour surprised us.

## Actual Behavior
Executing an activity with a defined StartToCloseTimeout, an undefined ScheduleToStartTimeout, and an undefined ScheduleToCloseTimeout does not raise an error and runs normally. Then if a WorkflowTaskTimedOut occurs, we observed this with a ScheduleToStart timeout type, the workflow task will fail and retryState will be set to `RetryPolicyNotSet`.

## Steps to Reproduce the Problem

  1. Execute a workflow with default WorkflowOptions.
  1. In that workflow, execute an activity with only StartToCloseTimeout specified in ActivityOptions.
  1. Return an error immediately within the activity task.
  1. Spam the worker with these tasks so that one times out due to ScheduleToStartTimeout.
  1. Once the workflow task times out due to ScheduleToStart, the workflow execution will fail.

## Specifications

  - Version: Temporal v1.12.3
  - Platform: Linux, Golang SDK in-between v1.11.1 and v1.12.0, basically up to this PR https://github.com/temporalio/sdk-go/pull/632

## Notes

I wanted to provide some more info on this bug, so it is easier to reproduce. I am unable to share the full workflow logs, but can share some of the non-sensitive parts.

Workflow task started with:
```
        "workflowExecutionTimeout": "0s",
        "workflowRunTimeout": "0s",
        "workflowTaskTimeout": "10s",
        "attempt": 1,
        "cronSchedule": "",
```

Activity task started with:
```
        "scheduleToCloseTimeout": "0s",
        "scheduleToStartTimeout": "0s",
        "startToCloseTimeout": "5s",
        "heartbeatTimeout": "0s",
        "retryPolicy": {
          "nonRetryableErrorTypes": [],
          "initialInterval": "1s",
          "backoffCoefficient": 2,
          "maximumInterval": "100s",
          "maximumAttempts": 0
        }
```

Activity task failed with this, which is the error I was throwing to test live failures:
```
        "lastFailure": {
          "message": "testing job failure for metrics dashboard",
          "source": "GoSDK",
          "stackTrace": "",
          "applicationFailureInfo": {
            "type": "",
            "nonRetryable": false
          },
          "failureInfo": "applicationFailureInfo"
        }
```

Workflow task scheduled as sticky:
```
      "workflowTaskScheduledEventAttributes": {
        "taskQueue": {
          ...
          "kind": "Sticky"
        },
        "startToCloseTimeout": "10s",
        "attempt": 1
      }
```

Then it timed out:
```
      "eventType": "WorkflowTaskTimedOut",
      "workflowTaskTimedOutEventAttributes": {
        "scheduledEventId": "8",
        "startedEventId": "0",
        "timeoutType": "ScheduleToStart"
      }
```

And finally, it failed:
```
      "workflowExecutionFailedEventAttributes": {
        "failure": {
          "message": "testing failure for metrics",
          "source": "GoSDK",
          "stackTrace": "",
          "applicationFailureInfo": {
            "type": "",
            "nonRetryable": false
          }
        },
        "retryState": "RetryPolicyNotSet",
      }
```

I tried root causing this, and I think it might be caused around here https://github.com/temporalio/temporal/blob/3de5687db2eda2ad8367beaff4c26e439c84f62c/service/history/commandChecker.go#L306

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-12-20 14:38:07.000 UTC</summary>

The title says:

> Specifying StartToCloseTimeout but no ScheduleToStartTimeout or ScheduleToCloseTimeout does not return an error

> It is possible that this behavior is expected, and just not clearly defined within the docs.

Definitely expected behavior (and is expected across all SDKs, as it is enforced server side). Simply: At least one of `ScheduleToCloseTimeout` or `StartToCloseTimeout` is required. From the Godoc on `ActivityOptions` you linked (other stuff left off for clarity):

```
	// Either this option or StartToClose is required: Defaults to unlimited.
	ScheduleToCloseTimeout time.Duration

	// If ScheduleToClose is not provided then this timeout is required: Defaults to the ScheduleToCloseTimeout value.
	StartToCloseTimeout time.Duration
```

This is also documented at https://docs.temporal.io/docs/go/how-to-set-activityoptions-in-go. We would be happy to make this clearer in any way you can think of. Suggestions?

</details>

<details>
<summary><strong>tminusplus</strong> commented on 2021-12-22 23:53:41.000 UTC</summary>

That makes sense, thank you for the clarification. The part that was confusing was these three comments from the godoc:
```
	// ...
	// Either this option or StartToClose is required: Defaults to unlimited.
	ScheduleToCloseTimeout time.Duration

	// ...
	// If ScheduleToClose is not provided then this timeout is required.
	// Optional: Defaults to unlimited.
	ScheduleToStartTimeout time.Duration

	// ...
	// If ScheduleToClose is not provided then this timeout is required: Defaults to the ScheduleToCloseTimeout value.
	StartToCloseTimeout time.Duration
```

It gave me the impression that if ScheduleToClose is not provided then both StartToClose and ScheduleToStart are required. Perhaps a potential improvement might be:
```
	// ...
	// If StartToClose is not provided then this timeout or ScheduleToStart are required. 
        // Defaults to unlimited.
	ScheduleToCloseTimeout time.Duration

	// ...
	// If StartToClose is not provided then this timeout or ScheduleToClose are required.
	// Optional: Defaults to unlimited.
	ScheduleToStartTimeout time.Duration

	// ...
	// If ScheduleToClose or ScheduleToStart are not provided then this timeout is required.
        // Defaults to the ScheduleToCloseTimeout value.
	StartToCloseTimeout time.Duration
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-30 20:08:55.000 UTC</summary>

```
	// If StartToClose is not provided then this timeout or ScheduleToStart are required. 
        // Defaults to unlimited.
	ScheduleToCloseTimeout time.Duration
```
I am not sure this is accurate. You must have at least one of `ScheduleToCloseTimeout` or `StartToCloseTimeout` timeout set. That requirement is unrelated to the `ScheduleToStartTimeout` requirement (at least from my reading, I may have to go confirm behavior).

</details>


---

<a id="672"></a>

### #672: Allow disabling of function name aliasing during registration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/672 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-15 20:26:47.000 UTC (4 years ago) |
| **Updated** | 2022-07-14 14:12:34.000 UTC |
| **Closed** | 2022-07-14 14:12:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Today when given a name to register workflows (and activities?) with, we also effectively register the function name _and_ we don't check for uniqueness like we do with the explicit name. So when the workflow is called by function reference, it could still suffer ambiguity.

**Describe the solution you'd like**

Add `workflow.RegisterOptions.DisableFunctionNameAlias` to disable this default aliasing (and activity too?). We can't make the disable default due to backwards-compatibility reasons.

**Describe alternatives you've considered**

We could just live with it and tell people that are registering with a string name that they have to call by string name too or we won't protect them. But this is a trivial change.

#### Comments (3)

<details>
<summary><strong>laniehei</strong> commented on 2021-12-15 20:37:17.000 UTC</summary>

maybe related? ðŸ™ƒ  https://github.com/temporalio/sdk-go/issues/425

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-12-20 22:02:30.000 UTC</summary>

After discussion, the better handling of this issue is to qualify the alias. Will probably close this and do that when this issue is tackled.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-01-06 19:26:49.000 UTC</summary>

This is also happening during test suites in surprising ways. Take this example:

```go
env.RegisterWorkflowWithOptions(somepkg.MyWorkflow, workflow.RegisterOptions{ Name: "MyCustomName" })
env.ExecuteWorkflow(someotherpkg.MyWorkflow, "foo", "bar")
```

Even though `ExecuteWorkflow` attempts implicit register, it silently ignores as expected if already registered. The `ExecuteWorkflow` actually tries to execute the registered one due to the alias which is very confusing.

</details>


---

<a id="644"></a>

### #644: Workflow panics after cancellation with clean up activity and child workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/644 |
| **State** | CLOSED |
| **Author** | nolotz (Noah-Jerome Lotzer) |
| **Created** | 2021-11-21 20:19:11.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-02 17:39:27.000 UTC |
| **Closed** | 2021-12-02 17:39:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
No panic

## Actual Behavior
If the intermediate workflow has a clean-up activity combined with a child workflow, it panics when root workflow gets canceled.

```
2021/11/21 20:05:05 ERROR Workflow panic Namespace default TaskQueue default WorkerID 1@6789789c47-xddcp@ WorkflowType MiddleWorkflow WorkflowID 19e5df4c-20ee-4800-818e-71a068512770_5 RunID d977d17c-4916-47f2-8460-d6fc18c28be9 Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 15, activityID: 14 StackTrace process event for default [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_decision_state_machine.go:395
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc0005983c0, {0xc00065ca28, 0x2}, 0x45b7954)
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_decision_state_machine.go:925 +0x10a
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc0005b0318, 0xc00039bf40, 0xf8, 0x0)
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_event_handlers.go:816 +0x279
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0003c61c0, 0xc000760960)
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_task_handlers.go:878 +0xccd
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc00071c0c0, 0xc000760960, 0xc0009302d0)
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_task_handlers.go:729 +0x493
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc0000a9520, 0xc000760960)
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_task_pollers.go:286 +0x2cd
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc0000a9520, {0xfd7b00, 0xc000760960})
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_task_pollers.go:257 +0x6c
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc0003ae0f0, {0xfd76c0, 0xc0003dbbd0})
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_worker_base.go:343 +0xdd
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
	/go/pkg/mod/go.temporal.io/sdk@v1.11.1/internal/internal_worker_base.go:270 +0xba
2021/11/21 20:05:05 WARN  Failed to process workflow task. Namespace default TaskQueue default WorkerID 1@6789789c47-xddcp@ WorkflowType MiddleWorkflow WorkflowID 19e5df4c-20ee-4800-818e-71a068512770_5 RunID d977d17c-4916-47f2-8460-d6fc18c28be9 Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 15, activityID: 14
```

## Steps to Reproduce the Problem

```
func RootWorkflow(ctx workflow.Context) error {
  info := workflow.GetInfo(ctx)

  ctx = workflow.WithChildOptions(ctx, workflow.ChildWorkflowOptions{
    TaskQueue:           info.TaskQueueName,
    WaitForCancellation: true,
    ParentClosePolicy:   enums.PARENT_CLOSE_POLICY_REQUEST_CANCEL,
  })

  err := workflow.ExecuteChildWorkflow(ctx, "IntermediateWorkflow").
    GetChildWorkflowExecution().
    Get(ctx, nil)
  if err != nil {
    return err
  }

  err = workflow.Sleep(ctx, time.Second * 30)
  if err != nil {
    return err
  }

  return errors.New("error")
}

func IntermediateWorkflow(ctx workflow.Context) error {
  info := workflow.GetInfo(ctx)
  ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
    TaskQueue:           info.TaskQueueName,
    StartToCloseTimeout: time.Second * 20,
  })
  ctx = workflow.WithChildOptions(ctx, workflow.ChildWorkflowOptions{
    TaskQueue:           info.TaskQueueName,
    WaitForCancellation: true,
    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_REQUEST_CANCEL,
  })
  cronWorkflow := workflow.ExecuteChildWorkflow(ctx, CRONWorkflow)

  defer func() {
    ctx, _ := workflow.NewDisconnectedContext(ctx)
    _ = workflow.ExecuteActivity(ctx, MiddleCleanUpActivity).Get(ctx, nil)
  }()

  var (
    err error
  )

  selector := workflow.NewSelector(ctx)
  selector.AddReceive(ctx.Done(), func(c workflow.ReceiveChannel, more bool) {
    c.Receive(ctx, nil)
    err = ctx.Err()
  })
  selector.AddFuture(cronWorkflow, func(f workflow.Future) {
    err = f.Get(ctx, nil)
  })
  selector.Select(ctx)

  return err
}

func CRONWorkflow(ctx workflow.Context) error {
  err := workflow.Sleep(ctx, time.Hour * 5)
  if err != nil {
    return err
  }

  return workflow.NewContinueAsNewError(ctx, CRONWorkflow)
}

func MiddleCleanUpActivity(ctx context.Context) error {
  return nil
}
```


## Specifications

  - Version: 1.11.1
  - Platform: 1.13.1


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-11-22 13:53:32.000 UTC</summary>

Thank you very much for the code to replicate! I am investigating immediately.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-22 14:33:18.000 UTC</summary>

I have replicated and confirmed that this was not introduced as a regression in any recent version (happens at least back through `v1.5.0`). I am doing more research into a fix.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-22 15:28:46.000 UTC</summary>

A smaller replication:

```go
func Workflow(ctx workflow.Context) error {
	// Start child but ignore future result
	workflow.ExecuteChildWorkflow(ctx, workflow.Sleep, 5*time.Hour)

	// Receive from done channel
	// XXX: This is important, waiting for child future or anything else does not trigger this
	ctx.Done().Receive(ctx, nil)

	// Run after-cancel activity
	ctx, _ = workflow.NewDisconnectedContext(ctx)
	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{StartToCloseTimeout: 5 * time.Minute})
	return workflow.ExecuteActivity(ctx, DoNothing).Get(ctx, nil)
}

func DoNothing(context.Context) error { return nil }
```

</details>


---

<a id="617"></a>

### #617: Better error message when calling activity with wrong number of parameters.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/617 |
| **State** | CLOSED |
| **Author** | finnigantime (Pat Finnigan) |
| **Created** | 2021-11-03 21:54:57.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-18 15:01:09.000 UTC |
| **Closed** | 2021-11-18 15:01:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Request: return an error when an activity is called with the wrong number of parameters

I spent awhile debugging an issue where I was calling an activity with the wrong number of parameters.

My code was:
`workflow.ExecuteActivity(activityCtx, UpdateLoadDetailsActivity, wfstate.EntityID, *params.DetailsParams)`

It should have been:
`workflow.ExecuteActivity(activityCtx, UpdateLoadDetailsActivity, *params.DetailsParams)`

I get this error:
```
Activity error.	{"Namespace": "default", "TaskQueue": "MEDIUM_PRI", "WorkerID": "8693@Patricks-MacBook-Pro.local@", "WorkflowID": "lifecycle:302-85005442966618114", "RunID": "b908c11f-f4a0-4ffd-a991-28cc9fd7e9cf", "ActivityType": "UpdateLoadDetailsActivity", "Attempt": 1, "Error": "unable to decode the activity function input payload with error: payload item 0: unable to decode: json: cannot unmarshal string into Go value of type store.UpdateLoadDetailsParams for function name: UpdateLoadDetailsActivity"}
```

The error is fine and obvious in retrospect - I passed an `EntityID` (alias for `string`) in a param that should have been a struct `UpdateLoadDetailsParams`. However, it took me awhile to see this as I was indeed passing a param of the correct type, it was just in the wrong order since I had the wrong number of params in my call.

**Describe the solution you'd like**
The request here is to return a more obvious error in this case - an error that the length of params is wrong. Note that this will be less forgiving than current behavior in the case when you call an activity with too many params and the types of the accepted params match - currently no error is thrown, the extra params are just ignored.

**Describe alternatives you've considered**
leave as-is

**Additional context**
-

#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-11-03 21:59:14.000 UTC</summary>

To clarify, is the suggestion that instead of reporting the first item (i.e. "item 0") is the wrong type, first do a param count check and report parameter count mismatch before trying to decode each one?

</details>

<details>
<summary><strong>finnigantime</strong> commented on 2021-11-03 22:00:05.000 UTC</summary>

Yes, that's exactly correct.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-16 16:32:36.000 UTC</summary>

@finnigantime - After digging, I have determined that we don't actually require that you have the exact parameter count. Any parameter you don't provide will be given the zero value. Therefore fewer parameters are allowed. The error about it being the wrong type is the correct one.

</details>


---

<a id="609"></a>

### #609: Test activities with same name on different queues (run from the same workflow)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/609 |
| **State** | CLOSED |
| **Author** | lunne (Mathias Ehrlin) |
| **Created** | 2021-10-27 15:33:23.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-16 18:52:12.000 UTC |
| **Closed** | 2021-11-16 18:52:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to test activities with the same name (different signature) on different task queues.

**Describe the solution you'd like**
Set what task queue the activity is being triggered on. If we could specify the task queue or something like that on the mock `.On()` we could keep the domain specific names for the acitivites.

**Describe alternatives you've considered**
The other option we have is to rename activities on the different services so they dont have the same name. this would cause us a pattern like this:

car.GetCarById() 

insetad of 
car.GetById() 


**Additional context**
The following is a test that represent how the error is being triggered today. 

```
// main.go
package main

import (
	"context"

	"go.temporal.io/sdk/workflow"
)

type GetCarByIdParams struct{}
type Car struct{}
type activitiesCar struct{}

func (a *activitiesCar) GetById(ctx context.Context, params *GetCarByIdParams) (*Car, error) {
	return &Car{}, nil
}

type GetBussByIdParams struct{}
type Buss struct{}
type activitiesBuss struct{}

func (a *activitiesBuss) GetById(ctx context.Context, params *GetBussByIdParams) (*Buss, error) {
	return &Buss{}, nil
}

var actCar *activitiesCar
var actBuss *activitiesBuss

func TestWorkflow(ctx workflow.Context) error {

	// get a car

	opt := workflow.ActivityOptions{
		TaskQueue: "temporal.Car.worker",
	}
	var car *Car
	if err := workflow.ExecuteActivity(
		workflow.WithActivityOptions(ctx, opt),
		ctx,
		actCar.GetById,
		&GetCarByIdParams{},
	).Get(ctx, car); err != nil {
		return err
	}

	opt = workflow.ActivityOptions{
		TaskQueue: "temporal.Buss.worker",
	}
	var buss *Buss
	if err := workflow.ExecuteActivity(
		workflow.WithActivityOptions(ctx, opt),
		actBuss.GetById,
		&GetBussByIdParams{},
	).Get(ctx, buss); err != nil {
		return err
	}

	return nil
}

```

```
//main_test.go
package main

import (
	"testing"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/testsuite"
)

type UnitTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite

	env *testsuite.TestWorkflowEnvironment
}

func (s *UnitTestSuite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()

	s.env.RegisterWorkflow(TestWorkflow)

}

func (s *UnitTestSuite) AfterTest(suiteName, testName string) {
	s.env.AssertExpectations(s.T())
}

func Test_NetworkService_Workflow_Tests(t *testing.T) {
	suite.Run(t, new(UnitTestSuite))
}

func (t *UnitTestSuite) Test_TestWorkflow() {

	t.env.OnActivity(actBuss.GetById, mock.Anything, &GetBussByIdParams{}).Return(&Buss{}, nil).Once()
	t.env.OnActivity(actCar.GetById, mock.Anything, &GetCarByIdParams{}).Return(&Car{}, nil).Once()

	t.env.ExecuteWorkflow(TestWorkflow)

	t.True(t.env.IsWorkflowCompleted())
	t.NoError(t.env.GetWorkflowError())
}

```


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-11-01 13:45:36.000 UTC</summary>

Thanks for the report! I will investigate options on how to mock activities specifically by task queue.

In the meantime, another alternative is to just have a callback that checks the info like:

```go
t.env.OnActivity("GetById", mock.Anything, mock.Anything).Return(func(ctx context.Context, params interface{}) (interface{}, error) {
  if activity.GetInfo(ctx).TaskQueue == "temporal.Car.worker" {
    return &Car{}, nil
  }
  return &Buss{}, nil
})
```

I haven't tested this, just hand-typed here, but the idea is there (will have to confirm whether empty interface param/return there works as expected). Granted this isn't as robust as potentially making a way to filter mocks on contextual information, so I will see if it is feasible to add such filtering.

For UI and other use cases, disambiguating the activity name may also have general value.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>lunne</strong> commented on 2021-11-05 17:25:53.000 UTC</summary>

The proposed solution does not work. The mock needs too done with the correct signature.

Yes, you are correct. In the UI it will be more clear if the resource is included in the name. Were are going in a direction where we rename the activities as we go instead. GetById will become GetCarById  and so on. 

So for our part this ticket could be closed but it might still be good to be able to select which queue tasks are being put on to test that activities is run on the correct queue?


</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-16 18:52:11.000 UTC</summary>

Yeah, I'm afraid `TestWorkflowEnvironment.OnActivity` for a single environment is similar to `Worker.RegisterActivity` for a single worker in that you cannot pick which task queue it each one applies to. This actually calls `RegisterActivity` internally which does not take a task queue option.

It would be a significant change I'm afraid to have task-queue specific registration and mocking inside the test suite.

</details>


---

<a id="604"></a>

### #604: WorkflowRun.Get method should support a flag to disable long poll

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/604 |
| **State** | CLOSED |
| **Author** | sbansal7 (Sachin Bansal) |
| **Created** | 2021-10-27 00:51:56.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-18 15:05:10.000 UTC |
| **Closed** | 2021-11-18 15:05:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, To get the result of a workflow, we can call WorkflowRun.Get(), but this is a blocking call that does a long poll for the workflow to finish. 

**Describe the solution you'd like**
It will be useful to add a flag in this method (or define a new method) that does not do long poll and instead returns immediately if the workflow is still running.

**Describe alternatives you've considered**
An alternative is to use a lower timeout to the Get call, but that might be a problem if network is slower. 




#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-11-02 17:00:06.000 UTC</summary>

As another alternative, you can call `Client.DescribeWorkflowExecution` until the status is no longer running then call `Get`. Is this acceptable? Internally, this is basically all a non-blocking `Get` (e.g. a `TryGet` or `GetAsync`) would do internally.

</details>

<details>
<summary><strong>sbansal7</strong> commented on 2021-11-04 16:41:08.000 UTC</summary>

Yes, that is what I am using as a workaround for now. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:05:10.000 UTC</summary>

It was decided that, with this workaround, this is not worth adding a call to the `WorkflowRun` interface at this time. Such a call would be the same as this workaround anyways.

</details>


---

<a id="602"></a>

### #602: Support OpenTelemetry tracing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/602 |
| **State** | CLOSED |
| **Author** | avarabyeu (Andrei Varabyeu) |
| **Created** | 2021-10-26 13:12:04.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-15 17:52:25.000 UTC |
| **Closed** | 2021-11-15 17:52:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, Temporal SDK supports OpenTracing which is now reported to be superseded by OpenTelemetry

**Describe the solution you'd like**
OpenTracing API needs to be replaced with OpenTelemetry API. 

**Describe alternatives you've considered**
Using OpenTracing created out of OpenTelemetry bridge does not work properly, probably due to some context propagation-related issues.


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-10-26 13:21:21.000 UTC</summary>

This is under active development as part of #529 and https://github.com/temporalio/proposals/pull/45.

</details>

<details>
<summary><strong>avarabyeu</strong> commented on 2021-10-26 14:47:36.000 UTC</summary>

Great news! Thank you for the update @cretz. Should i close this one?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-10-26 15:08:44.000 UTC</summary>

If you'd like, or we can leave it open until OpenTelemetry support lands

Reactions: ðŸ‘ 1

</details>


---

<a id="569"></a>

### #569: Dynamically adjusting MaxConcurrentActivityExecutionSize without restarting a worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/569 |
| **State** | CLOSED |
| **Author** | pattersp (Pascale Patterson) |
| **Created** | 2021-10-01 18:21:39.000 UTC (4y 3m ago) |
| **Updated** | 2024-11-19 18:55:06.000 UTC |
| **Closed** | 2024-11-19 18:55:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement, next-gen |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Not related to problem, just a feature that would be nice to have. Currently, it is possible to set MaxConcurrentActivityExecutionSize when starting a worker. It would nice to be able to dynamically adjust this value without restarting the worker.

**Describe the solution you'd like**
Without restarting a worker, I would like to be able to adjust the value of MaxConcurrentActivityExecutionSize.

If the value is decreased and the worker is subsequently executing a number of activities that exceeds the threshold, that is fine -- it can be more of an "eventual" threshold.

**Describe alternatives you've considered**
As a workaround solution, we could restart the worker to reset MaxConcurrentActivityExecutionSize, but that's a lot of overhead.

**Additional context**
See https://community.temporal.io/t/dynamically-adjusting-the-number-of-concurrent-activities-on-a-given-worker/3052


#### Comments (3)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:31:16.000 UTC</summary>

At this time, dynamically adjusting such a value is incredibly difficult on the internals due to how pool-transfer would have to work. I'm afraid the current best way to increase the size is to start a new worker.

I am leaving this issue opened to potentially solve in our next iteration of the SDK where the internals may be replaced by a different core and make such a task easier.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-06-07 12:54:23.000 UTC</summary>

Rethinking this a bit, we could basically expose `pollerRequestCh`, but we also have to allow control over task completion and get a slot count for metrics. I think we could have this interface:

```go
type SlotLimiter interface {
    AcquireSlot()
    ReleaseSlot()
    AvailableSlots() int
}
```

Then have a default slot limiter that uses today's approach (fixed max concurrent), and have advanced worker options for `ActivityTaskSlotLimiter SlotLimiter` and `WorkflowTaskSlotLimiter SlotLimiter`.

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2024-11-19 18:55:06.000 UTC</summary>

This was done as of https://github.com/temporalio/sdk-go/pull/1546 with the new `WorkerTuner` and `SlotSupplier` interfaces

</details>


---

<a id="515"></a>

### #515: Add Signal/Query interceptors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/515 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-08-13 04:46:53.000 UTC (4y 5m ago) |
| **Updated** | 2021-09-02 17:54:04.000 UTC |
| **Closed** | 2021-09-02 17:54:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

One of our users has [recently noticed](https://community.temporal.io/t/fine-grained-authorization/2646/6) that we don't have Query/Signal interceptors.

We should address this [TODO](https://github.com/temporalio/sdk-go/blob/c7aae265b40d85663431281d5959e0c61dbb58eb/internal/interceptors.go#L56) and add interceptors for Signal/Query.


#### Comments (3)

<details>
<summary><strong>vitarb</strong> commented on 2021-08-16 17:12:42.000 UTC</summary>

We should be able to support open tracing for all calls, headers should be available on API calls too.
Discuss with @Spikhalskiy who has a lot of context in java.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-08-16 17:20:44.000 UTC</summary>

Need to make sure that headers are passed on the server for signal/query. Split this task into workflow/activity and signal/query which would be implemented slightly differently.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-08-30 04:59:18.000 UTC</summary>

I'm going to keep this issue focused on Signal/Query as it's more specific.

</details>


---

<a id="488"></a>

### #488: data race in dispatcherImpl.ExecuteUntilAllBlocked

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/488 |
| **State** | CLOSED |
| **Author** | ryanhall07 (Ryan Hall) |
| **Created** | 2021-07-15 18:05:53.000 UTC (4y 5m ago) |
| **Updated** | 2021-07-21 01:12:47.000 UTC |
| **Closed** | 2021-07-21 01:11:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

We are seeing random flakes in our temporal workflow tests due to data races. The data race dumps are a little tough to read because it's missing the Previous Read stacktrace.

```
WARNING: DATA RACE

Write at 0x00c0005100d0 by goroutine 11:

  go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked.func1()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:956 +0x3e

  runtime.call32()

      /var/lib/buildkite-agent/.gimme/versions/go1.15.8.linux.amd64/src/runtime/asm_amd64.s:540 +0x3d

  go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:968 +0x4e4

  go.temporal.io/sdk/internal.executeDispatcher()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:566 +0xe1

  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:539 +0xa4

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).startWorkflowTask()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:638 +0x8f6

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).handleActivityResult()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:1480 +0x853

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).ExecuteActivity.func1.1.1()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:1088 +0x158

  go.temporal.io/sdk/internal.(*testCallbackHandle).processCallback()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:718 +0x11e

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).startMainLoop()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:672 +0x3e8

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:501 +0x404

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflow()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:445 +0x1e4

  go.temporal.io/sdk/internal.(*TestWorkflowEnvironment).ExecuteWorkflow()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/workflow_testsuite.go:495 +0x1d8

Previous read at 0x00c0005100d0 by goroutine 21:

  [failed to restore the stack

Goroutine 21 (running) created at:

  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:920 +0x404

  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:298 +0x93

  go.temporal.io/sdk/internal.newDispatcher()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:558 +0x19d

  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow.go:478 +0x22b

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal.func1()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:479 +0xfc

  go.temporal.io/sdk/internal.(*testCallbackHandle).processCallback()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:718 +0x11e

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).startMainLoop()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:661 +0x1ab

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:501 +0x404

  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflow()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/internal_workflow_testsuite.go:445 +0x1e4

  go.temporal.io/sdk/internal.(*TestWorkflowEnvironment).ExecuteWorkflow()

      /var/lib/buildkite-agent/go/pkg/mod/go.temporal.io/sdk@v1.8.0/internal/workflow_testsuite.go:495 +0x1d8
```

My theory is the new goroutine spawned by [NewCoroutine](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow.go#L920) (goroutine 21 above) is reading  the `executing` state, probably via `IsExecuting()`. goroutine 11 is updating `executing` without a lock in the [defer statement](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow.go#L956).



## Specifications

  - Version: 1.8
  - Platform: go sdk


#### Comments (3)

<details>
<summary><strong>vitarb</strong> commented on 2021-07-20 06:42:24.000 UTC</summary>

If you have a test that has a chance to cause this issue, would you be able to share it  with us?
One thing we can try is blindly adding locking into defer statement you've mentioned above, but I afraid it might be insufficient.
Meanwhile I'm trying to find a reliable way to reproduce this problem.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-07-20 22:57:56.000 UTC</summary>

I've found reliable repro:
```
func TestDataRace(t *testing.T) {
	done := false
	d := createNewDispatcher(func(ctx Context) {
		_ = Await(ctx, func() bool {
			time.Sleep(defaultDeadlockDetectionTimeout)
			return done
		})
	})
	err := d.ExecuteUntilAllBlocked(defaultDeadlockDetectionTimeout)
	require.NoError(t, err)
	d.Close()
}
```
It looks like race condition happens when deadlock detector and await/coroutine completion are happening at the same time.
```
WARNING: DATA RACE
Write at 0x00c00010ec60 by goroutine 7:
  go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked.func1()
      /home/vit/projects/go-sdk/internal/internal_workflow.go:956 +0x3e
  runtime.call16()
      /usr/lib/go/src/runtime/asm_amd64.s:550 +0x3d
  go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked()
      /home/vit/projects/go-sdk/internal/internal_workflow.go:968 +0x4f3
  go.temporal.io/sdk/internal.TestDataRace()
      /home/vit/projects/go-sdk/internal/internal_coroutines_test.go:765 +0xab
  testing.tRunner()
      /usr/lib/go/src/testing/testing.go:1193 +0x202

Previous read at 0x00c00010ec60 by goroutine 8:
  go.temporal.io/sdk/internal.(*dispatcherImpl).IsExecuting()
      /home/vit/projects/go-sdk/internal/internal_workflow.go:999 +0xad
  go.temporal.io/sdk/internal.getState()
      /home/vit/projects/go-sdk/internal/internal_workflow.go:596 +0x82
  go.temporal.io/sdk/internal.Await()
      /home/vit/projects/go-sdk/internal/workflow.go:282 +0x6d
  go.temporal.io/sdk/internal.TestDataRace.func1()
      /home/vit/projects/go-sdk/internal/internal_coroutines_test.go:760 +0x78
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /home/vit/projects/go-sdk/internal/internal_workflow.go:929 +0x11c
```

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-07-21 01:12:47.000 UTC</summary>

Above fix *should* address the issue. We plan to make a release soon, let us know/reopen if you keep seeing this after upgrading.

</details>


---

<a id="458"></a>

### #458: TestWorkflowEnvironment: Fail RegisterDelayedCallback after ExecuteWorkflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/458 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-06-09 00:57:16.000 UTC (4y 7m ago) |
| **Updated** | 2021-11-16 16:13:25.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
It is a mistake to register a delayed callback after calling ExecuteWorkflow. But some users do it and it is hard to troubleshoot.

**Describe the solution you'd like**
Panic on RegisterDelayedCallback after ExecuteWorkflow was called.



#### Comments (1)

<details>
<summary><strong>embano1</strong> commented on 2021-11-16 16:13:25.000 UTC</summary>

+1 just ran into the same issue and spent 1h troubleshooting. Definitely user issue, but was hard to debug and `panic` would be neat.

Reactions: ðŸ‘ 1

</details>


---

<a id="456"></a>

### #456: How to return `[]*proto.Message` from an activity?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/456 |
| **State** | CLOSED |
| **Author** | johanforssell (Johan Forssell) |
| **Created** | 2021-06-03 11:38:04.000 UTC (4y 7m ago) |
| **Updated** | 2023-08-24 18:53:07.000 UTC |
| **Closed** | 2023-08-24 18:53:07.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | question, potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

I'm thinking that I've missed something important in dealing with Protobuffers, rather than how Temporal works. 
I just want to hear if anybody here knows of this issue.

## Expected Behavior
```
events := make([]*pb.SparkpostEvent, 0)
workflow.ExecuteActivity(context, (*activities.Activities).Unmarshal, data).Get(context, &events)
```
**events** should now be a slice of *pb.SparkpostEvent, with all levels of protobuf messages below it
Like so: 
```
[
  SparkpostEvent { 
    Msys { 
      track_event { ... } 
    } 
  }, 
  SparkpostEvent{...}, 
  ...
]
```

## Actual Behavior
The events slice contains all the root level protobuffers but the children are missing.

I have an array of **SparkpostEvents**, but **Msys** is just nil.

## Steps to Reproduce the Problem

  1. Create a protobuffer message a couple of levels deep
  1. Return an array of them from `.Get()`

## Specifications

  - Version:	
      - go.temporal.io/api v1.4.1-0.20210429213054-a9a257b5cf16
      - go.temporal.io/sdk v1.6.0
  - Platform: M1 Mac


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-08-24 18:53:07.000 UTC</summary>

Closing old issue. Lists are converted via a different converter than proto. A pointer to a proto message interface may not be JSON serializable. Use full proto message or JSON serializable types in list if needed.

</details>


---

<a id="435"></a>

### #435: Workflow panic due to potential deadlock detected when many goroutines are running

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/435 |
| **State** | CLOSED |
| **Author** | bradleymcallister97 (Bradley McAllister) |
| **Created** | 2021-05-07 15:51:41.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-28 04:10:52.000 UTC |
| **Closed** | 2021-05-28 04:10:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When we add a large load on our temporal workflows we started to get `Workflow panic` errors with the description:
```
Potential deadlock detected: workflow goroutine "root" didn't yield for over a second
```
After some investigation, we determined that this issue was related to the number of goroutines a service had open. In order to mitigate the issue we set the `MaxConcurrentWorkflowTaskExecutionSize` and `MaxConcurrentActivityExecutionSize` on our temporal workers. The default value for each of these values is `1k`. We had to significantly lower this value to prevent the panic from occurring.

**Describe the solution you'd like**
We would like to be able to increase the `MaxConcurrentWorkflowTaskExecutionSize` and `MaxConcurrentActivityExecutionSize` values so that our service can complete activities and workflows quicker.

Currently, the default value is `1 sec`, it would be great to be able to make the deadlock timeout value configurable so that we can tweak the value on our end. We also see that there is an env var `TEMPORAL_DEBUG` which can be set to make the deadlock timeout value very large, however, this only seems like a workaround as opposed to a more permanent solution.


#### Comments (3)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-10 07:17:04.000 UTC</summary>

There was a similar request on the java sdk side, where users want to have ability to redefine this timeout. I think we should add a worker option to allow that. For now if you need a quick relief, you may set `TEMPORAL_DEBUG` environment variable, which would disable deadlock detection feature. However, we do not recommend doing this in production as deadlock detection is a useful feature that helps finding bugs in the workflow code. Also `TEMPORAL_DEBUG` is a test specific flag that may enable/disable more feature in the future, so I would be extra careful with that.
Slightly orthogonal question, why is it not sufficient for you to find the right value for MaxConcurrentX? That avoids overloading the machine, if there is a more than 1 sec processing backlog in go routines then you are probably not getting extra throughput from that added concurrency.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-05-10 18:05:25.000 UTC</summary>

> We would like to be able to increase the MaxConcurrentWorkflowTaskExecutionSize and MaxConcurrentActivityExecutionSize values so that our service can complete activities and workflows quicker.

Deadlock detector fires when a goroutine cannot get scheduled for execution for one second. It means that that your process is significantly overloaded and making it even more loaded is going to increase latency of processing and not make anything complete quicker.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-05-28 04:10:35.000 UTC</summary>

Looks like question has been resolved. Note that we are considering making `1 sec` timeout configurable in the future.

</details>


---

<a id="432"></a>

### #432: JSON Serialization Errors From Activity Responses Fail Silently

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/432 |
| **State** | CLOSED |
| **Author** | DannyHinshaw (Danny Hinshaw) |
| **Created** | 2021-05-06 18:41:01.000 UTC (4y 8m ago) |
| **Updated** | 2021-06-15 04:29:31.000 UTC |
| **Closed** | 2021-06-15 04:29:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior

When an Activity tries to return a non-serializable type (such as an `error`), an error should be presented in the worker logs.

## Actual Behavior

Currently the error is not output to logs, however it is possible to discover the issue by visiting the Temporal web app and inspect the Workflow execution history.

## Steps to Reproduce the Problem

  1. Return a struct with an `error` type attached to it from an Activity (make sure the response is an error and not `nil`).
  1. See the Workflow fails
  1. See there is no logging output in the worker logs.
  
  If you wish, I made a repo with a branch to repro this issue here: https://github.com/DannyHinshaw/go-temporal-sandbox/tree/issue/bad-json-silent-failure
  You can clone that, run `docker-compose up -d` and then hit the endpoint `GET http://localhost:8080/workflow` to trigger a workflow that shows the issue. From there you can inspect the system logs and Temporal web app.

#### Comments (3)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-10 07:23:52.000 UTC</summary>

Thanks for reporting this issue, failing silently definitely doesn't sound right, we'll take a look at it!

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-06-11 00:05:52.000 UTC</summary>

I've debugged this a bit and it looks like the problem is with default json converter, that returns no error if you marshal a struct with an error field into json, but then fails to unmarshal it back. This happens because error is an interface and serializer ends up having this confusing behavior.

Consider following test code (passes):
```

	pc := NewJSONPayloadConverter()

	wt := testStructWithError{Name: "qwe", Error: errors.New("some error")}
	payload, err := pc.ToPayload(wt)
	require.NoError(t, err) // Should this be an error since it's impossible to deserialize?

	var deserialized testStructWithError
	err = pc.FromPayload(payload, &deserialized)
	require.Error(t, err)
	assert.Equal(t, "unable to decode: json: cannot unmarshal object into Go struct field testStructWithError.Error of type error", err.Error())
```

Serialized data in this case would be:
`{"Name":"qwe","Error":{}}`

The reason why this doesn't produce any message when you complete an activity is because underlying json serializer succeeds and we successfully send bytes back to the server, and we get a failure only when we try to process subsequent workflow task, which fails to deserialize the payload. I'm not sure if there is a good general solution to this issue, I want to understand if this is considered a bug in the json serializer's behavior.

You may read through [this article](http://gregtrowbridge.com/golang-json-serialization-with-interfaces/) which provides some details about how to handle json serialization with interfaces (you may need to create your own type and define Marshal/Unmarshall Json functions).

I don't know why authors of the json serializer decided that this behavior is optimal, but it doesn't look like something that we would be able to change. 

We should also consider making [our documentation](https://docs.temporal.io/docs/go/activities#implementation) more clear about this case.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-06-15 04:29:31.000 UTC</summary>

I'm going to resolve this issue for now, please reopen if you have more questions or find response unsatisfactory.

</details>


---

<a id="424"></a>

### #424: Invocation of struct local activities is broken.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/424 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-04-30 17:16:22.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-12 18:42:50.000 UTC |
| **Closed** | 2021-05-12 18:42:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior
```go
	var a *Activities

	var greetResult string
	err := workflow.ExecuteLocalActivity(ctx, a.GetGreeting).Get(ctx, &greetResult)
```
should work the same way it works for normal activities.

## Actual Behavior
```
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x10 pc=0x18d07a4]

goroutine 70 [running]:
github.com/temporalio/samples-go/greetings.(*Activities).GetGreeting(...)
        /Users/maxim/temporal/temporal-go-samples/greetings/activities.go:17
reflect.Value.call(0x19454c0, 0xc000165910, 0x13, 0x1a72c0b, 0x4, 0x0, 0x0, 0x0, 0x203000, 0x203000, ...)
        /usr/local/go/src/reflect/value.go:476 +0x8c7
reflect.Value.Call(0x19454c0, 0xc000165910, 0x13, 0x0, 0x0, 0x0, 0x100f5f0, 0xc000588790, 0x10)
        /usr/local/go/src/reflect/value.go:337 +0xb9
go.temporal.io/sdk/internal.(*activityExecutor).executeWithActualArgsWithoutParseResult(0xc0005c2720, 0x1b801c0, 0xc000598ae0, 0x0, 0x0, 0x0, 0xc0005c09c0, 0x1b801c0, 0xc000598ae0)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_worker.go:830 +0x24a
go.temporal.io/sdk/internal.(*activityExecutor).ExecuteWithActualArgs(0xc0005c2720, 0x1b801c0, 0xc000598ae0, 0x0, 0x0, 0x0, 0x20a66c0, 0x202c7a9, 0xb)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_worker.go:804 +0x70
go.temporal.io/sdk/internal.(*localActivityTaskHandler).executeLocalActivityTask.func2(0x1b801c0, 0xc000598ae0, 0xc0004340e0, 0xc0005aaf00, 0xc0005c2720, 0xc00058c0d0, 0xc000588770, 0x1b88180, 0xc0005a2600, 0x2540be400, ...)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_task_pollers.go:563 +0x185
created by go.temporal.io/sdk/internal.(*localActivityTaskHandler).executeLocalActivityTask
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.6.0/internal/internal_task_pollers.go:559 +0xa45

Process finished with the exit code 2
```


## Steps to Reproduce the Problem

Take the greetings sample and change it to use local activities instead of the normal ones.



#### Comments (3)

<details>
<summary><strong>Sushisource</strong> commented on 2021-05-04 23:10:31.000 UTC</summary>

Looks like https://github.com/temporalio/sdk-go/issues/405

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-05-04 23:58:21.000 UTC</summary>

@mfateev I don't think this can be fixed without a pretty big change in how local activities work. The problem seems to be if you pass a "method value" like `a.GetGreeting` there is no way to use reflection or anything else to access the receiver pointer, so we can't check that it's nil and assign it to a default (which still strikes me as a weird thing to do anyway).

We could instead look up the function name, and see if the activity struct has been registered and call it that way, but the problem is since we only know that a function was passed in, and we can't know about the receiver, the function looks valid and like we should try to call it rather than look it up in the registry, at which point it's too late.

So, I think we should just advise people to either initialize structs if they call this way (easiest by far), or to not do this at all, and instead call by string.

Technically we could also allow calling by "method expression", like `(*Activities).GetGreeting` but... not sure anyone cares.

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-05-12 18:42:50.000 UTC</summary>

Should be fixed by #436 

</details>


---

<a id="336"></a>

### #336: Don't Require mock.Anything For context.Context Activity Parameter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/336 |
| **State** | CLOSED |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2021-01-12 19:01:03.000 UTC (4y 12m ago) |
| **Updated** | 2025-09-26 21:52:00.000 UTC |
| **Closed** | 2025-09-26 21:52:00.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
When executing activities, I believe context.Context can be omitted as an argument since thatâ€™s propagated. However, when mocking activities - it appears that it is required to pass in mock.Anything. Failure to do so results in a mismatched mock of the registered activities.

**Describe the solution you'd like**
It would be nice to not have to pass in mock.Anything for the context argument.

**Describe alternatives you've considered**
This might block someone from using context.Context as a mock argument. Not sure if this is a supported use case atm.

**Additional context**
https://community.temporal.io/t/testing-dont-require-mock-anything-for-context-context-parameter/1291


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-26 21:52:00.000 UTC</summary>

`context.Context` is a totally argument to mock , In general mock libraries require mock signature to match what is being mocked, seems confusing and error prone to allow a mismatch just for `context.Context` because some users may not mock it.

</details>


---

<a id="175"></a>

### #175: NewNonRetryableApplicationError not respected by 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/175 |
| **State** | CLOSED |
| **Author** | moh-abk (Mohammed Abubakar) |
| **Created** | 2020-06-29 15:17:59.000 UTC (5y 6m ago) |
| **Updated** | 2020-07-01 04:04:28.000 UTC |
| **Closed** | 2020-07-01 04:04:28.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | alexshtin |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

Regardless of what is set in `temporal.RetryPolicy`, `NewNonRetryableApplicationError` should not be retried 


## Actual Behavior

`NewNonRetryableApplicationError` returned by activities are still being retried.

## Steps to Reproduce the Problem

  1. Create a workflow with `RetryPolicy: &temporal.RetryPolicy{}`
  1. Create an activity that returns `temporal.NewNonRetryableApplicationError`
  1. Execute the workflow

## Specifications

  - Version: v0.26.0


#### Comments (1)

<details>
<summary><strong>moh-abk</strong> commented on 2020-06-29 23:00:55.000 UTC</summary>

After much investigation it seems adding an `error` (cause) to `NewNonRetryableApplicationError` (https://github.com/temporalio/temporal-go-sdk/blob/master/error.go#L165) - is what is causing the issue

to get the desired outcome I had to do this;

`temporal.NewNonRetryableApplicationError("random string", nil, "random string")`

passing an error like below doesnâ€™t work;

`temporal.NewNonRetryableApplicationError("random string", err, "random string")`

forked repo here - https://github.com/moh-abk/temporal-go-samples/tree/non-retry-testing

</details>


---

<a id="164"></a>

### #164: mocks.Client is broken

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/164 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-06-19 15:10:12.000 UTC (5y 6m ago) |
| **Updated** | 2020-06-19 20:36:57.000 UTC |
| **Closed** | 2020-06-19 20:36:57.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | potential-bug |
| **Assignees** | alexshtin |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
mocks.Client can be used to mock client.Client. 

## Actual Behavior
mocks.Client doesn't implement client.Client interface.

## Steps to Reproduce the Problem
modify Test_MockClient to make API calls through client.Client interface.


#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2020-06-19 16:43:02.000 UTC</summary>

This is odd, we have tests for mocks. I am checking mock and tests.

</details>


---

<a id="126"></a>

### #126: Add autoheartbeating of activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/126 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-11 15:20:46.000 UTC (5y 8m ago) |
| **Updated** | 2022-10-31 12:30:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸŽ‰ 9 |

#### Description

From Slack:

> wdyt about some sort of autoheartbeating? it would be very nice to not have to implement heartbeating in long-running activities where the ~only reason to implement heartbeating is to know whether a worker is alive or not. 

#### Comments (3)

<details>
<summary><strong>sevein</strong> commented on 2021-09-02 16:26:36.000 UTC</summary>

For the record, this option was added to Cadence's client in https://github.com/uber-go/cadence-client/pull/1053.
replayWorkflowActivity was updated in https://github.com/uber-go/cadence-client/pull/1088.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Sunkwan-Kwon</strong> commented on 2022-10-31 05:46:06.000 UTC</summary>

Hello. Temporal team.

Do you have a plan to merge the PR related with this issue?

I'm trying to migrate Cadence worker codes to Temporal, and the auto-heartbeat feature was useful while I'm using Cadence but it is not supported by Temporal yet. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-10-31 12:30:12.000 UTC</summary>

There are a lot of ways to auto heartbeat and no one size fits all. Here's a simple version: https://community.temporal.io/t/why-doesnt-the-sdk-go-have-enableautoheartbeat/6340/2. If this solves your needs maybe we can put in a sample.

</details>


---

<a id="39"></a>

### #39: Change client.NewClient signature

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/39 |
| **State** | CLOSED |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-02-25 18:15:51.000 UTC (5y 10m ago) |
| **Updated** | 2020-03-16 20:42:55.000 UTC |
| **Closed** | 2020-03-16 20:42:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

Currently we have only [one way](https://github.com/temporalio/temporal-go-client/blob/master/client/client.go#L402) to construct go client:
```
func NewClient(service workflowservice.WorkflowServiceClient, domain string, options *Options) Client
```
And every caller (customer code) has to do something like [this](https://github.com/temporalio/temporal-go-samples/blob/master/cmd/samples/common/factory.go#L92):
```
	connection, err := grpc.Dial(hostPort, grpc.WithInsecure())
	if err != nil {
		// log error
	}

	client := client.NewClient(workflowservice.NewWorkflowServiceClient(connection, "domain", options))
```
This is overwhelming and requires deep understanding of go-client internals. Also, now I need to add mandatory interceptors (for error conversion, metrics, and client version headers) and configure default round robin load balancing, which can be done only using `grpc.DialOptions`.

The proposal is to change `NewClient` signature to:
```
func  NewClient(hostPort, domain string, options *Options) Client
```
and add `GRPCOptions []grpc.DialOptions` to [Options](https://github.com/temporalio/temporal-go-client/blob/master/internal/client.go#L323).

Internally `NewClient` will merge passed `GRPCOptions` with default mandatory ones. This will keep same extensibility level, hide complexity, and set reasonable defaults.

#### Comments (3)

<details>
<summary><strong>mfateev</strong> commented on 2020-02-25 18:35:55.000 UTC</summary>

I propose to have three separate methods (naming is open for discussion):
```
NewClientLocal(domain string) Client
NewClientByAddress(hostPort, domain string, options *Options) Client
NewClientFromGRPC(service workflowservice.WorkflowServiceClient, domain string, options *Options) Client
```


</details>

<details>
<summary><strong>alexshtin</strong> commented on 2020-02-25 18:40:03.000 UTC</summary>

Replace `status` with `serviceerror` everywhere in go-client tests and [here](https://github.com/temporalio/temporal/blob/master/tools/cli/app_test.go) after implementation.

</details>

<details>
<summary><strong>alexshtin</strong> commented on 2020-02-25 18:49:40.000 UTC</summary>

We can't continue to support this:
```
NewClientFromGRPC(service workflowservice.WorkflowServiceClient, domain string, options *Options) Client
```
because there is no way to add interceptors when you have only client interface and not a connection itself. Actually they can not be even added to existing connection, therefore connection needs to be created internally.

Honestly, I don't see why we we might need to pass `workflowservice.WorkflowServiceClient`. There is no way to create it besides one single constructor which accepts only connection. And the only way to customize connection creation is to pass `grpc.DialOptions`.



</details>


---

<a id="2131"></a>

### #2131: Configurable minRPCTimeout for activity worker instead of using MaxHeartbeatThrottleInterval for RPC timeout. And allow retry manually when network error..

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2131 |
| **State** | OPEN |
| **Author** | ganlvtech (Ganlv) |
| **Created** | 2025-12-08 10:41:26.000 UTC (1 months ago) |
| **Updated** | 2025-12-19 02:18:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

My activity has a 300s timeout. The activity worker sends a heartbeat every 5s, and I can wait up to 30s for each heartbeat RPC to complete. Even if a heartbeat fails, I can retry up to 10 times before hitting the 300s timeout.

I set `MaxHeartbeatThrottleInterval = time.Duration(1)` to prevent heartbeat throttling, but this forces every heartbeat RPC to complete within 1s.

Related issues and PRs https://github.com/temporalio/sdk-go/pull/660 https://github.com/temporalio/sdk-go/issues/859 https://github.com/temporalio/sdk-go/pull/863

https://github.com/temporalio/sdk-go/blob/13ff29d79d5345c30f3e4109c0f94b737a19ad7a/internal/worker.go#L278-L283

> no pending heartbeat will wait longer than this amount of time to send

https://github.com/temporalio/sdk-go/blob/13ff29d79d5345c30f3e4109c0f94b737a19ad7a/internal/internal_task_handlers.go#L2154-L2162

And `Error: context deadline exceeded` will cause `isActivityCanceled = true` and cancel the activity's context. I cannot retry heartbeat manually.

https://github.com/temporalio/sdk-go/blob/13ff29d79d5345c30f3e4109c0f94b737a19ad7a/internal/internal_task_handlers.go#L2180-L2201

**Describe the solution you'd like**
Configurable `minRPCTimeout` for activity worker. Allow retry heartbeat on network error.

**Describe alternatives you've considered**
I have try to set `MaxHeartbeatThrottleInterval` to longer than my network ping. Yes, it works. But not expected.

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-18 23:01:32.000 UTC</summary>

Can you clarify the situation more? Why are you trying to disable heartbeat throttling? That would not be a recommended approach as it will make your workers more sensitive to network latency.

</details>

<details>
<summary><strong>ganlvtech</strong> commented on 2025-12-19 02:18:31.000 UTC</summary>

I want to stop this activity as soon as possible, because `ctx.Done()` in an activity func is triggered when `activity.RecordHeartbeat(ctx, nil)` is called and knows the server has already canceled this workflow.

</details>


---

<a id="2107"></a>

### #2107: Panic in temporal unit test framework.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2107 |
| **State** | OPEN |
| **Author** | jupudibhaskar967 (Naga Jupudi) |
| **Created** | 2025-11-10 21:16:09.000 UTC (1 months ago) |
| **Updated** | 2025-11-10 21:16:56.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
Test should be successful.

## Actual Behavior
Test panics when executing env.ExecuteWorkflow()
Tried with v1.36.0 SDK version as well but still the test is flaky and fails intermittently.

## Steps to Reproduce the Problem

Workflow definition
```
func TestNewWorkflow(ctx workflow.Context, envName string, orgName string, baseDir string) (string, error) {
	childOpts := workflow.ChildWorkflowOptions{
		WorkflowExecutionTimeout: childWorkflowTimeout,
		WorkflowTaskTimeout:      childWorkflowTaskTimeout,
		ParentClosePolicy:        enums.PARENT_CLOSE_POLICY_REQUEST_CANCEL,
	}
	childCtx := workflow.WithChildOptions(ctx, childOpts)
	futures := make([]workflow.ChildWorkflowFuture, 0)
	for ii := 0; ii < 500; ii++ {
		future := workflow.ExecuteChildWorkflow(childCtx, ManualStageWorkflow)
		futures = append(futures, future)
	}

	for ii := 0; ii < 500; ii++ {
		if err := futures[ii].Get(childCtx, nil); err != nil {
			return "", err
		}
	}

	return "Successfully executed 500 child workflows", nil
}
```

Unit test definition
```
// Registration and env instantiation:
testSuite = &testsuite.WorkflowTestSuite{}
env = testSuite.NewTestWorkflowEnvironment()
env.RegisterWorkflow(orchworker.TestNewWorkflow)
env.RegisterWorkflow(orchworker.ManualStageWorkflow)

// Actual test
It("Simulate panic", func() {
	env.OnWorkflow(orchworker.ManualStageWorkflow, mock.Anything, mock.Anything).
		Return(errors.New("test")).Maybe()
	env.ExecuteWorkflow(orchworker.TestNewWorkflow, "testenv", "org1", "")
	Expect(env.IsWorkflowCompleted()).To(BeTrue())
	Expect(env.GetWorkflowError()).To(HaveOccurred())
})

```

The test behavior is flaky with occasional failures
`watch -n3 "go clean -testcache && go test -v <package> -ginkgo.focus="Simulate panic""`

Panic stack trace:
```
/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/internal_workflow_testsuite.go:2855 +0x30
go.temporal.io/sdk/internal.(*testCallbackHandle).processCallback(0x40004d3bc8)
	/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/internal_workflow_testsuite.go:857 +0xb8
go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).startMainLoop(0x4000318488)
	/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/internal_workflow_testsuite.go:797 +0x10c
go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal(0x4000318488, 0x0, {0xf8ea84, 0xf}, 0x4000391c00)
	/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/internal_workflow_testsuite.go:591 +0x384
go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflow(0x4000318488, {0xa5a300, 0xc5ca40}, {0x4000472f60, 0x3, 0x3})
	/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/internal_workflow_testsuite.go:535 +0x104
go.temporal.io/sdk/internal.(*TestWorkflowEnvironment).ExecuteWorkflow(0x400037ea80?, {0xa5a300?, 0xc5ca40?}, {0x4000472f60?, 0x2?, 0x2?})
	/go/pkg/mod/go.temporal.io/sdk@v1.30.0/internal/workflow_testsuite.go:776 +0xac
orchestration/internal/orchworker_test.init.func3.4.3()
	/app/internal/orchworker/workflow_test.go:356 +0x154
```

## Specifications

  - Version: 1.30.0
  - Platform: Alpine with go 1.25.3



---

<a id="2102"></a>

### #2102: Feature Request: WorkflowRun function to get input

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2102 |
| **State** | CLOSED |
| **Author** | erik-ringsmuth (Erik Ringsmuth) |
| **Created** | 2025-11-07 19:39:20.000 UTC (2 months ago) |
| **Updated** | 2025-11-10 17:00:08.000 UTC |
| **Closed** | 2025-11-10 17:00:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I would like the ability to get a workflow run's input using the `WorkflowRun` interface.

Right now this supports getting the result, but not the input that started the workflow.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2025-11-07 20:47:53.000 UTC</summary>

This functionality is not available in a simple form today. You would have to fetch history and look at the first event. An issue has been opened at https://github.com/temporalio/temporal/issues/8608 to track this effort.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-11-10 17:00:01.000 UTC</summary>

When the [server issue](https://github.com/temporalio/temporal/issues/8608) is resolved it will be available on `Describe`. For now the only solution is to look at history.

</details>


---

<a id="2076"></a>

### #2076: SideEffects markers are very difficult to navigate in the timeline

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2076 |
| **State** | CLOSED |
| **Author** | djeer (Dima J) |
| **Created** | 2025-10-10 05:22:54.000 UTC (3 months ago) |
| **Updated** | 2025-10-20 16:36:27.000 UTC |
| **Closed** | 2025-10-20 16:36:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We're using SideEffects a lot and from a user perspective it's very hard to navigate the workflow timeline when there are 10-20 side effects in a row. The only way to see what was called there is to check the payload and try to understand which method could return this payload.

**Describe the solution you'd like**
Add SideEffectOptions with Name parameter 
PR https://github.com/temporalio/sdk-go/pull/2074

**Describe alternatives you've considered**
Checked if that can be implemented on UI side, by using MutableSideEffect with IDs, but those IDs are not shown in the timeline as well. Considered building Chrome extension to fetch MutableSideEffects's IDs in the UI, but overriding marker names in SDK is the cleanest solution.

**Additional context**

Solution that didn't work well - mutable side effects - you have to expand each of them, so there's not much benefit when reading a timeline.

<img width="2650" height="1004" alt="Image" src="https://github.com/user-attachments/assets/42ae6caa-6314-4080-9ebd-aea9bfd47226" />


My [proposed](https://github.com/temporalio/sdk-go/pull/2074) solution - name override, it's shown in the timeline.

<img width="903" height="588" alt="image" src="https://github.com/user-attachments/assets/5cdaebff-8f92-4650-be73-d18898a82d85" />


#### Comments (2)

<details>
<summary><strong>yuandrew</strong> commented on 2025-10-14 23:38:17.000 UTC</summary>

Thanks for the issue! I agree having a bunch of `SideEffect`s in a row in the UI is not helpful. We don't want to give `SideEffects` the ability to rename "Markers" themselves, but instead, we can add Summaries to "Markers", and then have the UI display summaries, similar to[ Activities and LocalActivities](https://github.com/temporalio/sdk-go/blob/ad990a3bfe17560c82cf84c80dfdf6c41eb43580/internal/internal_activity.go#L52C3-L52C32).

Reactions: â¤ï¸ 1

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-10-20 16:36:27.000 UTC</summary>

Closing in favor of #2084

</details>


---

<a id="2061"></a>

### #2061: add trace-id and span-id tags to sdk logs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2061 |
| **State** | CLOSED |
| **Author** | jjaegerman (Jonathan Jaegerman) |
| **Created** | 2025-09-30 14:34:58.000 UTC (3 months ago) |
| **Updated** | 2025-10-01 16:44:57.000 UTC |
| **Closed** | 2025-10-01 16:41:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When using "go.temporal.io/sdk/contrib/opentelemetry" `opentelemetry.NewTracingInterceptor`: if traces are sampled, all user logs (e.g. `activity.GetLogger()...`) and sdk logs (e.g. "Activity failure ...`) should include trace-id and span-id as log tags. It is especially useful to have these handy in sdk failure logs.

## Actual Behavior
If traces are samples, user logs contain trace-id and span-id as log tags, but sdk logs do not contain either.

## Steps to Reproduce the Problem
  1. Initialize an otel tracing interceptor with "go.temporal.io/sdk/contrib/opentelemetry" `opentelemetry.NewTracingInterceptor` and add to client options

## Specifications
  - Version: `v1.35.0`

## Related
https://github.com/temporalio/sdk-java/issues/1273


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-01 16:41:00.000 UTC</summary>

The interceptor already does attach trace and span ID for user created logger.

https://github.com/temporalio/sdk-go/blob/aecdca8be43def99f6237a07385f58612869cd65/contrib/opentelemetry/tracing_interceptor.go#L219

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-01 16:44:57.000 UTC</summary>

There is a separate issue for using the intercepted logger for all SDK logs https://github.com/temporalio/sdk-go/issues/829 as well. ()

</details>


---

<a id="2047"></a>

### #2047: Can the work queue be manually paused?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2047 |
| **State** | CLOSED |
| **Author** | wangpf09 (wangpf) |
| **Created** | 2025-09-04 08:18:01.000 UTC (4 months ago) |
| **Updated** | 2025-09-26 21:36:00.000 UTC |
| **Closed** | 2025-09-26 21:36:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I want to monitor resource usage to determine whether the work queue accepts new tasks, but the worker.Stop method can only be called once. Is there another way to achieve this?

<img width="828" height="294" alt="Image" src="https://github.com/user-attachments/assets/10224685-8e62-421e-b970-55f361d49073" />

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-10 21:26:51.000 UTC</summary>

Can you clarify what you mean by "pausing the work queue"? Temporal has not concept called a work queue, there are [task queues ](https://docs.temporal.io/task-queue), but task queues always accept new tasks and buffer them until a worker can pick them up.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-26 21:36:00.000 UTC</summary>

Closing due to no response, in general task queue or workers have no concept of "paused"

</details>


---

<a id="2003"></a>

### #2003: Feature request: more robust deployments with shutdownGraceTime

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2003 |
| **State** | CLOSED |
| **Author** | giovannibonetti-jota (Giovanni Bonetti) |
| **Created** | 2025-07-16 19:09:09.000 UTC (5 months ago) |
| **Updated** | 2025-07-16 19:59:06.000 UTC |
| **Closed** | 2025-07-16 19:59:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When deploying a new version of a service, some activities are aborted causing increased errors and latency. Even though the activities are meant to be retried, it seems wasteful to force them to do it instead of waiting a few seconds before shutting down the old compute instances.

**Describe the solution you'd like**
We would like to [set up `shutdownGraceTime` just like in the Typescript SDK](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#shutdowngracetime) to something like 10 seconds.

**Describe alternatives you've considered**
The only alternative we see is to avoid using Temporal in latency-sensitive workflows, which is not something we would like to do, but seems to be the only option currently. After all, we would like to make multiple deployments a day without noticeably increasing latency of the running workflows.

#### Comments (2)

<details>
<summary><strong>yuandrew</strong> commented on 2025-07-16 19:35:52.000 UTC</summary>

I believe what you're looking for is `WorkerStopTimeout`. See https://github.com/temporalio/sdk-go/blob/1dc8b10586d56bbf13f7007f87b6220454a825bf/internal/worker.go#L174

and the description from https://pkg.go.dev/go.temporal.io/temporal/activity#GetWorkerStopChannel

</details>

<details>
<summary><strong>giovannibonetti-jota</strong> commented on 2025-07-16 19:59:06.000 UTC</summary>

Great, that should be it. Thank you, @yuandrew!

</details>


---

<a id="1985"></a>

### #1985: StartDevServer fails with Cloudflare `Error 1101` when downloading Temporal v1.27.2

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1985 |
| **State** | CLOSED |
| **Author** | gnarea (Gus Narea) |
| **Created** | 2025-06-27 10:22:44.000 UTC (6 months ago) |
| **Updated** | 2025-06-27 14:34:22.000 UTC |
| **Closed** | 2025-06-27 14:34:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When using `testsuite.StartDevServer` with `CachedDownload.Version: "v1.27.2"`, the Temporal CLI should be downloaded successfully from `temporal.download` and the dev server should start without errors.

## Actual Behavior

The download fails with a Cloudflare Error 1101 ("Worker threw exception") when attempting to fetch CLI version v1.27.2. The exact error is:

```
failed to launch Temporal dev server: failed fetching info, status: 500 Internal Server Error, body: <!DOCTYPE html>...Worker threw exception | temporal.download | Cloudflare...
```

The failing URL is:
```
https://temporal.download/cli/v1.27.2?platform=darwin&arch=arm64&sdk-name=sdk-go&sdk-version=1.34.0
```

Note: Using much older versions like `v1.3.0` works fine.

## Steps to Reproduce the Problem

  1. Create a test file with `testsuite.StartDevServer` configured with `CachedDownload.Version: "v1.27.2"`
  1. Run `go test` to execute the test
  1. Observe the Cloudflare Error 1101 when the SDK attempts to download the CLI

Minimal reproduction:
```go
devServer, err = testsuite.StartDevServer(ctx, testsuite.DevServerOptions{
    CachedDownload: testsuite.CachedDownload{
        Version: "v1.27.2",
    },
    LogLevel: "error",
})
```

## Specifications

  - Version: Go SDK v1.34.0, requesting Temporal CLI v1.27.2
  - Platform: macOS (darwin) arm64, but likely affects all platforms
  - Cloudflare Ray ID: 95642c342f7ccf94 (example from one failed request)

**Additional Context:**
This appears to be an infrastructure issue with the `temporal.download` CDN rather than a client-side SDK issue, but reporting here since it blocks SDK functionality. The v1.27.2 CLI version is the latest release and should be the recommended version for SDK v1.34.0 compatibility.


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2025-06-27 14:06:45.000 UTC</summary>

`v1.27.2` is not a valid CLI version per https://github.com/temporalio/cli. You may be confusing CLI versions with server versions.

</details>

<details>
<summary><strong>gnarea</strong> commented on 2025-06-27 14:34:22.000 UTC</summary>

Thanks @cretz! You're right, that's exactly what's happening ðŸ˜¬ 

Reactions: ðŸ‘ 1

</details>


---

<a id="1980"></a>

### #1980: Feature Request: Include Version in workflowcheck -V=full Output

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1980 |
| **State** | OPEN |
| **Author** | deepika-awasthi |
| **Created** | 2025-06-18 17:20:48.000 UTC (6 months ago) |
| **Updated** | 2025-07-21 06:36:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
this is for tool -> go.temporal.io/sdk/contrib/tools/workflowcheck 

the binary doesn't embed its version information (like semver, buildID, or git hash). The output of workflowcheck -V=full currently shows "version devel".

`âžœ  sdk-go git:(master) workflowcheck -V=full
/Users/deepikaawasthi/go/bin/workflowcheck version devel comments-go-here buildID=793f950a87bc23493a6d8e28dd0f8db2adb5fbcae25a78eb37fd8d25150b4bd7
`

**Describe the solution you'd like**
workflowcheck binary to include the version that was used during its installation

```
> go install go.temporal.io/sdk/contrib/tools/workflowcheck@<theVersion>
...
> workflowcheck -V=full
... <theVersion> ...
```




#### Comments (2)

<details>
<summary><strong>Sushisource</strong> commented on 2025-07-01 16:44:37.000 UTC</summary>

Not a priority for us at the moment, but @deepika-awasthi if you'd like to make a PR yourself we'd welcome it. Thanks!

Reactions: ðŸ‘€ 1

</details>

<details>
<summary><strong>kris-gaudel</strong> commented on 2025-07-21 06:36:41.000 UTC</summary>

Hi is this issue still available? I'm interested in contributing as a first timer!

</details>


---

<a id="1954"></a>

### #1954: Ability to get original Logger from activity.GetLogger(ctx) / workflow.GetLogger(ctx)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1954 |
| **State** | OPEN |
| **Author** | SovaPluto (Volodymyr Sokolov) |
| **Created** | 2025-05-11 11:33:17.000 UTC (8 months ago) |
| **Updated** | 2025-05-11 11:39:36.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
We have our own logger structure across all the services that has important features implemented through its methods.
Temporal logger injects some fields using `With` before execution of activity. 
Another example is trace interceptor that also uses `With` to put trace/span ids as fields (key values). 
The problem is that in some cases I receive not my Adapter structure, but "ReplayLogger". I can't extract original structure from ReplayLogger (it's private).
\+ If other implementations/wrappers appear -- it will imposible to support.

**Describe the solution you'd like**
I want to have opportunity to get the original logger structure without losing all the fields injected previously.
So the solution can be EITHER, giving a method for getting my configured logger, passed at the configuration step, OR don't wrap the original logger anyhow during the execution (logger always keeps the same type, no decorators allowed). 

**Describe alternatives you've considered**
Using global logger in case I couldn't assert type to my adapter. In this case I can lose important fields or must duplicate them myself from the activity. It's more complicated and expensive to do.

**Additional context**

How I try to get the original logger from the activity's context:
![Image](https://github.com/user-attachments/assets/aa9e73fb-5ce5-4261-9679-45c5c63f3151)

`GetLogger` method represents "global" clean logger

Difference in execution:
![Image](https://github.com/user-attachments/assets/42d870ab-de36-427f-b264-3474f0f53e10)


P.S: I'd gladly consider other solutions if you have such. The main goal is to be able to re-use SDK logger enhancements + to continue using project's standard implementation


---

<a id="1951"></a>

### #1951: UpdateWorkflow does not use context aware data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1951 |
| **State** | CLOSED |
| **Author** | raymondregrello |
| **Created** | 2025-05-10 05:43:22.000 UTC (8 months ago) |
| **Updated** | 2025-07-07 15:43:42.000 UTC |
| **Closed** | 2025-07-07 15:43:42.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
UpdateWorkflow should use a context aware data converter

## Actual Behavior
UpdateWorkflow uses a non-context aware data converter

https://temporalio.slack.com/archives/CTDTU3J4T/p1745941143627199?thread_ts=1745446979.723639&cid=CTDTU3J4T

## Steps to Reproduce the Problem

I created a temporal client with a context aware data converter that encrypts payloads with a tenant-specific encryption key if the context contains a "tenant" value.

```
ctx = context.WithValue(ctx, "tenant", 1)
client.UpdateWorkflow(ctx, client.UpdateWorkflowOptions{})
```

I then checked the payload in the Temporal UI. The update input and output payloads were both unencrypted:
![Image](https://github.com/user-attachments/assets/66aba516-88e8-4680-a0e3-8894ffbf15b6)

## Specifications

  - Version: go.temporal.io/sdk v1.30.0, temporal server 1.26.2
  - Platform: Go, Temporal OSS



---

<a id="1932"></a>

### #1932: Provide a type-safe implementation of workflow.ExecuteActivity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1932 |
| **State** | CLOSED |
| **Author** | iwittkau |
| **Created** | 2025-04-24 15:35:20.000 UTC (8 months ago) |
| **Updated** | 2025-04-25 06:51:39.000 UTC |
| **Closed** | 2025-04-24 15:59:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

We're often defining activities like this:

```go
type ActivityArguments struct {
	Name string
}

type ActivityResults struct {
	Greeting string
}

func Activity(ctx context.Context, args ActivityArguments) (ActivityResults, error) {
	return ActivityResults{Greeting: "Hello " + args.Name + "!"}, nil
}
```

Executing this activity from a workflow usually looks like this:

```go
args := ActivityArguments{Name: name}
var result ActivityResults
if err := workflow.ExecuteActivity(ctx, Activity, args).Get(ctx, &result); err != nil {
    return "", err
}
```

This has some problems:

- Boilerplate code is required to create a result variable.
- No compile-time check if the arguments passed match the activity definition.
- No compile-time check if the results returned match the activity definition.

Also, the readability of this block of code will deteriorate as the names get longer.

**Describe the solution you'd like**

Writing generic, type-safe wrappers is already possible:

```go
func ExecuteActivityAndGetResult[A any, R any](ctx workflow.Context, activity func(context.Context, A) (R, error), args A) (R, error) {
	var result R
	err := workflow.ExecuteActivity(ctx, activity, args).Get(ctx, &result)
	return result, err
}

func ExecuteActivity[A any, R any](ctx workflow.Context, activity func(context.Context, A) (R, error), args A) Future[R] {
	f := workflow.ExecuteActivity(ctx, activity, args)
	return &futureWrapper[R]{Future: f}
}

type Future[T any] interface {
	Get(ctx workflow.Context, valuePtr *T) error
	IsReady() bool
}

type futureWrapper[T any] struct {
	workflow.Future
}

func (f *futureWrapper[T]) Get(ctx workflow.Context, valuePtr *T) error {
	return f.Future.Get(ctx, valuePtr)
}
```

This doesn't work with variadic parameters, but using a single struct [is recommended anyway](https://docs.temporal.io/develop/go/core-application#activity-parameters).

However, it fixes the problems mentioned above:

- Less boilerplate code.
- Type checks at compile-time.

It's a simple function call now: 

```go
args := ActivityArguments{Name: name}
result, err := ExecuteActivityAndGetResult(ctx, Activity, args)
if err != nil {
    return "", err
}
```

Or with a separate future:

```go
var result ActivityResults
f := ExecuteActivity(ctx, Activity, args)
if err := f.Get(ctx, &result); err != nil {
    return "", err
}
```

Now it fails to compile if the wrong types are used:

```go
result, err := ExecuteActivityAndGetResult(ctx, Activity, "Temporal")
if err != nil {
    return "", err
}
```

```
cannot use "Temporal" (untyped string constant) as ActivityArguments
```

Same here:

```go
var result string
f := ExecuteActivity(ctx, Activity, args)
if err := f.Get(ctx, &result); err != nil {
    return "", err
}
```

```
cannot use &result (value of type *string) as *ActivityResults
```

**Describe alternatives you've considered**

Doesn't apply.

**Additional context**

Doesn't apply.


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-24 15:59:26.000 UTC</summary>

Hi, Yes generic support is something we are interested in exploring at some point in the future. It likely wouldn't look exactly like what is proposed here, but I fully agree with you on the benefits it would provide. There is still a lot of design and thought that needs to go into how we create a fully type safe API, including things like type safe workflows, activities, signals, updates and queries.

We already have an issue for this so I am going to close this issue to avoid having duplicate issues for the same the same feature request.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>iwittkau</strong> commented on 2025-04-25 06:51:39.000 UTC</summary>

@Quinn-With-Two-Ns I tried searching for similar issues but couldn't find one. Having only one makes sense. I didn't expect my solution, which I came up with in an afternoon, to be implemented exactly like this anyway.
But since it seems like there are no concrete plans to implement this, I think I'll just add these helpers to my projects.

</details>


---

<a id="1929"></a>

### #1929: OTel emitted metrics do not match behavior described in the docs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1929 |
| **State** | OPEN |
| **Author** | kevinawoo (Kevin Woo) |
| **Created** | 2025-04-23 01:00:32.000 UTC (8 months ago) |
| **Updated** | 2025-05-01 05:20:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The behavior described via SDK docs and how the the OTel package was written is different. [Community Slack Discussion](https://temporalio.slack.com/archives/CTDTU3J4T/p1744839840976459)

According to these comments, the behavior is that the these metrics are monotone increasing. 
- https://github.com/temporalio/sdk-go/blob/a92189071ec5931c88a97284d60b8b06f1024fc3/client/client.go#L1315-L1316
- https://github.com/temporalio/sdk-go/blob/a92189071ec5931c88a97284d60b8b06f1024fc3/internal/common/metrics/handler.go#L49-L53

However the current OTel implementation supports explicitly supports negative numbers with the use of `UpDownCounter`
- https://github.com/temporalio/sdk-go/blob/a92189071ec5931c88a97284d60b8b06f1024fc3/contrib/opentelemetry/handler.go#L120-L121
- https://github.com/temporalio/sdk-go/blob/a92189071ec5931c88a97284d60b8b06f1024fc3/contrib/opentelemetry/handler_test.go#L89


## The Bug
The ask is to either fix the docs, or change OTel's emitted metric to be a `Counter` so that it matches how it's more commonly used.

The `UpDownCounter` type doesn't make contextual sense for the metrics emitted by the Temporal SDK.

See the **OTel-Contrib-Packages** section below on how other SDKs use `UpDownCounters` vs `Counters`.


## Specifications
  - Version: v1.34.0


## References

### Temporal Go SDK
The introduction of OTel was introduced in https://github.com/temporalio/sdk-go/pull/1336#discussion_r1443293471, with this comment left ambiguous about which counter type to use, however a [test case](https://github.com/temporalio/sdk-go/pull/1336/files#diff-f987a1b77ea038f5dfb730dff688338f356b0dcb8c4f5bc4ea9c4137f0c3b5acR90) was introduced to support negative numbers.

The summary of an [internal discussion](https://temporaltechnologies.slack.com/archives/C01FG4BRQVB/p1745346080185219) is that the package was built for general usage, without any limitations on the value.

Currently, all usages of the counter calls `.Inc(1)`, however this may change, especially numbers `> 1`.

The behavior of the metrics was copied from the behavior of Tally.


### Tally
uber-go/tally is ambiguous in which values is allowed, but it's implementation supports negative numbers:
- https://github.com/uber-go/tally/blob/12d200cf909b1094affc40bf4bf70fc99c5f39a3/stats.go#L72-L74
- There's no test cases that specifically address negative numbers https://github.com/uber-go/tally/blob/12d200cf909b1094affc40bf4bf70fc99c5f39a3/stats_test.go#L86-L101


### Prometheus
Prometheus does not support negative numbers for counters and will panic if a negative number is provided. https://github.com/prometheus/client_golang/blob/9b83d994624f3cab82ec593133a598b3a27d0841/prometheus/counter.go#L126-L129


### OTel Contrib Packages
OTel's Prometheus package implements `counters` as `monotonic` `sums`, which follows the spirit of Prometheus's implementation.

> [A Counter] is a cumulative metric that represents a single monotonically increasing counter whose value can only increase or be reset to zero on restart.

-[OTel's Prometheus Design Doc #Counters](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/d64038bc0e15111b345d218e17b3c0d4bed63ce5/receiver/prometheusreceiver/DESIGN.md#counter)
- and it's code [prometheusreceiver/internal/util.go](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/d64038bc0e15111b345d218e17b3c0d4bed63ce5/receiver/prometheusreceiver/internal/util.go#L97-L102)



There's limited usage of `UpDownCounters` in all of the `receiver` packages. This metric is mostly commonly used to show the number of things in flight/active.

Note, I think Fluent's usage is actually a bug in how the code is auto generated.


<details> 
<summary>23 occurrences (expand to see usage patterns)</summary>
<kbd>

![Image](https://github.com/user-attachments/assets/057774b6-8200-4c9d-86bb-75785357b761)

</kbd>

</details>



Where the `Counter` type is used as **a cumulative metric that represents a single monotonically increasing counter whose value can only increase or be reset to zero on restart.**


<details>
<summary>Temporal SDK usage of `counter` metric type</summary>

<kbd>

![Image](https://github.com/user-attachments/assets/b6cee77f-bbac-4261-9acc-5e68f4b27d76)

</kbd>
</details> 

<details>
<summary>Other SDK's use of `counter` type (164 occurrences)</summary>

<kbd>

![Image](https://github.com/user-attachments/assets/4572214d-ba7d-48a6-b1dd-3ede1f238a44)

</kbd>
</details> 

#### Comments (2)

<details>
<summary><strong>Sushisource</strong> commented on 2025-04-29 18:15:40.000 UTC</summary>

@kevinawoo Yeah, so this is all objectively true, but I think the consequence is fairly low. We use gauges in other places, so any metrics collection system is going to need to support those (I know in the community thread, they mention their system doesn't handle gauges well - but what system would that be? There'd be a lot of metrics that are gauges now [and should be] that they would be unable to use), and although these particular metrics probably can and should be simple counters, the fact that they aren't isn't exactly causing any damage.

So with that in mind we discussed on the SDK team and we're not likely to take this on immediately. We have a broader effort tracked to normalize metrics across SDKs, I've parented this under that in Jira, and when we take on that effort we can decide if we'll do this then too.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>danielhochman</strong> commented on 2025-05-01 05:20:39.000 UTC</summary>

Google Cloud Monitoring (formerly known as Stackdriver) doesn't natively support gauge deltas in their metrics query builder. This makes any sort of interactive debugging or exploration of metrics quite painful. Displaying a gauge is fine, just not deltas without writing [MQL which is deprecated](https://cloud.google.com/stackdriver/docs/deprecations/mql) or their flavor of PromQL which is [slightly different](https://cloud.google.com/stackdriver/docs/managed-prometheus/promql-differences) than PromQL, neither of which our team is trained up on.

Reactions: ðŸ‘ 1

</details>


---

<a id="1916"></a>

### #1916: Can we have a option for local activity for not marking result to the history

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1916 |
| **State** | CLOSED |
| **Author** | satya-nected |
| **Created** | 2025-04-16 05:47:10.000 UTC (8 months ago) |
| **Updated** | 2025-04-17 05:54:09.000 UTC |
| **Closed** | 2025-04-17 05:54:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I have a use case where I need to load large data(more than 2-5MB) from cache proccess them in workflow to spawn multiple workflows or acitvity based on that data. I tried to load them using local activity but I am getting `BadRecordMarkerAttributes: RecordMarkerCommandAttributes.Details exceeds size limit.`

If there is option of not logging result to the history then it will worked for me. I am ok with the fact that on replay this local activity re-execute again for this usecase.

**Describe the solution you'd like**
If there will be an option for not logging result to the history, then it will work for me.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2025-04-16 13:20:47.000 UTC</summary>

> I have a use case where I need to load large data(more than 2-5MB) from cache proccess them in workflow to spawn multiple workflows or acitvity based on that data. I tried to load them using local activity but I am getting BadRecordMarkerAttributes: RecordMarkerCommandAttributes.Details exceeds size limit.

Do you really need all of this data _inside_ the workflow to spawn multiple children or activities based on the data? Or can you have the local activity properly extract out of this data the small subset of information you actually need to start children or activities and return that from the local activity. We don't store what you load in the local activity, we store what you return in the local activity. If you need the actual large data because it becomes child/activity input, then you're going to just run into this again when the input size exceeds this limit.

> If there is option of not logging result to the history then it will worked for me. I am ok with the fact that on replay this local activity re-execute again for this usecase.

In this case, it's just unsafe code but you have to watch out for the deadlock detector for things that take 1s+. Using a local activity or a side effect is recommended here.

Also, for general questions, can join us on `#go-sdk` on [Slack](https://t.mp/slack) or [the forums](https://community.temporal.io/).

</details>

<details>
<summary><strong>satya-nected</strong> commented on 2025-04-17 05:54:07.000 UTC</summary>

Thanks @cretz for the clearification. I will have to re-structure my data so that I will load in subset of data and do proccessing. 

</details>


---

<a id="1887"></a>

### #1887: enabling FIPS only mode with go 1.24.1 raises panic related to MD5 usage

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1887 |
| **State** | CLOSED |
| **Author** | muralisrini |
| **Created** | 2025-03-26 19:56:14.000 UTC (9 months ago) |
| **Updated** | 2025-03-27 18:17:51.000 UTC |
| **Closed** | 2025-03-27 18:17:51.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
FIPS compatible protocols are in use and go runtime should not raise FIPS related panic

## Actual Behavior
Panic raised in GO runtime:

```
panic: crypto/md5: use of MD5 is not allowed in FIPS 140-only mode

goroutine 49 [running]:
go.temporal.io/sdk/internal.getBinaryChecksum()
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_worker.go:1246 +0xca
go.temporal.io/sdk/internal.(*workerExecutionParameters).getBuildID(...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_worker.go:291
go.temporal.io/sdk/internal.newWorkflowTaskHandler({{0x1d42a8c, 0x7}, {0x1dd9731, 0x18}, {0x2383840, 0xc000a894f0}, 0x40f86a0000000000, 0x5, 0x2, 0x40f86a0000000000, ...}, ...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_task_handlers.go:562 +0x54
go.temporal.io/sdk/internal.newWorkflowWorkerInternal(_, {{0x1d42a8c, 0x7}, {0x1dd9731, 0x18}, {0x2383840, 0xc000a894f0}, 0x40f86a0000000000, 0x5, 0x2, ...}, ...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_worker.go:320 +0xd0
go.temporal.io/sdk/internal.newWorkflowWorker(...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_worker.go:250
go.temporal.io/sdk/internal.NewAggregatedWorker(_, {_, _}, {0xc8, 0x0, 0xc8, 0x0, 0x0, 0x5, 0xc8, ...})
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_worker.go:1828 +0xeea
go.temporal.io/sdk/internal.NewWorker(...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/worker.go:360
go.temporal.io/sdk/worker.New({_, _}, {_, _}, {0xc8, 0x0, 0xc8, 0x0, 0x0, 0x5, ...})
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/worker/worker.go:259 +0x8c
```


## Steps to Reproduce the Problem

  1. start a workflow using GO 1.24.1 with environment variable `GODEBUG=fips140=only` as described in https://go.dev/doc/security/fips140


## Specifications

  - Version: v1.33.0
  - Platform: Ubuntu 24.04.1 LTS 

## Supplementary info 

Tried to work around the problem using by setting `BuildID`:
```
worker.Options{
                BuildID: "manetu." + uuid.New().String(),
...
```

This passed both when not using FIPS or when using `GODEBUG=fips140=on`.

However when using `GODEBUG=fips140=only` (the strictest mode), test failed with what appeared to be a timeout of some sort.  Ignoring application goroutines, see these on stack:

```
goroutine 39 [select]:
google.golang.org/grpc/internal/grpcsync.(*CallbackSerializer).run(0xc000f822b0, {0x23fb9a0, 0xc0007d21e0})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/grpcsync/callback_serializer.go:88 +0x10c
created by google.golang.org/grpc/internal/grpcsync.NewCallbackSerializer in goroutine 30
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/grpcsync/callback_serializer.go:52 +0x11a

goroutine 71 [select]:
google.golang.org/grpc/internal/transport.(*ClientStream).waitOnHeader(0xc0008827d0)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/transport/client_stream.go:92 +0x65
google.golang.org/grpc/internal/transport.(*ClientStream).RecvCompress(...)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/transport/client_stream.go:107
google.golang.org/grpc.(*csAttempt).recvMsg(0xc000f9e4e0, {0x1ce6140, 0xc000408460}, 0x1000000000000?)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/stream.go:1113 +0x117
google.golang.org/grpc.(*clientStream).RecvMsg.func1(0x136?)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/stream.go:970 +0x1f
google.golang.org/grpc.(*clientStream).withRetry(0xc000d90360, 0xc00006ec48, 0xc00006ec38)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/stream.go:790 +0x13b
google.golang.org/grpc.(*clientStream).RecvMsg(0xc000d90360, {0x1ce6140?, 0xc000408460?})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/stream.go:969 +0x155
google.golang.org/grpc.invoke({0x23fb968?, 0xc000bb8720?}, {0x1e947bf?, 0x465bd1?}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0x8?, {0xc000bdc500, ...})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/call.go:73 +0xc4
go.temporal.io/sdk/internal.requiredInterceptors.namespaceProviderInterceptor.func6({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, 0x221f178, ...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/grpc_dialer.go:194 +0x192
google.golang.org/grpc.getChainUnaryInvoker.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, {0xc000bdc500, ...})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/clientconn.go:489 +0x134
go.temporal.io/sdk/internal.requiredInterceptors.NewGRPCInterceptor.func3({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, 0xc000bb8690, ...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/common/metrics/grpc.go:80 +0x38d
google.golang.org/grpc.getChainUnaryInvoker.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, {0xc000bdc500, ...})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/clientconn.go:489 +0x134
github.com/grpc-ecosystem/go-grpc-middleware/retry.UnaryClientInterceptor.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, 0xc000bb8660, ...)
        /home/muralisr/manetu/pkg/mod/github.com/grpc-ecosystem/go-grpc-middleware@v1.4.0/retry/retry.go:44 +0x53d
google.golang.org/grpc.getChainUnaryInvoker.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, {0xc001336840, ...})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/clientconn.go:489 +0x134
go.temporal.io/sdk/internal.requiredInterceptors.NewRetryOptionsInterceptor.func2({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, 0xc000bb8630, ...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/common/retry/interceptor.go:168 +0x6c9
google.golang.org/grpc.getChainUnaryInvoker.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, {0xc000bb8570, ...})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/clientconn.go:489 +0x134
go.temporal.io/sdk/internal.requiredInterceptors.NewGRPCInterceptor.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, 0xc000bb85d0, ...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/common/metrics/grpc.go:80 +0x38d
google.golang.org/grpc.getChainUnaryInvoker.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, {0xc000bb8570, ...})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/clientconn.go:489 +0x134
go.temporal.io/sdk/internal.errorInterceptor({0x23fba10?, 0xc0004081c0?}, {0x1e947bf?, 0x1af2580?}, {0x1d0e380?, 0xc000408af0?}, {0x1ce6140?, 0xc000408460?}, 0x10?, 0xc000bb85a0, ...)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/grpc_dialer.go:223 +0x74
google.golang.org/grpc.NewClient.chainUnaryClientInterceptors.func1({0x23fba10, 0xc0004081c0}, {0x1e947bf, 0x4c}, {0x1d0e380, 0xc000408af0}, {0x1ce6140, 0xc000408460}, 0xc000f92008, 0x221f178, ...)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/clientconn.go:477 +0x10f
google.golang.org/grpc.(*ClientConn).Invoke(0xc000f92008, {0x23fba10?, 0xc0004081c0?}, {0x1e947bf?, 0x4c?}, {0x1d0e380?, 0xc000408af0?}, {0x1ce6140?, 0xc000408460?}, {0xc000ea01a0, ...})
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/call.go:35 +0x205
go.temporal.io/api/workflowservice/v1.(*workflowServiceClient).GetWorkflowExecutionHistory(0xc000f822c0, {0x23fba10, 0xc0004081c0}, 0xc000408af0, {0x0, 0x0, 0x50?})
        /home/muralisr/manetu/pkg/mod/go.temporal.io/api@v1.46.0/workflowservice/v1/service_grpc.pb.go:744 +0x167
go.temporal.io/sdk/internal.(*WorkflowClient).getWorkflowExecutionHistory(0xc00037be00, {0x23fb968, 0xc0011ffa70}, {0x23fc700, 0x35bba20}, 0x1, 0xc000408af0, 0x2)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_workflow_client.go:459 +0x1b1
go.temporal.io/sdk/internal.(*workflowClientInterceptor).ExecuteWorkflow.func1.(*WorkflowClient).getWorkflowHistory.1({0x0, 0x0, 0x0})
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_workflow_client.go:427 +0x1fd
go.temporal.io/sdk/internal.(*historyEventIteratorImpl).HasNext(0xc0013367e0)
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_workflow_client.go:1429 +0x62
go.temporal.io/sdk/internal.(*workflowRunImpl).GetWithOptions(0xc000408930, {0x23fb968, 0xc0011ffa70}, {0x19e2e80, 0xc0000aa448}, {0x1?})
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_workflow_client.go:1489 +0x99
go.temporal.io/sdk/internal.(*workflowRunImpl).Get(0xc000ecfa88?, {0x23fb968?, 0xc0011ffa70?}, {0x19e2e80?, 0xc0000aa448?})
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_workflow_client.go:1480 +0x2a
gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/cp/client/cp.CreateID({0x23fb968, 0xc0011ffa70}, {0x708818682198, 0xc00037be00}, 0xc0012120c0)
        /home/muralisr/manetu/src/gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/cp/client/cp/idcreate.go:43 +0x43d
gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors.createAdminIDCommand(0xc000f14500, {0xc0008f9530, 0x9}, {0xc0008f9508, 0x3}, {0xc0008f9550, 0x10, 0x10})
        /home/muralisr/manetu/src/gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors/utils.go:118 +0xdb3
gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors.(*ProviderCreatedEventHandler).createAdminIDCommand(0xc000c18cf0?, 0xc000f14500, {0xc0008f9530, 0x9}, 0xc000f15000)
        /home/muralisr/manetu/src/gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors/providercreated.go:105 +0x24e
gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors.(*ProviderCreatedEventHandler).Process(0x35bba20, 0xc000f14500, 0xc000fbff10, 0xc001037080)
        /home/muralisr/manetu/src/gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors/providercreated.go:48 +0x1ff
gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors_test.TestProviderCreatedProcess.func5(0xc0004c0fc0)
        /home/muralisr/manetu/src/gitlab.com/manetu/platform/control-plane/mcp-iam-service/internal/event/processors/providercreated_test.go:167 +0x219
testing.tRunner(0xc0004c0fc0, 0xc00067e230)
        /home/muralisr/go-1.24.1/src/testing/testing.go:1792 +0xf4
created by testing.(*T).Run in goroutine 30
        /home/muralisr/go-1.24.1/src/testing/testing.go:1851 +0x413

goroutine 54 [select]:
google.golang.org/grpc/internal/transport.(*controlBuffer).get(0xc000bdc180, 0x1)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/transport/controlbuf.go:412 +0x108
google.golang.org/grpc/internal/transport.(*loopyWriter).run(0xc000f96300)
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/transport/controlbuf.go:575 +0x78
google.golang.org/grpc/internal/transport.NewHTTP2Client.func6()
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/transport/http2_client.go:472 +0xd2
created by google.golang.org/grpc/internal/transport.NewHTTP2Client in goroutine 85
        /home/muralisr/manetu/pkg/mod/google.golang.org/grpc@v1.71.0/internal/transport/http2_client.go:470 +0x2452

goroutine 31 [syscall, 10 minutes]:
os/signal.signal_recv()
        /home/muralisr/go-1.24.1/src/runtime/sigqueue.go:152 +0x29
os/signal.loop()
        /home/muralisr/go-1.24.1/src/os/signal/signal_unix.go:23 +0x13
created by os/signal.Notify.func1.1 in goroutine 45
        /home/muralisr/go-1.24.1/src/os/signal/signal.go:152 +0x1f

goroutine 47 [chan receive, 10 minutes]:
go.temporal.io/sdk/internal.InterruptCh.func1()
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_utils.go:205 +0x2b
created by go.temporal.io/sdk/internal.InterruptCh in goroutine 45
        /home/muralisr/manetu/pkg/mod/go.temporal.io/sdk@v1.33.0/internal/internal_utils.go:204 +0xdc

```





---

<a id="1884"></a>

### #1884: Serialization context for codecs and converters

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1884 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-03-25 15:02:18.000 UTC (9 months ago) |
| **Updated** | 2025-03-25 18:11:42.000 UTC |
| **Closed** | 2025-03-25 18:11:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/434

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-25 15:15:47.000 UTC</summary>

@cretz this looks like a duplicate of https://github.com/temporalio/sdk-go/issues/1352

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-03-25 18:11:41.000 UTC</summary>

Thanks! I'll close this as a duplicate and update that issue and the features issue to reference each other.

</details>


---

<a id="1882"></a>

### #1882: Caller skips is incorrectly calculated when a custom logger is provided to the SDK client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1882 |
| **State** | CLOSED |
| **Author** | AhmadElsagheer (Ahmad Elsagheer) |
| **Created** | 2025-03-25 11:14:09.000 UTC (9 months ago) |
| **Updated** | 2025-03-25 14:07:19.000 UTC |
| **Closed** | 2025-03-25 14:07:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Context
We have, at Payrails, a custom logger (a wrapper of zap)  that implements the temporal SDK `log.Logger` interface and is provided to the SDK client. Recently, we wanted to sanitize the logs to make the zap log fields `caller` and `stacktrace` more representative of the actual log line skipping all logging and temporal SDK internal details. So, we additionally implemented `log.WithSkipCallers` interface but looks like there is an overcount in the skip calls.

Without implementing the skipping interface, an error log looks like
```json
{
    "level": "error",
    "ts": 1742899256.974098,
    "caller": "log/with_logger.go:79",    // <--- Current (without the skipping interface)
    "msg": "HelloWorld: this is an error inside the workflow",
    "Namespace": "default",
    "TaskQueue": "main_queue",
    "WorkerID": "37387@KCJ74K6WJ2@",
    "WorkflowType": "HelloWorld",
    "WorkflowID": "989f5c44-9311-4bd1-be2d-5477c157392c",
    "RunID": "84ecd3c3-6ab2-4cd9-82f6-ca14ed470f58",
    "Attempt": 1,
    "stacktrace": "go.temporal.io/sdk/log.(*withLogger).Error\n\t/payrails/sdk-go/log/with_logger.go:79\ngo.temporal.io/sdk/log.(*withLogger).Error\n\t/payrails/sdk-go/log/with_logger.go:79\ngo.temporal.io/sdk/internal/log.(*ReplayLogger).Error\n\t/payrails/sdk-go/internal/log/replay_logger.go:79\nmain.HelloWorld\n\t/payrails/sdk-go/play/business.go:11\nreflect.Value.call\n\t/usr/local/go/src/reflect/value.go:581\nreflect.Value.Call\n\t/usr/local/go/src/reflect/value.go:365\ngo.temporal.io/sdk/internal.executeFunction\n\t/payrails/sdk-go/internal/internal_worker.go:2087\ngo.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow\n\t/payrails/sdk-go/internal/workflow.go:797\ngo.temporal.io/sdk/internal.(*workflowExecutor).Execute\n\t/payrails/sdk-go/internal/internal_worker.go:922\ngo.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1\n\t/payrails/sdk-go/internal/internal_workflow.go:574\ngo.temporal.io/sdk/internal.(*coroutineState).run\n\t/payrails/sdk-go/internal/internal_workflow.go:1217"
}
```
```go
// Stacktrace
// go.temporal.io/sdk/log.(*withLogger).Error\n\t/payrails/sdk-go/log/with_logger.go:79\n <-- Temporal internals
// go.temporal.io/sdk/log.(*withLogger).Error\n\t/payrails/sdk-go/log/with_logger.go:79\n <-- Temporal internals
// go.temporal.io/sdk/internal/log.(*ReplayLogger).Error\n\t/payrails/sdk-go/internal/log/replay_logger.go:79\n <-- Temporal internals
// main.HelloWorld\n\t/payrails/sdk-go/play/business.go:1 <-- Target caller
```

## Expected Behavior
```json
{
    "level": "error",
    "ts": 1742898778.993421,
    "caller": "play/business.go:11",    // <--- Expected
    "msg": "HelloWorld: this is an error inside the workflow",
    "Namespace": "default",
    "TaskQueue": "main_queue",
    "WorkerID": "26036@KCJ74K6WJ2@",
    "WorkflowType": "HelloWorld",
    "WorkflowID": "c548205d-0c6d-428d-a916-40635de42e20",
    "RunID": "b67f831e-58c4-4743-8b28-6574d2197deb",
    "Attempt": 1,
    "stacktrace": "main.HelloWorld\n\t/payrails/sdk-go/play/business.go:11\nreflect.Value.call\n\t/usr/local/go/src/reflect/value.go:581\nreflect.Value.Call\n\t/usr/local/go/src/reflect/value.go:365\ngo.temporal.io/sdk/internal.executeFunction\n\t/payrails/sdk-go/internal/internal_worker.go:2087\ngo.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow\n\t/payrails/sdk-go/internal/workflow.go:797\ngo.temporal.io/sdk/internal.(*workflowExecutor).Execute\n\t/payrails/sdk-go/internal/internal_worker.go:922\ngo.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1\n\t/payrails/sdk-go/internal/internal_workflow.go:574\ngo.temporal.io/sdk/internal.(*coroutineState).run\n\t/payrails/sdk-go/internal/internal_workflow.go:1217"
}
```
Skipped callers = 3

## Actual Behavior
```json
{
    "level": "error",
    "ts": 1742898791.142066,
    "caller": "internal/workflow.go:797",    // <--- Actual unexpected (with the skipping interface)
    "msg": "HelloWorld: this is an error inside the workflow",
    "Namespace": "default",
    "TaskQueue": "main_queue",
    "WorkerID": "26374@KCJ74K6WJ2@",
    "WorkflowType": "HelloWorld",
    "WorkflowID": "33f1016d-bb9f-42e5-9788-c9d3e4440515",
    "RunID": "e83505ff-0de9-4373-9b86-0a91b52ffae5",
    "Attempt": 1,
    "stacktrace": "go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow\n\t/payrails/sdk-go/internal/workflow.go:797\ngo.temporal.io/sdk/internal.(*workflowExecutor).Execute\n\t/payrails/sdk-go/internal/internal_worker.go:922\ngo.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1\n\t/payrails/sdk-go/internal/internal_workflow.go:574\ngo.temporal.io/sdk/internal.(*coroutineState).run\n\t/payrails/sdk-go/internal/internal_workflow.go:1217"
}
```
Skipped callers = 7
```go
// go.temporal.io/sdk/log.(*withLogger).Error\n\t/payrails/sdk-go/log/with_logger.go:79\n // Skipped
// go.temporal.io/sdk/log.(*withLogger).Error\n\t/payrails/sdk-go/log/with_logger.go:79\n // Skipped
// go.temporal.io/sdk/internal/log.(*ReplayLogger).Error\n\t/payrails/sdk-go/internal/log/replay_logger.go:79\n // Skipped
// main.HelloWorld\n\t/payrails/sdk-go/play/business.go:11\n // Skipped
// reflect.Value.call\n\t/usr/local/go/src/reflect/value.go:581\n // Skipped
// reflect.Value.Call\n\t/usr/local/go/src/reflect/value.go:365\n // Skipped
// go.temporal.io/sdk/internal.executeFunction\n\t/payrails/sdk-go/internal/internal_worker.go:2087\n // Skipped
// go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow\n\t/payrails/sdk-go/internal/workflow.go:797\n // Caller
// go.temporal.io/sdk/internal.(*workflowExecutor).Execute\n\t/payrails/sdk-go/internal/internal_worker.go:922\n
// go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1\n\t/payrails/sdk-go/internal/internal_workflow.go:574\n
// go.temporal.io/sdk/internal.(*coroutineState).run\n\t/payrails/sdk-go/internal/internal_workflow.go:1217
```

## Steps to Reproduce the Problem
1. Run the code below (3 files) with:
```bash
go run ./play
```
```go
// ./play/business.go
package main

import (
	"fmt"

	"go.temporal.io/sdk/workflow"
)

func HelloWorld(ctx workflow.Context, name string) (string, error) {
	logger := workflow.GetLogger(ctx)
	logger.Error("HelloWorld: this is an error inside the workflow")
	return fmt.Sprintf("Hello %s", name), nil
}
```
```go
// ./play/logger.go
package main

import (
	"fmt"

	"go.temporal.io/sdk/log"
	"go.uber.org/zap"
)

var _ log.Logger = (*customLogger)(nil)

var _ log.WithSkipCallers = (*customLogger)(nil)

type customLogger struct {
	*zap.SugaredLogger
}

func newCustomLogger() log.Logger {
	zlog, err := zap.NewProduction(
		zap.AddCallerSkip(1), // Skip custom logger as caller
	)
	if err != nil {
		panic(err)
	}
	return &customLogger{SugaredLogger: zlog.Sugar()}
}

func (l *customLogger) Debug(msg string, keyvals ...interface{}) {
	l.SugaredLogger.Debugw(msg, keyvals...)
}

func (l *customLogger) Info(msg string, keyvals ...interface{}) {
	l.SugaredLogger.Infow(msg, keyvals...)
}

func (l *customLogger) Warn(msg string, keyvals ...interface{}) {
	l.SugaredLogger.Warnw(msg, keyvals...)
}

func (l *customLogger) Error(msg string, keyvals ...interface{}) {
	l.SugaredLogger.Errorw(msg, keyvals...)
}

func (l *customLogger) WithCallerSkip(depth int) log.Logger {
	fmt.Println("--- skip:", depth)
	return &customLogger{
		SugaredLogger: l.SugaredLogger.WithOptions(zap.AddCallerSkip(depth)),
	}
}
```
```go
// ./play/main.go
package main

import (
	"context"
	"fmt"
	"os"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func run() error {
	// 1. Create client
	logger := newCustomLogger()

	c, err := client.Dial(client.Options{
		Logger: logger,
	})
	if err != nil {
		return err
	}

	// 2. Create worker
	wk := worker.New(c, "main_queue", worker.Options{})
	wk.RegisterWorkflow(HelloWorld)

	// 3. Start a workflow
	go func() {
		run, err := c.ExecuteWorkflow(context.Background(),
			client.StartWorkflowOptions{
				TaskQueue: "main_queue",
			},
			HelloWorld,
			"Ben",
		)

		if err != nil {
			logger.Error("main: failed to execute workflow", "error", err)
		}

		var res string
		err = run.Get(context.Background(), &res)
		if err != nil {
			logger.Error("main: workflow failed", "error", err)
		}
	}()

	return wk.Run(worker.InterruptCh())
}
```

Output:
```
--- skip: 1
--- skip: 1
--- skip: 1
--- skip: 1
--- skip: 1
--- skip: 1
{"level":"error","ts":1742900250.435758,"caller":"internal/workflow.go:797","msg":"HelloWorld: this is an error inside the workflow","Namespace":"default","TaskQueue":"main_queue","WorkerID":"61032@KCJ74K6WJ2@","WorkflowType":"HelloWorld","WorkflowID":"c42fe9b6-357a-47ba-974e-44aeb745a25e","RunID":"2fb6c16d-54b4-4e5e-a42b-9637f9905b5e","Attempt":1,"stacktrace":"go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow\n\t/payrails/sdk-go/internal/workflow.go:797\ngo.temporal.io/sdk/internal.(*workflowExecutor).Execute\n\t/payrails/sdk-go/internal/internal_worker.go:922\ngo.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1\n\t/payrails/sdk-go/internal/internal_workflow.go:574\ngo.temporal.io/sdk/internal.(*coroutineState).run\n\t/payrails/sdk-go/internal/internal_workflow.go:1217"}
```


## Specifications

  - Version: `1.33.0`
  - Platform: MacOS Apple M1 Max, arm64


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-25 13:11:49.000 UTC</summary>

Your logger should also implement `WithLogger`

</details>

<details>
<summary><strong>AhmadElsagheer</strong> commented on 2025-03-25 14:07:18.000 UTC</summary>

Thanks, that solved the problem ðŸ‘ðŸ½ Looks like `WithSkipCallers` interface is not independent.

</details>


---

<a id="1857"></a>

### #1857: WorkflowIdReusePolicy document should mention WorkflowExecutionErrorWhenAlreadyStarted option

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1857 |
| **State** | CLOSED |
| **Author** | yux0 (Yu Xia) |
| **Created** | 2025-03-03 17:20:43.000 UTC (10 months ago) |
| **Updated** | 2025-03-17 16:16:25.000 UTC |
| **Closed** | 2025-03-17 16:16:25.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
The WorkflowExecutionAlreadyStartedFailure will only return when the option `WorkflowExecutionErrorWhenAlreadyStarted` is set.

## Actual Behavior
The doc on `WorkflowIdReusePolicy` is 
```
// Defines whether to allow re-using a workflow id from a previously *closed* workflow.
// If the request is denied, a `WorkflowExecutionAlreadyStartedFailure` is returned.
//
// See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
```
It does not mention the default behavior is not return WorkflowExecutionAlreadyStartedFailure. This is misleading.

## Specifications

  - Version:
  - Platform:



---

<a id="1856"></a>

### #1856: ExecuteWorkflow API document with return errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1856 |
| **State** | CLOSED |
| **Author** | yux0 (Yu Xia) |
| **Created** | 2025-03-03 17:17:54.000 UTC (10 months ago) |
| **Updated** | 2025-03-13 17:47:53.000 UTC |
| **Closed** | 2025-03-13 17:47:52.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
WorkflowExecutionErrorWhenAlreadyStarted can be returned from ExecuteWorkflow if WorkflowExecutionErrorWhenAlreadyStarted option is set.

## Actual Behavior
WorkflowExecutionErrorWhenAlreadyStarted error does not mentioned in the API document.

```
// ExecuteWorkflow starts a workflow execution and returns a WorkflowRun instance or error
		//
		// This can be used to start a workflow using a function reference or workflow type name.
		// Either by
		//     ExecuteWorkflow(ctx, options, "workflowTypeName", arg1, arg2, arg3)
		//     or
		//     ExecuteWorkflow(ctx, options, workflowExecuteFn, arg1, arg2, arg3)
		// The errors it can return:
		//  - serviceerror.NamespaceNotFound, if namespace does not exist
		//  - serviceerror.InvalidArgument
		//  - serviceerror.Internal
		//  - serviceerror.Unavailable
```

## Specifications

  - Version:
  - Platform:



---

<a id="1764"></a>

### #1764: Versioning override AutoUpgrade using a ref to an empty deployment struct instead of a nil pointer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1764 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2025-01-08 01:24:10.000 UTC (1 years ago) |
| **Updated** | 2025-01-10 18:51:08.000 UTC |
| **Closed** | 2025-01-10 18:51:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description


The new versioning override API (`UpdateWorkflowExecutionOptions`) requires a Deployment proto field with a pointer to nil to set 
AutoUpgrade behavior, and instead,  the SDK provides a pointer to an empty Deployment struct.

The result is that the server always fails the request.



#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-01-10 15:54:49.000 UTC</summary>

@antlai-temporal Can we close this issue?

</details>

<details>
<summary><strong>antlai-temporal</strong> commented on 2025-01-10 18:51:07.000 UTC</summary>

Sure, closing...

Reactions: â¤ï¸ 1

</details>


---

<a id="1740"></a>

### #1740: Can we get a release of workflowcheck? â¤ï¸ 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1740 |
| **State** | CLOSED |
| **Author** | azdagron (Andrew Harding) |
| **Created** | 2024-12-03 19:59:55.000 UTC (1y 1m ago) |
| **Updated** | 2025-01-16 23:47:58.000 UTC |
| **Closed** | 2025-01-16 23:47:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Workflowcheck hasn't had a tagged release for ~ 9 months. Is there one planned soon?

Of particular interest, commit https://github.com/temporalio/sdk-go/commit/d10e87118a07b44fd09bf88d39a628f0e6e70c34 fixes handling of alias types introduced in go1.22. Would be great to have this available in an official release.

Thanks much!


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-05 00:45:04.000 UTC</summary>

Yes we plan to tag it soon after the next SDK release , that should be this week

Reactions: â¤ï¸ 1

</details>

<details>
<summary><strong>yuandrew</strong> commented on 2025-01-16 23:47:57.000 UTC</summary>

Hi, we just tagged a new release for Workflowcheck! https://github.com/temporalio/sdk-go/releases/tag/contrib%2Ftools%2Fworkflowcheck%2Fv0.3.0

</details>


---

<a id="1728"></a>

### #1728: Simplify the update-wth-start API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1728 |
| **State** | CLOSED |
| **Author** | shizambles (Sriram Seshadri) |
| **Created** | 2024-11-26 21:24:18.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-15 17:26:44.000 UTC |
| **Closed** | 2024-12-15 17:26:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

The new, experimental update-with-start API provides a confusing API. Looking at the [integration test code](https://github.com/temporalio/sdk-go/pull/1579/files#diff-8118e44ac15fb5ab2e2ece2ab52fd23062a10b5cc9c55ee5b3620a1242cff27cR3992), it appears that the way to update-wth-start an already running workflow is to call [Client.ExecuteWorkflow()](https://pkg.go.dev/go.temporal.io/sdk@v1.30.0/client#Client) twice. 

1. The first call to `ExecuteWorkflow`, needs a `StartWorkflowOptions` with `WorkflowIDConflictPolicy` set to `WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING`. The documentation of this policy states -
```go
// Don't start a new workflow; instead return a workflow handle for the running workflow.
WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING WorkflowIdConflictPolicy = 2
```
2. The second call to `ExecuteWorkflow`, needs a `StartWorkflowOptions` with `WithStartOperation` set to a `NewUpdateWithStartWorkflowOperation` value like below.
```go
client.NewUpdateWithStartWorkflowOperation(
		client.UpdateWorkflowOptions{
			UpdateName:   "update",
			Args:         ....,
			WaitForStage: client.WorkflowUpdateStageCompleted,
		})
```
The documentation of `WithStartOperation` states - 
```go
// WithStartOperation - Operation to execute with Workflow Start.
// For example, see NewUpdateWithStartWorkflowOperation to perform Update-with-Start. Note that if the workflow is
// already running and WorkflowIDConflictPolicy is set to UseExisting, the start is skipped and only the
// operation is executed.
```

Needing two consecutive calls to `ExecuteWorkflow` to exercise the update-with-start functionality is confusing and in my opinion violates the principle of least surprise. The developer is now having to drill down into the documentation to realize that despite the documentation for `ExecuteWorkflow` stating that `ExecuteWorkflow starts a workflow execution and returns a WorkflowRun instance or error`, it many not actually start a workflow depending on what options are passed in.

**Describe the solution you'd like**

The API could be simplified by providing a single suitably named function - say `client.UpdateWithStartWorkflow` that hides the above details and does the needful. 


#### Comments (2)

<details>
<summary><strong>dandavison</strong> commented on 2024-11-27 15:44:28.000 UTC</summary>

Hi @shizambles, we're in the process of rolling out Update-With-Start across all languages and we are indeed planning to make an API change here. I'll update this ticket with details when the relevant PRs are merged, but what we're planning is similar to what you suggest.

That said, your interpretation of the current API isn't quite right. Update-With-Start requires only one call to `ExecuteWorkflow`, for example, see the sample here: https://github.com/temporalio/samples-go/blob/main/early-return/starter/main.go

The integration test you point to calls `ExecuteWorkflow` twice -- once to start a workflow, and a second time to confirm that an Update-With-Start can be sent to an already-running workflow. To test this style of usage of Update-With-Start, the second call has to pass the `USE_EXISTING` workflow ID conflict policy. This style of UwS usage is intended for situations where you have a relatively long-running workflow (e.g. an e-commerce shopping cart, or an "entity" workflow acting as a service of some sort), and you want to send an update to the workflow, starting it if necessary.

The other style of Update-With-Start usage involves using the (default) `FAIL` conflict policy. This is for when you want to start a workflow and at the same time send an update in the first workflow task, and you want the operation to fail if the workflow already exists (i.e. you demand that a workflow is _started_). This style is what is shown in the [sample](https://github.com/temporalio/samples-go/blob/main/early-return/starter/main.go).

It's important to understand that the concept of the workflow ID conflict policy is not specifically tied to Update-With-Start: it's available whenever you start a workflow, allowing you to control what happens when the workflow ID you supply corresponds to an already-running workflow. In other words, it's already the case, across all SDKs, that the start-workflow API can be used in an idempotent style that will succeed without actually starting a workflow, if it exists already. So it isn't specifically related to Update-With-Start, but understanding that option is central to understanding the two usage modes of Update-With-Start.

I'll ping this ticket when we make the planned changes!


</details>

<details>
<summary><strong>dandavison</strong> commented on 2024-12-15 17:26:44.000 UTC</summary>

The modified update-with-start API has now been released. See https://github.com/temporalio/sdk-go/releases/tag/v1.31.0 and API docs  https://pkg.go.dev/go.temporal.io/sdk@v1.31.0/client#Client.UpdateWithStartWorkflow

</details>


---

<a id="1673"></a>

### #1673: Support user metadata on activities and child/scheduled workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1673 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-10-15 12:29:38.000 UTC (1y 2m ago) |
| **Updated** | 2024-11-21 22:48:32.000 UTC |
| **Closed** | 2024-11-21 22:48:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See previous work done in https://github.com/temporalio/sdk-go/pull/1597. Accept optional "summary" on activities, and optional "static summary" + "static details" in child workflow and scheduled workflow options and mark experimental.

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-15 15:10:09.000 UTC</summary>

Didn't https://github.com/temporalio/sdk-go/pull/1597 already add support for metadata to child and scheduled workflows 

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-10-15 15:14:41.000 UTC</summary>

@Quinn-With-Two-Ns - the fields are there but not exposed and have TODO statements. This issue should expose them.

</details>


---

<a id="1646"></a>

### #1646: SetStartTime for activity test env

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1646 |
| **State** | OPEN |
| **Author** | rrrkren (Eric Ren) |
| **Created** | 2024-09-23 18:55:31.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-23 18:55:31.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

`TestWorkflowEnvironment` supports a `SetStartTime` method which allows one to set the start time of the workflow during testing. It would be great if such a feature exists for `TestActivityEnvironment` so similar start time related features can be tested properly. 

**Describe the solution you'd like**
`TestActivityEnvironment` to support `SetStartTime`

**Describe alternatives you've considered**
passing in start time for activity as parameter, but this is not encouraged as it could be imprecise due to worker coordination.

**Additional context**



---

<a id="1614"></a>

### #1614: For `go.temporal.io/api/proxy.VisitPayloadsOptions.Visitor`, parent not properly reset (and clarify docs)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1614 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-08-30 12:12:10.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-04 19:08:30.000 UTC |
| **Closed** | 2024-09-04 19:07:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

We set the parent on the context before making a visit call but then don't set it back when done causing it to leak to other calls. We need to set it back.

Also for clarity we need to change the doc from:

> Context is the same for every call of a visit, callers should not store it.

to

> Context is the same for every call of a visit and is mutated between calls, callers should not store it or reference it beyond the call. Also, context should be considered by mutated by users.

And perhaps put this doc on the `VisitPayloadsContext` itself. This is on this repo instead of https://github.com/temporalio/api-go because that has no "issues" section.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-08-30 14:01:05.000 UTC</summary>

```go
			ctx.Parent = o
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
```
should probably be more like
```go
			if err := visitPayloads(
				ctx,
				options,
				o,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
```
i.e. pass in the parent as a param and set the parent before the type switch. But up to implementer.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-09-04 19:08:28.000 UTC</summary>

(note this is not yet tagged/released in the API repo)

</details>


---

<a id="1611"></a>

### #1611: GetSystemInfo - panic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1611 |
| **State** | CLOSED |
| **Author** | longshanxu |
| **Created** | 2024-08-28 12:20:19.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-06 12:43:10.000 UTC |
| **Closed** | 2024-09-06 08:29:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
temporal go sdk 1.28.1 

## Actual Behavior
GetSystemInfo - panic

## Steps to Reproduce the Problem

  1. temporalClient, err := client.Dial(client.Options{})

## Specifications

  - Version: temporal go sdk 1.28.1 
  - Platform: windows

ps:
`	// grpcCtx, cancel := newGRPCContext(ctx, grpcTimeout(getSystemInfoTimeout))
	// defer cancel()
	resp, err := wc.workflowService.GetSystemInfo(ctx, &workflowservice.GetSystemInfoRequest{})`
	
**If I annotate these two lines of code and pass in ctx, it works. If I use timeout on ctx, I panic. What is the reason for this?**



#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-08-29 12:34:04.000 UTC</summary>

> Steps to Reproduce the Problem
> temporalClient, err := client.Dial(client.Options{})

Our most basic samples use `client.Dial(client.Options{})` e.g. https://github.com/temporalio/samples-go/tree/main/helloworld. Can you confirm that sample works for you?

</details>

<details>
<summary><strong>longshanxu</strong> commented on 2024-09-06 08:29:00.000 UTC</summary>

> > Steps to Reproduce the Problem
> > temporalClient, err := client.Dial(client.Options{})
> 
> Our most basic samples use `client.Dial(client.Options{})` e.g. https://github.com/temporalio/samples-go/tree/main/helloworld. Can you confirm that sample works for you?

I found the problem, using client.Dial(client.Options{}) to set localhost:7233 by default, timed out under windows. The timeout must be greater than 10 seconds, or use 127.0.0.1:7233

thanks for your reply!


</details>


---

<a id="1596"></a>

### #1596: Treat a 100 percent ramp in a versioning assignment rule as unramped

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1596 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-08-16 19:15:12.000 UTC (1y 4m ago) |
| **Updated** | 2025-02-11 08:32:18.000 UTC |
| **Closed** | 2025-02-11 08:32:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Customers are getting confused when they cannot set a 100% ramp, and they need a special case
**Describe the solution you'd like**

Treat a 100% ramp in an assignment versioning rule as un-ramped. This depends on server changes in
https://github.com/temporalio/temporal/pull/6409


#### Comments (2)

<details>
<summary><strong>antlai-temporal</strong> commented on 2025-02-11 08:32:05.000 UTC</summary>

Assignment rules have been deprecated, and soon to be removed, closing

</details>

<details>
<summary><strong>antlai-temporal</strong> commented on 2025-02-11 08:32:17.000 UTC</summary>

Assignment rules have been deprecated, and soon to be removed, closing

</details>


---

<a id="1594"></a>

### #1594: Workflow replay error: lookup failed for scheduledEventID to activityID

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1594 |
| **State** | CLOSED |
| **Author** | albertteoh (Albert) |
| **Created** | 2024-08-16 11:28:27.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-16 20:58:43.000 UTC |
| **Closed** | 2024-08-16 20:58:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

- I'd like the test to still pass with a recent workflow history.
- Older workflow histories (say from March or April 2024) appear to pass the test.
- I'm fairly confident it's not related to non-determinism.

## Actual Behavior

After downloading a recent workflow history from Temporal Cloud, my replay tests are failing with error:
```
=== RUN   TestFulfillmentWorkflowReplay
=== PAUSE TestFulfillmentWorkflowReplay
=== CONT  TestFulfillmentWorkflowReplay
2024/08/16 21:13:12 INFO  No DataConverter configured for temporal worker. Use default one.
2024/08/16 21:13:12 ERROR Workflow panic WorkflowType FulfillmentWorkflow WorkflowID ReplayId RunID 229d965d-04bc-4125-a3e2-6c5fc91e4067 Attempt 1 Error [TMPRL1100] lookup failed for scheduledEventID to activityID: scheduleEventID: 7, activityID: 7 StackTrace process event for main [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_command_state_machine.go:507
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0x14000613ae0, {0x10289e578, 0x1}, 0x7)
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_command_state_machine.go:1137 +0xec
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0x14000622978, 0x14000532bd0, 0x1?, 0x0)
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_event_handlers.go:1211 +0x258
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0x140003a1860, 0x14000632450)
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_task_handlers.go:1151 +0x13f0
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0x1400062e5b0, 0x14000632450, 0x140003a1860, 0x0)
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_task_handlers.go:916 +0x2b8
go.temporal.io/sdk/internal.(*WorkflowReplayer).replayWorkflowHistory(0x140001bf380, {0x101d93078, 0x14000622900}, {0x101dacdc0, 0x14000619760}, {0x10178017f, 0xf}, {{0x0?, 0x1020df5f1?}, {0x0?, ...}}, ...)
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_worker.go:1466 +0x754
go.temporal.io/sdk/internal.(*WorkflowReplayer).ReplayPartialWorkflowHistoryFromJSONFile(0x140001bf380, {0x0, 0x0}, {0x1017a9d2d?, 0x14000065801?}, 0x1400000d9f8?)
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_worker.go:1318 +0x1c0
go.temporal.io/sdk/internal.(*WorkflowReplayer).ReplayWorkflowHistoryFromJSONFile(0x140003c4540?, {0x0?, 0x0?}, {0x1017a9d2d?, 0x0?})
  /Users/albertteoh/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_worker.go:1298 +0x2c
github.com/packsmith/api/internal/workflows/definitions_test.TestFulfillmentWorkflowReplay(0x140000d1860)
  /Users/albertteoh/go/src/github.com/packsmith/api/internal/workflows/definitions/fulfillment_workflow_test.go:448 +0x434
testing.tRunner(0x140000d1860, 0x101d70088)
  /usr/local/go/src/testing/testing.go:1690 +0xe4
created by testing.(*T).Run in goroutine 1
  /usr/local/go/src/testing/testing.go:1743 +0x314
    fulfillment_workflow_test.go:449: 
          Error Trace:  /Users/albertteoh/go/src/github.com/packsmith/api/internal/workflows/definitions/fulfillment_workflow_test.go:449
          Error:        Received unexpected error:
                        [TMPRL1100] lookup failed for scheduledEventID to activityID: scheduleEventID: 7, activityID: 7
          Test:         TestFulfillmentWorkflowReplay
--- FAIL: TestFulfillmentWorkflowReplay (0.08s)
```

## Steps to Reproduce the Problem

My workflow replay code:
```go
import (
	"go.temporal.io/sdk/worker"
	...
)

func TestFulfillmentWorkflowReplay(t *testing.T) {
	t.Parallel()

	replayer := worker.NewWorkflowReplayer()

	p := telemetry.Params{
		Lifecycle: fakeLifecycle{},
		Logger:    zap.NewNop().Sugar(),
		Config:    config.Config{Telemetry: config.TelemetryConfig{}},
	}

	tm, err := telemetry.New(p)
	require.NoError(t, err)

	l, _ := definitions.NewLibrary(definitions.Deps{
		Logger:    zap.NewNop().Sugar(),
		Telemetry: tm,
	})
	replayer.RegisterWorkflow(l.FulfillmentWorkflow)

	err = replayer.ReplayWorkflowHistoryFromJSONFile(nil, "testdata/fulfillment_workflow_20240816.json")
	require.NoError(t, err)
}
```

Happy to attach the full workflow history files that reproduce the success and failure test runs; please let me know.

## Specifications

  - Version: Go SDK version 1.28.1
  - Platform: Temporal Cloud


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-16 14:53:23.000 UTC</summary>

Hi Albert, Could you please open a support ticket and someone from our support team can reach out. We do not use github issue for cloud support.

https://docs.temporal.io/cloud/support#zendesk-account

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2024-08-16 20:58:43.000 UTC</summary>

Will do, thanks for the prompt response, @Quinn-With-Two-Ns!

</details>


---

<a id="1593"></a>

### #1593: Consider potential range-over-func APIs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1593 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-08-15 22:59:01.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-16 14:01:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
With Go 1.23 range-over-func was brought into the language allowing the implementation of iterator like patterns

**Describe the solution you'd like**
Consider what APIs we can add to the Go SDK to take advantage of range-over-func

**Additional context**
https://go.dev/wiki/RangefuncExperiment

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-15 23:01:33.000 UTC</summary>

## Possible APIS

### Workflow

* Workflow channel iterator
* Deterministic map iterator

### Client

* List workflow and schedule iterators

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-08-16 14:01:25.000 UTC</summary>

The main place (async) iterators are used in other SDKs is listing workflows, listing schedules, and iterating history events. So would add "iterating history events" to your list.

Reactions: ðŸ‘ 1

</details>


---

<a id="1549"></a>

### #1549: Customize buckets per metric

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1549 |
| **State** | CLOSED |
| **Author** | Shubhamurkade (Shubham Urkade) |
| **Created** | 2024-07-17 06:12:06.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-31 02:01:26.000 UTC |
| **Closed** | 2024-08-31 02:01:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to customize the buckets per metric. The only way supported right now is with Tally, which will customize the buckets for all the metrics.

Please refer to the discussion on [this](https://community.temporal.io/t/increase-bucket-size-of-metrics-in-golang/12758) thread for more context. 

**Describe the solution you'd like**
Say, I'm using a metric `temporal_activity_execution_latency_bucket` and would like more buckets than the default number of buckets. Right now, it's not possible to increase the number of buckets only for this metric. The solution linked in the thread referenced in the previous section will increase the number of buckets for all the metrics. I would like to change the buckets only for the particular metric.

**Describe alternatives you've considered**
The only alternative will change the buckets for all metrics which isn't preferable.

**Additional context**
NA


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-17 15:09:15.000 UTC</summary>

`temporal_activity_execution_latency_bucket ` is a Timer,  in Tally I believe the only way to configure Timer histogram is to use `Reporter.RegisterTimer`

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-31 02:01:25.000 UTC</summary>

Closing as this configuration is part of the scope

</details>


---

<a id="1535"></a>

### #1535: Temporal Opentelemetry interceptor to use (and export) new temporal header Carrier interface

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1535 |
| **State** | CLOSED |
| **Author** | mcbadger88 |
| **Created** | 2024-07-03 03:55:59.000 UTC (1y 6m ago) |
| **Updated** | 2024-09-06 04:26:28.000 UTC |
| **Closed** | 2024-09-06 04:26:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When writing our own custom interceptor, we would like to be able to load/extract Opentelemetry data into the temporal headers using a common function that the temporal interceptor uses. This way we are guaranteed to get trace context propagation even if some components are using temporal's own interceptor vs some are using our custom interceptor.

**Describe the solution you'd like**
- Add a "Carrier" implementation that parses/loads into the temporal headers (e.g. [PR](https://github.com/temporalio/sdk-go/pull/1534))
- Export it for other libraries to use
- Use it in the temporal interceptors ([here](https://github.com/temporalio/sdk-go/blob/master/contrib/opentelemetry/tracing_interceptor.go#L146.)) From what I can tell this will require some small refactoring of the parent function too ([relevant comment](https://github.com/temporalio/sdk-go/pull/1534#discussion_r1663437892))


**Describe alternatives you've considered**
- Define the carrier locally to our private enterprise product. (we currently do this)
- Add to the opentelemetry contrib repo (they advise against this as the code has temporal dependency and is more reliably maintained close to its relevant repository)
- Make my own opensource library (do not have resources to maintain, also my company are not allowed to use personal or untrusted libraries)

**Additional context**
Tagging some of the authors who may have context or pointers, if I have the wrong people please let me know how best to tag the temporal opentelemetry experts. Appreciate your thoughts! @cretz @jvonfricken 

This is an issue raised off the back of some discussions in this PR https://github.com/temporalio/sdk-go/pull/1534, apologies that I did not see the comment to raise an issue first until I had already raised it.


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-07-03 13:13:33.000 UTC</summary>

I see @Quinn-With-Two-Ns is already looking at the PR, will defer to him. In general while Temporal has an interceptor that that uses propagation to populate a single internal header, we encourage users to write their own interceptors to do what they need if they need something beyond that. We can discuss options on the OTel interceptor if it needs to have something configured.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-06 04:26:28.000 UTC</summary>

Marking as closed based on the discussion in the PR

</details>


---

<a id="1527"></a>

### #1527: Stop checking that context is cancelled when a `CanceledError` is received

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1527 |
| **State** | CLOSED |
| **Author** | dmateusp (Daniel Mateus Pires) |
| **Created** | 2024-06-21 15:22:00.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-21 17:45:51.000 UTC |
| **Closed** | 2024-06-21 16:56:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Is your feature request related to a problem? Please describe.

I have an activity that checks some external condition, and doesn't run if that external condition is not fulfilled.

In that scenario I would like to see it as cancelled in Temporal, so I tried to return `temporal.NewCanceledError(...)` from within the activity.

However, temporal is currently wrapping my error in `fmt.Errorf("unexpected activity cancel error: %w", err)`, and I think that's happening [here](https://github.com/temporalio/sdk-go/blob/3ceb659a84817915261d0577e4627e0d8dff0916/internal/internal_task_pollers.go#L1155C9-L1155C64). This actually causes my error to be retried as any other error would.

I think this is happening because I'm trying to return that cancel error from an activity directly instead of having a workflow initiate an activity context cancel, see the check [here](https://github.com/temporalio/sdk-go/blob/3ceb659a84817915261d0577e4627e0d8dff0916/internal/internal_task_handlers.go#L2186)

## Describe the solution you'd like
I would like temporal to stop checking that the context was cancelled when handling CanceledError

## Describe alternatives you've considered
Right now I'm going to have to return a non-retryable error, but this stop scenario is not technically an error.




#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-06-21 15:50:15.000 UTC</summary>

> In that scenario I would like to see it as cancelled in Temporal

Activity cancellation can only result from the server issuing a cancellation, an activity cannot appear cancelled just by returning cancelled. This is Temporal platform/server behavior and not Go SDK (it will reject SDK attempts to mark activities as cancelled if a cancellation wasn't requested server side, which is why SDK must convert it to a normal error).

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>dmateusp</strong> commented on 2024-06-21 16:56:52.000 UTC</summary>

thanks @cretz for the explanation, I'll close this issue and keep using a non-retryable error 

Reactions: ðŸ‘ 1

</details>


---

<a id="1526"></a>

### #1526: Starting DevServer with UI Enabled May Fail Due to Invalid Port Number

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1526 |
| **State** | CLOSED |
| **Author** | tomwheeler (Tom Wheeler) |
| **Created** | 2024-06-20 22:38:16.000 UTC (1y 6m ago) |
| **Updated** | 2025-02-04 18:13:40.000 UTC |
| **Closed** | 2025-02-04 18:13:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

I would expect that if I start the [Dev Server](https://pkg.go.dev/go.temporal.io/sdk@v1.27.0/testsuite#StartDevServer), a valid functional test would pass regardless of how the DevServerOptions' `EnableUI` attribute was set.

## Actual Behavior

A [functional test](https://github.com/temporalio/reference-app-orders-go/blob/4546fb2a41cacd84bd4158728808aa74cd188e8f/app/test/order_test.go) written by a co-worker [started](https://github.com/temporalio/reference-app-orders-go/blob/4546fb2a41cacd84bd4158728808aa74cd188e8f/app/test/order_test.go#L76-L81) the Dev Server, setting `EnableUI` to `true`. I found that this caused a failure in at least one case because the SDK calculated an invalid (out of range) port number.

## Steps to Reproduce the Problem

I cannot reliably reproduce the problem and would imagine that it happens quite infrequently, but here's the output from a time when it failed:

```
go test -cover ./app/test -coverpkg ./... -args -test.gocoverdir=D:/a/tora-for-ci-testing/tora-for-ci-testing/.coverage/functional
2024/06/20 19:57:34 INFO  Downloading temporal CLI Url https://temporal.download/assets/temporalio/cli/releases/download/v0.13.1/temporal_cli_0.13.1_windows_amd64.zip ExePath C:\Users\RUNNER~1\AppData\Local\Temp\temporal-cli-go-sdk-1.26.0.exe
2024/06/20 19:57:36 INFO  Starting DevServer ExePath C:\Users\RUNNER~1\AppData\Local\Temp\temporal-cli-go-sdk-1.26.0.exe Args [server start-dev --ip 127.0.0.1 --port 65146 --namespace default --dynamic-config-value frontend.enableServerVersionCheck=false --dynamic-config-value system.forceSearchAttributesCacheRefreshOnRead=true]
time=2024-06-20T19:57:36.436 level=ERROR msg="can't use default UI port 66146 (65146 + 1000): listen tcp: address 66146: invalid port"
--- FAIL: Test_Order (67.38s)
    order_test.go:81: 
            Error Trace:    D:/a/tora-for-ci-testing/tora-for-ci-testing/app/test/order_test.go:81
            Error:          Received unexpected error:
                            failed connecting after timeout, last error: failed reaching server: last connection error: connection error: desc = "transport: Error while dialing: dial tcp 127.0.0.1:65146: connectex: No connection could be made because the target machine actively refused it."
```

This occurred when testing on Windows, although I doubt that it's limited to that platform. The heart of the problem seems to be the "listen tcp: address 66146: invalid port" message; the part preceding it suggests that it's calculating a port number without considering whether the result exceeds the allowed range. 

## Specifications

  - Version: v1.27.0
  - Platform: Windows 


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-06-21 15:04:47.000 UTC</summary>

I think the solution here is to have a `UIPort` option, and its default should be random if server port is random, +1000 if server port is present, or allow it to be set explicitly.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:13:39.000 UTC</summary>

Closed by https://github.com/temporalio/cli/commit/469e8cf4a2a5743e829a19b209f1fa499665d2cf

</details>


---

<a id="1493"></a>

### #1493: Add a `RawValue` payload converter like exists in other SDKs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1493 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2024-05-28 18:08:08.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-28 18:12:56.000 UTC |
| **Closed** | 2024-05-28 18:12:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It's frequently useful in our own various testing environments to be able to create raw payloads in a workflow without needing to hook up custom data converters. This has come up in both `features` and `cli` testing. Users will likely find it useful for their own testing as well.

See https://github.com/temporalio/sdk-python/blob/aa26503271f58f396abfd381b5e6d496fd6bb2c1/temporalio/common.py#L151 as an example

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-28 18:12:11.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-go/issues/1231

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2024-05-28 18:12:55.000 UTC</summary>

@Quinn-With-Two-Ns Thanks. I literally searched "RawValue" and github returned nothing. Cool.

Reactions: ðŸ˜„ 1

</details>


---

<a id="1492"></a>

### #1492: Make TraceID and SpanID logger keys configurable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1492 |
| **State** | CLOSED |
| **Author** | PatrikValo (pvalo) |
| **Created** | 2024-05-27 21:00:07.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-08 21:04:53.000 UTC |
| **Closed** | 2024-06-08 21:04:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
It would be nice to have an option to configure the logging keys for the tracing interceptor. Currently the keys are hardcoded and it makes it harder to keep the logging consistent with other components in my system. What do you think?

**Describe the solution you'd like**
https://github.com/temporalio/sdk-go/blob/master/contrib/opentelemetry/tracing_interceptor.go
```go
type TracerOptions struct {
        ...
    	LoggingTraceIDKey string 
	LoggingSpanIDKey string
}
```
where by default `LoggingTraceIDKey="TraceID"`, `LoggingSpanIDKey="SpanID"`
```go
func (t *tracer) GetLogger(logger log.Logger, ref interceptor.TracerSpanRef) log.Logger {
	span, ok := ref.(*tracerSpan)
	if !ok {
		return logger
	}

	logger = log.With(logger,
		tracer.options.LoggingTraceIDKey, span.SpanContext().TraceID(),
		tracer.options.LoggingSpanIDKey, span.SpanContext().SpanID(),
	)

	return logger
}
```
or something similar to that.

**Describe alternatives you've considered**
There is probably a workaround to create another interceptor which would basically does the same thing but it would use different keys and it would be responsible for mapping. So there would be all keys (default + custom).


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-06 16:20:31.000 UTC</summary>

All logging keys can also be changed by the `logger` implementation. If your using the standard library  `slog` with our integration you can use  `ReplaceAttr ` in [HandlerOptions](https://pkg.go.dev/golang.org/x/exp/slog#HandlerOptions) to replace any key you want.

Reactions: ðŸ‘ 2

</details>

<details>
<summary><strong>PatrikValo</strong> commented on 2024-06-08 21:04:52.000 UTC</summary>

Thanks!

</details>


---

<a id="1468"></a>

### #1468: Interceptors are skipped for mocked activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1468 |
| **State** | OPEN |
| **Author** | PatrikValo (pvalo) |
| **Created** | 2024-05-11 22:19:11.000 UTC (1y 8m ago) |
| **Updated** | 2025-02-04 18:24:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I would expect that when I test a workflow and I mock an activity with return values like following

```go
s.env.OnActivity(m.MyActivity, mock.Anything).Return(result, nil)
```

all executors defined in the test options

```go
s.env.SetWorkerOptions(
  worker.Options{
	  Interceptors: ...
  },
)
```

are executed.

## Actual Behavior
If I mock nonlocal activity with return values, interceptors are not executed. But for example if I mock the local activity in the tests with defined return values, interceptors are executed as expected. Also if I mock activities (local, nonlocal) with a function

```go
s.env.OnActivity(m.MyActivity, mock.Anything).Return(func (ctx context.Context) (int, error) {
    return result, nil
})
```

it works as expected and interceptors are executed.

## Steps to Reproduce the Problem
1. Define interceptors in the test environment
1. Mock non local activity with return values
1. Run workflow test

## Specifications
* Version: 1.26
* Platform: I think problem is on all platforms

## Thoughts
I think the problematic code lives in the `internal/internal_workflow_testsuite.go`
https://github.com/temporalio/sdk-go/blob/c69831e92d7f52e564421fcb99ed49f693c5acbe/internal/internal_workflow_testsuite.go#L1963-L1975
If the mock is a function, we execute the activity executor that calls all interceptors internally. On other if we directly specify return values, we don't use the activity executor and `m.getMockValue(mockRet)` is called. 

There is a workaround to provide a mock function, but it is not comfortable and readable if I have to define a function that just returns values on all places. So theoretically an easy fix could be to just wrap the mocked return values to a function at sdk level and unify the execution paths.



#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-14 17:27:27.000 UTC</summary>

Yes we should be consistent between local and normal activities. I'll have to verify what the Java SDK so we can align across SDKs

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>PatrikValo</strong> commented on 2024-05-14 19:32:48.000 UTC</summary>

Thanks! Meanwhile I have been looking into this issue and I created a commit - https://github.com/PatrikValo/sdk-go/commit/56f2c792a58e50c5568ecfba3f1fb86e0cce1702, I will not open PR for now and I will wait. Please let me know what you find about the java sdk.

</details>


---

<a id="1443"></a>

### #1443: Use of grpc-ecosystem/go-grpc-middleware/retry prevents dead code elimination

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1443 |
| **State** | CLOSED |
| **Author** | nunofgs (Nuno Sousa) |
| **Created** | 2024-04-16 21:54:47.000 UTC (1y 8m ago) |
| **Updated** | 2024-06-13 14:38:17.000 UTC |
| **Closed** | 2024-06-13 14:38:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The `retry` package in grpc-ecosystem/go-grpc-middleware makes use of golang.org/x/net/trace, which in turn calls text/template, which calls `reflect.Value.MethodByName` severely hampering dead code elimination.

You can verify by pointing this with _whydeadcode_:

```
â¯ go build -ldflags=-dumpdep ./cmd |& whydeadcode
reflect.Value.MethodByName reachable from:
	 text/template.(*state).evalField
	 text/template.(*state).evalFieldChain
	 text/template.(*state).evalFieldNode
	 text/template.(*state).evalCommand
	 text/template.(*state).evalPipeline
	 text/template.(*state).walk
	 text/template.(*Template).execute
	 html/template.(*Template).Execute
	 golang.org/x/net/trace.RenderEvents
	 golang.org/x/net/trace.Events
	 golang.org/x/net/trace.EventsÂ·f
	 golang.org/x/net/trace.init.0
	 golang.org/x/net/trace..inittask
	 github.com/grpc-ecosystem/go-grpc-middleware/retry..inittask
	 go.temporal.io/sdk/internal..inittask
	 go.temporal.io/sdk/client..inittask
	 main..inittask
	 runtime.main
	 runtime.mainPC
	 runtime.rt0_go
	 _rt0_arm64_darwin
	 main
	 _
```

Is it possible to work around it?

Also reported in https://github.com/grpc-ecosystem/go-grpc-middleware/issues/704.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-04-17 12:39:38.000 UTC</summary>

> which calls `reflect.Value.MethodByName` severely hampering dead code elimination.

How severely? And is it just this one reflection call or all of reflection? We also use reflection heavily, so unsure if removing that reflection call helps much.

> Is it possible to work around it?

I am not sure it's reasonable to work around this issue with a commonly used dependency like `go-grpc-middleware`. Of course if solved upstream we'd gladly take the benefits.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-13 14:38:17.000 UTC</summary>

Nothing immediate we can do here `go-grpc-middleware` is a dependency of the SDK. if `go-grpc-middleware` resolves https://github.com/grpc-ecosystem/go-grpc-middleware/issues/704 then we would update to that version.

</details>


---

<a id="1420"></a>

### #1420: Support the new versioning API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1420 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-03-12 04:11:52.000 UTC (1y 10m ago) |
| **Updated** | 2024-06-08 02:53:57.000 UTC |
| **Closed** | 2024-06-08 02:53:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The versioning API is changing with new abstractions that need to be supported by the Go SDK.


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-03-12 14:47:40.000 UTC</summary>

@antlai-temporal - does this apply to all SDKs? Maybe an overarching features issue that links to the other SDK issues could be helpful. Or if you're just doing Go first, having that issue so that you can link to the other issues when you create them later would be helpful.

</details>

<details>
<summary><strong>antlai-temporal</strong> commented on 2024-03-12 16:16:32.000 UTC</summary>

I'm starting with Go this sprint so I need an issue. There is an epic ticket but, yes, we will need to create tickets for the other sdks and link them to a publicly visible github issue.

</details>


---

<a id="1386"></a>

### #1386: Activity spans not nested under parent workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1386 |
| **State** | CLOSED |
| **Author** | albertteoh (Albert) |
| **Created** | 2024-02-12 11:17:59.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-13 13:21:09.000 UTC |
| **Closed** | 2024-02-13 08:03:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Workflow activities to be child spans of the workflow that's executing them.

## Actual Behavior

From this screenshot, the "FulfillmentWorkflow" is the workflow that executes the list of activities that you see as "root" spans below it (prefixed with `StartActivity` and `RunActivity`).

Maybe this is expected behaviour given it's executed asynchronously?

<img width="1337" alt="temporal-trace" src="https://github.com/temporalio/sdk-go/assets/26584478/a6dd1b83-69a3-45bb-b5dd-20ad18246b22">


## Steps to Reproduce the Problem

Use the opentelemetry interceptor:

```go
import (
        // ...
        "go.temporal.io/sdk/contrib/opentelemetry"
)

func New(...) {
	intceptor, err := opentelemetry.NewTracingInterceptor(opentelemetry.TracerOptions{
		TextMapPropagator: otel.GetTextMapPropagator(),
	})
	if err != nil {
		return nil, fmt.Errorf("creating tracing interceptor: %w", err)
	}

	tlogger := zapAdapter{logger}
	c, err := client.Dial(client.Options{
                 // ...
		Interceptors:      []interceptor.ClientInterceptor{intceptor},
	})
	if err != nil {
		logger.Fatalf("unable to create client: %s", err)
	}
// ...
}
```

Then the workflow is executed like so:
```go
	workflowOptions := temporal.StartWorkflowOptions{
		ID:        id,
		TaskQueue: taskQueue,
	}
	if _, err := m.client.ExecuteWorkflow(
		ctx,
		workflowOptions,
		FulfillmentWorkflow,
		// input args
	); err != nil {
		return fmt.Errorf("unable to execute workflow, error: %w", err)
	}
```

## Specifications

  - Version:
```
	go.opentelemetry.io/otel/sdk v1.16.0
	go.temporal.io/api v1.23.0
	go.temporal.io/sdk v1.23.1
	go.temporal.io/sdk/contrib/opentelemetry v0.2.0
```


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-02-12 14:17:32.000 UTC</summary>

Hrmm, while there can be span breakage across replays, it shouldn't affect the fact that the overall parent is still the same `StartWorkflow` from the client. Can you confirm that the client is created the same way for all execute-workflow calls and workers in use? Can you alter https://github.com/temporalio/samples-go/tree/main/opentelemetry to replicate your error.

</details>

<details>
<summary><strong>albertteoh</strong> commented on 2024-02-13 08:03:36.000 UTC</summary>

Thanks for the speedy response, @cretz!

After a lot of debugging, it turns out this is not a bug, but rather that the "StartWorkflow:FulfillmentWorkflow" had a pending child span "RunWorkflow:FulfillmentWorkflow" which all the activities depended on.

The reason why the activity spans were orphaned was because the "RunWorkflow:FulfillmentWorkflow" span is only emitted upon completion. I've attached a screenshot of the trace after completing the workflow, showing the child spans happily reunited with their parent ðŸ˜„ 

Your suggestion was very helpful by the way, because it gave me context that activities should correctly be nested under their parent workflow, so it allowed me to invest time into debugging further rather than exiting/giving up too early.

<img width="743" alt="Screenshot 2024-02-13 at 7 00 31â€¯pm" src="https://github.com/temporalio/sdk-go/assets/26584478/66b4959a-4e33-4a0e-b3fa-3c89a7ef6b8f">


Reactions: ðŸ‘ 1

</details>


---

<a id="1372"></a>

### #1372: Document `Client.GetSearchAttributes` doesn't work in cloud

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1372 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-01-31 17:05:03.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-20 15:58:18.000 UTC |
| **Closed** | 2024-02-20 15:58:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Document that `Client.GetSearchAttributes` doesn't work in cloud and is self-hosted only

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-31 17:12:29.000 UTC</summary>

IMO this does't belong in the SDK docs, we don't explicitly document what APIs do and don't work in cloud and more importantly it isn't a property of an SDK version if something is supported in cloud or not. Cloud can add support and make the SDK comment wrong. I think any docs like this belong in https://docs.temporal.io/

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-31 20:58:58.000 UTC</summary>

Agree usually, but I think this is the only high level workflow client call in any of our SDKs that doesn't work in cloud and self-hosted (haven't checked some of those other list calls).

Reactions: ðŸ‘ 1

</details>


---

<a id="1324"></a>

### #1324: Concurrent map writes with ActivityTestEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1324 |
| **State** | CLOSED |
| **Author** | hodbn (hodbn) |
| **Created** | 2023-12-16 20:40:27.000 UTC (2 years ago) |
| **Updated** | 2024-01-03 18:24:53.000 UTC |
| **Closed** | 2024-01-03 18:24:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
A test activity environment can execute multiple activities in parallel.

I'm assuming this is the expected behavior since one can execute multiple parallel activities on a real workflow.
Also, the [docs](https://docs.temporal.io/dev-guide/go/testing#test-activities) doesn't specify this limit.

## Actual Behavior
A test activity environment might crash (race) when executing multiple activities in parallel.
The cause looks to be [concurrent reads and writes](https://github.com/temporalio/sdk-go/blob/5d5b9c4c44a3f00df55958147b052d1e27233a4f/internal/internal_workflow_testsuite.go#L1340-L1351) to a map in `testWorkflowEnvironmentImpl`.
```
playground â€º go test ./...
?       github.com/example/playground/helloworld       [no test files]
?       github.com/example/playground/helloworld/starter       [no test files]
?       github.com/example/playground/helloworld/worker        [no test files]
fatal error: concurrent map read and map write

goroutine 88 [running]:
go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).getActivityHandle(0x1400029a1e0, {0x1400038073e, 0x2}, {0x105777eaf?, 0x10577b469?})
        /Users/user/.go/pkg/mod/go.temporal.io/sdk@v1.25.1/internal/internal_workflow_testsuite.go:1286 +0xa8
go.temporal.io/sdk/internal.(*activityExecutorWrapper).Execute(0x1400038d7e0, {0x105aa5ef8?, 0x14000412070}, 0x0)
        /Users/user/.go/pkg/mod/go.temporal.io/sdk@v1.25.1/internal/internal_workflow_testsuite.go:1623 +0x118
go.temporal.io/sdk/internal.(*activityTaskHandlerImpl).Execute(0x140003d5420, {0x10577b47f, 0x16}, 0x140003e4210)
        /Users/user/.go/pkg/mod/go.temporal.io/sdk@v1.25.1/internal/internal_task_handlers.go:2084 +0x6f4
go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeActivity(0x1400029a1e0, {0x105930b60?, 0x105a96a00?}, {0x0, 0x0, 0x0})
        /Users/user/.go/pkg/mod/go.temporal.io/sdk@v1.25.1/internal/internal_workflow_testsuite.go:603 +0x49c
go.temporal.io/sdk/internal.(*TestActivityEnvironment).ExecuteActivity(0x140003c09c0?, {0x105930b60?, 0x105a96a00?}, {0x0?, 0x1533bc000000000?, 0x6577fa36?})
        /Users/user/.go/pkg/mod/go.temporal.io/sdk@v1.25.1/internal/workflow_testsuite.go:191 +0x2c
github.com/example/playground_test.TestSomething.func1(0x0?)
        /Users/user/git/playground/main_test.go:23 +0x48
testing.tRunner(0x140003c09c0, 0x1400038c850)
        /opt/homebrew/Cellar/go/1.21.4/libexec/src/testing/testing.go:1595 +0xe8
created by testing.(*T).Run in goroutine 19
        /opt/homebrew/Cellar/go/1.21.4/libexec/src/testing/testing.go:1648 +0x33c

```

## Steps to Reproduce the Problem

  1. Run this with `go test ./...`:
```golang
// main_test.go
package main_test

import (
	"context"
	"fmt"
	"testing"

	"go.temporal.io/sdk/testsuite"
)

func NopActivity(ctx context.Context) error {
	return nil
}

func TestSomething(t *testing.T) {
	testSuite := &testsuite.WorkflowTestSuite{}
	env := testSuite.NewTestActivityEnvironment()
	env.RegisterActivity(NopActivity)

	for i := 0; i < 100; i++ {
		t.Run(fmt.Sprintf("iter-%d", i), func(t *testing.T) {
			t.Parallel()
			_, _ = env.ExecuteActivity(NopActivity)
		})
	}
}
```
  2. Most times you'll get a crash. You can play with the number of iterations.

## Specifications

  - Version: go sdk `v1.25.1`
  - Platform: macOS


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-16 20:55:21.000 UTC</summary>

The `ActivityTestEnvironment` is not designed to be thread safe. There is no documentation that says it is OK to use in multiple go routines. In the sdk-go package I would assume an API is not thread safe unless explicitly documented.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-03 18:24:53.000 UTC</summary>

Closing as this is expected behaviour, feel free to reopen if you have additional questions 

</details>


---

<a id="1322"></a>

### #1322: Worker autotuning - Pollers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1322 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-12-15 15:58:18.000 UTC (2 years ago) |
| **Updated** | 2025-08-25 15:44:21.000 UTC |
| **Closed** | 2025-08-25 15:44:21.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

https://github.com/temporalio/features/issues/334


---

<a id="1304"></a>

### #1304: Add GetName() func to Signal Chanel to return human readable name

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1304 |
| **State** | CLOSED |
| **Author** | ilewin |
| **Created** | 2023-11-21 19:17:45.000 UTC (2y 1m ago) |
| **Updated** | 2024-07-09 03:13:58.000 UTC |
| **Closed** | 2024-07-09 03:13:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
While dynamically creating signal channels and assigning callback functions to it, it is not possible to identify the channel name in the callback funciton

**Describe the solution you'd like**
adding a GetName() string func to the Chanel interface 




#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-27 16:35:01.000 UTC</summary>

Why can't you add the name when creating the callback? Normal Go channels don't support a name so I am not sure Temporal channels would need such a functionality

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-27 16:44:15.000 UTC</summary>

If we did want to include name, probably makes sense to group with other signal info https://github.com/temporalio/temporal/issues/5874

Reactions: ðŸ‘ 1

</details>


---

<a id="1275"></a>

### #1275: Inconsistent Activity Alias Mapping Behavior Across Multiple Task Queues

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1275 |
| **State** | CLOSED |
| **Author** | MMN3003 (Mohsen Malvandy Niko) |
| **Created** | 2023-10-21 11:04:51.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-04 17:01:55.000 UTC |
| **Closed** | 2023-11-04 17:01:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The `getActivityAlias` function should not be called or should return an appropriate response when invoked for an activity that belongs to a different task queue. It should only provide an alias mapping for activities that are registered within the same task queue context. This behavior ensures that activity alias mapping is confined to the specific task queue where the activity is registered and does not provide an alias for activities in different task queues.

## Actual Behavior
Currently, the `getActivityAlias` function is called for activities regardless of the task queue they belong to. It provides alias mapping even when the activity is invoked from a different task queue context, which may lead to incorrect alias mapping and behavior that does not align with the original task queue registration. This can result in unexpected or incorrect behavior when trying to retrieve alias information for activities that are not associated with the current task queue.


## Steps to Reproduce the Problem

  1.Create two distinct task queues, let's call them "QueueA" and "QueueB," within your Temporal application.
  2.Register an activity with an alias in each of these task queues. For example
  ```
  // Activity registration in QueueA (workerA) 
  worker.RegisterActivityWithOptions(ActivityA, activity.RegisterOptions{Name: "Name"})
  
    // Activity registration in QueueB (workerB) 
  worker.RegisterActivityWithOptions(Name, activity.RegisterOptions{Name: "OtherName"})
  ```
  3.In your Temporal workflow, initiate an activity invocation from one task queue but specify an activity that belongs to a different task queue. For example, invoke "ActivityA" from "QueueA" with alias name in a workflow that is running in "QueueB."
  ```
  // workflow with original task queue "QueueB"
  activityOptions := &workflow.ActivityOptions{
                ...
		TaskQueue:  "QueueA",
		...
	}
	ctx = workflow.WithActivityOptions(ctx, *activityOptions)
	workflow.ExecuteActivity(ctx, "Name", data).Get(ctx, nil)
  ```
`getActivityAlias` in  `ExecuteActivity` returns  `OtherName` as alias!!

  - Version: go.temporal.io/sdk v1.25.1
  - Platform: linux


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-10-23 13:37:01.000 UTC</summary>

Duplicate of #845.

Yes, we use the workflow's registry to lookup activity aliases. We can't really change this behavior without potentially breaking people. So we created #850 for this situation. We recommend you disable aliasing via the `DisableRegistrationAliasing` option.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-04 17:01:55.000 UTC</summary>

Closing as duplicate of https://github.com/temporalio/sdk-go/issues/845

</details>


---

<a id="1273"></a>

### #1273: [Testsuite] Registering a Workflow and Activity with the same name and mocking  the activity causes issues

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1273 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-18 14:26:18.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-04 17:02:41.000 UTC |
| **Closed** | 2023-11-04 17:02:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Registering an activity and workflow with the same name is fine

## Actual Behavior
Registering an activity and workflow with the same name and trying to mock the activity causes the test suite to error with unexpected calls.

## Steps to Reproduce the Problem
This test will panic
```
s := testsuite.WorkflowTestSuite{}
env := s.NewTestWorkflowEnvironment()

expectedInput := activities.ActivityInput{}
env.OnActivity(activities.CoolTricks, mock.Anything, expectedInput).
	Return(activities.ActivityOutput{}, nil)

workflowInput := WorkflowInput{}

env.ExecuteWorkflow(CoolTricks, workflowInput)
assert.True(t, env.IsWorkflowCompleted())

var result *WorkflowOutput
err := env.GetWorkflowResult(&result)

assert.Error(t, err)
assert.Nil(t, result)
```

https://temporalio.slack.com/archives/CTDTU3J4T/p1697581733270889


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-10-18 15:21:37.000 UTC</summary>

Likely duplicate of #887

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-04 17:02:41.000 UTC</summary>

Closing as duplicate of https://github.com/temporalio/sdk-go/issues/887

</details>


---

<a id="1270"></a>

### #1270: Clean up internal/context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1270 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-16 15:55:32.000 UTC (2y 2m ago) |
| **Updated** | 2023-12-16 05:29:07.000 UTC |
| **Closed** | 2023-12-16 05:29:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`internal/context.go` has some tech debt that should be cleaned up including

* Commented out code that should either be deleted or enabled https://github.com/temporalio/sdk-go/blob/269b55b8d184849209c6973fe913a427fafc07e3/internal/context.go#L348
* Incorrect use of `go` in a workflow context (this code appears to be dead, but should be removed regardless) https://github.com/temporalio/sdk-go/blob/269b55b8d184849209c6973fe913a427fafc07e3/internal/context.go#L239




#### Comments (2)

<details>
<summary><strong>tharun208</strong> commented on 2023-12-13 07:11:15.000 UTC</summary>

@Quinn-With-Two-Ns @Quinn-With-Two-Ns I like to work on this. Before, making a PR I have a question regarding the cleanup of incorrect use of the go routine, what should we do there after the cleanup? I am thinking of adding a `return` and end the function.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-14 00:40:57.000 UTC</summary>

@tharun208 that be great! When I last reviewed the code I conclude that the `else` statement was never satisfied since `parentCancelCtx` should always return true. If we can verify that then we can probably just add a panic because that is an undefined state.

Reactions: ðŸ‘ 1

</details>


---

<a id="1216"></a>

### #1216: Worker autotuning - PoC

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1216 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-08-29 14:00:05.000 UTC (2y 4m ago) |
| **Updated** | 2023-11-07 15:59:39.000 UTC |
| **Closed** | 2023-11-07 15:59:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Temporal worker should be able to autotune themselves based on some set of rules

**Additional context**
https://docs.temporal.io/dev-guide/worker-performance



#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-08-29 14:26:56.000 UTC</summary>

I do not believe this is a Go-specific request. This is a general feature for SDKs. We may need to track via a features issue (but can keep this issue here of course for Go-specific impl).

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-29 14:40:11.000 UTC</summary>

This issue is to track the Go Specific implementation 

Reactions: ðŸ‘ 1

</details>


---

<a id="1201"></a>

### #1201: RespondActivityTaskFailedRequest add result field

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1201 |
| **State** | CLOSED |
| **Author** | ppanphper |
| **Created** | 2023-08-15 06:49:28.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-15 19:59:59.000 UTC |
| **Closed** | 2023-08-15 19:59:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]


It is hoped that when the execution activity/workflow fails, the result can also be obtained, so that some special errors can obtain some information from the result



**Describe the solution you'd like**
A clear and concise description of what you want to happen.

RespondActivityTaskFailedRequest.Result = RespondActivityTaskCompletedRequest.Result

```
var result ActivityRes
err := workflow.ExecuteActivity(ctx, Activity, name).Get(ctx, &result)
// when err != nil, result has value
if err != nil {
logger.Error("Activity failed.", "Error", err, "Result", result)

// use result do some other things

return result, err
}
```

```
func (d *decodeFutureImpl) Get(ctx Context, valuePtr interface{}) error {
....
	//if d.futureImpl.err != nil || d.futureImpl.value == nil || valuePtr == nil {
	if d.futureImpl.value == nil || valuePtr == nil {
		return d.futureImpl.err
	}
...
}
func (f *futureImpl) Get(ctx Context, valuePtr interface{}) error {
...
	//if f.err != nil || f.value == nil || valuePtr == nil {
        if f.value == nil || valuePtr == nil {
		return f.err
	}
...
}
```

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
![image](https://github.com/temporalio/sdk-go/assets/6057923/23a2c0bd-4d75-4520-973d-b66d97de71ff)


![image](https://github.com/temporalio/sdk-go/assets/6057923/19de29b2-9f26-46fb-8939-1c3ad7b286d1)

![image](https://github.com/temporalio/sdk-go/assets/6057923/ce80d141-e7c7-4f6a-9997-949556c6ff87)

![image](https://github.com/temporalio/sdk-go/assets/6057923/295d3eae-8922-42eb-a0dc-57fbd96cf675)


#### Comments (2)

<details>
<summary><strong>ppanphper</strong> commented on 2023-08-15 09:29:16.000 UTC</summary>

I found the details of NewApplicationError which solved my needsã€‚But it's a bit complicated to use

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-15 19:59:47.000 UTC</summary>

In Temporal a workflow or an activity can either return a result or an error. This is for multiple reasons including but not limited to: 
* Temporal supports other languages than Go, including cross calling between them, and they have no way to return a result and failure
* Historically it has been the behavior and changing it would be a breaking changes to existing code 
* Not all errors returned from an activity result in `RespondActivityTaskFailedRequest` such as a cancelled error.
* In an error condition most of the time the result is meaningless/assumed invalid. Returning an error and a value that are both valid is a special case.

If you want to return some data with your error you should use details in NewApplicationError. That deals with all the problems listed above.

Reactions: ðŸ‘ 1

</details>


---

<a id="1160"></a>

### #1160: TestWorkflowEnvironment.XByID does not work with primary ID after primary ID updated

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1160 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-07-13 21:09:49.000 UTC (2y 6m ago) |
| **Updated** | 2023-07-17 17:44:22.000 UTC |
| **Closed** | 2023-07-17 17:44:22.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

Calling `SetStartWorkflowOptions` with an ID and then `SignalWorkflowByID` with that ID in delayed callback should work.

## Actual Behavior

We set the `runningWorkflows` map to the default ID and don't update the map on `SetStartWorkflowOptions` like we should. So it appears as not found.


---

<a id="1145"></a>

### #1145: Err on setup: concurrent map read and map write

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1145 |
| **State** | CLOSED |
| **Author** | shojaeix (Amin Shojaei) |
| **Created** | 2023-06-20 08:59:17.000 UTC (2y 6m ago) |
| **Updated** | 2023-07-29 17:03:40.000 UTC |
| **Closed** | 2023-07-29 17:03:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'm initiating a Temporal test server in the tests. 
Before each test, I create a server, and after each test, I close that server. 
So the server is in its and closes a few times. 

## Expected Behavior
Success or a standard error!

## Actual Behavior
Failing due to concurrent read/write from the map

## Log trace 
```

goroutine 723 [running]:
github.com/temporalio/tchannel-go/json.Register.func1({0x339d218, 0xc0007ee030}, 0xc00037e600)
	/home/runner/go/pkg/mod/github.com/temporalio/tchannel-go@v1.22.1-0.20220818200552-1be8d8cffa5b/json/handler.go:100 +0x4e
github.com/temporalio/tchannel-go.HandlerFunc.Handle(0xc00026d0e0?, {0x339d218?, 0xc0007ee030?}, 0x2143900?)
	/home/runner/go/pkg/mod/github.com/temporalio/tchannel-go@v1.22.1-0.20220818200552-1be8d8cffa5b/handlers.go:49 +0x2f
github.com/temporalio/tchannel-go.(*handlerMap).Handle(0x444f31?, {0x339d218, 0xc0007ee030}, 0xc00037e600)
	/home/runner/go/pkg/mod/github.com/temporalio/tchannel-go@v1.22.1-0.20220818200552-1be8d8cffa5b/handlers.go:123 +0x21c
github.com/temporalio/tchannel-go.channelHandler.Handle({0x22b0a80?}, {0x339d218, 0xc0007ee030}, 0xc00037e600)
	/home/runner/go/pkg/mod/github.com/temporalio/tchannel-go@v1.22.1-0.20220818200552-1be8d8cffa5b/handlers.go:131 +0x5a
github.com/temporalio/tchannel-go.(*Connection).dispatchInbound(0xc00074a580, 0x0?, 0x0?, 0xc00037e600, 0xc000402940?)
	/home/runner/go/pkg/mod/github.com/temporalio/tchannel-go@v1.22.1-0.20220818200552-1be8d8cffa5b/inbound.go:203 +0x454
created by github.com/temporalio/tchannel-go.(*Connection).handleCallReq
	/home/runner/go/pkg/mod/github.com/temporalio/tchannel-go@v1.22.1-0.20220818200552-1be8d8cffa5b/inbound.go:125 +0xe2a
```
## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version: `v1.22.1` (check the log trace)
  - Platform: 


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-06-20 12:43:13.000 UTC</summary>

This looks like the same `tchannel-go` concurrent map write issue as https://github.com/temporalio/temporal/issues/4000. This is a server-side issue I am afraid.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-29 17:03:39.000 UTC</summary>

Closing as duplicate  of https://github.com/temporalio/temporal/issues/4000

</details>


---

<a id="1144"></a>

### #1144: Non-determinism while replaying mutable side-effect behind workflow versioning 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1144 |
| **State** | CLOSED |
| **Author** | nitesh237 (Nitesh Gupta) |
| **Created** | 2023-06-16 19:53:18.000 UTC (2y 6m ago) |
| **Updated** | 2023-06-23 17:59:23.000 UTC |
| **Closed** | 2023-06-23 17:59:23.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior
When replaying the mutable side-effect behind workflow versioning, the command should be generated in the same exact order as they were generated during the execution.

## Actual Behavior
We are seeing non-determinism error while replaying due to missing mutable-side effect marker.

```
PanicError: lookup failed for scheduledEventID to activityID: scheduleEventID: 13, activityID: 13 
process event for example-task-queue [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_command_state_machine.go:455
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0x14001a315e0, {0x14001507798, 0x2}, 0x40?)
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_command_state_machine.go:1038 +0xf0
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0x1400089ef90, 0x14001a29b00, 0x20?, 0x0)
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_event_handlers.go:1031 +0x248
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0x140015fd3b0, 0x1400137c600)
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_task_handlers.go:962 +0xed0
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0x14000cd6c30, 0x1400137c600, 0x140018daa20)
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_task_handlers.go:780 +0x364
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0x14000ccc900, 0x1400137c600)
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_task_pollers.go:329 +0x2d0
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0x14000ccc900, {0x106c9dac0?, 0x1400137c600})
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_task_pollers.go:302 +0x70
go.temporal.io/sdk/internal.(*baseWorker).processTask(0x14000ca28c0, {0x106c9d640, 0x140019515a0})
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_worker_base.go:440 +0x15c
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
	/Users/nitesh/go/pkg/mod/go.temporal.io/sdk@v1.22.2/internal/internal_worker_base.go:334 +0x98
```


## Steps to Reproduce the Problem
Below sample workflow reproduces the non-determinism issue.
```
// Workflow is a Hello World workflow definition.
func Workflow(ctx workflow.Context, name string) (string, error) {
	uid := ""
	logger := workflow.GetLogger(ctx)
	logger.Info("HelloWorld workflow started", "name", name)

	v := workflow.GetVersion(ctx, "mutable-side-effect-bug", workflow.DefaultVersion, 1)
	if v == 1 {
		var err error
		uid, err = generateUUID(ctx)
		if err != nil {
			logger.Error("failed to generated uuid", "Error", err)
			return "", err
		}

		logger.Info("generated uuid", "uuid-val", uid)
	}

	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	var result string
	err := workflow.ExecuteActivity(ctx, Activity, name).Get(ctx, &result)
	if err != nil {
		logger.Error("Activity failed.", "Error", err)
		return "", err
	}

	logger.Info("HelloWorld workflow completed.", "result", result)

	return uid, nil
}

func generateUUID(ctx workflow.Context) (string, error) {
	var generatedUUID string

	err := workflow.MutableSideEffect(ctx, "generate-random-uuid", func(ctx workflow.Context) interface{} {
		return uuid.NewString()
	}, func(a, b interface{}) bool {
		return a.(string) == b.(string)
	}).Get(&generatedUUID)
	if err != nil {
		return "", err
	}

	return generatedUUID, nil
}

func Activity(ctx context.Context, name string) (string, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("Activity", "name", name)
	return "Hello " + name + "!", nil
}
```

## Specifications
As part of [this](https://github.com/temporalio/sdk-go/pull/809/files#diff-2977c91b9b6dd9d4ccf4c150ad6cb4b1c360334b5602cb3324d87769d7fe51e0R701) change, we are only recording side effect marker command while replaying based on lookup in `wc.mutableSideEffectsRecorded` map since mutable side-effect doesn't leave a marker in the history always. 
This works in a normal scenario, however, there is a catch, it seems while replaying `workflow.GetVersion` doesnâ€™t generate a command [explicitly](https://github.com/temporalio/sdk-go/blob/ae9ed7bebea6d1a371f20417f053c5d28730e365/internal/internal_event_handlers.go#L775) (donâ€™t know the reason). This is leading to a wrong lookup in `wc.mutableSideEffectsRecorded` specifically due to the wrong value in `wc.commandsHelper.nextCommandEventID`. This is leading to missing marker command while replaying.

  - Version:
  1.22.2, however, the bug seems to exist in 1.23.0 as well.
  



---

<a id="1134"></a>

### #1134: OnSignalExternalWorkflow doesn't function when signaling child workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1134 |
| **State** | CLOSED |
| **Author** | jvonfricken (Joshua VonFricken) |
| **Created** | 2023-06-07 19:39:46.000 UTC (2y 7m ago) |
| **Updated** | 2023-07-18 22:32:40.000 UTC |
| **Closed** | 2023-07-18 22:32:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I would expect that OnSignalExternalWorkflow would be triggered by calling `workflow.SignalExternalWorkflow` with matching params.

## Actual Behavior
However, whenever the target of `workflow.SignalExternalWorkflow` is a child workflow started with `env.OnWorkflow`, it is now considered a running workflow, and mock calls will not be triggered, but rather it will attempt to signal this workflow. This will fail to signal and also not register the call to the mocked `env.OnSignalExternalWorkflow`.

Essentially, it's impossible to correctly assert that `SignalExternalWorkflow` was called if the target workflow was first mocked with env.OnWorkflow.

This may be considered a feature request, but this behavior doesn't seem like it's the intended way things should be working?



#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-10 05:22:13.000 UTC</summary>

From our docs on [OnSignalExternalWorkflow ](https://pkg.go.dev/go.temporal.io/sdk/internal#TestWorkflowEnvironment.OnSignalExternalWorkflow)

```
TestWorkflowEnvironment handles sending signals between the workflows that are started from the root workflow. For example, sending signals between parent and child workflows. Or sending signals between 2 child workflows. However, it does not know what to do if your tested workflow code is sending signal to external unknown workflows. In that case, you will need to setup mock for those signal calls. Some examples of how to setup mock:
```

So  it is intended that signaling a child workflow does not trigger `OnSignalExternalWorkflow `.I don't think it is correct to call the mock on `OnSignalExternalWorkflow` . If the test environment is aware of the workflow being signaled then the test environment knows what will happen on the signal request, so there is no need to mock it. Mocking it just opens up potential ways users can write inconsistent test code


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-18 22:32:40.000 UTC</summary>

Closing since this is the intended behavior 

</details>


---

<a id="1130"></a>

### #1130: Proposal for Accessible `taskLimiter` for Worker Rate Modification

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1130 |
| **State** | CLOSED |
| **Author** | zboralski (Anthony Zboralski) |
| **Created** | 2023-06-07 12:01:35.000 UTC (2y 7m ago) |
| **Updated** | 2023-07-18 22:48:50.000 UTC |
| **Closed** | 2023-07-18 22:44:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
In the existing design, the `taskLimiter` of an activity, responsible for the worker's rate limit, remains inaccessible. This restricts our capability to adjust the worker's rate dynamically in line with shifting workloads or requirements.

**Describe the solution you'd like**
I suggest making the `taskLimiter` accessible, thereby enabling developers to modify the worker's rate directly. Upon examining the SDK and `rate.Limiter` code, it seems that using this approach is safe. The `rate.Limiter` uses a mutex to ensure thread safety when adjusting limits.

**Describe alternatives you've considered**
Maintaining rate limits using the external methods or restarting workers is an option. However, these methods lacks flexibility and might not be the best fit for managing varying workloads.

**Additional context**
By granting access to `taskLimiter`, we offer granular control over the worker's rate limit. This is notably beneficial for applications with fluctuating workloads. I recommend trying the function highlighted below and examining `rate.Limiter`'s implementation to verify the safety and efficiency of this proposed change. The internals of `rate.Limiter` are well-guarded by a mutex, ensuring secure adjustments to the rate limit.

Included is a function, GetLimiter(), which can retrieve the taskLimiter from a worker.Worker instance. This function uses reflection to access the internal taskLimiter field of the worker.Worker instance. It's designed to safely navigate various scenarios, including nil workers, non-struct workers, and non-addressable fields. Please note that this function serves as a workaround to demonstrate the importance and potential usage of making taskLimiter accessible, and isn't a recommended long-term solution.

```go
package main

import (
	"fmt"
	"reflect"
	"unsafe"

	"go.temporal.io/sdk/worker"
	"golang.org/x/time/rate"
)

func GetLimiter(w worker.Worker) (*rate.Limiter, error) {
	if w == nil {
		return nil, fmt.Errorf("Worker is nil")
	}

	// Extract the value from the interface
	value := reflect.ValueOf(w)
	if value.Kind() == reflect.Interface && !value.IsNil() {
		value = value.Elem()
	}

	// If the value is a pointer, dereference it
	if value.Kind() == reflect.Ptr && !value.IsNil() {
		value = value.Elem()
	}

	// If the value is now a struct, attempt to get the activityWorker field
	if value.Kind() != reflect.Struct {
		return nil, fmt.Errorf("Expected a struct, but got: %s", value.Kind())
	}

	activityWorkerField := value.FieldByName("activityWorker")
	if !(activityWorkerField.IsValid() && activityWorkerField.CanAddr()) {
		return nil, fmt.Errorf("Field 'activityWorker' is not valid or can't be addressed")
	}

	// Create a new Value that treats activityWorker as if it were exported
	activityWorkerField = reflect.NewAt(activityWorkerField.Type(), unsafe.Pointer(activityWorkerField.UnsafeAddr())).Elem()

	// Check if activityWorker is valid and then access baseWorker
	if activityWorkerField.Kind() == reflect.Ptr && !activityWorkerField.IsNil() {
		activityWorkerField = activityWorkerField.Elem()
	}

	if activityWorkerField.Kind() != reflect.Struct {
		return nil, fmt.Errorf("Expected a struct, but got: %s", activityWorkerField.Kind())
	}

	baseWorkerField := activityWorkerField.FieldByName("worker")
	if !(baseWorkerField.IsValid() && baseWorkerField.CanAddr()) {
		return nil, fmt.Errorf("Field 'worker' in 'activityWorker' is not valid or can't be addressed")
	}

	// Create a new Value that treats worker (baseWorker) as if it were exported
	baseWorkerField = reflect.NewAt(baseWorkerField.Type(), unsafe.Pointer(baseWorkerField.UnsafeAddr())).Elem()

	// Check if baseWorker is valid and then access taskLimiter
	if baseWorkerField.Kind() == reflect.Ptr && !baseWorkerField.IsNil() {
		baseWorkerField = baseWorkerField.Elem()
	}

	if baseWorkerField.Kind() != reflect.Struct {
		return nil, fmt.Errorf("Expected a struct, but got: %s", baseWorkerField.Kind())
	}

	taskLimiterField := baseWorkerField.FieldByName("taskLimiter")
	if !(taskLimiterField.IsValid() && taskLimiterField.CanAddr()) {
		return nil, fmt.Errorf("Field 'taskLimiter' in 'baseWorker' is not valid or can't be addressed")
	}

	// Finally return the taskLimiter as *rate.Limiter
	return (*rate.Limiter)(unsafe.Pointer(taskLimiterField.Pointer())), nil
}
```


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-06-07 12:17:43.000 UTC</summary>

This limiter doesn't do what you may think. This doesn't dynamically limit available slots, it just affects time processing after slots are used. The poll has already completed and the timeouts will have already started. Looking at code, this limiter (default governed by `WorkerActivitiesPerSecond` option) pauses the dequeued poll and the next poll from being internally handled, so it leaves two tasks paused even though they were already polled and their timeouts started.

What you need is #569 which is admittedly useful, yes, but challenging to implement.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-18 22:44:55.000 UTC</summary>

Closing, but feel free to  reopen if the above explanation wasn't enough

</details>


---

<a id="1086"></a>

### #1086: Add support for a graceful shutdown of go workers where all activities are finished before the worker returns

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1086 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-04-13 20:07:35.000 UTC (2y 9m ago) |
| **Updated** | 2023-06-29 13:43:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Users want to wait till all their activities are complete before killing their workers.

**Describe the solution you'd like**
Add an option to workers to allow them to wait for all activities to finish before `Stop()` returns for graceful shutdown.

**Describe alternatives you've considered**
Currently go workers have `WorkerStopTimeout` but that is a finite amount of time and the activity context is not cancelled until this timeout is up.



#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-04-20 16:12:39.000 UTC</summary>

see also: https://github.com/temporalio/features/issues/261


</details>

<details>
<summary><strong>eko</strong> commented on 2023-06-29 13:43:08.000 UTC</summary>

Hi,

I confirm that the workers are currently waiting for activities to finish and `WorkerStopTimeout` acts as a timeout.

For instance, if you have an activity that needs ~30mins more to finish and have a `WorkerStopTimeout` set to 1 hour, the worker will stop after 30mins, but in case your activity needs more time, it can wait until 1 hour (the hard shutdown timeout).

</details>


---

<a id="1065"></a>

### #1065: `workflowcheck` command `-V` (version) option does not work

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1065 |
| **State** | CLOSED |
| **Author** | tomwheeler (Tom Wheeler) |
| **Created** | 2023-03-17 15:11:29.000 UTC (2y 9m ago) |
| **Updated** | 2023-06-27 20:58:42.000 UTC |
| **Closed** | 2023-06-27 20:58:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I wanted to see which version of `workflowcheck` I had installed, so I ran `workflowcheck -h` to see the available options. The usage message claims that `-V` will print the version and exit, so I ran this, expecting to see the version number reported.

## Actual Behavior
I got an error `workflowcheck: unsupported flag value: -V=true`

## Steps to Reproduce the Problem

  1. Run `workflowcheck -h` to see the usage message
  2. Observe that the first flag described (`-V`) purports to show the version
  3. Run `workflowcheck -V`
  4. Observe that you see the error listed above instead of the expected version number

## Specifications

  - Version: Unclear (I could reproduce this with an older version installed a few months ago and the current version installed a few minutes ago)
  - Platform: Mac OS 12.6.3 running on a M1 Mac CPU


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-03-20 13:00:23.000 UTC</summary>

This is a Go bug: https://github.com/golang/go/issues/57716. They didn't have proper docs, you need to use `-V=full`. We just need to update `golang.org/x/tools` in our go.mod.

</details>

<details>
<summary><strong>tomwheeler</strong> commented on 2023-03-20 19:20:26.000 UTC</summary>

Like the reporter in the referenced issue #57716, using the `-V=full` option results in a `workflowcheck: open workflowcheck: no such file or directory` message, even though the `workflowcheck` tool is in my executable path. Perhaps I also need to upgrade Go, since I am using the same version (1.19.4) as him.

</details>


---

<a id="1061"></a>

### #1061: Warn on calling an `ExecuteActivity` on a function that takes a `workflow.Context`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1061 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-03-15 16:10:12.000 UTC (2y 10m ago) |
| **Updated** | 2023-04-24 17:50:07.000 UTC |
| **Closed** | 2023-04-24 17:50:07.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
A issue new users run into is they define an activity that takes a `workflow.Context` as a parameter, often just mistyping `context.Context`. The error users get is confusing as it says they aren't passing enough parameters, but if they don't notice the types they expect the context to be injected.

```
reflect: Call with too few input arguments
```

The other issue with passing a `workflow.Context` to an activity is it indicated a potential error if the user did intend to pass the workflow version because it means they may be trying to invoke a workflow function outside a workflow




---

<a id="1052"></a>

### #1052: Fix getVersion search attribute bloat

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1052 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-02-27 18:51:08.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-22 20:14:15.000 UTC |
| **Closed** | 2023-03-22 20:14:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

Java and Go accumulate values in the `TemporalChangeVersion` search attribute every time a `getVersion` call is made.

The search attribute value size is capped, which causes user workflows to get stuck in a WFT failure loop without an easy way of out of this situation. If we hit the size limit we should stop adding new versions to `TemporalChangeVersion` and log a clear error/warning when situation reached.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-02-27 18:58:31.000 UTC</summary>

> If we hit the size limit we should stop adding new versions to TemporalChangeVersion

Or remove the oldest from the list. But either way is fine, we just need to log a clear error/warning when situation reached.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-27 19:06:16.000 UTC</summary>

Yep good point, I noted the requirement to log as well

</details>


---

<a id="1050"></a>

### #1050: Data race in eager activity handling

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1050 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2023-02-21 18:19:31.000 UTC (2y 10m ago) |
| **Updated** | 2023-08-11 17:04:35.000 UTC |
| **Closed** | 2023-08-11 17:04:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Came up while running integ tests for an unrelated change:

```
==================
WARNING: DATA RACE
Read at 0x00c000316a80 by goroutine 4489:
  runtime.raceread()
      <autogenerated>:1 +0x24
  go.temporal.io/sdk/internal.(*eagerActivityExecutor).handleResponse()
      /home/runner/work/sdk-go/sdk-go/internal/internal_eager_activity.go:143 +0x388
  go.temporal.io/sdk/internal.(*workflowTaskPoller).RespondTaskCompleted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:427 +0x765
  go.temporal.io/sdk/internal.(*workflowTaskPoller).RespondTaskCompletedWithMetrics()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:386 +0x924
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:347 +0x64b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:296 +0x93
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:440 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher.func2()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:334 +0x58

Previous write at 0x00c000316a80 by goroutine 4493:
  runtime.racewrite()
      <autogenerated>:1 +0x24
  go.temporal.io/sdk/internal.awaitWaitGroup.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_utils.go:180 +0x39

Goroutine 4489 (running) created at:
  go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:334 +0x10f
  go.temporal.io/sdk/internal.(*baseWorker).Start.func3()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:275 +0x39

Goroutine 4493 (finished) created at:
  go.temporal.io/sdk/internal.awaitWaitGroup()
      /home/runner/work/sdk-go/sdk-go/internal/internal_utils.go:179 +0x131
  go.temporal.io/sdk/internal.(*baseWorker).Stop()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:458 +0xb9
  go.temporal.io/sdk/internal.(*activityWorker).Stop()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:472 +0x149
  go.temporal.io/sdk/internal.(*AggregatedWorker).Stop()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:1074 +0xeb
  go.temporal.io/sdk/test_test.(*IntegrationTestSuite).TearDownTest()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:254 +0x9e
  github.com/stretchr/testify/suite.Run.func1.1()
      /home/runner/go/pkg/mod/github.com/stretchr/testify@v1.8.1/suite/suite.go:157 +0x319
  runtime.deferreturn()
      /opt/hostedtoolcache/go/1.20.1/x64/src/runtime/panic.go:476 +0x32
  testing.tRunner()
      /opt/hostedtoolcache/go/1.20.1/x64/src/testing/testing.go:1576 +0x216
  testing.(*T).Run.func1()
      /opt/hostedtoolcache/go/1.20.1/x64/src/testing/testing.go:1629 +0x47
==================
```

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-02-21 18:46:39.000 UTC</summary>

Yeah, we're mutating that wait group while waiting on it and not sure there's an easy way out short of switching to channels. If https://github.com/temporalio/sdk-go/blob/dc4f883fc62dd266579b73b46e1e49b936291fd5/internal/internal_eager_activity.go#L143 didn't trigger it, https://github.com/temporalio/sdk-go/blob/dc4f883fc62dd266579b73b46e1e49b936291fd5/internal/internal_worker_base.go#L333 probably would. But this is definitely a race. If we receive an activity task (eager or not) during Stop, something could get missed.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-09 14:28:20.000 UTC</summary>

This is happening a lot more know with the introduction of `TestEagerWorkflowDispatchRaceWithWorkerStop`, going to need to fix this


https://github.com/temporalio/sdk-go/actions/runs/5803250659/job/15730996485


</details>


---

<a id="1033"></a>

### #1033: OnUpsertSearchAttributes and OnUpsertMemo unclear about mocking ability

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1033 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-02-08 15:27:12.000 UTC (2y 11m ago) |
| **Updated** | 2025-02-04 18:25:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`OnUpsertSearchAttributes` and `OnUpsertMemo` are just called when their methods are called. They were not developed to return values or return errors unlike many of our other mocks. We need to either:

* Properly document that these are essentially "event listeners" and they cannot affect behavior.
* Have these calls actually mock
  * Probably a bad idea, backwards incompat to have it override the default behavior of adding to the attr maps
  * But we could at least call this first and let the mocker return an error that is returned then to the workflow



#### Comments (2)

<details>
<summary><strong>jPomeranz</strong> commented on 2024-03-28 13:56:42.000 UTC</summary>

Just curious, was an internal consensus reached on the optimal behavior for these calls going forward? I was wondering if this is something we could make a PR for to allow the mocks or whether it's still awaiting an internal decision.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-13 22:31:15.000 UTC</summary>

We should document that `OnUpsertSearchAttributes` and `OnUpsertMemo` are just `event listeners`. Mocking these calls return value in the test environment doesn't make sense since the real environment and the test environment perform identical validation so mocking would just allow users to create discrepancies between a real workflow and one running in the test environment.  

</details>


---

<a id="1011"></a>

### #1011: WorkflowReplayer.ReplayWorkflowHistory doesn't return error when there is a de-serialization problem with the input

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1011 |
| **State** | CLOSED |
| **Author** | ericvg97 (Eric Valls) |
| **Created** | 2023-01-25 15:20:18.000 UTC (2y 11m ago) |
| **Updated** | 2023-02-01 10:28:00.000 UTC |
| **Closed** | 2023-02-01 10:27:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When replaying a workflow for a given history, if the initial input of the workflow can't be de-serialized during the replay, the replayer should return an error

## Actual Behavior
It doesn't return an error. In fact, it doesn't replay the workflow, it just returns without error.
This is problematic because we use the replayer to do a compatibility check on running workflows. Because of this, if there is a de-serialization problem we can't really test compatibility, as the replayer always returns nil.

## Steps to Reproduce the Problem

  1. Define any workflow
  2. Replay the workflow with a history that can't be de-serialized by the workflow (example: use a different format than what the workflow expects)

## Specifications

  - Version: v1.17.0
  - Platform: go


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-01-25 15:38:25.000 UTC</summary>

Can you confirm this issue still exists on the latest SDK? We have made a few replayer fixes. But yes, it does seem correct that a deserialization failure should be a task failure and therefore a replay failure.

</details>

<details>
<summary><strong>ericvg97</strong> commented on 2023-02-01 10:27:59.000 UTC</summary>

We have tested with version 20 and it is solved!! Thank you @cretz :)

</details>


---

<a id="995"></a>

### #995: Do not auto-retry gRPC-message-size-too-large errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/995 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-05 13:07:57.000 UTC (3 years ago) |
| **Updated** | 2025-08-26 16:08:46.000 UTC |
| **Closed** | 2025-08-26 16:08:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When server gets > 4MB message, it returns `ResourceExhausted` error with something like:

> grpc:Â receivedÂ messageÂ largerÂ thanÂ maxÂ (10248653Â vs.Â 4194304)

Which is retried by our gRPC interceptor as are all other `ResourceExhausted`. We need to stop retrying this one in particular but still retry others. If we can prevent it from going over the wire without pre-calculating the size that would be best, but otherwise we may need to hack something to change the error type for this particular error before it gets to the retry interceptor. Yes that may mean a message string check which is admittedly gross.

Also, add an integration test with a workflow whose activity payload will trigger this and confirm that it's a workflow task failure (can be in sdk-features).


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-01-05 19:16:30.000 UTC</summary>

Before developing, please see #466 for some context of a similar discussion in the past. It seems there was discussion around similar concerns and the max client size was changed to _prevent_ this error on the client side, but it still may occur on the server.

The goal here is to make sure grpc-message-too-large errors of, say, a 6MB workflow task completion cause a workflow task failure instead of implicit retry of resource exhausted.

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-05-14 14:49:43.000 UTC</summary>

Features issue made at https://github.com/temporalio/features/issues/624. Please refer to that for ideal behavior.

</details>


---

<a id="969"></a>

### #969: Ability to dump stack of deadlocking coroutine

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/969 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-11-29 23:47:02.000 UTC (3y 1m ago) |
| **Updated** | 2024-01-20 06:06:43.000 UTC |
| **Closed** | 2024-01-20 06:06:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now when we hit deadlock detector in Go, we panic w/ the stack where we timed out but we don't show the stack of blocked coroutines in the workflow

**Describe the solution you'd like**

Go does not have a "show stack of specific goroutine". In fact, Go doesn't even allow you to technically identify/address goroutines. But internally they do maintain a Go ID. I have seen projects take it via ugly stack parsing and via ugly internal reflection. So we could track these IDs when `workflow.Go` is called (we don't have to worry about users using real goroutines), then parse `runtime.Stack()` to filter out only the stack trace for known running coroutines of that workflow. If this is expensive to get that ID, we can make it opt-in (we don't care about how expensive it is as deadlock time though).

So, here's the goal:

* Allow users to see a stack of all running coroutines of a workflow

Here's the allowed compromise:

* If it's too expensive to create the identifier of the coroutine for tracking when deadlock detection hits, we could make it opt in.

See if there are any known projects that have done these things we could take inspiration from



#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2022-11-30 00:31:59.000 UTC</summary>

We don't really need stack of all workflow blocked coroutines as we need the stack only of the one that was executing while detector timeout happened.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-11-30 13:20:21.000 UTC</summary>

Yes, sorry, duh, there can only be one "running coroutine" of a workflow at any time.

</details>


---

<a id="954"></a>

### #954: remove error from return since it always return nil

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/954 |
| **State** | CLOSED |
| **Author** | ktong (Kuisong Tong) |
| **Created** | 2022-11-10 20:07:42.000 UTC (3y 2m ago) |
| **Updated** | 2022-11-14 14:22:20.000 UTC |
| **Closed** | 2022-11-14 14:22:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/sdk-go/blob/34f71ac9d724670c6542faf1fac3e5594479a98a/contrib/opentelemetry/tracing_interceptor.go#L89

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-11-10 20:14:10.000 UTC</summary>

This is for future proofing. We may return an error from it one day, so we need it to be present now so we don't break people later. Please always check for an error from this call.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-11-14 14:22:19.000 UTC</summary>

Closing. Feel free to keep commenting or request re-open.

</details>


---

<a id="950"></a>

### #950: Eager activity execution should be limited to 3 per workflow task completion by default

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/950 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-11-09 01:03:33.000 UTC (3y 2m ago) |
| **Updated** | 2022-11-10 17:44:26.000 UTC |
| **Closed** | 2022-11-10 17:44:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

In #946 we set `MaxConcurrentActivityExecutionSize` default to 3, instead we should have set the max number of eager activities requested per workflow task completion to 3.

I wish we hadn't exposed `MaxConcurrentActivityExecutionSize` and `DisableEagerActivities`, next time when we add new options we should mark them experimental, but in this case I think it might be okay to remove these, risking a breaking change.

In other SDKs, we've allowed disabling eager activity execution per activity invocation via activity options and have not yet exposed a way to configure the number of eager activity requests, it's hardcoded to 3.
I would like us to expose a way to configure the number of eager activity requests eventually but would rather wait until we know more about the implications of turning this on before exposing so we can document how to tune that parameter.
Since eager activities are [still disabled by default server side](https://github.com/temporalio/temporal/blob/bbd386e034fd981054667e683c0afcee8426d65a/service/history/configs/config.go#L506) that should be enough for now.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-11-09 14:01:35.000 UTC</summary>

> In https://github.com/temporalio/sdk-go/pull/946 we set MaxConcurrentActivityExecutionSize default to 3, instead we should have set the max number of eager activities requested per workflow task completion to 3.

It is `MaxConcurrentEagerActivityExecutionSize` and I still it is best IMO. The whole point of having this throttle was to not overload the worker or unexpected consequences of doing thousands of these things. If you made this per workflow, you're only stopping the rare case of `ExecuteActivity` called 3+ times before either is waited. That's hardly ever. In the meantime, I'd start 1000 workflows that each start an activity, and then they would all be eager. It would make the option useless.

We have `MaxConcurrent` settings for activities, local activities, sessions, pollers, tasks, and now eager activities. These are consistent and across the worker. It'd be inconsistent and almost worthless to do per workflow or per workflow task.

> I wish we hadn't exposed MaxConcurrentActivityExecutionSize and DisableEagerActivities

Why not? These are perfectly valid settings and are inline with other settings this SDK uses. They both have worker-level value. I'd like to see these options in every SDK. Everyone should be able to set max concurrent and disable eager activities at the worker level. Remember however that `0` in Go is "unset" which means "default" and we don't want to default to disabled. That's why there are two settings.

> next time when we add new options we should mark them experimental

We don't usually do this with new option additions, e.g. https://typescript.temporal.io/api/interfaces/common.ActivityOptions#alloweagerdispatch. Are you saying all SDKs should have marked them experimental, or are you saying Go uniquely did something wrong here?

> but in this case I think it might be okay to remove these, risking a breaking change.

Concur, these are unused and such a breaking change to these options is fine. Can you clarify exactly what they should change to?

> I would like us to expose a way to configure the number of eager activity requests eventually but would rather wait until we know more about the implications of turning this on before exposing so we can document how to tune that parameter.

I remember being asked for this explicitly when I developed this feature, but maybe I wasn't supposed to make it user overridable? It would be a deviation from the norm with all the other configuration options we create on new features like this. I think Go was the first SDK to offer a user-facing API related to eager activities so there wasn't a model to follow that I recall. Why does how we tune the default affect whether the user-overridable option exists? We can remove and hardcode if we must.

I could quite easily argue that eager activity should _never_ be a per-activity option. A workflow author does not need to concern themselves with such a thing.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-11-09 22:04:03.000 UTC</summary>

After discussion, we just need to remove the "3" default from max concurrent eager (so leave that as unlimited) and hardcode a new setting of max 3 per workflow task.

</details>


---

<a id="933"></a>

### #933: No problem indicators on failed workflow input deserialization during queries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/933 |
| **State** | OPEN |
| **Author** | Drahflow (Jens-Wolfhard Schicke-Uffmann) |
| **Created** | 2022-10-13 12:23:01.000 UTC (3y 2m ago) |
| **Updated** | 2022-10-13 13:02:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When attempting to query a workflow (e.g. via temporal UI) and the workflow worker cannot successfully replay the workflow state due to deserialization errors of the input payload of the workflow, there should be some log message about said failure to deserialize.

## Actual Behavior

The desired query type is not visible in the UI. Stacktraces (which are also served by queries) are not available without explanation.

Please see #932 for an initial analysis of the cause and some pointers where it goes wrong.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-10-13 12:34:15.000 UTC</summary>

> there should be some log message about said failure to deserialize.

From your PR, it seems your logs are in general error location and obviously we don't want to add logs for all errors now (some are expected/normal). Do you have a specific suggestion of where to add logging? What about workflow and signal argument deserialization errors? (even if no specific suggestion, no worries, we will investigate where to add)

</details>

<details>
<summary><strong>Drahflow</strong> commented on 2022-10-13 13:02:13.000 UTC</summary>

I tried to find a good place, but couldn't. thus the half-baked PR. The problem is from the dispatcher startup perspective, these errors are indistinguishable from "normal" termination with workflow error. And the history replay loop (where it is known that the code has just replayed the WorkflowStart) doesn't seem to have a good way to access the workflow environment where the dispatcher will update the error.

That might be the ideal logic: If the workflow went into an error state after replaying just the StartWorkflow event -> log.
(I think replay errors of later events are covered via the non-determinism check anyway.) No idea whatever about signal payload deserialization problems, we didn't have that yet :)

</details>


---

<a id="918"></a>

### #918: Define an external type for internal.WorflowClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/918 |
| **State** | CLOSED |
| **Author** | LXiao2015 |
| **Created** | 2022-09-26 08:22:16.000 UTC (3y 3m ago) |
| **Updated** | 2022-12-02 19:12:34.000 UTC |
| **Closed** | 2022-12-02 19:12:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I'm writing unit test for my code and need a way to mock ExecuteWorkflow method. But I'm blocked because I'm not able to use *internal.WorkflowClient type inside internal package.

**Describe the solution you'd like**
Like what we already have, internal.WorkflowRun can be accessed with client.WorkflowRun. Can we also define this for internal.WorkflowClient?

**Describe alternatives you've considered**


**Additional context**



#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-09-26 14:56:57.000 UTC</summary>

You should mock the `client.Client` interface with your favorite mocking approach. You shouldn't need access to any particular implementation of `client.Client`. For example (untested, just typed here in chat):

```go
type MyClient struct {
  client.Client
  onExecute func(context.Context, client.StartWorkflowOptions, interface{}, ...interface{}) (client.WorkflowRun, error)
}

func (m *MyClient) ExecuteWorkflow(ctx context.Context, options StartWorkflowOptions, workflow interface{}, args ...interface{}) (WorkflowRun, error) {
  return m.onExecute(ctx, options, workflow, args...)
}
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-02 19:12:34.000 UTC</summary>

Closing, feel free to reopen if you have other questions

</details>


---

<a id="899"></a>

### #899: github.com/uber-go/tally/v4-v4.1.1: 2 vulnerabilities (highest severity is: 7.5)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/899 |
| **State** | OPEN |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-08-30 17:58:26.000 UTC (3y 4m ago) |
| **Updated** | 2024-03-01 22:38:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>github.com/uber-go/tally/v4-v4.1.1</b></p></summary>

<p>A Go metrics interface with fast buffered metrics and third party reporters</p>
<p>Library home page: <a href="https://proxy.golang.org/github.com/uber-go/tally/v4/@v/v4.1.1.zip">https://proxy.golang.org/github.com/uber-go/tally/v4/@v/v4.1.1.zip</a></p>
<p>Path to dependency file: /contrib/tally/go.mod</p>
<p>Path to vulnerable library: /go/pkg/mod/cache/download/github.com/uber-go/tally/v4/@v/v4.1.1.mod,/go/pkg/mod/cache/download/github.com/uber-go/tally/v4/@v/v4.1.1.mod</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (github.com/uber-go/tally/v4-v4.1.1 version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2019-0210](https://www.mend.io/vulnerability-database/CVE-2019-0210) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | github.com/uber-go/tally/v4-v4.1.1 | Direct | 0.13.0 | &#9989; |
| [CVE-2019-0205](https://www.mend.io/vulnerability-database/CVE-2019-0205) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | github.com/uber-go/tally/v4-v4.1.1 | Direct | org.apache.thrift:libthrift:0.13.0 | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2019-0210</summary>


###  Vulnerable Library - <b>github.com/uber-go/tally/v4-v4.1.1</b></p>

<p>A Go metrics interface with fast buffered metrics and third party reporters</p>
<p>Library home page: <a href="https://proxy.golang.org/github.com/uber-go/tally/v4/@v/v4.1.1.zip">https://proxy.golang.org/github.com/uber-go/tally/v4/@v/v4.1.1.zip</a></p>
<p>Path to dependency file: /contrib/tally/go.mod</p>
<p>Path to vulnerable library: /go/pkg/mod/cache/download/github.com/uber-go/tally/v4/@v/v4.1.1.mod,/go/pkg/mod/cache/download/github.com/uber-go/tally/v4/@v/v4.1.1.mod</p>
<p>

Dependency Hierarchy:
  - :x: **github.com/uber-go/tally/v4-v4.1.1** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In Apache Thrift 0.9.3 to 0.12.0, a server implemented in Go using TJSONProtocol or TSimpleJSONProtocol may panic when feed with invalid input data.

<p>Publish Date: 2019-10-29
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2019-0210>CVE-2019-0210</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="http://mail-archives.apache.org/mod_mbox/thrift-dev/201910.mbox/%3C277A46CA87494176B1BBCF5D72624A2A%40HAGGIS%3E">http://mail-archives.apache.org/mod_mbox/thrift-dev/201910.mbox/%3C277A46CA87494176B1BBCF5D72624A2A%40HAGGIS%3E</a></p>
<p>Release Date: 2019-10-29</p>
<p>Fix Resolution: 0.13.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2019-0205</summary>


###  Vulnerable Library - <b>github.com/uber-go/tally/v4-v4.1.1</b></p>

<p>A Go metrics interface with fast buffered metrics and third party reporters</p>
<p>Library home page: <a href="https://proxy.golang.org/github.com/uber-go/tally/v4/@v/v4.1.1.zip">https://proxy.golang.org/github.com/uber-go/tally/v4/@v/v4.1.1.zip</a></p>
<p>Path to dependency file: /contrib/tally/go.mod</p>
<p>Path to vulnerable library: /go/pkg/mod/cache/download/github.com/uber-go/tally/v4/@v/v4.1.1.mod,/go/pkg/mod/cache/download/github.com/uber-go/tally/v4/@v/v4.1.1.mod</p>
<p>

Dependency Hierarchy:
  - :x: **github.com/uber-go/tally/v4-v4.1.1** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In Apache Thrift all versions up to and including 0.12.0, a server or client may run into an endless loop when feed with specific input data. Because the issue had already been partially fixed in version 0.11.0, depending on the installed version it affects only certain language bindings.

<p>Publish Date: 2019-10-29
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2019-0205>CVE-2019-0205</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-0205">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-0205</a></p>
<p>Release Date: 2019-10-29</p>
<p>Fix Resolution: org.apache.thrift:libthrift:0.13.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>

#### Comments (2)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-06-27 20:59:51.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-08-11 16:42:46.000 UTC</summary>

:information_source: This issue was automatically re-opened by Mend because the vulnerable library in the specific branch(es) has been detected in the Mend inventory.

</details>


---

<a id="865"></a>

### #865: Replayer uses different run ID than runtime after reset

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/865 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-07-21 17:47:58.000 UTC (3y 5m ago) |
| **Updated** | 2023-01-05 18:02:44.000 UTC |
| **Closed** | 2023-01-05 18:02:44.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

They use the same run ID

## Actual Behavior

Today, replayer uses `temporal.api.history.v1.WorkflowExecutionStartedEventAttributes.original_execution_run_id` while runtime uses `temporal.api.workflowservice.v1.workflow_execution.run_id`. This run ID affects the default child workflow ID. We should change the replayer (changing the runtime is not acceptable for compatibility reasons of course).



---

<a id="855"></a>

### #855: Panic with double stop on worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/855 |
| **State** | CLOSED |
| **Author** | yux0 (Yu Xia) |
| **Created** | 2022-07-15 17:04:48.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-09 14:29:14.000 UTC |
| **Closed** | 2022-08-09 14:29:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Ignore the second stop

## Actual Behavior
panic: close of closed channel

https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker.go#L1051
Can it check if the channel is closed using assertNotStopped()?

## Steps to Reproduce the Problem
Call worker.stop twice



#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-07-15 17:50:44.000 UTC</summary>

> Ignore the second stop

I am not sure this is expected behavior anymore than a file can be closed/deleted twice.

Do we expect `Start` to be able to be called twice too? `Run` as well?

> Can it check if the channel is closed using assertNotStopped()?

That is not atomic though, so technically you could still get this panic.

We _could_ call this, but then it changes the behavior. I am not convinced we need to allow worker functions to be safe for multiple calls. If a user's code cannot know whether they have called stop, they can maintain such a state.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-09 14:29:14.000 UTC</summary>

Closing after 3 weeks with no response. I will document that `Stop` cannot be called twice.

</details>


---

<a id="847"></a>

### #847: sdk 1.15.0 seems to be incompatible with go.temporal.io/api v1.9.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/847 |
| **State** | CLOSED |
| **Author** | c4milo (Camilo Aguilar) |
| **Created** | 2022-07-06 18:40:21.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-06 18:42:04.000 UTC |
| **Closed** | 2022-07-06 18:41:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We started running into this issue when doing a `go mod tidy` 

```
â¯ go build
# go.temporal.io/sdk/client
/Users/camiloaguilar/go/pkg/mod/go.temporal.io/sdk@v1.15.0/client/service_proxy.go:50:9: cannot use &workflowServiceProxyServer{â€¦} (value of type *workflowServiceProxyServer) as type workflowservice.WorkflowServiceServer in return statement:
	*workflowServiceProxyServer does not implement workflowservice.WorkflowServiceServer (missing GetWorkerBuildIdOrdering method)
```

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-07-06 18:41:39.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-go/issues/832

</details>

<details>
<summary><strong>c4milo</strong> commented on 2022-07-06 18:42:04.000 UTC</summary>

ah, perfect, thanks @cretz! 

Reactions: ðŸ‘ 1

</details>


---

<a id="845"></a>

### #845: Activity function alias lookup is done even on different task queue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/845 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-07-01 15:03:16.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-14 14:12:34.000 UTC |
| **Closed** | 2022-07-14 14:12:34.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

ExecuteActivity should only look up function alias in local registry when executing on the same task queue.

## Actual Behavior

Alias lookup is done regardless of calling task queue.

## Concerns

Fixing this may be tricky due to people relying on this aliasing across task queues today. Will discuss with team.


---

<a id="834"></a>

### #834: Can't check if a error is type ContinueAsNewError in Interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/834 |
| **State** | CLOSED |
| **Author** | qiuyuzhou (Qiu Yuzhou) |
| **Created** | 2022-06-21 05:29:08.000 UTC (3y 6m ago) |
| **Updated** | 2022-06-22 03:37:04.000 UTC |
| **Closed** | 2022-06-22 03:37:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Can't check if a error is type ContinueAsNewError in Interceptor, because it is in the `internal` package.

```
imports github.com/sdcxtech/sentrytemporal
	/go/pkg/mod/github.com/sdcxtech/sentrytemporal@v0.2.0/workflow.go:8:2: use of internal package go.temporal.io/sdk/internal not allowed
```

I'm trying to skip the ContinueAsNewError.

```go
	ret, err = w.Next.ExecuteWorkflow(ctx, in)
	if err != nil {
		var continueAsNewErr *internal.ContinueAsNewError
		if errors.As(err, &continueAsNewErr) {
			return
		}

		if temporal.IsCanceledError(err) || temporal.IsTimeoutError(err) || temporal.IsTerminatedError(err) {
			return
		}

		if skipper := w.root.options.WorkflowErrorSkipper; skipper != nil && skipper(err) {
			return
		}

		hub := sentry.CurrentHub().Clone()
		hub.ConfigureScope(configureScope)
		_ = hub.CaptureException(err)
	}
```

https://github.com/sdcxtech/sentrytemporal/blob/d754847708dafd4792928b01f14426455d33888b/workflow.go#L51-L56

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-06-21 21:07:50.000 UTC</summary>

> Can't check if a error is type ContinueAsNewError in Interceptor, because it is in the internal package.

It is exposed at https://pkg.go.dev/go.temporal.io/sdk/workflow#ContinueAsNewError

</details>

<details>
<summary><strong>qiuyuzhou</strong> commented on 2022-06-22 03:37:03.000 UTC</summary>

Thanks

</details>


---

<a id="833"></a>

### #833: Captures and reports panic/errors in an interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/833 |
| **State** | CLOSED |
| **Author** | qiuyuzhou (Qiu Yuzhou) |
| **Created** | 2022-06-20 07:34:15.000 UTC (3y 6m ago) |
| **Updated** | 2022-06-21 04:58:04.000 UTC |
| **Closed** | 2022-06-21 04:58:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'm trying to implement an interceptor to capture all panic and errors from workflows and activities to [sentry](https://sentry.io) server.

My Question is:

Should I wrap the `Next.HandleSignal` execution in `WorkflowInboundInterceptor.HandleSignal` method.

I don't understand  temporal.io how to handle signal in internal. So I don't known how to write a test case to raise error captured in `WorkflowInboundInterceptor.HandleSignal`.

https://github.com/sdcxtech/sentrytemporal/blob/18f35d5db68bc29a34cc82d615edb092d6320bfa/workflow.go#L109

https://github.com/sdcxtech/sentrytemporal/blob/18f35d5db68bc29a34cc82d615edb092d6320bfa/tests/workflow_cases/worflow.go#L33


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-06-20 21:49:44.000 UTC</summary>

Since signals are handled via channels in Go, user code can't really panic/error the interceptor signal handler unless it was a user-defined interceptor signal handler panicking downstream. Basically the downstream final signal handler just puts it on the channel, so it can't really panic and the only error that can happen seems to be if it gets over 100k signals which is not really possible with history limits anyways.

So you probably don't need to worry about capturing panics/errors from signal handlers unless your concerned about a downstream interceptor.

</details>

<details>
<summary><strong>qiuyuzhou</strong> commented on 2022-06-21 04:58:04.000 UTC</summary>

Thanks for your response!

I would remove the capturing for signal handler.

</details>


---

<a id="816"></a>

### #816: Investigate how to unit test child workflows signalling a parent

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/816 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-05-26 18:06:02.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-31 22:15:57.000 UTC |
| **Closed** | 2022-05-31 22:15:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Some child workflows use `WorkflowInfo.ParentExecution` info to do an external signal to parent. This may not be working in unit tests and we may not provide a way to set parent execution if users want to just test single workflows.

**Describe the solution you'd like**

Do investigation and if easy to support parent workflow signalling, do so. Otherwise make it possible to set parent execution info.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-05-31 14:48:25.000 UTC</summary>

I am struggling to replicate this. Here is a test case showing parent signalling from child:

```go
package main_test

import (
	"testing"

	"github.com/stretchr/testify/require"
	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/workflow"
)

func TestChildSignalParent(t *testing.T) {
	childWorkflowFn := func(ctx workflow.Context) error {
		return workflow.SignalExternalWorkflow(ctx,
			workflow.GetInfo(ctx).ParentWorkflowExecution.ID, "", "some-signal", "val1").Get(ctx, nil)
	}
	parentWorkflowFn := func(ctx workflow.Context) (string, error) {
		childFut := workflow.ExecuteChildWorkflow(ctx, childWorkflowFn)
		if err := childFut.GetChildWorkflowExecution().Get(ctx, nil); err != nil {
			return "", err
		}
		var signalArg string
		workflow.GetSignalChannel(ctx, "some-signal").Receive(ctx, &signalArg)
		return signalArg, childFut.Get(ctx, nil)
	}
	var suite testsuite.WorkflowTestSuite
	env := suite.NewTestWorkflowEnvironment()
	env.RegisterWorkflow(childWorkflowFn)
	env.RegisterWorkflow(parentWorkflowFn)
	env.ExecuteWorkflow(parentWorkflowFn)
	require.True(t, env.IsWorkflowCompleted())
	require.NoError(t, env.GetWorkflowError())
	var resStr string
	require.NoError(t, env.GetWorkflowResult(&resStr))
	require.Equal(t, "val1", resStr)
}
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-31 22:15:57.000 UTC</summary>

Confirmed with user this is was an unrelated issue with their code

</details>


---

<a id="804"></a>

### #804: How can i get span trace id from workflow context?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/804 |
| **State** | CLOSED |
| **Author** | woyong (è´¾æˆ‘å‹‡) |
| **Created** | 2022-05-12 13:20:56.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-23 17:08:13.000 UTC |
| **Closed** | 2022-05-23 17:08:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

```
w := worker.New(c, model.TaskQueueLiveEvent, worker.Options{
          Interceptors: []sdkinterceptor.WorkerInterceptor{NewWorkerInterceptor(InterceptorOptions{
              GetExtraLogTagsForWorkflow: func(ctx sdkworkflow.Context) []interface{} {
                  return []interface{}{"WorkflowStartTime", sdkworkflow.GetInfo(ctx).WorkflowStartTime.Format(time.RFC3339)}
              },
              GetExtraLogTagsForActivity: func(ctx context.Context) []interface{} {

                  var traceID string
                  if span := trace.SpanContextFromContext(ctx); span.HasTraceID() {
                      traceID = span.TraceID().String()
                  }
                  return []interface{}{"trace_id", traceID}
              },
          })},
      })
```

i can implement the interceptor add trace_id for activity log, but i don't know how to get trace id from workflow context.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-05-16 14:57:00.000 UTC</summary>

Are you using OpenTracing or OpenTelemetry? Regardless, the context key on which the span is stored is in a non-exported struct. You may set `TracerOptions.SpanContextKey` to a custom value of your choice and then use that value to extract the span out of the context.

Having said that, I would recommend not reusing span info but instead passing your own info around in context and/or using `workflow.GetInfo` or similar.

Does this answer your question?

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-05-23 17:08:12.000 UTC</summary>

Closing as answered. Please update if you need more info.

</details>


---

<a id="789"></a>

### #789: Allow getting workflow result to not follow runs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/789 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-04-22 19:48:03.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-02 21:27:28.000 UTC |
| **Closed** | 2022-05-02 21:27:28.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

People want to see results for that execution, but if `WorkflowExecutionCompletedEventAttributes.new_execution_run_id` is set, we automatically follow to the next one. This sucks for things like wanting to get an older cron result.

**Describe the solution you'd like**

Allow users to opt-out of "follow runs" like we do in other languages. It is still up in the air on how best to provide that option to the `client.WorkflowRun.Get` call without breaking backwards compat (new call adds method to the iface, context value is ugly but may be best here).


---

<a id="784"></a>

### #784: Task queue not recorded on temporal_worker_task_slots_available metric

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/784 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-04-19 17:00:35.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-25 13:42:05.000 UTC |
| **Closed** | 2022-04-25 13:42:05.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

Expect worker task queue to be on `temporal_worker_task_slots_available` but it is not

## Actual Behavior

Task queue is not set


---

<a id="769"></a>

### #769: Move some data conversion out of the deadlock detection scope

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/769 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-03-30 17:17:47.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-13 16:55:28.000 UTC |
| **Closed** | 2022-04-13 16:55:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Some advanced use cases of workflow data converters do not want to be bound to Temporal workflow deadlock rules

**Describe the solution you'd like**

For as much as is reasonable, try to do the data conversion outside of the inline workflow and nearer to the commands/events. Even if I try to take a simple approach (e.g. shipping Go object + data converter around instead of payloads), I fear this is quite a daunting challenge. Also, I will have to confirm we don't expect data conversion errors to be able to be handled inline.

#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2022-03-30 17:49:00.000 UTC</summary>

One "hacky" option is to measure time spent in DataConverter and extend the deadlock detector timeout by this value.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-03-30 18:45:26.000 UTC</summary>

Yes, I am thinking this is the most likely approach (or as a timer that can be stopped and then started again)

</details>


---

<a id="767"></a>

### #767: workflowcheck gets stuck forever when using templates in the workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/767 |
| **State** | CLOSED |
| **Author** | mbark (Martin Wohlfart) |
| **Created** | 2022-03-30 09:48:46.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-19 17:05:50.000 UTC |
| **Closed** | 2022-04-19 17:05:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When using `workflowcheck` it should always terminate.

## Actual Behavior

When using `text/template` in the workflow code `workflowcheck` gets stuck and never terminates.

## Steps to Reproduce the Problem

See my [example repo](https://github.com/mbark/temporal-workflowcheck-error) here. I added a `Makefile` to simplify running `workflowcheck`, `make workflowcheck` will download it and run the version referenced in `tools.go` for you.

To reproduce:
  1. Run `make workflowcheck`;
  1. `workflowcheck` doesn't terminate;
  1. Comment lines 16-20 in `workflow.go`;
  2. Re-run `make workflowcheck`;
  3. It terminates successfully.

## Specifications

  - Version: `go.temporal.io/sdk/contrib/tools/workflowcheck v0.0.0-20220324161800-48b3cb957491`
  - Platform: macOS


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-03-30 13:35:46.000 UTC</summary>

Thanks for the report! To investigate, we will want to run with debug enabled and/or run via `go vet` just to see it isn't heavy rather than stuck.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-18 17:42:21.000 UTC</summary>

Thanks for the reproducer! I have replicated this. Strangely I cannot replicate on Windows, only Linux. Here's what the Windows output shows:

```
c:\path\to\temporal-workflowcheck-error\main.go:20:2: templateworkflowcheck.Workflow is non-deterministic, reason: calls non-deterministic function (*text/template.Template).Execute
  (*text/template.Template).Execute is non-deterministic, reason: calls non-deterministic function (*text/template.Template).execute
    (*text/template.Template).execute is non-deterministic, reason: calls non-deterministic function (*text/template.state).walk
      (*text/template.state).walk is non-deterministic, reason: calls non-deterministic function (*text/template.state).printValue
        (*text/template.state).printValue is non-deterministic, reason: calls non-deterministic function text/template.printableValue
          text/template.printableValue is non-deterministic, reason: calls non-deterministic function reflect.PtrTo
            reflect.PtrTo is non-deterministic, reason: calls non-deterministic function (*reflect.rtype).ptrTo
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                  (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                  (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
          text/template.printableValue is non-deterministic, reason: calls non-deterministic function reflect.PtrTo
            reflect.PtrTo is non-deterministic, reason: calls non-deterministic function (*reflect.rtype).ptrTo
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                  (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                  (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
          text/template.printableValue is non-deterministic, reason: calls non-deterministic function (reflect.Value).Addr
            (reflect.Value).Addr is non-deterministic, reason: calls non-deterministic function (*reflect.rtype).ptrTo
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                  (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
              (*reflect.rtype).ptrTo is non-deterministic, reason: calls non-deterministic function (*sync.Map).LoadOrStore
                (*sync.Map).LoadOrStore is non-deterministic, reason: calls non-deterministic function (*sync.Map).dirtyLocked
                  (*sync.Map).dirtyLocked is non-deterministic, reason: iterates over map
```

I am continuing to investigate Linux. In the meantime, you can add `//workflowcheck:ignore` either above or at the end of that `.Execute` line. Also, you can upgrade your version with `go get go.temporal.io/sdk/contrib/tools/workflowcheck@latest` which does have some output improvements but it doesn't solve this issue.

From the static analyzer's POV, `Template.Execute` will be considered non-deterministic due to its internals having lots of non-deterministic code. So you're going to need to ignore `text/template` anyways with `//workflowcheck:ignore`. Technically you could make that as always deterministic via config (see README at https://github.com/temporalio/sdk-go/tree/master/contrib/tools/workflowcheck) but then if other people use the package non-deterministically you'll never know.

Reactions: ðŸ‘ 1

</details>


---

<a id="754"></a>

### #754: gRPC Proxy Integration Test

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/754 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-03-14 17:52:08.000 UTC (3y 10m ago) |
| **Updated** | 2024-12-17 21:17:36.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

Need integration/end-to-end test for the gRPC proxy

**Describe the solution you'd like**

Create test (maybe in `test/integration_test.go`) that uses a proxy and a custom codec/converter for both the client and worker to run a workflow.

Noticed when reviewing https://github.com/temporalio/samples-go/pull/179


---

<a id="709"></a>

### #709: Nested children in workflowcheck aren't showing the final leaf reason for non-determinism

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/709 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-31 22:23:19.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-16 17:58:57.000 UTC |
| **Closed** | 2022-02-16 17:58:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Hierarchical tree should show full tree of non-determinism all the way down to transitive reason

## Actual Behavior

Hierarchical tree is not showing final leaf reason

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-02-16 12:35:38.000 UTC</summary>

I am struggling to replicate this. All my tests show the hierarchy going down to the leaf.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-02-16 17:58:57.000 UTC</summary>

I have found the issue here. I only carry over reasoning from the direct imports, not transitive ones. I have trialed bringing over transitive reasons, but that becomes extremely memory heavy. I am not going to do this for now.

</details>


---

<a id="687"></a>

### #687: `make test` fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/687 |
| **State** | CLOSED |
| **Author** | lorensr (Loren â˜ºï¸) |
| **Created** | 2022-01-06 04:59:14.000 UTC (4 years ago) |
| **Updated** | 2022-01-06 21:53:13.000 UTC |
| **Closed** | 2022-01-06 21:52:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Exit code 0

## Actual Behavior

Exit code 2, ending with this output:

<details>

```
$ make test
...
=== RUN   Test_MockResetWorkflowExecution
    mock_test.go:116: PASS:     ResetWorkflowExecution(string,string)
--- PASS: Test_MockResetWorkflowExecution (0.00s)
PASS
coverage: 25.6% of statements
ok      go.temporal.io/sdk/mocks        0.365s  coverage: 25.6% of statements
=== RUN   TestAsyncBindingsTestSuite
objc[18411]: Attempt to use unknown class 0x7ff859ace260.
SIGABRT: abort
PC=0x7ff818286dfe m=5 sigcode=0

goroutine 0 [idle]:
runtime: unknown pc 0x7ff818286dfe
stack: frame={sp:0x7000060b3e58, fp:0x0} stack=[0x700006035338,0x7000060b4f38)
0x00007000060b3d58:  0x0000000000000002  0x0000000000000002 
0x00007000060b3d68:  0x00000000034ea000  0x00000000034ea400 
0x00007000060b3d78:  0x000000000000000c  0x00007000060b3de0 
0x00007000060b3d88:  0x00007ff8180bc619  0x0000000000000000 
0x00007000060b3d98:  0xf6890000c000100c  0x000000000000ffff 
0x00007000060b3da8:  0x0000000000000030  0x0000000000000000 
0x00007000060b3db8:  0x000000000000002d  0x000000000000002d 
0x00007000060b3dc8:  0x0000000000000000  0x00000000034ea000 
0x00007000060b3dd8:  0x00007ff859ae2000  0x00007000060b3e10 
0x00007000060b3de8:  0x00007ff8180bc546  0x00007ff8180bc50e 
0x00007000060b3df8:  0x000000000000002d  0x0000000000000001 
0x00007000060b3e08:  0x00007ff859ae2000  0x00007000060b3e50 
0x00007000060b3e18:  0x00007ff8180d8ad6  0x000000000000002c 
0x00007000060b3e28:  0x000000000000002d  0x0000600003300000 
0x00007000060b3e38:  0x0000000000000003  0x0000600002c00000 
0x00007000060b3e48:  0x0000000000000000  0x00007000060b3e80 
0x00007000060b3e58: <0x00007ff818288893  0x0000000000000000 
0x00007000060b3e68:  0x00000020060b3ec0  0x0000600002c00000 
0x00007000060b3e78:  0x00007000060b3ec0  0x0000600003300000 
0x00007000060b3e88:  0x0000000000000003  0x0000000000000080 
0x00007000060b3e98:  0x0000000000000001  0x00007000060b3eb0 
0x00007000060b3ea8:  0x00007ff818288843  0x00007000060b3ef0 
0x00007000060b3eb8:  0x00007ff818154bce  0x0000600002c00080 
0x00007000060b3ec8:  0x0000000000000000  0x0000600002c00000 
0x00007000060b3ed8:  0x00007ffffffffff8  0x00007ff859ace260 
0x00007000060b3ee8:  0x0000000080080001  0x00007000060b3fd0 
0x00007000060b3ef8:  0x00007ff818154b5c  0x0000003000000010 
0x00007000060b3f08:  0x00007000060b3fe0  0x00007000060b3f20 
0x00007000060b3f18:  0x0000000000000000  0x0000000000000000 
0x00007000060b3f28:  0x00007ff859ace260  0x00007ff859ace260 
0x00007000060b3f38:  0x0000000000000001  0x00000000ffffffff 
0x00007000060b3f48:  0x0000000000000000  0x0000000000000000 
runtime: unknown pc 0x7ff818286dfe
stack: frame={sp:0x7000060b3e58, fp:0x0} stack=[0x700006035338,0x7000060b4f38)
0x00007000060b3d58:  0x0000000000000002  0x0000000000000002 
0x00007000060b3d68:  0x00000000034ea000  0x00000000034ea400 
0x00007000060b3d78:  0x000000000000000c  0x00007000060b3de0 
0x00007000060b3d88:  0x00007ff8180bc619  0x0000000000000000 
0x00007000060b3d98:  0xf6890000c000100c  0x000000000000ffff 
0x00007000060b3da8:  0x0000000000000030  0x0000000000000000 
0x00007000060b3db8:  0x000000000000002d  0x000000000000002d 
0x00007000060b3dc8:  0x0000000000000000  0x00000000034ea000 
0x00007000060b3dd8:  0x00007ff859ae2000  0x00007000060b3e10 
0x00007000060b3de8:  0x00007ff8180bc546  0x00007ff8180bc50e 
0x00007000060b3df8:  0x000000000000002d  0x0000000000000001 
0x00007000060b3e08:  0x00007ff859ae2000  0x00007000060b3e50 
0x00007000060b3e18:  0x00007ff8180d8ad6  0x000000000000002c 
0x00007000060b3e28:  0x000000000000002d  0x0000600003300000 
0x00007000060b3e38:  0x0000000000000003  0x0000600002c00000 
0x00007000060b3e48:  0x0000000000000000  0x00007000060b3e80 
0x00007000060b3e58: <0x00007ff818288893  0x0000000000000000 
0x00007000060b3e68:  0x00000020060b3ec0  0x0000600002c00000 
0x00007000060b3e78:  0x00007000060b3ec0  0x0000600003300000 
0x00007000060b3e88:  0x0000000000000003  0x0000000000000080 
0x00007000060b3e98:  0x0000000000000001  0x00007000060b3eb0 
0x00007000060b3ea8:  0x00007ff818288843  0x00007000060b3ef0 
0x00007000060b3eb8:  0x00007ff818154bce  0x0000600002c00080 
0x00007000060b3ec8:  0x0000000000000000  0x0000600002c00000 
0x00007000060b3ed8:  0x00007ffffffffff8  0x00007ff859ace260 
0x00007000060b3ee8:  0x0000000080080001  0x00007000060b3fd0 
0x00007000060b3ef8:  0x00007ff818154b5c  0x0000003000000010 
0x00007000060b3f08:  0x00007000060b3fe0  0x00007000060b3f20 
0x00007000060b3f18:  0x0000000000000000  0x0000000000000000 
0x00007000060b3f28:  0x00007ff859ace260  0x00007ff859ace260 
0x00007000060b3f38:  0x0000000000000001  0x00000000ffffffff 
0x00007000060b3f48:  0x0000000000000000  0x0000000000000000 

goroutine 6 [syscall]:
runtime.cgocall(0x1001140, 0xc000087ca0)
        /usr/local/opt/go/libexec/src/runtime/cgocall.go:156 +0x6e fp=0xc000087c78 sp=0xc000087c40 pc=0x1044b8e
net._C2func_getaddrinfo(0xc000038186, 0x0, 0xc0000a6120, 0xc000010020)
        _cgo_gotypes.go:97 +0x8b fp=0xc000087ca0 sp=0xc000087c78 pc=0x159ffeb
net.cgoLookupIPCNAME.func1({0xc000038186, 0xa, 0xc0001b2f0f}, 0x10af825, 0x28448e0)
        /usr/local/opt/go/libexec/src/net/cgo_unix.go:163 +0xb2 fp=0xc000087d10 sp=0xc000087ca0 pc=0x15a2cb2
net.cgoLookupIPCNAME({0x1fa0d8a, 0x3}, {0xc0001b2f0f, 0x1})
        /usr/local/opt/go/libexec/src/net/cgo_unix.go:163 +0x26e fp=0xc000087f10 sp=0xc000087d10 pc=0x15a21ae
net.cgoIPLookup(0x28448f0, {0x1fa0d8a, 0x3}, {0xc0001b2f0f, 0x9})
        /usr/local/opt/go/libexec/src/net/cgo_unix.go:220 +0x67 fp=0xc000087f80 sp=0xc000087f10 pc=0x15a2dc7
net.cgoLookupIPÂ·dwrapÂ·22()
        /usr/local/opt/go/libexec/src/net/cgo_unix.go:230 +0x72 fp=0xc000087fe0 sp=0xc000087f80 pc=0x15a3472
runtime.goexit()
        /usr/local/opt/go/libexec/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc000087fe8 sp=0xc000087fe0 pc=0x10acb01
created by net.cgoLookupIP
        /usr/local/opt/go/libexec/src/net/cgo_unix.go:230 +0x1ba

goroutine 1 [chan receive]:
testing.(*T).Run(0xc000254b60, {0x1fb648b, 0x1a}, 0x1ff34f8)
        /usr/local/opt/go/libexec/src/testing/testing.go:1307 +0x752
testing.runTests.func1(0x0)
        /usr/local/opt/go/libexec/src/testing/testing.go:1598 +0x9a
testing.tRunner(0xc000254b60, 0xc0003dfbc0)
        /usr/local/opt/go/libexec/src/testing/testing.go:1259 +0x230
testing.runTests(0xc000294680, {0x282f380, 0x2, 0x2}, {0x0, 0xc000213880, 0x28482a0})
        /usr/local/opt/go/libexec/src/testing/testing.go:1596 +0x7cb
testing.(*M).Run(0xc000294680)
        /usr/local/opt/go/libexec/src/testing/testing.go:1504 +0x9d2
main.main()
        _testmain.go:95 +0x32c

goroutine 19 [select]:
google.golang.org/grpc.(*pickerWrapper).pick(0xc000530390, {0x2135a20, 0xc0005307e0}, 0x1, {{0x1fb850d, 0x0}, {0x2135a20, 0xc0005307e0}})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/picker_wrapper.go:103 +0x1f6
google.golang.org/grpc.(*ClientConn).getTransport(0xc00040c500, {0x2135a20, 0xc0005307e0}, 0x78, {0x1fb850d, 0x1c})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:955 +0x9b
google.golang.org/grpc.(*clientStream).newAttemptLocked(0xc00040a300, 0x0)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/stream.go:408 +0xf3c
google.golang.org/grpc.newClientStreamWithParams({0x21359e8, 0xc000524840}, 0x2844880, 0xc00040c500, {0x1fb850d, 0x1fb850d}, {0x0, 0x0, 0x0, 0x0, ...}, ...)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/stream.go:298 +0x118b
google.golang.org/grpc.newClientStream.func2({0x21359e8, 0xc000524840}, 0xc000524840)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/stream.go:184 +0x19a
google.golang.org/grpc.newClientStream({0x21359e8, 0xc000524840}, 0x2844880, 0xc00040c500, {0x1fb850d, 0x2}, {0xc00020ffc0, 0x2, 0x2})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/stream.go:212 +0x714
google.golang.org/grpc.invoke({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x4, {0xc00020ffc0, ...})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/call.go:66 +0xd3
go.temporal.io/sdk/internal/common/metrics.NewGRPCInterceptor.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0xc0004c6680}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x10af825, 0x1ff3640, ...)
        /Users/me/gh/sdk-go/internal/common/metrics/grpc.go:67 +0x315
google.golang.org/grpc.getChainUnaryInvoker.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x3710a68, {0xc00020ffc0, ...})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:356 +0x1ac
github.com/grpc-ecosystem/go-grpc-middleware/retry.UnaryClientInterceptor.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x1b3e001, 0xc0005306c0, ...)
        /Users/me/go/pkg/mod/github.com/grpc-ecosystem/go-grpc-middleware@v1.3.0/retry/retry.go:36 +0x16b
google.golang.org/grpc.getChainUnaryInvoker.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x8, {0xc0004c6640, ...})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:356 +0x1ac
go.temporal.io/sdk/internal/common/retry.NewRetryOptionsInterceptor.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x1facb3b, 0xc000530690, ...)
        /Users/me/gh/sdk-go/internal/common/retry/interceptor.go:157 +0xa77
google.golang.org/grpc.getChainUnaryInvoker.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x30, {0xc00020fd80, ...})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:356 +0x1ac
go.temporal.io/sdk/internal/common/metrics.NewGRPCInterceptor.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x10}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x0, 0xc000530630, ...)
        /Users/me/gh/sdk-go/internal/common/metrics/grpc.go:67 +0x315
google.golang.org/grpc.getChainUnaryInvoker.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0xc000524850, {0xc00020fd80, ...})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:356 +0x1ac
go.temporal.io/sdk/internal.errorInterceptor({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x203000, 0xc000530600, ...)
        /Users/me/gh/sdk-go/internal/grpc_dialer.go:180 +0xe6
google.golang.org/grpc.chainUnaryClientInterceptors.func1({0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, 0x2848a80, 0x1ff3640, ...)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:344 +0x167
google.golang.org/grpc.(*ClientConn).Invoke(0xc00040c500, {0x21359e8, 0xc000524840}, {0x1fb850d, 0x1c}, {0x1ef3c80, 0xc0004c6600}, {0x1ef3d40, 0xc0005305d0}, {0x0, ...})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/call.go:35 +0x26c
google.golang.org/grpc/health/grpc_health_v1.(*healthClient).Check(0xc0004def80, {0x21359e8, 0xc000524840}, 0xda80e388, {0x0, 0x0, 0x0})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/health/grpc_health_v1/health_grpc.pb.go:56 +0xfd
go.temporal.io/sdk/internal.checkHealth.func1()
        /Users/me/gh/sdk-go/internal/client.go:811 +0xec
go.temporal.io/sdk/internal/common/backoff.Retry({0x21359e8, 0xc0005247e0}, 0xc00021b5d0, {0x212b808, 0xc0001a0d20}, 0x0)
        /Users/me/gh/sdk-go/internal/common/backoff/retry.go:107 +0x124
go.temporal.io/sdk/internal.checkHealth({0x212bb00, 0xc00040c500}, {0x0, {0x0, 0x0}, 0x0, 0x0, 0x0, 0x0, 0x0, ...})
        /Users/me/gh/sdk-go/internal/client.go:808 +0x2c5
go.temporal.io/sdk/internal.NewClient({{0x1faac09, 0xe}, {0x1fb6a21, 0x1a}, {0x2136dd0, 0xc0001b0fd8}, {0x2137460, 0x2878678}, {0x0, 0x0}, ...})
        /Users/me/gh/sdk-go/internal/client.go:653 +0x6c5
go.temporal.io/sdk/client.NewClient(...)
        /Users/me/gh/sdk-go/client/client.go:436
go.temporal.io/sdk/test_test.(*AsyncBindingsTestSuite).SetupSuite(0xc000294700)
        /Users/me/gh/sdk-go/test/bindings_test.go:68 +0x405
github.com/stretchr/testify/suite.Run(0xc000254d00, {0x212b880, 0xc000294700})
        /Users/me/go/pkg/mod/github.com/stretchr/testify@v1.7.0/suite/suite.go:118 +0x5b8
go.temporal.io/sdk/test_test.TestAsyncBindingsTestSuite(0x0)
        /Users/me/gh/sdk-go/test/bindings_test.go:61 +0x45
testing.tRunner(0xc000254d00, 0x1ff34f8)
        /usr/local/opt/go/libexec/src/testing/testing.go:1259 +0x230
created by testing.(*T).Run
        /usr/local/opt/go/libexec/src/testing/testing.go:1306 +0x727

goroutine 20 [select]:
google.golang.org/grpc.(*ccBalancerWrapper).watcher(0xc0005224b0)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/balancer_conn_wrappers.go:77 +0x15c
created by google.golang.org/grpc.newCCBalancerWrapper
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/balancer_conn_wrappers.go:67 +0x4d9

goroutine 21 [select]:
net.(*Resolver).lookupIPAddr(0x28448e0, {0x21359e8, 0xc0000a0120}, {0x1fa0d8a, 0x3}, {0xc0001b2f0f, 0x9})
        /usr/local/opt/go/libexec/src/net/lookup.go:302 +0x81c
net.(*Resolver).internetAddrList(0x21359e8, {0x21359e8, 0xc0000a0120}, {0x1fa0d8a, 0x3}, {0xc0001b2f0f, 0xe})
        /usr/local/opt/go/libexec/src/net/ipsock.go:288 +0x7c6
net.(*Resolver).resolveAddrList(0x2878678, {0x21359e8, 0xc0000a0120}, {0x1fa134d, 0x4}, {0x1fa0d8a, 0x3}, {0xc0001b2f0f, 0xe}, {0x0, ...})
        /usr/local/opt/go/libexec/src/net/dial.go:221 +0x556
net.(*Dialer).DialContext(0xc000216a28, {0x21359e8, 0xc0000a0120}, {0x1fa0d8a, 0x10484ad}, {0xc0001b2f0f, 0x1e528e0})
        /usr/local/opt/go/libexec/src/net/dial.go:406 +0x6e5
google.golang.org/grpc/internal/transport.proxyDial({0x21359e8, 0xc0000a0120}, {0xc0001b2f0f, 0x0}, {0x1faab53, 0xe})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/internal/transport/proxy.go:125 +0x11f
google.golang.org/grpc/internal/transport.dial({0x21359e8, 0xc0000a0120}, 0x0, {{0xc0001b2f0f, 0xe}, {0xc0001b2f0f, 0xe}, 0x0, 0x0, 0x0, ...}, ...)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/internal/transport/http2_client.go:171 +0x3bc
google.golang.org/grpc/internal/transport.newHTTP2Client({_, _}, {_, _}, {{0xc0001b2f0f, 0xe}, {0xc0001b2f0f, 0xe}, 0x0, 0x0, ...}, ...)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/internal/transport/http2_client.go:204 +0x191
google.golang.org/grpc/internal/transport.NewClientTransport(...)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/internal/transport/transport.go:576
google.golang.org/grpc.(*addrConn).createTransport(_, {{0xc0001b2f0f, 0xe}, {0xc0001b2f0f, 0xe}, 0x0, 0x0, 0x0, {0x0, 0x0}}, ...)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:1312 +0x8ab
google.golang.org/grpc.(*addrConn).tryAllAddrs(0xc00055a000, {0xc000522500, 0x1, 0x0}, {0x10be125, 0xc00040c8e8, 0x28482a0})
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:1249 +0x518
google.golang.org/grpc.(*addrConn).resetTransport(0xc00055a000)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:1184 +0x20b
google.golang.org/grpc.(*addrConn).connect(0xc00055a000)
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/clientconn.go:845 +0xbc
created by google.golang.org/grpc.(*acBalancerWrapper).Connect
        /Users/me/go/pkg/mod/google.golang.org/grpc@v1.42.0/balancer_conn_wrappers.go:285 +0x125

goroutine 5 [select]:
net.cgoLookupIP({0x2135978, 0xc00009e140}, {0x1fa0d8a, 0x9}, {0xc0001b2f0f, 0x0})
        /usr/local/opt/go/libexec/src/net/cgo_unix.go:231 +0x289
net.(*Resolver).lookupIP(0x28448e0, {0x2135978, 0xc00009e140}, {0x1fa0d8a, 0x3}, {0xc0001b2f0f, 0x9})
        /usr/local/opt/go/libexec/src/net/lookup_unix.go:97 +0x113
net.glob..func1({0x2135978, 0xc00009e140}, 0xc000088150, {0x1fa0d8a, 0x3}, {0xc0001b2f0f, 0x9})
        /usr/local/opt/go/libexec/src/net/hook.go:23 +0x89
net.(*Resolver).lookupIPAddr.func1()
        /usr/local/opt/go/libexec/src/net/lookup.go:296 +0x133
internal/singleflight.(*Group).doCall(0x28448f0, 0xc0000320a0, {0xc000038173, 0xd}, 0xc00009e180)
        /usr/local/opt/go/libexec/src/internal/singleflight/singleflight.go:95 +0x68
created by internal/singleflight.(*Group).DoChan
        /usr/local/opt/go/libexec/src/internal/singleflight/singleflight.go:88 +0x59b

rax    0x2000209
rbx    0x80
rcx    0x7000060b3e58
rdx    0x0
rdi    0x8
rsi    0x1
rbp    0x7000060b3ea0
rsp    0x7000060b3e58
r8     0x600002c00000
r9     0x80
r10    0x0
r11    0x246
r12    0x0
r13    0x0
r14    0x1
r15    0x8
rip    0x7ff818286dfe
rflags 0x246
cs     0x7
fs     0x0
gs     0x0
FAIL    go.temporal.io/sdk/test 0.435s
FAIL
make: *** [integration-test-zero-cache] Error 1
```

</details>

`make check` and `make unit-test` succeed, as does:

```
$ cd test && go test -run ^TestAsyncBindingsTestSuite$ .
ok      go.temporal.io/sdk/test 1.726s
```

## Steps to Reproduce the Problem

  1. `make test`

## Specifications

  - Version: master
  - Platform: Mac 12.1


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-01-06 14:58:11.000 UTC</summary>

I cannot replicate this. From the `Makefile`, `make test` is the equivalent of `make unit-test`, `make integration-test-zero-cache`, and `make integration-test-normal-cache`.

Your error seems to be a mac-specific known issue when using race detector on mac. Can you look at https://github.com/golang/go/issues/49138 and see if anything in that issue helps? It looks like Go 1.18 will fix this per https://github.com/golang/go/commit/5f6552018d1ec920c3ca3d459691528f48363c3c, but in the meantime you can mimic what https://github.com/Shopify/toxiproxy/commit/40f632786e8362cb969cc82f33c3d313a6413e88 did (specifically add `MallocNanoZone=0` before running `go test`).

I'm undecided on whether we should alter the makefile for this bug, but if it's a big enough issue we can.

</details>

<details>
<summary><strong>lorensr</strong> commented on 2022-01-06 21:52:50.000 UTC</summary>

Thanks, that worked! Here's a patch file for anyone else with this issue:

```
diff --git a/Makefile b/Makefile
index 6b523e6..3845bc0 100644
--- a/Makefile
+++ b/Makefile
@@ -46,13 +46,13 @@ unit-test: $(BUILD)/dummy
 integration-test-zero-cache: $(BUILD)/dummy
 	@mkdir -p $(COVER_ROOT)
 	@for dir in $(INTEG_TEST_DIRS); do \
-		(cd "$$dir" &&WORKFLOW_CACHE_SIZE=0 go test $(TEST_ARG) . -coverprofile=$(INTEG_ZERO_CACHE_COVER_FILE) -coverpkg=./...) || exit 1; \
+		(cd "$$dir" &&WORKFLOW_CACHE_SIZE=0 MallocNanoZone=0 go test $(TEST_ARG) . -coverprofile=$(INTEG_ZERO_CACHE_COVER_FILE) -coverpkg=./...) || exit 1; \
 	done;
 
 integration-test-normal-cache: $(BUILD)/dummy
 	@mkdir -p $(COVER_ROOT)
 	@for dir in $(INTEG_TEST_DIRS); do \
-		(cd "$$dir" && go test $(TEST_ARG) . -coverprofile=$(INTEG_NORMAL_CACHE_COVER_FILE) -coverpkg=./...) || exit 1; \
+		(cd "$$dir" && MallocNanoZone=0 go test $(TEST_ARG) . -coverprofile=$(INTEG_NORMAL_CACHE_COVER_FILE) -coverpkg=./...) || exit 1; \
 	done;
 
 test: unit-test integration-test-zero-cache integration-test-normal-cache
```

`git apply patch`

Reactions: ðŸ‘ 1

</details>


---

<a id="682"></a>

### #682: Failed to test a activity with logger

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/682 |
| **State** | CLOSED |
| **Author** | rainfd (RainFD) |
| **Created** | 2022-01-04 02:44:58.000 UTC (4 years ago) |
| **Updated** | 2022-01-05 02:09:30.000 UTC |
| **Closed** | 2022-01-05 02:09:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Cant' test an activity with logger. Is there a way to generate a context with activityInterceptorContextKey ?

## Expected Behavior


## Actual Behavior
```
// activity
func (a *Activities) GetFile(ctx context.Context, fileID string) (string, error) {
	logger := activity.GetLogger(ctx)
        //...
}
// test method
func (s *FileTestSuite) Test_GetFile() {
	var err error
	s.testWavName, err = s.a.GetFile(context.TODO(), s.testWavID)
	s.NoError(err)
}
// panic code
func getActivityOutboundInterceptor(ctx context.Context) ActivityOutboundInterceptor {
	a := ctx.Value(activityInterceptorContextKey)
	if a == nil {
		panic("getActivityOutboundInterceptor: Not an activity context")
	}
	return a.(ActivityOutboundInterceptor)
}
```

```
--- FAIL: TestFileTestSuite (5.03s)
    --- FAIL: TestFileTestSuite/Test_GetFile (5.01s)
        suite.go:63: test panicked: getActivityOutboundInterceptor: Not an activity context
```

## Steps to Reproduce the Problem


## Specifications

  - Version: 1.12.0
  - Platform: MacOs Monterey 12.1


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-01-04 15:00:17.000 UTC</summary>

If you want to use an activity context with all the activity bells and whistles, you need to use the `go.temporal.io/sdk/testsuite` package and create a suite and an activity environment.

Unfortunately I don't see any samples for how to do this (opened https://github.com/temporalio/samples-go/issues/163). But basically it's (untested):

```go
var suite testsuite.WorkflowTestSuite
env := suite.NewTestActivityEnvironment()
var a Activities
env.RegisterActivity(a)
val, err := env.ExecuteActivity(a.GetFile, "some file ID")
// ...
```

</details>

<details>
<summary><strong>rainfd</strong> commented on 2022-01-05 02:09:18.000 UTC</summary>

@cretz Thanks for help. It works
```golang
func (s *ActivityTestSuite) TestGetFile() {
        // BEFORE
	// var err error
	// s.testWavName, err = s.a.GetFile(context.TODO(), s.testWavID)
	// s.NoError(err)
	// defer os.Remove(s.testWavName)
	// _, err = os.Stat(s.testWavName)
	// s.NoError(err)

         // AFTER
	var fileName string
	val, err := s.env.ExecuteActivity(s.a.GetFile, s.testWavID)
	s.NoError(err)

	err = val.Get(&fileName)
	s.NoError(err)

	s.NotEqual("", fileName)
	os.Remove(fileName)
}
```

</details>


---

<a id="656"></a>

### #656: Heartbeat throttling interval should be configurable and default interval should be less than 10 minutes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/656 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2021-11-30 02:22:02.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-13 17:32:56.000 UTC |
| **Closed** | 2021-12-13 17:32:56.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

Go SDK to implement this behavior: https://temporalio.notion.site/Activity-heartbeats-inconsistent-behavior-between-SDKs-32d81da0748044a8932481d2c9864791


---

<a id="638"></a>

### #638: Document about and warn when attempting to use activity cancellation/heartbeats without HeartbeatTimeout

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/638 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-17 20:16:28.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-03 16:32:33.000 UTC |
| **Closed** | 2021-12-03 16:32:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently we silently do not cancel the activity context even when regularly heartbeating and a cancel occurs from the outside unless `HeartbeatTimeout` is set. We should document that this value _must_ be set for standard cancellation (i.e. context-based cancellation) to work with activities and we should warn if heartbeating is attempted on an activity with no heartbeat timeout set.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-11-17 20:22:07.000 UTC</summary>

Make sure to confirm that heartbeating for other purposes also doesn't work without this timeout.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-17 21:56:13.000 UTC</summary>

After further investigation, there is an internal batching default of 10m that is used if a heartbeat timeout is not set. Therefore, after the first heartbeat, it can take 10m to actually send another heartbeat which is what tells it the activity has been cancelled. Therefore, the documentation needs to make sure to tell people that there can be a long time between actual server side heartbeats, which affects when an activity is told it has been cancelled, if there is no heartbeat timeout is set.

</details>


---

<a id="624"></a>

### #624: unhandled panic from workflow code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/624 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-11-10 01:56:40.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-10 20:17:55.000 UTC |
| **Closed** | 2021-11-10 20:17:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

Panic from workflow code, including any code running in corotine created by any workflow.Go() should be handled by sdk.
User reported this panic stack trace suggest that we might have panic coming from [here](https://github.com/temporalio/sdk-go/blob/384e906eaace5e8914a6c0890419c23eba3b033c/internal/internal_workflow.go#L863)
panic: manual inject panic from go routine [recovered]
	panic: runtime error: slice bounds out of range [9:8]

goroutine 52489 [running]:
go.temporal.io/sdk/internal.getStackTraceRaw({0xc000e7c180, 0x14}, 0x9, 0x4)
	external/io_temporal_go_sdk/internal/internal_workflow.go:863 +0x1bd
go.temporal.io/sdk/internal.getStackTrace({0x52ba998, 0x7f069a39aa68}, {0x30317d5, 0x5}, 0x4)
	external/io_temporal_go_sdk/internal/internal_workflow.go:853 +0xab
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1.1()
	external/io_temporal_go_sdk/internal/internal_workflow.go:936 +0x73
panic({0x2995340, 0x346e360})
	GOROOT/src/runtime/panic.go:1038 +0x215
xxxxxxx/xxxx/xxxxxxxx.(*Workflow).startBlocks.func1({0xc001857950, 0x1})
	xxxxx/xxxxxxxx/workflow.go:432 +0x27
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1(0xc0008ee120)
	external/io_temporal_go_sdk/internal/internal_workflow.go:941 +0xde
created by go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine
	external/io_temporal_go_sdk/internal/internal_workflow.go:932 +0x365
panic: manual inject panic from go routine [recovered]
	panic: runtime error: slice bounds out of range [9:8]

goroutine 52382 [running]:
go.temporal.io/sdk/internal.getStackTraceRaw({0xc001e65698, 0x14}, 0x9, 0x4)
	external/io_temporal_go_sdk/internal/internal_workflow.go:863 +0x1bd
go.temporal.io/sdk/internal.getStackTrace({0x52ba998, 0x34ed810}, {0x30317d5, 0x5}, 0x4)
	external/io_temporal_go_sdk/internal/internal_workflow.go:853 +0xab
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1.1()
	external/io_temporal_go_sdk/internal/internal_workflow.go:936 +0x73
panic({0x2995340, 0x346e360})
	GOROOT/src/runtime/panic.go:1038 +0x215
xxxxxxx/xxxxxxx/xxxxxxxxxx.(*Workflow).startBlocks.func1({0xc001c8fe50, 0x1})
	xxxxxxx/xxxxxxxxxx/workflow.go:432 +0x27
go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1(0xc0024b1030)
	external/io_temporal_go_sdk/internal/internal_workflow.go:941 +0xde
created by go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine
	external/io_temporal_go_sdk/internal/internal_workflow.go:932 +0x365

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-11-10 15:43:56.000 UTC</summary>

I am struggling to replicate this. I cannot panic from `workflow.Go` in a way that gets the stack small enough to replicate this. I can of course fix bounds size issue, but I would like a way to test. Can simple code to replicate be provided?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-10 18:56:00.000 UTC</summary>

Despite being unable to replicate, I am adding bounds checks to the stack trace line filter.

</details>


---

<a id="616"></a>

### #616: Investigate options around latency reporting and comparison with server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/616 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-02 20:39:32.000 UTC (4y 2m ago) |
| **Updated** | 2024-03-15 04:59:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement, external dependency |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

We are seeing some differences in client request latency and server request latency. This is to investigate ways to track that and find out why.

**Describe the solution you'd like**

We may want to try two things:

* Seeing if we can have the server have a gRPC interceptor that puts a start-to-end duration in gRPC metadata and have a number/percent at which a difference between that and the client duration are large enough to at least trigger a warning
* See if there is a gRPC metric that is low-level enough to apply to HTTP2 messages specifically so that we can see if there is a difference between our interceptor-based ones (that surround serialization and other operations) and the low-level ones



#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-11-02 20:52:00.000 UTC</summary>

It appears that https://pkg.go.dev/google.golang.org/grpc/stats is available to provide lower-level stats, I will confirm how it is implemented in gRPC itself and then look to expose that info.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-03 14:04:29.000 UTC</summary>

gRPC stats do happen after interceptors. I have made an example of using gRPC stats at https://github.com/temporalio/samples-go/compare/master...cretz:grpc-stats that require dial options exposed in https://github.com/temporalio/sdk-go/compare/master...cretz:grpc-options.

Will wait for feedback/updates on how to proceed.

</details>


---

<a id="607"></a>

### #607: Allow `EncodingDataConverter` to be context aware

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/607 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-10-28 15:37:28.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-16 18:44:26.000 UTC |
| **Closed** | 2021-11-16 18:44:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Encoding data converters and the payload encoders themselves cannot use contextual information

**Describe the solution you'd like**

See https://github.com/temporalio/samples-go/pull/147#discussion_r738384374. Basically we need to call underlying context aware data converter and return response, and also allow payload encoders be context aware.

Also update the sample at https://github.com/temporalio/samples-go/pull/147

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-11-01 19:19:23.000 UTC</summary>

@robholland - There is a bit of a problem here. We intentionally do not make the `converter` package aware of the `workflow` package (causes circular package dependency). Right now we have `workflow.ContextAware` and _technically_ we could have `workflow.EncodingContextAware` or `workflow.PayloadContextAware`, but in order to keep things reasonably separated, I think context awareness of an encoding converter may have to be a sample instead of something in code.

Thoughts?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-16 18:44:26.000 UTC</summary>

After some thought, we have decided to abandon context-awareness for encoding data converters at the moment.

</details>


---

<a id="603"></a>

### #603: Document/enforce `SignalWithStartWorkflow` does not use same workflow ID option as `ExecuteWorkflow`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/603 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-10-26 13:50:46.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-15 23:32:14.000 UTC |
| **Closed** | 2021-11-15 23:32:14.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

`SignalWithStartWorkflow` uses the `workflowID` parameter like `SignalWorkflow` instead of the ID in options like `ExecuteWorkflow`. That means the function accepts ID in two ways and ignores one.

**Describe the solution you'd like**

Document that the ID in options is disallowed and error if it is provided and is different than the `workflowID` parameter.


---

<a id="601"></a>

### #601: Support workflow metadata query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/601 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2021-10-25 15:50:14.000 UTC (4y 2m ago) |
| **Updated** | 2025-02-04 18:24:49.000 UTC |
| **Closed** | 2025-02-04 18:24:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See original issue temporalio/sdk-features#51

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-11-17 14:41:08.000 UTC</summary>

Waiting on SDK consensus here.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-02 21:26:06.000 UTC</summary>

See https://github.com/temporalio/features/issues/51

</details>


---

<a id="600"></a>

### #600: Child workflow logger being output during replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/600 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-10-22 18:09:22.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-03 13:23:44.000 UTC |
| **Closed** | 2021-11-03 13:23:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior

Logger by default should not log on replay in parent or child workflow.

## Actual Behavior

Based on user report, logger not logging on replay in parent workflow but is logging on replay in child workflow.

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-11-02 14:31:15.000 UTC</summary>

I am not able to replicate this. Every time I get a child workflow to replay (i.e. `workflow.IsReplaying(ctx) == true`) it does not log anything.

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-03 13:23:43.000 UTC</summary>

Confirmed from original user that this is not an issue.

</details>


---

<a id="587"></a>

### #587: panic: runtime error: index out of range [1532] with length 1532

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/587 |
| **State** | CLOSED |
| **Author** | JunaidMkdn (Junaid Muthukadan) |
| **Created** | 2021-10-14 06:39:54.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-01 17:54:20.000 UTC |
| **Closed** | 2021-11-01 17:54:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

no panics 

## Actual Behavior

panic: runtime error: index out of range [1532] with length 1532

goroutine 106 [running]:
github.com/temporalio/ringpop-go/swim.(*memberlist).MemberAt(0xc000136800, 0x5fc, 0xc000e0f540)
	/go/pkg/mod/github.com/temporalio/ringpop-go@v0.0.0-20200708034907-1e016ebb537a/swim/memberlist.go:196 +0x11d
github.com/temporalio/ringpop-go/swim.(*memberlistIter).Next(0xc0007b78a8, 0x40dbdb, 0x7fd423b56f18)
	/go/pkg/mod/github.com/temporalio/ringpop-go@v0.0.0-20200708034907-1e016ebb537a/swim/memberlist_iter.go:63 +0x105
github.com/temporalio/ringpop-go/swim.(*Node).pingNextMember(0xc0000a0b60)
	/go/pkg/mod/github.com/temporalio/ringpop-go@v0.0.0-20200708034907-1e016ebb537a/swim/node.go:512 +0x5f
github.com/temporalio/ringpop-go/swim.(*gossip).ProtocolPeriod(0xc00080e840)
	/go/pkg/mod/github.com/temporalio/ringpop-go@v0.0.0-20200708034907-1e016ebb537a/swim/gossip.go:177 +0x65
github.com/temporalio/ringpop-go/swim.scheduleRepeaditly.func1(0xc0009ba180, 0xc00042d380, 0xc00042d370, 0x269eed0, 0x3556178, 0xc00000e048)
	/go/pkg/mod/github.com/temporalio/ringpop-go@v0.0.0-20200708034907-1e016ebb537a/swim/schedule.go:30 +0x82
created by github.com/temporalio/ringpop-go/swim.scheduleRepeaditly
	/go/pkg/mod/github.com/temporalio/ringpop-go@v0.0.0-20200708034907-1e016ebb537a/swim/schedule.go:26 +0xdb



## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version: 1.6.0
  - Platform:


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-10-14 13:04:31.000 UTC</summary>

This appears like it may be an issue with https://github.com/temporalio/ringpop-go instead of this repository. It might be best to open the issue there with more detailed steps on how to replicate (granted the repository is not under active development).

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-01 17:54:20.000 UTC</summary>

Please feel free to reopen if this seems to be an issue with the Go SDK.

</details>


---

<a id="573"></a>

### #573: `temporal_activity_endtoend_latency` is not useful as-is

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/573 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2021-10-06 19:14:17.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-07 18:58:44.000 UTC |
| **Closed** | 2021-10-07 18:58:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This metric is almost completely duplicative of `activity_scheduletostart_latency` + `activity_execution_latency` currently. It provides effectively no value and is misleading.

Intuitively, it should be "time activity was first scheduled -> last activity execution successful finish"

Fixing it should be a matter of changing https://github.com/temporalio/sdk-go/blob/e739f5149504440fea33da4f8762554636c54170/internal/internal_task_pollers.go#L895 from using `GetStartedTime` to using `GetScheduledTime`

Additionally, it should only be recorded when the activity is completed successfully 

#### Comments (2)

<details>
<summary><strong>Sushisource</strong> commented on 2021-10-06 20:14:23.000 UTC</summary>

In Java: https://github.com/temporalio/sdk-java/issues/799

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-10-06 20:24:05.000 UTC</summary>

Match Java renames here: https://github.com/temporalio/sdk-java/pull/800

</details>


---

<a id="563"></a>

### #563: missing default retry policy for local activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/563 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-09-29 02:39:15.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-01 00:25:35.000 UTC |
| **Closed** | 2021-10-01 00:25:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
LocalActivity should be retried even when no retry policy is specified.

## Actual Behavior
LocalActivity is not retried if no retry policy is specified. Or if retry policy is specified with only MaxAttempt=3 and all other fields left as unspecified.

## additional
Need to add unit test AND integration test to verify both remote activity and local activity is retried when no retry policy is specified. Also, when retry policy is specified with only MaxAttempt = 3 and all other fields unspecified. 


#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-09-29 19:32:15.000 UTC</summary>

If no retry options are set, they will be nil, and [this code](https://github.com/temporalio/sdk-go/blob/ca2954d991b6a7ed6850641c502af3720d5aba4c/internal/internal_task_handlers.go#L985) is what will preventing LA retries.
In this case LA will not be retried upon failure within the same workflow task but instead will be relying on workflow task retries. Given that we retry workflow tasks until workflow itself times out this provides a natural catch all here.
Let's discuss if we want to change this behavior.

</details>

<details>
<summary><strong>yiminc</strong> commented on 2021-09-29 20:29:07.000 UTC</summary>

Why would the workflow task fail? The LA will return error without retry and workflow code will move on. 

</details>


---

<a id="560"></a>

### #560: Provide more customizable history output

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/560 |
| **State** | CLOSED |
| **Author** | lucperkins (Luc Perkins) |
| **Created** | 2021-09-26 02:55:43.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:33:01.000 UTC |
| **Closed** | 2021-11-18 15:33:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I have a use case for Temporal (and am using the Go SDK) that involves providing event histories for workflows. The output for `GetWorkflowHistory` is quite nice if you want to relay Temporal's raw event data elsewhere, but it's a bit hard to work with if you want to provide a more "massaged" variant of that data. In my case, I'm only interested in a handful of event types and want to extract specific portions of the `Attributes` payload for each `HistoryEvent`. But since `HistoryEvent` is at the moment pretty much directly derived from the underlying Protobuf definitions, it's really tricky to wrangle into a more custom shape. It would be quite useful to me to have more "Go-native" constructs available.

I'm certainly happy to help out with this if desired. But I wanted to check in first and see if there are already efforts underway in this domain.



#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-10-18 15:00:41.000 UTC</summary>

@lucperkins - Sorry for the delayed response. The raw history does let us remain compatible with the server, but it might make sense to have helpers around either the history object or the iterator to extract certain things. I am not sure it's reasonable to maintain a conversion of every history proto struct to a more idiomatic Go struct.

Can you give me an example of what you're extracting and maybe we can see if we can make the logic simpler?

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:33:01.000 UTC</summary>

I am closing this issue, but please comment or reopen with details you'd like to see. Unfortunately to remain compatible with server changes, we need to keep the raw history available, but maybe we can provide helpers.

</details>


---

<a id="546"></a>

### #546: TestActivityRetryOnHBTimeout is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/546 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 05:39:07.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:55.000 UTC |
| **Closed** | 2021-11-18 15:38:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

Error from the build pipeline:
```
=== RUN   TestIntegrationSuite/TestActivityRetryOnHBTimeout

Handling connection for 7233

2021/09/23 07:46:13 INFO  Started Worker Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@

2021/09/23 07:46:13 DEBUG ExecuteActivity Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@ WorkflowType ActivityRetryOnHBTimeout WorkflowID test-activity-retry-on-hbtimeout RunID 362e659a-3ea4-4d68-9577-461d4230c1f7 Attempt 1 ActivityID 5 ActivityType HeartbeatAndSleep

2021/09/23 07:46:13 INFO  Running HeartbeatAndSleep activity Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@ ActivityID 5 ActivityType HeartbeatAndSleep Attempt 1 WorkflowType ActivityRetryOnHBTimeout WorkflowID test-activity-retry-on-hbtimeout RunID 362e659a-3ea4-4d68-9577-461d4230c1f7

2021/09/23 07:46:15 INFO  Task processing failed with error Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@ WorkerType ActivityWorker Error invalid activityID or activity already timed out or invoking workflow is completed

2021/09/23 07:46:16 INFO  Running HeartbeatAndSleep activity Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@ ActivityID 5 ActivityType HeartbeatAndSleep Attempt 2 WorkflowType ActivityRetryOnHBTimeout WorkflowID test-activity-retry-on-hbtimeout RunID 362e659a-3ea4-4d68-9577-461d4230c1f7

2021/09/23 07:46:18 INFO  Task processing failed with error Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@ WorkerType ActivityWorker Error invalid activityID or activity already timed out or invoking workflow is completed

2021/09/23 07:46:19 INFO  Running HeartbeatAndSleep activity Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@ ActivityID 5 ActivityType HeartbeatAndSleep Attempt 3 WorkflowType ActivityRetryOnHBTimeout WorkflowID test-activity-retry-on-hbtimeout RunID 362e659a-3ea4-4d68-9577-461d4230c1f7

    TestIntegrationSuite: integration_test.go:382: 

        	Error Trace:	integration_test.go:382

        	Error:      	Received unexpected error:

        	            	workflow execution error (type: ActivityRetryOnHBTimeout, workflowID: test-activity-retry-on-hbtimeout, runID: 362e659a-3ea4-4d68-9577-461d4230c1f7): expected activity to fail but succeeded

        	Test:       	TestIntegrationSuite

2021/09/23 07:46:21 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-5-TestIntegrationSuite/TestActivityRetryOnHBTimeout WorkerID 6171@fdbd4600-e1aa-46fb-6b79-777ba48942e4@

    TestIntegrationSuite/TestActivityRetryOnHBTimeout: testing.go:916: test executed panic(nil) or runtime.Goexit: subtest may have called FailNow on a parent test
```

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2021-09-28 22:07:02.000 UTC</summary>

I think this was fixed (or at least improved) by #545 

</details>

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:55.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="521"></a>

### #521: Heartbeat data is not successfully recorded when an activity reports failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/521 |
| **State** | CLOSED |
| **Author** | robholland (Rob Holland) |
| **Created** | 2021-08-26 15:45:49.000 UTC (4y 4m ago) |
| **Updated** | 2021-10-08 21:41:19.000 UTC |
| **Closed** | 2021-10-08 21:41:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior

Running https://github.com/temporalio/samples-go/blob/master/retryactivity/retry_activity_workflow.go should work as the (passing) tests suggest and hand the correct heartbeat data over to the next activity attempt when the activity reports failure.

## Actual Behavior

The heartbeat batching code correctly attempts to send the last heartbeat data the activity recorded to the server when the activity fails. It seems that it re-uses the activity context to pass to the GRPC request function, but activity context is closed on the code path for activity failure handling, so the GRPC request is never made.

## Steps to Reproduce the Problem

  1. Run the sample against a Temporal server
  1. Watch it eventually exhaust it's retry attempts and fail because only the first heartbeat details the activity records per run are actually sent to the server

## Specifications

  - Version: 1.9.0
  - Platform: OS X (not relevant).


#### Comments (2)

<details>
<summary><strong>robholland</strong> commented on 2021-08-26 15:47:03.000 UTC</summary>

Diff of the code I used to help pinpoint this:

```diff
git diff                                                                                                                                                                                                                     â”€â•¯
diff --git a/internal/activity.go b/internal/activity.go
index b838030..884eb54 100644
--- a/internal/activity.go
+++ b/internal/activity.go
@@ -182,6 +182,7 @@ func HasHeartbeatDetails(ctx context.Context) bool {
 // retry attempt. Activity could extract the details by GetHeartbeatDetails() and resume from the progress.
 func GetHeartbeatDetails(ctx context.Context, d ...interface{}) error {
        env := getActivityEnv(ctx)
+       fmt.Printf("\nHeartbeat Details returned: %v\n", env.heartbeatDetails)
        if env.heartbeatDetails == nil {
                return ErrNoData
        }
diff --git a/internal/internal_task_handlers.go b/internal/internal_task_handlers.go
index 2823bc8..3e8ca1d 100644
--- a/internal/internal_task_handlers.go
+++ b/internal/internal_task_handlers.go
@@ -1604,6 +1604,8 @@ type temporalInvoker struct {
 }

 func (i *temporalInvoker) Heartbeat(ctx context.Context, details *commonpb.Payloads, skipBatching bool) error {
+       fmt.Printf("\nHeartbeat: %v\n", details)
+
        i.Lock()
        defer i.Unlock()

@@ -1636,9 +1638,12 @@ func (i *temporalInvoker) Heartbeat(ctx context.Context, details *commonpb.Paylo
                        select {
                        case <-i.hbBatchEndTimer.C:
                                // We are close to deadline.
+                               fmt.Printf("\nEvent: deadline\n")
                        case <-i.workerStopChannel:
                                // Activity worker is close to stop. This does the same steps as batch timer ends.
+                               fmt.Printf("\nEvent: worker stop\n")
                        case <-i.closeCh:
+                               fmt.Printf("\nEvent: closed\n")
                                // We got closed.
                                return
                        }
@@ -1648,6 +1653,7 @@ func (i *temporalInvoker) Heartbeat(ctx context.Context, details *commonpb.Paylo

                        i.Lock()
                        detailsToReport = i.lastDetailsToReport
+                       fmt.Printf("\nHeartbeat Details: %v\n", detailsToReport)
                        i.hbBatchEndTimer.Stop()
                        i.hbBatchEndTimer = nil
                        i.Unlock()
@@ -1666,6 +1672,8 @@ func (i *temporalInvoker) Heartbeat(ctx context.Context, details *commonpb.Paylo
 }

 func (i *temporalInvoker) internalHeartBeat(ctx context.Context, details *commonpb.Payloads) (bool, error) {
+       fmt.Printf("\nHeartbeat Sent: %v\n", details)
+
        isActivityCanceled := false
        timeout := i.heartBeatTimeout
        if timeout <= 0 {
@@ -1676,6 +1684,8 @@ func (i *temporalInvoker) internalHeartBeat(ctx context.Context, details *common

        err := recordActivityHeartbeat(ctx, i.service, i.metricsScope, i.identity, i.taskToken, details)

+       fmt.Printf("\nHeartbeat Request Error: %v\n", err)
+
        switch err.(type) {
        case *CanceledError:
                // We are asked to cancel. inform the activity about cancellation through context.
@@ -1888,6 +1898,7 @@ func recordActivityHeartbeat(ctx context.Context, service workflowservice.Workfl
        defer cancel()

        heartbeatResponse, err := service.RecordActivityTaskHeartbeat(grpcCtx, request)
+       fmt.Printf("\nHeartbeat GRPC Request Error: %v\n", err)
        if err == nil && heartbeatResponse != nil && heartbeatResponse.GetCancelRequested() {
                return NewCanceledError()
        }
```

</details>

<details>
<summary><strong>robholland</strong> commented on 2021-08-26 15:48:46.000 UTC</summary>

Example worker output when running the retryactivity sample:

```
2021/08/26 16:47:40 DEBUG ExecuteActivity Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 Attempt 1 ActivityID 5 ActivityType BatchProcessingActivity
2021/08/26 16:47:40 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 0

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[48],},},}

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[48],},},}

Heartbeat GRPC Request Error: <nil>

Heartbeat Request Error: <nil>
2021/08/26 16:47:41 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 0
2021/08/26 16:47:41 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 1

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[49],},},}
2021/08/26 16:47:42 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 1
2021/08/26 16:47:42 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 2

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[50],},},}
2021/08/26 16:47:43 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 2
2021/08/26 16:47:43 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 3

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[51],},},}
2021/08/26 16:47:44 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 3
2021/08/26 16:47:44 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 4

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[52],},},}
2021/08/26 16:47:45 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 4
2021/08/26 16:47:45 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 5

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[53],},},}
2021/08/26 16:47:46 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 5
2021/08/26 16:47:46 INFO  Activity failed, will retry... Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 1 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4
2021/08/26 16:47:46 ERROR Activity error. Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ActivityType BatchProcessingActivity Attempt 1 Error some retryable error (type: SomeType, retryable: true)

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[53],},},}

Event: closed

Heartbeat GRPC Request Error: context canceled

Heartbeat Request Error: context canceled

Heartbeat Details returned: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[48],},},}
2021/08/26 16:47:47 INFO  Resuming from failed attempt Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 0
2021/08/26 16:47:47 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 1

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[49],},},}

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[49],},},}

Heartbeat GRPC Request Error: <nil>

Heartbeat Request Error: <nil>
2021/08/26 16:47:48 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 1
2021/08/26 16:47:48 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 2

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[50],},},}
2021/08/26 16:47:49 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 2
2021/08/26 16:47:49 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 3

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[51],},},}
2021/08/26 16:47:50 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 3
2021/08/26 16:47:50 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 4

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[52],},},}
2021/08/26 16:47:51 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 4
2021/08/26 16:47:51 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 5

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[53],},},}
2021/08/26 16:47:52 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 5
2021/08/26 16:47:52 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 6

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[54],},},}
2021/08/26 16:47:53 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 6
2021/08/26 16:47:53 INFO  Activity failed, will retry... Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 2 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4
2021/08/26 16:47:53 ERROR Activity error. Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ActivityType BatchProcessingActivity Attempt 2 Error some retryable error (type: SomeType, retryable: true)

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[54],},},}

Event: closed

Heartbeat GRPC Request Error: context canceled

Heartbeat Request Error: context canceled

Heartbeat Details returned: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[49],},},}
2021/08/26 16:47:55 INFO  Resuming from failed attempt Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 1
2021/08/26 16:47:55 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 2

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[50],},},}

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[50],},},}

Heartbeat GRPC Request Error: <nil>

Heartbeat Request Error: <nil>
2021/08/26 16:47:56 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 2
2021/08/26 16:47:56 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 3

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[51],},},}
2021/08/26 16:47:57 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 3
2021/08/26 16:47:57 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 4

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[52],},},}
2021/08/26 16:47:58 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 4
2021/08/26 16:47:58 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 5

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[53],},},}
2021/08/26 16:47:59 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 5
2021/08/26 16:47:59 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 6

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[54],},},}
2021/08/26 16:48:00 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 6
2021/08/26 16:48:00 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 7

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[55],},},}
2021/08/26 16:48:01 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 7
2021/08/26 16:48:01 INFO  Activity failed, will retry... Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 3 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4
2021/08/26 16:48:01 ERROR Activity error. Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ActivityType BatchProcessingActivity Attempt 3 Error some retryable error (type: SomeType, retryable: true)

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[55],},},}

Event: closed

Heartbeat GRPC Request Error: context canceled

Heartbeat Request Error: context canceled

Heartbeat Details returned: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[50],},},}
2021/08/26 16:48:05 INFO  Resuming from failed attempt Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 2
2021/08/26 16:48:05 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 3

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[51],},},}

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[51],},},}

Heartbeat GRPC Request Error: <nil>

Heartbeat Request Error: <nil>
2021/08/26 16:48:06 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 3
2021/08/26 16:48:06 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 4

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[52],},},}
2021/08/26 16:48:07 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 4
2021/08/26 16:48:07 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 5

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[53],},},}
2021/08/26 16:48:08 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 5
2021/08/26 16:48:08 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 6

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[54],},},}
2021/08/26 16:48:09 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 6
2021/08/26 16:48:09 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 7

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[55],},},}
2021/08/26 16:48:10 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 7
2021/08/26 16:48:10 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 8

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[56],},},}
2021/08/26 16:48:11 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 8
2021/08/26 16:48:11 INFO  Activity failed, will retry... Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 4 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4
2021/08/26 16:48:11 ERROR Activity error. Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ActivityType BatchProcessingActivity Attempt 4 Error some retryable error (type: SomeType, retryable: true)

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[56],},},}

Event: closed

Heartbeat GRPC Request Error: context canceled

Heartbeat Request Error: context canceled

Heartbeat Details returned: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[51],},},}
2021/08/26 16:48:19 INFO  Resuming from failed attempt Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 3
2021/08/26 16:48:19 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 4

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[52],},},}

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[52],},},}

Heartbeat GRPC Request Error: <nil>

Heartbeat Request Error: <nil>
2021/08/26 16:48:20 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 4
2021/08/26 16:48:20 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 5

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[53],},},}
2021/08/26 16:48:21 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 5
2021/08/26 16:48:21 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 6

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[54],},},}
2021/08/26 16:48:22 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 6
2021/08/26 16:48:22 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 7

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[55],},},}
2021/08/26 16:48:23 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 7
2021/08/26 16:48:23 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 8

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[56],},},}
2021/08/26 16:48:24 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 8
2021/08/26 16:48:24 INFO  processing task Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 TaskID 9

Heartbeat: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[57],},},}
2021/08/26 16:48:25 INFO  Recording heartbeat Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ReportedProgress 9
2021/08/26 16:48:25 INFO  Activity failed, will retry... Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ ActivityID 5 ActivityType BatchProcessingActivity Attempt 5 WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4
2021/08/26 16:48:25 ERROR Activity error. Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 ActivityType BatchProcessingActivity Attempt 5 Error some retryable error (type: SomeType, retryable: true)

Heartbeat Sent: &Payloads{Payloads:[]*Payload{&Payload{Metadata:map[string][]byte{encoding: [106 115 111 110 47 112 108 97 105 110],},Data:[57],},},}

Event: closed

Heartbeat GRPC Request Error: context canceled

Heartbeat Request Error: context canceled
2021/08/26 16:48:25 INFO  Workflow completed with error. Namespace default TaskQueue retry-activity WorkerID 97704@RobTemporal-MacBook.local@ WorkflowType RetryWorkflow WorkflowID retry_activity_d4343d2e-1a16-4101-82f1-8ef11637e2a9 RunID 4497c9f6-a862-42f7-912d-6400cc89ddc4 Attempt 1 Error activity error (type: BatchProcessingActivity, scheduledEventID: 5, startedEventID: 6, identity: 97704@RobTemporal-MacBook.local@): some retryable error (type: SomeType, retryable: true)

```

</details>


---

<a id="513"></a>

### #513: Use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` for non-deterministic workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/513 |
| **State** | CLOSED |
| **Author** | wxing1292 (Wenquan Xing) |
| **Created** | 2021-08-10 21:56:20.000 UTC (4y 5m ago) |
| **Updated** | 2022-05-03 14:33:03.000 UTC |
| **Closed** | 2022-05-03 14:33:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` as cause for `RespondWorkflowTaskFailed` if user workflow logic is non-deterministic

Ref: https://github.com/temporalio/temporal/pull/1726


#### Comments (2)

<details>
<summary><strong>Sushisource</strong> commented on 2021-08-17 16:40:53.000 UTC</summary>

FYI this requires organizing and categorizing pretty much everywhere errors can be thrown in the SDK, which is potentially quite a lot of work/change.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-27 20:30:11.000 UTC</summary>

We'll (hopefully) be looking into doing this soon

</details>


---

<a id="500"></a>

### #500: [Bug?] Incorrect error `Call with too few input arguments` when activity uses the wrong context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/500 |
| **State** | CLOSED |
| **Author** | swyxio (swyx.io) |
| **Created** | 2021-07-28 20:45:51.000 UTC (4y 5m ago) |
| **Updated** | 2023-07-30 14:35:43.000 UTC |
| **Closed** | 2023-07-30 14:35:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Steps to Reproduce the Problem

i made a repro repo for you! https://github.com/sw-yx/temp-workflow-repro please see this repo to see the issue

![CleanShot 2021-07-28 at 13 44 54@2x](https://user-images.githubusercontent.com/6764957/127393422-05d0020f-59e4-447d-ae6d-f12c46de2188.png)


## Specifications

  - Version: latest
  - Platform: mac


#### Comments (2)

<details>
<summary><strong>Delicious-Bacon</strong> commented on 2022-05-27 17:09:28.000 UTC</summary>

I had this too. The error does not provide good information.

Thanks to the OP for spotting this one!

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-30 14:35:43.000 UTC</summary>

https://github.com/temporalio/sdk-go/pull/1093

</details>


---

<a id="497"></a>

### #497: [Test suite] Query after signal works in SDK, but not in Test Suite

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/497 |
| **State** | OPEN |
| **Author** | swyxio (swyx.io) |
| **Created** | 2021-07-26 17:04:40.000 UTC (4y 5m ago) |
| **Updated** | 2021-10-28 13:46:09.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

According to @mfateev, "The inability to query after the signal is purely Go testing framework limitation. In both real Go applications and Java (including unit testing) we provide read after write consistency in signal then query case. I think we want to file an issue to fix the Go testing framework."

**Describe the solution you'd like**

We shouldn't need to break up the signal and the query here: https://docs.temporal.io/blog/build-an-ecommerce-app-with-temporal-part-3-testing#signaling-workflows-in-tests in different delayed callbacks just for testing, because that isn't reflective of real life usage.


**Additional context**

In https://docs.temporal.io/blog/build-an-ecommerce-app-with-temporal-part-3-testing, we ran into this.



---

<a id="442"></a>

### #442: Reported Metrics around availability include initial retry failures even if final call succeeds

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/442 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2021-05-14 01:35:43.000 UTC (4y 8m ago) |
| **Updated** | 2021-06-09 05:09:51.000 UTC |
| **Closed** | 2021-06-09 05:09:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
If, due to some transient issue, the SDK fails on its first attempt to call Temporal, but succeeds on a retry, the metric reports 1 failure and 1 success, which could be misleading. This is because the metric emission happens on an interceptor that is triggered per-request:

```
// NewScopeInterceptor creates new metrics scope interceptor.
func NewScopeInterceptor(defaultScope tally.Scope) grpc.UnaryClientInterceptor {
	return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		scope, ok := ctx.Value(ScopeContextKey).(tally.Scope)
		if !ok || scope == nil {
			scope = defaultScope
		}
		isLongPoll, ok := ctx.Value(LongPollContextKey).(bool)
		if !ok {
			isLongPoll = false
		}
		rs := newRequestScope(scope, method, isLongPoll)
		rs.recordStart()
		err := invoker(ctx, method, req, reply, cc, opts...)
		rs.recordEnd(err)
		return err
	}
}
```

Ideal behavior would be to differentiate "overall" SLA vs SLA including retry failures.

#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-27 06:52:51.000 UTC</summary>

I think existing metrics are good as they are because they give us detailed view of the server behavior. 
Your ask for a higher level metric that would exclude retries makes sense though, and we could add it on top of existing ones.
If I understand you correctly you want something like a replay aware `WorkflowOutboundCallsInterceptor` that would publish success/failure rate for all calls?

</details>

<details>
<summary><strong>mastermanu</strong> commented on 2021-05-27 23:37:54.000 UTC</summary>

Yes, an additional metric that excludes retries for ultimately successful calls would be useful.  Even though this metric would not include the intermediate retries, the retries should still be in the calculated latency.

Not sure if this applies to any "replay-aware" interceptors though. This is purely about distinguishing between intermediate retries vs final success rate for gRPC calls to temporal server. Maybe I am misunderstanding where replay comes into the picture?

</details>


---

<a id="439"></a>

### #439: Include a way to perform assertions on the workflow signal channel in the testing environment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/439 |
| **State** | OPEN |
| **Author** | ingyamilmolinar (ymolinar) |
| **Created** | 2021-05-11 19:22:29.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-11 19:22:29.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

There's no way to observe the state of the workflow signal channel and perform assertions on it. Currently, I cannot know whether or not all received signals were consumed by the workflow.

An env.GetWorkflowSignalChannel() or something similar will be a great addition to the testing environment.

I'm unable to find a workaround for this situation without modifying workflow code.


---

<a id="431"></a>

### #431: ActivityEndToEndLatency Incorrectly Recorded

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/431 |
| **State** | CLOSED |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2021-05-06 01:23:21.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-10 07:24:50.000 UTC |
| **Closed** | 2021-05-10 07:24:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Activity end to end latency is from when the activity task was scheduled to when the activity task response was completed.

## Actual Behavior
Activity end to end latency is incorrect.

```
activityMetricsScope.Timer(metrics.ActivityEndToEndLatency).Record(time.Since(activityTask.pollStartTime))
```

pollStartTime is defined here: https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_pollers.go#L825, but that's the start time of when the poll was started that received the activity task, not the start time of the actual activity task. 

It should line up with how ScheduleToStart is calculated, which uses the GetStartTime() method on the returned task: https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_pollers.go#L851

## Specifications

  - Version: 1.6.0
  - Platform: N/A


#### Comments (2)

<details>
<summary><strong>sjmtan</strong> commented on 2021-05-06 01:23:30.000 UTC</summary>

CC @mastermanu 

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-05-10 07:24:49.000 UTC</summary>

This issue should be resolved as PR has been merged.

</details>


---

<a id="420"></a>

### #420: Get history size information in workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/420 |
| **State** | CLOSED |
| **Author** | daigx |
| **Created** | 2021-04-29 02:01:32.000 UTC (4y 8m ago) |
| **Updated** | 2023-10-16 17:47:52.000 UTC |
| **Closed** | 2023-10-16 17:47:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I'm seeing **history size exceeds error limit** error. We have DSL on top of Temporal, so I'm not able to decided when to continue workflow as new. If user define DSL with some big for loop, it will cause **history size exceeds error limit** error. 

**example error message**
```
"msg": "history size exceeds error limit.",
"wf-history-size": 14013736,
"wf-event-count": 51201,
```

**Describe the solution you'd like**
Is it possible to return history size information trough workflow.GetInfo(ctx)? In this way, I'm able to check **wf-history-size** and **wf-event-count** in workflow to decide continue as new or not.


#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-07 06:07:10.000 UTC</summary>

I think this is a valid feature request, I'll discuss with the team if we have good way to expose this information.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-16 17:47:46.000 UTC</summary>

Workflow info now includes history size and length

</details>


---

<a id="405"></a>

### #405: Struct pointer to Activities is nil when executed using ExecuteLocalActivity 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/405 |
| **State** | CLOSED |
| **Author** | ghstahl (Herb Stahl) |
| **Created** | 2021-04-13 18:44:43.000 UTC (4y 9m ago) |
| **Updated** | 2023-05-24 08:03:42.000 UTC |
| **Closed** | 2023-05-24 08:03:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior
Activities executed should not behave differently when executed using either ***ExecuteActivity*** or ***ExecuteLocalActivity***  

## Actual Behavior
***ExecuteLocalActivity***  results in the struct pointer to the activities being nil.   

## Steps to Reproduce the Problem

  [reproduced project](https://github.com/fluffy-bunny/temporal-go-localexecute-issue)   

When registering activites using a struct as such;

## Activities  
```go
type BeautifulActivities struct {
}

var MyBeautifulActivities *BeautifulActivities

func NewBeautifulActivities() *BeautifulActivities {
	return &BeautifulActivities{}
}
func (a *BeautifulActivities) ComposeGreeting(name string) (string, error) {
	if a == nil {
		// This happens when ExecuteLocalActivity
		fmt.Println("Ermaghd me pointer is nil!")
		panic("Ermaghd me pointer is nil!")
	} else {
		fmt.Println("Nothing to see here, everything is A-OK!")
	}
	greeting := fmt.Sprintf("Hello %s!", name)
	return greeting, nil
}
```
## Registering Activities  
```go
act := app.NewBeautifulActivities()
w.RegisterActivity(act)
``` 
Results in the pointer to **\*BeautifulActivities** being nil if the activity is executed locally.  
```go 
func (a *BeautifulActivities) ComposeGreeting(name string) (string, error) {
// a is nil - panic
}
```  

```go
localOptions := workflow.LocalActivityOptions{
		StartToCloseTimeout: time.Second * 5,
}
ctx = workflow.WithLocalActivityOptions(ctx, localOptions)
err = workflow.ExecuteLocalActivity(ctx, MyBeautifulActivities.ComposeGreeting, name).Get(ctx, &result)
```

This does not happen when the activity is executed normally.  
```go
options := workflow.ActivityOptions{
		StartToCloseTimeout: time.Second * 5,
}
ctx = workflow.WithActivityOptions(ctx, options)
var result string
err := workflow.ExecuteActivity(ctx, MyBeautifulActivities.ComposeGreeting, name).Get(ctx, &result)
```
## Specifications

  - Version:
  - Platform:
```yaml
version: "3.5"
services:
  cassandra:
    container_name: temporal-cassandra
    image: cassandra:3.11.9
    networks:
      - temporal-network
    ports:
      - 9042:9042
  temporal:
    container_name: temporal
    depends_on:
      - cassandra
    environment:
      - CASSANDRA_SEEDS=cassandra
      - DYNAMIC_CONFIG_FILE_PATH=config/dynamicconfig/development.yaml
    image: temporalio/auto-setup:1.8.1
    networks:
      - temporal-network
    ports:
      - 7233:7233
    volumes:
      - ./dynamicconfig:/etc/temporal/config/dynamicconfig
  temporal-admin-tools:
    container_name: temporal-admin-tools
    depends_on:
      - temporal
    environment:
      - TEMPORAL_CLI_ADDRESS=temporal:7233
    image: temporalio/admin-tools:1.8.1
    networks:
      - temporal-network
    stdin_open: true
    tty: true
  temporal-web:
    container_name: temporal-web
    depends_on:
      - temporal
    environment:
      - TEMPORAL_GRPC_ENDPOINT=temporal:7233
      - TEMPORAL_PERMIT_WRITE_API=true
    image: temporalio/web:1.8.1
    networks:
      - temporal-network
    ports:
      - 8088:8088
networks:
  temporal-network:
    driver: bridge
    name: temporal-network

```

#### Comments (2)

<details>
<summary><strong>Sushisource</strong> commented on 2021-05-12 18:43:41.000 UTC</summary>

@ghstahl This should be fixed by #436 - give it a shot and let us know

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-24 08:03:41.000 UTC</summary>

closing as this is fixed by https://github.com/temporalio/sdk-go/pull/426

</details>


---

<a id="359"></a>

### #359: Add deterministic range over map helper

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/359 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-02-11 02:16:13.000 UTC (4y 11m ago) |
| **Updated** | 2024-01-09 20:05:24.000 UTC |
| **Closed** | 2024-01-09 20:05:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Go built in range over map is not deterministic. The workaround has to be implemented by each user.

**Describe the solution you'd like**
Some helper to support deterministic iteration over map.



#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-10 22:26:03.000 UTC</summary>

Was deferring this until [range over func](https://github.com/golang/go/wiki/RangefuncExperiment) support was added in Go 1.22, but looks like that didn't make that release.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-12-11 13:46:40.000 UTC</summary>

It should be noted that the only way this can be done is either 1) requiring that map keys are comparable (that is not required by Go today, just equality, but you can require this with Go generics) or 2) storing the map keys in some deterministic way for replay.

</details>


---

<a id="358"></a>

### #358: [Bug] the json input is invalid in the workflow history and with a wrong encoding for accents

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/358 |
| **State** | OPEN |
| **Author** | lerminou (Nicolas DUBUT) |
| **Created** | 2020-11-17 09:58:49.000 UTC (5y 1m ago) |
| **Updated** | 2021-02-11 01:27:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I want to copy the input to perform a check on the json
The input payload should be well structured

## Actual Behavior
When debugging a failed workflow through the temporal web, I wanted to check the input filled.
Actually, the input payload is invalid
![image](https://user-images.githubusercontent.com/3818051/99374927-67321000-28c3-11eb-9a07-413657e0b57e.png)
![image](https://user-images.githubusercontent.com/3818051/99375136-aa8c7e80-28c3-11eb-98b9-e95304d1ff00.png)


## Steps to Reproduce the Problem

  1. launch a workflow with an input json
  1. check the temporal web or call the /history API
  1.

## Specifications

  - Version: 1.3.0
  - Platform: docker-compose


#### Comments (2)

<details>
<summary><strong>lerminou</strong> commented on 2020-11-23 10:46:11.000 UTC</summary>

Temporal encoding doesn't support accents in the input too.
`firstName:Pr\\u00e9nom test` for `firstName:PrÃ©nom test`

</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-11 01:27:10.000 UTC</summary>

@vitarb @Sushisource afaik this relates to all sdks?

</details>


---

<a id="352"></a>

### #352: ReplayLogger.With doesn't expand keyvals variadic function parameter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/352 |
| **State** | CLOSED |
| **Author** | smkent (Stephen Kent) |
| **Created** | 2021-01-28 00:52:19.000 UTC (4y 11m ago) |
| **Updated** | 2021-03-18 19:00:37.000 UTC |
| **Closed** | 2021-03-18 19:00:37.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

## Expected Behavior

When using the temporal logger, adding values with `With("key", "value", /* etc */)` should send these values as separate arguments to the underlying logger's `With` method

## Actual behavior

When using the temporal logger, adding values with `With("key", "value", /* etc */)` fails because all of the arguments end up getting passed to the underlying logger as a single array argument instead of the expanded values as separate arguments.

## Requested fix

`keyvals` on this line:
https://github.com/temporalio/sdk-go/blob/540ca8003df06414b05851bdf975aa1ebd2d816f/internal/log/replay_logger.go#L81

needs to have `...` appended like so:

```go
return NewReplayLogger(With(l.logger, keyvals...), l.isReplay, l.enableLoggingInReplay) 
```



---

<a id="292"></a>

### #292: [doc] Should remove all activity.Register in document

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/292 |
| **State** | CLOSED |
| **Author** | giautm (Giau. Tran Minh) |
| **Created** | 2020-11-17 19:29:34.000 UTC (5y 1m ago) |
| **Updated** | 2020-12-22 23:52:48.000 UTC |
| **Closed** | 2020-12-22 23:52:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | flossypurse |
| **Milestone** | None |

#### Description

I found three places mention about activity.Register. https://github.com/temporalio/sdk-go/pull/41

https://github.com/temporalio/sdk-go/blob/88b35b585712dcbeb3e493036b32f8a5baecd91c/activity/doc.go#L45-L47

https://github.com/temporalio/sdk-go/blob/88b35b585712dcbeb3e493036b32f8a5baecd91c/activity/doc.go#L184-L188

https://github.com/temporalio/sdk-go/blob/88b35b585712dcbeb3e493036b32f8a5baecd91c/worker/worker.go#L121

#### Comments (2)

<details>
<summary><strong>flossypurse</strong> commented on 2020-12-07 17:34:03.000 UTC</summary>

Addressing these issues here: https://github.com/temporalio/sdk-go/pull/306

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2020-12-22 23:52:48.000 UTC</summary>

Was fixed in #306 

Reactions: ðŸŽ‰ 1

</details>


---

<a id="280"></a>

### #280: Add a Registry/WorkerRegistry interface to the worker package

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/280 |
| **State** | CLOSED |
| **Author** | sagikazarmark (MÃ¡rk SÃ¡gi-KazÃ¡r) |
| **Created** | 2020-11-05 21:24:41.000 UTC (5y 2m ago) |
| **Updated** | 2020-11-08 01:22:09.000 UTC |
| **Closed** | 2020-11-08 01:22:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When registering workflows/activities in a worker, consumers often don't need the Start and Stop methods of the worker interface.

**Describe the solution you'd like**
Define a `Registry` or a `WorkerRegistry` interface in the worker package with the registration methods and embed it in the worker interface. Consumers can use this interface instead of the `Worker` interface. Although in Go consumers usually own interfaces, in this case the interface and the use case is well-defined by the provider, so it makes sense to define it in the worker package.


#### Comments (2)

<details>
<summary><strong>sagikazarmark</strong> commented on 2020-11-05 23:28:39.000 UTC</summary>

Further thinking about this, I'd also consider splitting the methods up to `WorkflowRegistry` and `ActivityRegistry`.

Reactions: ðŸ‘ 1

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-11-06 02:01:16.000 UTC</summary>

PR is welcome

</details>


---

<a id="266"></a>

### #266: Expose activity start and completion information to the workflow code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/266 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-10-08 22:54:38.000 UTC (5y 3m ago) |
| **Updated** | 2020-10-08 22:54:38.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

Same request for Java: https://github.com/temporalio/sdk-java/issues/228


---

<a id="228"></a>

### #228: Workflow hangs if we try to run two local activities in parallel

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/228 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2020-08-12 17:28:27.000 UTC (5y 5m ago) |
| **Updated** | 2020-08-14 06:41:21.000 UTC |
| **Closed** | 2020-08-14 06:41:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | mfateev, samarabbas, mastermanu |
| **Milestone** | None |

#### Description

## Expected Behavior
Both activities execute and finish.

## Actual Behavior
Only one of the activities execute. The other one never even starts executing and the workflow is just stuck

## Steps to Reproduce the Problem
Create a Workflow that spawns and waits for two LOCAL activities.

## Specifications

  - Version:
  - Platform:


#### Comments (2)

<details>
<summary><strong>mastermanu</strong> commented on 2020-08-12 17:31:34.000 UTC</summary>

Was able to reproduce this was a simple integration test. Am debugging

</details>

<details>
<summary><strong>mastermanu</strong> commented on 2020-08-12 22:26:01.000 UTC</summary>

The Go SDK currently has a bug where Local Activities executed in parallel cause the Workflow to hang.
The issue here is that for Local Activities started in parallel, they are incorrectly assigned the same activity ID as it uses the "next command event ID" and for local activities, that next command event ID is only incremented when the local activity finishes.

Furthermore, that local activity ID is then used on replay to match a previous local activity result with a blocked future, which means that if we were to just change the semantics blindly on the client (to perhaps use a separate id counter for local activities), existing workflows with local activity IDs would pretty much be broken, so we need to find a way to fix this in a backwards compatible fashion.

Relevant code:
go-sdk/internal/internal_decision_state_machine.go

Line 891 in 00fb030

 func (h *commandsHelper) recordLocalActivityMarker(activityID string, details map[string]*commonpb.Payloads, failure *failurepb.Failure) commandStateMachine { 
--> This is where the command ID is incremented for a local activity
go-sdk/internal/internal_event_handlers.go

Line 1114 in 478fbb8

 func (weh *workflowExecutionEventHandlerImpl) handleLocalActivityMarker(details map[string]*commonpb.Payloads, failure *failurepb.Failure) error { 
--> This is where we process previous local activity results on replay
go-sdk/internal/internal_event_handlers.go

Line 483 in 478fbb8

 activityID := wc.GenerateSequenceID() 
--> This is where the local activityID is assigned. The GenerateSequenceID() returns the same ID unless an actual command happens, which is why multiple local activities spawned result in having the same activity ID.
TO BE FURTHER INVESTIGATED: The same issue could potentially exist for mutable side effects and regular side effects that were spawned in parallel if they are on actually on separate Go Routines as they get the sequence number and increment after execution is finished. In that case, the sideeffect ID would be overwritten by the last write that wins.

</details>


---

<a id="190"></a>

### #190: testsuite context propagation is broken

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/190 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-07-13 01:58:58.000 UTC (5y 6m ago) |
| **Updated** | 2020-11-24 00:15:03.000 UTC |
| **Closed** | 2020-11-24 00:15:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug, potential-bug |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

## Expected Behavior
Context propagation works during unit tests

## Actual Behavior
The code path that extracts headers from context passed to testWorkflowEnvironment.Execute is not present in the testsuite code.

## Steps to Reproduce the Problem

  1. Run contextpropagator unit test: https://github.com/temporalio/go-samples/blob/c0e2921476b95ad959cb20cc2933ad59784af5ab/ctxpropagation/workflow_test.go#L22

## Specifications

  - Version: 0.26.0 of SDK/Service



#### Comments (2)

<details>
<summary><strong>alexshtin</strong> commented on 2020-07-14 00:25:39.000 UTC</summary>

Looks like duplicate of #29.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2020-11-24 00:15:03.000 UTC</summary>

Closing as dupelicate

</details>


---

<a id="118"></a>

### #118: ChildWorkflow inherits WorkflowRunTimeout from parent

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/118 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-05-03 21:17:54.000 UTC (5y 8m ago) |
| **Updated** | 2020-07-19 23:10:21.000 UTC |
| **Closed** | 2020-07-19 23:10:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | samarabbas |
| **Milestone** | Code Complete |

#### Description

Recently we changed definition of timeouts for workflow.  Based on the new definition all timeouts on workflow are now optional.  Here are the new timeouts:
1. WorkflowExecutionTimeout
2. WorkflowRunTimeout
3. WorkflowTaskTimeout

Default for WorkflowExecutionTimeout is 10 years, and default for WorkflowRunTimeout is same as WorkflowExecutionTimeout.
In the case of ChildWorkflow, looks like we inherit WorkflowRunTimeout from parent execution.  This seems counter intuitive in the following case.

Parent is started with WorkflowExecutionTimeout of 1 minute.
```
workflowOptions := client.StartWorkflowOptions{
		ID:                       workflowID,
		TaskList:                 "child-workflow-task-list",
		WorkflowExecutionTimeout: time.Minute,
	}
```

Child Workflow execution is started with WorkflowExecutionTimeout of 30 minutes:
```
cwo := workflow.ChildWorkflowOptions{
		WorkflowID:               childID,
		WorkflowExecutionTimeout: 30 * time.Minute,
	}
```

Now when child is started, workflow execution timeout is 30 minutes but workflow run timeout is 1 minutes:

```
./tctl wf show -w 1 -pdt
  1  2020-05-03T14:03:39-07:00  WorkflowExecutionStarted     {WorkflowType:{Name:SampleChildWorkflow}, ParentWorkflowNamespace:default,
                                                              ParentWorkflowExecution:{WorkflowId:parent-workflow_40416b51-c93a-46ef-a132-904f2f7aad21,
                                                              RunId:ecbfdd56-be57-48be-af24-5d14d63aa402}, ParentInitiatedEventId:5,
                                                              TaskList:{Name:child-workflow-task-list, Kind:Normal},
                                                              Input:{Payloads:[len=2]}, WorkflowExecutionTimeoutSeconds:1800,
                                                              WorkflowRunTimeoutSeconds:60, WorkflowTaskTimeoutSeconds:10,
                                                              Initiator:Decider, OriginalExecutionRunId:5d75373b-867b-454f-ba63-4a52c37dea17,
                                                              FirstExecutionRunId:5d75373b-867b-454f-ba63-4a52c37dea17, Attempt:0,
                                                              WorkflowExecutionExpirationTimestamp:0, FirstDecisionTaskBackoffSeconds:0,
                                                              Header:{Fields:map{}}}
```

#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2020-05-04 03:20:27.000 UTC</summary>

Agree, defaulting child to the execution timeout that was specified by the parent makes more sense.

</details>

<details>
<summary><strong>samarabbas</strong> commented on 2020-07-19 23:10:08.000 UTC</summary>

This is a server side issue.  Ported as https://github.com/temporalio/temporal/issues/565

</details>


---

<a id="104"></a>

### #104: Panic in serviceerror.FromStatus

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/104 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-19 23:10:23.000 UTC (5y 8m ago) |
| **Updated** | 2020-04-24 17:57:41.000 UTC |
| **Closed** | 2020-04-24 17:57:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

It looks like the service doesn't include NotFound into details:

<img width="511" alt="Screen Shot 2020-04-19 at 7 11 10 PM" src="https://user-images.githubusercontent.com/1463622/79707544-b2bf0580-8271-11ea-80f5-5d27ca6a6e2c.png">

```
GOROOT=/usr/local/go #gosetup
GOPATH=/Users/maxim/go #gosetup
/usr/local/go/bin/go build -o /private/var/folders/q2/4s0fwr9s30zbg8qr8tw8y_440000gn/T/___go_build_main_go__1_ /Users/maxim/temporal/temporal-go-samples/helloworld/starter/main.go #gosetup
/private/var/folders/q2/4s0fwr9s30zbg8qr8tw8y_440000gn/T/___go_build_main_go__1_ #gosetup
panic: interface conversion: interface {} is nil, not *failure.NotFound

goroutine 1 [running]:
go.temporal.io/temporal-proto/serviceerror.FromStatus(0xc000010050, 0xc0000ee370, 0xc000010050)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal-proto@v0.20.22/serviceerror/convert.go:94 +0x1d29
go.temporal.io/temporal/internal.errorInterceptor(0x19da6c0, 0xc000146ba0, 0x18f216f, 0x37, 0x18b8ec0, 0xc0001569a0, 0x188d840, 0xc0003cc100, 0xc0003be700, 0x1906e70, ...)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal@v0.21.1-0.20200414162012-9592ebc6a1f7/internal/grpc_dialer.go:72 +0xef
google.golang.org/grpc.getChainUnaryInvoker.func1(0x19da6c0, 0xc000146ba0, 0x18f216f, 0x37, 0x18b8ec0, 0xc0001569a0, 0x188d840, 0xc0003cc100, 0xc0003be700, 0x0, ...)
        /Users/maxim/go/pkg/mod/google.golang.org/grpc@v1.28.1/clientconn.go:359 +0x151
go.temporal.io/temporal/internal/common/metrics.NewScopeInterceptor.func1(0x19da6c0, 0xc000146ba0, 0x18f216f, 0x37, 0x18b8ec0, 0xc0001569a0, 0x188d840, 0xc0003cc100, 0xc0003be700, 0xc0003251a0, ...)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal@v0.21.1-0.20200414162012-9592ebc6a1f7/internal/common/metrics/interceptor.go:50 +0x108
google.golang.org/grpc.chainUnaryClientInterceptors.func1(0x19da6c0, 0xc000146ba0, 0x18f216f, 0x37, 0x18b8ec0, 0xc0001569a0, 0x188d840, 0xc0003cc100, 0xc0003be700, 0x1906e70, ...)
        /Users/maxim/go/pkg/mod/google.golang.org/grpc@v1.28.1/clientconn.go:347 +0x12f
google.golang.org/grpc.(*ClientConn).Invoke(0xc0003be700, 0x19da6c0, 0xc000146ba0, 0x18f216f, 0x37, 0x18b8ec0, 0xc0001569a0, 0x188d840, 0xc0003cc100, 0x0, ...)
        /Users/maxim/go/pkg/mod/google.golang.org/grpc@v1.28.1/call.go:35 +0x109
go.temporal.io/temporal-proto/workflowservice.(*workflowServiceClient).StartWorkflowExecution(0xc00014a390, 0x19da6c0, 0xc000146ba0, 0xc0001569a0, 0x0, 0x0, 0x0, 0xc0003cc0f0, 0x49d5e6031b5e0, 0x1f4c440)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal-proto@v0.20.22/workflowservice/service.pb.go:337 +0xcf
go.temporal.io/temporal/internal.(*WorkflowClient).StartWorkflow.func1(0x0, 0x0)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal@v0.21.1-0.20200414162012-9592ebc6a1f7/internal/internal_workflow_client.go:229 +0x112
go.temporal.io/temporal/internal/common/backoff.Retry(0x19da680, 0xc0000ce000, 0xc0002077d0, 0x19c4e80, 0xc00020a2a0, 0x1906be8, 0x1f4b6a0, 0xc000134ec0)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal@v0.21.1-0.20200414162012-9592ebc6a1f7/internal/common/backoff/retry.go:102 +0xfb
go.temporal.io/temporal/internal.(*WorkflowClient).StartWorkflow(0xc0001fe6c0, 0x19da680, 0xc0000ce000, 0x18daebc, 0x16, 0x18da54b, 0x15, 0xdf8475800, 0x0, 0x0, ...)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal@v0.21.1-0.20200414162012-9592ebc6a1f7/internal/internal_workflow_client.go:223 +0x727
go.temporal.io/temporal/internal.(*WorkflowClient).ExecuteWorkflow(0xc0001fe6c0, 0x19da680, 0xc0000ce000, 0x18daebc, 0x16, 0x18da54b, 0x15, 0xdf8475800, 0x0, 0x0, ...)
        /Users/maxim/go/pkg/mod/go.temporal.io/temporal@v0.21.1-0.20200414162012-9592ebc6a1f7/internal/internal_workflow_client.go:263 +0xc7
main.main()
        /Users/maxim/temporal/temporal-go-samples/helloworld/starter/main.go:32 +0x457

Process finished with exit code 2

```
I'm running service as of 729c8e458ac0fd3bf6d6f1ad509b2e20300e2bd9

#### Comments (2)

<details>
<summary><strong>alexshtin</strong> commented on 2020-04-20 05:03:31.000 UTC</summary>

You updated `go.temporal.io/temporal-proto` to 0.20.22 a little bit earlier. I made a change there which is intended to be used for latest merge from Cadence. Please roll back to 0.20.21 and it should work fine. I will update SDK later, when server is ready.

</details>

<details>
<summary><strong>alexshtin</strong> commented on 2020-04-24 17:57:24.000 UTC</summary>

Fixed by https://github.com/temporalio/temporal-proto-go/commit/fd32111876d6ed73c2771107460783b09fb36a6f.

</details>


---

<a id="101"></a>

### #101: Add ability to pass Channel as a parameter to Child workflow and activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/101 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-13 18:14:15.000 UTC (5y 9m ago) |
| **Updated** | 2020-04-13 18:14:15.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

This is an attempt from a user:
```
	resultChannel := workflow.NewChannel(ctx)
	if err := workflow.ExecuteActivity(ctx, enumerateDomainActivity, enumerateInput, resultChannel); 

	workflow.NewSelector(ctx).AddReceive(resultChannel, func(c workflow.Channel, more bool){
            ...
        }
	}).Select(ctx)
```
This code is currently not possible as Channel is not a value type. 

The proposal is to pass to the activity the information about the channelID and return to activity a native Go channel. And when an activity sends something to it make SignalWorkflow call to the service. 
Inside the workflow code this signal is pushed to the channel passed to the activity as a parameter.

The similar approach should work for child workflows as well.



---

<a id="97"></a>

### #97: Remove error from WorkflowClient.CloseConnection

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/97 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-10 03:52:09.000 UTC (5y 9m ago) |
| **Updated** | 2020-07-16 04:42:35.000 UTC |
| **Closed** | 2020-07-16 04:42:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

Rename WorkflowClient.CloseConnection to Close and remote error as it is not very useful anyway.

#### Comments (2)

<details>
<summary><strong>samarabbas</strong> commented on 2020-07-15 20:47:38.000 UTC</summary>

Looks like this is fixed.  @alexshtin please link and close.

</details>

<details>
<summary><strong>alexshtin</strong> commented on 2020-07-16 04:42:34.000 UTC</summary>

Closed by #131.

</details>


---

<a id="95"></a>

### #95: Go SDK meta tag resolution not working properly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/95 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-04-09 15:46:21.000 UTC (5y 9m ago) |
| **Updated** | 2020-08-19 20:18:27.000 UTC |
| **Closed** | 2020-08-19 20:18:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

Go Get on the following package does not work:
```
curl 'http://go.temporal.io/temporal/worker/?go-get=1'
```

This should return go meta tags as well
```
https://godoc.org/go.temporal.io/temporal/worker
```
godoc doesn't really work

This seems to be working:
```
curl 'http://go.temporal.io/temporal/?go-get=1'
```


#### Comments (2)

<details>
<summary><strong>alexshtin</strong> commented on 2020-04-09 16:55:40.000 UTC</summary>

From `go help packages`:
```
If the import path is not a known code hosting site and also lacks a
version control qualifier, the go tool attempts to fetch the import
over https/http and looks for a <meta> tag in the document's HTML
<head>.

The meta tag has the form:

        <meta name="go-import" content="import-prefix vcs repo-root">

The import-prefix is the import path corresponding to the repository
root. It must be a prefix or an exact match of the package being
fetched with "go get". If it's not an exact match, another http
request is made at the prefix to verify the <meta> tags match.
```
So, yes, it seems we need to return `<meta>` tag not only on go module level but also on every package level.

</details>

<details>
<summary><strong>alexshtin</strong> commented on 2020-04-09 17:07:14.000 UTC</summary>

It seems github pages supports custom 404 only on root level and we have 2 packages: `temporal` and `temporal-proto` listed there. I see no option besides creating directory for every package with `index.html` in it. 

</details>


---

<a id="59"></a>

### #59: Add workflow deadlock detector

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/59 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-03-13 16:19:53.000 UTC (5y 10m ago) |
| **Updated** | 2020-11-10 20:13:33.000 UTC |
| **Closed** | 2020-11-10 20:13:32.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

Similar Java SDK issue: https://github.com/temporalio/temporal-java-client/issues/28


---

<a id="51"></a>

### #51: sticky cache: fix resource leaks on worker.Stop()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/51 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-03-03 21:58:49.000 UTC (5y 10m ago) |
| **Updated** | 2021-03-01 19:02:08.000 UTC |
| **Closed** | 2021-03-01 19:02:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently, entire sticky cache is leaked when worker is stopped. This is because the stickyCache is a global singleton which makes it impossible to clear it on worker.Stop() (because there could be other workers using the cache and there is no way to tell which entries belong to which worker). Leaking sticky cache results in memory & go routine leaks.

The right fix here is to create stickyCache per worker and purge it completely on worker.Stop()

#### Comments (2)

<details>
<summary><strong>samarabbas</strong> commented on 2020-03-03 21:59:01.000 UTC</summary>

Ported from: Uber Cadence GO: Issue 739

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2021-03-01 19:02:06.000 UTC</summary>

Fixed this a while back https://github.com/temporalio/sdk-go/pull/310

</details>


---

<a id="35"></a>

### #35: Add ability to pass configuration to a workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/35 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-15 02:50:12.000 UTC (5y 11m ago) |
| **Updated** | 2020-11-23 23:39:13.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ðŸ‘ 1 |

#### Description

Currently there is no clean way to pass configuration information to a workflow. It shouldn't be passed as workflow argument as clients are not interested in implementation details. Passing it through a context propagator is not safe as it is not recorded and can break determinism.

The strawman proposal is to add `configuration` field to WorkerOptions and return them to the workflow through 
```
var config MyConfig
err := workflow.GetConfiguration(&config)
```
The GetConfiguration should either use `SideEffect`, `MutableSideEffect` or local activity to ensure that configuration changes never break determinism.



---

<a id="2141"></a>

### #2141: Activity Alias Collision in Test Environment When Using Anonymous Functions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2141 |
| **State** | OPEN |
| **Author** | autocracy (Jeff Ferland) |
| **Created** | 2026-01-08 02:07:59.000 UTC (1 days ago) |
| **Updated** | 2026-01-08 21:08:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Summary

The test environment's activity alias registry uses short function names (e.g., `func1`) as keys, which causes collisions when multiple packages register activities using anonymous functions. This results in local activities being incorrectly routed to unrelated registered activity mocks, causing panics due to signature mismatches.

## Affected Version

- `go.temporal.io/sdk` v1.38.0 (and likely earlier versions)

## Reproduction

### Minimal Test Case Demonstrating the Bug

```go
package alias_collision_test

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/activity"
	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/workflow"
)

type AliasCollisionSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
}

func TestAliasCollisionSuite(t *testing.T) {
	suite.Run(t, new(AliasCollisionSuite))
}

// SomeActivityRequest is a request type for a registered activity
type SomeActivityRequest struct {
	Value string
}

// SomeActivityResponse is a response type for a registered activity
type SomeActivityResponse struct {
	Result string
}

// TestAliasCollision_Fails demonstrates the bug where anonymous functions
// with the same short name collide in the activity alias registry.
func (s *AliasCollisionSuite) TestAliasCollision_Fails() {
	env := s.NewTestWorkflowEnvironment()

	// Register an activity using an anonymous function.
	// This anonymous function gets a short name like "func1" in the registry.
	env.RegisterActivityWithOptions(
		func(ctx context.Context, req *SomeActivityRequest) (*SomeActivityResponse, error) {
			return &SomeActivityResponse{Result: "from registered activity"}, nil
		},
		activity.RegisterOptions{Name: "SomeActivity"},
	)

	// This workflow executes a LOCAL activity using an INLINE anonymous function.
	// The inline function also gets a short name like "func1".
	// Due to the collision, the test environment incorrectly tries to call
	// the registered "SomeActivity" with the wrong arguments.
	testWorkflow := func(ctx workflow.Context) (string, error) {
		lao := workflow.LocalActivityOptions{
			ScheduleToCloseTimeout: 10 * time.Second,
		}
		ctx = workflow.WithLocalActivityOptions(ctx, lao)

		var result string
		// This inline anonymous function takes only context and returns (string, error)
		// but the registry thinks it should call SomeActivity which takes
		// (context.Context, *SomeActivityRequest) -> (*SomeActivityResponse, error)
		err := workflow.ExecuteLocalActivity(ctx, func(ctx context.Context) (string, error) {
			return "from inline local activity", nil
		}).Get(ctx, &result)

		return result, err
	}

	env.ExecuteWorkflow(testWorkflow)

	require.True(s.T(), env.IsWorkflowCompleted())
	require.NoError(s.T(), env.GetWorkflowError())

	var result string
	require.NoError(s.T(), env.GetWorkflowResult(&result))
	require.Equal(s.T(), "from inline local activity", result)
}

// TestAliasCollision_Workaround demonstrates the workaround: use named functions
// instead of anonymous functions when registering activities.
func (s *AliasCollisionSuite) TestAliasCollision_Workaround() {
	env := s.NewTestWorkflowEnvironment()

	// WORKAROUND: Use a named function instead of an anonymous function.
	// Named functions have unique full names that won't collide.
	env.RegisterActivityWithOptions(
		namedActivityMock, // This gets a unique name like "alias_collision_test.namedActivityMock"
		activity.RegisterOptions{Name: "SomeActivity"},
	)

	testWorkflow := func(ctx workflow.Context) (string, error) {
		lao := workflow.LocalActivityOptions{
			ScheduleToCloseTimeout: 10 * time.Second,
		}
		ctx = workflow.WithLocalActivityOptions(ctx, lao)

		var result string
		err := workflow.ExecuteLocalActivity(ctx, func(ctx context.Context) (string, error) {
			return "from inline local activity", nil
		}).Get(ctx, &result)

		return result, err
	}

	env.ExecuteWorkflow(testWorkflow)

	require.True(s.T(), env.IsWorkflowCompleted())
	require.NoError(s.T(), env.GetWorkflowError())

	var result string
	require.NoError(s.T(), env.GetWorkflowResult(&result))
	require.Equal(s.T(), "from inline local activity", result)
}

// namedActivityMock is a named function used as a workaround for the alias collision bug.
func namedActivityMock(ctx context.Context, req *SomeActivityRequest) (*SomeActivityResponse, error) {
	return &SomeActivityResponse{Result: "from registered activity"}, nil
}
```

### Expected Behavior

Both tests should pass. The inline local activity function should execute independently of the registered activity mock, as they are completely separate functions with different purposes.

### Actual Behavior

`TestAliasCollision_Fails` panics with:
```
reflect: Call with too few input arguments
```

The test environment incorrectly routes the inline local activity to the registered "SomeActivity" mock because both anonymous functions have the same short name (`func1`).

## Root Cause Analysis

### 1. Short function names used as alias keys

In `internal/internal_worker.go`, the `getFunctionName` function returns only the short name:

```go
func getFunctionName(i interface{}) (name string, isMethod bool) {
    fullName := runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
    elements := strings.Split(fullName, ".")
    shortName := elements[len(elements)-1]  // Returns "func1", "func2", etc.
    return strings.TrimSuffix(shortName, "-fm"), isMethod
}
```

### 2. Alias stored using short name

In `internal/internal_worker.go` line ~730:
```go
if len(alias) > 0 && r.activityAliasMap != nil {
    r.activityAliasMap[fnName] = alias  // fnName is "func1"
}
```

### 3. Test environment looks up alias for local activities

In `internal/internal_workflow_testsuite.go` line ~1559:
```go
func (env *testWorkflowEnvironmentImpl) ExecuteLocalActivity(...) {
    ae := &activityExecutor{name: getActivityFunctionName(env.registry, params.ActivityFn), fn: params.ActivityFn}
    if at, _ := getValidatedActivityFunction(params.ActivityFn, params.InputArgs, env.registry); at != nil {
        // This finds the wrong alias because both functions have short name "func1"
        ae.name = at.Name
    }
    // ...
}
```

### 4. Mock lookup uses the wrong name

In `internal/internal_workflow_testsuite.go` line ~1817:
```go
m := &mockWrapper{env: a.env, name: a.name, fn: a.fn, isWorkflow: false}
if mockRet := m.getActivityMockReturnWithActualArgs(ctx, inputArgs); mockRet != nil {
    // Finds the mock for "SomeActivity" when it shouldn't
}
```

## Proposed Fix

### Option 1: Use full function name as alias key (Recommended)

Change the alias map to use full function names instead of short names:

```go
func (r *registry) RegisterActivityWithOptions(a interface{}, options RegisterActivityOptions) {
    // ... existing code ...
    
    // Use full function name as alias key
    fullName := runtime.FuncForPC(reflect.ValueOf(af).Pointer()).Name()
    
    if len(alias) > 0 && r.activityAliasMap != nil {
        r.activityAliasMap[fullName] = alias
    }
}

func (r *registry) getActivityAlias(fnName string) (string, bool) {
    // fnName should also be the full function name
    alias, ok := r.activityAliasMap[fnName]
    return alias, ok
}
```

This requires updating all callers of `getActivityAlias` to pass the full function name.

### Option 2: Skip alias lookup for anonymous functions in test environment

In `ExecuteLocalActivity`, detect anonymous functions and skip the alias lookup:

```go
func (env *testWorkflowEnvironmentImpl) ExecuteLocalActivity(...) {
    ae := &activityExecutor{name: getActivityFunctionName(env.registry, params.ActivityFn), fn: params.ActivityFn}
    
    // Only look up alias if this is not an anonymous function
    fullName := runtime.FuncForPC(reflect.ValueOf(params.ActivityFn).Pointer()).Name()
    if !isAnonymousFunction(fullName) {
        if at, _ := getValidatedActivityFunction(params.ActivityFn, params.InputArgs, env.registry); at != nil {
            ae.name = at.Name
        }
    }
    // ...
}

func isAnonymousFunction(fullName string) bool {
    // Anonymous functions have names ending in ".funcN" where N is a number
    parts := strings.Split(fullName, ".")
    if len(parts) == 0 {
        return false
    }
    lastPart := parts[len(parts)-1]
    return strings.HasPrefix(lastPart, "func") && len(lastPart) > 4
}
```

## Real-World Impact

This bug affects users of [protoc-gen-go-temporal](https://github.com/cludden/protoc-gen-go-temporal), which generates code that uses anonymous functions for expression evaluation in workflow ID generation:

```go
// Generated code in lifecycle_temporal.pb.go
func (o *ServerDrainChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
    // ...
    if err := workflow.ExecuteLocalActivity(ctx, func(ctx context.Context) (string, error) {
        id, err := expression.EvalExpression(ServerDrainIdexpression, req)
        // ...
    }).Get(ctx, &opts.WorkflowID); err != nil {
        // ...
    }
    // ...
}
```

When users register activities with anonymous functions in their tests, these collide with the generated expression evaluation functions.

## Workaround

Until this is fixed, users should use **named functions** instead of anonymous functions when calling `RegisterActivityWithOptions` or generated `Register*Activity` functions:

```go
// Instead of this (FAILS):
env.RegisterActivityWithOptions(
    func(ctx context.Context, req *MyRequest) (*MyResponse, error) {
        return &MyResponse{}, nil
    },
    activity.RegisterOptions{Name: "MyActivity"},
)

// Do this (WORKS):
func myActivityMock(ctx context.Context, req *MyRequest) (*MyResponse, error) {
    return &MyResponse{}, nil
}

env.RegisterActivityWithOptions(myActivityMock, activity.RegisterOptions{Name: "MyActivity"})
```

## Environment

- Go version: 1.25.5
- OS: macOS (also affects Linux)
- Temporal SDK version: v1.38.0


#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2026-01-08 21:08:03.000 UTC</summary>

Thanks for the issue and thorough write-up!

We strongly discourage usage of anonymous functions for local activities, see the following line in the doc comment for [ExecuteLocalActivity](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteLocalActivity)

> WARNING: Technically, an anonymous function can be used as a local activity, but this is not recommended as their name is generated by the Go runtime and is not deterministic. This is only allowed for backward compatibility.

Changing alias lookup would be very difficult to do in a non-breaking way with old histories, so that is not something we want to do at the moment.

We hope to eventually flag this in the WorkflowCheck tool as non-deterministic, https://github.com/temporalio/sdk-go/issues/1341. 

</details>


---

<a id="2136"></a>

### #2136: Understanding the Worker Slots Gauge

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2136 |
| **State** | CLOSED |
| **Author** | davidlbudiman (David Latief Budiman) |
| **Created** | 2025-12-03 13:51:54.000 UTC (1 months ago) |
| **Updated** | 2025-12-12 02:36:15.000 UTC |
| **Closed** | 2025-12-12 02:33:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hi, there!

I want to understand further on how to understand the Worker slots gauge. I tried to search the documentation but I couldn't make sense of it. 

Here's more context:
* Metrics Dashboard: DataDog
* MaxConcurrentWorkflowTaskExecutionSize: 7500
* MaxConcurrentLocalActivityExecutionSize: 7500
* IsLocalActivityWorkerOnly: True
* MaxConcurrentWorkflowTaskPollers: 2
* Workflow avg latency: 50ms
* Workflow max latency: 5min.
* Expected incoming workflow per second: 1k and expected to increase on further development.
* Duration of incoming workflow per second: Possibly 6 hours, there might be need to make the duration goes faster, which means incoming workflow per second will be higher based on the business requirements.

I wanted to increase the # of Workflows that can be taken per second. But, I don't understand the gauge. Because it kept showing at max it takes 7 for the WorkflowTask Workers. What does this 7 mean? Is it that the worker takes 7 workflows at that second, or is it that it creates 700% concurrent workflow tasks? How do I know the number of running workflows per seconds? The reason I'm focusing on MaxConcurrent*ExecutionSize, I find that increasing them seems to increase the concurrency of the workflows. But, am I right? How do I make sure of this?

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-12 02:33:43.000 UTC</summary>

Worker slots is the number of concurrently running workflow tasks at that point in time. Increasing it would increase the number of concurrent workflow tasks. The max value it can be is `MaxConcurrentWorkflowTaskExecutionSize`. We have a whole docs page that cover Worker performance and improving a workers performance I would recommend reviewing at your connivence https://docs.temporal.io/develop/worker-performance.

Closing this issue since we do not use github for support.

In the future please use our slack for any support or questions https://t.mp/slack

</details>


---

<a id="2130"></a>

### #2130: `TEMPORAL_LOG_LEVEL` variable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2130 |
| **State** | CLOSED |
| **Author** | jpds (Jonathan Davies) |
| **Created** | 2025-12-05 18:16:55.000 UTC (1 months ago) |
| **Updated** | 2025-12-07 05:53:31.000 UTC |
| **Closed** | 2025-12-07 05:53:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Rather than coding [this](https://github.com/temporalio/sdk-go?tab=readme-ov-file#using-slog) into a problematic worker, I'd like to just set `TEMPORAL_LOG_LEVEL=debug`.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-07 05:53:31.000 UTC</summary>

The SDK is not able to set the log level of the [logger](https://pkg.go.dev/go.temporal.io/sdk/log#Logger) that users provide. If you want to control the log level through an environment variable you are free to set the log level through your own environment variable. 

</details>


---

<a id="2101"></a>

### #2101: Feature Request: WorkflowRun GetWithOptions() option to populate valuePtr for failed run

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2101 |
| **State** | CLOSED |
| **Author** | erik-ringsmuth (Erik Ringsmuth) |
| **Created** | 2025-11-07 19:35:55.000 UTC (2 months ago) |
| **Updated** | 2025-11-10 17:01:09.000 UTC |
| **Closed** | 2025-11-10 17:01:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'm looking for a way to load a workflow run's result in the case where the run failed with an error.

The current `WorkflowRun` APIs [Get() and GetWithOptions()](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_client.go#L104-L132) either populate `valuePtr` or return an error, but not both.

I'm looking for a way to load the result into the `valuePtr` even if the workflow failed.

#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-11-07 21:35:38.000 UTC</summary>

You can add details to an Application failure, https://github.com/temporalio/sdk-go/blob/a451bef0b7c99092974ac3d58311532d4c244896/temporal/error.go#L169, if you're looking to add data to your errors. Or you could create your own custom Result type that encapsulates all the info you need, and return that.

Even though you're technically able to return both from your Go Workflow function, we don't record both, Error always wins.

</details>


---

<a id="2098"></a>

### #2098: Update ChildWorkflowOptions comment to indicate the default WorkflowIDReusePolicy and WorkflowIdConflictPolicy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2098 |
| **State** | OPEN |
| **Author** | codemonkeycxy (Xinyi Chen) |
| **Created** | 2025-11-05 19:33:19.000 UTC (2 months ago) |
| **Updated** | 2025-11-07 18:08:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, it's not clear what the default WorkflowIDReusePolicy and WorkflowIdConflictPolicy are by reading the SDK code https://github.com/temporalio/sdk-go/blob/master/internal/workflow.go#L390-L392

**Describe the solution you'd like**
Add inline comments to make the default behavior clear

**Describe alternatives you've considered**
Document it in the Temporal developer guide https://docs.temporal.io/develop/go

**Additional context**
N/A

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2025-11-07 18:08:12.000 UTC</summary>

@codemonkeycxy Would you be willing to just make a PR for this?

</details>


---

<a id="2084"></a>

### #2084: Add support for static summary for side effects and mutable side effects

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2084 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-10-20 16:35:52.000 UTC (2 months ago) |
| **Updated** | 2025-12-17 03:17:06.000 UTC |
| **Closed** | 2025-12-17 03:17:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | â¤ï¸ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

Side Effect markers in the UI don't have any identifiable information, when there's multiple in quick succession in the UI, we're not able to identify them apart unless we click into the specific item.

**Describe the solution you'd like**

Support static summary for these items, then UI can be changed to display their summaries, similar to activities and local activities.

**Additional context**
Add any other context or screenshots about the feature request here.
https://github.com/temporalio/sdk-go/issues/2076


#### Comments (1)

<details>
<summary><strong>djeer</strong> commented on 2025-12-05 16:14:16.000 UTC</summary>

Added PR to implement it here https://github.com/temporalio/sdk-go/pull/2129

</details>


---

<a id="2064"></a>

### #2064: Allow heartbeats after Activity cancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2064 |
| **State** | CLOSED |
| **Author** | ntaylorkhan |
| **Created** | 2025-10-02 19:56:50.000 UTC (3 months ago) |
| **Updated** | 2025-11-13 17:33:10.000 UTC |
| **Closed** | 2025-11-13 17:33:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
You cannot ignore cancellation on Activities in the Go SDK. Other SDK's do not have this issue and you can already do this in Workflow via `worklow.GetDisconnectedContext`

**Describe the solution you'd like**
Allow heartbeats after cancellation.

**Describe alternatives you've considered**
None.

**Additional context**
n/a

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-10-02 19:58:10.000 UTC</summary>

Note, this is similar to #1574 but this isn't even a new context, this is a desire to be able to heartbeat even if server has requested cancellation, which we should support. (cancellation is a request, it does not have to be honored)

</details>


---

<a id="2058"></a>

### #2058: ResetWorkflow panic policy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2058 |
| **State** | CLOSED |
| **Author** | elb3k (Elbek Khoshimjonov) |
| **Created** | 2025-09-26 19:34:38.000 UTC (3 months ago) |
| **Updated** | 2025-09-26 19:39:48.000 UTC |
| **Closed** | 2025-09-26 19:39:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
New panic policy to reset the workflow from the start in case of panic/non-determinism. Full discussion [here](https://community.temporal.io/t/catching-nondeterministicexception/5020/10?u=_elbek_khoshimjonov).

**Describe the solution you'd like**
New option called `ResetWorkflow` [here](https://github.com/temporalio/sdk-go/blob/aecdca8be43def99f6237a07385f58612869cd65/worker/worker.go#L249-L259)

**Describe alternatives you've considered**
With `WorkflowPanicPolicy` set to `worker.FailWorkflow`
And `RetryPolicy` set to some value when starting a workflow allows us to restart the workflow when the workflow encounters non-deterministic panics.

**Additional context**
The solution I had in mind has some caveats:
- Any panic in the workflow will result in a restart, and if the workflow code does not handle the issue, there might be an infinite loop. (Some kind of maximum limit should be set.)

The alternative solution I have described has a few caveats:
- Any real errors returning from the workflow to terminate the workflow must be wrapped with `temporal.NewNonRetryableError`
- Workflow retry does not seem to replay the signals (which we want for our use case)


#### Comments (1)

<details>
<summary><strong>elb3k</strong> commented on 2025-09-26 19:39:48.000 UTC</summary>

Duplicate of https://github.com/temporalio/features/issues/417

</details>


---

<a id="2040"></a>

### #2040: Test environment does not deliver signals to mocked child workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2040 |
| **State** | CLOSED |
| **Author** | Patrick-McKeever (Patrick McKeever) |
| **Created** | 2025-08-28 18:14:17.000 UTC (4 months ago) |
| **Updated** | 2025-09-02 14:32:25.000 UTC |
| **Closed** | 2025-09-02 14:32:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When mocking a parent and child workflow, signal handlers registered with `selector.AddReceive` inside the mocked child workflow should be triggered when the corresponding signal is sent by the parent workflow.

## Actual Behavior
Only the first signal is delivered to the child workflow, and subsequent calls to `selector.Select()` simply block without invoking the callback for the sent signal.


## Steps to Reproduce the Problem

A minimal example is shown below. (As far as I know, itâ€™s not possible to use env.OnSignalExternalWorkflow here, because â€œTestWorkflowEnvironment handles sending signals between the workflows that are started from the root workflow. For example, sending signals between parent and child workflows. Or sending signals between 2 child workflowsâ€, [per the docs](https://pkg.go.dev/go.temporal.io/sdk/internal#TestWorkflowEnvironment.OnSignalExternalWorkflow).)

```golang
func TestParentChildSignalExchange(t *testing.T) {
    var ts testsuite.WorkflowTestSuite
    env := ts.NewTestWorkflowEnvironment()
    var childReceivedC bool

    mockChildWorkflow := func(ctx workflow.Context, parentWfId string) error {
        s := workflow.NewSelector(ctx)
        s.AddReceive(workflow.GetSignalChannel(ctx, SignalA), func(c workflow.ReceiveChannel, _ bool) {
            var val string
            c.Receive(ctx, &val)
            fmt.Println("Child received signal A")
            _ = workflow.SignalExternalWorkflow(ctx, parentWfId, "", SignalB, "payload-B").Get(ctx, nil)
            fmt.Println("Child sent signal B")
        })

        s.AddReceive(workflow.GetSignalChannel(ctx, SignalC), func(c workflow.ReceiveChannel, _ bool) {
            var val string
            c.Receive(ctx, &val)
            fmt.Println("Child received signal C")
            childReceivedC = true
        })

        // Selects for signal A and signal C
        s.Select(ctx)
        s.Select(ctx)
        return nil
    }
    parentWorkflow := func(ctx workflow.Context) error {
        cwo := workflow.ChildWorkflowOptions{
            WorkflowID: "child-workflow-id",
        }
        var childWE workflow.Execution
        workflowId := workflow.GetInfo(ctx).WorkflowExecution.ID
        ctx = workflow.WithChildOptions(ctx, cwo)
        err := workflow.ExecuteChildWorkflow(ctx, "MockChildWorkflow", workflowId).GetChildWorkflowExecution().Get(ctx, &childWE)
        if err != nil {
            return err
        }

        workflow.SignalExternalWorkflow(ctx, childWE.ID, childWE.RunID, SignalA, "payload-A")
        fmt.Println("Parent sent signal A")
        var bVal string
        s := workflow.NewSelector(ctx)
        s.AddReceive(workflow.GetSignalChannel(ctx, SignalB), func(c workflow.ReceiveChannel, _ bool) {
            c.Receive(ctx, &bVal)
            fmt.Println("Parent received signal B")
            _ = workflow.SignalExternalWorkflow(ctx, childWE.ID, childWE.RunID, SignalC, "payload-C").Get(ctx, nil)
            fmt.Println("Parent sent signal C")
        })
        s.Select(ctx)
        return nil
    }
    env.RegisterWorkflow(parentWorkflow)
    env.RegisterWorkflowWithOptions(mockChildWorkflow, workflow.RegisterOptions{Name: "MockChildWorkflow"})

    env.ExecuteWorkflow(parentWorkflow)
    require.True(t, env.IsWorkflowCompleted())
    require.True(t, childReceivedC, "child workflow should have received signal C")
}
```

This gives the following output, showing that the child workflow successfully receives the first signal but not the second.

```
=== RUN   TestParentChildSignalExchange
2025/08/27 17:34:10 INFO  ExecuteChildWorkflow WorkflowType MockChildWorkflow
Parent sent signal A
Child received signal A
Child sent signal B
Parent received signal B
Parent sent signal C
    /home/patrick/go-scheduler/workflow/temporal_executor_test.go:158:
                Error Trace:    /home/patrick/go-scheduler/workflow/temporal_executor_test.go:158
                Error:          Should be true
                Test:           TestParentChildSignalExchange
                Messages:       child workflow should have received signal C
--- FAIL: TestParentChildSignalExchange (0.00s)
FAIL
```

## Specifications

  - Version: 1.35.0
  - Platform: Debian GNU/Linux 11 (bullseye), go 1.24.4

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-02 14:32:25.000 UTC</summary>

This is expected behaviour, if you parent workflow finished by default your child workflow is terminated and will no longer receive signals. See `ChildWorkflowOptions.ParentClosePolicy` for more details. If you want your child workflow to live after you parent workflow finishes,  use `PARENT_CLOSE_POLICY_ABANDON`

</details>


---

<a id="2039"></a>

### #2039: Joining errors causes TestWorkflowEnvironment to hide panics and pass test

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2039 |
| **State** | OPEN |
| **Author** | ioudas |
| **Created** | 2025-08-28 12:50:10.000 UTC (4 months ago) |
| **Updated** | 2025-08-28 14:19:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When workflow is executed in `TestWorkflowEnvironment ` and :
- tries to execute an activity that wasn't registered
- returns the resulting error wrapped inside either `joinError` or `wrapError`
- the test fails with `unable to find activityType=...`

## Actual Behavior
Test prints the expected error, but passes.

## Steps to Reproduce the Problem
1. A workflow that executes an activity that is not registered at all and returns the resulting error using either `errors.Join` or `fmt.Errorf("%w: %w", err1, err2)`
```
errExecute := workflow.ExecuteActivity(ctx, ThisActivityIsNotRegistered)).Get(ctx, nil)
if errExecute != nil {
  return errors.Join(errExecute , doSomethingWithErr(errExecute))
}
```
2. Execute the above workflow in a unit test, using `TestWorkflowEnvironment`

## Specifications

  - Version: 
  ```
go.temporal.io/api v1.52.0
go.temporal.io/sdk v1.35.0
```
  - Platform: Ubuntu 20.04


#### Comments (1)

<details>
<summary><strong>ioudas</strong> commented on 2025-08-28 14:19:50.000 UTC</summary>

Looks like this was user error. The correct way to return a joined error is `temporal.NewApplicationErrorWithCause`. Otherwise it breaks `errors.As` / `errors.Is` matching.

</details>


---

<a id="2021"></a>

### #2021: Graceful worker shutdown of sessions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2021 |
| **State** | CLOSED |
| **Author** | renescheepers (Rene Scheepers) |
| **Created** | 2025-08-13 18:04:02.000 UTC (4 months ago) |
| **Updated** | 2025-08-26 16:33:01.000 UTC |
| **Closed** | 2025-08-26 16:33:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We're having some issues in our application when deploying a new version where the worker will wait for the activity to finish but in a session it won't wait until the session is manually closed. We will get a heartbeat timeout and then the workflow fails.

**Describe the solution you'd like**
The option to configure for a worker to wait until all open sessions are closed before shutting down.

**Describe alternatives you've considered**
Manually keeping a count of the open sessions and wait until there are 0 open before invoking the shut down. However there doesn't seem to be a way to stop scheduling new sessions on a given worker.



#### Comments (1)

<details>
<summary><strong>bergundy</strong> commented on 2025-08-18 17:27:58.000 UTC</summary>

@renescheepers I transferred the issue to sdk-go since this is an SDK side feature.

Reactions: ðŸ‘ 1

</details>


---

<a id="2017"></a>

### #2017: Add first execution run ID to workflow info

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2017 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-08-11 14:26:47.000 UTC (5 months ago) |
| **Updated** | 2025-08-11 15:54:28.000 UTC |
| **Closed** | 2025-08-11 15:54:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/29

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-11 15:54:28.000 UTC</summary>

This is already exposed https://github.com/temporalio/sdk-go/blame/573d6de997240ce75c8fc9795c4b161d6e836005/internal/workflow.go#L1301

</details>


---

<a id="2011"></a>

### #2011: `WorkerDeploymentVersion.BuildId` should be `...BuildID` (as everywhere else)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2011 |
| **State** | CLOSED |
| **Author** | Drahflow (Jens-Wolfhard Schicke-Uffmann) |
| **Created** | 2025-08-04 16:03:37.000 UTC (5 months ago) |
| **Updated** | 2025-09-12 18:19:55.000 UTC |
| **Closed** | 2025-09-12 18:19:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

The SDK has consistent field names.

## Actual Behavior

Most (re-exported) structs have `BuildID`, but `WorkerDeploymentVersion` has `BuildId` (which also violates golang conventions https://google.github.io/styleguide/go/decisions.html#initialisms ).

## Steps to Reproduce the Problem

Search https://pkg.go.dev/go.temporal.io/sdk@v1.35.0/internal#WorkerDeploymentVersion for `BuildID` and `BuildId` (with case-matching enabled).

## Specifications

  - Version: 1.35.0
  - Platform: irrelevant


#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2025-08-18 20:25:21.000 UTC</summary>

Thanks for the info, definitely an oversight on my part. I'm a bit conflicted about whether we want to accept the breaking change just to fix this, though. Will discuss w/ the team.

</details>


---

<a id="2010"></a>

### #2010: Setting a mock activity to Never isn't always enforced

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2010 |
| **State** | CLOSED |
| **Author** | OfirEnglard |
| **Created** | 2025-08-03 16:26:11.000 UTC (5 months ago) |
| **Updated** | 2025-08-03 18:01:07.000 UTC |
| **Closed** | 2025-08-03 17:40:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

env.OnActivity(MyActivity,...).Never() should panic when MyActivity is called, and fail our test.
It should panic and fail even if we're not checking or using the returned err from workflow.ExecuteActivity.


## Actual Behavior
Tests that call activities that were set to never() are passing.

## Steps to Reproduce the Problem

  1. Create a workflow that executes an activity and doesn't fail the workflow when the activity fails
  2. Create a test which sets the activity to never be run 
  3. env.ExecuteWorkflow(my_workflow)
  4. require.NoError(t, env.GetWorkflowError())

```code
func TestMyWorkflow(t *testing.T) {
	t.Parallel()
	s := &testsuite.WorkflowTestSuite{}
	env := s.NewTestWorkflowEnvironment()

	env.OnActivity(MyActivity, mock.Anything, mock.Anything).Return("output", nil).Never()

	env.ExecuteWorkflow(MyWorkflow, "input")
	require.True(t, env.IsWorkflowCompleted())
	require.NoError(t, env.GetWorkflowError())

	env.AssertExpectations(t)

}

func MyWorkflow(ctx workflow.Context, input string) (string, error) {
	var result string
	activityOptions := workflow.ActivityOptions{
		StartToCloseTimeout: common.ActivityStartToCloseTimeout,
	}
	ctx = workflow.WithActivityOptions(ctx, activityOptions)
	err := workflow.ExecuteActivity(ctx, MyActivity, input).Get(ctx, &result)
	if err != nil {
		slog.Error("Failed to execute activity", slog.String("input", input), slog.Any("error", err))
	}
	return result, nil
}

func MyActivity(ctx context.Context, input string) (string, error) {
	return "output", nil
}
 ```

We believe it's happening due to the recover in internal/internal_task_handlers which handles the execution of both regular and mock activities
## Specifications

  - Version: 1.35.0
  - Platform:


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-03 17:43:11.000 UTC</summary>

Yes you should be checking test result of your activity, it is not recommend to ignore the result of an activity. A workaround would be to fail the test if the activity is called since testify[ does not consider these mock failures as failing the test](https://github.com/stretchr/testify/issues/608), but the recommend approach is to always check activity results in workflows.

Reactions: ðŸ‘Ž 1

</details>


---

<a id="2001"></a>

### #2001: Try synctest for time control

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2001 |
| **State** | CLOSED |
| **Author** | vikstrous2 (Viktor Stanchev) |
| **Created** | 2025-07-14 15:15:31.000 UTC (5 months ago) |
| **Updated** | 2025-07-14 15:27:47.000 UTC |
| **Closed** | 2025-07-14 15:27:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I know that the temporal SDK uses careful control of a fake clock to execute tests correctly. I've tried synctest in go 1.24 and it seems to work for simple tests. I wonder if it would work for a full temporal workflow test. In go 1.25, this feature is becoming enabled by default. I think it's worth a try. Maybe it would simplify the implementation of the temporal go sdk? Would it change the testing API?

The documentation is at https://pkg.go.dev/testing/synctest@go1.25rc2

I'm just curious how this would work and if it's really possible.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-07-14 15:27:47.000 UTC</summary>

Sync test is definitely a cool feature I am personally excited for, but it is not really useful for the Temporal Go SDK, at least with its current features

> I wonder if it would work for a full temporal workflow test.

A workflow environment is a lot more then just skipping time, it also requires control of other things like random, task scheduling activities, child workflows etc. Actually the Temporal Go SDK doesn't even use Go's normal timers in workflow code at all so it is not relevant for a workflow. For an integrated test with workflows and activities, there is no way to have the time skipping for the `synctest` interact with time skipping in the workflow and vice versa which would be a crucial feature for the SDK use case. 

So at this time `synctest ` isn't worth integrating into the SDK, though we may use it internally for some of our own tests. Depending on how the feature evolves we may certainly resist this in the future. 

Reactions: ðŸ‘ 1

</details>


---

<a id="1993"></a>

### #1993: Do we have any temporal service health status metrics -This is just for information

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1993 |
| **State** | CLOSED |
| **Author** | amithmanden (M, Amith) |
| **Created** | 2025-07-08 13:44:24.000 UTC (6 months ago) |
| **Updated** | 2025-07-08 14:02:56.000 UTC |
| **Closed** | 2025-07-08 14:02:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Do we have any  metrics available for service health.?  Are we checking  the service health  internally.  

#### Comments (1)

<details>
<summary><strong>amithmanden</strong> commented on 2025-07-08 14:02:56.000 UTC</summary>

igonore this

</details>


---

<a id="1966"></a>

### #1966: better error messages when Error context deadline exceeded

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1966 |
| **State** | CLOSED |
| **Author** | spa5k (Kamran) |
| **Created** | 2025-06-09 12:02:36.000 UTC (7 months ago) |
| **Updated** | 2025-06-09 14:30:37.000 UTC |
| **Closed** | 2025-06-09 14:30:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
It's insanely frustrating when it gives generic error like "context deadline exceeded" in case the data we are returning back is more than 2MB, with pretty much no info, one can keep guessing for days unless they read docs line by line, find this limit and somehow connect it to their error, neither LLMs can guess it, all they do is to keep increasing context timeout (which is useless)

**Describe the solution you'd like**
Better errors for such cases like "context size limit exceeded", and other similar errors there are, I even saw connection issues in other issues in web giving same error

**Describe alternatives you've considered**
Nope

**Additional context**


```shell
2025/06/09 16:58:50 INFO  Page images converted Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 ActivityID 11 ActivityType ProcessPDFComprehensive Attempt 1 WorkflowType OCRJobWorkflow WorkflowID ocr-job-e4727a7c-c885-4568-9677-30b52e315646 RunID 01975473-2c38-71ac-af4f-cfe51b5b295e images_count 3
2025/06/09 16:58:50 INFO  Embedded images extracted Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 ActivityID 11 ActivityType ProcessPDFComprehensive Attempt 1 WorkflowType OCRJobWorkflow WorkflowID ocr-job-e4727a7c-c885-4568-9677-30b52e315646 RunID 01975473-2c38-71ac-af4f-cfe51b5b295e total_images 4 pages_with_images 3
2025/06/09 16:58:50 INFO  Comprehensive PDF processing completed Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 ActivityID 11 ActivityType ProcessPDFComprehensive Attempt 1 WorkflowType OCRJobWorkflow WorkflowID ocr-job-e4727a7c-c885-4568-9677-30b52e315646 RunID 01975473-2c38-71ac-af4f-cfe51b5b295e file_name drylab.pdf total_pages 3 optimized_size 1366849 page_images 3 embedded_images 3
2025/06/09 16:58:51 INFO  Page images converted Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 ActivityID 11 ActivityType ProcessPDFComprehensive Attempt 3 WorkflowType OCRJobWorkflow WorkflowID ocr-job-9d497972-7b3b-456f-adcb-66da0a9ecfdb RunID 01975469-8f0e-7bc3-a7c0-272a8a78613b images_count 3
2025/06/09 16:58:51 INFO  Embedded images extracted Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 ActivityID 11 ActivityType ProcessPDFComprehensive Attempt 3 WorkflowType OCRJobWorkflow WorkflowID ocr-job-9d497972-7b3b-456f-adcb-66da0a9ecfdb RunID 01975469-8f0e-7bc3-a7c0-272a8a78613b total_images 4 pages_with_images 3
2025/06/09 16:58:51 INFO  Comprehensive PDF processing completed Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 ActivityID 11 ActivityType ProcessPDFComprehensive Attempt 3 WorkflowType OCRJobWorkflow WorkflowID ocr-job-9d497972-7b3b-456f-adcb-66da0a9ecfdb RunID 01975469-8f0e-7bc3-a7c0-272a8a78613b file_name drylab.pdf total_pages 3 optimized_size 1366848 page_images 3 embedded_images 3
2025/06/09 16:59:00 INFO  Task processing failed with error Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 WorkerType ActivityWorker Error context deadline exceeded
2025/06/09 16:59:01 INFO  Task processing failed with error Namespace default TaskQueue ocr-task-queue WorkerID ocr-worker-1749468519 WorkerType ActivityWorker Error context deadline exceeded
```

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-09 14:30:35.000 UTC</summary>

Hey, we agree this error message is not obvious or helpful in this case. We already have an [issue](https://github.com/temporalio/sdk-go/issues/995) to solve this across our SDKs and are actively working on implementing a solution. Hopefully Go SDK will be soon.

please follow [this](https://github.com/temporalio/sdk-go/issues/995) issue for updates

Reactions: ðŸ‘ 1

</details>


---

<a id="1940"></a>

### #1940: Bug: remote dataconverter schedule decsribe

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1940 |
| **State** | CLOSED |
| **Author** | ron20hg |
| **Created** | 2025-04-29 11:12:27.000 UTC (8 months ago) |
| **Updated** | 2025-04-30 00:04:16.000 UTC |
| **Closed** | 2025-04-30 00:04:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Background
We have a custom dataconverter used for encryption for our sdk clients and we are doing automation for creating schedules

## Expected Behavior
`scheduleHandle.Describe()` returns the description of the schedule

## Actual Behavior
`scheduleHandle.Describe()` returns error: `could not decode user metadata summary: Bad Request: proto: syntax error (line 1:14): unexpected token null`


## Steps to Reproduce the Problem

  1. Create client with remote dataconverter
  2. Create schedule on the temporal server
  3. Create handle to the schedule and call Describe on it

## Specifications

  - Version: 1.33.1
  - Platform: go-sdk

## The error

The error comes from:
https://github.com/temporalio/sdk-go/blob/master/converter/codec.go#L361
```
if err = protojson.Unmarshal(bs, &payloadspb); err != nil {
	http.Error(w, err.Error(), http.StatusBadRequest)
	return
}
```
The `bs` variable which is the body of the request is: `{"payloads":[null]}`

Our solution for now is downgrade the client to 1.30.0 before adding the user metadata summary feature.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-04-29 14:02:10.000 UTC</summary>

Thanks! Yes, we should not be calling the data converter with a null payload. We will fix. Arguably, we should also gracefully use zero value when deserializing from a null payload, but that is a separate concern.

</details>


---

<a id="1928"></a>

### #1928: Race condition with Local Activities and worker shutdown

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1928 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-04-22 17:38:48.000 UTC (8 months ago) |
| **Updated** | 2025-07-15 14:41:20.000 UTC |
| **Closed** | 2025-07-15 14:41:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Worker shutdown should be consistently handled with local activities.


## Actual Behavior
If a local activity has logic to complete on `ctx.Done()`, sometimes the local activity completes first, other times the worker shuts down first. The former will cancel the context for the worker, causing a different error message to be bubbled up (`context canceled`) instead of `ErrWorkerShutdown`.

This is the goroutine that handles the local activity execution: [link](https://github.com/temporalio/sdk-go/blob/a92189071ec5931c88a97284d60b8b06f1024fc3/internal/internal_task_pollers.go#L689)

which causes us to [skip inspecting context ](https://github.com/temporalio/sdk-go/blob/a92189071ec5931c88a97284d60b8b06f1024fc3/internal/internal_task_pollers.go#L734)for the cause. 

## Steps to Reproduce the Problem

  1. Execute this workflow and activity, stop a worker, then create a new worker on the same task queue.
```
func (a *Activities) ReactToCancel(ctx context.Context) error {
	fmt.Println("[ReactToCancel]")
	select {
	case <-time.After(1 * time.Second):
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}
func (w *Workflows) WorkflowReactToCancel(ctx workflow.Context, localActivity bool) error {
	var activities *Activities

	ctx = workflow.WithLocalActivityOptions(ctx, workflow.LocalActivityOptions{
		StartToCloseTimeout:    5 * time.Second,
		ScheduleToCloseTimeout: 5 * time.Second,
		RetryPolicy: &temporal.RetryPolicy{
			MaximumAttempts: 10,
		},
	})
	err := workflow.ExecuteLocalActivity(ctx, activities.ReactToCancel).Get(ctx, nil)
	if err != nil {
		return err
	}
	return nil
}
```
  1.An easy way to hit this bug is to change `ReactToCancel` to the code above, then run `TestLocalActivityCancelFromWorkerShutdown`. Sometimes the test should pass, and other runs the test should fail.
  1.

## Specifications

  - Version:1.34.0
  - Platform:


#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-07-15 14:41:20.000 UTC</summary>

No longer able to repro the issue, I believe #1910 has fixed this race

</details>


---

<a id="1926"></a>

### #1926: Warn when the server-provided task start time is fairly different than time SDK begins processing the task

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1926 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-22 12:19:38.000 UTC (8 months ago) |
| **Updated** | 2025-09-23 20:07:50.000 UTC |
| **Closed** | 2025-09-23 20:07:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/616

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2025-09-23 20:07:49.000 UTC</summary>

We're not gonna do this. Too niche.

</details>


---

<a id="1880"></a>

### #1880: Many internal `GetSystemInfo` requests use `defaultGetSystemInfoTimeout` even if `ConnectionOptions.GetSystemInfoTimeout` was passed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1880 |
| **State** | CLOSED |
| **Author** | stan-stately |
| **Created** | 2025-03-24 21:47:16.000 UTC (9 months ago) |
| **Updated** | 2025-04-02 21:06:43.000 UTC |
| **Closed** | 2025-04-02 21:06:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
- Internal APIs would use provided value from `ConnectionOptions`


## Actual Behavior
- Many callsites do not use the value from the provided options. At least [here](https://github.com/temporalio/sdk-go/blob/07a817f18109e8022540978945f94731209bab4b/internal/internal_workflow_client.go#L1319) and [here](https://github.com/temporalio/sdk-go/blob/07a817f18109e8022540978945f94731209bab4b/internal/internal_worker.go#L1095). There may be more spots
- The reason i was poking out here is because i get timeouts a lot when talking to local temporal dev server when the dev server is definitely up. If anyone knows what causes that some advice would be appreciated


## Steps to Reproduce the Problem
- N/A

## Specifications

  - Version: 1.33.0
  - Platform: Go


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-03-25 13:50:38.000 UTC</summary>

> Many callsites do not use the value from the provided options. At least [here](https://github.com/temporalio/sdk-go/blob/07a817f18109e8022540978945f94731209bab4b/internal/internal_workflow_client.go#L1319) and [here](https://github.com/temporalio/sdk-go/blob/07a817f18109e8022540978945f94731209bab4b/internal/internal_worker.go#L1095). There may be more spots

Yes, it appears #1416 didn't apply the timeout to all places get system info is called. We do need to fix this, thanks!

> The reason i was poking out here is because i get timeouts a lot when talking to local temporal dev server when the dev server is definitely up. If anyone knows what causes that some advice would be appreciated

This could be for any number of reasons. Many use the dev server a lot and it should always connect basically immediately and definitely not hit any timeouts (default or manually set). There may be something unique to your setup. For support on this separate from this GitHub issue about using user-set timeout, you can contact us on [Slack](https://t.mp/slack) in the `#go-sdk` channel, or on the forums, or if you are a cloud user you can open a ticket.

Reactions: â¤ï¸ 1

</details>


---

<a id="1865"></a>

### #1865: [api-go] Repeated Payload not being visited

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1865 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-03-12 21:00:19.000 UTC (10 months ago) |
| **Updated** | 2025-04-09 16:26:48.000 UTC |
| **Closed** | 2025-04-09 16:26:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Visitor should visit this `repeated temporal.api.common.v1.Payload` https://github.com/temporalio/api/blob/9156239c8272003b6f228951602ca2b130a55876/temporal/api/workflowservice/v1/request_response.proto#L938

This test should pass
```
func TestVisitPayloads_AggregationGroup(t *testing.T) {
	// Due to us not visiting protos inside Any, this test used to fail
	root := &workflowservice.CountWorkflowExecutionsResponse_AggregationGroup{GroupValues: []*common.Payload{{Data: []byte("orig-val")}}}

	var count int
	// Visit with any recursion enabled and only change orig-val
	err := VisitPayloads(context.Background(), root, VisitPayloadsOptions{
		Visitor: func(ctx *VisitPayloadsContext, p []*common.Payload) ([]*common.Payload, error) {
			count += 1
			// Only mutate if the payloads has orig-val
			if len(p) == 1 && string(p[0].Data) == "orig-val" {
				return []*common.Payload{{Data: []byte("new-val")}}, nil
			}
			return p, nil
		},
	})
	require.NoError(t, err)
	require.Equal(t, 1, count)
}
```


## Actual Behavior
Test is failing due to Payload not being visited.


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-04-09 16:26:47.000 UTC</summary>

closed by https://github.com/temporalio/api-go/pull/216

</details>


---

<a id="1864"></a>

### #1864: [api-go] Support repeated Any fields

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1864 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-03-12 16:20:29.000 UTC (10 months ago) |
| **Updated** | 2025-04-09 16:22:18.000 UTC |
| **Closed** | 2025-04-09 16:22:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Today our Payload visitor will visit Any fields, but we don't properly visit and parse through a map of Any's, i.e. [this repeated Any field](https://github.com/temporalio/api/blob/9156239c8272003b6f228951602ca2b130a55876/temporal/api/errordetails/v1/message.proto#L143) in our API.

**Describe the solution you'd like**
This test should pass.
```
func TestVisitPayloads_ArrayAny(t *testing.T) {
	msg, err := anypb.New(&update.Request{Input: &update.Input{Args: &common.Payloads{
		Payloads: []*common.Payload{{Data: []byte("orig-val")}},
	}}})
	require.NoError(t, err)
	root := &errordetails.MultiOperationExecutionFailure_OperationStatus{Details: []*anypb.Any{msg}}
	var anyCount int
	err = VisitPayloads(context.Background(), root, VisitPayloadsOptions{
		Visitor: func(ctx *VisitPayloadsContext, p []*common.Payload) ([]*common.Payload, error) {
			anyCount++
			// Only mutate if the payloads has "test"
			if len(p) == 1 && string(p[0].Data) == "orig-val" {
				return []*common.Payload{{Data: []byte("new-val")}}, nil
			}
			return p, nil
		},
	})
	require.NoError(t, err)
	require.Equal(t, 1, anyCount)
	update1, err := root.Details[0].UnmarshalNew()

	require.NoError(t, err)
	require.Equal(t, "new-val", string(update1.(*update.Request).Input.Args.Payloads[0].Data))
}
```

Likely will require enhancing or creating a new case here https://github.com/temporalio/api-go/blob/4c00816d0d87af129f51a33be6f3b2ca20e3ccb7/cmd/proxygenerator/interceptor.go#L262

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-03-12 17:29:28.000 UTC</summary>

When this is implemented, this is another test that could be added 
```
func TestOperationStatus(t *testing.T) {
	require := require.New(t)

	var messageType protoreflect.MessageType
	protoregistry.GlobalTypes.RangeMessages(func(mt protoreflect.MessageType) bool {
		if string(mt.Descriptor().FullName()) == "temporal.api.errordetails.v1.MultiOperationExecutionFailure.OperationStatus" { 
			messageType = mt
		}
		return true
	})

	// Create empty instance and populate with test values
	msg := messageType.New().Interface().(proto.Message)
	var totalCount, count int
	populatePayload(&msg, msg, require, &totalCount, &count)

	require.Equal(0, count)
	require.Equal(1, totalCount)
}
```

</details>


---

<a id="1862"></a>

### #1862: [api-go] Support direct Payload's and Payload`s at top-level of Any in payload visitor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1862 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-03-11 21:25:14.000 UTC (10 months ago) |
| **Updated** | 2025-04-09 16:24:05.000 UTC |
| **Closed** | 2025-04-09 16:24:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
When creating a `common.Payload` and marshaling it into an `Any` type, the visitor is not able to visit this scenario, due to a missing `case *common.Payload` in `visitPayloads()`.

This scenario is not used in our API today, but something we may want to support in the future. 

**Describe the solution you'd like**
Implement this base case so we can visit this scenario.

**Additional context**
Here is a basic test I wrote to validate this new feature 
```
func TestVisitPayloads_AnyPayload(t *testing.T) {
	msg, err := anypb.New(inputPayload())
	require.NoError(t, err)
	root := &protocol.Message{Body: msg}
	var anyCount int
	err = VisitPayloads(context.Background(), root, VisitPayloadsOptions{
		Visitor: func(ctx *VisitPayloadsContext, p []*common.Payload) ([]*common.Payload, error) {
			anyCount++
			// Only mutate if the payloads has "test"
			if len(p) == 1 && string(p[0].Data) == "test" {
				return []*common.Payload{{Data: []byte("new-val")}}, nil
			}
			return p, nil
		},
	})
	require.NoError(t, err)
	require.Equal(t, 1, anyCount)
	update1, err := root.Body.UnmarshalNew()
	require.NoError(t, err)
	require.Equal(t, "new-val", string(update1.(*common.Payload).Data))
}
```

also see https://github.com/temporalio/api-go/pull/202#discussion_r1920352920 for more context


#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-03-12 17:30:29.000 UTC</summary>

When this is implemented, this is another test that can be added
```
func TestProtocolMessage(t *testing.T) {
	require := require.New(t)

	var messageType protoreflect.MessageType
	protoregistry.GlobalTypes.RangeMessages(func(mt protoreflect.MessageType) bool {
		if string(mt.Descriptor().FullName()) == "temporal.api.protocol.v1.Message" {
			messageType = mt
		}
		return true
	})

	// Create empty instance and populate with test values
	msg := messageType.New().Interface().(proto.Message)
	var totalCount, count int
	populatePayload(&msg, msg, require, &totalCount, &count)

	require.Equal(0, count)
	require.Equal(1, totalCount)
}
```

</details>


---

<a id="1842"></a>

### #1842: Support "RawValue" non-converted values

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1842 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-21 20:26:07.000 UTC (10 months ago) |
| **Updated** | 2025-02-21 20:30:32.000 UTC |
| **Closed** | 2025-02-21 20:30:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/603, need a simple payload wrapper that tells converters not to apply conversion.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-02-21 20:30:30.000 UTC</summary>

Actually, this is already present at #1231, closing this as duplicate

</details>


---

<a id="1809"></a>

### #1809: [api-go] Add test for proxy to make sure all payloads are visited even if it's not reachable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1809 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-02-10 15:19:26.000 UTC (11 months ago) |
| **Updated** | 2025-03-18 20:15:13.000 UTC |
| **Closed** | 2025-03-18 20:15:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The proxy should visit all payloads even if they are not reachable by the workflow service

**Describe the solution you'd like**
 Add a test that somehow makes sure every payload is visited even if it's not reachable from workflow service.

An ideal approach would be to confirm payload encoding in all the existing integration tests rather than trying to build a contrived one. The key is we use a different way of discovering/walking payloads vs. what is used to walk them on encoding.

**Additional context**
https://github.com/temporalio/api-go/pull/209

#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-03-18 20:15:12.000 UTC</summary>

completed in https://github.com/temporalio/api-go/pull/211

</details>


---

<a id="1757"></a>

### #1757: `WithStartOperation` docs fix

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1757 |
| **State** | CLOSED |
| **Author** | stephanos (Stephan Behnke) |
| **Created** | 2024-12-15 17:41:21.000 UTC (1 years ago) |
| **Updated** | 2025-02-26 01:37:06.000 UTC |
| **Closed** | 2025-02-26 01:37:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | stephanos |
| **Milestone** | None |

#### Description

https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions still mentions `WithStartOperation` from the old Update-with-Start API. Also, mention that `WorkflowIDConflictPolicy` is required.

#### Comments (1)

<details>
<summary><strong>stephanos</strong> commented on 2024-12-15 17:41:48.000 UTC</summary>

cc @dandavison. Just FYI, I can fix it.

</details>


---

<a id="1715"></a>

### #1715: Add VersioningOverride to StartWorkflowExecutionRequest

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1715 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-11-19 19:13:40.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-01 21:49:22.000 UTC |
| **Closed** | 2024-12-01 21:49:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

For canary tests in versioning-3 we need to specify target versioning information in the options when creating a workflow, so that we override the current default. See https://github.com/temporalio/api/pull/477 for details.



#### Comments (1)

<details>
<summary><strong>antlai-temporal</strong> commented on 2024-12-01 21:49:21.000 UTC</summary>

Merged in versioning-3 branch

</details>


---

<a id="1714"></a>

### #1714: Add versioning fields to WorkflowExecutionInfo

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1714 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-11-19 19:09:01.000 UTC (1y 1m ago) |
| **Updated** | 2024-11-27 04:36:40.000 UTC |
| **Closed** | 2024-11-27 04:35:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Versioning-3, an experimental API, introduces new `versioning_info` metadata that needs to be exposed in WorkflowExecutionInfo. See  https://github.com/temporalio/api/pull/472 for details.


#### Comments (1)

<details>
<summary><strong>antlai-temporal</strong> commented on 2024-11-27 04:35:37.000 UTC</summary>

The go sdk just exposes raw protobufs for `WorkflowExecutionInfo`, and the CLI just uses them directly. Closing...

</details>


---

<a id="1712"></a>

### #1712: Add support for the UpdateWorkflowExecutionOptions API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1712 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-11-19 18:59:48.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-01 21:50:07.000 UTC |
| **Closed** | 2024-12-01 21:50:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

A new API https://github.com/temporalio/api/pull/466 has been added that enables external tools to override versioning attributes for an existing workflow.

In the future, it will be extended to override other attributes, such as memo.

The ultimate goal is to provide support in the CLI, but we need to add SDK-go support first. 

#### Comments (1)

<details>
<summary><strong>antlai-temporal</strong> commented on 2024-12-01 21:50:06.000 UTC</summary>

Merged in versioning-3 branch

</details>


---

<a id="1705"></a>

### #1705: User-defined RequestId for SignalWorkflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1705 |
| **State** | OPEN |
| **Author** | ndtretyak (Nikolay Tretyak) |
| **Created** | 2024-11-07 14:54:22.000 UTC (1y 2m ago) |
| **Updated** | 2024-11-07 19:17:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I want to use server-side deduplication for signals. However, `RequestId` is always set to `uuid.New`
https://github.com/temporalio/sdk-go/blob/9d74a905fc3602dfa9dddf114087c43a1b64e6b8/internal/internal_workflow_client.go#L1829


**Describe the solution you'd like**
 An option to override the `RequestId` in each method, allowing users to specify their own identifier instead of a generated UUID. 



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-07 19:17:35.000 UTC</summary>

Long term server side deduplication of signals by `RequestId` is not a stable feature users should rely on https://github.com/temporalio/temporal/issues/4021 so it is intentionally not exposed in any SDK. If you want deduplication of signals the best approach is to put your own ID in the signal input and deduplicate in the workflow

</details>


---

<a id="1624"></a>

### #1624: Signal sent to Selector can be lost if Default path blocks 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1624 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-06 04:34:11.000 UTC (1y 4m ago) |
| **Updated** | 2025-11-12 16:50:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Selector can block in Default path without loosing signals

## Actual Behavior

Selector that block in the Default path risk loosing signals

When a signal is sent to the channel while the AddDefault method (long running) is executing, the signal is lost without being received. This was because if AddDefault is specified, the readyFunc is never executed. By storing the value in channel's recValue beforehand, we are making it available for any future receives on that channel without dropping the signal.

## Steps to Reproduce the Problem

  See: https://github.com/altafDevRev/temporal-samples/pull/1


#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-11-12 16:50:29.000 UTC</summary>

SDK flag was reverted in #2070, so this needs to be re-addressed.

When re-enabling the flag, must address the issue described in https://github.com/temporalio/sdk-go/issues/2066

</details>


---

<a id="1602"></a>

### #1602: Update internal timers to use NewTimerWithOptions and a summary

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1602 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-08-19 17:15:07.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-10 23:09:48.000 UTC |
| **Closed** | 2024-09-10 23:09:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Since #1597, there is now a way to provide a summary for a timer, so we should do so for internal timers we create inside the SDK

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-21 20:19:58.000 UTC</summary>

We should probably also expose s summary on `AwaitWithTimeout` as well so the timer is creates can have specific details. For internal and external use.

</details>


---

<a id="1598"></a>

### #1598: Typed nil versioning ramp panics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1598 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-08-17 00:22:19.000 UTC (1y 4m ago) |
| **Updated** | 2025-02-11 08:33:39.000 UTC |
| **Closed** | 2025-02-11 08:33:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The interface `Ramp` is an optional field for `VersioningAssignmentRule`, we should be able to set
it to `nil` regardless of the type of the `nil` object 

## Actual Behavior
Currently we can set it to  untyped `nil`, but with a typed `nil` it panics with a 
bad memory reference.

## Steps to Reproduce the Problem
```
func Test_WorkerVersioningRules_typed_nil(t *testing.T) {
	ramp := &VersioningRampByPercentage{
		Percentage: 45.0,
	}
	ramp = nil

	u := UpdateWorkerVersioningRulesOptions{
		TaskQueue: "myQueue",
		Operation: &VersioningOperationInsertAssignmentRule{
			RuleIndex: 0,
			Rule: VersioningAssignmentRule{
				TargetBuildID: "2.0",
				Ramp:          ramp,
			},
		},
	}
      /// This panics....!!
	_, err := u.validateAndConvertToProto("my_namespace")
}
```


#### Comments (1)

<details>
<summary><strong>antlai-temporal</strong> commented on 2025-02-11 08:33:38.000 UTC</summary>

Assignment rules have been deprecated and soon to be removed. Closing...

</details>


---

<a id="1587"></a>

### #1587: Activity failure is not encrypted with the key set to the context propagator, used to encrypt workflow and activity payload

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1587 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza PÃ©rez) |
| **Created** | 2024-08-13 13:01:49.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-27 14:43:12.000 UTC |
| **Closed** | 2024-08-27 14:43:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Using [this code](https://github.com/temporalio/samples-go/tree/main/encryption) as example, I have set the Failure converter with EncodeCommonAttributes to encrypt failures 

```
c, err := client.Dial(client.Options{
...
...
FailureConverter: temporal.NewDefaultFailureConverter(temporal.DefaultFailureConverterOptions{
	EncodeCommonAttributes: true,
	DataConverter:          dataConverter,
}),
```

workflow and activity payload are encrypted with the [key set to the context propagator](https://github.com/temporalio/samples-go/blob/main/encryption/starter/main.go#L55-L57) but not failures. 


## Expected Behavior

Failure attributes should be encrypted


## Actual Behavior

Failure attributes are not encrypted (or are encrypted with a different key) 


## Steps to Reproduce the Problem

There is a repro [here](https://github.com/antmendoza/my-temporal-pocs/tree/main/go/_6715/src) and 
the workflow history that it produces where [encryption-key-id is empty](https://github.com/antmendoza/my-temporal-pocs/blob/main/go/_6715/src/6a8e27d0-2d12-4c24-b960-de993137c587_events.json#L175-L177) 







#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-27 14:43:05.000 UTC</summary>

As discussed offline this is not excepted to work because failure converters cannot be context aware. I opened up an issue to add support to failure converters https://github.com/temporalio/sdk-go/issues/1609

Reactions: ðŸ‘ 1

</details>


---

<a id="1586"></a>

### #1586: Allow passing explicit search attributes when continuing as new

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1586 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2024-08-09 21:34:04.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-13 20:05:41.000 UTC |
| **Closed** | 2024-08-13 20:05:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Right now the SDK will carry over the current workflow's search attributes. Other SDKs also allow you to specify them explicitly. Obtain parity in this regard.

#### Comments (1)

<details>
<summary><strong>josh-berry</strong> commented on 2024-08-13 20:05:40.000 UTC</summary>

You can do this thru the WorkflowOptions; closing.

</details>


---

<a id="1574"></a>

### #1574: Batched heartbeat got canceled due to caller context cancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1574 |
| **State** | OPEN |
| **Author** | codemonkeycxy (Xinyi Chen) |
| **Created** | 2024-07-31 19:17:48.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-01 04:44:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Say I have the following activity code
```
func (a *Activities) MyActivity(ctx) (out, error)(
  g, gctx := errgroup.WithContext(ctx)
  g.SetLimit(4)
  for _, batch := range batches {
    batch := batch
    g.Go(func() error {
      activity.RecordHeartbeat(gctx)
      // Goroutine logic
    })
  }
  if err := g.Wait(); err != nil {
    return nil, err
  }

  for _, item := range array {
    activity.RecordHeartbeat(ctx)
    // Additional logic
  }
}
```
I expect heartbeat to get sent out to the server and my activity to NOT time out

## Actual Behavior
Activity timed out with `activity Heartbeat timeout`

This is because `g.Wait()` cancels `gctx` but `gctx` is still referenced in SDK `Heartbeat` function's goroutine https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L2031. Due to the batch heartbeat logic, `gctx` was used after `g.Wait()` had finished in my code and caused a `context canceled` error when making the call to the server

I could change `activity.RecordHeartbeat(gctx)` to `activity.RecordHeartbeat(ctx)` but wonder if SDK can avoid this pitfall by using context.Background()


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version: go.temporal.io/sdk v1.27.0
  - Platform: Linux


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-01 04:44:53.000 UTC</summary>

Talked offline discussed we should:
* Clarify the documentation around how `RecordHeartbeat` will behave if the calling context is cancelled
* If `RecordHeartbeat` is called with multiple contexts we should use the last non cancelled context.

</details>


---

<a id="1561"></a>

### #1561: Support Search Attributes in Schedules via Query Update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1561 |
| **State** | CLOSED |
| **Author** | justinp-tt |
| **Created** | 2024-07-23 21:53:48.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-25 18:34:05.000 UTC |
| **Closed** | 2024-07-25 18:34:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Support Search Attributes in Schedules via Query Update

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-07-24 12:41:50.000 UTC</summary>

Can the title be changed here to reflect this is for schedules and also that it is unrelated to query? Also, this seems to be very Go specific. We usually use the https://github.com/temporalio/features repository to make cross-SDK issues like this one so we track it for each SDK. Should I create the overarching issue so this can be done in other SDKs?

Reactions: ðŸ‘ 1

</details>


---

<a id="1551"></a>

### #1551: Typed search attributes issue with SignalWithStartWorkflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1551 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-07-17 17:22:32.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-17 19:42:02.000 UTC |
| **Closed** | 2024-07-17 19:42:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Typed search attributes defined in workflow options, for example:

        workflowOptions := client.StartWorkflowOptions{
		ID:                    "typed-search_attributes_test",
		TaskQueue:             "typed-search-attributes",
		TypedSearchAttributes: temporal.NewSearchAttributes(typedsearchattributes.CustomIntKey.ValueSet(1)),
	}

are propagated fine via ExecuteWorkflow but are missed to be propagated to new execution via SignalWithStartWorkflow
(when no workflow with workflow id exists, so new execution is created)

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-07-17 17:27:16.000 UTC</summary>

Thanks, I think this is a bug. https://github.com/temporalio/sdk-go/blob/81a76b1623de784f909a8e4c9fae647b92f5621f/internal/internal_workflow_client.go#L1713 is supposed to look like https://github.com/temporalio/sdk-go/blob/81a76b1623de784f909a8e4c9fae647b92f5621f/internal/internal_workflow_client.go#L1572 We will fix

Reactions: ðŸ‘ 1

</details>


---

<a id="1547"></a>

### #1547: Testing - child workflow update handler not registered in test

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1547 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-07-15 19:54:28.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-17 14:50:09.000 UTC |
| **Closed** | 2024-07-17 14:50:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Full test (can cut/paste/run): https://gist.github.com/tsurdilo/9e27c853e242a3a2a200ee704049bcf0

includes error in gist

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-17 14:50:08.000 UTC</summary>

Closed by https://github.com/temporalio/sdk-go/pull/1548

</details>


---

<a id="1521"></a>

### #1521: Workflow-friendly concurrency control

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1521 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 17:14:14.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-27 16:52:22.000 UTC |
| **Closed** | 2024-06-27 16:52:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.  To be used within signal and update handlers and the main workflow coroutine.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-27 16:52:22.000 UTC</summary>

Closed by https://github.com/temporalio/sdk-go/pull/1530

</details>


---

<a id="1501"></a>

### #1501: Expose UpdateID in an update handler

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1501 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-04 16:17:07.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-04 16:20:23.000 UTC |
| **Closed** | 2024-06-04 16:20:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This will allow users to use it when they want a unique primary key for samples

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-04 16:20:23.000 UTC</summary>

Update ID is already [exposed](https://pkg.go.dev/go.temporal.io/sdk@v1.26.1/internal#UpdateInfo)  

</details>


---

<a id="1499"></a>

### #1499: Warn or error when update handlers dangle across CAN or workflow exit

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1499 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-04 04:21:59.000 UTC (1y 7m ago) |
| **Updated** | 2024-07-03 21:07:16.000 UTC |
| **Closed** | 2024-07-03 21:07:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We can recommend the await-all-handlers or drop-all-handlers methods. TBD whether error or warning.


#### Comments (1)

<details>
<summary><strong>dandavison</strong> commented on 2024-06-28 12:21:22.000 UTC</summary>

I've merged the first PR, for Python: https://github.com/temporalio/sdk-python/pull/556

The basic spec that that PR's proposing for other SDKs is

- Workflow code can wait on a method named similarly to `workflow.all_handlers_finished()`

- By default, the worker will emit `workflow.UnfinishedUpdateHandlersWarning` and `workflow.UnfinishedSignalHandlersWarning` if any handlers of those types are unfinished when the workflow completes (cancellation, failure, success). See PR for wording of message.

- These warnings are controlled by a policy whose default value is `workflow.HandlerUnfinishedPolicy.WARN_AND_ABANDON`

- Users can silence the warning on a per-handler basis by setting unfinished_policy to `workflow.HandlerUnfinishedPolicy.ABANDON`

- Tests should verify the above for worker-side workflow exit via cancellation, failure, and success

</details>


---

<a id="1497"></a>

### #1497: Ensure our proxy helpers forward metadata

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1497 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-31 17:33:10.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-27 20:36:56.000 UTC |
| **Closed** | 2024-06-27 20:36:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

This would be an issue for https://pkg.go.dev/go.temporal.io/api/proxy but there is no "issues" section there. Basically we need to confirm that when using the proxy library in the default way, that the headers like client-name/client-version flow through the proxy. Write a test and, if it's not flowing through, make it do so. This may just be a case of our code gen using https://pkg.go.dev/google.golang.org/grpc/metadata to populating incoming context to outgoing context (and adding an option to disable it). Probably can't have an interceptor since users control that part, we just control the service proxy helper.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-06-05 16:11:05.000 UTC</summary>

PR opened at https://github.com/temporalio/api-go/pull/167 (which will be waiting for https://github.com/temporalio/sdk-go/pull/1502 to be released before merging).

</details>


---

<a id="1479"></a>

### #1479: Wrap GRPC::CANCELED and DEADLINE_EXCEEDED in an SDK Timeout exception for Update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1479 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-05-18 00:50:58.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-22 01:02:12.000 UTC |
| **Closed** | 2024-06-22 01:02:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

So that users only have to catch one predictable exception

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-06-05 20:01:18.000 UTC</summary>

See https://github.com/temporalio/features/issues/483#issuecomment-2150832036 for implementation details

</details>


---

<a id="1477"></a>

### #1477: temporal_worker_task_slots_available only reports workflow slots when using opentelemetry metrics handler

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1477 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza PÃ©rez) |
| **Created** | 2024-05-17 16:16:49.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-22 21:24:56.000 UTC |
| **Closed** | 2024-05-22 21:24:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
SDK should report the [slots available](https://docs.temporal.io/references/sdk-metrics#worker_task_slots_available) for workflow, activity and local activity worker 

it works as expected when the metrics handler is tally https://github.com/temporalio/samples-go/blob/main/metrics/worker/main.go#L18-L24 

## Actual Behavior
Using the opentelemetry metrics handler 

```
	exp, err := otlpmetrichttp.New(ctx, otlpmetrichttp.WithEndpointURL("http://localhost:4318"))
	if err != nil {
		panic(err)
	}
	meterProvider := metric.NewMeterProvider(metric.WithReader(
		metric.NewPeriodicReader(exp, metric.WithInterval(1*time.Second)),
	))
	handler := opentelemetry.NewMetricsHandler(
		opentelemetry.MetricsHandlerOptions{
			Meter: meterProvider.Meter("temporal-sdk-go"),
		},
	)

```
the SDK only reports slots available for `worker_type="WorkflowWorker"`

![Screenshot 2024-05-17 at 17 22 44](https://github.com/temporalio/sdk-go/assets/514932/e636bea2-5478-45b1-8c8f-48fc67887537)


Other metrics that have different values for workflow_type seem ok. 

![Screenshot 2024-05-17 at 17 22 27](https://github.com/temporalio/sdk-go/assets/514932/9e0825d1-ad8b-4f85-a9c8-7970c9875783)


You can find a repro here 

https://github.com/antmendoza/my-temporal-pocs/tree/main/go/_5888


```
go.temporal.io/api v1.33.0
go.temporal.io/sdk v1.26.1
go.temporal.io/sdk/contrib/opentelemetry v0.5.0

```



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-18 23:31:52.000 UTC</summary>

This appears to be a regression or at least change in behaviour of the [OTEL Go SDK](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric) testing with version `1.21.0` then `temporal_worker_task_slots_available` is reported correctly, but testing with `1.26.0` it is not. I have a work around for our integration and will need to open up and issue with the OTEL Go SDK if this is intentional or not.

Reactions: ðŸ‘ 1

</details>


---

<a id="1474"></a>

### #1474: Tracing interceptor support for Nexus Operations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1474 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-05-16 16:28:28.000 UTC (1y 7m ago) |
| **Updated** | 2025-04-30 16:10:39.000 UTC |
| **Closed** | 2025-04-30 16:10:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We need to add support for propagating headers from a Workflow to a Nexus Operation handler to the StartOperation request.

In order to do that we'll need to first add an `NexusOperationInboundInterceptor`.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-16 16:30:32.000 UTC</summary>

I think we just need to add support for the [TracingInterceptor](https://github.com/temporalio/sdk-go/blob/master/interceptor/tracing_interceptor.go) 

Reactions: ðŸ‘ 1

</details>


---

<a id="1471"></a>

### #1471: Support New Versioning in WorkflowInfo.GetCurrentBuildID()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1471 |
| **State** | OPEN |
| **Author** | ShahabT (Shahab Tajik) |
| **Created** | 2024-05-14 05:06:29.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-29 01:17:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

In new versioning, current build ID for tasks being replayed should be retrieved from the WFTStarted event rather than WFTCompleted event. The stamp in `WorkflowTaskCompletedEventAttributes` is deprecated and will be removed after old versioning clean up.

Note that if the started event does not have a (non-empty) Build ID, then the one in completed task should be still used to keep the support for old versioning for now.


#### Comments (1)

<details>
<summary><strong>antlai-temporal</strong> commented on 2024-05-29 01:17:13.000 UTC</summary>

Currently we are duplicating the Build ID and adding it to both WFTStarted and WFTCompleted for backwards compatibility, is that correct?

</details>


---

<a id="1445"></a>

### #1445: OTel metric handler improvements

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1445 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-04-17 15:05:59.000 UTC (1y 8m ago) |
| **Updated** | 2024-04-17 15:24:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

* Opt-in option to have timers/histograms in integer milliseconds instead of float seconds
* Opt-in option to have counters suffixed with `_total` and histograms end with `_milliseconds` or `_seconds`
* Do not report a gauge value if no value is ever set for it

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-17 15:24:51.000 UTC</summary>

Renaming should go through a [view](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric#View) we should provide a sample showing how. I am not sure if changing the metric type can be done through a view, if not then agree we should add. Agree with the last point.

Reactions: ðŸ‘ 1

</details>


---

<a id="1441"></a>

### #1441: temporal_workflow_task_execution_failed not emitted on replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1441 |
| **State** | CLOSED |
| **Author** | codemonkeycxy (Xinyi Chen) |
| **Created** | 2024-04-11 16:23:37.000 UTC (1y 9m ago) |
| **Updated** | 2024-10-15 16:15:12.000 UTC |
| **Closed** | 2024-10-15 16:15:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
We rely on `temporal_workflow_task_execution_failed` metric to alert us on potential workflow non-determinism errors. We expect this metric to be emitted when closed workflow is replayed

## Actual Behavior
The metric is not emitted when the closed workflow is replayed

## Steps to Reproduce the Problem

  1. Run a workflow and wait for completion
  1. Update worker with a non-deterministic change
  1. Query the completed workflow and `temporal_workflow_task_execution_failed` is not emitted

## Specifications

  - Version: v1.26.0
  - Platform:


#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2024-10-11 17:08:48.000 UTC</summary>

@codemonkeycxy I've confirmed this hits on 1.26.0. Going off of tip of tree, this seems to be resolved and the metric emits correctly. Is this still an issue for you, or were you able to upgrade your SDK version to ingest the fix?

</details>


---

<a id="1399"></a>

### #1399: Reset `WorkflowPanicPolicy` option

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1399 |
| **State** | CLOSED |
| **Author** | elb3k (Elbek Khoshimjonov) |
| **Created** | 2024-02-26 20:46:40.000 UTC (1y 10m ago) |
| **Updated** | 2024-02-26 22:26:42.000 UTC |
| **Closed** | 2024-02-26 22:15:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
All workflows we use are restartable, workflow versioning is not possible, since there are a lot of changes being deployed.

**Describe the solution you'd like**
When `WorkflowPanicPolicy` is set to `ResetWorkflow`, the workflow will restart when a panic occurs.
An additional option called `ResetReapplyType` same as in the `ResetWorkflowExecutionRequest` (option is used when resetting a workflow)

**Describe alternatives you've considered**
Setting `WorkflowPanicPolicy` as `FailWorkflow` and set workflow `RetryPolicy` seems to be working. But there are a few caveats with it:
- Any real errors returning from the workflow to terminate the workflow must be wrapped with `temporal.NewNonRetyableError`
- Reset does not replay the signals (which we want).

**Additional context**
Discussion related to this feature request: https://community.temporal.io/t/catching-nondeterministicexception/5020/5


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-26 21:26:10.000 UTC</summary>

@elb3k there is already a SDK feature issue for this https://github.com/temporalio/features/issues/417.


Reactions: ðŸ‘ 1

</details>


---

<a id="1395"></a>

### #1395: Make TestWorkflowEnvironment return errors with stack traces

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1395 |
| **State** | OPEN |
| **Author** | recht (Joakim Recht) |
| **Created** | 2024-02-22 20:39:03.000 UTC (1y 10m ago) |
| **Updated** | 2024-02-26 15:30:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

If a test fails, for example because a context is used wrongly, there's almost no information available to debug, and you have to go through error unwrapping and checking in order to get to a usable stacktrace.

The usual solution is to implement a `Format` function on errors that prints more information when formatted using `%+v`. Functions like `require.NoError` also use this, so if there is a verbose version then that will be printed.


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-02-26 15:30:08.000 UTC</summary>

> If a test fails, for example because a context is used wrongly, there's almost no information available to debug

Are you setting logging in this test environment? Go errors are often short on this kind of information when just printed directly and encourage logging or explicit error extraction to fill in the gaps here. If we are not logging information that we should, we can make sure we do.

</details>


---

<a id="1376"></a>

### #1376: Expose next retry delay on Application Failure in all SDKs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1376 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-02-02 22:35:15.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-02 22:36:39.000 UTC |
| **Closed** | 2024-02-02 22:36:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We recently added the ability for an activity to specify the next retry delay on failure via a [field on `ApplicationFailureInfo`](https://github.com/temporalio/api/blob/822966d29758cba3462d6f5ff198257fbaa426f6/temporal/api/failure/v1/message.proto#L49).

Expose this in the SDK.

#### Comments (1)

<details>
<summary><strong>bergundy</strong> commented on 2024-02-02 22:36:30.000 UTC</summary>

This was done in Go already.

</details>


---

<a id="1354"></a>

### #1354: Please help regenerate mocks

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1354 |
| **State** | CLOSED |
| **Author** | yinsidij (Yinsidi) |
| **Created** | 2024-01-15 08:15:06.000 UTC (1y 12m ago) |
| **Updated** | 2024-01-17 22:20:25.000 UTC |
| **Closed** | 2024-01-17 22:20:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, the `ExecuteWorkflow` mocker can only support return based on the static argument

```
	mockClient.On("ExecuteWorkflow", mock.Anything, mock.AnythingOfType("internal.StartWorkflowOptions"), mock.Anything,
		&datamodel.NewCustomerMetadata{
			CustomerID:       "good",
		},
	).Return(mockWorkflowRun, nil).Maybe()

	mockClient.On("ExecuteWorkflow", mock.Anything, mock.AnythingOfType("internal.StartWorkflowOptions"), mock.Anything,
		&datamodel.NewCustomerMetadata{
			CustomerID:       "bad",
		},
	).Return(nil, fmt.Errorf("error")).Maybe()
```
With latest mocker, we could do
```
	mockClient.On("ExecuteWorkflow", mock.Anything, mock.AnythingOfType("internal.StartWorkflowOptions"), mock.AnythingOfType("string"), mock.Anything).Return(
		func(ctx context.Context, options client.StartWorkflowOptions, workflow string, newCustomerMetadata *datamodel.NewCustomerMetadata) (client.WorkflowRun, error) {
			if newCustomerMetadata.CustomerID == "bad" {
				return nil, fmt.Errorf("error")
			}
			return nil, nil
		},
	).Maybe()
```
This is becoming very useful if one argument in `newCustomerMetadata` is `timestamp` with the usage `time.Now()`. With existing mocker, it's difficult to do the mocking as testify would find out the argument match by value

**Describe the solution you'd like**
Please rerun latest mockery
Example
https://github.com/temporalio/sdk-go/pull/1353

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (1)

<details>
<summary><strong>yinsidij</strong> commented on 2024-01-17 22:20:25.000 UTC</summary>

this will be solved by PRs
https://github.com/temporalio/sdk-go/pull/1353
https://github.com/temporalio/sdk-go/pull/1361

</details>


---

<a id="1334"></a>

### #1334: Allow opting out of tracer span creation on schedule create

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1334 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-01-03 21:11:23.000 UTC (2 years ago) |
| **Updated** | 2025-12-05 21:22:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Today the tracing interceptor always creates a span and attaches to workflow action on schedule create. Allow user to opt out of this in tracing interceptor options.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-12-05 21:22:21.000 UTC</summary>

(do not blindly implement as is, see discussion starting with comment https://github.com/temporalio/features/issues/394#issuecomment-1966551344 before proceeding)

</details>


---

<a id="1323"></a>

### #1323: Dynamic worker config

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1323 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-12-15 15:58:48.000 UTC (2 years ago) |
| **Updated** | 2025-02-04 19:00:08.000 UTC |
| **Closed** | 2025-02-04 19:00:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/388



#### Comments (1)

<details>
<summary><strong>josh-berry</strong> commented on 2025-02-04 19:00:06.000 UTC</summary>

Unclear what/how we want to do this, and a lot has changed since this was opened (e.g. we are building Nexus now, which could be a transport for config changes). Closing for now.

</details>


---

<a id="1300"></a>

### #1300: Better Task Failures when passing incorrect options to Execute[Local]Activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1300 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2023-11-23 00:32:32.000 UTC (2y 1m ago) |
| **Updated** | 2023-11-27 14:57:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
If you pass `ActivityOptions` to `ExecuteLocalActivity` or make the inverse mistake, right now that'll surface as a task failure generated by server along the lines of you missing one of the required timeouts. This is technically true, but can be a source of confusion to a user looking at their code and saying "I _am_ setting a timeout" without realizing that the real problem was they specified the wrong kind of options.

**Describe the solution you'd like**
We should explicitly fail the task from the SDK side with an error message making it clear that the wrong type of options were applied to the context for the call being made.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-11-27 14:57:36.000 UTC</summary>

The problem here is that you're not "passing" things to these calls, they are just set on the context somewhere before. That one set of options may be present does not mean there was an options mixup. But having said that, yes, if we don't give a clear error message that (local) activity options are not set on the context, we should (and clearly state _which_ ones must be set).

</details>


---

<a id="1284"></a>

### #1284: [feature]: Allow GetCurrentHistoryLength() to return > 0 during tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1284 |
| **State** | CLOSED |
| **Author** | justenwalker (Justen Walker) |
| **Created** | 2023-10-29 22:23:10.000 UTC (2y 2m ago) |
| **Updated** | 2023-10-29 22:26:49.000 UTC |
| **Closed** | 2023-10-29 22:26:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

It is currently not possible to test a workflow that runs forever.

Something like:
```go
func MyWorkflow(ctx workflow.Context, params Params) error {
  for {
    if workflow.GetInfo(ctx).GetCurrentHistoryLength() > maxHistoryLength { // This will never evaluate to true in tests
      return workflow.NewContinueAsNewError(ctx, MyWorkflow, params)
    }
    // doSomething
    if err := workflow.Sleep(ctx, time.Hour); err != nil { return err }
  }
}
```

Will never stop running since the history length is always 0 during tests.

**Describe the solution you'd like**

There should be some way to set the current history length as returned by `workflow.GetInfo(ctx).GetCurrentHistoryLength()` to trigger the `continue-as-new` branch.

**Describe alternatives you've considered**

One could possible expose a global variable that you could set in testing to bypass the history check and make it always run the ContinueAsNew line; but adding additional code to workflow solely for testing seems like a poor practice.



#### Comments (1)

<details>
<summary><strong>justenwalker</strong> commented on 2023-10-29 22:26:49.000 UTC</summary>

Seems this exists: nevermind!
https://github.com/temporalio/sdk-go/blob/3cccbdd5f47d640fffe6651e4f49c236a4803a47/internal/workflow_testsuite.go#L309

</details>


---

<a id="1271"></a>

### #1271: Make nondeterminism errors more clear

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1271 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-18 14:10:04.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-21 16:44:49.000 UTC |
| **Closed** | 2023-11-21 16:44:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Some errors the SDK returns when it detects non determinism do not make it obvious to users that the root cause is likely non determinism.

Errors like:

```
lookup failed for scheduledEventID to activityID: scheduleEventID: 5, activityID: 5 [...]
```

```
No cached result found for side effectID[...]
```

more [here](https://community.temporal.io/t/go-sdk-troubleshooting/4440#workflow-non-determinism-5)

All these errors should suggested the error is likely caused by a non deterministic code change so users have a place to start debugging.

#### Comments (1)

<details>
<summary><strong>josh-berry</strong> commented on 2023-11-07 19:36:23.000 UTC</summary>

Is this a dup of #864?

</details>


---

<a id="1261"></a>

### #1261: Simplify/fix worker API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1261 |
| **State** | CLOSED |
| **Author** | ash2k (Mikhail Mazurskiy) |
| **Created** | 2023-10-11 04:37:38.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-11 15:21:38.000 UTC |
| **Closed** | 2023-10-11 15:21:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Tried using `Worker.Run()` with a context but the signature wants a `<-chan interface{}` while context's `Done()` returns `<-chan struct{}`.

**Describe the solution you'd like**

I think the API can be simplified to just have `Run(context.Context) error` method instead of the `Start()`/`Stop()` (i.e. remove them as they duplicate functionality).


`worker.InterruptCh()` is not needed because the user can always do it using [`signal.NotifyContext()`](https://pkg.go.dev/os/signal#NotifyContext).

**Describe alternatives you've considered**

If not the above, `Run()` should at least take the `context.Context` rather than a channel.

**Additional context**

N/A


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-11 15:21:37.000 UTC</summary>

In hindsight making `Run` take a `<-chan struct{}` would have been better then taking a `<-chan interface{}` or `context`, but we have stability requirements that prevent changing any of our public API.

</details>


---

<a id="1259"></a>

### #1259: contrib/opentelemetry release that has AllowInvalidParentSpans

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1259 |
| **State** | CLOSED |
| **Author** | rivaldya |
| **Created** | 2023-10-09 23:03:30.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-10 22:32:20.000 UTC |
| **Closed** | 2023-10-10 22:32:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

With the release of 1.25.0 where tracing interceptor accepts `AllowInvalidParentSpans` in tracer options (https://github.com/temporalio/sdk-go/pull/1178), there needs to be a subsequent release for contrib/opentelemetry (the latest one is 0.2.0) to apply the changes in https://github.com/temporalio/sdk-go/pull/1178 in contrib/opentelemetry


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-10 22:32:20.000 UTC</summary>

A latest release has been tagged https://pkg.go.dev/go.temporal.io/sdk/contrib/opentelemetry@v0.3.0

Reactions: â¤ï¸ 1

</details>


---

<a id="1257"></a>

### #1257: Allow RetryPolicyOptions to take a predicate (function) to evaluate whether to retry or not

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1257 |
| **State** | CLOSED |
| **Author** | Mohsin-Ul-Islam (Syed Mohsin Ul Islam) |
| **Created** | 2023-10-04 12:07:00.000 UTC (2y 3m ago) |
| **Updated** | 2023-11-12 07:45:49.000 UTC |
| **Closed** | 2023-11-12 07:45:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It would be great to have retry based on some predicate that the user provides alongside the existing retry options. 

For example:

```go
RetryPolicy{
  InitialInterval: time.Second * 1,
  MaxAttempts: 5,
  Predicate: func () bool { return true },
}
```

Something like this would be very convenient to have custom retry logic. Currently, I handle custom retries manually with Temporal.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-11 12:35:00.000 UTC</summary>

Hi @Mohsin-Ul-Islam,  while I do think that would be useful I don't think it is feasible as described. `RetryPolicy`  are retries that are handled by the Temporal  service, and I wouldn't want to change that semantics. Therefore any `RetryPolicy` the worker needs to be able to serialize and send them to Temporal. We can't serialize an arbitrary function.

I  think a feature like is described here https://github.com/temporalio/sdk-java/issues/806 would be a more feasible alternative.

Reactions: ðŸ‘ 1

</details>


---

<a id="1231"></a>

### #1231: Add RawValue type 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1231 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-11 14:16:15.000 UTC (2y 4m ago) |
| **Updated** | 2025-03-27 20:33:43.000 UTC |
| **Closed** | 2025-03-27 20:33:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Sometimes users just want to get the payload from something without attempting any data conversion.

**Describe the solution you'd like**
Add a type like pythons [RawValue](https://python.temporal.io/temporalio.common.RawValue.html) to the Go SDK

**Additional context**
This would be useful to handle corrupted signals because the user could read the signal value without putting it through the data converter

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-02-21 20:30:40.000 UTC</summary>

See https://github.com/temporalio/features/issues/603

</details>


---

<a id="1227"></a>

### #1227: Worker versioning + workflow session

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1227 |
| **State** | OPEN |
| **Author** | robindarby (Robin Darby) |
| **Created** | 2023-09-06 12:35:30.000 UTC (2y 4m ago) |
| **Updated** | 2025-02-04 18:25:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Calling workflow.CreateSessio, while using a versioned worker, creates a new session context for that worker.

## Actual Behavior
The new session has no worker; "internalSessionCreationActivity" will timeout: 
`activity error (type: internalSessionCreationActivity, scheduledEventID: 6, startedEventID: 0, identity: ): activity ScheduleToStart timeout (type: ScheduleToStart) ;`

Could it be because this internal activity has the following attribute: Use Compatible Version false (as seen in the UI)?

## Steps to Reproduce the Problem
1. set a worker version via the SDK as follows:

```
func setTemporalTaskQueueDefaultVersion(temporalClient client.Client, taskQueue string, buildId string) error {
	if err := temporalClient.UpdateWorkerBuildIdCompatibility(context.Background(), &client.UpdateWorkerBuildIdCompatibilityOptions{
		TaskQueue: taskQueue,
		Operation: &client.BuildIDOpAddNewIDInNewDefaultSet{
			BuildID: buildId,
		},
	}); err != nil {
		return err
	}
	return nil
}
```

1. Then, use that version in the worker:

```
	w := worker.New(temporalClient, workflows.QueueName, worker.Options{
		EnableSessionWorker:     true,
		BuildID:                 *buildId,
		UseBuildIDForVersioning: useBuildIDForVersioning,
	})
```

1. Now, in a workflow, when you call:

```
	activityOptions := workflow.ActivityOptions{
		StartToCloseTimeout: 60 * time.Minute,
		RetryPolicy: &temporal.RetryPolicy{
			MaximumAttempts: 2,
		},
		TaskQueue:        QueueName,
	}
	ctx = workflow.WithActivityOptions(ctx, activityOptions)

	so := &workflow.SessionOptions{
		CreationTimeout:  time.Minute,
		ExecutionTimeout: time.Hour,
	}
	ctx, err := workflow.CreateSession(ctx, so)
	if err != nil {
		return nil, err
	}
	defer workflow.CompleteSession(ctx)
```

## Specifications
* Version: v1.24.0
* Platform: Linux



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-09-09 23:00:37.000 UTC</summary>

Unfortunately worker versioning and sessions are not compatible at this time because the task queue used for `internalSessionCreationActivity` ,  the activity responsible for creating the session, does not have the same version info as the original task queue and the server has no way to link two task queues together.

</details>


---

<a id="1212"></a>

### #1212: Queryable registry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1212 |
| **State** | CLOSED |
| **Author** | edmondop (Edmondo Porcu) |
| **Created** | 2023-08-27 20:41:33.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-28 19:23:02.000 UTC |
| **Closed** | 2023-08-28 19:23:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

As discussed in this thread https://temporalio.slack.com/archives/CTDTU3J4T/p1692921277359619 there might be use cases where querying the worker for the registered activities and workflow could be useful


**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
Storing this information into an external data structure or as tsurdilo mentioned : "have seen users in code that creates worker and registers activities write small file to file system with what it registered and then in worker host pod/container expose like simple get api that returns this info"

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-08-28 12:17:40.000 UTC</summary>

(reposting what I put on PR)

I don't think this is necessary. Users are the ones adding to the registry, so they can keep track of what they add (or they can implement the interface themselves with something that does keep track or put what to register in a collection that is then registered all at once or whatever).

Also, adding methods to an interface is a breaking change (though we still sometimes do it).

</details>


---

<a id="1211"></a>

### #1211: Client for test environment [golang]

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1211 |
| **State** | CLOSED |
| **Author** | orby-will (Will Lu) |
| **Created** | 2022-11-21 19:07:50.000 UTC (3y 1m ago) |
| **Updated** | 2023-08-28 12:20:25.000 UTC |
| **Closed** | 2023-08-28 12:20:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The testsuite.TestWorkflowEnvironment struct implements all the functions of client.Client interface except for the cancel function.

**Describe the solution you'd like**
Cannot use env (variable of type *"go.temporal.io/sdk/internal".TestWorkflowEnvironment) as client.Client value in assignment: *"go.temporal.io/sdk/internal".TestWorkflowEnvironment does not implement client.Client (wrong type for method CancelWorkflow)
		have CancelWorkflow()
		want CancelWorkflow(ctx "context".Context, workflowID string, runID string) error

**Describe alternatives you've considered**
Alternatively, if the team can provide a separate implementation for the client.



#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-08-28 12:20:25.000 UTC</summary>

> The testsuite.TestWorkflowEnvironment struct implements all the functions of client.Client interface except for the cancel function.

There are actually/now many functions that it doesn't implement. The test environment is not meant to implement the client. That would be confusing for people that expect client behavior. Closing as won't fix, but feel free to continue discussion.

</details>


---

<a id="1209"></a>

### #1209: Race condition when evicting a workflow from cache

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1209 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-08-24 18:13:11.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-29 13:52:32.000 UTC |
| **Closed** | 2023-08-29 13:52:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Evicting a workflow from cache does not cause a race condition in the SDK

## Actual Behavior
Evicting a workflow from cache does causes a race condition in the SDK


## Steps to Reproduce the Problem
To reproduce run add this workflow and a test to run it to `test` in the Go SDK
```
func (w *Workflows) ReproduceRace(ctx workflow.Context) error {
	re := func(ctx workflow.Context) {
		fmt.Printf("Goroutine running \n")
		ctx, _ = workflow.NewDisconnectedContext(ctx)
		childCtx, childCancel := workflow.WithCancel(ctx)
		childCtx = workflow.WithChildOptions(childCtx, workflow.ChildWorkflowOptions{WaitForCancellation: true})
		child := workflow.ExecuteChildWorkflow(childCtx, w.SleepForDuration, 10*time.Minute)
		if err := child.GetChildWorkflowExecution().Get(ctx, nil); err != nil {
			panic(err)
		}

		defer func() {
			fmt.Printf("Goroutine defer \n")
			time.Sleep(time.Second)
			childCancel()
		}()

		workflow.Sleep(ctx, time.Hour)
		fmt.Printf("!!!! Ran passed sleep, this is unexpected \n")
	}

	for i := 0; i < 10; i++ {
		fmt.Printf("Launching goroutine: %d \n", i)
		workflow.Go(ctx, re)
	}
	fmt.Printf("Workflow sleeping \n")
	workflow.Sleep(ctx, 5*time.Second)
	fmt.Printf("Workflow returning \n")
	return nil
}
```
and run with race detector on like
`go test --race  -run TestIntegrationSuite -testify.m TestConcurrentMapWriteWorkflow`

This will trigger a race condition in the SDK, the exact races change between runs, but here is one
```
WARNING: DATA RACE
Read at 0x00c0003fe6f0 by goroutine 65:
  runtime.mapaccess1()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/map.go:396 +0x26c
  go.temporal.io/sdk/internal.(*commandsHelper).getCommand()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_command_state_machine.go:919 +0x54
  go.temporal.io/sdk/internal.(*commandsHelper).requestCancelExternalWorkflowExecution()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_command_state_machine.go:1202 +0x70
  go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).RequestCancelChildWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_event_handlers.go:372 +0x8c
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).RequestCancelChildWorkflow()
      <autogenerated>:1 +0x20
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteChildWorkflow.func2.1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:956 +0x158
  go.temporal.io/sdk/internal.(*channelImpl).Close()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:901 +0x114
  go.temporal.io/sdk/internal.(*cancelCtx).cancel()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/context.go:333 +0xdc
  go.temporal.io/sdk/internal.WithCancel.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/context.go:196 +0x4c
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace.func1.1()
      /Users/quinnklassen/Documents/Code/sdk-go/test/workflow_test.go:835 +0x78
  runtime.deferCallSave()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/panic.go:798 +0x8c
  go.temporal.io/sdk/internal.(*coroutineState).initialYield()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:928 +0xa0
  go.temporal.io/sdk/internal.(*coroutineState).yield()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:937 +0x378
  go.temporal.io/sdk/internal.(*channelImpl).Receive()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:729 +0x2dc
  go.temporal.io/sdk/internal.(*futureImpl).Get()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:321 +0x74
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:1153 +0x58
  go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/interceptor_base.go:258 +0x64
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Sleep()
      <autogenerated>:1 +0x20
  go.temporal.io/sdk/internal.Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:1148 +0x90
  go.temporal.io/sdk/workflow.Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/workflow/deterministic_wrappers.go:174 +0x208
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/test/workflow_test.go:842 +0x1f0
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1040 +0xf0
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1041 +0x44

Previous write at 0x00c0003fe6f0 by goroutine 61:
  runtime.mapaccessK()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/map.go:519 +0x1ec
  go.temporal.io/sdk/internal.(*commandsHelper).moveCommandToBack()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_command_state_machine.go:963 +0x5bc
  go.temporal.io/sdk/internal.(*childWorkflowCommandStateMachine).cancel()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_command_state_machine.go:711 +0xb0
  go.temporal.io/sdk/internal.(*commandsHelper).requestCancelExternalWorkflowExecution()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_command_state_machine.go:1203 +0x84
  go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).RequestCancelChildWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_event_handlers.go:372 +0x8c
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).RequestCancelChildWorkflow()
      <autogenerated>:1 +0x20
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteChildWorkflow.func2.1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:956 +0x158
  go.temporal.io/sdk/internal.(*channelImpl).Close()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:901 +0x114
  go.temporal.io/sdk/internal.(*cancelCtx).cancel()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/context.go:333 +0xdc
  go.temporal.io/sdk/internal.WithCancel.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/context.go:196 +0x4c
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace.func1.1()
      /Users/quinnklassen/Documents/Code/sdk-go/test/workflow_test.go:835 +0x78
  runtime.deferCallSave()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/panic.go:798 +0x8c
  go.temporal.io/sdk/internal.(*coroutineState).initialYield()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:928 +0xa0
  go.temporal.io/sdk/internal.(*coroutineState).yield()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:937 +0x378
  go.temporal.io/sdk/internal.(*channelImpl).Receive()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:729 +0x2dc
  go.temporal.io/sdk/internal.(*futureImpl).Get()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:321 +0x74
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:1153 +0x58
  go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/interceptor_base.go:258 +0x64
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Sleep()
      <autogenerated>:1 +0x20
  go.temporal.io/sdk/internal.Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:1148 +0x90
  go.temporal.io/sdk/workflow.Sleep()
      /Users/quinnklassen/Documents/Code/sdk-go/workflow/deterministic_wrappers.go:174 +0x208
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/test/workflow_test.go:842 +0x1f0
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1040 +0xf0
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1041 +0x44

Goroutine 65 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1031 +0x578
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:308 +0x70
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
      /Users/quinnklassen/Documents/Code/sdk-go/test/integration_test.go:4090 +0x19c
  go.temporal.io/sdk/internal.Go()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:450 +0x98
  go.temporal.io/sdk/workflow.Go()
      /Users/quinnklassen/Documents/Code/sdk-go/workflow/deterministic_wrappers.go:138 +0x188
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace()
      /Users/quinnklassen/Documents/Code/sdk-go/test/workflow_test.go:848 +0x178
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace-fm()
      <autogenerated>:1 +0x44
  runtime.call16()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/asm_arm64.s:478 +0x74
  reflect.Value.Call()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/reflect/value.go:380 +0x90
  go.temporal.io/sdk/internal.executeFunction()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_worker.go:1797 +0x34c
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:530 +0x1fc
  go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/interceptor_base.go:154 +0x64
  go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
      <autogenerated>:1 +0x20
  go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/test/integration_test.go:4133 +0x158
  go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_worker.go:805 +0x370
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:512 +0x150
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1040 +0xf0
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1041 +0x44

Goroutine 61 (finished) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1031 +0x578
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:308 +0x70
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
      /Users/quinnklassen/Documents/Code/sdk-go/test/integration_test.go:4090 +0x19c
  go.temporal.io/sdk/internal.Go()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:450 +0x98
  go.temporal.io/sdk/workflow.Go()
      /Users/quinnklassen/Documents/Code/sdk-go/workflow/deterministic_wrappers.go:138 +0x188
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace()
      /Users/quinnklassen/Documents/Code/sdk-go/test/workflow_test.go:848 +0x178
  go.temporal.io/sdk/test_test.(*Workflows).ReproduceRace-fm()
      <autogenerated>:1 +0x44
  runtime.call16()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/asm_arm64.s:478 +0x74
  reflect.Value.Call()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/reflect/value.go:380 +0x90
  go.temporal.io/sdk/internal.executeFunction()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_worker.go:1797 +0x34c
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/workflow.go:530 +0x1fc
  go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/interceptor_base.go:154 +0x64
  go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
      <autogenerated>:1 +0x20
  go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
      /Users/quinnklassen/Documents/Code/sdk-go/test/integration_test.go:4133 +0x158
  go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_worker.go:805 +0x370
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:512 +0x150
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1040 +0xf0
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /Users/quinnklassen/Documents/Code/sdk-go/internal/internal_workflow.go:1041 +0x44
==================
```

I believe the reason for these races is how we clean up a cached workflow when we evict it from the cache (In this case we are evicting when the workflow is completed) 

When we evict a workflow from the cache we call `runtime.Goexit()` [from each Go routine the workflow launched](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow.go#L1006). Calling `runtime.Goexit()` terminates those Go routines, but also calls their respective defers. Since we clean up all the workflows Go routines in [a loop](https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow.go#L1142), and don't do any synchronization between them, we are running all their defers in parallel. If more than one of those defers does something that generates a command there is a race on multiple data structure in the SDK state machine. I'll note note every command that would normally generate a command will generate a command in this case because the `dispatcherImpl` is no longer running a lot of those function like `ExecuteActivity` will panic. Canceling a child workflow is not one of those cases.



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-24 18:14:07.000 UTC</summary>

Possibly the root cause of these bugs https://github.com/temporalio/sdk-go/issues/743, https://github.com/temporalio/sdk-go/issues/1190

</details>


---

<a id="1196"></a>

### #1196: v1.24.0 requires Go v1.19+

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1196 |
| **State** | CLOSED |
| **Author** | AriehSchneier (Arieh Schneier) |
| **Created** | 2023-08-09 23:38:31.000 UTC (2y 5m ago) |
| **Updated** | 2023-08-11 17:04:08.000 UTC |
| **Closed** | 2023-08-11 17:04:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This PR https://github.com/temporalio/sdk-go/pull/1164 added the usage of `atomic.Bool` which was only added in [Go v1.19](https://pkg.go.dev/sync/atomic#Bool).

You should update your go.mod to specify the min requirement, or switch it to use `uberatomic.Bool` (like the rest of the code) instead.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-09 23:45:17.000 UTC</summary>

When we update CI for Go 1.21 we will update the Go mod file

Reactions: ðŸ‘ 1

</details>


---

<a id="1172"></a>

### #1172: Temporarily expose gRPC client connection for cloud API use

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1172 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-07-24 17:19:28.000 UTC (2y 5m ago) |
| **Updated** | 2024-03-22 15:58:31.000 UTC |
| **Closed** | 2024-03-22 15:58:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

The in-development cloud API wants to reuse the gRPC connection from the Go client to instantiate the gRPC API. This API is not yet stable and may move to a different location at some point, so this is just a temporary need at this time.

I think a `GetGRPCConnection(internal.Client) *grpc.ClientConn` should be added to https://pkg.go.dev/go.temporal.io/sdk/internalbindings with a warning that it is experimental and may be removed in the future.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-03-22 15:58:31.000 UTC</summary>

This is not the approach we're going to take, see #1426 for a more full-fledged cloud client.

</details>


---

<a id="1111"></a>

### #1111: Panic from goroutine is not caught and crashes worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1111 |
| **State** | CLOSED |
| **Author** | nfiacco (Nick Fiacco) |
| **Created** | 2023-05-15 23:49:33.000 UTC (2y 7m ago) |
| **Updated** | 2023-05-22 12:39:41.000 UTC |
| **Closed** | 2023-05-22 12:39:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When my activity panics, the panic should be trapped by recover within the Temporal Go SDK.

## Actual Behavior
The panic crashes the entire worker.

## Steps to Reproduce the Problem

  1. Panic from a goroutine via nil pointer dereference.

Sample reproduction can be found here: https://github.com/nfiacco/temporal-bug-repro

## Specifications

  - Version: v1.22.2
  - Platform: Go SDK


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-05-22 12:39:41.000 UTC</summary>

Temporal cannot catch panics in every goroutine you create. You are responsible for handling your own panics in your goroutines. There's not even a mechanism in Go for libraries to intercept goroutine calls on behalf of the users to add `recover()`.

You will need to be responsible for your own panic handling in goroutines you create.

</details>


---

<a id="1104"></a>

### #1104: Context timeout is halved on client.ExecuteWorkflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1104 |
| **State** | OPEN |
| **Author** | taonic (Tao Guo) |
| **Created** | 2023-05-17 07:36:11.000 UTC (2y 7m ago) |
| **Updated** | 2023-05-17 12:00:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When a context with timeout (e.g. 4s as duration) is passed into `client.ExecuteWorkflow`, and it gets a client-side context deadline exceeded error, the method should timeout and return after the designated duration.

## Actual Behavior

Currently, the `client.ExecuteWorkflow` times out after half of the designated duration, 2s instead of 4s as an example.

Code to reproduce:

```go
	timeout := 4 * time.Second
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
â€‹
	workflowOptions := client.StartWorkflowOptions{
		ID:        workflowID,
		TaskQueue: "cancel-activity",
	}
â€‹
	then := time.Now()
	fmt.Println("ctx before execute: ", ctx)
â€‹
	we, err := c.ExecuteWorkflow(ctx, workflowOptions, cancellation.YourWorkflow)
	if err != nil {
		fmt.Println("ctx after execute: ", ctx)
		fmt.Printf("Time elapsed: %v", time.Since(then))
		log.Fatalf("Unable to execute workflow %+v\n", err)
	}
```

Output:

```
ctx before execute:  context.Background.WithDeadline(2023-05-16 22:12:16.653157 +1000 AEST m=+10.639604834 [3.999887833s])
ctx after execute:  context.Background.WithDeadline(2023-05-16 22:12:16.653157 +1000 AEST m=+10.639604834 [1.998066541s])
Time elapsed: 2.001958166s
2023/05/16 22:12:14 Unable to execute workflow context deadline exceeded
exit status 1
```

We suspect the behaviour was originally introduced as part of the dynamic retry policy for Cadence server: https://github.com/temporalio/sdk-go/commit/646d94de74a547ee7fa1c649142a9839a52d0a6e#diff-e0628cecb8a238a2d362a0ce845f7f8a8ff26d38942b471d09d7e079b5af55e7R110


## Specifications

  - Version: v1.22.2

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-05-17 12:00:48.000 UTC</summary>

To add clarification, we halve the user-provided timeout so we can retry within it, but if server is down we don't retry we get user context deadline exceeded context error (not the server-side gRPC deadline exceeded error code) so it is effectively half. Making RPC timeout half the context timeout is fine, we just need to make sure to only halve the RPC timeout not the context timeout.

</details>


---

<a id="1099"></a>

### #1099: TestWorkflowEnvironment timeouts run defer statements

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1099 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-05-04 16:23:56.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-04 19:28:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Workflows that timeout from `TestWorkflowEnvironment.SetWorkflowRunTimeout` run `deferred` statements

## Actual Behavior
Workflows that timeout from the real server do not run `defer` statements




#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-05-04 19:25:52.000 UTC</summary>

Hrmm, I don't think this is possible in Go without leaking goroutines/memory. Panic and runtime.Goexit both call `defer`. You can't exit a function without calling defer in any way that I can think of. I'd be curious to know how we do cache eviction and if we run defer then and just discard commands. Seems likely. But it may be a big effort to discard everything instead of running mocks here, unsure.

</details>


---

<a id="1097"></a>

### #1097: Stopping dev server not supported on Windows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1097 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-05-02 12:50:59.000 UTC (2y 8m ago) |
| **Updated** | 2025-02-04 18:16:04.000 UTC |
| **Closed** | 2025-02-04 18:16:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Dev server should stop on Windows, but we foolishly used signals. We should make  a `util_nonwindows.go` file with:

```go
//go:build !windows

package main

import (
	"os"
	"syscall"
)

func sendInterrupt(process *os.Process) error {
	return process.Signal(syscall.SIGINT)
}
```

And a `util_windows.go` file with:

```go
package main

import (
	"os"
	"syscall"

	"golang.org/x/sys/windows"
)

func sendInterrupt(process *os.Process) error {
	dll, err := windows.LoadDLL("kernel32.dll")
	if err != nil {
		return err
	}
	defer dll.Release()
	f, err := dll.FindProc("AttachConsole")
	if err != nil {
		return err
	}
	r1, _, err := f.Call(uintptr(process.Pid))
	if r1 == 0 && err != syscall.ERROR_ACCESS_DENIED {
		return err
	}

	f, err = dll.FindProc("SetConsoleCtrlHandler")
	if err != nil {
		return err
	}
	r1, _, err = f.Call(0, 1)
	if r1 == 0 {
		return err
	}
	f, err = dll.FindProc("GenerateConsoleCtrlEvent")
	if err != nil {
		return err
	}
	r1, _, err = f.Call(windows.CTRL_BREAK_EVENT, uintptr(process.Pid))
	if r1 == 0 {
		return err
	}
	return nil
}
```

And then just call `sendInterrupt` to close the server.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:16:02.000 UTC</summary>

https://github.com/temporalio/sdk-go/pull/1129

</details>


---

<a id="1078"></a>

### #1078: num_pollers not exposed in worker metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1078 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-04-06 17:12:47.000 UTC (2y 9m ago) |
| **Updated** | 2023-04-06 19:03:27.000 UTC |
| **Closed** | 2023-04-06 19:03:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

        NumPoller                = TemporalMetricsPrefix + "num_pollers"

This metric is for some reason not present in raw metrics produced by workers. 
To reproduce you can run to go metrics sample and see its missing: https://github.com/temporalio/samples-go/tree/main/metrics

SDK has test for it here: https://github.com/temporalio/sdk-go/blob/1b62656a17d39001201bace9a01be646663dea49/test/integration_test.go#L1869
but seems for some reason its not showing in produced worker metrics.

#### Comments (1)

<details>
<summary><strong>tsurdilo</strong> commented on 2023-04-06 19:03:26.000 UTC</summary>

I had an older version on go.temporal.io/sdk 
in my test project. after setting it to v1.21.1 metric starts being displayed.

thanks for the help @Quinn-With-Two-Ns !!

</details>


---

<a id="1075"></a>

### #1075: Verify UpdateExecutionComplete on replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1075 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-03-31 19:53:38.000 UTC (2y 9m ago) |
| **Updated** | 2023-06-10 05:06:35.000 UTC |
| **Closed** | 2023-06-10 05:06:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

 Check update workflow execution completes at the same point on replay

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-10 05:06:35.000 UTC</summary>

resolved with https://github.com/temporalio/sdk-go/commit/720dab006426a69d3e2ef0efdb1cc7cb817e3049

</details>


---

<a id="1068"></a>

### #1068: LocalActivity Tunnel not reset on stale cache lookup

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1068 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-03-23 22:55:14.000 UTC (2y 9m ago) |
| **Updated** | 2023-03-27 15:07:51.000 UTC |
| **Closed** | 2023-03-27 15:07:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
If a worker is restarted (but not the process) cached workflows should work...

## Actual Behavior
Cached workflows can no longer start local activities.

## Steps to Reproduce the Problem

  1. launch a workflow that waits on signal then starts a local activity
  2. restart the worker, but not the process
  3. signal the workflow

The workflow will now be stuck because the workflow execution was using the local activity tunnel for the worker before the restart



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-03-24 02:22:55.000 UTC</summary>

On namespace migration since the workflow context is not only holding a stale local activity channel, but the workflow task handler is also stale.

</details>


---

<a id="1057"></a>

### #1057: Double Update Accepted Event Due to Replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1057 |
| **State** | CLOSED |
| **Author** | mmcshane (Matt McShane) |
| **Created** | 2023-03-09 21:19:39.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-17 16:41:05.000 UTC |
| **Closed** | 2023-03-17 16:41:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | mmcshane |
| **Milestone** | None |

#### Description

## Expected Behavior
An update should be accepted (or rejected) exactly once

## Actual Behavior
If a workflow replays due to something like a worker crash while there is an update in-flight, we don't re-run the validator for the update but we _do_ call Accept() on the update state machine. That leads to an update.Acceptance message being sent on the WFTCompleted which is duly made durable into the history by the server.

Note that one might consider the fact that the server doesn't catch the mistake to _also_ be a bug. That will be covered with a separate issue. 

## Steps to Reproduce the Problem

There will be a test in temporalio/features for this (it's how the problem was found in the first place). The general flow is:

1. Start a workflow with separate activity and workflow workers
1. Start an update that itself launches an activity
1. Block in the activity
1. Stop or otherwise kill the workflow worker
1. Unblock the blocked activity
1. Start the workflow worker again
1. Observe that the workflow replays to rebuild state but that the incorrect extra UpdateAccepted event is added to the history. This history will not replay correctly.

## Specifications

  - Version: v1.21
  - Platform: all


#### Comments (1)

<details>
<summary><strong>mmcshane</strong> commented on 2023-03-17 16:41:05.000 UTC</summary>

Closed by #1059 

</details>


---

<a id="1045"></a>

### #1045: Memo does not go through user provided data coverter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1045 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-02-17 21:33:39.000 UTC (2y 10m ago) |
| **Updated** | 2025-10-29 21:44:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Go to use the user provided data converter like other SDKs to encode memos when creating workflow and schedules.

## Actual Behavior
https://github.com/temporalio/sdk-go/blob/0b0234f751a218e3d093e7261922dc6f9748387e/internal/internal_workflow_client.go#L1310-L1311

Go uses the default data converter. 

Need to decide how we will fix this as changing is not backwards compatible and could break running workflows

#### Comments (1)

<details>
<summary><strong>yuandrew</strong> commented on 2025-10-29 21:44:43.000 UTC</summary>

Reminder, already mentioned in the issue itself, but schedules also need to be updated

https://github.com/temporalio/sdk-go/blob/5cd20cf09a022d3cda9edef9376054df46b20021/internal/internal_schedule_client.go#L882C4-L882C70 

</details>


---

<a id="1014"></a>

### #1014: workflow.MutableSideEffect not deterministic if called multiple times with the same ID in the same WFT

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1014 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-01-28 00:16:17.000 UTC (2y 11m ago) |
| **Updated** | 2023-03-01 21:06:28.000 UTC |
| **Closed** | 2023-03-01 21:06:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description


This workflow
```
func MutableSideEffectWorkflow(ctx workflow.Context) error {
	i := 0
	encodedValue := workflow.MutableSideEffect(ctx, "id",
		func(ctx workflow.Context) interface{} { return i },
		func(a interface{}, b interface{}) bool {
			return a == b
		},
	)
	var sideEffectValue int
	err := encodedValue.Get(&sideEffectValue)
	if err != nil {
		return err
	}
	var future workflow.Future
	if sideEffectValue == 0 {
		ao := workflow.ActivityOptions{
			ScheduleToStartTimeout: time.Minute,
			StartToCloseTimeout:    time.Minute,
			HeartbeatTimeout:       time.Second * 20,
		}
		ctx = workflow.WithActivityOptions(ctx, ao)
		input := "hello"
		future = workflow.ExecuteActivity(ctx, helloworldActivity, input)
	}
	i += 1

	encodedValue = workflow.MutableSideEffect(ctx, "id",
		func(ctx workflow.Context) interface{} { return i },
		func(a interface{}, b interface{}) bool {
			return a == b
		},
	)
	err = encodedValue.Get(&sideEffectValue)
	if err != nil {
		return err
	}

	var output string
	err = future.Get(ctx, &output)
	if err != nil {
		return err
	}
	return nil
}
```
Is not deterministic because on the fist run `sideEffectValue` is equal to one 0 after the first `MutableSideEffect` and the activity starts. On replay `sideEffectValue` is equal to 1 and the activity is not launched. We don't document this [limitation](https://pkg.go.dev/go.temporal.io/sdk/workflow#MutableSideEffect) of mutable side effects and I believe it is a bug.

The problem is the Go SDK always uses the lastest value of a MutableSideEffect up to the current WFT for each ID so if `MutableSideEffect` returns a different value in the same WFT the last will be used on replay.

I found this while trying to fix workflow versioning in a loop, but @cretz also brought up this issue in his PR https://github.com/temporalio/sdk-go/pull/809

>Question: What if two mutable side effects of the same ID are run during the same WFT? We don't differentiate by command, only by user-defined marker ID.

  - Version: 1.20.0
  - Platform: Mac M1


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-01-30 04:47:11.000 UTC</summary>

Looking at it more I don't believe this can be fixed without writing new information to the history. There is not enough information to distinguish when the MSE changed value on replay because only the nextCommandID is recorded and that if almost useless to tell them apart. 

note: the fix in https://github.com/temporalio/sdk-go/pull/809 does not actually generate the commands on the correct MSE so it does not apply. It only makes the history work because we do not check payload. 

</details>


---

<a id="1012"></a>

### #1012: Tag workflowcheck

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1012 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-25 20:27:36.000 UTC (2y 11m ago) |
| **Updated** | 2023-06-28 17:53:51.000 UTC |
| **Closed** | 2023-06-28 17:53:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Create a new `contrib/tools/workflowcheck/v0.1.0` tag for a table reference point on workflow check.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-28 17:53:50.000 UTC</summary>

`workflowcheck ` is tagged as `contrib/tools/workflowcheck/v0.1.0 `

</details>


---

<a id="1000"></a>

### #1000: Panic with clear error message when workflow commands are produced in a side-effect/query function

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1000 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2023-01-09 16:22:45.000 UTC (3 years ago) |
| **Updated** | 2023-07-17 16:01:28.000 UTC |
| **Closed** | 2023-07-17 16:01:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The snippet below looks like valid code but will cause replay issues since the side effect function is not called on replay and thus not generating the StartTimer command.

```go
workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {
   return workflow.Sleep(ctx, 45 * time.Second)
})
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-06-12 13:07:49.000 UTC</summary>

We should also do this for if commands are produced in a query handler

</details>


---

<a id="996"></a>

### #996: Opt-in to having stack trace query use custom data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/996 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-05 13:16:34.000 UTC (3 years ago) |
| **Updated** | 2023-01-05 14:02:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Make a new worker option like `StackTraceQueryUsesConverter bool`. If false, the `__stack_trace` query response should not be converted/encoded/etc, but if `true` it should be. We accept that this changes today's default behavior so we need to make it loud and clear on release notes.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-01-05 14:02:55.000 UTC</summary>

We need to discuss how this affects the proxy now in api-go. Do we need to have that stop encoding this specific query?

</details>


---

<a id="994"></a>

### #994: Cannot set workflow ID for replayer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/994 |
| **State** | CLOSED |
| **Author** | Drahflow (Jens-Wolfhard Schicke-Uffmann) |
| **Created** | 2023-01-04 12:48:46.000 UTC (3 years ago) |
| **Updated** | 2023-01-05 18:02:43.000 UTC |
| **Closed** | 2023-01-05 18:02:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We have a workflow which derives various child workflow execution IDs by appending subtask names (`"-start-session"` in the example below) to the current workflow execution ID. Upon replaying those histories during CI to check for non-determinism problems, we see (re-wrapped for your convenience):
```
2023/01/04 13:33:12 ERROR Workflow panic
    WorkflowType Main
    WorkflowID ReplayId
    RunID 2bc48c60-ee48-4b19-99fb-0656c4d30a99
    Attempt 1 Error unknown command
    CommandType: ChildWorkflow, ID: merchant-consumer-workflow/ed472a6d-b793-501c-af06-a501158487b6-start-session,
    possible causes are nondeterministic workflow definition code or incompatible change in the workflow definition
    StackTrace process event for Merchant [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
        /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.19.0/internal/internal_command_state_machine.go:532
...
```
as the re-derived child workflow IDs will now (i.e. during replay) be based upon the `ReplayId` string used as the workflow execution ID here:
https://github.com/temporalio/sdk-go/blob/06e474c93e936b71dc4afcec973460b22c13986d/internal/internal_worker.go#L1235

In reality however, there is nothing non-deterministic about such a derivation, as the workflow execution ID is fixed for a given execution.

A possible solution would be to allow providing a custom execution ID (in practice derived from the recorded history filename) when replaying a history.

----

A workaround is relatively straightforward via recording the own execution ID in a side-effect, but that seems extremely unnecessary.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-01-04 14:04:28.000 UTC</summary>

Yeah workflow ID, unlike run ID, cannot currently be derived from history. Unlike our other SDKs, the Go SDK does not offer a way to set the workflow ID on the replayer. I have altered the title of this issue.

Reactions: ðŸ‘ 1

</details>


---

<a id="980"></a>

### #980: workflowcheck should allow fmt.Errorf and fmt.Sprintf and others

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/980 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-12-09 16:55:49.000 UTC (3y 1m ago) |
| **Updated** | 2023-02-14 16:46:44.000 UTC |
| **Closed** | 2023-02-14 16:46:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

These are deterministic (or at least enough so these days that they should be ignored) and should not error

## Actual Behavior

Getting errors like:

```
calls non-deterministic function fmt.Errorf
    fmt.Errorf is non-deterministic, reason: calls non-deterministic function (*fmt.pp).doPrintf
      (*fmt.pp).doPrintf is non-deterministic, reason: calls non-deterministic function (*fmt.pp).printArg
        (*fmt.pp).printArg is non-deterministic, reason: calls non-deterministic function (*fmt.pp).fmtComplex
          (*fmt.pp).fmtComplex is non-deterministic, reason: calls non-deterministic function (*fmt.pp).badVerb
            (*fmt.pp).badVerb is non-deterministic, reason: calls non-deterministic function (*fmt.pp).printValue
              (*fmt.pp).printValue is non-deterministic, reason: calls non-deterministic function (reflect.Value).Bool
                (reflect.Value).Bool is non-deterministic, reason: calls non-deterministic function (reflect.Value).panicNotBool
                  (reflect.Value).panicNotBool is non-deterministic, reason: calls non-deterministic function (reflect.flag).mustBe
                    (reflect.flag).mustBe is non-deterministic, reason: calls non-deterministic function reflect.valueMethodName
                      reflect.valueMethodName is non-deterministic, reason: calls non-deterministic function (*runtime.Frames).Next
                        (*runtime.Frames).Next is non-deterministic, reason: calls non-deterministic function runtime.expandCgoFrames
                          runtime.expandCgoFrames is non-deterministic, reason: calls non-deterministic function runtime.gostring
                            runtime.gostring is non-deterministic, reason: calls non-deterministic function runtime.rawstring
                              runtime.rawstring is non-deterministic, reason: calls non-deterministic function runtime.mallocgc
                                runtime.mallocgc is non-deterministic, reason: calls non-deterministic function runtime.gcStart
                                  runtime.gcStart is non-deterministic, reason: calls non-deterministic function runtime.gcBgMarkStartWorkers
                                    runtime.gcBgMarkStartWorkers is non-deterministic, reason: starts goroutine
              (*fmt.pp).printValue is non-deterministic, reason: calls non-deterministic function internal/fmtsort.Sort
                internal/fmtsort.Sort is non-deterministic, reason: calls non-deterministic function (reflect.Value).MapRange
                  (reflect.Value).MapRange is non-deterministic, reason: calls non-deterministic function (reflect.flag).panicNotMap
                    (reflect.flag).panicNotMap is non-deterministic, reason: calls non-deterministic function (reflect.flag).mustBe
                      (reflect.flag).mustBe is non-deterministic, reason: calls non-deterministic function reflect.valueMethodName
```

Basically many things that cross into reflection we say are non-deterministic. We should explicitly mark these deterministic. We should also consider marking some reflection things non-deterministic at the level of the function instead of having them give this big long stack.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-02-13 16:44:12.000 UTC</summary>

This appears to happen more in recent version of golang 1.19 and 1.20 and is blocking updating the golang version on some pipelines.

</details>


---

<a id="975"></a>

### #975: Missing mock invocation causes PanicError in a test but the test succeeds with exit code 0.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/975 |
| **State** | OPEN |
| **Author** | EllieSager-Forte (Ellie A Sager) |
| **Created** | 2022-12-06 00:36:01.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-06 13:18:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Invocation count assertions provided by the mocking library, such as Once() or Times(n) should always fail a test if the assertion does not hold. The same should happen if an unexpected invocation occurs during a test.

## Actual Behavior
This workflow has only one activity that is non-retry-able. Under test, it throws a PanicError in the logs when the code is executed and mock invocation is missing. Yet the test always succeeds with exit code 0.

```
err := workflow.ExecuteActivity(
  workflow.WithActivityOptions(ctx, workflow.ActivityOptions 
  {RetryPolicy: &temporal.RetryPolicy{MaximumAttempts: 1}}), 
  MyActivity).Get(ctx, nil) // what if we forget to mock "MyActivity" method??
  	if err != nil { log.Error("error in workflow, don't interrupt workflow!", "some message", err.Error()) }
```

A test for the workflow should mock the activity to be invoked at least once, but a developer has forgotten to add the mock. Here is a line you might expect in a test, that is missing:`env.OnActivity("MyActivity", any).Return(nil, errors.New("test failure")).Once()`
This activity is configured with NO retries and even though logs correctly print a panic statement,  no error is returned and the test succeeds. Since workflow is set up to continue after the error, we end up with a workflow that succeeds and has no errors. So, [the method outlined here](https://github.com/temporalio/sdk-go/issues/642#issuecomment-1204102286): "check no error happened inside the workflow by checking the workflow error" - `s.assertions.NoError(s.env.GetWorkflowError())` - won't work.

One might argue that since we don't care if the activity fails inside our workflow, the workflow will always succeed and, therefore, the tests with the activity failing should be always marked as "PASSED". However, there is a difference between an activity failing in prod for a legitimate reason and activity failing due to a forgotten mock invocation. We definitely want to know about missing or incorrect mocks in our tests! Since your guys's code already detects discrepancies in mock calls, why don't we just mark the test as FAILED in this case?

OR, alternatively, you can expose the `env.mock` field as suggested here: https://github.com/temporalio/sdk-go/issues/642#issuecomment-1203779650 or provide a setter for it.

This issue is being opened based on this conversation: https://temporalio.slack.com/archives/CTDTU3J4T/p1669935765304739 (long) and
https://temporalio.slack.com/archives/CTDTU3J4T/p1669935765304739 (short)

## Steps to Reproduce the Problem
See above

## Specifications

  - Version: temporal sdk@v1.16.0/testify@v1.8.0
  - Platform: n/a


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-12-06 13:14:46.000 UTC</summary>

> One might argue that since we don't care if the activity fails inside our workflow, the workflow will always succeed and, therefore, the tests with the activity failing should be always marked as "PASSED". However, there is a difference between an activity failing in prod for a legitimate reason and activity failing due to a forgotten mock invocation. We definitely want to know about missing or incorrect mocks in our tests! Since your guys's code already detects discrepancies in mock calls, why don't we just mark the test as FAILED in this case?

Do you definitely want to know about missing or incorrect activities in production? The test is acting like production. If your workflow is built to not care about missing activities, it won't care about missing activities regardless of environment (or any other error).

If someone wants to test a missing activity behavior they can. It is important that our test environment fail similar to how production fails when you are missing an activity.

Your workflow is written to run regardless of that activity, so one could argue there's no benefit to mocking it since your workflow doesn't care if it even ran. You'll never know whether you remember to even register that activity in production.

</details>


---

<a id="970"></a>

### #970: Search attributes and memos are kept from previous runs when resetting workflow context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/970 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-12-01 16:04:37.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-07 00:12:12.000 UTC |
| **Closed** | 2022-12-07 00:12:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

## Expected Behavior

When a workflow's context is reset due to cache staleness, all mutable aspects should be reset to original values

## Actual Behavior

When a workflow's context is reset due to cache staleness, the mutated search attribute map remains (and I presume memo too)

## Steps to Reproduce the Problem

This sample program will cause a non-determinism error due to cache reset not working right. (there is another issue concerning workers sharing cache that I may open another issue for)

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Printf("Creating client")
	c, err := client.NewClient(client.Options{})
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	log.Printf("Starting worker1")
	taskQueue := uuid.NewString()
	worker1 := worker.New(c, taskQueue, worker.Options{})
	worker1.RegisterWorkflow(MyWorkflow)
	if err := worker1.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}

	log.Printf("Starting workflow")
	run, err := c.ExecuteWorkflow(ctx, client.StartWorkflowOptions{TaskQueue: taskQueue}, MyWorkflow)
	if err != nil {
		return fmt.Errorf("failed starting workflow: %w", err)
	}

	log.Printf("Sending signal in 2 seconds")
	time.Sleep(2 * time.Second)
	if err := c.SignalWorkflow(ctx, run.GetID(), run.GetRunID(), "tick", nil); err != nil {
		return err
	}

	log.Printf("Stopping worker1 and starting worker2")
	worker1.Stop()
	worker2 := worker.New(c, taskQueue, worker.Options{})
	worker2.RegisterWorkflow(MyWorkflow)
	if err := worker2.Start(); err != nil {
		return fmt.Errorf("failed starting worker client: %w", err)
	}
	defer worker2.Stop()

	log.Printf("Sending signal in 2 seconds, then ending program in 10")
	time.Sleep(2 * time.Second)
	if err := c.SignalWorkflow(ctx, run.GetID(), run.GetRunID(), "tick", nil); err != nil {
		return err
	}
	time.Sleep(10 * time.Second)
	return nil
}

func MyWorkflow(ctx workflow.Context) error {
	// Do one thing is a search attribute is there or add it if not
	_, exists := workflow.GetInfo(ctx).SearchAttributes.GetIndexedFields()["CustomTextField"]
	log.Printf("Search attribute exists? %v. Replaying? %v.", exists, workflow.IsReplaying(ctx))
	var err error
	if exists {
		err = workflow.Sleep(ctx, 100*time.Millisecond)
	} else {
		err = workflow.UpsertSearchAttributes(ctx, map[string]interface{}{"CustomTextField": "some value"})
	}
	if err != nil {
		return err
	}

	// Now just wait for signals over and over
	signalCh := workflow.GetSignalChannel(ctx, "tick")
	for {
		signalCh.Receive(ctx, nil)
		log.Printf("Signal received (replaying? %v)", workflow.IsReplaying(ctx))
	}
}
```

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-12-01 16:48:12.000 UTC</summary>

Can confirm `Memo` also has the same issue as `SearchAttributes`

</details>


---

<a id="968"></a>

### #968: Remove deprecated metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/968 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2022-11-29 01:13:37.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-29 14:46:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Remove deprecated metrics `local_activity_canceled` and `local_activity_failed` at some point in the future. They have been replaced by `local_activity_execution_failed ` and  `local_activity_execution_canceled`


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-11-29 14:46:23.000 UTC</summary>

I wouldn't expect this to ever happen to be honest. The cost of duplicate metrics is much much lower than the cost of removing them. This would be a silent removal, i.e. that there would be no compiler error to fix.

These types of removals are mostly unreasonable unless a reason beyond normal deprecation principles is provided. We haven't broken people's metric output in years and we should not for this case.

</details>


---

<a id="967"></a>

### #967: testsuite.TestWorkflowEnvironment does not complete workflows synchronously when activities create new environments to start nested workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/967 |
| **State** | OPEN |
| **Author** | subhan-nadeem (Subhan Nadeem) |
| **Created** | 2022-11-28 16:56:25.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-29 18:20:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When executing a workflow with `testsuite.TestWorkflowEnvironment` that has two activities, which each start an additional workflow on a newly instantiated `testsuite.TestWorkflowEnvironment`, I expect the nested internal workflows to complete synchronously before the outer workflow completes synchronously as well.

## Actual Behavior

One of the nested test workflows that is started by an activity on a new `testsuite.TestWorkflowEnvironment` exits its `ExecuteWorkflow` call before `testEnvironment.WorkflowIsCompleted()` returns true. If I write `for !testEnvironment.WorkflowIsCompleted() { }` to block the main thread until the workflow completes, eventually `testEnvironment.WorkflowIsCompleted()` evaluates to true, indicating that the workflow is operating in a separate goroutine after `ExecuteWorkflow` returns.

## Steps to Reproduce the Problem

The below sample workflow is an approximation of what my code does: a workflow that fires off two activities; each activity starts another workflow by instantiating a new `testsuite.TestWorkflowEnvironment` and executed another workflow. 

Unfortunately, the sample workflow does not seem to reproduce the buggy behaviour and I'm unable to paste my full source code. [Here](https://temporalio.slack.com/archives/CTRCR8RBP/p1668449589481079) is the Slack thread that initially raised the issue

```
func MyWorkflow(
	ctx workflow.Context,
	stop bool,
) error {
	if stop {
		return nil
	}

	var futures []workflow.Future
	for i := 0; i < 2; i++ {
		future := workflow.ExecuteActivity(
			workflow.WithActivityOptions(ctx, workflow.ActivityOptions{StartToCloseTimeout: 1 * time.Minute}),
			ATestActivity,
		)
		futures = append(futures, future)
	}
	for _, f := range futures {
		if err := f.Get(ctx, nil); err != nil {
			return err
		}
	}

	return nil
}


func ATestActivity(ctx context.Context) error {
	t := testsuite.WorkflowTestSuite{}
	env := t.NewTestWorkflowEnvironment()
	env.RegisterActivity(s.SleepActivity)
	env.ExecuteWorkflow(MyWorkflow, true)

	randomID := uuid.NewUUID().String()
	for !env.IsWorkflowCompleted() {
		fmt.Println("WORKFLOW NOT COMPLETED " + randomID)
	}

	fmt.Println("WORKFLOW COMPLETED " + randomID)

	return nil
}

func (s *TestSuite) TestMyWorkflow() {
	t := testsuite.WorkflowTestSuite{}
	env := t.NewTestWorkflowEnvironment()
	env.RegisterActivity(ATestActivity)

	env.ExecuteWorkflow(MyWorkflow, false)
	s.NoError(env.GetWorkflowError())
}
```

## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-11-28 17:20:37.000 UTC</summary>

> Unfortunately, the sample workflow does not seem to reproduce the buggy behaviour and I'm unable to paste my full source code.

Is there any code to reproduce? Can you continually reduce your source that you cannot paste until it is something you can paste while also replicating the error?

> [Here](https://temporalio.slack.com/archives/CTRCR8RBP/p1668449589481079) is the Slack thread that initially raised the issue

Note, our public Slack threads are regularly culled so this link may not be valid in the future (but no need, I think you have the gist here).

</details>


---

<a id="958"></a>

### #958: Confusing interface match for client.ScheduleWorkflowAction

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/958 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-11-15 15:02:16.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-15 23:24:25.000 UTC |
| **Closed** | 2022-11-15 23:24:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

In Go, a receiver that is a non-pointer matches pointer and non-pointer. Therefore most interfaces that are used like sum types, like our `ScheduleAction`, expect the concrete types to be pointers so the developer cannot have both pointer and non-pointer options.

Today, `ScheduleAction` can be set to `ScheduleWorkflowAction` _or_ `*ScheduleWorkflowAction`, but the latter fails at runtime. I think maybe we should always _require_ `*ScheduleWorkflowAction` by changing receiver to `func (*ScheduleWorkflowAction) isScheduleAction()`.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2022-11-15 23:24:25.000 UTC</summary>

closed in https://github.com/temporalio/sdk-go/pull/959

</details>


---

<a id="947"></a>

### #947: Panic: Error adding duplicate command on duplicated child workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/947 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-11-06 19:21:15.000 UTC (3y 2m ago) |
| **Updated** | 2023-01-06 03:12:39.000 UTC |
| **Closed** | 2023-01-06 03:12:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior
An attempt to start a child workflow with the same ID as the one already running should result in `ChildWorkflowExecutionAlreadyStartedError`.

## Actual Behavior
```
2022/11/06 11:12:07 ERROR Workflow panic Namespace default TaskQueue child-workflow WorkerID 8968@Maxims-MacBook-Pro.local@ WorkflowType SampleParentWorkflow WorkflowID parent-workflow_ed5bbdc7-183d-43b7-936a-d2a9e4d9bd2f RunID b4a73c0b-a1d3-4ef9-ab29-8bfd34b4138d Attempt 1 Error adding duplicate command CommandType: ChildWorkflow, ID: ABC-SIMPLE-CHILD-WORKFLOW-ID, state=Created, isDone()=false, history=[Created] StackTrace coroutine root [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/internal_command_state_machine.go:502
go.temporal.io/sdk/internal.(*commandsHelper).addCommand(0x14000554230, {0x1016656f0, 0x140000a3290})
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/internal_command_state_machine.go:998 +0x2f8
go.temporal.io/sdk/internal.(*commandsHelper).startChildWorkflowExecution(0x41b8?, 0x102180668?)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/internal_command_state_machine.go:1228 +0x38
go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).ExecuteChildWorkflow(_, {{{0x140001b21e0, 0xe}, 0x0, 0x0, 0x0, {0x1013796f7, 0x7}, {0x10138d56c, 0x1c}, ...}, ...}, ...)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/internal_event_handlers.go:476 +0x3b0
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteChildWorkflow(0x140005506c0?, {0x10165fff8?, 0x1400017e000}, {0x1017c363a, 0x13}, {0x140000a3200, 0x1, 0x1})
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/workflow.go:903 +0x6b8
go.temporal.io/sdk/internal.ExecuteChildWorkflow({0x10165fff8, 0x140005506c0}, {0x101548ca0, 0x101651d80}, {0x140000a3200, 0x1, 0x1})
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/workflow.go:851 +0x188
go.temporal.io/sdk/workflow.ExecuteChildWorkflow(...)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/workflow/workflow.go:181
github.com/temporalio/samples-go/child-workflow.SampleParentWorkflow({0x10165fff8, 0x14000550690})
        /Users/maxim/temporal/temporal-go-samples/child-workflow/parent_workflow.go:25 +0x164
reflect.Value.call({0x101539b00?, 0x101651d88?, 0x102000f18?}, {0x101376901, 0x4}, {0x1400000fb48, 0x1, 0x5?})
        /opt/homebrew/Cellar/go/1.19.2/libexec/src/reflect/value.go:584 +0x688
reflect.Value.Call({0x101539b00?, 0x101651d88?, 0x5000?}, {0x1400000fb48?, 0x1400044bcf8?, 0x10134ce50?})
        /opt/homebrew/Cellar/go/1.19.2/libexec/src/reflect/value.go:368 +0x90
go.temporal.io/sdk/internal.executeFunction({0x101539b00, 0x101651d88}, {0x1400044bde8, 0x1, 0x14000090000?})
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/internal_worker.go:1651 +0x140
go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow(0x14000554280, {0x10165fea8?, 0x14000109d40}, 0x1400000fb30)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/workflow.go:504 +0x14c
go.temporal.io/sdk/internal.(*workflowExecutor).Execute(0x14000113300, {0x10165fea8, 0x14000109d40}, 0x25?)
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/internal_worker.go:771 +0x238
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1({0x10165fff8, 0x14000550570})
        /Users/maxim/go/pkg/mod/go.temporal.io/sdk@v1.17.0/internal/internal_workflow.go:553 +0xd0
```

## Steps to Reproduce the Problem
[Modified child_worklfow sample](https://github.com/temporalio/samples-go/compare/main...mfateev:duplicated_child?expand=1):
```go
func SampleParentWorkflow(ctx workflow.Context) (string, error) {
	logger := workflow.GetLogger(ctx)

	cwo := workflow.ChildWorkflowOptions{
		WorkflowID: "ABC-SIMPLE-CHILD-WORKFLOW-ID",
	}
	ctx = workflow.WithChildOptions(ctx, cwo)

	var result string
	child1 := workflow.ExecuteChildWorkflow(ctx, SampleChildWorkflow, "World")

	workflow.Sleep(ctx, 10*time.Second)
	err := workflow.ExecuteChildWorkflow(ctx, SampleChildWorkflow, "World").Get(ctx, &result)
	if err != nil {
		logger.Error("Parent execution received second child execution failure.", "Error", err)
		return "", err
	}
	err = child1.Get(ctx, &result)
	if err != nil {
		logger.Error("Parent execution received child execution failure.", "Error", err)
		return "", err
	}

	logger.Info("Parent execution completed.", "Result", result)
	return result, nil
}

func SampleChildWorkflow(ctx workflow.Context, name string) (string, error) {
	logger := workflow.GetLogger(ctx)
	greeting := "Hello " + name + "!"
	logger.Info("Child workflow execution: " + greeting)
	workflow.Sleep(ctx, 15*time.Second)
	return greeting, nil
}
```

## Specifications

  - Version:         go.temporal.io/sdk v1.17.0


#### Comments (1)

<details>
<summary><strong>bohlander</strong> commented on 2022-11-07 17:49:18.000 UTC</summary>

We have seen this same panic even when the 1st child workflow has exited before the 2nd one is started. 

We have some long running (~40 day) workflows that have a timer that runs daily.  These have been stable for 6+ months, but last night we had a significant amount of them fail with: `adding duplicate command CommandType: ChildWorkflow, ID: <snip>, state=Created, isDone()=false, history=[Created]","Namespace":"default","RunID":"10c62aba-5487-4a5f-b1c1-93badbdb5ee8","StackTrace":<snip> `. This occurs when the workflow with the timer is attempting to start a child workflow. 

<img width="1230" alt="Screen Shot 2022-11-06 at 10 41 06 AM" src="https://user-images.githubusercontent.com/470585/200379335-e129b5c3-0244-4595-afe4-f9417363d836.png">
<img width="1257" alt="Screen Shot 2022-11-06 at 10 40 40 AM" src="https://user-images.githubusercontent.com/470585/200379357-e4798b23-db8c-4953-b545-93b71fb5916f.png">

You can see it finished the childworkflow with same id finished at 11/5/22 7:21:31.  Then the duplicate command failure occurs ~24 hrs later at 11/6/22 7:20:52 (the temporal web UI screenshot is in PST whereas the logs are in UTC)

</details>


---

<a id="939"></a>

### #939: Nightly CI against server `master`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/939 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-10-28 00:14:34.000 UTC (3y 2m ago) |
| **Updated** | 2022-10-28 00:25:46.000 UTC |
| **Closed** | 2022-10-28 00:25:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | bergundy |
| **Milestone** | None |

#### Description

In order to catch SDK-server incompatibilities ASAP, we should test integration of the latest version of these components.

#### Comments (1)

<details>
<summary><strong>bergundy</strong> commented on 2022-10-28 00:25:46.000 UTC</summary>

We'll test in sdk-features instead: https://github.com/temporalio/sdk-features/issues/150

</details>


---

<a id="935"></a>

### #935: Testing: Be Able to Unit Test a Workflow with a Populated `ContinuedExecutionRunID`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/935 |
| **State** | OPEN |
| **Author** | Albert-Coding (Albert) |
| **Created** | 2022-10-14 00:10:07.000 UTC (3y 2m ago) |
| **Updated** | 2022-10-14 12:11:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to test my workflow when it has a populated `workflow.GetInfo(ctx).ContinuedExecutionRunID`.  Currently, one cannot do that so not all workflow paths may be unit tested.

**Describe the solution you'd like**
Ideally, I would like a way to set a workflow's context during its unit test execution.

**Describe alternatives you've considered**
One could do something elaborate for testing purposes.  Maybe have a variable or a dependency injection so the unit test can pretend to see a value for `ContinuedExecutionRunID`.

**Additional context**
https://community.temporal.io/t/testing-continueasnew/6211/6

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-10-14 12:11:26.000 UTC</summary>

Hrmm, there are several other things on workflow info one might want to set as well. _Technically_ the workflow info is mutable in the test suite so we could expose the mutable pointer via `TestWorkflowEnvironment.WorkflowInfo()` or similar. I think this will work best.

</details>


---

<a id="930"></a>

### #930: Support failure encoding in proxy gRPC interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/930 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-10-11 14:57:56.000 UTC (3y 3m ago) |
| **Updated** | 2023-01-11 15:47:03.000 UTC |
| **Closed** | 2023-01-11 15:47:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

In #924 we added support to optionally move message and stack trace into encoded attributes. We need to support this for proxies too.

**Describe the solution you'd like**

Probably best to alter https://github.com/temporalio/sdk-go/blob/master/internal/cmd/generateinterceptor/main.go to add `EncodeCommonAttributes bool` to `PayloadCodecGRPCClientInterceptorOptions` and, if `true`, move the message and stack trace to the encoded attributes pre-encode (and back out post-decode). This will allow proxies using this interceptor to support encoded failure attributes transparently via the interceptor in the way that's understandable in the UI.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-01-11 15:47:00.000 UTC</summary>

This was done as `converter.NewFailureGRPCClientInterceptor` in #974 

</details>


---

<a id="922"></a>

### #922: TestWorkflowEnvironment.SignalExternalWorkflow data race on signal data

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/922 |
| **State** | OPEN |
| **Author** | Drahflow (Jens-Wolfhard Schicke-Uffmann) |
| **Created** | 2022-09-28 14:02:43.000 UTC (3y 3m ago) |
| **Updated** | 2022-09-28 14:11:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Testing a workflow which signals external workflows should work, even if the signal data is modified later in the workflow.

## Actual Behavior

It does not (reliably), specifically data-races such as this can be observed (occasionally):

```
==================
WARNING: DATA RACE
Read at 0x00c000515190 by goroutine 113:
  reflect.typedmemmove()
      /usr/lib/go-1.19/src/runtime/mbarrier.go:178 +0x0
[...]
  github.com/stretchr/testify/mock.Arguments.Diff()
      /home/drahflow/go/pkg/mod/github.com/stretchr/testify@v1.8.0/mock/mock.go:883 +0x18e
  github.com/stretchr/testify/mock.(*Mock).findExpectedCall()
      /home/drahflow/go/pkg/mod/github.com/stretchr/testify@v1.8.0/mock/mock.go:355 +0x146
  github.com/stretchr/testify/mock.(*Mock).MethodCalled()
      /home/drahflow/go/pkg/mod/github.com/stretchr/testify@v1.8.0/mock/mock.go:460 +0xb9
  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).SignalExternalWorkflow.func2()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow_testsuite.go:2118 +0x329

Previous write at 0x00c000515190 by goroutine 97:
  github.com/payrails/demo/pkg/merchant/workflows/consumer_checkout.cancelPaymentMethods.func1.2()
      /work/pkg/merchant/workflows/consumer_checkout/main.go:829 +0xfc
[...]

Goroutine 113 (running) created at:
  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).SignalExternalWorkflow()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow_testsuite.go:2115 +0x396
  go.temporal.io/sdk/internal.signalExternalWorkflow()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/workflow.go:1077 +0x46e
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).SignalExternalWorkflow()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/workflow.go:1040 +0xc4
  go.temporal.io/sdk/internal.SignalExternalWorkflow()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/workflow.go:1035 +0x20d
  go.temporal.io/sdk/workflow.SignalExternalWorkflow()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/workflow/workflow.go:221 +0x171
  github.com/payrails/demo/pkg/merchant/workflows/consumer_checkout.(*Channel[...]).Reply()
      /work/pkg/merchant/workflows/consumer_checkout/channels.go:91 +0x66
  github.com/payrails/demo/pkg/merchant/workflows/consumer_checkout.waitForFinalize.func1()
      /work/pkg/merchant/workflows/consumer_checkout/main.go:725 +0x271
  github.com/payrails/demo/pkg/merchant/workflows/consumer_checkout.(*Channel[...]).OnSignal.func1()
      /work/pkg/merchant/workflows/consumer_checkout/channels.go:57 +0x11a
  go.temporal.io/sdk/internal.(*selectorImpl).Select.func2.1()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow.go:1158 +0xa1
  go.temporal.io/sdk/internal.(*selectorImpl).Select()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow.go:1253 +0x120d
[...]

Goroutine 97 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow.go:981 +0x65a
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow.go:299 +0x86
  go.temporal.io/sdk/internal.newDispatcher()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow.go:598 +0x282
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow.go:488 +0x1c4
  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal.func1()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow_testsuite.go:486 +0xc2
  go.temporal.io/sdk/internal.(*testCallbackHandle).processCallback()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow_testsuite.go:732 +0xfb
  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).startMainLoop()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow_testsuite.go:672 +0x2a4
  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflowInternal()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow_testsuite.go:508 +0x4f1
  go.temporal.io/sdk/internal.(*testWorkflowEnvironmentImpl).executeWorkflow()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/internal_workflow_testsuite.go:452 +0x1cc
  go.temporal.io/sdk/internal.(*TestWorkflowEnvironment).ExecuteWorkflow()
      /home/drahflow/go/pkg/mod/go.temporal.io/sdk@v1.15.0/internal/workflow_testsuite.go:516 +0xf84
[...]
==================
```
[Edited for brevity and NDAs].

The code for the conflicting write at
`/work/pkg/merchant/workflows/consumer_checkout/main.go:829 +0xfc`
is a standard member-access to a struct which was sent as part of the signal payload. This works on real execution, as the signal data is serialized and sent before the workflow processing continues (as far as I can see), but in `TestWorkflowEnvironment.SignalExternalWorkflow`, a new go-routine is spawned, which tries to look up the correct mock of the signal receiver _concurrently_ with the rest of the workflow proceeding (and modifying the data of the signal currently being processed): https://github.com/temporalio/sdk-go/blob/754b253bb196d69c64317af1ed28fa85a74d584d/internal/internal_workflow_testsuite.go#L2068

## Steps to Reproduce the Problem

  1. Make workflow which sends signal to other workflow and immediately proceeds to modify member fields of the signal payload
  1. Build a workflow test and mock the signal receiver
  1. Run the workflow test very often with `go test -race`

## Specifications

  - Version: go.temporal.io/sdk v1.15.0
  - Platform: linux, x86_64, go version go1.19.1 linux/amd64

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-09-28 14:11:34.000 UTC</summary>

Thanks! This is similar to #908. Some of the test environment was not developed in a concurrency safe way. We will fix.

</details>


---

<a id="912"></a>

### #912: Change default Prometheus santitize options to not change values

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/912 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-15 18:42:12.000 UTC (3y 3m ago) |
| **Updated** | 2022-09-15 18:45:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

The options at https://github.com/temporalio/sdk-go/blob/c1ce1d25238b7bb15095f0767497fa93215c2589/contrib/tally/prometheus.go#L31-L38 which are based on the sample at https://github.com/temporalio/samples-go/blob/65d2450b15f920d4f28ead7ece62e15be0ddb810/metrics/worker/main.go#L65-L87 are altering label values which is not good

**Describe the solution you'd like**

Stop altering label values

#### Comments (1)

<details>
<summary><strong>wyattanderson</strong> commented on 2022-09-15 18:45:24.000 UTC</summary>

Thanks! This surfaced for us because we're naming workflows and activities according to fully qualified Protobuf names, so we have things like `company.domain.Workflow`, which was turned into `company_domain_Workflow` when emitted as a metric label value.

I think it might be sufficient to change the `Characters` option to something like `tally.UnderscoreDashDotCharacters` (which is what I've done locally for now), or maybe even additionally including `/`, which I could see people using in a workflow or activity name (assuming that's valid).

</details>


---

<a id="901"></a>

### #901: Tag new releases for contrib/opentracing and contrib/opentelemetry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/901 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-31 21:00:13.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-01 17:06:09.000 UTC |
| **Closed** | 2022-09-01 17:06:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Need new tags for new features

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-09-01 17:06:09.000 UTC</summary>

Done

</details>


---

<a id="898"></a>

### #898: golang.org/x/tools-v0.1.10: 3 vulnerabilities (highest severity is: 6.1) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/898 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-08-30 17:58:24.000 UTC (3y 4m ago) |
| **Updated** | 2022-11-03 13:49:12.000 UTC |
| **Closed** | 2022-11-03 13:49:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>golang.org/x/tools-v0.1.10</b></p></summary>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip</a></p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (golang.org/x/tools-v0.1.10 version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2020-11022](https://www.mend.io/vulnerability-database/CVE-2020-11022) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | golang.org/x/tools-v0.1.10 | Direct | jQuery - 3.5.0 | &#10060; |
| [CVE-2015-9251](https://www.mend.io/vulnerability-database/CVE-2015-9251) | <img src='https://whitesource-resources.whitesourcesoftware.com/low_vul.png' width=19 height=20> Low | 3.7 | golang.org/x/tools-v0.1.10 | Direct | jQuery - 3.0.0 | &#10060; |
| [CVE-2012-6708](https://www.mend.io/vulnerability-database/CVE-2012-6708) | <img src='https://whitesource-resources.whitesourcesoftware.com/low_vul.png' width=19 height=20> Low | 3.7 | golang.org/x/tools-v0.1.10 | Direct | jQuery - v1.9.0 | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2020-11022</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.10</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.10** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In jQuery versions greater than or equal to 1.2 and before 3.5.0, passing HTML from untrusted sources - even after sanitizing it - to one of jQuery's DOM manipulation methods (i.e. .html(), .append(), and others) may execute untrusted code. This problem is patched in jQuery 3.5.0.

<p>Publish Date: 2020-04-29
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2020-11022>CVE-2020-11022</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11022">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11022</a></p>
<p>Release Date: 2020-04-29</p>
<p>Fix Resolution: jQuery - 3.5.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/low_vul.png' width=19 height=20> CVE-2015-9251</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.10</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.10** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 3.0.0 is vulnerable to Cross-site Scripting (XSS) attacks when a cross-domain Ajax request is performed without the dataType option, causing text/javascript responses to be executed.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2015-9251>CVE-2015-9251</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>3.7</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: High
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2015-9251">https://nvd.nist.gov/vuln/detail/CVE-2015-9251</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - 3.0.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/low_vul.png' width=19 height=20> CVE-2012-6708</summary>


###  Vulnerable Library - <b>golang.org/x/tools-v0.1.10</b></p>

<p></p>
<p>Library home page: <a href="https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip">https://proxy.golang.org/golang.org/x/tools/@v/v0.1.10.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **golang.org/x/tools-v0.1.10** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/b5942aefecb0379859bab42b44fa267ca8f3f8d8">b5942aefecb0379859bab42b44fa267ca8f3f8d8</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 1.9.0 is vulnerable to Cross-site Scripting (XSS) attacks. The jQuery(strInput) function does not differentiate selectors from HTML in a reliable fashion. In vulnerable versions, jQuery determined whether the input was HTML by looking for the '<' character anywhere in the string, giving attackers more flexibility when attempting to construct a malicious payload. In fixed versions, jQuery only deems the input to be HTML if it explicitly starts with the '<' character, limiting exploitability only to attackers who can control the beginning of a string, which is far less common.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2012-6708>CVE-2012-6708</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>3.7</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: High
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-6708">https://nvd.nist.gov/vuln/detail/CVE-2012-6708</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - v1.9.0</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-11-03 13:49:12.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="891"></a>

### #891: New Tally contrib lib release

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/891 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-25 19:56:37.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-29 19:48:50.000 UTC |
| **Closed** | 2022-08-29 19:48:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Need #756 in a tagged Tally contrib library release

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-08-29 19:48:47.000 UTC</summary>

There is now a tag for `contrib/tally/v0.2.0`

</details>


---

<a id="886"></a>

### #886: independent lifecycles for cloned clients

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/886 |
| **State** | CLOSED |
| **Author** | dnr (David Reiss) |
| **Created** | 2022-08-19 22:55:04.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-01 17:54:57.000 UTC |
| **Closed** | 2022-09-01 17:54:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When using `NewClientFromExisting` from #881, the "parent" and "child" `Client`s have independent lifecycles from the point of view of client code, even though they share some resources. That is, I can call `Close` on only one or both of them, and resources will be cleaned up when appropriate.

This makes it easier to use in large programs since we don't have to essentially ban use of `Close`, we can let anyone who gets a cloned client treat it as if it were a fully-independent one.

## Actual Behavior

Calling `Close()` on either the parent or child will close the connection for both of them immediately.

## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version: unreleased post 1.16
  - Platform:


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-08-25 05:15:40.000 UTC</summary>

:+1: We need to make it very clear in Godoc on `Close()` that it sometimes doesn't close the connection and that one reused connection left open will forever leave the connection open for everyone.

</details>


---

<a id="876"></a>

### #876: Completed workflow not properly checking command/event mismatch for non-determinism

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/876 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-03 13:14:52.000 UTC (3y 5m ago) |
| **Updated** | 2023-05-24 08:40:10.000 UTC |
| **Closed** | 2023-05-24 08:40:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior

Running a completed workflow through the replayer with a workflow with the activities in a different order should fail as nondeterministic due to command/event mismatch.

## Actual Behavior

This is not occurring because of the `!w.isWorkflowCompleted` conditional at https://github.com/temporalio/sdk-go/blob/38b2b69f18bdc3bcaf1b4e48f940d1c60b5f9253/internal/internal_task_handlers.go#L946

Will investigate how to make sure we re-enable determinism checks on completed workflows without: 1) causing any issues with what that conditional was trying to protect against (which I believe is premature workflow completion due to panic error), and 2) causing any issues with people's running code today.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-11-18 17:53:32.000 UTC</summary>

This also surfaces when a history doesn't necessarily have completion events but there are no steps after the last replay before `return` from the workflow.

</details>


---

<a id="864"></a>

### #864: Make possible non-deterministic errors clear that's what they may be

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/864 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-07-21 17:10:14.000 UTC (3y 5m ago) |
| **Updated** | 2023-11-29 15:03:11.000 UTC |
| **Closed** | 2023-11-29 15:03:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Of the three errors at https://community.temporal.io/t/go-sdk-troubleshooting/4440#workflow-non-determinism-5, only one mentions non-determinism.
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**

Prepend `"nondeterministic workflow: "` to the other two.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 15:03:10.000 UTC</summary>

closing in favor of https://github.com/temporalio/sdk-go/pull/1281

</details>


---

<a id="861"></a>

### #861: Support creating new client from existing client's connection

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/861 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-07-21 12:31:30.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-16 11:54:14.000 UTC |
| **Closed** | 2022-08-10 12:58:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

People need to create a client from an existing connection but just change the non-connection options

**Describe the solution you'd like**

Options:

* Accept something a `WorkflowService` in client options which means all connection options are ignored (this same will have to be done for operator service if/when we get there)
* Accept a grpc.ClientConn in client options which means all connection options are ignored. We'd also have to expose this connection from the client somehow (really hoping not to add a new interface method)
* Make a `Clone(existingClient Client, newOptions Options) (Client, error)` call

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-07-21 14:01:51.000 UTC</summary>

There is a bit of a problem here. We use gRPC interceptors, which are only done at dial time, to put the namespace on the following all client methods (i.e. `temporal[_long]_request[_latency|_failure][_attempt]`). We set this as a fixed value.

I could technically extract this from most operation requests, but what do I do with the calls that don't have namespace? The only client interface call this would apply to is health check, but technically there are some direct-to-gRPC calls they can make. Today they are given a `namespace` tag in the metrics. For those rare calls, I can either:

1. Set the namespace tag on those calls to `"<unknown>"` or `""` or something, but now I've just changed people's metrics
2. Leave the namespace as the original client's namespace, which means a health check call from the new client will have the old client's namespace

Thoughts?

</details>


---

<a id="854"></a>

### #854: num_pollers metric

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/854 |
| **State** | CLOSED |
| **Author** | robholland (Rob Holland) |
| **Created** | 2022-07-15 16:37:19.000 UTC (3y 5m ago) |
| **Updated** | 2022-11-28 19:33:13.000 UTC |
| **Closed** | 2022-11-28 19:33:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
There is no clear way to tell how many pollers were active at any given time when tuning a cluster or doing an outage post mortem.

**Describe the solution you'd like**
Please implement the num_pollers metric for the Go SDK: https://docs.temporal.io/references/sdk-metrics/#num_pollers


#### Comments (1)

<details>
<summary><strong>yiminc</strong> commented on 2022-11-17 00:24:58.000 UTC</summary>

Need to be able to tell how many activity pollers and how many workflow pollers. 

</details>


---

<a id="853"></a>

### #853: github.com/stretchr/testify-v1.8.0: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/853 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-07-13 21:01:44.000 UTC (3y 6m ago) |
| **Updated** | 2022-08-01 13:23:36.000 UTC |
| **Closed** | 2022-08-01 13:23:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>github.com/stretchr/testify-v1.8.0</b></p></summary>

<p></p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/de63fea375d5f1a6fcf77677f8b4624d50a0c761">de63fea375d5f1a6fcf77677f8b4624d50a0c761</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-28948](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | github.com/stretchr/objx-v0.4.0 | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-28948</summary>


###  Vulnerable Library - <b>github.com/stretchr/objx-v0.4.0</b></p>

<p>Go package for dealing with maps, slices, JSON and other data.</p>
<p>

Dependency Hierarchy:
  - github.com/stretchr/testify-v1.8.0 (Root Library)
    - :x: **github.com/stretchr/objx-v0.4.0** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/de63fea375d5f1a6fcf77677f8b4624d50a0c761">de63fea375d5f1a6fcf77677f8b4624d50a0c761</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.

<p>Publish Date: 2022-05-19
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948>CVE-2022-28948</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://security-tracker.debian.org/tracker/CVE-2022-28948">https://security-tracker.debian.org/tracker/CVE-2022-28948</a></p>
<p>Release Date: 2022-05-19</p>
<p>Fix Resolution: v3.0.0</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-08-01 13:23:36.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="846"></a>

### #846: URL in metrics API 404s

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/846 |
| **State** | CLOSED |
| **Author** | rachfop (Patrick Rachford) |
| **Created** | 2022-07-05 17:43:38.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-05 17:46:11.000 UTC |
| **Closed** | 2022-07-05 17:46:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

>A common implementation is at **go.temporal.io/sdk/contrib/tally.NewMetricsHandler.** The NopHandler is a noop handler. A handler may implement "Unwrap() Handler" if it wraps a handler.

https://github.com/temporalio/sdk-go/blob/2f76f4de20f0171cb67a6881853c6969f2324761/client/client.go#L432

I think the URL should point to: https://pkg.go.dev/go.temporal.io/sdk/contrib/tally#NewMetricsHandler

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-07-05 17:45:37.000 UTC</summary>

That's not meant to be a URL, that's a fully qualified function reference. I am not sure we want to change function references to URLs.

Reactions: ðŸ‘ 1

</details>


---

<a id="837"></a>

### #837: Support github.com/golang/protobuf messageType name

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/837 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-06-27 21:36:41.000 UTC (3y 6m ago) |
| **Updated** | 2022-06-28 14:27:05.000 UTC |
| **Closed** | 2022-06-28 14:27:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

`messageType` metadata value should have the qualified proto name

## Actual Behavior

It does for the non-deprecated library at https://pkg.go.dev/google.golang.org/protobuf but does not for the deprecated library at https://pkg.go.dev/github.com/golang/protobuf.

It's easy enough to support the older, so we should.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-06-28 14:27:04.000 UTC</summary>

We cannot do this. See https://github.com/temporalio/sdk-go/blob/1f6019818824ee160c544b92d77db14907ff9f57/converter/proto_json_payload_converter.go#L77-L85

Basically, we cannot depend on the pre `1.4.0` `github.com/golang/protobuf` to check this because we properly depend on the later one. This really old version is deprecated and there is not much we can do.

</details>


---

<a id="827"></a>

### #827: github.com/stretchr/testify-v1.7.0: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/827 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-06-07 18:41:26.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-11 01:01:07.000 UTC |
| **Closed** | 2022-06-11 01:01:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>github.com/stretchr/testify-v1.7.0</b></p></summary>

<p></p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-28948](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | github.com/go-yaml/yaml-496545a6307b2a7d7a710fd516e5e16e8ab62dbc | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-28948</summary>


###  Vulnerable Library - <b>github.com/go-yaml/yaml-496545a6307b2a7d7a710fd516e5e16e8ab62dbc</b></p>

<p>YAML support for the Go language.</p>
<p>

Dependency Hierarchy:
  - github.com/stretchr/testify-v1.7.0 (Root Library)
    - :x: **github.com/go-yaml/yaml-496545a6307b2a7d7a710fd516e5e16e8ab62dbc** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.

<p>Publish Date: 2022-05-19
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948>CVE-2022-28948</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-hp87-p4gw-j4gq">https://github.com/advisories/GHSA-hp87-p4gw-j4gq</a></p>
<p>Release Date: 2022-05-19</p>
<p>Fix Resolution: 3.0.0</p>

</p>

<p></p>

</details>
<!-- <REMEDIATE>[{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"GO","packageName":"github.com/go-yaml/yaml","packageVersion":"496545a6307b2a7d7a710fd516e5e16e8ab62dbc","packageFilePaths":[],"isTransitiveDependency":true,"dependencyTree":"github.com/stretchr/testify:v1.7.0;github.com/go-yaml/yaml:496545a6307b2a7d7a710fd516e5e16e8ab62dbc","isMinimumFixVersionAvailable":true,"minimumFixVersion":"3.0.0","isBinary":true}],"baseBranches":["master"],"vulnerabilityIdentifier":"CVE-2022-28948","vulnerabilityDetails":"An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.","vulnerabilityUrl":"https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948","cvss3Severity":"high","cvss3Score":"7.5","cvss3Metrics":{"A":"High","AC":"Low","PR":"None","S":"Unchanged","C":"None","UI":"None","AV":"Network","I":"None"},"extraData":{}}]</REMEDIATE> -->

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-06-11 01:01:07.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="817"></a>

### #817: github.com/go-yaml/yaml-v2.4.0: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/817 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-05-29 20:36:20.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-07 14:34:51.000 UTC |
| **Closed** | 2022-06-07 14:34:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>github.com/go-yaml/yaml-v2.4.0</b></p></summary>

<p>YAML support for the Go language.</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-28948](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | github.com/go-yaml/yaml-v2.4.0 | Direct | v3.0.0 | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-28948</summary>


###  Vulnerable Library - <b>github.com/go-yaml/yaml-v2.4.0</b></p>

<p>YAML support for the Go language.</p>
<p>

Dependency Hierarchy:
  - :x: **github.com/go-yaml/yaml-v2.4.0** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.

<p>Publish Date: 2022-05-19
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948>CVE-2022-28948</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-fm53-mpmp-7qw2">https://github.com/advisories/GHSA-fm53-mpmp-7qw2</a></p>
<p>Release Date: 2022-05-19</p>
<p>Fix Resolution: v3.0.0</p>

</p>

<p></p>

</details>
<!-- <REMEDIATE>[{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"GO","packageName":"github.com/go-yaml/yaml","packageVersion":"v2.4.0","packageFilePaths":[],"isTransitiveDependency":false,"dependencyTree":"github.com/go-yaml/yaml:v2.4.0","isMinimumFixVersionAvailable":true,"minimumFixVersion":"v3.0.0","isBinary":true}],"baseBranches":["master"],"vulnerabilityIdentifier":"CVE-2022-28948","vulnerabilityDetails":"An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.","vulnerabilityUrl":"https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-28948","cvss3Severity":"high","cvss3Score":"7.5","cvss3Metrics":{"A":"High","AC":"Low","PR":"None","S":"Unchanged","C":"None","UI":"None","AV":"Network","I":"None"},"extraData":{}}]</REMEDIATE> -->

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-06-07 14:34:51.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="810"></a>

### #810: OnUpsertSearchAttributes changes / additions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/810 |
| **State** | CLOSED |
| **Author** | gsmcwhirter (Gregory McWhirter) |
| **Created** | 2022-05-18 15:16:22.000 UTC (3y 7m ago) |
| **Updated** | 2022-07-01 12:29:16.000 UTC |
| **Closed** | 2022-07-01 12:29:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I am trying to write a workflow test that would call `workflow.UpsertSearchAttributes` possibly many times. The order of the calls is slightly random (randomization inside a side effect for deterministic replay), so I was hoping to use the `OnUpsertSearchAttributes` hook of the `TestWorkflowEnvironment` to record the calls that were made and check myself to ensure they are within the expected randomization bounds.

However, it appears that `OnUpsertSearchAttributes` takes a single argument of type `map[string]interface{}`, unlike `OnActivity` whose arguments are just `interface{}`. As far as I can tell, this prevents me from passing something equivalent to `mock.Anything` and using the `.Run()` function on the mock to record the actual arguments that were passed.

**Describe the solution you'd like**
I would like a way to use `OnUpsertSearchAttributes` or some other similar hook more like `OnActivity`.

**Describe alternatives you've considered**
We tried using the actual key(s) that would be in the upsert payload with `mock.Anything` as the value; we also tried using `mock.Anything` as the key, but neither allowed for arbitrary matching.

**Additional context**



#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-05-18 15:24:04.000 UTC</summary>

Hrmm, I wonder if just changing that param from `map[string]interface{}` to just `interface{}` introduces any big problematic backwards compatibility concerns. I will investigate.

</details>


---

<a id="793"></a>

### #793: Deprecate NewClient, create Dial, NewLazyClient, and CheckHealth calls and support laziness

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/793 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-04-27 21:45:35.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-06 14:58:35.000 UTC |
| **Closed** | 2022-05-06 14:58:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Today we have `NewClient` which, possibly unexpectedly to users, does more than create a client, it also connects to the server to confirm all connectivity. We previously had the ability to disable this but we removed that in #706.

**Describe the solution you'd like**

* (re)Add `client.Options.ConnectionOptions.DisableEagerConnection bool` that defaults to false for `NewClient`
* Add `client.Dial` call that force-sets `client.Options.ConnectionOptions.DisableEagerConnection` to `false` (so basically it's the same as `NewClient` today)
* Add `client.NewLazyClient` call that force-sets `client.Options.ConnectionOptions.DisableEagerConnection` to `true`
* Deprecate `NewClient` in favor of the `Dial` and `NewLazyClient` calls
* Add a client `ensureServerCapabilitiesFetched` that atomically lazily obtains the server capabilities if not fetched already and are memoized on success
* Update all client calls to have `ensureServerCapabilitiesFetched` call to support lazy connectivity
* Add a `CheckHealth` call on the client that uses the gRPC health API (note, it too will lazily fetch capabilities)

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-27 22:26:25.000 UTC</summary>

This scope supersedes #753 and #595

Reactions: ðŸ‘ 1

</details>


---

<a id="792"></a>

### #792: Expose fatal worker error in some way and stop killing process

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/792 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-04-27 19:07:18.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-06 13:16:46.000 UTC |
| **Closed** | 2022-05-06 13:16:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now, a non-retryable worker error signals itself to kill the process which is not OK.

**Describe the solution you'd like**

We need to just stop the entire worker and relay the error. Right now, someone can `Start` and won't see an error until `Stop` is called. We can relay via the `Run` call, but not everyone uses that. We should either return something that the user can listen for errors on from `Start` or we need to have a `WorkerFailureHandler` option or similar (whether that defaults to signal + process death to keep compat is an open question).

#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2022-04-27 21:57:50.000 UTC</summary>

Code reference: https://github.com/temporalio/sdk-go/blob/cb9c7de44f8774ab6681f4469ecbed8243d082dd/internal/internal_worker_base.go#L320

</details>


---

<a id="781"></a>

### #781: ReplayWorkflowExecution fails when history is too long

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/781 |
| **State** | CLOSED |
| **Author** | vikstrous2 (Viktor Stanchev) |
| **Created** | 2022-04-18 17:51:32.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-19 17:21:14.000 UTC |
| **Closed** | 2022-04-19 17:21:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
ReplayWorkflowExecution should work regardless of the length of history of operations

## Actual Behavior
ReplayWorkflowExecution fails if there are multiple pages of workflow history

## Steps to Reproduce the Problem

  1. Run a workflow that does something in a loop for a while
  1. Write a test that uses ReplayWorkflowExecution to replay its execution
  1. It'll error with something like "extra replay command for X:"

This is the line of code with the bug: https://github.com/temporalio/sdk-go/blob/8cb1963d6bdf913b1cb7992a7c84e3874d9de0fa/internal/internal_worker.go#L1121

This struct has pagination parameters that are not used: https://github.com/temporalio/api-go/blob/62ccc454aff1488d6ae47464033a39977579761f/workflowservice/v1/request_response.pb.go#L948




#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-04-18 19:51:20.000 UTC</summary>

Good catch! We are not properly using pagination here and we should. I will fix this in short order.

</details>


---

<a id="777"></a>

### #777: github.com/golang/tools-v0.1.10: 3 vulnerabilities (highest severity is: 6.1) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/777 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-04-13 20:35:12.000 UTC (3y 9m ago) |
| **Updated** | 2022-08-30 17:58:29.000 UTC |
| **Closed** | 2022-08-30 17:58:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>github.com/golang/tools-v0.1.10</b></p></summary>

<p>[mirror] Go Tools</p>
<p>Library home page: <a href="https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip">https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip</a></p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2020-11022](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2020-11022) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | github.com/golang/tools-v0.1.10 | Direct | jQuery - 3.5.0 | &#10060; |
| [CVE-2015-9251](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2015-9251) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | github.com/golang/tools-v0.1.10 | Direct | jQuery - v3.0.0 | &#10060; |
| [CVE-2012-6708](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2012-6708) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | github.com/golang/tools-v0.1.10 | Direct | jQuery - v1.9.0 | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2020-11022</summary>


###  Vulnerable Library - <b>github.com/golang/tools-v0.1.10</b></p>

<p>[mirror] Go Tools</p>
<p>Library home page: <a href="https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip">https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **github.com/golang/tools-v0.1.10** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In jQuery versions greater than or equal to 1.2 and before 3.5.0, passing HTML from untrusted sources - even after sanitizing it - to one of jQuery's DOM manipulation methods (i.e. .html(), .append(), and others) may execute untrusted code. This problem is patched in jQuery 3.5.0.

<p>Publish Date: 2020-04-29
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2020-11022>CVE-2020-11022</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/">https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/</a></p>
<p>Release Date: 2020-04-29</p>
<p>Fix Resolution: jQuery - 3.5.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2015-9251</summary>


###  Vulnerable Library - <b>github.com/golang/tools-v0.1.10</b></p>

<p>[mirror] Go Tools</p>
<p>Library home page: <a href="https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip">https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **github.com/golang/tools-v0.1.10** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 3.0.0 is vulnerable to Cross-site Scripting (XSS) attacks when a cross-domain Ajax request is performed without the dataType option, causing text/javascript responses to be executed.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2015-9251>CVE-2015-9251</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2015-9251">https://nvd.nist.gov/vuln/detail/CVE-2015-9251</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - v3.0.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2012-6708</summary>


###  Vulnerable Library - <b>github.com/golang/tools-v0.1.10</b></p>

<p>[mirror] Go Tools</p>
<p>Library home page: <a href="https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip">https://proxy.golang.org/github.com/golang/tools/@v/v0.1.10.zip</a></p>
<p>

Dependency Hierarchy:
  - :x: **github.com/golang/tools-v0.1.10** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-go/commit/3a2b86ebed54b2f01acfa03635867e89913c3bd4">3a2b86ebed54b2f01acfa03635867e89913c3bd4</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 1.9.0 is vulnerable to Cross-site Scripting (XSS) attacks. The jQuery(strInput) function does not differentiate selectors from HTML in a reliable fashion. In vulnerable versions, jQuery determined whether the input was HTML by looking for the '<' character anywhere in the string, giving attackers more flexibility when attempting to construct a malicious payload. In fixed versions, jQuery only deems the input to be HTML if it explicitly starts with the '<' character, limiting exploitability only to attackers who can control the beginning of a string, which is far less common.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2012-6708>CVE-2012-6708</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-6708">https://nvd.nist.gov/vuln/detail/CVE-2012-6708</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - v1.9.0</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-08-30 17:58:29.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="775"></a>

### #775: github.com/golang/tools-v0.1.8: 3 vulnerabilities (highest severity is: 6.1) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/775 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-04-13 01:28:35.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-13 16:43:11.000 UTC |
| **Closed** | 2022-04-13 16:43:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>github.com/golang/tools-v0.1.8</b></p></summary>

<p>[mirror] Go Tools</p>
<p>

</details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2020-11022](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2020-11022) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | github.com/golang/tools-v0.1.8 | Direct | jQuery - 3.5.0 | &#10060; |
| [CVE-2015-9251](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2015-9251) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | github.com/golang/tools-v0.1.8 | Direct | jQuery - v3.0.0 | &#10060; |
| [CVE-2012-6708](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2012-6708) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.1 | github.com/golang/tools-v0.1.8 | Direct | jQuery - v1.9.0 | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2020-11022</summary>


###  Vulnerable Library - <b>github.com/golang/tools-v0.1.8</b></p>

<p>[mirror] Go Tools</p>
<p>

Dependency Hierarchy:
  - :x: **github.com/golang/tools-v0.1.8** (Vulnerable Library)
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In jQuery versions greater than or equal to 1.2 and before 3.5.0, passing HTML from untrusted sources - even after sanitizing it - to one of jQuery's DOM manipulation methods (i.e. .html(), .append(), and others) may execute untrusted code. This problem is patched in jQuery 3.5.0.

<p>Publish Date: 2020-04-29
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2020-11022>CVE-2020-11022</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/">https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/</a></p>
<p>Release Date: 2020-04-29</p>
<p>Fix Resolution: jQuery - 3.5.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2015-9251</summary>


###  Vulnerable Library - <b>github.com/golang/tools-v0.1.8</b></p>

<p>[mirror] Go Tools</p>
<p>

Dependency Hierarchy:
  - :x: **github.com/golang/tools-v0.1.8** (Vulnerable Library)
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 3.0.0 is vulnerable to Cross-site Scripting (XSS) attacks when a cross-domain Ajax request is performed without the dataType option, causing text/javascript responses to be executed.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2015-9251>CVE-2015-9251</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2015-9251">https://nvd.nist.gov/vuln/detail/CVE-2015-9251</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - v3.0.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2012-6708</summary>


###  Vulnerable Library - <b>github.com/golang/tools-v0.1.8</b></p>

<p>[mirror] Go Tools</p>
<p>

Dependency Hierarchy:
  - :x: **github.com/golang/tools-v0.1.8** (Vulnerable Library)
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jQuery before 1.9.0 is vulnerable to Cross-site Scripting (XSS) attacks. The jQuery(strInput) function does not differentiate selectors from HTML in a reliable fashion. In vulnerable versions, jQuery determined whether the input was HTML by looking for the '<' character anywhere in the string, giving attackers more flexibility when attempting to construct a malicious payload. In fixed versions, jQuery only deems the input to be HTML if it explicitly starts with the '<' character, limiting exploitability only to attackers who can control the beginning of a string, which is far less common.

<p>Publish Date: 2018-01-18
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2012-6708>CVE-2012-6708</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Changed
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-6708">https://nvd.nist.gov/vuln/detail/CVE-2012-6708</a></p>
<p>Release Date: 2018-01-18</p>
<p>Fix Resolution: jQuery - v1.9.0</p>

</p>

<p></p>

</details>
<!-- <REMEDIATE>[{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"GO","packageName":"github.com/golang/tools","packageVersion":"v0.1.8","packageFilePaths":[],"isTransitiveDependency":false,"dependencyTree":"github.com/golang/tools:v0.1.8","isMinimumFixVersionAvailable":true,"minimumFixVersion":"jQuery - 3.5.0","isBinary":true}],"baseBranches":["master"],"vulnerabilityIdentifier":"CVE-2020-11022","vulnerabilityDetails":"In jQuery versions greater than or equal to 1.2 and before 3.5.0, passing HTML from untrusted sources - even after sanitizing it - to one of jQuery\u0027s DOM manipulation methods (i.e. .html(), .append(), and others) may execute untrusted code. This problem is patched in jQuery 3.5.0.","vulnerabilityUrl":"https://vuln.whitesourcesoftware.com/vulnerability/CVE-2020-11022","cvss3Severity":"medium","cvss3Score":"6.1","cvss3Metrics":{"A":"None","AC":"Low","PR":"None","S":"Changed","C":"Low","UI":"Required","AV":"Network","I":"Low"},"extraData":{}},{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"GO","packageName":"github.com/golang/tools","packageVersion":"v0.1.8","packageFilePaths":[],"isTransitiveDependency":false,"dependencyTree":"github.com/golang/tools:v0.1.8","isMinimumFixVersionAvailable":true,"minimumFixVersion":"jQuery - v3.0.0","isBinary":true}],"baseBranches":["master"],"vulnerabilityIdentifier":"CVE-2015-9251","vulnerabilityDetails":"jQuery before 3.0.0 is vulnerable to Cross-site Scripting (XSS) attacks when a cross-domain Ajax request is performed without the dataType option, causing text/javascript responses to be executed.","vulnerabilityUrl":"https://vuln.whitesourcesoftware.com/vulnerability/CVE-2015-9251","cvss3Severity":"medium","cvss3Score":"6.1","cvss3Metrics":{"A":"None","AC":"Low","PR":"None","S":"Changed","C":"Low","UI":"Required","AV":"Network","I":"Low"},"extraData":{}},{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"GO","packageName":"github.com/golang/tools","packageVersion":"v0.1.8","packageFilePaths":[],"isTransitiveDependency":false,"dependencyTree":"github.com/golang/tools:v0.1.8","isMinimumFixVersionAvailable":true,"minimumFixVersion":"jQuery - v1.9.0","isBinary":true}],"baseBranches":["master"],"vulnerabilityIdentifier":"CVE-2012-6708","vulnerabilityDetails":"jQuery before 1.9.0 is vulnerable to Cross-site Scripting (XSS) attacks. The jQuery(strInput) function does not differentiate selectors from HTML in a reliable fashion. In vulnerable versions, jQuery determined whether the input was HTML by looking for the \u0027\u003c\u0027 character anywhere in the string, giving attackers more flexibility when attempting to construct a malicious payload. In fixed versions, jQuery only deems the input to be HTML if it explicitly starts with the \u0027\u003c\u0027 character, limiting exploitability only to attackers who can control the beginning of a string, which is far less common.","vulnerabilityUrl":"https://vuln.whitesourcesoftware.com/vulnerability/CVE-2012-6708","cvss3Severity":"medium","cvss3Score":"6.1","cvss3Metrics":{"A":"None","AC":"Low","PR":"None","S":"Changed","C":"Low","UI":"Required","AV":"Network","I":"Low"},"extraData":{}}]</REMEDIATE> -->

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-04-13 16:43:10.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by WhiteSource because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the WhiteSource inventory.

</details>


---

<a id="773"></a>

### #773: deadlock detected: workflow goroutine "root" didn't yield for over a second

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/773 |
| **State** | CLOSED |
| **Author** | koolay (koolay) |
| **Created** | 2022-04-12 06:39:43.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-12 13:17:17.000 UTC |
| **Closed** | 2022-04-12 13:17:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

CronJob works ok.

## Actual Behavior

`deadlock detected: workflow goroutine "root" didn't yield for over a second`

## Steps to Reproduce the Problem

**Start workflow**

```go
package main

import (
	"context"
	"log"
	"time"

	"github.com/koolay/temporal-quickstart/pkg/workflows"
	"go.temporal.io/sdk/client"
	clientSdk "go.temporal.io/sdk/client"
)

var serverHost = "localhost:7233"

func main() {
	client, err := client.NewClient(client.Options{
		HostPort: serverHost,
	})
	if err != nil {
		log.Fatalln("unable to create temporal client", err)
	}
	defer client.Close()

	options := clientSdk.StartWorkflowOptions{
		ID:                       workflows.CronWorkflowID,
		TaskQueue:                workflows.CronQueueName,
		CronSchedule:             "@every 10s",
		WorkflowRunTimeout:       5 * time.Second,
		WorkflowExecutionTimeout: 10 * time.Second,
	}

	running, err := client.ExecuteWorkflow(context.Background(), options, workflows.CronWorkflow)
	if err != nil {
		log.Fatalln("unable to start cron workflow", err)
	}

	log.Println("execute workflow:", running.GetID(), running.GetRunID())
}

```

`workflow`

```go
func CronWorkflow(ctx workflow.Context) error {
	time.Sleep(time.Second)
	workflow.GetLogger(ctx).Info("Cron workflow started.", "StartTime", workflow.Now(ctx))
	return nil
}

```

**Run worker**
```go
package main

import (
	"log"

	"github.com/koolay/temporal-quickstart/pkg/workflows"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

var serverHost = "localhost:7233"

func main() {
	// The client and worker are heavyweight objects that should be created once per process.
	client, err := client.NewClient(client.Options{
		HostPort:  serverHost,
		Namespace: "default",
	})
	if err != nil {
		log.Fatalln("Unable to create client", err)
	}

	defer client.Close()

	w := worker.New(client, "cron", worker.Options{})

	w.RegisterWorkflow(workflows.CronWorkflow)

	err = w.Run(worker.InterruptCh())
	if err != nil {
		log.Fatalln("Unable to start worker", err)
	}
}

```

## Specifications

  - Version:1.14.0
  - Platform:docker


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-04-12 13:17:01.000 UTC</summary>

You cannot sleep in workflows using `time.Sleep`. Please see https://docs.temporal.io/docs/go/how-to-develop-a-workflow-definition-in-go#workflow-logic-requirements-in-go and the documentation at the top of https://pkg.go.dev/go.temporal.io/sdk.

</details>


---

<a id="753"></a>

### #753: Allow lazy connection on client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/753 |
| **State** | CLOSED |
| **Author** | danielhochman (Daniel Hochman) |
| **Created** | 2022-03-14 17:28:12.000 UTC (3y 10m ago) |
| **Updated** | 2022-05-06 14:58:35.000 UTC |
| **Closed** | 2022-05-06 14:58:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The ability to lazy connect to the server was removed in v1.14.0 with the addition of the getCapabilities call on client creation.

Ideally the SDK would still offer the option to connect lazily. Fail fast in a critical application with multiple concerns (i.e. Temporal access plus at least one other concern) is a non-starter. It can block and bring an entire service down during a deploy, scale up, or other lifecycle event even if only a small portion of the service is not operational.

**Describe the solution you'd like**
Each call on the client can check whether or not the connection has been created, and use a mutex to lock and create it before allowing any calls to proceed.

**Describe alternatives you've considered**
One option would be to duplicate the entire interface in our application to wrap every call with the solution described above. From a maintenance perspective it's not great. Would prefer to have this option in the upstream client.

A client factory can help, but the factory has side-effects in that case. This is an anti-pattern, so additional warnings are then needed to prevent a developer from calling the factory somewhere it could block (e.g. in the instantiation of a module during dependency injection or similar). To better mitigate the problem an application can implement a factory that creates the config and then an additional `GetConnection()` call off of the returned struct. This signals to the developer that the call will connect to the server and should not be used during application start.

**Additional context**
See this thread for more discussion: https://temporalio.slack.com/archives/CTRCR8RBP/p1645050691089599

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-04-22 21:13:27.000 UTC</summary>

After some discussion internally and across languages, it looks like we may end up moving to this model.

</details>


---

<a id="716"></a>

### #716: If a workflow is terminated while processing, it can leak coroutines

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/716 |
| **State** | OPEN |
| **Author** | aouji |
| **Created** | 2022-02-04 02:02:38.000 UTC (3y 11m ago) |
| **Updated** | 2022-04-21 13:32:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Terminating a workflow should not leave behind coroutines

## Actual Behavior
If a workflow is terminated while processing, it can leak coroutines.

We have a fairly complex workflow following the dsl pattern in https://github.com/temporalio/samples-go/blob/main/dsl/workflow.go . It seems like if a dsl workflow is terminated before all activities are processed, any pending coroutines handling them will be stuck forever. We can see this using pprof:

```
-----------+-------------------------------------------------------
      1231   runtime.gopark
             runtime.chanrecv
             runtime.chanrecv1
             go.temporal.io/sdk/internal.(*coroutineState).initialYield
             go.temporal.io/sdk/internal.(*coroutineState).yield (inline)
             go.temporal.io/sdk/internal.(*channelImpl).Receive
             go.temporal.io/sdk/internal.(*decodeFutureImpl).Get
             pkg/workflows.ActivityInvocation.execute
             pkg/workflows.(*Statement).execute
             pkg/workflows.executeAsync.func1
             go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1
-----------+-------------------------------------------------------
        17   runtime.gopark
             runtime.chanrecv
             runtime.chanrecv1
             go.temporal.io/sdk/internal.(*coroutineState).initialYield
             go.temporal.io/sdk/internal.(*coroutineState).yield (inline)
             go.temporal.io/sdk/internal.(*selectorImpl).Select
             pkg/workflows.Parallel.execute
             pkg/workflows.(*Statement).execute
             pkg/workflows.Sequence.execute
             pkg/workflows.(*Statement).execute
             pkg/workflows.DSLWorkflow
             reflect.Value.call
             reflect.Value.Call
             go.temporal.io/sdk/internal.executeFunction
             go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow
             go.temporal.io/sdk/internal.(*workflowExecutor).Execute
             go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1
             go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1
```

This is specially affecting us as due to another issue our workflows can get stuck during cancellation ( https://community.temporal.io/t/invalid-history-builder-state-for-action-add-activitytask-cancel-requested-event/3459 ) and we have worked around that by trying to detect and automatically terminate such workflows... 

It will be great if the sdk can ensure all channels are closed and nothing is leaked when a workflow is terminated

## Steps to Reproduce the Problem

  1. Try running the dsl workflow at https://github.com/temporalio/samples-go/blob/main/dsl/workflow.go with a large number of parallel activities 
  1. Terminate the workflow before activities finish
  1. check number of goroutines in the worker process that handled the workflow

## Specifications

  - Version:  1.12.0
  - Platform: MacOS


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-04-21 13:30:58.000 UTC</summary>

This may be fixed by #779, but we will have to test after that is merged.

</details>


---

<a id="698"></a>

### #698: Allow "unable to find workflow type" error to be configured to hard-fail the workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/698 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-15 02:13:13.000 UTC (3y 12m ago) |
| **Updated** | 2022-01-15 02:49:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Currently we allow this error to support retry so a worker can be deployed with the proper workflow for it to work.

**Describe the solution you'd like**

Need to investigate options about making it non-retryable.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-01-15 02:49:53.000 UTC</summary>

The best approach for this may be to go ahead and support #543 so a catch-all workflow implementation can be written

</details>


---

<a id="695"></a>

### #695: RetryPolicy not propagated on ContinueAsNew

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/695 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-13 15:06:56.000 UTC (3y 12m ago) |
| **Updated** | 2022-01-18 19:29:12.000 UTC |
| **Closed** | 2022-01-18 19:29:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

RetryPolicy should either be propagated or accepted as a param for continue as new

## Actual Behavior

RetryPolicy is completely unset in `ContinueAsNewWorkflowExecutionCommandAttributes`

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2022-01-13 15:18:12.000 UTC</summary>

I believe service propagates most of the attributes by default. I'm not sure about the retryOptions.

</details>


---

<a id="686"></a>

### #686: Manually returned activity cancel error without receiving a server-side cancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/686 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-05 22:41:05.000 UTC (4 years ago) |
| **Updated** | 2022-01-14 14:50:22.000 UTC |
| **Closed** | 2022-01-14 14:50:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Today for activities, when you return `temporal.CanceledError` or `context.Canceled`, we send back `RespondActivityTaskCanceledRequest` regardless of whether there was a cancellation in flight. See https://github.com/temporalio/sdk-go/blob/4d6762570b52a77fe6df5a644ca024a1191bc407/internal/internal_task_pollers.go#L974-L987.

**Describe the solution you'd like**

* Make sure to only handle those cancelled errors as actually sending a cancel to the server if the server sent us a cancel
* Make sure to wrap `temporal.CanceledError` and `context.Canceled` into a normal retryable `ApplicationFailure` in other cases
* Make sure other SDKs do the same
* Write a test confirming what happens in these situations
* Write a test confirming what happens if an activity is not heartbeating to receive a cancel and returns a failure
* To check potential workflow behavior incompatibility, write a test to confirm what workflow does when we return a canceled error (or go canceled error) when a cancellation was requested and, most importantly, when it was not.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-01-05 22:51:36.000 UTC</summary>

Also see server side PR that errors if you try to cancel activity not expecting it: https://github.com/temporalio/temporal/pull/2344

</details>


---

<a id="670"></a>

### #670: Test activity start and complete between workflow schedule and start

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/670 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-13 22:10:34.000 UTC (4 years ago) |
| **Updated** | 2021-12-16 16:39:09.000 UTC |
| **Closed** | 2021-12-16 16:39:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

User reported a history that has the following events in order: `WorkflowTaskScheduled`, `ActivityTaskStarted`, `ActivityTaskCompleted`, then `WorkflowTaskStarted` and it gave the:

> lookup failed for scheduledEventID to activityID: scheduleEventID: 109, activityID: 108 

As can happen in unexpected orders. Attempt to replicate.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 16:39:09.000 UTC</summary>

I was unable to successfully replicate a bug, but I could replicate that series of events. PR opened at https://github.com/temporalio/sdk-features/pull/5.

</details>


---

<a id="667"></a>

### #667: Test and document exactly what contexts are cancelled on worker stop

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/667 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-10 15:15:13.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-16 16:45:01.000 UTC |
| **Closed** | 2021-12-16 16:45:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now it is not clear to users which contexts are closed on worker stop.

**Describe the solution you'd like**

Test and document whether workflow and activity context parameters (not just `activity.GetWorkerStopChannel`) are cancelled on worker stop.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 16:45:00.000 UTC</summary>

This is already present and I just missed it. From `go.temporal.io/sdk/activity.GetWorkerStopChannel`: https://github.com/temporalio/sdk-go/blob/5e5645f0c550dcf717c095ae32c76a7087d2e985/activity/activity.go#L94-L95

So that channel can be used for during-worker-stop graceful handling, and the parameter context can be used for after-worker-stop-graceful-handling-timeout handling.

For workflows they obviously don't run longer than a second and their context cancellation is not tied to which worker they run on.

</details>


---

<a id="666"></a>

### #666: -

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/666 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-10 15:13:56.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-16 17:30:14.000 UTC |
| **Closed** | 2021-12-16 16:39:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Move to next issue

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2021-12-16 17:30:14.000 UTC</summary>

Lol

Reactions: ðŸ˜„ 1

</details>


---

<a id="664"></a>

### #664: Add opentracing.MustNewInterceptor and opentelemetry.MustNewTracingInterceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/664 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-09 17:53:37.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-16 19:43:38.000 UTC |
| **Closed** | 2021-12-16 19:43:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The existing functions never really return errors, errors are just in the return for future proofing. So we might as well have `Must` equivalents.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-12-16 19:43:38.000 UTC</summary>

I'm no longer convinced in the value of these shortcuts. We should reopen if necessary.

</details>


---

<a id="646"></a>

### #646: Confirm support or lack of for multiple query return types

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/646 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-22 18:00:46.000 UTC (4y 1m ago) |
| **Updated** | 2021-11-23 18:56:23.000 UTC |
| **Closed** | 2021-11-23 18:56:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This does not seem to error but our query response API in the library only gives access to a single value.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-23 18:56:22.000 UTC</summary>

Confirmed that we error at query registration time if there aren't exactly two return types and the second one is error.

</details>


---

<a id="615"></a>

### #615: Header support for signals and queries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/615 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-02 16:54:26.000 UTC (4y 2m ago) |
| **Updated** | 2021-12-15 22:14:19.000 UTC |
| **Closed** | 2021-12-15 22:14:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement, external dependency |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Interceptors for signals and queries do not support 

**Describe the solution you'd like**

Support header propagation for signals and queries the same way as we do for workflows and activities. This depends on #610 and https://github.com/temporalio/temporal/issues/2125.


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-17 14:40:31.000 UTC</summary>

PR is in place, but waiting for a server release to update CI.

</details>


---

<a id="568"></a>

### #568: custom data converter is not correctly wired up for local activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/568 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-09-30 22:52:51.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-01 17:05:27.000 UTC |
| **Closed** | 2021-10-01 17:05:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
local activity result should be converted by user supplied data converter.

## Actual Behavior
Local activity result is not converted.

## Steps to Reproduce the Problem

  1. Add a simple local activity to this sample https://github.com/temporalio/samples-go/tree/master/encrypted-payloads
  1. Run it and use tctl to show history
  1. The local activity result is show as plain text.

## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>robholland</strong> commented on 2021-10-01 17:05:27.000 UTC</summary>

This was actually due to https://github.com/temporalio/samples-go/pull/140, the wiring in the go SDK is correct.

</details>


---

<a id="558"></a>

### #558: TestCancelTimerAfterActivity is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/558 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 07:47:01.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:03.000 UTC |
| **Closed** | 2021-11-18 15:38:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
2021/09/24 00:46:47 INFO  Started Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelTimerAfterActivity WorkerID 87997@arch@
2021/09/24 00:46:49 DEBUG NewTimer Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelTimerAfterActivity WorkerID 87997@arch@ WorkflowType CancelTimerAfterActivity WorkflowID test-cancel-timer-after-activity RunID f9fe9f38-9f87-404d-9727-e505f6ce00c5 Attempt 1 TimerID 5 Duration 3s
2021/09/24 00:46:49 DEBUG ExecuteActivity Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelTimerAfterActivity WorkerID 87997@arch@ WorkflowType CancelTimerAfterActivity WorkflowID test-cancel-timer-after-activity RunID f9fe9f38-9f87-404d-9727-e505f6ce00c5 Attempt 1 ActivityID 6 ActivityType Prefix_ToUpper
2021/09/24 00:46:49 DEBUG RequestCancelTimer Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelTimerAfterActivity WorkerID 87997@arch@ WorkflowType CancelTimerAfterActivity WorkflowID test-cancel-timer-after-activity RunID f9fe9f38-9f87-404d-9727-e505f6ce00c5 Attempt 1 TimerID 5
=== CONT  TestIntegrationSuite
    integration_test.go:756: 
        	Error Trace:	integration_test.go:756
        	Error:      	Received unexpected error:
        	            	workflow execution error (type: CancelTimerAfterActivity, workflowID: test-cancel-timer-after-activity, runID: f9fe9f38-9f87-404d-9727-e505f6ce00c5): activity error (type: Prefix_ToUpper, scheduledEventID: 6, startedEventID: 0, identity: ): activity timeout (type: ScheduleToStart)
        	Test:       	TestIntegrationSuite
2021/09/24 00:46:54 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelTimerAfterActivity WorkerID 87997@arch@
=== CONT  TestIntegrationSuite/TestCancelTimerAfterActivity
    testing.go:1169: test executed panic(nil) or runtime.Goexit: subtest may have called FailNow on a parent test

```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:03.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="557"></a>

### #557: TestCancelChildWorkflowUnusualTransitions is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/557 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 07:40:21.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:07.000 UTC |
| **Closed** | 2021-11-18 15:38:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
=== RUN   TestIntegrationSuite
=== CONT  TestIntegrationSuite
    integration_test.go:809: 
        	Error Trace:	integration_test.go:809
        	Error:      	Should NOT be empty, but was 
        	Test:       	TestIntegrationSuite
2021/09/24 00:39:57 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelChildWorkflowUnusualTransitions WorkerID 85926@arch@
--- FAIL: TestIntegrationSuite (20.66s)
=== RUN   TestIntegrationSuite/TestCancelChildWorkflowUnusualTransitions
2021/09/24 00:39:53 INFO  Started Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelChildWorkflowUnusualTransitions WorkerID 85926@arch@
2021/09/24 00:39:55 DEBUG ExecuteChildWorkflow Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestCancelChildWorkflowUnusualTransitions WorkerID 85926@arch@ WorkflowType ChildWorkflowCancelUnusualTransitionsRepro WorkflowID test-cancel-child-workflow-unusual-transitions RunID f05a56aa-58b8-4d11-ab8d-f123cd458f3c Attempt 1 ChildWorkflowID f05a56aa-58b8-4d11-ab8d-f123cd458f3c_5 WorkflowType childWorkflowWaitOnSignal
=== CONT  TestIntegrationSuite/TestCancelChildWorkflowUnusualTransitions
    testing.go:1169: test executed panic(nil) or runtime.Goexit: subtest may have called FailNow on a parent test
    --- FAIL: TestIntegrationSuite/TestCancelChildWorkflowUnusualTransitions (4.97s)


FAIL

Process finished with the exit code 1


```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:07.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="555"></a>

### #555: TestActivityNotRegisteredRetry is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/555 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 07:33:09.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:11.000 UTC |
| **Closed** | 2021-11-18 15:38:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
    integration_test.go:1267: 
        	Error Trace:	integration_test.go:1267
        	            				integration_test.go:350
        	Error:      	Not equal: 
        	            	expected: int(2)
        	            	actual  : int64(3)
        	Test:       	TestIntegrationSuite
        	Messages:   	Expected value doesn't match actual value for counter temporal_unregistered_activity_invocation
2021/09/24 00:29:47 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestActivityNotRegisteredRetry WorkerID 83850@arch@
--- FAIL: TestIntegrationSuite (11.63s)
=== RUN   TestIntegrationSuite/TestActivityNotRegisteredRetry
2021/09/24 00:29:37 INFO  Started Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestActivityNotRegisteredRetry WorkerID 83850@arch@
2021/09/24 00:29:39 DEBUG ExecuteActivity Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestActivityNotRegisteredRetry WorkerID 83850@arch@ WorkflowType CallUnregisteredActivityRetry WorkflowID test-activity-retry-on-error RunID 66afc979-5705-48bd-ad2d-3242765c5e99 Attempt 1 ActivityID 5 ActivityType Unknown
=== CONT  TestIntegrationSuite/TestActivityNotRegisteredRetry
    testing.go:1169: test executed panic(nil) or runtime.Goexit: subtest may have called FailNow on a parent test
    --- FAIL: TestIntegrationSuite/TestActivityNotRegisteredRetry (10.44s)



Expected :int(2)
Actual   :int64(3)
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:10.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="554"></a>

### #554: TestActivityNotRegisteredRetry is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/554 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 07:19:36.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-24 07:24:39.000 UTC |
| **Closed** | 2021-09-24 07:24:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

```
=== RUN   TestIntegrationSuite
=== CONT  TestIntegrationSuite
    integration_test.go:1267: 
        	Error Trace:	integration_test.go:1267
        	            				integration_test.go:350
        	Error:      	Not equal: 
        	            	expected: int(2)
        	            	actual  : int64(1)
        	Test:       	TestIntegrationSuite
        	Messages:   	Expected value doesn't match actual value for counter temporal_unregistered_activity_invocation
2021/09/24 00:16:41 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-3-TestIntegrationSuite/TestActivityNotRegisteredRetry WorkerID 77523@arch@
--- FAIL: TestIntegrationSuite (28.51s)
=== RUN   TestIntegrationSuite/TestActivityNotRegisteredRetry
2021/09/24 00:16:29 INFO  Started Worker Namespace integration-test-namespace TaskQueue tq-3-TestIntegrationSuite/TestActivityNotRegisteredRetry WorkerID 77523@arch@
2021/09/24 00:16:33 DEBUG ExecuteActivity Namespace integration-test-namespace TaskQueue tq-3-TestIntegrationSuite/TestActivityNotRegisteredRetry WorkerID 77523@arch@ WorkflowType CallUnregisteredActivityRetry WorkflowID test-activity-retry-on-error RunID 9d7caefd-d19c-4cea-8bcf-1a9d887dd87e Attempt 1 ActivityID 5 ActivityType Unknown
=== CONT  TestIntegrationSuite/TestActivityNotRegisteredRetry
    testing.go:1169: test executed panic(nil) or runtime.Goexit: subtest may have called FailNow on a parent test
    --- FAIL: TestIntegrationSuite/TestActivityNotRegisteredRetry (11.82s)



Expected :int(2)
Actual   :int64(1)
<Click to see difference>



```

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-09-24 07:24:39.000 UTC</summary>

Hard to repro individually. Going to close for now.

</details>


---

<a id="553"></a>

### #553: TestAsyncActivityCompletion is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/553 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 07:08:39.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:14.000 UTC |
| **Closed** | 2021-11-18 15:38:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
   integration_test.go:1004: 
        	Error Trace:	integration_test.go:1004
        	Error:      	Not equal: 
        	            	expected: []string{"asyncComplete", "asyncComplete"}
        	            	actual  : []string{"asyncComplete"}
        	            	
        	            	Diff:
        	            	--- Expected
        	            	+++ Actual
        	            	@@ -1,3 +1,2 @@
        	            	-([]string) (len=2) {
        	            	- (string) (len=13) "asyncComplete",
        	            	+([]string) (len=1) {
        	            	  (string) (len=13) "asyncComplete"
        	Test:       	TestIntegrationSuite
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:14.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="552"></a>

### #552: TestActivityStartedAtSameTimeAsTimerCancel is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/552 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 07:04:21.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:39.000 UTC |
| **Closed** | 2021-11-18 15:38:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
=== CONT  TestIntegrationSuite
    integration_test.go:889: 
        	Error Trace:	integration_test.go:889
        	Error:      	Received unexpected error:
        	            	workflow execution error (type: WorkflowWithLocalActivityStartWhenTimerCancel, workflowID: test-activity-start-with-timer-cancel, runID: f98b5815-9604-43b3-8fa3-14122856e257): Workflow timeout (type: StartToClose)
        	Test:       	TestIntegrationSuite
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:39.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="551"></a>

### #551: TestActivityRetryOnTimeoutStableError is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/551 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 06:55:24.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:43.000 UTC |
| **Closed** | 2021-11-18 15:38:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
=== CONT  TestIntegrationSuite
    integration_test.go:358: 
        	Error Trace:	integration_test.go:358
        	Error:      	Expected nil, but got: &internal.WorkflowExecutionError{workflowID:"test-activity-retry-on-timeout-stable-error", runID:"094b1acb-c630-4cf0-b41d-90a8348a81c6", workflowType:"RetryTimeoutStableErrorWorkflow", cause:(*internal.ApplicationError)(0xc0004039e0)}
        	Test:       	TestIntegrationSuite
2021/09/23 23:53:11 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-7-TestIntegrationSuite/TestActivityRetryOnTimeoutStableError WorkerID 73060@arch@
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:43.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="549"></a>

### #549: TestActivityRetryOnStartToCloseTimeout is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/549 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 06:51:35.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:46.000 UTC |
| **Closed** | 2021-11-18 15:38:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
=== CONT  TestIntegrationSuite
    integration_test.go:376: 
        	Error Trace:	integration_test.go:376
        	Error:      	Received unexpected error:
        	            	workflow execution error (type: ActivityRetryOnTimeout, workflowID: test-activity-retry-on-start2close-timeout, runID: ce44ffbe-1e86-4f67-af1d-52984cafa444): activity failed due to unexpected timeout ScheduleToClose
        	Test:       	TestIntegrationSuite
2021/09/23 23:51:31 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-6-TestIntegrationSuite/TestActivityRetryOnStartToCloseTimeout WorkerID 72688@arch@
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:46.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="548"></a>

### #548: TestActivityNotRegisteredRetry is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/548 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 06:33:24.000 UTC (4y 3m ago) |
| **Updated** | 2021-11-18 15:38:49.000 UTC |
| **Closed** | 2021-11-18 15:38:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

```
=== CONT  TestIntegrationSuite
    integration_test.go:1261: 
        	Error Trace:	integration_test.go:1261
        	            				integration_test.go:349
        	Error:      	Not equal: 
        	            	expected: int(2)
        	            	actual  : int64(1)
        	Test:       	TestIntegrationSuite
        	Messages:   	Expected value doesn't match actual value for counter temporal_unregistered_activity_invocation
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-11-18 15:38:49.000 UTC</summary>

This test does not appear flaky anymore in CI

</details>


---

<a id="528"></a>

### #528: clarify `ActivityOptions.ActivityID`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/528 |
| **State** | CLOSED |
| **Author** | jackieli-tes (Jackie Li) |
| **Created** | 2021-09-06 15:55:51.000 UTC (4y 4m ago) |
| **Updated** | 2025-02-04 18:32:05.000 UTC |
| **Closed** | 2025-02-04 18:32:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Whilst utilising the workflow.ActivityOptions, I see the description:

https://github.com/temporalio/sdk-go/blob/master/internal/activity.go#L119-L122

```go
// ActivityID - Business level activity ID, this is not needed for most of the cases if you have
// to specify this then talk to temporal team. This is something will be done in future.
// Optional: default empty string
ActivityID string
```

I have tested this field. Looks like it already does what it says. Should the help just read:

```go
// ActivityID - Business level activity ID
// Optional: default empty string
ActivityID string
```


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:32:04.000 UTC</summary>

As the comment says activity ID is not recommend for most uses.

</details>


---

<a id="517"></a>

### #517: codahale/hdrhistogram repo url has been transferred under the github HdrHstogram umbrella

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/517 |
| **State** | CLOSED |
| **Author** | filipecosta90 (Filipe Oliveira (Personal)) |
| **Created** | 2021-08-16 00:42:02.000 UTC (4y 4m ago) |
| **Updated** | 2024-06-13 14:31:32.000 UTC |
| **Closed** | 2024-06-13 14:31:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Problem 

The codahale/hdrhistogram repo has been transferred under the github HdrHstogram umbrella with the help from the original author in Sept 2020 (new repo url https://github.com/HdrHistogram/hdrhistogram-go). The main reasons are to group all implementations under the same roof and to provide more active contribution from the community as the original repository was archived several years ago.

The dependency URL should be modified to point to the new repository URL. The tag "v0.9.0" was applied at the point of transfer and will reflect the exact code that was frozen in the original repository.

If you are using Go modules, you can update to the exact point of transfer using the @v0.9.0 tag in your go get command.
```
go mod edit -replace github.com/codahale/hdrhistogram=github.com/HdrHistogram/hdrhistogram-go@v0.9.0
```

## Performance Improvements

From the point of transfer, up until now (mon 16 aug 2021), we've released 3 versions that aim support the standard HdrHistogram serialization/exposition formats, and deeply improve READ performance. 
We recommend to update to the latest version.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-13 14:31:27.000 UTC</summary>

Closing as no longer needed

</details>


---

<a id="502"></a>

### #502: Backoff poller on ResourceExhausted error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/502 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-07-30 19:47:23.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-02 22:23:44.000 UTC |
| **Closed** | 2021-08-02 22:23:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug, potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
poller should backoff on see ResourceExhausted.

## Actual Behavior
Poller keeps aggressive retry.

## Steps to Reproduce the Problem

  1. set matching rpc dynamic config



#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-07-30 21:28:16.000 UTC</summary>

I agree that current retry policy is overly aggressive. I would like to discuss this with Alex before we make a change though.
Also we need to decide if we want to treat all retryable error codes the same or if we want `ResourceExhausted` have special treatment. See the list of [retryable errors](https://www.notion.so/temporalio/Retryable-gRPC-error-codes-e1324307c4a745839b6c4a84a27373b8) for more context.

</details>


---

<a id="496"></a>

### #496: Add accessors for ActivityError fields

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/496 |
| **State** | CLOSED |
| **Author** | aocole (Andrew Cole) |
| **Created** | 2021-07-23 22:53:17.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-04 18:16:08.000 UTC |
| **Closed** | 2021-08-04 18:16:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When handling an ActivityError from a workflow, it would be nice to be able to access some of the fields of the ActivityError such as retryState.

**Describe the solution you'd like**
I would like exported accessor functions on ActivityError to access fields such as retryState

**Additional context**
[Discussed in the forums](https://community.temporal.io/t/questions-around-activity-errors-retry-and-more-complex-error-handling-scenarios/2016/9?u=aocole) and Maxim requested this issue.


#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-08-03 06:40:35.000 UTC</summary>

Out of all fields
```
	ActivityError struct {
		temporalError
		scheduledEventID int64
		startedEventID   int64
		identity         string
		activityType     *commonpb.ActivityType
		activityID       string
		retryState       enumspb.RetryState
		cause            error
	}
```
cause is already exposed via `Unwrap`

while `Error` function provides details for activity type, scheduled/started event IDs and identity:
```
func (e *ActivityError) Error() string {
	msg := fmt.Sprintf("%s (type: %s, scheduledEventID: %d, startedEventID: %d, identity: %s)", e.message(), e.activityType.GetName(), e.scheduledEventID, e.startedEventID, e.identity)
	if e.cause != nil {
		msg = fmt.Sprintf("%s: %v", msg, e.cause)
	}
	return msg
}
```
I think for convenience reasons we should also provide values for the above variables so that users are not forced to parse the string if they need these details inside of the workflow.
Also we should add getters for two missing fields - RetryState and ActivityID.
Now the question is, if we should do the same for other error types, here is a full list:
```
ApplicationError
CanceledError
ServerError
ChildWorkflowExecutionError
WorkflowExecutionError
TimeoutError
TerminatedError
PanicError
UnknownExternalWorkflowExecutionError
```

</details>


---

<a id="473"></a>

### #473: Workflow replay is broken if workflow contains multiple subsequent calls to GetVersion

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/473 |
| **State** | CLOSED |
| **Author** | mfesenko (Mary Fesenko) |
| **Created** | 2021-06-20 22:28:35.000 UTC (4y 6m ago) |
| **Updated** | 2021-06-22 01:40:46.000 UTC |
| **Closed** | 2021-06-21 16:51:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
- No workflow panics in worker logs
- `Query` tab should load properly:
![image](https://user-images.githubusercontent.com/8646655/122689984-2e7a6080-d22f-11eb-9caf-c0fec8e16eea.png)

## Actual Behavior
- Workflow panic in worker logs:
```
2021/06/21 01:17:37 ERROR Workflow panic Namespace default TaskQueue TEST_TASK_QUEUE WorkerID 75752@Marys-MacBook-Pro.local@ WorkflowType MyWorkflow WorkflowID my-workflow RunID bfbe63a0-5344-4641-8452-471445bce46c Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 9, activityID: 9 StackTrace process event for TEST_TASK_QUEUE [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_decision_state_machine.go:395
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc0000990e0, 0x206d5a8, 0x1, 0x9)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_decision_state_machine.go:891 +0x165
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc0004f6600, 0xc000146980, 0x1, 0x0, 0x0)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_event_handlers.go:813 +0x42e
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc00016e380, 0xc00047a8a0, 0x20b69a0, 0xc0001d4150, 0xc00016e380, 0x0)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:875 +0x73c
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc0000dfe40, 0xc00047a8a0, 0xc000900900, 0x0, 0x0, 0x0, 0x0)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_task_handlers.go:726 +0x739
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc0001abba0, 0xc00047a8a0, 0x0, 0x0)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:286 +0x4ae
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc0001abba0, 0x191bc00, 0xc00047a8a0, 0x1b84de0, 0xc0000421e0)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_task_pollers.go:257 +0x85
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc0002120f0, 0x191b7c0, 0xc000408110)
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:343 +0xba
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
        /Users/mary/work/temporal-examples/money-transfer-project-template-go/vendor/go.temporal.io/sdk/internal/internal_worker_base.go:270 +0xff
2021/06/21 01:17:37 WARN  Failed to process workflow task. Namespace default TaskQueue TEST_TASK_QUEUE WorkerID 75752@Marys-MacBook-Pro.local@ WorkflowType MyWorkflow WorkflowID my-workflow RunID bfbe63a0-5344-4641-8452-471445bce46c Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 9, activityID: 9
2021/06/21 01:17:37 INFO  Task processing failed with error Namespace default TaskQueue TEST_TASK_QUEUE WorkerID 75752@Marys-MacBook-Pro.local@ WorkerType WorkflowWorker Error Workflow executionsRow not found.  WorkflowId: TEST_TASK_QUEUE, RunId: 768d01d9-aabe-4ccf-9985-7af61f445403
```
- `Query` tab says that no queries are registered:
![image](https://user-images.githubusercontent.com/8646655/122689995-4ce05c00-d22f-11eb-9533-8f38b82d6a9c.png)
## Steps to Reproduce the Problem

  1. Run a workflow that contains two calls to `workflow.GetVersion` in a row:
```
package app

import (
	"context"
	"fmt"
	"time"

	"go.temporal.io/sdk/workflow"
)

func MyWorkflow(ctx workflow.Context) error {
	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		StartToCloseTimeout: time.Minute,
	})

	workflow.GetVersion(ctx, "change-1", workflow.DefaultVersion, 1)

	workflow.GetVersion(ctx, "change-2", workflow.DefaultVersion, 1)

	return workflow.ExecuteActivity(ctx, SendMessage, "foo").Get(ctx, nil)
}

func SendMessage(ctx context.Context, message string) error {
	fmt.Printf("Sending message '%s'\n", message)
	return nil
}
``` 
  2. Open `Query` tab in Temporal UI
  3. Check worker logs

## Specifications

  - Version: `1.7.0`, looks like it got broken somewhere between `1.2.0` and `1.3.0`



#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-22 01:40:46.000 UTC</summary>

Also reported in https://community.temporal.io/t/panic-occurs-for-multiple-changeid/2334/12

</details>


---

<a id="469"></a>

### #469: Propgate Context Cancellations to Workflow Futures which are blocked on `Get(ctx, valuePtr)`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/469 |
| **State** | CLOSED |
| **Author** | daveworth (David E Worth) |
| **Created** | 2021-06-16 16:47:56.000 UTC (4y 6m ago) |
| **Updated** | 2025-08-25 15:23:10.000 UTC |
| **Closed** | 2025-08-25 15:23:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Cancellation of a Context passed to a `WorkflowRun.Get(ctx, valuePtr)` cancels the blocking for the return value rather than the `WorkflowRun` itself.

**Describe the solution you'd like**
[Maxim describes the above as intended](https://temporalio.slack.com/archives/CTDTU3J4T/p1622853305052600?thread_ts=1622851948.052500&cid=CTDTU3J4T).  An additional or different `WorkflowCancelingGet(ctx, valuePtr)` which cancels the workflow allows for the more conventional "cancel all downstream actions because they are too slow or we already have the result we need" behavior as present in Golang web apps and other context-aware applications.  In particular I can imagine a context in which the `WorkflowRun` above has spun off a number of parallel activities in goroutines and are blocking on a Select.  If that takes too long the context can be cancelled and all downstream activities can shut down and return `nil` or another appropriate value/error.

**Additional context**
This issue was created based on Maxim's request in [this](https://temporalio.slack.com/archives/CTDTU3J4T/p1622851948052500) thread in the Temporal Slack.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-25 15:23:09.000 UTC</summary>

Currently no plans to change how `WorkflowRun.Get(ctx, valuePtr)` works. To cancel a workflow you can use `WorkflowClient.CancelWorkflow`

</details>


---

<a id="468"></a>

### #468: Vulnerability CVE-2021-3121

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/468 |
| **State** | CLOSED |
| **Author** | W0nderMuffin |
| **Created** | 2021-06-16 07:17:19.000 UTC (4y 6m ago) |
| **Updated** | 2021-06-16 17:47:47.000 UTC |
| **Closed** | 2021-06-16 17:47:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description


The `github.com/gogo/status:v1.1.0` dependency includes a  vunerability by using outdated protobuf `github.com/gogo/protobuf v1.2.0`

## CVE-2021-3121
An issue was discovered in GoGo Protobuf before 1.3.2. plugin/unmarshal/unmarshal.go lacks certain index validation, aka the "skippy peanut butter" issue.

https://nvd.nist.gov/vuln/detail/CVE-2021-3121

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-16 17:47:42.000 UTC</summary>

SDK [is using](https://github.com/temporalio/sdk-go/blob/master/go.mod#L8) `1.3.2` for a while now.

Here is dependency graph:
```
â¯ go mod graph | grep "gogo/protobuf"
go.temporal.io/sdk github.com/gogo/protobuf@v1.3.2
github.com/gogo/protobuf@v1.3.2 github.com/kisielk/errcheck@v1.5.0
github.com/gogo/protobuf@v1.3.2 github.com/kisielk/gotool@v1.0.0
github.com/gogo/protobuf@v1.3.2 golang.org/x/tools@v0.0.0-20210106214847-113979e3529a
github.com/gogo/status@v1.1.0 github.com/gogo/protobuf@v1.2.0
github.com/grpc-ecosystem/go-grpc-middleware@v1.3.0 github.com/gogo/protobuf@v1.3.2
go.temporal.io/api@v1.4.1-0.20210420220407-6f00f7f98373 github.com/gogo/protobuf@v1.3.2
github.com/gogo/googleapis@v1.4.1 github.com/gogo/protobuf@v1.3.2
```

Latest `gogo/status` is still relying on `v1.2.0`, which I believe is why we see this version in the `go.sum` as well.
But since we have `v1.3.2` in the `go.mod` file, it is the on that is actually in use.

```
â¯ go list -m -json all | grep -A2 "gogo/protobuf"
	"Path": "github.com/gogo/protobuf",
	"Version": "v1.3.2",
	"Time": "2021-01-10T08:01:47Z",
	"Dir": "/home/vit/go/pkg/mod/github.com/gogo/protobuf@v1.3.2",
	"GoMod": "/home/vit/go/pkg/mod/cache/download/github.com/gogo/protobuf/@v/v1.3.2.mod",
	"GoVersion": "1.15"
}
```

I'm going to close this one, please let me know if you have more questions.

</details>


---

<a id="464"></a>

### #464: Add workflow/activity error/panic worker hooks

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/464 |
| **State** | CLOSED |
| **Author** | ingyamilmolinar (ymolinar) |
| **Created** | 2021-06-14 16:27:09.000 UTC (4y 7m ago) |
| **Updated** | 2025-09-26 21:54:08.000 UTC |
| **Closed** | 2025-09-26 21:54:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We use Sentry to capture all failures and errors in our codebase. The current way we are able to do that is to add a line that will recover from panics and then sends them to Sentry. We also send all errors to Sentry within the activity code by adding a wrapper that runs the function and reports the error back to Sentry. Unfortunately, we currently don't have any way of reporting workflow panics.

It would be nice to have as part of the worker's API a hook registration feature which provides the ability to register non-deterministic functions (or activities) that will run just after a workflow or an activity panics/errors and before they are retried.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-26 21:54:08.000 UTC</summary>

This can be done with `Interceptors`, we don't have a Go example using Sentry but we do have a [Python one](https://github.com/temporalio/samples-python/tree/326204aed1238c55a66958ddf138b79a0ff1e32e/sentry).

</details>


---

<a id="461"></a>

### #461: Default retry policy is not set in test framework

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/461 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-06-11 02:12:07.000 UTC (4y 7m ago) |
| **Updated** | 2021-06-21 16:43:37.000 UTC |
| **Closed** | 2021-06-21 16:43:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Activity RetryPolicy is optional, and if not set a default retry policy will be used by server.
We need this same behavior on local unit test.

## Actual Behavior
Retry only happen if you explicitly set the retry policy.

## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>yiminc</strong> commented on 2021-06-11 17:01:14.000 UTC</summary>

Fix by #462 

</details>


---

<a id="457"></a>

### #457: temporal_activity_execution_failure Metric Doesn't Seem to Work

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/457 |
| **State** | CLOSED |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2021-06-08 18:12:41.000 UTC (4y 7m ago) |
| **Updated** | 2021-06-24 17:17:56.000 UTC |
| **Closed** | 2021-06-24 17:17:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior

When activities return an error - even if it is retryable - they should be logged against this metric.

## Actual Behavior

Activity errors don't result in any change for this metric. (Or perhaps another metric is appropriate instead).

I believe this is caused by: https://github.com/temporalio/sdk-go/blob/master/internal/internal_task_handlers.go#L1838. This returns nil for the error, but that means the code here never logs it. 

```
	// Process the activity task.
	request, err := atp.taskHandler.Execute(atp.taskQueueName, activityTask.task)
	if err != nil {
		activityMetricsScope.Counter(metrics.ActivityExecutionFailedCounter).Inc(1)
		return err
	}
```

## Steps to Reproduce the Problem

  1. Have an activity return a retryable error
  2. See that nothing is logged against this metric

## Specifications

  - Version: 1.6.0


#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-24 02:11:48.000 UTC</summary>

Above PR should address the problem, meanwhile if you need it urgently, you should be able to use RPC metric (`temporal_request` with `operation=RespondActivityTaskFailed`). It won't have activity/workflow types and will not account for internal errors (but they are captured in `temporal_activity_execution_failed` so you can combine the two).

</details>


---

<a id="443"></a>

### #443: Add support to de-register workflows and activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/443 |
| **State** | CLOSED |
| **Author** | ingyamilmolinar (ymolinar) |
| **Created** | 2021-05-14 16:36:45.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-27 06:14:53.000 UTC |
| **Closed** | 2021-05-27 06:14:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'm seeing some errors in the temporal workers regarding unknown activities (which were previously registered but no workflow uses anymore):

```
2021/05/14 15:54:24 util.go:27  Task processing failed with error%!(EXTRA string=Namespace, string=default, string=TaskQueue, string=jobs, string=WorkerID, string=1@temporalworker@, string=WorkerType, string=ActivityWorker, string=Error, *errors.errorString=unable to find activityType=Activity1. Supported types: [Activity2, Activity3])
```

This is happening on our staging environment since we test workflows in development there and we cannot just cleanup the database. If I list all the workflows with `tctl`, there is no workflow that is using Activity1.

There's really no way I can tell to avoid this problem. I don't want to register some previous unused activity just to avoid this error from happening if that activity is not going to be used (and I don't want it to be used).

I tried toying with `tctl admin db scan` and `tctl admin db clean` but I get a Cassandra connection issue. (I'm not using Cassandra or ES, I'm using Posgress). See: https://github.com/temporalio/temporal/issues/598


#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-27 06:14:53.000 UTC</summary>

I think there might be some misunderstanding here.
You don't need to "de-register" activities explicitly, you do that by deploying a worker that doesn't register an activity during startup.
If your question is about what happens to the older workflows that are still using old activity that you've deleted then you have two options here:
1. Identify and terminate or reset all workflows that are using old activity.
2. Use [versioning](https://docs.temporal.io/docs/go/versioning/) to branch your code and differentiate between old and new workflows. This way you would keep "old" activity around as long as workflows that are using it exist in the system and then you could go ahead and delete it fully once you only have new workflows that are no longer using it.
I'm going to resolve this issue as I don't see any work on the SDK that needs to be done for it, if you have more questions, please visit our [community forum](https://community.temporal.io/) and post your questions there.

</details>


---

<a id="438"></a>

### #438: Client creation doesn't have any retries if health check intermittently fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/438 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2021-05-10 21:46:03.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-28 03:16:03.000 UTC |
| **Closed** | 2021-05-28 03:16:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Health check code:

```
func checkHealth(connection grpc.ClientConnInterface, options ConnectionOptions) error {
	if options.DisableHealthCheck {
		return nil
	}
	healthClient := healthpb.NewHealthClient(connection)
	request := &healthpb.HealthCheckRequest{
		Service: healthCheckServiceName,
	}
	healthCheckTimeout := options.HealthCheckTimeout
	if healthCheckTimeout == 0 {
		healthCheckTimeout = defaultHealthCheckTimeout
	}
	ctx, cancel := context.WithTimeout(context.Background(), healthCheckTimeout)
	defer cancel()
	resp, err := healthClient.Check(ctx, request)
	if err != nil {
		return fmt.Errorf("health check error: %w", err)
	}
	if resp.Status != healthpb.HealthCheckResponse_SERVING {
		return fmt.Errorf("health check returned unhealthy status: %v", resp.Status)
	}
	return nil
}
```

User's only option is to disable the health check or add retries on their application layer. For checkHealth calls on create client, we may want more sophisticated logic, or at least the ability to configure something via ConnectionOptions

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-27 07:43:59.000 UTC</summary>

@mastermanu what do you think about #453?

</details>


---

<a id="417"></a>

### #417: Error handling documentation outdated

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/417 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-04-28 04:45:41.000 UTC (4y 8m ago) |
| **Updated** | 2023-05-24 08:14:23.000 UTC |
| **Closed** | 2023-05-24 08:14:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
workflow/doc.go contains up-to-date information about failures. It is still referencing CustomError and GenericError.

I think `doc.go` should be completely reviewed to match the current implementation.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-24 08:14:22.000 UTC</summary>

closing as this is fixed in https://github.com/temporalio/sdk-go/pull/879

</details>


---

<a id="416"></a>

### #416: Confusing Docs Around Reuse Policy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/416 |
| **State** | CLOSED |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2021-04-28 00:26:20.000 UTC (4y 8m ago) |
| **Updated** | 2025-08-25 15:29:10.000 UTC |
| **Closed** | 2025-08-25 15:29:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I think this doc could be clarified a bit, I think. In particular, I think the reuse doesn't clarify that this only applies to previously closed workflows: https://community.temporal.io/t/workflow-id-policy-suggestion/1021/2?u=shannon_tan

```
// WorkflowIDReusePolicy - Whether server allow reuse of workflow ID, can be useful
// for dedupe logic if set to RejectDuplicate.
// Optional: defaulted to AllowDuplicate.
WorkflowIDReusePolicy enumspb.WorkflowIdReusePolicy
```

This also makes it a bit confusing when tying it into this following parameter. Is the following line saying that if a workflow had already failed with this ID, and we have this parameter set to false, it'll always return an error? I think what's confusing is that if the WorkflowIDReusePolicy only applies to completed/failed workflows only, I'm not sure how we'd have a "current" or last run.

```
// When WorkflowExecutionErrorWhenAlreadyStarted is true, Client.ExecuteWorkflow will return an error if the
// workflow id has already been used and WorkflowIDReusePolicy would disallow a re-run. If it is set to false,
// rather than erroring a WorkflowRun instance representing the current or last run will be returned.
//
// Optional: defaults to false
WorkflowExecutionErrorWhenAlreadyStarted bool
```

Perhaps it'd be rephrased as:
```
// When WorkflowExecutionErrorWhenAlreadyStarted is true, client.ExecuteWorkflow will return an error if
// a workflow is already in progress with that ID. If false, rather than erroring, a WorkflowRun instance 
// representing the current or last run will be returned. 
// Note that workflow IDs must still conform to WorkflowIDReusePolicy regardless of this setting.
```

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-25 15:29:10.000 UTC</summary>

This documentation was updated a while ago

</details>


---

<a id="413"></a>

### #413: BackoffCoefficient must be defined and not defaulting to default value of 2.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/413 |
| **State** | CLOSED |
| **Author** | cowell21 (Chris Cowell) |
| **Created** | 2021-04-22 17:41:49.000 UTC (4y 8m ago) |
| **Updated** | 2021-08-18 06:04:53.000 UTC |
| **Closed** | 2021-08-18 06:01:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When `BackoffCoefficient` is not defined in `RetryPolicy` struct it should be the default value of `2.0` per documentation in go SDK.  Cited here: https://github.com/temporalio/sdk-go/blob/4b99c26e67e253c718add87dcec54bb0e7fa29a2/internal/client.go#L530-L533

## Actual Behavior
When not defined it throws a error saying `BackoffCoefficient cannot be less than 1 on retry policy` suggesting it is defaulting to something other than `2.0`

## Possible Solutions
Fix code documentation to denote this is a required field and it doesn't have a default value.
OR
When `BackoffCoefficient` is not defined, have it backfill with default value `2.0`.

## Steps to Reproduce the Problem
  1. Create an activity / workflow without `BackoffCoefficient` defined in `RetryPolicy`
  2. Run activity and see err `BackoffCoefficient cannot be less than 1 on retry policy` surface

## Specifications

  - Version: SDK v1.4.1


#### Comments (1)

<details>
<summary><strong>laniehei</strong> commented on 2021-08-18 06:01:43.000 UTC</summary>

I believe this issue was resolved by #462, as I'm not seeing this error surface anywhere but in the unit test. Please reopen if this issue persists.

</details>


---

<a id="412"></a>

### #412: SDK Overview link in the about section on the right side of the repository is broken (page not found)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/412 |
| **State** | CLOSED |
| **Author** | loganintech (Logan Saso) |
| **Created** | 2021-04-21 20:57:34.000 UTC (4y 8m ago) |
| **Updated** | 2021-04-22 15:38:29.000 UTC |
| **Closed** | 2021-04-22 15:38:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | flossypurse |
| **Milestone** | None |

#### Description

This link is dead: https://docs.temporal.io/docs/go-sdk-overview

#### Comments (1)

<details>
<summary><strong>flossypurse</strong> commented on 2021-04-22 15:38:28.000 UTC</summary>

Looks like there was a typo in the redirect rule. Fixed here: https://github.com/temporalio/documentation/pull/369
That link works now, though the actual page URL has changed.

</details>


---

<a id="410"></a>

### #410: Multiple filter support on ListWorkflow client methods

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/410 |
| **State** | CLOSED |
| **Author** | ingyamilmolinar (ymolinar) |
| **Created** | 2021-04-20 22:25:40.000 UTC (4y 8m ago) |
| **Updated** | 2025-09-26 21:49:55.000 UTC |
| **Closed** | 2025-09-26 21:49:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently, there's no way to add multiple filters in a ListClosedWorkflow query meaning if I want to query for the most recent workflow execution of type F with status S I need to get all workflows of type F and then go through each one of those until I get the most recent one that satisfy the requirements. (Or get all workflows with status S and then get the most recent one of type F).

The List*Workflow methods should support multiple Filters instead of just 1 so these types of queries become easier and more efficient since the result set would be smaller.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-26 21:49:55.000 UTC</summary>

`ListClosedWorkflow` has bee superseded by `ListWorkflow` that takes a `query` parameter that can filter on multiple conditions.

</details>


---

<a id="406"></a>

### #406: Activity Retry Policy is ignored in workflow tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/406 |
| **State** | CLOSED |
| **Author** | ingyamilmolinar (ymolinar) |
| **Created** | 2021-04-13 22:23:48.000 UTC (4y 9m ago) |
| **Updated** | 2021-06-11 02:12:31.000 UTC |
| **Closed** | 2021-06-11 02:12:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Workflow testing environment should respect the activity retry policy set in the workflow.Context.

## Actual Behavior
Workflow testing environment is not retrying activities when it should based on the retry policy.

## Steps to Reproduce the Problem
1. Register the following workflow and activity:
```
func Workflow(ctx workflow.Context) error {
ao := workflow.ActivityOptions{
StartToCloseTimeout: 1 * time.Second,
// NOTE: using default retry policy which is unlimited retries
}
ctx = workflow.WithActivityOptions(ctx, ao)

future := workflow.ExecuteActivity(ctx, Activity)
if err := future.Get(ctx, nil); err != nil {
return err
}
return nil
}

func Activity(ctx context.Context) error {
return nil
}
```
2. Write a test for your workflow and mock the activity to return an error once:
```
env.OnActivity(Activity, mock.Anything).Return(errors.New("Error occurred")).Once()
```
3. Verify that the workflow error is nil in your test (because the activity should be retried once after failing):
```
var wts testsuite.WorkflowTestSuite
env = wts.NewTestWorkflowEnvironment()
env.OnActivity(Activity, mock.Anything).Return(errors.New("Error occurred")).Once()

env.ExecuteWorkflow(Workflow)

Expect(env.IsWorkflowCompleted()).To(BeTrue())
Expect(env.GetWorkflowError()).To(BeNil()) // THIS WILL FAIL!
```

## Specifications

  - Version: SDK v1.4.1
  - Platform: Linux 5.7.0-0.bpo.2-amd64 #1 SMP Debian 5.7.10-1~bpo10+1 (2020-07-30) x86_64 GNU/Linux



#### Comments (1)

<details>
<summary><strong>yiminc</strong> commented on 2021-06-11 02:12:30.000 UTC</summary>

Looks like the default retry policy is not set for local unit test environment. If you explicitly set the retry policy, the test should work. 

Here is a working example (for hello world workflow at https://github.com/temporalio/samples-go/tree/master/helloworld):
1) set retry policy in workflow:
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval: time.Second,
			BackoffCoefficient: 2,
			MaximumAttempts: 3,
		},
	}
2) set mock to fail for first attempt:
	env.OnActivity(Activity, mock.Anything, "Temporal").Return(func(ctx context.Context, msg string) (string, error) {
		info := activity.GetInfo(ctx)
		if info.Attempt == 1 {
			return "", errors.New("retry me")
		}

		return Activity(ctx, msg)
	  })

The default policy is set by server, we need to set the default one for test as well. Created a separate issue to track that: https://github.com/temporalio/sdk-go/issues/461

</details>


---

<a id="389"></a>

### #389: Add validation of input addr during client creation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/389 |
| **State** | CLOSED |
| **Author** | wxing1292 (Wenquan Xing) |
| **Created** | 2021-03-26 20:40:41.000 UTC (4y 9m ago) |
| **Updated** | 2023-05-24 08:02:19.000 UTC |
| **Closed** | 2023-05-24 08:02:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
https://github.com/temporalio/sdk-go/blob/555111c79989bec4448edb018ce8a3f48cb98b09/internal/client.go#L329
host port should be validated during client creation.

## Actual Behavior
no validation, the error will only be returned when creating a connection
```
last connection error: connection error: desc = "transport: Error while dialing dial tcp: address 172.22.199.91: missing port in address
```

## Specifications

  - Version: 1.5.1
  - Platform:


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-24 08:02:19.000 UTC</summary>

closing as the original PR was closed because resolution is configurable 

</details>


---

<a id="377"></a>

### #377: Add an ApplicationErrorBuilder

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/377 |
| **State** | CLOSED |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2021-03-02 19:22:17.000 UTC (4y 10m ago) |
| **Updated** | 2025-02-04 18:39:42.000 UTC |
| **Closed** | 2025-02-04 18:39:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I find the NewApplicationError function to be long and verbose in code.

**Describe the solution you'd like**
Create an ApplicationErrorBuilder that would allow chaining to pass in specific fields.

```
nonRetryableError := temporal.NewApplicationErrorBuilder().
	WithCause(err).
	WithMessage("oh no! an error").
	WithNonRetryable(true).
	Build()
```

**Describe alternatives you've considered**
I'm not sure how popular builders are in Golang - we've recently adopted a similar ErrorBuilder at my company, and it is a bit clearer.

**Additional context**
I'm happy to help write this since its not that much effort, but I'd like validation for this proposal first.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:39:38.000 UTC</summary>

We currently have no plans to add an `ApplicationErrorBuilder` they are not a common approach in Go and we do not want to introduce multiple ways to construct an `ApplicationError`

</details>


---

<a id="356"></a>

### #356: Registering Activity Fails Silently When Function Doesn't Match Signature

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/356 |
| **State** | CLOSED |
| **Author** | sjmtan (Shannon Tan) |
| **Created** | 2021-02-11 01:06:14.000 UTC (4y 11m ago) |
| **Updated** | 2021-03-02 18:17:36.000 UTC |
| **Closed** | 2021-03-02 18:17:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior
When registering an activity struct that has methods that don't conform to the expected signature, activity registration should either fail with an error (maybe panic/fail in tests) or skip over the function.

## Actual Behavior
When registering an activity struct that has methods that don't conform to the expected signature because they don't intend on being registered, activity registration fails silently without indication of what method it failed to bind as an activity.

https://github.com/temporalio/sdk-go/blob/master/internal/internal_worker.go#L534

## Steps to Reproduce the Problem
```
type Activity struct {}

func (a *Activity) ActivityMethod(ctx context.Context) error {}
func (a *Activity) OtherMethod(ctx context.Context) {}

...

env.RegisterActivityWithOptions(activities, activity.RegisterOptions{Name: "AsyncInputsActivities_"}) // no failure, no indication
```

## Specifications

  - Version: 1.4.1


#### Comments (1)

<details>
<summary><strong>sjmtan</strong> commented on 2021-02-11 01:06:51.000 UTC</summary>

I think the behavior should be 1 or the other - but not silent failure with only methods processed up until that nonconforming activity registered.

</details>


---

<a id="347"></a>

### #347: regarding change in inputs of running workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/347 |
| **State** | CLOSED |
| **Author** | ru90 |
| **Created** | 2021-01-21 16:20:53.000 UTC (4y 11m ago) |
| **Updated** | 2021-01-21 20:23:20.000 UTC |
| **Closed** | 2021-01-21 20:22:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Can I change input of running workflow with signaling? Is there any sample example for this?.

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-01-21 20:22:33.000 UTC</summary>

Please use our [community forum](https://community.temporal.io/) for questions like this. This makes it easier for others to find in case if someone has a similar problem in the future.

</details>


---

<a id="324"></a>

### #324: Logrus maintaince mode

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/324 |
| **State** | CLOSED |
| **Author** | reidlai (Reid Lai) |
| **Created** | 2020-12-29 14:56:45.000 UTC (5 years ago) |
| **Updated** | 2020-12-29 15:18:40.000 UTC |
| **Closed** | 2020-12-29 15:18:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Because Logrus is in maintenance mode, is there any plan to use zap logger?


#### Comments (1)

<details>
<summary><strong>reidlai</strong> commented on 2020-12-29 15:18:38.000 UTC</summary>

Found can use logur adapter to plug with Temporal..so I'll close this Issue

</details>


---

<a id="309"></a>

### #309: relation "schema_version" does not exist on fresh postgresql DB

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/309 |
| **State** | CLOSED |
| **Author** | hazcod (Niels Hofmans) |
| **Created** | 2020-12-14 08:31:47.000 UTC (5 years ago) |
| **Updated** | 2020-12-14 08:33:43.000 UTC |
| **Closed** | 2020-12-14 08:33:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Setup all necessary stuff in the psql database.

## Actual Behavior
Service fails wtih `relation "schema_version" does not exist.`.

## Steps to Reproduce the Problem
docker-compose:
```yaml
services:

  temporaldb:
    image: cockroachdb/cockroach:v20.1.9
    volumes:
    - data-temporal:/cockroach/cockroach-data
    tty: false
    restart: "on-failure:5"
    security_opt:
    - "no-new-privileges"
    read_only: true
    cap_drop:
    - ALL
    networks:
    - backend

  temporal:
    image: temporalio/server:1.4.1
    restart: "on-failure:5"
    environment:
    - "LOG_LEVEL=warn"
    - "AUTO_SETUP=true"
    - "DB=postgresql"
    - "DB_PORT=26257"
    - "POSTGRES_USER=root"
    - "POSTGRES_PWD=postgres"
    - "POSTGRES_SEEDS=postgres"
    - "SKIP_DEFAULT_NAMESPACE_CREATION=true"
    links:
    - temporaldb:postgres
    ports:
    - 7233
    depends_on:
    - temporaldb
```

Logs:
```
+ DB=postgresql

+ ENABLE_ES=false

+ ES_SCHEMA_SETUP_TIMEOUT_IN_SECONDS=0

+ ES_PORT=9200

+ ES_SCHEME=http

+ ES_VIS_INDEX=temporal-visibility-dev

+ RF=1

+ DEFAULT_NAMESPACE=default

+ DEFAULT_NAMESPACE_RETENTION=1

+ CASSANDRA_PORT=9042

+ export TEMPORAL_CLI_ADDRESS=172.18.0.4:7233

+ TEMPORAL_CLI_ADDRESS=172.18.0.4:7233

+ export KEYSPACE=temporal

+ KEYSPACE=temporal

+ export VISIBILITY_KEYSPACE=temporal_visibility

+ VISIBILITY_KEYSPACE=temporal_visibility

+ export DBNAME=temporal

+ DBNAME=temporal

+ export VISIBILITY_DBNAME=temporal_visibility

+ VISIBILITY_DBNAME=temporal_visibility

+ export DB_PORT=26257

+ DB_PORT=26257

+ '[' '' = autosetup ']'

+ '[' false == true ']'

+ exec bash /start-temporal.sh

+ dockerize -template /etc/temporal/config/config_template.yaml:/etc/temporal/config/docker.yaml

+ IFS=:,

+ read -ra SERVICE_LIST

++ printf -- '--service=%s ' history matching frontend worker

+ SERVICE_ARGS='--service=history --service=matching --service=frontend --service=worker '

+ exec temporal-server --root /etc/temporal --env docker start --service=history --service=matching --service=frontend --service=worker

2020/12/14 08:26:43 Loading config; env=docker,zone=,configDir=/etc/temporal/config

2020/12/14 08:26:43 Loading config files=[/etc/temporal/config/docker.yaml]

Unable to start server: sql schema version compatibility check failed: unable to read DB schema version keyspace/database: temporal error: pq: relation "schema_version" does not exist.
```


#### Comments (1)

<details>
<summary><strong>hazcod</strong> commented on 2020-12-14 08:33:43.000 UTC</summary>

Moving to https://github.com/temporalio/temporal/issues/1088

</details>


---

<a id="305"></a>

### #305: Custom error types inaccessible as they are defined in internal package

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/305 |
| **State** | CLOSED |
| **Author** | shaunco (Shaun) |
| **Created** | 2020-12-06 07:16:01.000 UTC (5y 1m ago) |
| **Updated** | 2020-12-06 07:42:11.000 UTC |
| **Closed** | 2020-12-06 07:42:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Custom error types should be accessible per the docs at https://github.com/temporalio/documentation/blob/master/docs/go-error-handling.md

## Actual Behavior
Custom error types are all defined in https://github.com/temporalio/sdk-go/blob/master/internal/error.go which makes them inaccessible by modules that make use of `go.temporal.io/sdk/client` since `go.temporal.io/sdk/internal` gives `use of internal package go.temporal.io/sdk/internal not allowed`

## Steps to Reproduce the Problem

  1. Try to make use of `go.temporal.io/sdk/internal` from a different module per the docs provided

## Specifications

  - Version: v1.2.0
  - Platform: linux


#### Comments (1)

<details>
<summary><strong>shaunco</strong> commented on 2020-12-06 07:42:11.000 UTC</summary>

Apparently I'm blind, as they are also in `go.temporal.io/sdk/temporal`

</details>


---

<a id="295"></a>

### #295: Data race on cache eviction

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/295 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-11-22 23:50:35.000 UTC (5y 1m ago) |
| **Updated** | 2020-11-23 18:49:16.000 UTC |
| **Closed** | 2020-11-23 18:49:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
No data races

## Actual Behavior

```
==================
WARNING: DATA RACE
Write at 0x00c000120629 by goroutine 124:
  go.temporal.io/sdk/internal.(*coroutineState).close()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:868 +0x5a
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:909 +0x148

Previous read at 0x00c000120629 by goroutine 61:
  go.temporal.io/sdk/internal.(*dispatcherImpl).Close()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:991 +0x174
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Close()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:548 +0xb7
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).Close()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_event_handlers.go:941 +0xb7
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).clearState()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_task_handlers.go:570 +0x20b
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).onEviction()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_task_handlers.go:534 +0xb8
  go.temporal.io/sdk/internal.getWorkflowCache.func1.1()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_task_handlers.go:433 +0x61

Goroutine 124 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:899 +0x1d8
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:298 +0xa9
  go.temporal.io/sdk/test_test.(*tracingOutboundCallsInterceptor).Go()
      /Users/maxim/temporal/temporal-go-sdk/test/integration_test.go:787 +0x1c5
  go.temporal.io/sdk/internal.newDispatcher()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:558 +0x1a9
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_workflow.go:478 +0x2af
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).handleWorkflowExecutionStarted()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_event_handlers.go:955 +0x287
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_event_handlers.go:773 +0x64f
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_task_handlers.go:891 +0x18d6
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_task_handlers.go:778 +0xa64
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_task_pollers.go:286 +0x414
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_task_pollers.go:259 +0xe2
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /Users/maxim/temporal/temporal-go-sdk/internal/internal_worker_base.go:343 +0x1aa
==================
```

## Steps to Reproduce the Problem
I got it executing  TestIntegrationSuite/TestLongRunningActivityWithHB



#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2020-11-23 17:35:10.000 UTC</summary>

@mfateev FYI I made the same fix in https://github.com/temporalio/sdk-go/pull/294 that's in your PR

</details>


---

<a id="275"></a>

### #275: If a retryable workflow returns a non-retryable error that was originally returned by an activity, the workflow still gets retried

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/275 |
| **State** | CLOSED |
| **Author** | umran (Umran Hussain) |
| **Created** | 2020-10-22 22:45:20.000 UTC (5y 2m ago) |
| **Updated** | 2020-10-26 08:22:45.000 UTC |
| **Closed** | 2020-10-26 02:32:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I expect the workflow to not be retried if the type of the error that is returned from the workflow (although originating from an activity) matches one of the non-retryable types specified in the workflow's retry policy.

## Actual Behavior
The workflow keeps getting retried despite the error being a non-retryable type.

## Steps to Reproduce the Problem

1. Define an activity that results in a non-retryable error:

```go
func MyActivity(ctx context.Context) (string, error) {
	return "", temporal.NewApplicationError("this is a rejection", "Rejection")
}
```

2. Define a workflow that returns the error as is from the activity:

```go
func MyWorkflow(ctx workflow.Context) (string, error) {
	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		ScheduleToCloseTimeout: time.Second * 60,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:        time.Second * 1,
			NonRetryableErrorTypes: []string{"Rejection"},
		},
	})

	var result string
	err := workflow.ExecuteActivity(ctx, MyActivity).Get(ctx, &result)
	if err != nil {
		return "", err
	}

	return result, nil
}
```

3. Call the workflow with a retry policy:

```go
func main() {
	c, err := client.NewClient(client.Options{})
	if err != nil {
		log.Fatalln("unable to create Temporal client", err)
	}

	workflowOptions := client.StartWorkflowOptions{
		TaskQueue: "someTaskQueue",
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:        time.Second * 1,
			MaximumAttempts:        30,
			NonRetryableErrorTypes: []string{"Rejection"},
		},
	}

	var result string
	err = c.ExecuteWorkflow(context.Background(), workflowOptions, MyWorkflow).Get(context.Background(), &result)
	if err != nil {
		log.Fatalln(err)
	}

	fmt.Println(result)
}
```

I would expect the workflow to quit on the first attempt, but it keeps getting retried until MaxAttempts is reached.

Note that if I omit the retry policy from workflow options, I get back the error and am able to cast it as temporal.ApplicationError (as expected) and if I call its Type() method, it returns "Rejection".

## Specifications

  - Version: v1.1.0
  - Platform: mac

#### Comments (1)

<details>
<summary><strong>umran</strong> commented on 2020-10-26 02:32:22.000 UTC</summary>

Closing as I think the thread [here](https://community.temporal.io/t/application-error-handling/708) sufficiently clears up the issue

</details>


---

<a id="268"></a>

### #268: Add ability to reject ExecuteWorkflow call on duplicated workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/268 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-10-13 15:57:55.000 UTC (5y 2m ago) |
| **Updated** | 2020-12-23 21:59:17.000 UTC |
| **Closed** | 2020-12-23 21:59:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
If `WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE` is set the `ExecuteWorkflow `call returns result of already existing workflow instead of the `WorkflowExecutionAlreadyStarted` error. This behavior is the best one for the cases when the deduping of ExecuteWorkflow calls is needed. But in some cases, the client needs to know if it is a duplicated call.

**Describe the solution you'd like**
Add `StartWorkflowOptions.FailOnAlreadyStareted` option that would force returning `WorkflowExecutionAlreadyStarted` in this case.

**Describe alternatives you've considered**
Do not return the result of the previous workflow invocation. But it would be a backward incompatible change.



#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2020-12-23 21:59:17.000 UTC</summary>

Dupe of https://github.com/temporalio/sdk-go/issues/220

</details>


---

<a id="243"></a>

### #243: Support proto structs generated by google proto compiler

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/243 |
| **State** | CLOSED |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-08-31 22:55:01.000 UTC (5y 4m ago) |
| **Updated** | 2021-04-29 22:47:14.000 UTC |
| **Closed** | 2021-04-29 22:46:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

Currently only gogo proto structs are supported since we us gogo jsonpb and proto marshaller. This is not very useful as most users will likely use google compiler which is not fully supported by gogo. For example enums are serialized in a wrong way: https://community.temporal.io/t/protos-in-activities-arguments/555.

#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2021-04-29 22:47:14.000 UTC</summary>

It was fixed long time ago.

</details>


---

<a id="233"></a>

### #233: Deprecate and remove disable sticky execution flag

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/233 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-08-14 03:33:02.000 UTC (5y 4m ago) |
| **Updated** | 2021-03-01 19:05:05.000 UTC |
| **Closed** | 2021-03-01 19:05:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We have a bunch of code in GoSDK which was created to be able to release sticky execution feature in backwards compatible manner.  This is no longer needed and should be removed along with any code related to disabling sticky execution.

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2021-03-01 19:05:04.000 UTC</summary>

Was fixed a while back https://github.com/temporalio/sdk-go/pull/318

</details>


---

<a id="220"></a>

### #220: Unable to get WorkflowExecutionAlreadyStartedError

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/220 |
| **State** | CLOSED |
| **Author** | olegmedvedev (Oleg Medvedev) |
| **Created** | 2020-07-29 08:04:41.000 UTC (5y 5m ago) |
| **Updated** | 2020-12-24 17:18:54.000 UTC |
| **Closed** | 2020-12-24 17:18:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

After migration from Uber Cadence to Temporal.io my internal logics are broken. As I see `StartWorkflow` was removed from interface and `ExecuteWorkflow` consumes error `WorkflowExecutionAlreadyStartedError` and returns existing `WorkflowRun`.

## Expected Behavior

Being able to receive `WorkflowExecutionAlreadyStartedError` on `ExecuteWorkflow` if `ReusePolicy` is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`

## Actual Behavior

Unable to receive `WorkflowExecutionAlreadyStartedError` on `ExecuteWorkflow` if `ReusePolicy` is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`


## Steps to Reproduce the Problem

  1. Execute workflow with `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`
  2. Execute workflow with `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY` with the same workflow id again.
  

## Specifications

  - Version: v0.26.0
  - Platform: linux x86_64


#### Comments (1)

<details>
<summary><strong>arxeiss</strong> commented on 2020-12-03 15:12:09.000 UTC</summary>

I just faced a similar issue, but I used the `ReusePolicy` with `WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`.

When I started the workflow with ID, which was already finished or failed, I got a successful message with the last RunID. But nothing was added to the queue and nothing was run.

</details>


---

<a id="208"></a>

### #208: Unix specific API breaks windows development

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/208 |
| **State** | CLOSED |
| **Author** | jarnett (Jesse Arnett) |
| **Created** | 2020-07-24 16:16:52.000 UTC (5y 5m ago) |
| **Updated** | 2020-07-24 21:03:09.000 UTC |
| **Closed** | 2020-07-24 21:03:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

I'm seeing the following after moving my project to v0.27.0
```
# go.temporal.io/sdk/internal
..\..\..\..\..\..\pkg\mod\go.temporal.io\sdk@v0.27.0\internal\internal_worker_base.go:287:9: undefined: syscall.Kill
```
the platform is Windows 10.

#### Comments (1)

<details>
<summary><strong>Lercher</strong> commented on 2020-07-24 18:51:57.000 UTC</summary>

+1  
some advice from elsewhere: https://github.com/bugsnag/bugsnag-go/issues/96

Reactions: ðŸ‘ 2

</details>


---

<a id="194"></a>

### #194: Support seamless cleanup during session cancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/194 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-07-15 18:09:54.000 UTC (5y 5m ago) |
| **Updated** | 2020-10-15 10:54:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
https://community.temporal.io/t/doing-cleanup-when-using-sessions/193

**Describe the solution you'd like**
Cancellation of a workflow should allow executing some cleanup logic in a session without ugly workarounds.




#### Comments (1)

<details>
<summary><strong>linvon</strong> commented on 2020-10-15 10:54:17.000 UTC</summary>

Cleanup in session cannot finished correctly in cancellation of workflow, maybe we can set an option like "keep session info" when use 'NewDisconnectedContext', or export queue of sessionInfo to set queue manually

</details>


---

<a id="183"></a>

### #183: Report connection issues in more user friendly way

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/183 |
| **State** | CLOSED |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-07-08 18:53:56.000 UTC (5y 6m ago) |
| **Updated** | 2020-08-19 20:16:56.000 UTC |
| **Closed** | 2020-08-19 20:16:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, if worker can't connect to the server it gives namespace error which is not clear. More details at: https://community.temporal.io/t/error-unknown-service-workflowservice-workflowservice/103/2.

**Describe the solution you'd like**
Check connection before starting worker and log clear error message such as "Unable connect to Temporal server at localhost:7233"



#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2020-08-19 20:16:56.000 UTC</summary>

Closed by #214.

</details>


---

<a id="149"></a>

### #149: Race in Register...WithOptions due to un-protected map read

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/149 |
| **State** | CLOSED |
| **Author** | Groxx (Steven L) |
| **Created** | 2020-05-30 05:04:13.000 UTC (5y 7m ago) |
| **Updated** | 2020-12-23 00:03:48.000 UTC |
| **Closed** | 2020-12-23 00:03:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

https://github.com/temporalio/temporal-go-sdk/blob/09ced59198a7e5a402ba463a8d11f2952c34dd5e/internal/internal_worker.go#L607

Same core issue as the parent-project: https://github.com/uber-go/cadence-client/issues/979

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2020-12-23 00:03:48.000 UTC</summary>

Issue is stale - map access is properly protected by a map now.

</details>


---

<a id="139"></a>

### #139: Support returning WorkflowExecutionAlreadyStartedError in tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/139 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-22 18:00:22.000 UTC (5y 7m ago) |
| **Updated** | 2023-05-24 07:40:39.000 UTC |
| **Closed** | 2023-05-24 07:40:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/uber-go/cadence-client/pull/969

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-24 07:40:39.000 UTC</summary>

closing since looks like this was resolved https://github.com/temporalio/sdk-go/commit/e204e07feb1328c2828fa4bbebd0cf92ebe2c8f1

</details>


---

<a id="127"></a>

### #127: Enable ContextPropagator for ExecuteLocalActivity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/127 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-11 15:29:30.000 UTC (5y 8m ago) |
| **Updated** | 2020-07-14 05:08:41.000 UTC |
| **Closed** | 2020-07-14 05:08:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It looks like the ContextPropagator is invoked only inside ExecuteActivity and not ExecuteLocalActivity.

#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2020-07-14 05:08:29.000 UTC</summary>

This was fixed in Cadence and cherry picked by us: https://github.com/uber-go/cadence-client/commit/ccea6a6fb6d5f219e0c1abf5b5573bbc3cce4072.

</details>


---

<a id="116"></a>

### #116: Selector should match closed channel once

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/116 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-30 22:18:14.000 UTC (5y 8m ago) |
| **Updated** | 2021-03-02 03:02:31.000 UTC |
| **Closed** | 2021-03-02 03:02:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | mfateev |
| **Milestone** | Code Complete |

#### Description

Currently the following code:

```
selector.AddReceive(cancelCtx.Done(), func(c workflow.Channel, more bool) {
   c.Receive(ctx, nil)
   workflow.GetLogger(ctx).Info("1")
})

for {
  selector.Select()
}
```

is going to loop forever without blocking if `context Done()` channel is closed. We should match it only once the same way it is done for a `Future`.

#### Comments (1)

<details>
<summary><strong>samarabbas</strong> commented on 2020-07-31 18:23:39.000 UTC</summary>

We will tackle this during stabilization.

</details>


---

<a id="94"></a>

### #94: Worker Start/Stop behavior

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/94 |
| **State** | CLOSED |
| **Author** | sagikazarmark (MÃ¡rk SÃ¡gi-KazÃ¡r) |
| **Created** | 2020-04-09 13:57:54.000 UTC (5y 9m ago) |
| **Updated** | 2020-07-23 16:17:43.000 UTC |
| **Closed** | 2020-07-23 16:12:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | Code Complete |

#### Description

I'm reopening uber-go/cadence-client#642

Listening to signals should be left to the caller.

Something closer to a work actor like this would be nice:

https://github.com/sagikazarmark/appkit/pull/7

Then again, this is probably not the highest priority right now.

#### Comments (1)

<details>
<summary><strong>sagikazarmark</strong> commented on 2020-07-23 16:17:42.000 UTC</summary>

Awesome! ðŸŽ‰ 

</details>


---

<a id="86"></a>

### #86: Add ability to call healthcheck from WorkflowClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/86 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-04 16:02:09.000 UTC (5y 9m ago) |
| **Updated** | 2020-07-28 17:57:27.000 UTC |
| **Closed** | 2020-07-28 17:57:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | Code Complete |

#### Description

Customer request:

> does temporal client have something similar to Ping() ?
> c, err := client.NewClient(client.Options{
> 		HostPort: <WRONG_HOSTPORT>,
> 	})
> when I start a workflow worker with the above, no error is returned until when you do something â€” would be nice to have something similar to SELECT 1 in postgres

My proposal is to add ability to call grpc health check endpoint of the frontends.

#### Comments (1)

<details>
<summary><strong>samarabbas</strong> commented on 2020-07-15 20:51:00.000 UTC</summary>

Make sure API has support to do that in the future.

</details>


---

<a id="75"></a>

### #75: Test_WorkflowLocalActivityWithMockAndListeners is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/75 |
| **State** | CLOSED |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-03-23 23:29:35.000 UTC (5y 9m ago) |
| **Updated** | 2020-07-14 00:18:05.000 UTC |
| **Closed** | 2020-07-14 00:18:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

```
    --- FAIL: TestUnitTestSuite/Test_WorkflowLocalActivityWithMockAndListeners (0.00s)
        internal_workflow_testsuite_test.go:1751: PASS:	func1(string,string)
        internal_workflow_testsuite_test.go:1752:
            	Error Trace:	internal_workflow_testsuite_test.go:1752
            	Error:      	Not equal:
            	            	expected: 2
            	            	actual  : 1
            	Test:       	TestUnitTestSuite/Test_WorkflowLocalActivityWithMockAndListeners
        internal_workflow_testsuite_test.go:1761:
            	Error Trace:	internal_workflow_testsuite_test.go:1761
            	Error:      	Should be true
            	Test:       	TestUnitTestSuite/Test_WorkflowLocalActivityWithMockAndListeners
```

After few restarts test usually pass.

#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2020-07-14 00:18:05.000 UTC</summary>

Closed by #182.

</details>


---

<a id="72"></a>

### #72: Add code linting to the SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/72 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-03-22 16:56:13.000 UTC (5y 9m ago) |
| **Updated** | 2024-03-13 15:28:27.000 UTC |
| **Closed** | 2024-03-13 15:28:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We need a linter to check for common mistakes that violate SDK imposed restrictions in workflow and activity implementations.
We can base it on the contributed one: https://github.com/sagikazarmark/cadencelint

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-13 15:28:27.000 UTC</summary>

Closing since this is solved with the [workflowchecker](https://github.com/temporalio/sdk-go/tree/master/contrib/tools/workflowcheck)

</details>


---

<a id="50"></a>

### #50: Make TestWorkflowEnvironment support test multiple workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/50 |
| **State** | OPEN |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-03-03 21:56:23.000 UTC (5y 10m ago) |
| **Updated** | 2020-03-04 18:03:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently, the TestWorkflowEnvironment can run multiple workflows but only for parent-child relationships. It would be good to be able to use TestWorkflowEnvironment to test 2 workflows that are not parent-child.

#### Comments (1)

<details>
<summary><strong>samarabbas</strong> commented on 2020-03-03 21:56:37.000 UTC</summary>

Ported from: Uber Cadence GO: Issue 616

</details>


---

<a id="49"></a>

### #49: Context used for ExecuteActivity is ignored or SideEffect ignores parameters

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/49 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-03-03 21:54:37.000 UTC (5y 10m ago) |
| **Updated** | 2020-03-03 21:54:53.000 UTC |
| **Closed** | 2020-03-03 21:54:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I have a workflow that contains a snippet like this:

```
options := workflow.ActivityOptions{
		ScheduleToStartTimeout: 60 * time.Minute,
		StartToCloseTimeout:    60 * time.Minute,
		ScheduleToCloseTimeout: 60 * time.Minute,
		HeartbeatTimeout:       5 * time.Minute,
		ActivityID:             activities.GenerateID(ctx, "partprocessor"),
	}
	partProcessorContext := workflow.WithActivityOptions(ctx, options)

	completeEntityCtx := workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		ScheduleToStartTimeout: 5 * time.Second,
		StartToCloseTimeout:    10 * time.Minute,
		ScheduleToCloseTimeout: 10 * time.Minute,
		HeartbeatTimeout:       10 * time.Minute,
		ActivityID:             activities.GenerateID(ctx, "completeentity"),
	})

	var runPartProcessorOutput activities.RunPartProcessorOutput
	err := workflow.ExecuteActivity(partProcessorContext, activities.RunPartProcessor, partID).Get(partProcessorContext, &runPartProcessorOutput)
```

`GenerateID` above calls `workflow.SideEffect` to generate an id for our activities.

```
func GenerateID(ctx workflow.Context, activityName string) string {
	encodedActivityID := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {
		return workflow.GetInfo(ctx).WorkflowExecution.ID + "-" + activityName + "-" + uuid.New()
	})
	var activityID string
	err := encodedActivityID.Get(&activityID)
	if err != nil {
		panic(err)
	}
	return activityID
}
```

When I run this code, `RunPartProcessor` activity ends up with an id that contains the word `completeentity`. So not sure if the problem is that I've called `SideEffect` twice in a row with different parameters. Or if `ExecuteActivity` is using the latest context created instead of the context I explicitly passed.

Here's my test that fails:

```
func TestWorkflow(t *testing.T) {
	t.Run("WhenSuccessfulExpectsWorkflowCompleted", func(t *testing.T) {
		// arrange - variables
		s := &testsuite.WorkflowTestSuite{}
		env := s.NewTestWorkflowEnvironment()
		partID := 32
		expectedRunPartProcessorOutput := &activities.RunPartProcessorOutput{}

		// arrange - mock activities
		mockPartProcessorActivity := func(ctx context.Context, partID int) (*activities.RunPartProcessorOutput, error) {
			activityInfo := activity.GetInfo(ctx)
			env.RegisterDelayedCallback(func() {
				err := env.CompleteActivity(activityInfo.TaskToken, expectedRunPartProcessorOutput, nil)
				assert.NoError(t, err)
			}, time.Second)
			return nil, activity.ErrResultPending
		}

		env.OnActivity(activities.RunPartProcessor, mock.Anything, partID).Return(mockPartProcessorActivity)
		env.OnActivity(activities.CompleteEntity, mock.Anything, keys.PartManager, partID, 0, "").Return(nil)

		// arrange - setup listeners
		env.SetOnActivityCompletedListener(func(activityInfo *activity.Info, result encoded.Value, err error) {
			switch activityInfo.ActivityType.Name {
			case "github.com/3dsim/workflow/activities.RunPartProcessor":
				if err != nil && err != activity.ErrResultPending {
					assert.FailNow(t, err.Error())
				}
				assert.NotEmpty(t, activityInfo.ActivityID, "Expected part processor to have completed")
				assert.Contains(t, activityInfo.ActivityID, "partprocessor", "Expected activity id for RunPartProcessor to contain the word 'partprocessor'")
			case "github.com/3dsim/workflow/activities.CompleteEntity":
				assert.Contains(t, activityInfo.ActivityID, "completeentity", "Expected activity id for CompleteEntity to contain the word 'completeentity'")
				assert.NotEmpty(t, activityInfo.ActivityID, "Expected completeEntity to have completed")
			default:
				t.Fatal("Unknown activity type: " + activityInfo.ActivityType.Name)
			}
		})

		// act
		env.ExecuteWorkflow(Workflow, partID)

		// assert
		assert.True(t, env.IsWorkflowCompleted(), "Expected workflow to complete")
		assert.NoError(t, env.GetWorkflowError(), "Expected no errors")
		env.AssertExpectations(t)
	})
}
```

#### Comments (1)

<details>
<summary><strong>samarabbas</strong> commented on 2020-03-03 21:54:52.000 UTC</summary>

Ported from https://github.com/uber-go/cadence-client/issues/372

</details>


---

<a id="38"></a>

### #38: Remove path prefix from activity and workflow type names

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/38 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-24 20:42:05.000 UTC (5y 10m ago) |
| **Updated** | 2020-11-23 23:43:38.000 UTC |
| **Closed** | 2020-11-23 23:43:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | mfateev |
| **Milestone** | None |

#### Description

This is current name of a workflow:

`go.temporal.io/temporal/internal.splitJoinActivityWorkflow`

This make moving workflows between directories hard and forces specifying string name for every workflow.

The proposal is to change it to `splitJoinActivityWorkflow`

#### Comments (1)

<details>
<summary><strong>samarabbas</strong> commented on 2020-07-15 20:55:43.000 UTC</summary>

Add capitalization of first letter.  Already fixed.  Verify and close.

</details>


---

<a id="36"></a>

### #36: Add support for cross namespace activity and child workflow scheduling

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/36 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-18 23:04:48.000 UTC (5y 10m ago) |
| **Updated** | 2025-02-04 18:41:17.000 UTC |
| **Closed** | 2025-02-04 18:41:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Works on the server side on a single cluster, but as soon as you enable cross DC it will break.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-04 18:41:15.000 UTC</summary>

This will be solved with [Nexus](https://docs.temporal.io/nexus)

</details>


---

<a id="2"></a>

### #2: Pass function result by pointer to the DataConverter for consistency

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2019-10-31 10:52:14.000 UTC (6y 2m ago) |
| **Updated** | 2020-07-25 01:50:28.000 UTC |
| **Closed** | 2020-07-25 01:50:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | Code Complete |

#### Description

Currently when deserializing arguments they are passed as pointer. But when deserializing a function result it is passed by value into DataConverter.fromData. I believe the result should be also passed as pointer to be consistent.

#### Comments (1)

<details>
<summary><strong>alexshtin</strong> commented on 2020-07-25 01:50:28.000 UTC</summary>

It seems that this problem is already fixed somehow (refactoring or external merges).

</details>


---

<a id="2140"></a>

### #2140: OpenTelemetry incorrect metric type for Counter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2140 |
| **State** | OPEN |
| **Author** | LaurynasKatkus |
| **Created** | 2026-01-07 12:26:43.000 UTC (2 days ago) |
| **Updated** | 2026-01-07 12:26:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When I use `contrib/opentelemetry` as MetricsHandler in `client.Dial(client.Options{})`, I expect that Counter metrics will have `_total` suffix as describe in Prometheus. They do not.

## Actual Behavior

As per [Temporal metric documentation](https://docs.temporal.io/references/sdk-metrics#workflow_completed), `workflow_completed` metric is of type Counter. According to [Prometheus documentation](https://prometheus.io/docs/specs/om/open_metrics_spec/#counter-1):

> The MetricPoint's Total Value Sample MetricName MUST have the suffix _total

When I expose metrics using `contrib/opentelemetry`, instead of Tally, the `workflow_completed` is described as Gauge, not as Counter.

Support for OpenTelemetry was added with this [issue](https://github.com/temporalio/sdk-go/issues/1137).

## Steps to Reproduce the Problem

I have used https://github.com/temporalio/samples-go/tree/main/metrics as a base. Instead of Tally, I have wired worker to use OTEL:

```
func main() {
	reader, err := prometheusexporter.New()
	if err != nil {
		fmt.Errorf("error creating prometheus exporter: %w", err)
	}

	meterProvider := sdkmetric.NewMeterProvider(sdkmetric.WithReader(reader))
	otel.SetMeterProvider(meterProvider)

	// Start Prometheus HTTP server using the registry
	go func() {
		log.Println("Serving Prometheus metrics on :9090/metrics")
		http.Handle("/metrics", promhttp.Handler())
		if err := http.ListenAndServe(":9090", nil); err != nil {
			log.Fatalln("Failed to start Prometheus server", err)
		}
	}()

	// The client and worker are heavyweight objects that should be created once per process.
	c, err := client.Dial(client.Options{
		MetricsHandler: opentelemetry.NewMetricsHandler(opentelemetry.MetricsHandlerOptions{
			Meter: meterProvider.Meter("temporal-sdk"),
		}),
	})
	if err != nil {
		log.Fatalln("Unable to create client", err)
	}
	defer c.Close()

	w := worker.New(c, "metrics", worker.Options{})

	w.RegisterWorkflow(metrics.Workflow)
	w.RegisterActivity(metrics.Activity)

	err = w.Run(worker.InterruptCh())
	if err != nil {
		log.Fatalln("Unable to start worker", err)
	}

	// Shutdown the MeterProvider
	if err := meterProvider.Shutdown(context.Background()); err != nil {
		log.Println("Error shutting down meter provider:", err)
	}
}
```

The rest is the same.

## Specific Problem

OpenTelemetry handler implements Counter as `m.meter.Int64UpDownCounter(name)`. Within the test of Counter, it explicitly tests whether Counter is [not monotonic](https://github.com/temporalio/sdk-go/blob/master/contrib/opentelemetry/handler_test.go#L81). In opentelemetry-go prometheus exporter, it [explicitly checks](https://github.com/open-telemetry/opentelemetry-go/blob/exporters/prometheus/v0.61.0/exporters/prometheus/exporter.go#L523) whether the type Sum is monotonic or not. If it is not - then it is Gauge value.

I have created a local patch with one change in `handler` `Counter` method:
```
func (m MetricsHandler) Counter(name string) client.MetricsCounter {
	c, err := m.meter.Int64Counter(name)
        ...
}
```

Then it works as expected.

## Specifications

  - Version: Golang version 1.25.5, go.temporal.io/sdk v1.38.0, go.temporal.io/sdk/contrib/opentelemetry v0.6.0
  - Platform: macOS Sequoia Version 15.7.2



---

<a id="2124"></a>

### #2124: Support non-workflow activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2124 |
| **State** | OPEN |
| **Author** | maciejdudko (Maciej Dudkowski) |
| **Created** | 2025-12-02 17:20:25.000 UTC (1 months ago) |
| **Updated** | 2025-12-02 17:20:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Allow executing activities without a workflow. The clients must support the new (upcoming) server APIs for starting, managing and getting results of activities. The workers must support running activities outside of workflow context.

**Additional context**

Server API PR (WIP): https://github.com/temporalio/api/pull/640


---

<a id="2123"></a>

### #2123: [api-go] Proxy: allow payload visitor to run in parallel

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2123 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-12-02 16:31:30.000 UTC (1 months ago) |
| **Updated** | 2025-12-16 18:00:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When visiting payloads in the proxy my visitor is slow and would benefit from being run in parellel

**Describe the solution you'd like**
Add an option to the proxy visitor to allow paralleziation. Users should be able to control the max concurrency factor. The default should still be no concurrency.




---

<a id="2114"></a>

### #2114: Set GrpcMessageTooLarge as failure_reason for workflow task failed metric

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2114 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-11-19 04:29:10.000 UTC (1 months ago) |
| **Updated** | 2025-11-20 17:59:57.000 UTC |
| **Closed** | 2025-11-20 17:59:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/695


---

<a id="2111"></a>

### #2111: workflow_completed and workflow_continue_as_new counters should be logged after a successful reporting to the server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2111 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-11-17 15:07:08.000 UTC (1 months ago) |
| **Updated** | 2025-12-01 23:09:18.000 UTC |
| **Closed** | 2025-12-01 23:09:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/222


---

<a id="2108"></a>

### #2108: Allow overriding of the Worker Deployment Version when invoking a Child Workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2108 |
| **State** | CLOSED |
| **Author** | chris-olszewski (Chris Olszewski) |
| **Created** | 2025-11-12 16:21:31.000 UTC (1 months ago) |
| **Updated** | 2025-12-03 08:18:28.000 UTC |
| **Closed** | 2025-12-03 08:18:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Users want to override the target version on a workflow, especially when doing pre-deployment testing. This should work the same as it does when creating a Workflow from a client.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
https://github.com/temporalio/features/issues/694



---

<a id="2106"></a>

### #2106: Poller Autoscaling can't scale past InitialNumberOfPollers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2106 |
| **State** | CLOSED |
| **Author** | jjaegerman (Jonathan Jaegerman) |
| **Created** | 2025-11-07 23:19:47.000 UTC (2 months ago) |
| **Updated** | 2025-11-17 17:26:54.000 UTC |
| **Closed** | 2025-11-17 17:26:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Given sufficient computational capacity, worker slots, and task queue backlog, an autoscaling poller should increase number of pollers to a number greater than `InitialNumberOfPollers` to pick up more work (up to `MaxinumNumberOfPollers` pollers).

## Actual Behavior
An autoscaling poller is incapable of running more than `InitialNumberOfPollers` concurrent pollers.

## Steps to Reproduce the Problem
  1. Enable Poller Autoscaling

e.g.
```
workerOpts := worker.Options{
  ActivityTaskPollerBehavior = worker.NewPollerBehaviorAutoscaling(worker.PollerBehaviorAutoscalingOptions{InitialNumberOfPollers: 1})
  WorkflowTaskPollerBehavior = worker.NewPollerBehaviorAutoscaling(worker.PollerBehaviorAutoscalingOptions{InitialNumberOfPollers: 1})
}
[...]
```
  2. Run a high volume of resource-light tasks

I specifically ran 2048 workflows at the same time, each of which execute one no-op (`time.Sleep(1 second)`) activity every second on a loop for 15 minutes. The worker was configured with the poller behavior above (1 initial poller for activities and workflows).

I observed `temporal_num_pollers` stay at 1 for each worker type despite minimal cpu/memory utilization, ample free worker slots, and significant workflow task schedule to start latency (~30s average).

## Specifications

  - Version: `v1.37.0`
  - Platform: n/a



---

<a id="2094"></a>

### #2094: Worker Heartbeating

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2094 |
| **State** | OPEN |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-10-28 01:50:19.000 UTC (2 months ago) |
| **Updated** | 2025-10-28 01:50:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**
Implement worker heartbeating, which is sent via a new background nexus worker.

Basically need to design a Go version of https://github.com/temporalio/sdk-core/pull/953 and https://github.com/temporalio/sdk-core/pull/1038

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="2092"></a>

### #2092: go.temporal.io/sdk/contrib/envconfig docs mention wrong path

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2092 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-10-27 15:12:40.000 UTC (2 months ago) |
| **Updated** | 2025-10-27 20:50:13.000 UTC |
| **Closed** | 2025-10-27 20:50:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

In multiple places in `envconfig` package, `[os.UserConfigDir]/temporal/temporal.toml` is mentioned, but it should be `[os.UserConfigDir]/temporalio/temporal.toml`.


---

<a id="2090"></a>

### #2090: Starting a child workflow in tests leaks goroutines

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2090 |
| **State** | OPEN |
| **Author** | mbark (Martin Wohlfart) |
| **Created** | 2025-10-24 07:17:10.000 UTC (2 months ago) |
| **Updated** | 2025-10-24 07:18:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

If a child workflow is started and terminates during the test no go routine should be left once the test completes.

## Actual Behavior

A go routine is left running from `executeChildWorkflowWithDelay` which doesn't seem to terminate.

## Steps to Reproduce the Problem

  1. Create a test that runs a Workflow that starts a ChildWorkflow.
  2. Use `defer goleak.VerifyNone(s.T())`

I've added a [repo](https://github.com/mbark/temporal-childwf-reproduction) to illustrate how to reproduce the issue, see the file `do_test.go`:

```go
type TestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
}

func Test(t *testing.T) {
	suite.Run(t, new(TestSuite))
}

func ChildWorkflow(ctx workflow.Context) error {
	return workflow.Sleep(ctx, 24*time.Hour)
}

func ParentWorkflow(ctx workflow.Context) error {
	return workflow.ExecuteChildWorkflow(ctx, "ChildWorkflow", nil).Get(ctx, nil)
}

func (s *TestSuite) TestChildWorkflow() {
	defer goleak.VerifyNone(s.T())
	env := s.NewTestWorkflowEnvironment()
	env.RegisterWorkflow(ChildWorkflow)
	env.RegisterWorkflow(ParentWorkflow)

	env.ExecuteWorkflow(ParentWorkflow)
	err := env.GetWorkflowError()
	s.Require().NoError(err)

	env.AssertExpectations(s.T())
}
```

## Specifications

  - Version: `v1.37.0`
  - Platform: -



---

<a id="2089"></a>

### #2089: Add resource tuner metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2089 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-10-23 22:52:41.000 UTC (2 months ago) |
| **Updated** | 2025-12-17 02:21:33.000 UTC |
| **Closed** | 2025-12-17 02:21:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The CPU/mem usage metrics that are present in Core/Java are absent here. https://docs.temporal.io/references/sdk-metrics#resource_slots_cpu_usage for reference.

Add them (and possibly also the pid value metrics, though those are less obviously useful and could be skipped).


---

<a id="2086"></a>

### #2086: [go] Plugin + SimplePlugin

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2086 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2025-10-20 21:22:50.000 UTC (2 months ago) |
| **Updated** | 2025-10-20 21:25:03.000 UTC |
| **Closed** | 2025-10-20 21:24:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Implement Plugins so that users can self-serve creating integrations with Temporal Workflows.  This is done in Python and we can copy.


---

<a id="2085"></a>

### #2085: Add support for firstExecutionRunId to cancel and terminate

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2085 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-10-20 17:30:09.000 UTC (2 months ago) |
| **Updated** | 2025-10-20 17:30:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add support for `firstExecutionRunId` to cancel and terminate so users can target a workflow execution chain

**Describe the solution you'd like**
add methods like `cancelWithOptions` and `terminateWithOptions` that take an options struct to pass `firstExecutionRunId`



---

<a id="2083"></a>

### #2083: Use normal task queue name for sticky task queue client metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2083 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-10-17 21:41:10.000 UTC (2 months ago) |
| **Updated** | 2025-10-20 17:27:48.000 UTC |
| **Closed** | 2025-10-20 17:27:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Port https://github.com/temporalio/sdk-core/pull/1039


---

<a id="2053"></a>

### #2053: Expose Temporal Nexus operation info to Temporal Nexus operation authors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2053 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-09-13 20:52:07.000 UTC (3 months ago) |
| **Updated** | 2025-09-22 18:28:23.000 UTC |
| **Closed** | 2025-09-22 18:28:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/674



---

<a id="2045"></a>

### #2045: Ensure tests exist to confirm custom slot supplier slot info has proper fields

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2045 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-09-05 12:30:17.000 UTC (4 months ago) |
| **Updated** | 2025-09-05 12:30:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/672


---

<a id="2034"></a>

### #2034: [Feature Request] Reclassify Benign Application errors in OpenTelemetry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2034 |
| **State** | CLOSED |
| **Author** | THardy98 (Thomas Hardy) |
| **Created** | 2025-08-26 20:39:14.000 UTC (4 months ago) |
| **Updated** | 2025-11-14 17:46:29.000 UTC |
| **Closed** | 2025-11-14 17:46:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See issue description here:

https://github.com/temporalio/sdk-python/issues/1041


---

<a id="2033"></a>

### #2033: Flaky tests: TestIntegrationSuite/TestGrpcMessageTooLarge

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2033 |
| **State** | CLOSED |
| **Author** | maciejdudko (Maciej Dudkowski) |
| **Created** | 2025-08-26 18:35:09.000 UTC (4 months ago) |
| **Updated** | 2025-09-02 14:51:27.000 UTC |
| **Closed** | 2025-09-02 14:51:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

#2026 added `TestIntegrationSuite/TestGrpcMessageTooLarge` test suite. It's sometimes failing in CI.

The cause is unknown, but one potential theory is that it's due to timeouts. The test should be rewritten so that it does not rely on timing of errors.


---

<a id="2031"></a>

### #2031: Add Go to Waitgroup

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2031 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-08-26 15:32:07.000 UTC (4 months ago) |
| **Updated** | 2025-08-26 19:54:06.000 UTC |
| **Closed** | 2025-08-26 19:54:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The SDK has a workflow safe version of `Waitgroup`, recently Go 1.25 added `Waitgroup.Go`. The SDK should also have a similar method for consistency.

https://pkg.go.dev/sync#WaitGroup





---

<a id="2030"></a>

### #2030: Move RESOURCE_EXHAUSTED_CAUSE_EXT_GRPC_MESSAGE_TOO_LARGE to upstream API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2030 |
| **State** | CLOSED |
| **Author** | maciejdudko (Maciej Dudkowski) |
| **Created** | 2025-08-26 14:59:43.000 UTC (4 months ago) |
| **Updated** | 2025-09-02 14:51:26.000 UTC |
| **Closed** | 2025-09-02 14:51:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

#2026 added a constant `RESOURCE_EXHAUSTED_CAUSE_EXT_GRPC_MESSAGE_TOO_LARGE` as an extension of the ResourceExhaustedCause enum for better handling of gRPC message too large errors. To avoid compatibility issues, the upstream API definition of the enum should have this constant added (with the next ordinal integer value and without `EXT` in the name). After that, the SDK code should be changed to remove the extension constant and use the constant in upstream API instead.


---

<a id="2025"></a>

### #2025: Fix DescribeTaskQueueEnhanced w/ stats to use non-deprecated APIs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2025 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-08-19 22:05:28.000 UTC (4 months ago) |
| **Updated** | 2025-08-19 22:06:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently, this call is still using a variety of now-deprecated APIs. Fix it to use the non-deprecated fields.

`TestTaskQueueStats` should then have the lines referencing this issue uncommented


---

<a id="2024"></a>

### #2024: Set Span Kinds in Otel tracer interceptors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2024 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-08-19 16:14:07.000 UTC (4 months ago) |
| **Updated** | 2025-11-14 17:44:13.000 UTC |
| **Closed** | 2025-11-14 17:44:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
Python, .NET, and Ruby all set span kinds in their OTel tracer interceptors

**Describe the solution you'd like**
A clear and concise description of what you want to happen.
Go should also set their span kinds. `client` as the outbound span kind, and `server` as the inbound span kind

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="2020"></a>

### #2020: Plugin support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2020 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-08-15 14:32:26.000 UTC (4 months ago) |
| **Updated** | 2026-01-07 17:06:56.000 UTC |
| **Closed** | 2026-01-07 17:06:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/652


---

<a id="2015"></a>

### #2015: Remove usage of deprecated `Control` fields

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2015 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-08-06 21:48:07.000 UTC (5 months ago) |
| **Updated** | 2025-08-25 15:41:06.000 UTC |
| **Closed** | 2025-08-25 15:41:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
There is a deprecated `control` field still used in Go in a few spots. One spot: https://github.com/temporalio/sdk-go/blob/eca0bb454260f34ca6b873b73c7353dafb4f7ebb/internal/internal_event_handlers.go#L1275

This needs to be removed since it may be yeeted from server at some point in the future (and no other SDKs use it)

**Describe the solution you'd like**
Seemingly, this is just being set to event number. Just use event number instead, and cover it with some tests.


---

<a id="2006"></a>

### #2006: Add a compiler check to ensure the WorkflowReplayer interface implements the WorkflowRegistry interface.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2006 |
| **State** | CLOSED |
| **Author** | GSmithApps (Grant) |
| **Created** | 2025-07-25 17:41:30.000 UTC (5 months ago) |
| **Updated** | 2025-07-30 23:15:02.000 UTC |
| **Closed** | 2025-07-30 23:15:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When we added dynamic workflows, the `WorkflowReplayer` stopped implementing the `WorkflowRegistry` interface.

**Describe the solution you'd like**
Add a compiler check to ensure the `WorkflowReplayer` interface implements the `WorkflowRegistry` interface. The main implication of this is that we need to add `RegisterDynamicWorkflow` to the workflow replayer.

**Describe alternatives you've considered**
Another option is removing the two explicit register calls onÂ `WorkflowReplayer`Â and embeddingÂ `WorkflowRegistry`Â interface there and implementingÂ `RegisterDynamicWorkflow`Â on the workflow replayer.


---

<a id="2005"></a>

### #2005: OnWorkflow test mocker doesn't propagate context headers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/2005 |
| **State** | OPEN |
| **Author** | codemonkeycxy (Xinyi Chen) |
| **Created** | 2025-07-20 00:00:18.000 UTC (5 months ago) |
| **Updated** | 2025-07-20 00:00:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
If the parent workflow adds headers to the workflow context it passes to the child workflow, I would expect to be able to verify those headers using OnWorkflow mocker

## Actual Behavior
OnWorkflow mocker was not able to see the headers passed through the workflow context from the parent workflow

## Steps to Reproduce the Problem

  1. gh repo clone codemonkeycxy/nexus-exp
  2. go test
  3. You can see `Test_ChildWorkflowContextPropagation` passes as expected, which confirms the header passing is working and the child workflow can see it
  4. But `Test_ChildWorkflowContextPropagation_Matcher` fails, which means the headers are not viewable via the OnWorkflow mocker

## Specifications

  - Version: v1.24.0
  - Platform:
  ```
uname -a
Darwin Xinyis-Laptop.local 24.5.0 Darwin Kernel Version 24.5.0: Tue Apr 22 19:54:49 PDT 2025; root:xnu-11417.121.6~2/RELEASE_ARM64_T6000 arm64
```


---

<a id="1999"></a>

### #1999: DataConverter silent all encoding error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1999 |
| **State** | CLOSED |
| **Author** | cedricmoulard (CÃ©dric Moulard) |
| **Created** | 2025-07-11 11:22:18.000 UTC (6 months ago) |
| **Updated** | 2025-07-15 22:29:21.000 UTC |
| **Closed** | 2025-07-15 22:29:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I am using data converter to encrypt sensible data in payload. I am managing many encryption keys and raise an error if i'm not able to get a valid key.

```
// Encode implements converter.PayloadCodec.Encode.
func (e *Codec) Encode(payloads []*commonpb.Payload) ([]*commonpb.Payload, error) {
	result := make([]*commonpb.Payload, len(payloads))
	for index, payload := range payloads {

		[...]

		key, err := e.getKey(e.KeyID)
		if err != nil {
			return nil, fmt.Errorf("no encryption key found for key id %s: %w", e.KeyID, err)
		}

		[...]
	}

	return result, nil
}
```

I expect to get an error since temporal use the Encode method but I got the plaintext payload

## Actual Behavior

This code silent the error an return the parent payload
```
encodedPayloads, err := e.encode([]*commonpb.Payload{payload})
	if err != nil {
		return payload, nil
	}
```

https://github.com/temporalio/sdk-go/blame/78b8535e80732c93c46df818b91d916da322dc0d/converter/codec.go#L159

Is it the good and expected behavior?

## Steps to Reproduce the Problem

  1. Create a codec that raise an error on the `Encode` method
  2. Add DataConverter to worker

## Specifications

  - Version: 1.35.0
  - Platform:



---

<a id="1997"></a>

### #1997: workflowRunOperationToken should not encode version if 0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1997 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-07-10 21:08:40.000 UTC (6 months ago) |
| **Updated** | 2025-07-10 22:46:26.000 UTC |
| **Closed** | 2025-07-10 22:46:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

workflowRunOperationToken should not encode version if 0



---

<a id="1988"></a>

### #1988: Add Summary to LocalActivityOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1988 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-07-02 17:51:42.000 UTC (6 months ago) |
| **Updated** | 2025-07-03 22:30:41.000 UTC |
| **Closed** | 2025-07-03 22:30:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See parent features issue for details https://github.com/temporalio/features/issues/637



---

<a id="1983"></a>

### #1983: Expose StartToCloseTimeout in ActivityInfo struct

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1983 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-06-25 14:03:51.000 UTC (6 months ago) |
| **Updated** | 2025-07-04 17:31:48.000 UTC |
| **Closed** | 2025-07-04 17:31:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Similarly to what Java sdk exposes in ActivityInfo - https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/activity/ActivityInfo.java#L73 


---

<a id="1971"></a>

### #1971: [go] Add `WorkflowTaskFailedCause` to `RespondQueryTaskCompletedRequest`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1971 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-06-13 21:27:44.000 UTC (6 months ago) |
| **Updated** | 2025-08-01 23:04:40.000 UTC |
| **Closed** | 2025-08-01 23:04:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Should work the same as for workflow task failures


---

<a id="1963"></a>

### #1963: GetWorkerStopChannel no longer indicates worker shutdown for Local Activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1963 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-05-30 19:08:55.000 UTC (7 months ago) |
| **Updated** | 2025-06-26 01:44:56.000 UTC |
| **Closed** | 2025-06-26 01:44:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`GetWorkerStopChannel()` should indicate that a worker has begun shutting down


## Actual Behavior
`GetWorkerStopChannel()` for local activities now indicates when the local activity specific stop channel has closed. This is due to https://github.com/temporalio/sdk-go/pull/1875.

The solution should be to also keep the worker stop channel in the Local Activity poller and have GetWorkerStopChannel() return that, while also ensuring shutdown behaves properly and the LA specific stop channel is closed at the right time.

Once this is fixed, see TODO comment linking this issue in integration tests and have Local Activity wait on that channel closure, instead of a manual time wait, to avoid potential race conditions


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:



---

<a id="1948"></a>

### #1948: Remove license headers from files in api-go

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1948 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-05-02 16:07:50.000 UTC (8 months ago) |
| **Updated** | 2025-05-05 19:06:08.000 UTC |
| **Closed** | 2025-05-05 19:06:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Following server in https://github.com/temporalio/temporal/pull/7689, license headers are no longer required on files. Remove from all files in the `api-go` repository and remove any tooling that generates them or requires them. Note this includes generated files too.


---

<a id="1947"></a>

### #1947: Remove license headers from files

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1947 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-05-02 16:03:14.000 UTC (8 months ago) |
| **Updated** | 2025-05-05 18:59:00.000 UTC |
| **Closed** | 2025-05-05 18:59:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Following server in https://github.com/temporalio/temporal/pull/7689, license headers are no longer required on files. Remove from all files in the SDK and remove any tooling that generates them or requires them.


---

<a id="1943"></a>

### #1943: `SearchAttributes.Copy` is getting flagged by `workflowcheck`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1943 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-30 12:38:17.000 UTC (8 months ago) |
| **Updated** | 2025-05-15 17:29:27.000 UTC |
| **Closed** | 2025-05-15 17:29:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Need to mark `SearchAttributes.Copy` as ignored by `workflowcheck`



---

<a id="1931"></a>

### #1931: [go] SDK support for activity reset

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1931 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2025-04-23 19:08:09.000 UTC (8 months ago) |
| **Updated** | 2025-09-19 18:54:32.000 UTC |
| **Closed** | 2025-09-19 18:54:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/620


---

<a id="1930"></a>

### #1930: Have implicit activity context timeout start-to-close be relative to system time not server time

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1930 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-23 13:09:53.000 UTC (8 months ago) |
| **Updated** | 2025-06-05 17:40:04.000 UTC |
| **Closed** | 2025-06-05 17:40:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Currently the code at https://github.com/temporalio/sdk-go/blob/a92189071ec5931c88a97284d60b8b06f1024fc3/internal/activity.go#L444-L454 has start-to-close calculated from server-provided start time instead of current system time which means it may be subject to skew (ref #1912). Have it based on `time.Now()` instead. Note, nothing can be done about schedule-to-start equivalent because there is no local-time equivalent for "scheduled".


---

<a id="1921"></a>

### #1921: [api-go] Remove cloud submodule and cloud protos

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1921 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-18 13:01:21.000 UTC (8 months ago) |
| **Updated** | 2025-04-29 16:54:49.000 UTC |
| **Closed** | 2025-04-29 16:54:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Now that https://github.com/temporalio/cloud-sdk-go exists and now that #1831 has been out for a couple of releases now, we should remove the cloud submodule and cloud protos from https://github.com/temporalio/api-go, mentioning in the PR that https://github.com/temporalio/cloud-sdk-go is the home for them now.


---

<a id="1919"></a>

### #1919: Show retry policy on activity info

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1919 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-17 12:23:43.000 UTC (8 months ago) |
| **Updated** | 2025-09-23 17:43:37.000 UTC |
| **Closed** | 2025-09-23 17:43:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/615


---

<a id="1908"></a>

### #1908: Apply application failure logging and metrics behaviour according to ApplicationErrorCategory

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1908 |
| **State** | CLOSED |
| **Author** | THardy98 (Thomas Hardy) |
| **Created** | 2025-04-09 18:26:17.000 UTC (9 months ago) |
| **Updated** | 2025-04-25 21:58:07.000 UTC |
| **Closed** | 2025-04-25 21:58:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See corresponding features issue:
https://github.com/temporalio/features/issues/614



---

<a id="1899"></a>

### #1899: Heartbeating activities should be interrupted when the activities are paused.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1899 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2025-04-01 23:43:13.000 UTC (9 months ago) |
| **Updated** | 2025-04-14 17:55:15.000 UTC |
| **Closed** | 2025-04-14 17:55:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/602


---

<a id="1889"></a>

### #1889: [api-go] Support proxy interceptor returning valid response and error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1889 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-03-26 20:48:45.000 UTC (9 months ago) |
| **Updated** | 2025-05-01 00:04:02.000 UTC |
| **Closed** | 2025-05-01 00:04:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
An interceptor can return an error with valid response

## Actual Behavior
Today when we hit an error, we immediately return the error, not visiting the payload/failure.


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:



---

<a id="1886"></a>

### #1886: [api-go] failure converter/payload codec interceptor order issue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1886 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-03-26 01:05:07.000 UTC (9 months ago) |
| **Updated** | 2025-03-26 21:31:10.000 UTC |
| **Closed** | 2025-03-26 21:31:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Payloads created by the failure converter should be visited by the payload visitor interceptor.

## Actual Behavior
If you set the failure converter to use encoded failures and you have the failures interceptor after the payload visitor interceptor, you may miss intercepting payloads created by the failure converter.

We should consider documenting above NewFailureVisitorInterceptor and NewPayloadVisitorInterceptor in this package, and above NewFailureGRPCClientInterceptor and NewPayloadCodecGRPCClientInterceptor in the go.temporal.io/sdk/converter package that failure converter should come before payload codec converter.

## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:



---

<a id="1874"></a>

### #1874: Document that local activities should not use anonymous functions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1874 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-03-18 15:59:09.000 UTC (9 months ago) |
| **Updated** | 2025-03-31 17:38:28.000 UTC |
| **Closed** | 2025-03-31 17:38:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We should document  that local activities should not use anonymous functions, even though it is technically allowed. This is because the function name, and therefore activity type, can be non deterministic and it is easy for the local activity to capture local variable which is also dangerous


---

<a id="1869"></a>

### #1869: SetOnChildWorkflowCompletedListener doesn't work as expected

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1869 |
| **State** | OPEN |
| **Author** | nicovak (Kovacs Nicolas) |
| **Created** | 2025-03-14 13:07:24.000 UTC (10 months ago) |
| **Updated** | 2025-03-14 13:07:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

As see with @Quinn-With-Two-Ns on slack, i'm posting issue here.

## Expected Behavior

Testing an async child workflow error should be catch by `SetOnChildWorkflowCompletedListener`. That is not the case right now.

## Actual Behavior

The listener is not invoked.

## Steps to Reproduce the Problem

[Github Repo Example](https://github.com/nicovak/child-wf-listener)

## Specifications

  - Version:
go.temporal.io/api v1.44.1
go.temporal.io/sdk v1.33.0
  - Platform: Mac OS



---

<a id="1868"></a>

### #1868: ResourceBasedSlotSupplier.ReleaseSlot not implemented

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1868 |
| **State** | CLOSED |
| **Author** | captchanjack-anzx |
| **Created** | 2025-03-13 02:53:25.000 UTC (10 months ago) |
| **Updated** | 2025-03-14 18:57:27.000 UTC |
| **Closed** | 2025-03-14 18:57:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Activity SlotSupplier created with `resourcetuner.NewResourceBasedSlotSupplier` should release activity slots when they are completed.

## Actual Behavior
Activity slots are not released after task is completed. This causes scheduled activities to forever hand in `PENDING_ACTIVITY_STATE_SCHEDULED` state.

I suspect because the SlotSupplier interface method ReleaseSlot is not implemented:

https://github.com/temporalio/sdk-go/blob/master/contrib/resourcetuner/resourcetuner.go#L204

## Steps to Reproduce the Problem

  1. Create a tuner with `worker.NewCompositeTuner` and `resourcetuner.NewResourceBasedSlotSupplier` as suggested in [go-sdk docs](https://docs.temporal.io/develop/worker-performance#go-sdk)
  1. Set activity `ResourceBasedSlotSupplierOptions.MaxSlots` to something small like 4.
  1. Start a worker with tuner set in worker.Options
  1. Execute a workflow that starts a large amount of activities - few activities should be scheduled, and others should be schedule/stuck in pending state.

## Specifications

  - Version:
  ```
        go.temporal.io/api v1.44.1
	go.temporal.io/sdk v1.33.0
	go.temporal.io/sdk/contrib/resourcetuner v0.0.0-20250227195219-884681f7392e
```
  - Platform: GCP Cloud Run, 8 cores 8GiB per instance, unsure chip used (i think amd based)



---

<a id="1861"></a>

### #1861: Add summary to Nexus operation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1861 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-03-11 18:37:39.000 UTC (10 months ago) |
| **Updated** | 2025-03-20 15:55:45.000 UTC |
| **Closed** | 2025-03-20 15:55:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/610


---

<a id="1860"></a>

### #1860: testsuite.TestUpdateCallback method should be given no-ops when not provided

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1860 |
| **State** | CLOSED |
| **Author** | mnichols (Mike Nichols) |
| **Created** | 2025-03-10 00:11:29.000 UTC (10 months ago) |
| **Updated** | 2025-04-14 21:29:21.000 UTC |
| **Closed** | 2025-04-14 21:29:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

I should be able to just provide a callback for `OnComplete` in the `testsuite.TestUpdateCallbacks`. 
Either that, or I should get an error that tells me what is really wrong (not nil pointer).

## Actual Behavior

This doesn't seem to check that each callback is provided so will panic when invoked downstream. These `nil pointer` exceptions are super hard to understand coming out of this test suite and make testing brittle with UpdateWorkflow. 

I recommend we either:
1. catch the error and provided a more meaningful error
2. (better) provide no-op stubs when a particular callback is not provided (eg `OnAccept: func() {}`)

Somewhere in here probably:
https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_testsuite.go#L2986

## Steps to Reproduce the Problem

This will fail because I don't have `OnAccept` provided as a noop.
IMO this should be an opt-in facility.

```
package myworkflow

import (
	"fmt"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/workflow"
	"testing"
)

func MyWorkflow(ctx workflow.Context) error {

	if err := workflow.SetUpdateHandler(
		ctx,
		"add",
		func(ctx workflow.Context) (int, error) {
			fmt.Printf("UpdateHandler called")
			return 42, nil
		}); err != nil {

		return fmt.Errorf("could not set update: %w", err)
	}
	return nil
}

func TestUpdateReturnsAppropriateResponse(t *testing.T) {
	A := assert.New(t)
	R := require.New(t)

	s := &testsuite.WorkflowTestSuite{}

	env := s.NewTestWorkflowEnvironment()

	env.RegisterWorkflow(StandaloneScreening)
	env.RegisterDelayedCallback(func() {
		env.UpdateWorkflow("add", uuid.New().String(), &testsuite.TestUpdateCallback{
			//  uncomment this callback to let it pass
                         // OnAccept: func() {},
			OnReject: func(err error) {
				R.NoError(err)
			},
			OnComplete: func(i interface{}, err error) {
				fmt.Printf("OnComplete: %v\n", i)
			},
		})
	}, 0)
	env.ExecuteWorkflow(MyWorkflow)
	err := env.GetWorkflowError()
	R.NoError(err)
	A.True(env.IsWorkflowCompleted())
	A.NoError(env.GetWorkflowError())
}

```


## Specifications

  - Version:
  - Platform:



---

<a id="1848"></a>

### #1848: Expose root workflow execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1848 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-25 14:14:53.000 UTC (10 months ago) |
| **Updated** | 2025-04-21 16:19:02.000 UTC |
| **Closed** | 2025-04-21 16:19:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/605. Due to how list and describe work in this SDK, only need to do the workflow info part probably.



---

<a id="1846"></a>

### #1846: AsTime() on a nil pointer converts to  Jan. 1st, 1970 at midnight UTC

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1846 |
| **State** | OPEN |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2025-02-25 00:25:30.000 UTC (10 months ago) |
| **Updated** | 2025-02-25 00:25:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The protobuf library maps a nil timestamp to Jan. 1st, 1970 at midnight UTC and makes IsZero() false. One side effect is that the cli  `cardOmitEmpty` and `omitEmpty` no longer filter timestamps that have not been initialized. This is also a problem for users of the raw grpc API.

`(*timestamppb.Timestamp)(nil).AsTime().IsZero() // FALSE!`

The solution is to check with `IsValid()` before calling `AsTime()`



---

<a id="1843"></a>

### #1843: Built-in query responses should use "RawValue"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1843 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-21 20:31:15.000 UTC (10 months ago) |
| **Updated** | 2025-04-02 15:11:56.000 UTC |
| **Closed** | 2025-04-02 15:11:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/604. When #1231 is done, make sure built-in queries return a raw value


---

<a id="1839"></a>

### #1839: Remove old Nexus workflow run operation token format

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1839 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-20 23:02:06.000 UTC (10 months ago) |
| **Updated** | 2025-04-23 15:18:37.000 UTC |
| **Closed** | 2025-04-23 15:18:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Remove old workflow run operation token format support, treat all un-parsable tokens as a handler error. Similar to Java equivalent at https://github.com/temporalio/sdk-java/issues/2423.


---

<a id="1838"></a>

### #1838: Non-deterministic workflow code can send incorrect WFT completion without task failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1838 |
| **State** | OPEN |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2025-02-20 19:04:40.000 UTC (10 months ago) |
| **Updated** | 2025-02-20 19:04:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/sdk-go/pull/1835 repros a situation in which non-deterministic workflow code sends an incorrect WFT completion without task failure, causing a invalid update state transition in History service.

The test causes a workflow to execute two WFTs. On WFT 2, it changes a boolean flag in the workflow making the code non-deterministic.

WFT1 is triggered by an update-with-start (update ID A) and is responded to by accepting & completing that update. 

WFT2 is triggered by an update (update ID B).

However, when responding to WFT2, the SDK re-sends acceptance and completion messages for update A, which is incorrect.


---

<a id="1829"></a>

### #1829: doclink: Incorrect "Exposed" requirement in method without context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1829 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2025-02-18 04:36:06.000 UTC (10 months ago) |
| **Updated** | 2025-04-10 17:13:15.000 UTC |
| **Closed** | 2025-04-10 17:13:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

##  Actual Behavior
```
	// WorkerDeploymentHandle is a handle to a Worker Deployment.
	// NOTE: Experimental
	//
	// Exposed as: [go.temporal.io/sdk/client.WorkerDeploymentHandle]
	WorkerDeploymentHandle interface {
        ...
        }
	// WorkerDeploymentClient is the client that manages Worker Deployments.
	// NOTE: Experimental
	//
	// Exposed as: [go.temporal.io/sdk/client.WorkerDeploymentClient]
	WorkerDeploymentClient interface {
		// GetHandle returns a handle to a Worker Deployment.
		//
		// This method does not validate the Worker Deployment Name. If there is no deployment
		// with that name in this namespace, methods like WorkerDeploymentHandle.Describe()
		// will return an error.
		// NOTE: Experimental
		//
		// Exposed as: [go.temporal.io/sdk/client.WorkerDeploymentHandle]    <----- WRONG, not needed, added by -fix
		GetHandle(name string) WorkerDeploymentHandle
       }
```

Missing doc in internal/worker_deployment_client.go for internal:WorkerDeploymentHandle to client:WorkerDeploymentHandle
2025/02/17 20:19:49 Changes needed, see previous stdout for which objects. Re-run command with -fix to auto-generate new docs.

Got above after running `-fix`

## Expected Behavior
It should not add/require Exposed in GetHandle

See https://github.com/temporalio/sdk-go/pull/1814




---

<a id="1827"></a>

### #1827: TestNumPollersCounter consistently fails on stable macos-arm in CI

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1827 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-02-14 21:23:54.000 UTC (10 months ago) |
| **Updated** | 2025-02-19 23:40:41.000 UTC |
| **Closed** | 2025-02-19 23:40:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
workflow_task expected pollers should be 2 in the test

## Actual Behavior
metric is only showing up as 1

## Steps to Reproduce the Problem

  1. Run CI after https://github.com/temporalio/sdk-go/pull/1816 but before https://github.com/temporalio/sdk-go/pull/1826
  1. haven't been able to repro locally
  1.

## Specifications

  - Version:
  - Platform:



---

<a id="1825"></a>

### #1825: [api-go] Proxy gRPC interceptors in should visit payloads and failures of gRPC errors too

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1825 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-14 19:20:39.000 UTC (10 months ago) |
| **Updated** | 2025-03-26 21:35:13.000 UTC |
| **Closed** | 2025-03-26 21:35:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

In `api-go`, `NewPayloadVisitorInterceptor` should visit payloads in the status details of gRPC errors as well, and `NewFailureVisitorInterceptor` should do the same for visiting failures. Try to keep in mind performance, but there may be no choice but to unpack the any, visit, and repack.


---

<a id="1817"></a>

### #1817: Expose Workflow cancel cause/reason

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1817 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-02-11 20:44:23.000 UTC (11 months ago) |
| **Updated** | 2025-02-11 20:44:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

WorkflowExecutionCancelRequestedEventAttributes has a cause field that should be exposed when workflows receive cancels, and we should additionally expose this as an input when users are issuing cancels from clients or commands


---

<a id="1815"></a>

### #1815: Environment configuration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1815 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-11 18:36:52.000 UTC (11 months ago) |
| **Updated** | 2025-04-21 17:22:25.000 UTC |
| **Closed** | 2025-04-01 14:21:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/441 and https://github.com/temporalio/proposals/blob/master/all-sdk/external-client-configuration.md


---

<a id="1812"></a>

### #1812: Doc tool flags missing annotations on variable declarations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1812 |
| **State** | CLOSED |
| **Author** | stephanos (Stephan Behnke) |
| **Created** | 2025-02-10 21:06:30.000 UTC (11 months ago) |
| **Updated** | 2025-02-13 02:05:17.000 UTC |
| **Closed** | 2025-02-13 02:05:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Running `internal/cmd/build/main.go` via `go run . check` fails if there's a doc comment on a function variable declaration without `Exposed as:`.

## Actual Behavior

It should ignore variable declarations in functions.

## Steps to Reproduce the Problem

For example:
```
// If the priority only contains default values, return nil instead
// - since there's no need to send the default values to the server.
var defaultPriority Priority
```

See https://github.com/temporalio/sdk-go/pull/1792/commits/5ff0c1c6cf928545bf22caa66a6e7d85b3677bb8




---

<a id="1811"></a>

### #1811: [api-go] Code gen for payload visiting should walk all descriptors instead of workflow service reachability

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1811 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-10 20:06:29.000 UTC (11 months ago) |
| **Updated** | 2025-02-18 17:28:59.000 UTC |
| **Closed** | 2025-02-18 17:28:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Today the codegen for https://pkg.go.dev/go.temporal.io/api/proxy has a big switch statement built on recursive reachability from workflow service (and a couple of other places). This causes orphaned proto messages (i.e. ones not referenced in that object graph) to be missed. We should change the code generator to walk the file descriptors of the entire proto repo so we know we catch them all.

This goes along with https://github.com/temporalio/sdk-go/issues/1809.


---

<a id="1810"></a>

### #1810: Change application error to Nexus HandlerError conversion to use non-retryable internal errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1810 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2025-02-10 19:52:07.000 UTC (11 months ago) |
| **Updated** | 2025-04-30 16:10:45.000 UTC |
| **Closed** | 2025-04-30 16:10:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Needs to be done before the Go SDK goes GA and after the server 1.27.0 release.


_Originally posted by @Quinn-With-Two-Ns in https://github.com/temporalio/sdk-go/pull/1802#discussion_r1946829532_
            


---

<a id="1796"></a>

### #1796: Add `Patched()` and `DeprecatePatch()` APIs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1796 |
| **State** | OPEN |
| **Author** | mjameswh (James Watkins-Harvey) |
| **Created** | 2025-01-29 23:35:41.000 UTC (11 months ago) |
| **Updated** | 2025-01-29 23:39:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

### Describe the solution you'd like

In short:

- Add the `Patched(patchId, memoized): boolean` and `DeprecatePatch(patchId, memoized): boolean` APIs. Refer to Core's implementation (once it is ready).

- (Maybe) Deprecate the `GetVersion` API.

See temporalio/features#591 for details.


---

<a id="1788"></a>

### #1788: Allow customization of dev server UI port

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1788 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-01-24 13:25:29.000 UTC (11 months ago) |
| **Updated** | 2025-02-08 19:49:50.000 UTC |
| **Closed** | 2025-02-08 19:49:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/588



---

<a id="1779"></a>

### #1779: Special behavior for Temporal built-in prefixes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1779 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-01-15 13:11:05.000 UTC (11 months ago) |
| **Updated** | 2025-02-11 06:42:51.000 UTC |
| **Closed** | 2025-02-11 06:42:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/576 (note most already solved in Go)


---

<a id="1778"></a>

### #1778: Rename Worker Deployment API interfaces

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1778 |
| **State** | OPEN |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2025-01-14 20:13:21.000 UTC (11 months ago) |
| **Updated** | 2025-01-14 20:13:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Some interfaces of the Worker Deployment API are changing to reflect the embedding of the Rollout API within a Deployment.





---

<a id="1777"></a>

### #1777: Add ramp to Worker Deployments

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1777 |
| **State** | OPEN |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2025-01-14 20:08:20.000 UTC (11 months ago) |
| **Updated** | 2025-01-14 20:08:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add support for the ramp API to Worker Deployments. A ramp gracefully transitions Workflows and
Activity tasks between two implementations.



---

<a id="1776"></a>

### #1776: Provide flag to tell the update handler that the handling is from a re-apply

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1776 |
| **State** | OPEN |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2025-01-14 16:41:43.000 UTC (12 months ago) |
| **Updated** | 2025-01-14 16:41:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | â¤ï¸ 1 |

#### Description

See https://github.com/temporalio/features/issues/564


---

<a id="1774"></a>

### #1774: Doclink bug: duplicate "Exposed as" strings being generated

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1774 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-01-13 22:08:32.000 UTC (12 months ago) |
| **Updated** | 2025-01-14 18:38:09.000 UTC |
| **Closed** | 2025-01-14 18:38:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
A single "// Exposed as" docstring to add and maintain

## Actual Behavior
Duplicate docstrings are being generated.

## Steps to Reproduce the Problem
  1. Add a new alias, then run the tool with `-fix`
  1.
  1.

Originally noticed in #1770

## Specifications

  - Version:
  - Platform:



---

<a id="1761"></a>

### #1761: Provide client from activity context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1761 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-01-07 14:27:52.000 UTC (1 years ago) |
| **Updated** | 2025-01-28 17:23:12.000 UTC |
| **Closed** | 2025-01-28 17:23:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Allow users to access Temporal client from within an activity. This is likely a `GetClient(context.Context)` function in the `activity` package, but there may be circular import concerns. If so, maybe this is a `GetClientInActivity(context.Context)` function in the `client` package. Up to implementer. See https://github.com/temporalio/features/issues/203.


---

<a id="1760"></a>

### #1760: Provide "workflow local"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1760 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-01-07 13:40:36.000 UTC (1 years ago) |
| **Updated** | 2025-01-07 13:48:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Users need a workflow-local var that is scoped only to the current workflow when accessed via code.

Rough sketch: 

* A user can have `var myValue workflow.LocalVar[string]`
* `myValue.Get(ctx)` returns the workflow-specific value (zero value if never set, no need for a `TryGet`, a user can choose to wrap in nil-able type for optional/unset if needed)
* `myValue.Set(ctx, value)` sets the workflow-specific value

This is basically just type-safe sugar for top-level context value. See https://github.com/temporalio/features/issues/571.


---

<a id="1756"></a>

### #1756: Malformed code links in API docs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1756 |
| **State** | CLOSED |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2024-12-15 17:23:02.000 UTC (1 years ago) |
| **Updated** | 2025-02-11 17:32:19.000 UTC |
| **Closed** | 2025-02-11 17:32:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

There are various places in the API docs where the intention was to create a link, but the API docs renderer has not created a link. It looks like relevant documentation for creating links is at https://pkg.go.dev/github.com/fluhus/godoc-tricks#hdr-Documentation_Links-Links. We should do a pass  replacing malformed links with correct links.


Examples:

https://pkg.go.dev/go.temporal.io/sdk@v1.31.0/internal#UpdateWorkerVersioningRulesOptions
```
UpdateWorkerVersioningRulesOptions is the input to [Client.UpdateWorkerVersioningRules]
```

https://pkg.go.dev/go.temporal.io/sdk@v1.31.0/client#UpdateWithStartWorkflowOptions
```
UpdateWorkerVersioningRulesOptions is the input to [Client.UpdateWorkerVersioningRules]
```

https://pkg.go.dev/go.temporal.io/sdk@v1.31.0/internal#WithStartWorkflowOperation
```
WithStartWorkflowOperation defines how to start a workflow when using UpdateWithStartWorkflow. See [NewWithStartWorkflowOperation] and [UpdateWithStartWorkflow]
```




---

<a id="1739"></a>

### #1739: Fail registration of workflow types without versioning behavior

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1739 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-12-03 02:49:51.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-16 14:58:55.000 UTC |
| **Closed** | 2024-12-16 14:58:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Worker Versioning-3 adds the notion of workflow behavior to decide whether to
migrate existing workflows to new Build IDs. The worker can specify a default, 
but if there is no default, and it is not provided as an option for that workflow, 
it should fail. 

The current server implementation ignores the `UseVersioning` flag
and relies on missing behavior info to disable versioning. Therefore,
the server cannot fail the task, it has to be the SDK...

The solution proposed does two things:
- Removes the programmatic API to set versioning behavior. It is fragile, there 
is not a clear use case for the flexibility added, and makes it hard to fail workflows early (without side-effects).
- Add a check at workflow type registration to fail registration when there is no default, and no value provided.



---

<a id="1737"></a>

### #1737: `WorkflowTestSuite.UpdateWorkflow` should generate an update ID if none is set like the `WorkflowClient`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1737 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-12-02 23:36:49.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-03 21:25:50.000 UTC |
| **Closed** | 2024-12-03 21:25:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
`WorkflowTestSuite.UpdateWorkflow` should generate an update ID if none is set like the `WorkflowClient`. Currently if no update ID is set when calling `WorkflowTestSuite.UpdateWorkflow` the update ID is just treated as an empty string. This is confusing because it does not match the client behaviour.

**Additional context**
https://temporalio.slack.com/archives/CTDTU3J4T/p1733075499953679


---

<a id="1732"></a>

### #1732: Session worker delays with single activity limit after Tuner introduction

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1732 |
| **State** | CLOSED |
| **Author** | sevein (JesÃºs GarcÃ­a Crespo) |
| **Created** | 2024-11-29 05:14:51.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-02 22:23:31.000 UTC |
| **Closed** | 2024-12-02 22:23:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When `MaxConcurrentActivityExecutionSize` is set to `1`, session workers used to process activity executions in a session without delays, maintaining timely execution.

## Actual Behavior

After the introduction of worker tuners, session workers no longer process activities within a session promptly when `MaxConcurrentActivityExecutionSize` is set to `1`. Activities experience significant delays (~120 seconds) before execution begins. Increasing `MaxConcurrentActivityExecutionSize` to 3, or configuring a fixed-size tuner with `3` slots for activity tasks, resolves the issue.

## Steps to Reproduce the Problem

  1. Use SDK v1.29.0 or newer, specifically including commit a1d05a6f990da31143a702806e5915ef5a860e59 (https://github.com/temporalio/sdk-go/pull/1546), 
  2. Configure the worker with `EnableSessionWorker: true` and `MaxConcurrentActivityExecutionSize: 1`,
  3. Build a workflow with a series of small activities, all executed within a session.
  4. Observe the behavior:
      - Every other activity in the session takes ~120 seconds to complete.
      - The Temporal UI shows the `Activity Task Scheduled` event and `PENDING_ACTIVITY_STATE_SCHEDULED`.
      - After the delay, the `Activity Task Started` and `Activity Task Completed` events appear. Despite the worker completing the activity quickly (under a second), it delays starting execution.

## Specifications

  - Version: SDK v1.29.0 or newer
  - Platform: Linux



---

<a id="1725"></a>

### #1725: Add accessors for ChildWorkflowExecutionError fields

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1725 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-11-25 23:48:00.000 UTC (1y 1m ago) |
| **Updated** | 2024-11-26 05:22:54.000 UTC |
| **Closed** | 2024-11-26 05:22:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
`ChildWorkflowExecutionError` has private fields that users have no way to access today

**Describe the solution you'd like**
Add accessors to `ChildWorkflowExecutionError` to access those fields 

**Additional context**
https://github.com/temporalio/sdk-go/issues/496


---

<a id="1713"></a>

### #1713: Support the Deployment API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1713 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-11-19 19:05:25.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-03 05:08:26.000 UTC |
| **Closed** | 2024-12-03 05:08:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The Deployment API https://github.com/temporalio/api/pull/479 is a low-level API that enables Worker versioning-3 by providing a CRUD interface to manage deployments. 

It also enables directly setting the current deployment target, forcing redirection or creation of workflows to a different worker pool.

This is an experimental API part of the versioning-3 effort.


---

<a id="1700"></a>

### #1700: Test environment shouldn't default to SdkFlags being true

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1700 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2024-11-01 17:15:01.000 UTC (1y 2m ago) |
| **Updated** | 2025-01-21 22:23:52.000 UTC |
| **Closed** | 2025-01-21 18:55:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
SdkFlags should be off by default

## Actual Behavior
Test environment assumes they are on by default.


## Steps to Reproduce the Problem

  1.`createNewDispatcher()` automatically sets flags to true

## Specifications

  - Version: 1.30.0
  - Platform:



---

<a id="1698"></a>

### #1698: Enable type-scoped Versioning Behavior for workflows  

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1698 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-10-30 21:09:50.000 UTC (1y 2m ago) |
| **Updated** | 2024-12-03 20:14:58.000 UTC |
| **Closed** | 2024-12-03 20:14:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Versioning-3 introduces behavior annotations for workflows  that could change what Build ID will be used for a workflow next task.

The current API is programmatic, and requires invoking *SetVersioningBehavior()* during the first workflow task. This gives extra 
flexibility for dynamic workflows but can be error-prone.

This issue suggests an alternative approach which associates a default behavior to a workflow type, using a new option for workflow registration.

**Describe the solution you'd like**

Add the option `DefaultVersioningBehavior` to `workflow.RegisterOptions`, providing a default behavior for all workflows of a particular type that do not use the programmatic API.



---

<a id="1693"></a>

### #1693: Provide details and actionable info about Non Deterministic Errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1693 |
| **State** | OPEN |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2024-10-28 19:13:38.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-28 19:13:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
This is one example of the current NDE:
```
2024-10-22T20:38:57.8502536Z 2024/10/22 20:38:57 ERROR Workflow panic Namespace default TaskQueue Interpreter_DEFAULT WorkerID 11283@fv-az1498-207@ WorkflowType Interpreter WorkflowID locking1729629466434353139 RunID 96cc0bce-c727-45ab-8c58-32a9928ec882 Attempt 1 Error [TMPRL1100] lookup failed for scheduledEventID to activityID: scheduleEventID: 60, activityID: 60 StackTrace process event for Interpreter_DEFAULT [panic]:
2024-10-22T20:38:57.8505930Z go.temporal.io/sdk/internal.panicIllegalState(...)
2024-10-22T20:38:57.8507126Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_command_state_machine.go:518
2024-10-22T20:38:57.8508780Z go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc000b779a0, {0xc000a3d88c, 0x2}, 0x3c)
2024-10-22T20:38:57.8510591Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_command_state_machine.go:1150 +0xf8
2024-10-22T20:38:57.8512440Z go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc000e13ea8, 0xc0012bdef0, 0x4?, 0x0)
2024-10-22T20:38:57.8514059Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_event_handlers.go:1217 +0x275
2024-10-22T20:38:57.8515606Z go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc001184c80, 0xc00150da40)
2024-10-22T20:38:57.8517165Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_task_handlers.go:1152 +0x199c
2024-10-22T20:38:57.8518726Z go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc0011a6750, 0xc00150da40, 0xc001184c80, 0xc00111fc50)
2024-10-22T20:38:57.8520250Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_task_handlers.go:917 +0x3bf
2024-10-22T20:38:57.8521674Z go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc000a0e120, 0xc00150da40)
2024-10-22T20:38:57.8522716Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_task_pollers.go:363 +0x3a3
2024-10-22T20:38:57.8523572Z go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc000a0e120, {0x14d1660, 0xc00150da40})
2024-10-22T20:38:57.8524404Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_task_pollers.go:325 +0x78
2024-10-22T20:38:57.8525101Z go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
2024-10-22T20:38:57.8525809Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_worker_base.go:444 +0x12f
2024-10-22T20:38:57.8526802Z created by go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync in goroutine 5428
2024-10-22T20:38:57.8527590Z 	/home/runner/go/pkg/mod/go.temporal.io/sdk@v1.29.1/internal/internal_worker_base.go:423 +0x90
```
In this example, my workflow removed a "UpsertSearchAttribute" API by mistake. 
But this info is really hard to figure out why it runs into NDE. I would expect the error to say it more clearly: `Workflow code tried to scheduled an activity but based on the history events to replay, it should upsert a search attribute instead`. That way, we can clearly know that is something wrong with our code with the upsert search attribute (by looking at the event details of UpsertSearchAttribute in the history). 


**Describe the solution you'd like**
As above said.

**Describe alternatives you've considered**
NA

**Additional context**
NA



---

<a id="1668"></a>

### #1668: When deserializing typed search attributes, invalid values should be ignored

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1668 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-10-11 13:07:26.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-11 13:07:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

If a user creates a workflow or a schedule using untyped attributes and passes in a single-item array, the typed search attributes should simply not include that value.

## Actual Behavior

Today, if a user creates a workflow or schedule using untyped attributes like keyword with a single-item array, it is a panic when we try to convert to typed search attributes. While it may seem like inside a workflow this panic is the users fault for accessing typed search attributes, it is not the users fault when simply describing the workflow. We might as well just ignore all invalid values. This is confirmed to be the behavior in Python (didn't confirm elsewhere).

This was most obvious when a user used the TypeScript SDK to create a schedule that has a workflow action with its search attributes as a single item array (the only form TypeScript SDK supports at this time since it lacks typed search attributes). Then the user did a `temporal schedule describe` in CLI which panics.


---

<a id="1667"></a>

### #1667: Add high-level workflow describe

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1667 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-10-10 16:13:01.000 UTC (1y 3m ago) |
| **Updated** | 2025-04-30 14:36:44.000 UTC |
| **Closed** | 2025-04-30 14:36:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

* Add a `DescribeWorkflow` call on client
  * Probably deprecate `DescribeWorkflowExecution`
* Return a `WorkflowExecutionDescription` that contains some obvious things and access to the raw describe response for now
  * Ideally this should embed the type that just represents the workflow information that can come back from list even though we don't have high-level list call at this time
* Make sure it is interceptable

See TypeScript, Python, and .NET SDKs if looking for design inspiration for this call, or reference https://github.com/temporalio/sdk-java/issues/2265.


---

<a id="1663"></a>

### #1663: Add workflow annotations for versioning

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1663 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2024-10-08 18:50:06.000 UTC (1y 3m ago) |
| **Updated** | 2024-12-16 14:58:29.000 UTC |
| **Closed** | 2024-12-16 14:58:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See the parent feature issue in https://github.com/temporalio/features/issues/548

The goal is to support the new versioning APIs that rely on workflow annotations.



---

<a id="1650"></a>

### #1650: List of flaky tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1650 |
| **State** | OPEN |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2024-09-24 21:10:04.000 UTC (1y 3m ago) |
| **Updated** | 2025-02-18 21:20:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hoping to start a list of flaky tests for the Go SDK:
- `TestTaskHandlersTestSuite/TestSideEffectDefer` - https://github.com/temporalio/sdk-go/actions/runs/13298856210/job/37136477031
- `TestIntegrationSuite` https://github.com/temporalio/sdk-go/actions/runs/11020856944
- `TestIntegrationSuite\OtelTracing`

New as of Go 1.24
- `TestIntegrationSuite/TestNumPollersCounter` - https://github.com/temporalio/sdk-go/actions/runs/13298856210/job/37136477031

- `TestMockCallWrapperNotBefore` https://github.com/temporalio/sdk-go/actions/runs/13399984461/job/37428296220


---

<a id="1648"></a>

### #1648: Show update handler and ID in logging context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1648 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-09-24 16:37:36.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-08 16:27:50.000 UTC |
| **Closed** | 2024-10-08 16:27:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/466 for more details


---

<a id="1639"></a>

### #1639: Improve UX for testing Workflow Update with the Workflow Test Environment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1639 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-17 04:49:47.000 UTC (1y 3m ago) |
| **Updated** | 2024-11-25 22:49:14.000 UTC |
| **Closed** | 2024-11-25 22:49:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Improve UX for testing Workflow Update with the Workflow Test Environment. Currently users using the TestEnviorment have to implement the `UpdateCallbacks` to assert the result of an update call

**Describe the solution you'd like**
Provide helpers in the SDK for common update testing scenarios

**Additional context**
https://github.com/temporalio/samples-go/blob/main/reqrespupdate/workflow_test.go#L40


---

<a id="1635"></a>

### #1635: ExecuteMultiOperation is not retrying non-admitted Updates

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1635 |
| **State** | CLOSED |
| **Author** | stephanos (Stephan Behnke) |
| **Created** | 2024-09-16 16:05:02.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-02 21:53:53.000 UTC |
| **Closed** | 2024-10-02 21:53:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

ExecuteMultiOperation (ie Update-with-Start) should retry the entire call when the Update has not at least reached a durable stage yet.

## Actual Behavior

ExecuteMultiOperation does not retry when encountering a non-durable Update stage.

## Steps to Reproduce the Problem

## Specifications

  - Version: v1.29.0
 


---

<a id="1633"></a>

### #1633: Modify test suite to dump junit XML

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1633 |
| **State** | OPEN |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2024-09-12 09:55:26.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-12 09:55:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

As in https://github.com/temporalio/sdk-python/pull/617 and https://github.com/temporalio/cli/pull/650, I propose to modify the test suite to output junit XML. The motivation for this is that, given appropriate tools, it will make it easier for us to study patterns of flakiness, test timings etc, across matrix builds within a run, and across runs. Producing the files now will allow us to test tools for doing this.


---

<a id="1628"></a>

### #1628: API `MockWorkflowServiceServer` does not implement `WorkflowServiceServer` properly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1628 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-09-10 16:14:22.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-13 18:35:39.000 UTC |
| **Closed** | 2024-09-13 18:35:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

https://pkg.go.dev/go.temporal.io/api/workflowservicemock/v1#MockWorkflowServiceServer should be able to implement https://pkg.go.dev/go.temporal.io/api/workflowservice/v1#WorkflowServiceServer.

## Actual Behavior

Compile error when tried.

https://pkg.go.dev/go.temporal.io/api/workflowservicemock/v1#MockWorkflowServiceServer is generated via a step created in the gRPC days before https://pkg.go.dev/go.temporal.io/api/workflowservice/v1#WorkflowServiceServer required embedding https://pkg.go.dev/go.temporal.io/api/workflowservice/v1#UnimplementedWorkflowServiceServer.

Probably need to alter the generated mock to embed https://pkg.go.dev/go.temporal.io/api/workflowservice/v1#UnimplementedWorkflowServiceServer _and_ add a compile time check to ensure conformity to the interface it's mocking. Granted arguably we should just remove/deprecate mocks in this repository and encourage users use their preferred mocking tooling.


---

<a id="1622"></a>

### #1622: API Go's payload visitor not visiting `Any` for payloads inside

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1622 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-09-05 12:37:35.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-05 20:50:15.000 UTC |
| **Closed** | 2024-09-05 20:50:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

All payloads should be visited in https://github.com/temporalio/api-go's payload visitor, even if they are inside `Any`.

## Actual Behavior

The generator only visits things with a clear path to `common.Payload` so it does not include `Any` that might have an object with a payload inside it. So for example an `update.Request` from `workflowservice.PollWorkflowTaskQueueResponse` may not be visited because `messages` is a `protocol.Message` with an `Any` containing that request.

Make sure to support `Any` in addition to payload.


---

<a id="1612"></a>

### #1612: Request to make queryRejectedError public to enhance Interceptor error handling

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1612 |
| **State** | CLOSED |
| **Author** | deepika-awasthi |
| **Created** | 2024-08-28 16:45:25.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-03 17:41:36.000 UTC |
| **Closed** | 2024-09-03 17:41:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

When using QueryWorkflowWithOptions with QUERY_REJECT_CONDITION_NOT_OPEN, query rejection errors cannot be caught in the interceptor because the queryRejectedError is private in the Go SDK. Making this error public would allow better handling in error interceptors

**Describe the solution you'd like**

Making queryRejectedError public so that it can be explicitly handled in interceptors, similar to other common errors.

**Describe alternatives you've considered**

- Using QueryWorkflowWithOptionsResponse.QueryRejected directly is not an ideal solution because the rejection status is returned as part of the workflow's response, meaning it bypasses the typical error handling flow used in interceptors. 
- String matching the error message is also an option, but it is not a reliable solution.

**Additional context**

This issue affects error handling consistency and prevents query rejection errors from being managed properly in interceptors.


---

<a id="1610"></a>

### #1610: Provide access to the workflow results from worker.WorkflowReplayer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1610 |
| **State** | OPEN |
| **Author** | kylelemons (Kyle Lemons) |
| **Created** | 2024-08-27 21:49:59.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-27 21:53:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The `worker.WorkflowReplayer` [interface](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) does not have the `GetWorkflowResult` method on it, even though [the underlying WorkflowReplayer struct does](https://pkg.go.dev/go.temporal.io/sdk@v1.28.1/internal#WorkflowReplayer.GetWorkflowResult).

I am using this to build a test helper to replay workflows and ensure that their results are the same each time, and so I currently need to to my own interface assertion to get access to this method:

```go
type replayerWithResults interface {
	worker.WorkflowReplayer

	// GetWorkflowResult returns the result of a workflow execution.
	//
	// For replays, the workflowID will always be "ReplayId".
	//
	// https://pkg.go.dev/go.temporal.io/sdk@v1.28.1/internal#WorkflowReplayer.GetWorkflowResult
	GetWorkflowResult(workflowID string, valuePtr any) error
}
```

**Describe the solution you'd like**
It's a bit challenging to make this a completely backward compatible change, since this API is returning an interface rather than a concrete type.

Ideally, it would switch to returning the WorkflowReplayer struct directly from e.g. `NewWorkflowReplayerWithOptions`, so that new methods can be added backward-compatibly.  However, I think that ship has sailed, so there are a few options:
* **Create a new API that returns the concrete type, e.g. `NewWorkflowReplayerWithResults`.**
* Expose the internal.WorkflowReplayer type via a type alias so that users can type assert the type directly, and promise that this is the type that will be returned from these constructors.
* Create another interface (e.g. `WorkflowReplayerWithResults`) and document that it will be returned from these constructors.
* Document that the returned type has additional methods that users can use in their own interfaces and what they are.

I think the first one is probably the optimal one from a user standpoint, but the second one is likely to be close enough, and it is future proof in a way that the final two are not.


---

<a id="1591"></a>

### #1591: Fix workflow start delay docs to say signal does not interrupt delay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1591 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-08-15 12:29:53.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-16 03:36:38.000 UTC |
| **Closed** | 2024-08-16 03:36:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Per discussion at https://github.com/temporalio/api/pull/441#discussion_r1710132081, signal does not interrupt delay


---

<a id="1588"></a>

### #1588: Support updates in tracing interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1588 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-08-13 16:14:32.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-21 17:35:45.000 UTC |
| **Closed** | 2024-08-21 17:35:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Need to support `ClientOutboundInterceptor.UpdateWorkflow` in the tracing interceptor to populate header and `WorkflowInboundInterceptor.ExecuteUpdate` (and validate too maybe) to put span on context.


---

<a id="1580"></a>

### #1580: Do not warn on unfinished handlers if the workflow has failed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1580 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-08-06 21:08:29.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-06 23:45:52.000 UTC |
| **Closed** | 2024-08-06 23:45:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It was decided we would not warn on unfinished handlers if the workflow has failed.


---

<a id="1567"></a>

### #1567: Worker can panic if it receives a legacy query task with no history and the SDK has a destroyed execution in cache

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1567 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-07-29 00:59:08.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-29 17:22:17.000 UTC |
| **Closed** | 2024-07-29 17:22:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

SDK detects this is a legacy query task and shouldn't have any history and resets the cached exeuciton

## Actual Behavior

SDK panics

```
2024-07-25T10:50:16.216-0700    ERROR   internal/internal_worker_base.go:519    Unhandled panic.        {"Namespace": "default", "TaskQueue": "fuzzer:zvsrg654", "WorkerID": "785534
@ShtinUbuntu2@", "WorkerType": "WorkflowWorker", "PanicError": "runtime error: index out of range [0] with length 0", "PanicStack": "base worker for WorkflowWorker [panic]:\ngo.tem
poral.io/sdk/internal.(*workflowTaskHandlerImpl).GetOrCreateWorkflowContext(0xc0002be410, 0xc0006dfa00, {0xf775a0, 0xc00029bb20})\n\t/home/shtin/go/pkg/mod/go.temporal.io/sdk@v1.28
.1/internal/internal_task_handlers.go:772 +0xafe\ngo.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc000228b40, 0xc000cd4a50)\n\t/home/shtin/go/pkg/mod/go.tem
poral.io/sdk@v1.28.1/internal/internal_task_pollers.go:344 +0x19b\ngo.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc000228b40, {0xc496e0, 0xc000cd4a50})\n\t/home/sh
tin/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_task_pollers.go:321 +0x78\ngo.temporal.io/sdk/internal.(*baseWorker).processTask(0xc00034c420, {0xc4a320, 0xc001335330})
\n\t/home/shtin/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_worker_base.go:528 +0x153\ngo.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()\n\t/home/shtin
/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_worker_base.go:379 +0x45\ncreated by go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync in goroutine 26\n\t/home/sh
tin/go/pkg/mod/go.temporal.io/sdk@v1.28.1/internal/internal_worker_base.go:375 +0xa5"}
```



---

<a id="1566"></a>

### #1566: `go.temporal.io/api/proxy.VisitPayloads` doesn't visit `export` package

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1566 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-26 20:57:25.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-16 23:08:26.000 UTC |
| **Closed** | 2024-08-16 23:08:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Have the generated code that backs the `go.temporal.io/api/proxy.VisitPayloads` work for `export` package too. Presumably it doesn't because that package is never referenced from the workflow service in any way, so it is a rare orphan.

(created here because https://github.com/temporalio/api-go doesn't allow issues to be opened on it)


---

<a id="1565"></a>

### #1565: User metadata and workflow metadata query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1565 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-26 20:11:32.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-30 14:49:45.000 UTC |
| **Closed** | 2024-08-30 14:49:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/486. This can only be worked on in Go at this time because CI is testing against unstable server currently.


---

<a id="1564"></a>

### #1564: Test Nexus with Cloud

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1564 |
| **State** | OPEN |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-07-25 23:21:49.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-25 23:21:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It would be great to have coverage of sync and async operations on Cloud.

The Cloud namespace that we use in CI has Nexus enabled.

The tricky part to test this would be to allow tests to run concurrently since a Nexus endpoint has to be defined in advance and it points to a specific task queue. The endpoint registry has inherent registration delay that is tricky to deal with in automated tests.


---

<a id="1545"></a>

### #1545: Review and add tests for Nexus operation log and metrics labels

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1545 |
| **State** | CLOSED |
| **Author** | pdoerner |
| **Created** | 2024-07-12 15:08:26.000 UTC (1y 6m ago) |
| **Updated** | 2025-02-27 19:52:20.000 UTC |
| **Closed** | 2025-02-27 19:52:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Review the labels that are currently set on the metrics handler and logger returned from `temporalnexus.GetMetricsHandler` and `temporalnexus.GetLogger`. At the time of writing it is Nexus service, Nexus operation, and task queue.

**Describe the solution you'd like**
Any other useful labels should be added and tests should be updated to ensure they are being set appropriately.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.




---

<a id="1539"></a>

### #1539: Support "query" when listing schedules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1539 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-08 14:22:40.000 UTC (1y 6m ago) |
| **Updated** | 2024-07-22 17:27:03.000 UTC |
| **Closed** | 2024-07-22 17:27:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | justinp-tt |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Need to support the query option when listing schedules same as we do when listing workflows.


---

<a id="1536"></a>

### #1536: TERMINATE_IF_RUNNING doesn't work for duplicate child workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1536 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2024-07-03 19:19:20.000 UTC (1y 6m ago) |
| **Updated** | 2025-02-04 18:26:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
A child workflow with IdReusePolicy set to TERMINATE_IF_RUNNING is started twice from the same parent. Both starts are expected to succeed. 

## Actual Behavior
Workflow receives ChildWorkflowExecutionAlreadyStartedError.

## Steps to Reproduce the Problem
Reproduction:
https://github.com/temporalio/samples-go/pull/356




---

<a id="1523"></a>

### #1523: Accept search attributes in dev server startup

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1523 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-06-20 20:32:11.000 UTC (1y 6m ago) |
| **Updated** | 2025-07-24 23:50:23.000 UTC |
| **Closed** | 2025-07-24 23:50:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/494. With https://github.com/temporalio/cli/pull/593 deployed, users should be allowed to set search attributes in dev server option that translate to `--search-attribute` calls.


---

<a id="1520"></a>

### #1520: Workflow-friendly concurrency control

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1520 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 17:09:50.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-18 17:12:56.000 UTC |
| **Closed** | 2024-06-18 17:12:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.  To be used within signal and update handlers and the main workflow coroutine.


---

<a id="1519"></a>

### #1519: Testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1519 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 03:56:37.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-18 03:57:12.000 UTC |
| **Closed** | 2024-06-18 03:57:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

testing


---

<a id="1518"></a>

### #1518: Testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1518 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 03:55:00.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-19 15:18:10.000 UTC |
| **Closed** | 2024-06-19 15:18:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

testing


---

<a id="1517"></a>

### #1517: Testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1517 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 03:54:09.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-19 15:18:19.000 UTC |
| **Closed** | 2024-06-19 15:18:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

testing


---

<a id="1500"></a>

### #1500: Provide methods to wait for handlers to finish

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1500 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-04 04:39:20.000 UTC (1y 7m ago) |
| **Updated** | 2024-07-03 21:07:26.000 UTC |
| **Closed** | 2024-07-03 21:07:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Users want to easily await (or ignore) all their remaining handlers when they continue as new or exit the workflow.  Since we can't tell what they want, they should specify.


---

<a id="1496"></a>

### #1496: Workflow outcome is inconsistent between test env and real server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1496 |
| **State** | OPEN |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-05-30 20:47:35.000 UTC (1y 7m ago) |
| **Updated** | 2025-02-04 18:23:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When running a workflow that starts a child and cancels it:

```go
wf := func(ctx workflow.Context) error {
	childCtx, cancel := workflow.WithCancel(ctx)
	defer cancel()
	fut := workflow.ExecuteChildWorkflow(childCtx, waitForCancelWorkflow)
	if err := fut.GetChildWorkflowExecution().Get(ctx, nil); err != nil {
		return err
	}
	cancel()
	return fut.Get(ctx, nil)
}

func waitForCancelWorkflow(ctx workflow.Context) error {
	return workflow.Await(ctx, func() bool { return false })
}
```

I'm getting inconsistent outcomes:

With server:

```
workflow execution error (type: func1, workflowID: 1eb1f045-b804-429f-b99e-57e45023a6e8, runID: 4821bd7c-b9f6-4684-92be-ab7354eefc36): canceled
```

With test env:

```
workflow execution error (type: func1, workflowID: default-test-workflow-id, runID: default-test-run-id): child workflow execution error (type: waitForCancelWorkflow, workflowID: default-test-run-id_1, runID: default-test-run-id_1_RunID, initiatedEventID: 0, startedEventID: 0): canceled
```

The test env is consistent with the behavior of other SDKs, but it's likely too late to change the cancelation behavior with the real server for consistency. I propose we change the test env to be consistent with the "real" env.




---

<a id="1491"></a>

### #1491: Better testing story for Nexus Operations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1491 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-05-24 19:32:19.000 UTC (1y 7m ago) |
| **Updated** | 2024-11-14 22:12:53.000 UTC |
| **Closed** | 2024-11-14 22:12:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently the test environment support workflow run operations, sync operations get a client that panics for any method call.

To improve the testing story for Nexus, we'll want:

- [ ] Add a `TestNexusEnvironment` for users to test their operations outside of workflow context
  There are details to be ironed out here, e.g. how are sync operations going to work since they reference a `Client`.
- [ ] Add an `OnNexusOperation` method to the workflow test environment to integrate with current mocking and time skipping approach.


---

<a id="1483"></a>

### #1483: workflowcheck -: named files must all be in one directory; have . and workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1483 |
| **State** | CLOSED |
| **Author** | Vishal1297 (Vishal Yadav) |
| **Created** | 2024-05-20 13:24:08.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-23 19:35:07.000 UTC |
| **Closed** | 2024-05-23 19:35:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest
workflowcheck ./main.go ./workflows/my-wf.go

Determinism Related Errors...

## Actual Behavior
go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest
workflowcheck ./main.go ./workflows/my-wf.go
workflowcheck: error during loading

## Steps to Reproduce the Problem

  1. Create a project with two files main.go & workflows/wf.go
  2. Install workflowcheck - go install go.temporal.io/sdk/contrib/tools/workflowcheck@latest
  3. Run workflowcheck - workflowcheck ./main.go ./workflows/my-wf.go

## Specifications

  - Version: v1.26.1
  - Platform:



---

<a id="1476"></a>

### #1476: Infer input type when executing a Nexus Operation from a workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1476 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-05-17 00:15:31.000 UTC (1y 7m ago) |
| **Updated** | 2025-02-03 20:47:42.000 UTC |
| **Closed** | 2025-02-03 20:47:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We don't have access to the generics on [`OperationReference`](https://github.com/nexus-rpc/sdk-go/blob/2b47041a2cc2ac3ec2ea921aa50579cf9f58da42/nexus/operation.go#L21), the solution may need to come from the Nexus Go SDK.

_Originally posted by @bergundy in https://github.com/temporalio/sdk-go/pull/1473#discussion_r1603704167_




---

<a id="1469"></a>

### #1469: Allow specifying attempt in TestWorkflowEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1469 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-05-13 22:30:30.000 UTC (1y 8m ago) |
| **Updated** | 2025-02-04 18:24:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Users may have different logic based on the attempt count of a workflow or activity, we should allow them to test those condition by allowing them to specifying the attempt count in the test environment.




---

<a id="1465"></a>

### #1465: `activity_succeed_endtoend_latency` is recorded even on activity failure/cancel

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1465 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-10 19:38:19.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-21 14:23:29.000 UTC |
| **Closed** | 2024-05-21 14:23:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Expect `activity_succeed_endtoend_latency` to only record on activity success like https://github.com/temporalio/sdk-java/pull/800 does.

## Actual Behavior

Actually `activity_succeed_endtoend_latency` in https://github.com/temporalio/sdk-go/pull/575 didn't properly take into account what form of activity completion the request was for, so it's recorded for all completions including failures and cancellations.


---

<a id="1460"></a>

### #1460: QueryRejectCondition not used in QueryWorkflowWithOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1460 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-05-09 19:52:49.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-10 17:33:49.000 UTC |
| **Closed** | 2024-05-10 17:33:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

query reject condition not being passed - https://github.com/temporalio/sdk-go/blob/386a6d3df3ae426a1354d42ce1c8b39c36cc798c/internal/internal_workflow_client.go#L899


---

<a id="1459"></a>

### #1459: Cloud Operations API Client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1459 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-09 15:34:06.000 UTC (1y 8m ago) |
| **Updated** | 2024-07-08 19:51:33.000 UTC |
| **Closed** | 2024-07-08 19:51:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/440 and https://github.com/temporalio/sdk-go/pull/1426. We need a separate cloud client using the cloud protos (they are separate today). The client should be marked experimental.



---

<a id="1455"></a>

### #1455: Update handler should require `workflow.Context` as first parameter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1455 |
| **State** | CLOSED |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2024-05-06 19:19:00.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-09 14:53:50.000 UTC |
| **Closed** | 2024-05-09 14:53:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Consider the following code:

```go
	workflowFn := func(ctx workflow.Context) error {
		workflow.SetUpdateHandler(ctx, "my-update-handler", func(arg string) error {
			err := workflow.Sleep(ctx, time.Minute)
			return err
		})
        ...
	}
```

The relevant documentation is:

> SetUpdateHandler forwards to SetUpdateHandlerWithOptions with an zero-initialized UpdateHandlerOptions struct. See SetUpdateHandlerWithOptions for more details

> SetUpdateHandlerWithOptions binds an update handler function to the specified name such that update invocations specifying that name will invoke the handler. The handler function can take as input any number of parameters so long as they can be serialized/deserialized by the system. The handler can take a [workflow.Context] as its first parameter but this is not required. The update handler must return either a single error or a single serializable object along with a single error. The update handler function is invoked in the context of the workflow and thus is subject to the same restrictions as workflow code, namely, the update handler must be deterministic. As with other workflow code, update code is free to invoke and wait on the results of activities. Update handler code is free to mutate workflow state.

The code type-checks, but is incorrect, since the update handler is attempting to use the `workflow.Context` instance from the main workflow body coroutine.

## Expected Behavior
`SetUpdateHandler` should be documented as taking a handler function that must take a `workflow.Context` as its first parameter.

If the first argument is found not to be of the correct type at run time, the `SetUpdateHandler` call should fail with an error message explaining to the user that they should alter the signature of their handler.


## Actual Behavior
It fails at run time with an error in SDK coroutine scheduler internals:
```
Error trying to block on coroutine which is already blocked,
most likely a wrong Context is used to do blocking call (like Future.Get() or Channel.Receive()
```



---

<a id="1454"></a>

### #1454: Local activity support for next-retry-delay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1454 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-06 16:32:41.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-09 22:19:10.000 UTC |
| **Closed** | 2024-05-09 22:19:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Re https://github.com/temporalio/features/issues/419, it was decided we need to support next retry delay in application failures from local activity too. Implementation details are still pending.


---

<a id="1449"></a>

### #1449: Clarify waiting semantics for UpdateWorkflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1449 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-04-25 01:30:55.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-28 19:03:55.000 UTC |
| **Closed** | 2024-05-28 19:03:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Per https://github.com/temporalio/sdk-go/blob/836106795bd31710bc509f8a306a876e4be70429/client/client.go#L575-L586
it's unclear from the docstrings how to start a workflow and wait for acceptance/rejection.
I see https://github.com/temporalio/sdk-go/blob/master/internal/internal_workflow_client.go#L756 and, per the parent task, want to make sure we require `WaitPolicy` and don't default to anything that could be dangerous.

**Describe the solution you'd like**
Make sure availability tradeoff is documented clearly and user is opting in to a wait policy.

**Describe alternatives you've considered**

**Additional context**
Add any other context or screenshots about the feature request here.
Parent: https://github.com/temporalio/features/issues/469


---

<a id="1447"></a>

### #1447: Support for WorkflowIdConflictPolicy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1447 |
| **State** | CLOSED |
| **Author** | stephanos (Stephan Behnke) |
| **Created** | 2024-04-23 20:47:03.000 UTC (1y 8m ago) |
| **Updated** | 2024-07-26 16:16:10.000 UTC |
| **Closed** | 2024-07-26 16:16:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/437


---

<a id="1442"></a>

### #1442: Expose defaultConnection() method to switch between localhost and cloud based on env

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1442 |
| **State** | CLOSED |
| **Author** | josh-berry (Josh Berry) |
| **Created** | 2024-04-12 23:54:37.000 UTC (1y 9m ago) |
| **Updated** | 2025-10-06 19:01:04.000 UTC |
| **Closed** | 2025-08-25 15:14:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Expose a defaultConnection() method or similar that switches between localhost (default) and cloud based on some environment variable, so that we can use it in the samples repos to allow people to easily run samples in the cloud. See: https://github.com/temporalio/features/issues/454




---

<a id="1435"></a>

### #1435: It is not possible to unit test a child workflow that calls continue as new.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1435 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2024-04-06 00:58:41.000 UTC (1y 9m ago) |
| **Updated** | 2024-04-09 18:55:19.000 UTC |
| **Closed** | 2024-04-09 18:55:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
A child workflow continues as new, and the parent waits for the child to complete.

## Actual Behavior
The parent receives ChildWorkflowExecutionError with ContinueAsNewError wrapped error.

## Steps to Reproduce the Problem

  1. Add the following test to [child-workflow-continue-as-new](https://github.com/temporalio/samples-go/tree/main/child-workflow-continue-as-new) sample.

```
package child_workflow_continue_as_new

import (
	"testing"

	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/testsuite"
)

type UnitTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
}

func TestUnitTestSuite(t *testing.T) {
	suite.Run(t, new(UnitTestSuite))
}

func (s *UnitTestSuite) Test_ExclusiveChoiceWorkflow() {
	env := s.NewTestWorkflowEnvironment()

	env.RegisterWorkflow(SampleChildWorkflow)
	env.ExecuteWorkflow(SampleParentWorkflow)

	s.True(env.IsWorkflowCompleted())
	s.NoError(env.GetWorkflowError())
}
```
Test fails with 
```
2024/04/05 17:52:02 ERROR Parent execution received child execution failure. Error child workflow execution error (type: SampleChildWorkflow, workflowID: child_workflow:default-test-run-id, runID: child_workflow:default-test-run-id_RunID, initiatedEventID: 0, startedEventID: 0): continue as new
    workflow_test.go:26: 
        	Error Trace:	/Users/maxim/temporal/samples-go/child-workflow-continue-as-new/workflow_test.go:26
        	Error:      	Received unexpected error:
        	            	workflow execution error (type: SampleParentWorkflow, workflowID: default-test-workflow-id, runID: default-test-run-id): child workflow execution error (type: SampleChildWorkflow, workflowID: child_workflow:default-test-run-id, runID: child_workflow:default-test-run-id_RunID, initiatedEventID: 0, startedEventID: 0): continue as new
        	Test:       	TestUnitTestSuite/Test_ExclusiveChoiceWorkflow
--- FAIL: TestUnitTestSuite (0.00s)
    --- FAIL: TestUnitTestSuite/Test_ExclusiveChoiceWorkflow (0.00s)

```


---

<a id="1427"></a>

### #1427: TestWorkflowEnvironment workflow Context does not block when canceled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1427 |
| **State** | OPEN |
| **Author** | emetsger (Elliot Metsger) |
| **Created** | 2024-03-23 15:04:57.000 UTC (1y 9m ago) |
| **Updated** | 2025-02-04 18:25:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I expect the test environment to have parity with the production runtime environment.

When a workflow receives a cancellation request whilst a non-heartbeating activity is executing, I expect the workflow to block waiting for the activity to return before advancing the workflow, including the execution of any `defer`ed funcs.

Two observations:

1. The expected behavior seems to only occur in the _production_ runtime when `WaitForCancellation` activity option is `true`.
1. The expected behavior does not occur _at all_ in the test runtime (i.e., using `TestWorkflowEnvironment`).  In testing, the workflow does not block, regardless of `WaitForCancellation`.

This issue and test case relates to **observation #2**.  I was trying to write a test case for #1, and encountered buggy behavior in the test environment.

See additional context in [Slack](https://temporalio.slack.com/archives/CTDTU3J4T/p1711112606967079).

## Actual Behavior
In the test runtime, the workflow receives a cancelation request and immediately moves on to executing deferred without waiting for the currently executing activity to complete.

## Steps to Reproduce the Problem
Run the supplied [test case](https://gist.github.com/emetsger/053591b397ab64c97d77e94830ec1d1e)

The test case expects the activity in the main body of the workflow to complete before the activity in the deferred func.  The test case demonstrates that the deferred activity executes while the main activity is still running.

The test issues a cancelation request using a delayed callback, and the activity uses `time.Sleep()` to ensure that cancelation occurs while the activity is executing.

## Specifications
* Version: `go.temporal.io/sdk v1.26.0`, `go.temporal.io/sdk v1.25.1`
* Platform: `Darwin Kernel Version 22.6.0`, `go version go1.21.4 darwin/arm64`




---

<a id="1414"></a>

### #1414: [Feature Request] SDK should not return an update handle if the update has not reached the desired state

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1414 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-03-06 18:17:51.000 UTC (1y 10m ago) |
| **Updated** | 2024-05-28 19:03:55.000 UTC |
| **Closed** | 2024-05-28 19:03:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/432



---

<a id="1411"></a>

### #1411: Replace use of *updatepb.WaitPolicy with enum defined in the Go SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1411 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-03-06 04:56:23.000 UTC (1y 10m ago) |
| **Updated** | 2024-05-28 19:03:56.000 UTC |
| **Closed** | 2024-05-28 19:03:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Using `updatepb.WaitPolicy` in `UpdateWorkflowWithOptionsRequest` is not ideal since it require declaring a whole struct and a protobuf enum just to set the wait policy. We can replace this with an "enum" defined in the Go SDK.

https://github.com/temporalio/sdk-go/blob/efabf4622182554045df2bb9ab9f78d159ffd928/internal/internal_workflow_client.go#L785



---

<a id="1401"></a>

### #1401: API key client option

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1401 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-02-27 15:20:41.000 UTC (1y 10m ago) |
| **Updated** | 2024-03-08 13:37:18.000 UTC |
| **Closed** | 2024-03-08 13:37:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/426


---

<a id="1387"></a>

### #1387: Configurable panic policy at the workflow level

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1387 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-02-12 14:28:33.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-12 14:28:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/322. May be determined we don't need this and closed.



---

<a id="1384"></a>

### #1384: Add an option to override retry policy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1384 |
| **State** | CLOSED |
| **Author** | jiezhang (Jie Zhang) |
| **Created** | 2024-02-09 06:02:51.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-14 22:18:35.000 UTC |
| **Closed** | 2024-02-14 22:18:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
For a long running workflows that is restarted periodically using `NewContinueAsNewError`, the existing retry policy is propagated to the new workflow. This behavior is fine until we need to adjust the retry policy. Without such an option, the workflow needs to be re-submitted using `StartWorkflowOptions`.

Note that this option is already available in `sdk-java`: https://github.com/temporalio/sdk-java/blob/72ebff1dcb2c14b3aecc7de14a2b9aa21ef9cc4a/temporal-sdk/src/main/java/io/temporal/workflow/ContinueAsNewOptions.java#L95

**Describe the solution you'd like**
Similar to `WithWorkflowRunTimeout`, provide an option to override the retry policy.

**Describe alternatives you've considered**


**Additional context**




---

<a id="1360"></a>

### #1360: `testsuite.DevServer` occasionally does not stop

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1360 |
| **State** | OPEN |
| **Author** | wyrobnik (David Wyrobnik) |
| **Created** | 2024-01-16 18:35:07.000 UTC (1y 11m ago) |
| **Updated** | 2024-01-16 18:35:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When calling [DevServer.Stop()](https://pkg.go.dev/go.temporal.io/sdk/testsuite#DevServer.Stop) eventually the underlying process should stop and the call should return.

## Actual Behavior
`DevServer.Stop()` hangs and never returns causing test timeouts. Excerpt from the logs:

```
{"level":"error","ts":"2024-01-16T18:24:51.369Z","msg":"Membership upsert failed.","error":"context canceled","logging-call-at":"monitor.go:310","stacktrace":"go.temporal.io/server/common/log.(*zapLogger).Error\n\t/home/runner/go/pkg/mod/go.temporal.io/server@v1.22.2/common/log/zap_logger.go:156\ngo.temporal.io/server/common/membership/ringpop.(*monitor).startHeartbeatUpsertLoop.func1\n\t/home/runner/go/pkg/mod/go.temporal.io/server@v1.22.2/common/membership/ringpop/monitor.go:310"}

{"level":"warn","ts":"2024-01-16T18:12:21.982Z","msg":"Failed to cancel outstanding poller.","service":"frontend","wf-task-queue-name":"localhost:945e3c13-795f-4add-b33d-043cd437ab5b","error":"Not enough hosts to serve the request","logging-call-at":"workflow_handler.go:4622"}

{"level":"error","ts":"2024-01-16T18:12:22.014Z","msg":"service failures","operation":"PollWorkflowTaskQueue","wf-namespace":"temporal-system","error":"Not enough hosts to serve the request","logging-call-at"
erceptor.(*TelemetryInterceptor).handleError\n\t/home/runner/go/pkg/mod/go.temporal.io/server@v1.22.2/common/rpc/interceptor/telemetry.go:341\ngo.temporal.io/server/common/rpc/interceptor.(*TelemetryIntercept
rg/grpc@v1.59.0/server.go:1163\ngo.temporal.io/server/service/frontend.(*RedirectionInterceptor).handleRedirectAPIInvocation.func2\n\t/home/runner/go/pkg/mod/go.temporal.io/server@v1.22.2/service/frontend/red
y.go:125\ngo.temporal.io/server/service/frontend.(*RedirectionInterceptor).handleRedirectAPIInvocation\n\t/home/runner/go/pkg/mod/go.temporal.io/server@v1.22.2/service/frontend/redirection_interceptor.go:235\
hainUnaryHandler.func1\n\t/home/runner/go/pkg/mod/google.golang.org/grpc@v1.59.0/server.go:1163\ngo.temporal.io/server/common/metrics.NewServerMetricsContextInjectorInterceptor.func1\n\t/home/runner/go/pkg/mo
b/instrumentation/google.golang.org/grpc/otelgrpc.UnaryServerInterceptor.func1\n\t/home/runner/go/pkg/mod/go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc@v0.42.0/interceptor.go:344
\t/home/runner/go/pkg/mod/go.temporal.io/server@v1.22.2/common/rpc/interceptor/namespace_logger.go:84\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\n\t/home/runner/go/pkg/mod/google.golang.org/grpc@v1.59
pace_validator.go:111\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\n\t/home/runner/go/pkg/mod/google.golang.org/grpc@v1.59.0/server.go:1163\ngo.temporal.io/server/common/rpc.ServiceErrorInterceptor\n\t/
poral.io/api/workflowservice/v1._WorkflowService_PollWorkflowTaskQueue_Handler\n\t/home/runner/go/pkg/mod/go.temporal.io/api@v1.25.0/workflowservice/v1/service.pb.go:1671\ngoogle.golang.org/grpc.(*Server).pro
ogle.golang.org/grpc.(*Server).serveStreams.func1.1\n\t/home/runner/go/pkg/mod/google.golang.org/grpc@v1.59.0/server.go:986"}                                                                                   
```

## Steps to Reproduce the Problem

  1. Create a dev server with `devServer, err := testsuite.StartDevServer`
  1. Interact with it (e.g. start some workflows).
  1. Call `devServer.Stop()`.

## Specifications

  - Version: temporal cli v0.10.7, sdk-go v1.25.1 
  - Platform: Ubuntu 20.04.1



---

<a id="1359"></a>

### #1359: PollWorkflowUpdate does not use a context aware data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1359 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-16 16:38:51.000 UTC (1y 11m ago) |
| **Updated** | 2025-07-07 15:59:20.000 UTC |
| **Closed** | 2025-07-07 15:59:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

PollWorkflowUpdate does use a context aware data converter.

## Actual Behavior

PollWorkflowUpdate does not use a context aware data converter.

https://github.com/temporalio/sdk-go/blob/54e131e191406487481e2af2af46b3f5f57201d8/internal/internal_workflow_client.go#L1900


---

<a id="1357"></a>

### #1357: SDK should evict workflow execution from cache on failure to respond to a workflow task

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1357 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-16 16:24:23.000 UTC (1y 11m ago) |
| **Updated** | 2024-01-16 18:02:56.000 UTC |
| **Closed** | 2024-01-16 18:02:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

SDK should evict workflow execution from cache on failure to respond to a workflow task

## Actual Behavior

SDK may not evict workflow execution from cache on failure to respond to a workflow task




---

<a id="1349"></a>

### #1349: WorkflowRun.Get does not use a context aware data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1349 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-13 17:10:00.000 UTC (1y 12m ago) |
| **Updated** | 2024-01-13 17:10:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`WorkflowRun.Get` and `WorkflowRun.GetWithOptions` uses a context aware data converter like all other client and workflow calls

## Actual Behavior
`WorkflowRun.Get` and `WorkflowRun.GetWithOptions` does not use a context aware data converter.

https://github.com/temporalio/sdk-go/blob/5ca9a4dfd4c37a56f0dd886596494be4599f01c8/internal/internal_workflow_client.go#L288




---

<a id="1347"></a>

### #1347: Workflow/Activity context is dropped when using `DataConverterWithoutDeadlockDetection` wrapper

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1347 |
| **State** | CLOSED |
| **Author** | taonic (Tao Guo) |
| **Created** | 2024-01-13 01:31:40.000 UTC (1y 12m ago) |
| **Updated** | 2024-01-16 15:29:33.000 UTC |
| **Closed** | 2024-01-16 15:29:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When wrapping a [ContextAware](https://github.com/temporalio/sdk-go/blob/1c576d0da97d1e26d372d426b00ec253fb09cf07/internal/headers.go#L72-L75) `DataConverter` with the `DataConverterWithoutDeadlockDetection`, Workflow/Activity context should be passed down the chain.

## Actual Behavior

Context is dropped by `DataConverterWithoutDeadlockDetection` wrapper causing the underlying `DataConverter` not able to perform context driven logics.

## Steps to Reproduce the Problem

  1. Add DataConverterWithoutDeadlockDetection to https://github.com/temporalio/samples-go/blob/main/encryption/worker/main.go#L35-L38
  ```
workflow.DataConverterWithoutDeadlockDetection(encryption.NewEncryptionDataConverter(
		converter.GetDefaultDataConverter(),
		encryption.DataConverterOptions{Compress: true},
))
  ```
  2. Check [KeyID](https://github.com/temporalio/samples-go/blob/main/encryption/data_converter.go#L109C21-L109C26) that is no longer populated.

## Specifications

  - Version: v1.25.1
  - Platform: ARM



---

<a id="1341"></a>

### #1341: WorkflowChecker should flag anonymous functions in local activities as non deterministic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1341 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-09 18:33:24.000 UTC (2 years ago) |
| **Updated** | 2026-01-08 20:54:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
WorkflowChecker should consider anonymous functions in local activities non deterministic.

## Actual Behavior
WorkflowChecker does not consider anonymous functions in local activities non deterministic.

## Steps to Reproduce the Problem

```Go
func GreetingSample(ctx workflow.Context) error {
	fut := workflow.ExecuteLocalActivity(ctx, func(ctx context.Context) time.Time { return time.Now() })
}
```

## Note

Anonymous functions as local activities are ripe for data races because they can run in parallel with the workflow function, so maybe we should warn about their use from that perspective.



---

<a id="1315"></a>

### #1315: Deprecate Update related SDK flags

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1315 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-12-04 19:11:59.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-04 19:11:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

To preserve history compatibility we introduced a couple update related flags `SDKFlagProtocolMessageCommand` `SDKPriorityUpdateHandling` that should be deprecated in the future since update is not GA and we don't need to maintain histroy compatibility.



---

<a id="1313"></a>

### #1313: Support OpenTelemetry Metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1313 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-12-01 20:33:13.000 UTC (2y 1m ago) |
| **Updated** | 2024-01-08 05:15:20.000 UTC |
| **Closed** | 2024-01-08 05:15:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Now that it is stable (ref #113 and https://opentelemetry.io/blog/2023/otel-go-metrics-sdk-stable/), we should add `NewMetricsHandler` to `go.temporal.io/sdk/contrib/opentelemetry`.


---

<a id="1312"></a>

### #1312: Fail task on unknown event when HistoryEvent.worker_may_ignore is false

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1312 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-12-01 13:43:30.000 UTC (2y 1m ago) |
| **Updated** | 2024-01-22 17:03:53.000 UTC |
| **Closed** | 2024-01-22 17:03:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Fail the task when an event is seen that the worker must handle but is not familiar with


---

<a id="1297"></a>

### #1297: Update handle needs to be invoked immediately when registered with pending updates

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1297 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-21 18:19:12.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-04 21:27:00.000 UTC |
| **Closed** | 2023-12-04 21:26:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

 Update handle needs to be invoked immediately when registered with pending updates. If we do not it is possible a workflow function may return before the update handle is called, preventing the workflow from properly handling the update.


For example:
```Go
inFlightUpdates := 0
SetUpdateHandlerWithOptions(
	ctx,
	updateName,
	func() (T, error) {
                 inFlightUpdates = inFlightUpdates + 1
		// << change Workflow state >>

		return <result>, nil
	},
)

Await(inFlightUpdates == 0) // until Workflow is done
return
```
here the update handle won't be invoked until after the return so the `Await` won't work as intended


---

<a id="1290"></a>

### #1290: Context propagators aren't used when running local activities with the test environments

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1290 |
| **State** | CLOSED |
| **Author** | DeRauk (DeRauk Gibble) |
| **Created** | 2023-11-08 16:18:11.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-08 19:47:00.000 UTC |
| **Closed** | 2023-11-08 19:47:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When using the [ExecuteLocalActivity](https://github.com/temporalio/sdk-go/blob/0352634b45b1b81293c9bf3cec3bb033b82f841f/internal/workflow_testsuite.go#L196) method in `TestActivityEnvironment` struct, any context propagators configured for the test environment should be used.

## Actual Behavior
The context propagators are not used.

## Steps to Reproduce the Problem
Write a test configured with a context propagator that invokes a local activity. Try to access the injected context values in that activity.

Example: https://gist.github.com/DeRauk/aaecab6eaca325d25e354661acae3711

## Specifications

  - Version:  v1.25.1
  - Platform: OSX



---

<a id="1289"></a>

### #1289: [Feature Request] Tag workflow_task_execution_failed with error type

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1289 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-07 16:12:53.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-30 17:20:55.000 UTC |
| **Closed** | 2023-11-30 17:20:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

see https://github.com/temporalio/features/issues/231



---

<a id="1283"></a>

### #1283: Remove ClientOutboundInterceptor.PollWorkflowUpdate

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1283 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-10-27 19:37:46.000 UTC (2y 2m ago) |
| **Updated** | 2023-10-27 19:37:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

This does not need to be interceptable any more than getting a workflow result does


---

<a id="1272"></a>

### #1272: Failed Read-Only check should cause a WFT failure in an update validator, not fail the update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1272 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-18 14:12:09.000 UTC (2y 2m ago) |
| **Updated** | 2023-12-30 17:04:31.000 UTC |
| **Closed** | 2023-12-30 17:04:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Failed read-Only check should cause a WFT failure 

## Actual Behavior
Failed read-Only check fails the update




---

<a id="1266"></a>

### #1266: `loggerWith.WithCallerSkip` should expand keyvals

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1266 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-12 16:00:02.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-13 15:57:41.000 UTC |
| **Closed** | 2023-10-13 15:57:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`loggerWith.WithCallerSkip` should expand `keyvals`

## Actual Behavior
`loggerWith.WithCallerSkip` does not expand `keyvals`

```
func (l *withLogger) WithCallerSkip(depth int) Logger {
	if sl, ok := l.logger.(WithSkipCallers); ok {
		return newWithLogger(sl.WithCallerSkip(depth), l.keyvals)
	}
	return l
}
```

https://github.com/temporalio/sdk-go/pull/1219



---

<a id="1263"></a>

### #1263: Add TestWorkflowEnvironment#UpdateWorkflowByID

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1263 |
| **State** | CLOSED |
| **Author** | robholland (Rob Holland) |
| **Created** | 2023-10-11 09:40:06.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-12 20:55:40.000 UTC |
| **Closed** | 2023-10-12 20:55:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
For testing we need UpdateWorkflowByID as the update equivalent of SignalWorkflowByID. This is needed to, for example, send an update to a child workflow of the workflow under test.

**Describe alternatives you've considered**
I can write a workflow in the test environment that sends the updates, but that is clumsy and complicates the tests.



---

<a id="1252"></a>

### #1252: Panics in update state machine don't cause WFT failures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1252 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-02 18:12:20.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-02 23:43:27.000 UTC |
| **Closed** | 2023-10-02 23:43:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Panics in update state machine should be treated like panics in command state machines.

## Actual Behavior
Panics in update state machine are not handled




---

<a id="1250"></a>

### #1250: Don't use versioned workers for eager workflow start

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1250 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-27 21:51:39.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-28 02:46:24.000 UTC |
| **Closed** | 2023-09-28 02:46:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently there is a bug with eager workflow start + worker versioning. If a client is used to start a workflow on a task queue with versioning enabled and enables eager workflow start and their is a local worker listening on that task queue, the server will return an eager workflow task for the start workflow request regardless of what version that local version is. 


---

<a id="1248"></a>

### #1248: Enable TCP Keep alive by default

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1248 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-26 15:11:59.000 UTC (2y 3m ago) |
| **Updated** | 2023-12-01 16:15:14.000 UTC |
| **Closed** | 2023-12-01 16:15:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Enable TCP Keep alive by default

https://github.com/temporalio/features/issues/123



---

<a id="1243"></a>

### #1243: Add start delay to start workflow options

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1243 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-19 17:01:05.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-24 04:57:21.000 UTC |
| **Closed** | 2023-09-24 04:57:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/338



---

<a id="1240"></a>

### #1240: Data race after deadlock detector fired

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1240 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-18 21:42:54.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-18 21:42:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Data race observed in `VersionLoopWorkflow`, after the deadlock detector fired. `VersionLoopWorkflow` has no defer's or cancellation that are known issues. Likely suspect is this [PR](https://github.com/temporalio/sdk-go/commit/a059d880141b183ccf18c081caea66748747c296)

https://github.com/temporalio/sdk-go/actions/runs/6227934624/job/16903653066

```
2023/09/18 21:09:04 ERROR Workflow panic Namespace integration-test-namespace TaskQueue tq-62779e48-2585-42cd-b9d3-6945da2ebf53-TestIntegrationSuite/TestVersionLoopWorkflow WorkerID 16605@fv-az437-13@ WorkflowType VersionLoopWorkflow WorkflowID test-version-loop-workflow RunID 676d31fa-41ab-4afa-8533-46a73d2b28e6 Attempt 1 Error Potential deadlock detected: workflow goroutine "root" didn't yield for over a second StackTrace process event for tq-62779e48-2585-42cd-b9d3-6945da2ebf53-TestIntegrationSuite/TestVersionLoopWorkflow [panic]:
go.temporal.io/sdk/internal.(*coroutineState).call(0xc00064e870, 0x3b9aca00)
	/home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1011 +0x2cb
go.temporal.io/sdk/internal.(*dispatcherImpl).ExecuteUntilAllBlocked(0xc00012c780, 0x1645f00?)
	/home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1108 +0x2d7
go.temporal.io/sdk/internal.executeDispatcher({0x19c9dc0, 0xc00012c840}, {0x19cb8c0, 0xc00012c780}, 0xc000250f90?)
	/home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:622 +0xc8
go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted(0xc00014a240, 0x179?)
	/home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:592 +0x89
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc000012840, 0xc0004b9700, 0x0, 0x1)
	/home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1063 +0x603
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc000520bd0, 0xc0004c0930)
	/home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fca
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc0007ccea0, 0xc0004c0930, 0xc000520bd0, 0xc0002513e0)
	/home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69c
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc0005c26c0, 0xc0004c0930)
	/home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x756
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc0005c26c0, {0x161d060?, 0xc0004c0930?})
	/home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xcb
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc0003beb00, {0x161cba0, 0xc000cca6c0})
	/home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x256
go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
	/home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8c
created by go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync
	/home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:352 +0x13a
2023/09/18 21:09:04 WARN  Serialized size of TemporalChangeVersion search attribute update would exceed the maximum value size. Skipping this upsert. Be aware that your visibility records will not include the following patch: changeID_2:0-1 Namespace integration-test-namespace TaskQueue tq-62779e48-2585-42cd-b9d3-6945da2ebf53-TestIntegrationSuite/TestVersionLoopWorkflow WorkerID 16605@fv-az437-13@ WorkflowType VersionLoopWorkflow WorkflowID test-version-loop-workflow RunID 676d31fa-41ab-4afa-8533-46a73d2b28e6 Attempt 1
==================
WARNING: DATA RACE
Read at 0x00c000250fc0 by goroutine 6063:
  runtime.mapaccess2()
      /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/map.go:456 +0x0
  go.temporal.io/sdk/internal.(*commandsHelper).addCommand()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:929 +0xb6
  go.temporal.io/sdk/internal.(*commandsHelper).recordVersionMarker()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1073 +0x512
  go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:799 +0x734
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).GetVersion()
      <autogenerated>:1 +0x78
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1681 +0x6f
  go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:336 +0x9a
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).GetVersion()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/internal.GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1677 +0xb7
  go.temporal.io/sdk/workflow.GetVersion()
      /home/runner/work/sdk-go/sdk-go/workflow/workflow.go:384 +0x19e
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/workflow_test.go:2319 +0x113
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow-fm()
      <autogenerated>:1 +0x92
  runtime.call64()
      /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/asm_amd64.s:730 +0x48
  reflect.Value.Call()
      /opt/hostedtoolcache/go/1.20.8/x64/src/reflect/value.go:370 +0xc7
  go.temporal.io/sdk/internal.executeFunction()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:[1806](https://github.com/temporalio/sdk-go/actions/runs/6227934624/job/16903653066#step:7:1807) +0x5b0
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:530 +0x23e
  go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:154 +0x76
  go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4136 +0x18e
  go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:805 +0x41a
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:512 +0x189
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1057 +0x165
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1058 +0x47

Previous write at 0x00c000250fc0 by goroutine 6062:
  runtime.mapdelete()
      /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/map.go:695 +0x0
  go.temporal.io/sdk/internal.(*commandStateMachineBase).moveState()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:430 +0x646
  go.temporal.io/sdk/internal.(*markerCommandStateMachine).handleCommandSent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:836 +0xab
  go.temporal.io/sdk/internal.(*commandsHelper).getCommands()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1417 +0x276
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).CompleteWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1244 +0x81b
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).applyWorkflowPanicPolicy()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1142 +0x1064
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1088 +0x1676
  go.temporal.io/sdk/internal.executeDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:622 +0xc7
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:592 +0x88
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1063 +0x602
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6063 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1048 +0x66e
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:308 +0x86
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4093 +0x201
  go.temporal.io/sdk/internal.newDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:614 +0x27e
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:499 +0x1c4
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).handleWorkflowExecutionStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1269 +0x36b
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1044 +0x20e
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6062 (running) created at:
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:352 +0x139
  go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:382 +0x116
  go.temporal.io/sdk/internal.(*baseWorker).Start.func3()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:284 +0x39
==================
==================
WARNING: DATA RACE
Read at 0x00c000250f90 by goroutine 6063:
  container/list.(*List).lazyInit()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:86 +0x131
  container/list.(*List).PushBack()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:151 +0x12c
  go.temporal.io/sdk/internal.(*commandsHelper).addCommand()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:933 +0xd2
  go.temporal.io/sdk/internal.(*commandsHelper).recordVersionMarker()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1073 +0x512
  go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:799 +0x734
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).GetVersion()
      <autogenerated>:1 +0x78
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1681 +0x6f
  go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:336 +0x9a
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).GetVersion()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/internal.GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1677 +0xb7
  go.temporal.io/sdk/workflow.GetVersion()
      /home/runner/work/sdk-go/sdk-go/workflow/workflow.go:384 +0x19e
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/workflow_test.go:2319 +0x113
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow-fm()
      <autogenerated>:1 +0x92
  runtime.call64()
      /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/asm_amd64.s:730 +0x48
  reflect.Value.Call()
      /opt/hostedtoolcache/go/1.20.8/x64/src/reflect/value.go:370 +0xc7
  go.temporal.io/sdk/internal.executeFunction()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:1806 +0x5b0
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:530 +0x23e
  go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:154 +0x76
  go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4136 +0x18e
  go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:805 +0x41a
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:512 +0x189
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1057 +0x165
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1058 +0x47

Previous write at 0x00c000250f90 by goroutine 6062:
  container/list.(*List).remove()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:109 +0x445
  container/list.(*List).Remove()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:138 +0x40a
  go.temporal.io/sdk/internal.(*commandStateMachineBase).moveState()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:429 +0x395
  go.temporal.io/sdk/internal.(*markerCommandStateMachine).handleCommandSent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:836 +0xab
  go.temporal.io/sdk/internal.(*commandsHelper).getCommands()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1417 +0x276
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).CompleteWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1244 +0x81b
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).applyWorkflowPanicPolicy()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1142 +0x1064
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1088 +0x1676
  go.temporal.io/sdk/internal.executeDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:622 +0xc7
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:592 +0x88
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1063 +0x602
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6063 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1048 +0x66e
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:308 +0x86
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4093 +0x201
  go.temporal.io/sdk/internal.newDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:614 +0x27e
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:499 +0x1c4
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).handleWorkflowExecutionStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1269 +0x36b
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1044 +0x20e
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6062 (running) created at:
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:352 +0x139
  go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:382 +0x116
  go.temporal.io/sdk/internal.(*baseWorker).Start.func3()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:284 +0x39
==================
==================
WARNING: DATA RACE
Read at 0x00c000250f98 by goroutine 6063:
  container/list.(*List).PushBack()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:152 +0x1c4
  go.temporal.io/sdk/internal.(*commandsHelper).addCommand()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:933 +0xd2
  go.temporal.io/sdk/internal.(*commandsHelper).recordVersionMarker()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1073 +0x512
  go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:799 +0x734
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).GetVersion()
      <autogenerated>:1 +0x78
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1681 +0x6f
  go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:336 +0x9a
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).GetVersion()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/internal.GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1677 +0xb7
  go.temporal.io/sdk/workflow.GetVersion()
      /home/runner/work/sdk-go/sdk-go/workflow/workflow.go:384 +0x19e
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/workflow_test.go:2319 +0x113
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow-fm()
      <autogenerated>:1 +0x92
  runtime.call64()
      /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/asm_amd64.s:730 +0x48
  reflect.Value.Call()
      /opt/hostedtoolcache/go/1.20.8/x64/src/reflect/value.go:370 +0xc7
  go.temporal.io/sdk/internal.executeFunction()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:1806 +0x5b0
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:530 +0x23e
  go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:154 +0x76
  go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4136 +0x18e
  go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:805 +0x41a
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:512 +0x189
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1057 +0x165
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1058 +0x47

Previous write at 0x00c000250f98 by goroutine 6062:
  container/list.(*List).remove()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:110 +0x4ac
  container/list.(*List).Remove()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:138 +0x40a
  go.temporal.io/sdk/internal.(*commandStateMachineBase).moveState()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:429 +0x395
  go.temporal.io/sdk/internal.(*markerCommandStateMachine).handleCommandSent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:836 +0xab
  go.temporal.io/sdk/internal.(*commandsHelper).getCommands()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1417 +0x276
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).CompleteWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1244 +0x81b
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).applyWorkflowPanicPolicy()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1142 +0x1064
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1088 +0x1676
  go.temporal.io/sdk/internal.executeDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:622 +0xc7
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:592 +0x88
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1063 +0x602
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6063 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1048 +0x66e
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:308 +0x86
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4093 +0x201
  go.temporal.io/sdk/internal.newDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:614 +0x27e
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:499 +0x1c4
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).handleWorkflowExecutionStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1269 +0x36b
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1044 +0x20e
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6062 (running) created at:
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:352 +0x139
  go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:382 +0x116
  go.temporal.io/sdk/internal.(*baseWorker).Start.func3()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:284 +0x39
==================
==================
WARNING: DATA RACE
Read at 0x00c000250fb8 by goroutine 6063:
  container/list.(*List).insert()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:98 +0x3f8
  container/list.(*List).insertValue()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:104 +0x1d3
  container/list.(*List).PushBack()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:152 +0x1b8
  go.temporal.io/sdk/internal.(*commandsHelper).addCommand()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:933 +0xd2
  go.temporal.io/sdk/internal.(*commandsHelper).recordVersionMarker()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1073 +0x512
  go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:799 +0x734
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).GetVersion()
      <autogenerated>:1 +0x78
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1681 +0x6f
  go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:336 +0x9a
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).GetVersion()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/internal.GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1677 +0xb7
  go.temporal.io/sdk/workflow.GetVersion()
      /home/runner/work/sdk-go/sdk-go/workflow/workflow.go:384 +0x19e
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/workflow_test.go:2319 +0x113
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow-fm()
      <autogenerated>:1 +0x92
  runtime.call64()
      /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/asm_amd64.s:730 +0x48
  reflect.Value.Call()
      /opt/hostedtoolcache/go/1.20.8/x64/src/reflect/value.go:370 +0xc7
  go.temporal.io/sdk/internal.executeFunction()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:1806 +0x5b0
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:530 +0x23e
  go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:154 +0x76
  go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4136 +0x18e
  go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:805 +0x41a
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:512 +0x189
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1057 +0x165
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1058 +0x47

Previous write at 0x00c000250fb8 by goroutine 6062:
  container/list.(*List).remove()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:114 +0x59c
  container/list.(*List).Remove()
      /opt/hostedtoolcache/go/1.20.8/x64/src/container/list/list.go:138 +0x40a
  go.temporal.io/sdk/internal.(*commandStateMachineBase).moveState()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:429 +0x395
  go.temporal.io/sdk/internal.(*markerCommandStateMachine).handleCommandSent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:836 +0xab
  go.temporal.io/sdk/internal.(*commandsHelper).getCommands()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1417 +0x276
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).CompleteWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1244 +0x81b
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).applyWorkflowPanicPolicy()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1142 +0x1064
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1088 +0x1676
  go.temporal.io/sdk/internal.executeDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:622 +0xc7
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:592 +0x88
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1063 +0x602
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6063 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1048 +0x66e
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:308 +0x86
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4093 +0x201
  go.temporal.io/sdk/internal.newDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:614 +0x27e
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:499 +0x1c4
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).handleWorkflowExecutionStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1269 +0x36b
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1044 +0x20e
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6062 (running) created at:
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:352 +0x139
  go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:382 +0x116
  go.temporal.io/sdk/internal.(*baseWorker).Start.func3()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:284 +0x39
==================
==================
WARNING: DATA RACE
Write at 0x00c000055ef8 by goroutine 6063:
  go.temporal.io/sdk/internal.(*commandsHelper).addCommand()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:934 +0x48a
  go.temporal.io/sdk/internal.(*commandsHelper).recordVersionMarker()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1073 +0x512
  go.temporal.io/sdk/internal.(*workflowEnvironmentImpl).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:799 +0x734
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).GetVersion()
      <autogenerated>:1 +0x78
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1681 +0x6f
  go.temporal.io/sdk/internal.(*WorkflowOutboundInterceptorBase).GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:336 +0x9a
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).GetVersion()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/internal.GetVersion()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:1677 +0xb7
  go.temporal.io/sdk/workflow.GetVersion()
      /home/runner/work/sdk-go/sdk-go/workflow/workflow.go:384 +0x19e
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/workflow_test.go:2319 +0x113
  go.temporal.io/sdk/test_test.(*Workflows).VersionLoopWorkflow-fm()
      <autogenerated>:1 +0x92
  runtime.call64()
      /opt/hostedtoolcache/go/1.20.8/x64/src/runtime/asm_amd64.s:730 +0x48
  reflect.Value.Call()
      /opt/hostedtoolcache/go/1.20.8/x64/src/reflect/value.go:370 +0xc7
  go.temporal.io/sdk/internal.executeFunction()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:1806 +0x5b0
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/workflow.go:530 +0x23e
  go.temporal.io/sdk/internal.(*WorkflowInboundInterceptorBase).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/internal/interceptor_base.go:154 +0x76
  go.temporal.io/sdk/test_test.(*signalWorkflowInboundInterceptor).ExecuteWorkflow()
      <autogenerated>:1 +0x29
  go.temporal.io/sdk/test_test.(*tracingWorkflowInboundInterceptor).ExecuteWorkflow()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4136 +0x18e
  go.temporal.io/sdk/internal.(*workflowExecutor).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker.go:805 +0x41a
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:512 +0x189
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1057 +0x165
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func2()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1058 +0x47

Previous read at 0x00c000055ef8 by goroutine 6062:
  go.temporal.io/sdk/internal.(*commandStateMachineBase).moveState()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:428 +0x377
  go.temporal.io/sdk/internal.(*markerCommandStateMachine).handleCommandSent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:836 +0xab
  go.temporal.io/sdk/internal.(*commandsHelper).getCommands()
      /home/runner/work/sdk-go/sdk-go/internal/internal_command_state_machine.go:1417 +0x276
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).CompleteWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1244 +0x81b
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).applyWorkflowPanicPolicy()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1142 +0x1064
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1088 +0x1676
  go.temporal.io/sdk/internal.executeDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:622 +0xc7
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).OnWorkflowTaskStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:592 +0x88
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1063 +0x602
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6063 (running) created at:
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:1048 +0x66e
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:308 +0x86
  go.temporal.io/sdk/test_test.(*tracingWorkflowOutboundInterceptor).Go()
      /home/runner/work/sdk-go/sdk-go/test/integration_test.go:4093 +0x201
  go.temporal.io/sdk/internal.newDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:614 +0x27e
  go.temporal.io/sdk/internal.(*syncWorkflowDefinition).Execute()
      /home/runner/work/sdk-go/sdk-go/internal/internal_workflow.go:499 +0x1c4
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).handleWorkflowExecutionStarted()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1269 +0x36b
  go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent()
      /home/runner/work/sdk-go/sdk-go/internal/internal_event_handlers.go:1044 +0x20e
  go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:1028 +0x1fc9
  go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_handlers.go:836 +0x69b
  go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:354 +0x755
  go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_task_pollers.go:318 +0xca
  go.temporal.io/sdk/internal.(*baseWorker).processTask()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:505 +0x255
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync.func1()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:356 +0x8b

Goroutine 6062 (running) created at:
  go.temporal.io/sdk/internal.(*baseWorker).processTaskAsync()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:352 +0x139
  go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:382 +0x116
  go.temporal.io/sdk/internal.(*baseWorker).Start.func3()
      /home/runner/work/sdk-go/sdk-go/internal/internal_worker_base.go:284 +0x39
==================
[2023](https://github.com/temporalio/sdk-go/actions/runs/6227934624/job/16903653066#step:7:2024)/09/18 21:09:05 WARN  Serialized size of TemporalChangeVersion search attribute update would exceed the maximum value size. Skipping this upsert. Be aware that your visibility records will not include the following patch: changeID_2:1-1 Namespace integration-test-namespace T
``


---

<a id="1238"></a>

### #1238: Bad Update mock in NamespaceClient breaks mocking calls to this function

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1238 |
| **State** | CLOSED |
| **Author** | jkinkead (Jesse Kinkead) |
| **Created** | 2023-09-15 02:58:28.000 UTC (2y 3m ago) |
| **Updated** | 2023-12-27 17:12:18.000 UTC |
| **Closed** | 2023-12-27 17:12:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

[This line](https://github.com/temporalio/sdk-go/blob/ecfaa6563f168ea023e3ee83abf52f7d6ca552a8/mocks/NamespaceClient.go#L80) is missing the `request` argument to the `Update` function. This means that there is _always_ a mismatch in arguments when attempting to use this mock to return values.


---

<a id="1237"></a>

### #1237: Support build ID reachability API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1237 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-13 22:59:10.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-04 16:38:54.000 UTC |
| **Closed** | 2023-10-04 16:38:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Build ID reachability API should be supported in the Go SDK

https://docs.temporal.io/workers#build-id-reachability



---

<a id="1236"></a>

### #1236: Test `TestVersionLoopWorkflow` can sometimes fail because the workflow does not yield for more then a second 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1236 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-13 18:58:36.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-24 04:01:50.000 UTC |
| **Closed** | 2023-09-24 04:01:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I believe this is just because the `for` loop in the test takes too long. We can probably just reduce the number of iteration in the loop


example failure:

https://github.com/temporalio/sdk-go/actions/runs/6176513119/job/16765594126


---

<a id="1235"></a>

### #1235: Defers in `workflow.Go` should be run deterministically and in sequence on cache eviction.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1235 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-13 18:48:00.000 UTC (2y 3m ago) |
| **Updated** | 2024-01-22 16:29:56.000 UTC |
| **Closed** | 2024-01-22 16:29:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Defers in `workflow.Go` should be run deterministically and in sequence on cache eviction.

## Actual Behavior

Defers in `workflow.Go` should be run in parallel.

## Steps to Reproduce the Problem
See https://github.com/temporalio/sdk-go/issues/1209

while https://github.com/temporalio/sdk-go/pull/1210 fixed the main consequence of the defers running in parallel there are still some edge cases where running the defers in parallel could cause problems for users.

When we fix this we need to make sure we think about how this will effect trying to evict a stuck workflow and make sure we don't block the cache eviction on this case



---

<a id="1234"></a>

### #1234: Disable creating a session worker and a versioned worker together

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1234 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-13 18:43:45.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-24 04:26:56.000 UTC |
| **Closed** | 2023-09-24 04:26:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Due to https://github.com/temporalio/sdk-go/issues/1227, users cannot combine sessions and worker versioning . Until the version API can handle the constraints of sessions we agreeded to fail when trying to combine sessions and worker version.



---

<a id="1218"></a>

### #1218: [Feature Request] Typed search attributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1218 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-08-30 15:04:48.000 UTC (2y 4m ago) |
| **Updated** | 2024-02-01 18:46:53.000 UTC |
| **Closed** | 2024-02-01 18:46:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Describe the solution you'd like:

Implementation of [typed search attributes](https://github.com/temporalio/proposals/blob/master/sdk-typed-search-attributes.md).




---

<a id="1197"></a>

### #1197: Drain polled tasks on shutdown

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1197 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-08-10 13:29:34.000 UTC (2y 5m ago) |
| **Updated** | 2023-08-10 13:29:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When a worker is shutting down, if it has polled for tasks, but not started processing them it will drop them and continue to close

**Describe the solution you'd like**
When a worker is shutting down, it should stop accepting new tasks, but let any it already has polled try to be processed in the worker stop timeout

**Additional context**
https://github.com/temporalio/sdk-go/pull/1195


---

<a id="1194"></a>

### #1194: Update sdk-name and sdk-version in task-level metadata if changed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1194 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-08-09 20:30:36.000 UTC (2y 5m ago) |
| **Updated** | 2023-09-25 23:22:08.000 UTC |
| **Closed** | 2023-09-25 23:22:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Independently, if either SDK name or SDK version changed on the workflow from what was last seen on some task, set it to the current values (same values as client-name and client-version gRPC headers).

See https://github.com/temporalio/features/issues/321


---

<a id="1189"></a>

### #1189: Package docs on testsuite incorrectly showing license instead

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1189 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-08-07 13:29:59.000 UTC (2y 5m ago) |
| **Updated** | 2023-08-10 15:58:33.000 UTC |
| **Closed** | 2023-08-10 15:58:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

https://pkg.go.dev/go.temporal.io/sdk lists all first sentences of package-level docs.

## Actual Behavior

It shows "The MIT License" for `testsuite` because https://pkg.go.dev/go.temporal.io/sdk/testsuite is showing the license as the package docs because https://github.com/temporalio/sdk-go/blob/master/testsuite/freeport.go does not put a blank line between license and `package` declaration.


---

<a id="1173"></a>

### #1173: Enable testing with OnActivity and non-retryable errors to verify options are set correctly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1173 |
| **State** | OPEN |
| **Author** | underrun (J Derek Wilson) |
| **Created** | 2023-07-26 15:05:08.000 UTC (2y 5m ago) |
| **Updated** | 2023-07-26 15:05:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When working with non-retryable errors in activites where those errors are set as non-retryable via activity options there isn't an obvious way to test to make sure the activity options have been set correctly when testing errors returned from activities. We can test errors returned from activities using `OnActivity` in test code and we can use that to make sure the workflow invoking the activity handles the error correctly, but it doesn't look like theres any way to verify that the error is also properly set as non-retryable - because the error returned from `OnActivity` is always marked as retryable.

The issue with this is that with string matching being used to detect errors and whether or not to retry them, I don't have a good way to verify that the activity options i've set in the workflow will actually result in the error i want to fall through actually not being retried.

**Describe the solution you'd like**
Ideally i'd like testing with `OnActivity` to fail a test if it tries to return an activity that is set as retryable from the workflow setting its activity options. I'd also like non-retryable errors returned from `OnActivity` to have them properly marked as non-retryable. 

**Describe alternatives you've considered**
there isn't a good alternative to know that i've set the error as non-retryable properly from temporal's perspective. I can verify that I set it to what I think the error name is or even do some reflection and verify that the string i'm passing in is the error i want to handle. but this isn't super easy and can also miss things like whether or not errors in modules need the `module.WhateverError` or just `WhateverError` or if it doesn't matter.

**Additional context**
None


---

<a id="1157"></a>

### #1157: Support LocalActivityOptions.WaitForCancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1157 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-07-06 19:26:59.000 UTC (2y 6m ago) |
| **Updated** | 2023-07-06 19:26:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Local activities need to be able to react to worker stop cancellation if they want. I have not investigated how hard this is to implement.


---

<a id="1155"></a>

### #1155: Support intercepting `workflow.Await` on WorkflowOutboundInterceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1155 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-07-05 20:15:58.000 UTC (2y 6m ago) |
| **Updated** | 2023-07-17 17:26:27.000 UTC |
| **Closed** | 2023-07-17 17:26:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Many `workflow` package calls are on `WorkflowOutboundInterceptor`, but not this one yet. We should add it.


---

<a id="1132"></a>

### #1132: Add support for visiting all payloads at once in proxy visitor interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1132 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-06-08 22:34:39.000 UTC (2y 7m ago) |
| **Updated** | 2023-06-08 22:34:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

This is for the https://github.com/temporalio/api-go project but it doesn't accept issues.

Today the payload visitor in https://pkg.go.dev/go.temporal.io/api/proxy visits sets of payloads as they are seen one set at a time. Users want to collect these and then visit them together all at once. Here's how they collect them all in user-land:

```go
func CollectAllPayloads(msg proto.Message) (payloads []*common.Payload, err error) {
	err = proxy.VisitPayloads(context.Background(), msg, proxy.VisitPayloadsOptions{
		Visitor: func(ctx *proxy.VisitPayloadsContext, p []*common.Payload) ([]*common.Payload, error) {
			payloads = append(payloads, p...)
			return p, nil
		},
		SkipSearchAttributes: true,
	})
	return
}
```

And a utility to apply something to all payloads:

```go
func ApplyToAllPayloads(msg proto.Message, apply ApplyFunc) error {
	payloads, err := CollectAllPayloads(msg)
	if err != nil {
		return err
	}
	newPayloads, err := apply(payloads)
	if err != nil {
		return err
	}
	if len(newPayloads) != len(payloads) {
		return fmt.Errorf("expected %v payload(s), got %v", len(payloads), len(newPayloads))
	}
	// Clear and merge new payloads onto old ones
	// this mutates the payloads var
	for i, payload := range payloads {
		payload.Reset()
		proto.Merge(payload, newPayloads[i])
	}
	return nil
}
```

Then how they may invoke them all at once in the interceptor:

```go
type AllPayloadVisitorInterceptorOptions struct {
	OutboundApplyAll func([]*common.Payload) ([]*common.Payload, error)
	InboundApplyAll  func([]*common.Payload) ([]*common.Payload, error)
}

func NewAllPayloadVisitorInterceptor(options AllPayloadVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {
	return func(ctx context.Context, method string, req, response interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		if reqMsg, ok := req.(proto.Message); ok && options.OutboundApplyAll != nil {
			err := ApplyToAllPayloads(reqMsg, options.OutboundApplyAll)
			if err != nil {
				return err
			}
		}

		err := invoker(ctx, method, req, response, cc, opts...)
		if err != nil {
			return err
		}

		if resMsg, ok := response.(proto.Message); ok && options.InboundApplyAll != nil {
			return ApplyToAllPayloads(resMsg, options.InboundApplyAll)
		}

		return nil
	}, nil
}
```

Basically we need this functionality opt-in. The best solution is probably some kind of `AllAtOnce bool` option on `VisitPayloadsOptions`, with documentation saying that every output payload must be 1:1 with input, and that the payloads still need to be able to be handled individually on in/out (i.e. you can't encrypt them together as one blob, because they need to be isolated), and that `VisitPayloadsContext.Parent` will be nil for the single visit call we will make.


---

<a id="1131"></a>

### #1131: worker.Options.WorkerActivitiesPerSecond applies after poll is received

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1131 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-06-07 15:28:47.000 UTC (2y 7m ago) |
| **Updated** | 2023-06-07 15:28:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Since this rate limit is applied post-poll-pre-process, server timeouts apply while it is waiting. We even have a doc on this field saying users can set it to a fraction of a second, e.g. 1 activity every 10s, but if they had a heartbeat timeout, it could timeout before it starts.

We should either fix this (hard) or at least document this warning on the field.


---

<a id="1127"></a>

### #1127: TestWorkflowEnvironment support mocking Activity without pre-registering but doesn't support for Workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1127 |
| **State** | CLOSED |
| **Author** | edmondop (Edmondo Porcu) |
| **Created** | 2023-06-05 21:47:44.000 UTC (2y 7m ago) |
| **Updated** | 2023-07-15 22:22:02.000 UTC |
| **Closed** | 2023-07-15 22:22:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Workflows that are mocked are automatically registered when using a `reflect.Func` as a `reflect.TypeOf(workflow)` when invoking the api `OnWorkflow`, the same way this happens using `OnActivity`

## Actual Behavior

In the `OnActivity` method, the Activity is registered here: https://github.com/temporalio/sdk-go/blob/master/internal/workflow_testsuite.go#LL338C1-L340C36

while in the OnWorkflow method there is no automatic registration https://github.com/temporalio/sdk-go/blob/master/internal/workflow_testsuite.go#L399

Also, when the activity is mocked by Name, since registering the activity requires a `reflect.Func`, the function fails if the activity hasn't been registered before. 

https://github.com/temporalio/sdk-go/blob/master/internal/workflow_testsuite.go#L345-L349

while this is not happening when mocking the workflow by name (which doesn't work, but doesn't return an error)




---

<a id="1098"></a>

### #1098: Test CI on all platforms we support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1098 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-05-02 12:52:15.000 UTC (2y 8m ago) |
| **Updated** | 2023-11-28 16:36:38.000 UTC |
| **Closed** | 2023-11-28 16:36:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Every platform we support should be tested in CI. See what we do in Python and .NET for an example.


---

<a id="1091"></a>

### #1091: Replaying Workflow History Yields Unexpected Error Due to Unknown Field "workerVersioningId"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1091 |
| **State** | CLOSED |
| **Author** | tomwheeler (Tom Wheeler) |
| **Created** | 2023-04-19 16:36:54.000 UTC (2y 8m ago) |
| **Updated** | 2023-04-19 19:56:36.000 UTC |
| **Closed** | 2023-04-19 19:56:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I have an automated test that uses `ReplayWorkflowHistoryFromJSONFile` to verify compatibility of a Workflow Definition with the JSON file representing the history of a previous execution. The test passes when using Go SDK v.1.19.0 and I expected that it would continue to pass after I upgraded to Go SDK v1.22.1.

## Actual Behavior

When using Go SDK v1.22.1, the test fails with this error:

```
      Error:   Received unexpected error:
                  unknown field "workerVersioningId" in history.WorkflowTaskCompletedEventAttributes
```

This is likely occurring because several of the Events in the JSON file have a `workerVersioningId` attribute and all of those have a `null` value. For example:

```
    {
      "eventId": "120",
      "eventTime": "2023-02-23T22:36:23.449411426Z",
      "eventType": "WorkflowTaskCompleted",
      "version": "0",
      "taskId": "1048893",
      "workerMayIgnore": false,
      "workflowTaskCompletedEventAttributes": {
        "scheduledEventId": "118",
        "startedEventId": "119",
        "identity": "89088@twwmbp@",
        "binaryChecksum": "c71778aac6cf45bd5e0f83254734a73a",
        "workerVersioningId": null
      }
    },
```

While the ideal solution is probably to ensure that the Web UI does not include null attributes like these, the fact that there's a version in production that includes them means that the SDK probably needs to handle them (i.e., by ignoring them instead of returning the error).

NOTE: I downloaded the JSON file from the Temporal Web UI. It was _likely_ version 2.10.3, but since I downloaded that file several weeks ago, I can't be 100% sure about which version I was running at the time. Also note that this may be the same problem originally reported in [#1084](https://github.com/temporalio/sdk-go/issues/1084), but there's not enough detail in that issue for me to be sure of that.

## Steps to Reproduce the Problem

I have created a git repo with an example you can use to reproduce the problem:

  1. `git clone git@github.com:tomwheeler/workflow-replayer-bug-reproduction.git`
  1. `cd workflow-replayer-bug-reproduction/example`
  1. `go test`

You should observe the failure. You can then checkout the `sdk-v1.19.0`, run `go mod tidy`, and repeat the steps to observe that the test passes when using the older Go SDK (v1.19.0 instead of v.1.22.1).


## Specifications

  - Version: Go SDK 1.22.1
  - Platform: macOS



---

<a id="1087"></a>

### #1087: Expose OriginalRunId and FirstRunId 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1087 |
| **State** | CLOSED |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2023-04-13 21:57:11.000 UTC (2y 9m ago) |
| **Updated** | 2023-04-24 13:10:27.000 UTC |
| **Closed** | 2023-04-24 13:10:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

They are already provided in Java SDK: https://github.com/temporalio/sdk-java/blob/4f91956597b6218f18de39509e19b61d01f9a08c/temporal-sdk/src/main/java/io/temporal/workflow/WorkflowInfo.java#L85

And also Cadence Golang SDK:
https://github.com/uber-go/cadence-client/blob/18c143aa5b28f24e59c8579a26a20db62f54e101/internal/workflow.go#L1097


---

<a id="1074"></a>

### #1074: Update client API docs related to visibility

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1074 |
| **State** | CLOSED |
| **Author** | rodrigozhou (Rodrigo Zhou) |
| **Created** | 2023-03-28 23:20:23.000 UTC (2y 9m ago) |
| **Updated** | 2023-08-04 17:00:49.000 UTC |
| **Closed** | 2023-08-04 17:00:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
No.

**Describe the solution you'd like**
Update client API docs related to visibility since advanced visibility features are now available with SQL DB (eg: https://github.com/temporalio/sdk-go/blob/88a40de39c33a2dfbcbe23a8684a7217535e10c8/client/client.go#L369-L380)

**Describe alternatives you've considered**
N/A

**Additional context**
N/A



---

<a id="1066"></a>

### #1066: LocalActivity timeouts are inconsistent

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1066 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-03-20 17:06:52.000 UTC (2y 9m ago) |
| **Updated** | 2023-08-02 17:51:31.000 UTC |
| **Closed** | 2023-08-02 17:51:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Local activity timeouts as defined in `LocalActivityOptions`:
```
// LocalActivityOptions stores local activity specific parameters that will be stored inside of a context.
LocalActivityOptions struct {
   ....
    // ScheduleToCloseTimeout - The end to end timeout for the local activity including retries.
    // This field is required.
    ScheduleToCloseTimeout time.Duration

    // StartToCloseTimeout - The timeout for a single execution of the local activity.
    // Optional: defaults to ScheduleToClose
    StartToCloseTimeout time.Duration
}
```
however in the [implementation](https://github.com/temporalio/sdk-go/blob/6a0e7ab04a0ed2c24150a435522c085ae3d618d5/internal/internal_activity.go#L217) we just require one and then override `StartToCloseTimeout` with `ScheduleToCloseTimeout` if it is set.

```
	if p.ScheduleToCloseTimeout == 0 {
		p.ScheduleToCloseTimeout = p.StartToCloseTimeout
	} else {
		p.StartToCloseTimeout = p.ScheduleToCloseTimeout
	}
```

If we fix this bug we have another problem that `StartToCloseTimeout` is not retried because it always treats `ErrDeadlineExceeded` as a `TIMEOUT_TYPE_SCHEDULE_TO_CLOSE `

We also do not have a [ScheduleToStartTimeout](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.19.0/io/temporal/activity/LocalActivityOptions.html#getScheduleToStartTimeout()) like java.


---

<a id="1062"></a>

### #1062: Confusing documentation for client.ExecuteWorkflow API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1062 |
| **State** | CLOSED |
| **Author** | mindaugasrukas (Mind.R.) |
| **Created** | 2023-03-15 17:49:12.000 UTC (2y 10m ago) |
| **Updated** | 2023-10-12 17:23:52.000 UTC |
| **Closed** | 2023-10-12 17:23:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I'm looking to execute a Workflow from a Workflow on another Server instance.
I found the documentation confusing, especially this note:
https://github.com/temporalio/sdk-go/blob/master/client/client.go#L238
```
// NOTE: DO NOT USE THIS API INSIDE A WORKFLOW, USE workflow.ExecuteChildWorkflow instead
```

For my use case, it makes sense to use `client.ExecuteWorkflow`.

**Describe the solution you'd like**
Have clear documentation explaining that my use case is valid and what is the best practice for it.

**Describe alternatives you've considered**
No alternatives.

**Additional context**
No.



---

<a id="1054"></a>

### #1054: EncodedFailureAttributes capability should be respected

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1054 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-03-06 21:53:04.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-06 21:53:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Go SDK respects `EncodedFailureAttributes` capability and only encodes failures if the server supports it.

## Actual Behavior
Go SDK ignores `EncodedFailureAttributes`.




---

<a id="1040"></a>

### #1040: ScheduleCalendarSpec should have a default for every time except year

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1040 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-02-15 22:42:27.000 UTC (2y 10m ago) |
| **Updated** | 2023-02-28 19:32:56.000 UTC |
| **Closed** | 2023-02-28 19:32:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
currently in `ScheduleCalendarSpec`
> For all fields besides year, at least one Range must be present to match anything.

This is difficult for users and is not what was implemented in other SDKs. The ask is to align with other SDKs like typescript and set unset ranges to the zero range when creating a schedule




---

<a id="1010"></a>

### #1010: Missing Heading for "Async/Manual Activity Completion" in Go SDK Doc

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/1010 |
| **State** | CLOSED |
| **Author** | tomwheeler (Tom Wheeler) |
| **Created** | 2023-01-25 02:15:07.000 UTC (2y 11m ago) |
| **Updated** | 2023-01-31 23:05:29.000 UTC |
| **Closed** | 2023-01-31 23:05:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
While reading the Go SDK documentation on [Activity Cancellation](https://pkg.go.dev/go.temporal.io/sdk@v1.20.0/activity#hdr-Activity_Cancellation), I found myself confused by repeated mentions of Task Tokens and Asynchronous Activities. I then realized that this was because I had continued to the next section, which was missing the heading. Instead, what should have been a heading ("Async/Manual Activity Completion") was shown as regular text.

## Actual Behavior
![image](https://user-images.githubusercontent.com/2183904/214463269-1a35ffdb-df48-4d37-86b5-38809d4d7e7a.png)


## Steps to Reproduce the Problem

  1. Navigate to the [Activity Cancellation](https://pkg.go.dev/go.temporal.io/sdk@v1.20.0/activity#hdr-Activity_Cancellation) section of the Go SDK 1.20.0 documentation
  2. Observe the "Activity Cancellation" heading, which is displayed as it should be (bold black text on a light blue background), as depicted in the screenshot above.
  3. Observe the "Async/Manual Activity Completion " text, which is displayed as plain text instead of a heading (also visible in the screenshot above)

I suspect that the slash disqualifies this text as an implicit heading, and therefore prefixing [that line](https://github.com/temporalio/sdk-go/blob/v1.20.0/activity/doc.go#L117) with `# ` to make it an explicit heading might fix it.

## Specifications

  - Version: 1.20.0
  - Platform: macOS (but this is not relevant since it's not a client-side issue)



---

<a id="997"></a>

### #997: Support dynamic query and update handler

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/997 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-05 13:52:58.000 UTC (3 years ago) |
| **Updated** | 2023-12-07 14:06:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Need to allow a dynamic query or update handler that is called when no other query or update handler is found. Its signature must accept a string name and a slice of `converter.EncodedValue` (or we need a `RawValue` or something).


---

<a id="991"></a>

### #991: QueryWorkflowWithOptions not going through interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/991 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-03 15:36:12.000 UTC (3 years ago) |
| **Updated** | 2023-07-24 14:59:00.000 UTC |
| **Closed** | 2023-07-24 14:59:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

The client interceptor for queries should intercept all query calls, not just the non-options form. If this means the with-options form has to check if the error is a query rejected error to convert it to a non-error response, so be it.

## Actual Behavior

Currently the with-options form is called by the interceptor, not the other way around as it should be.


---

<a id="971"></a>

### #971: Move most interceptor/proxy-based code gen to api-go

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/971 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-12-01 21:57:16.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-09 10:50:04.000 UTC |
| **Closed** | 2023-01-09 10:50:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | robholland |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now our SDK relies on every API message which is not cool

**Describe the solution you'd like**

We need to move the code gen for proxy and interceptor to https://github.com/temporalio/api-go.

Specifically in api-go we should add a `cmd/generateproxy` binary package that:

* Does what `internal/cmd/generateproxy` does today _and_ what `internal/cmd/generateinterceptor` does (can just be two
  methods called from top-level)
* Make the `generateinterceptor` not rely on known package set (if you have to use the file system to walk the known
  packages so be it). We want to be future proof for new packages.
* Give this its own `go.mod` so that it can depend on `golang.org/x/tools/go` without forcing api-go to add that
  directory.
* Runs after protoc everytime api-go is regenerated

That tool should generate/overwrite package `go.temporal.io/api/proxy` (so basically just a `proxy` dir in `api-go`). It
should generate the following Go public API (can be broken up across files if needed) for the proxy:

```go
package proxy

type WorkflowServiceProxyOptions struct {
  Client workflowservice.WorkflowServiceClient
}

func NewWorkflowServiceProxyServer(options WorkflowServiceProxyOptions) (workflowservice.WorkflowServiceServer, error) {
  // ...
}
```

This is exactly what's in `client` of the SDK today. As for the interceptor side, we need:

```go
package proxy

type VisitPayloadOptions struct {
  Visitor func(*common.Payload) error
  SkipSearchAttributes bool
}

func VisitPayloads(msg proto.Message, options VisitPayloadOptions) error {
  // ...
}

type PayloadVisitorInterceptorOptions struct {
  Outbound *VisitPayloadOptions
  Inbound *VisitPayloadOptions
}

func NewPayloadVisitorInterceptor(options PayloadVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {
  // ...
}
```

Do what is needed behind the scenes to make that work. You'll want the unexported recursive function to take a pointer to those `VisitPayloadOptions` btw so as not to copy each recursion.

Finally, just change the SDK to use this. The `client` package calls can just delegate to this. The `converter` stuff
can just delegate to this but make the payload codec encode/decode as the visitor.

**Describe alternatives you've considered**

Reflection, but decided against.


---

<a id="948"></a>

### #948: Document that workflow test suite defaults to maximum activity attempt of 10

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/948 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-11-07 13:35:36.000 UTC (3y 2m ago) |
| **Updated** | 2022-12-06 22:49:42.000 UTC |
| **Closed** | 2022-12-06 22:49:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

When https://github.com/temporalio/sdk-go/pull/462 was done, no documentation was made. Document this.


---

<a id="925"></a>

### #925: Godoc for workflow.Sleep and workflow.NewTimer is wrong about second resolution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/925 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-30 21:06:37.000 UTC (3y 3m ago) |
| **Updated** | 2022-12-06 22:49:41.000 UTC |
| **Closed** | 2022-12-06 22:49:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Just remove the statements


---

<a id="919"></a>

### #919: Default MaxConcurrentEagerActivityExecutionSize to 3

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/919 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-26 16:53:16.000 UTC (3y 3m ago) |
| **Updated** | 2022-11-03 21:28:00.000 UTC |
| **Closed** | 2022-11-03 21:28:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

`MaxConcurrentEagerActivityExecutionSize` as unlimited is too much by default. See https://github.com/temporalio/sdk-core/pull/405 and https://github.com/temporalio/sdk-java/pull/1455

**Describe the solution you'd like**

Make `0` be the same as `3`, and ask users to just give a really high number if they want effectively unlimited. Any concerns w/ backwards compatibility of this unused thing?


---

<a id="910"></a>

### #910: Add activity.InActivity(context.Context) bool

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/910 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-15 12:57:19.000 UTC (3y 3m ago) |
| **Updated** | 2023-07-24 23:13:15.000 UTC |
| **Closed** | 2023-07-24 23:13:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Need to know whether the context is an activity context.


---

<a id="909"></a>

### #909: Fatal poll error on worker start isn't stopping activity poller

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/909 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-14 18:50:36.000 UTC (3y 3m ago) |
| **Updated** | 2022-09-14 18:50:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

All workers should stop on fatal error

## Actual Behavior

Seems if the first poll fails w/ fatal error, there may be a case where the activity worker stop is not taking hold. This may be fixed by just switching the order of https://github.com/temporalio/sdk-go/blob/c1ce1d25238b7bb15095f0767497fa93215c2589/internal/internal_worker_base.go#L438-L441

## Steps to Reproduce the Problem

Maybe try to start a worker and have the first poll immediately give back a namespace not found and confirm activity poller still polls.


---

<a id="908"></a>

### #908: Heartbeats in test environment are not concurrency-safe

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/908 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-14 18:38:26.000 UTC (3y 3m ago) |
| **Updated** | 2025-02-11 23:31:04.000 UTC |
| **Closed** | 2025-02-11 23:31:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Expect multiple goroutines of an activity can heartbeat in the test framework

## Actual Behavior
Race detector says this is clashing. Specifically at https://github.com/temporalio/sdk-go/blob/c1ce1d25238b7bb15095f0767497fa93215c2589/internal/internal_workflow_testsuite.go#L321 which calls getActivityHandle, that is not concurrency safe.

This was commented on before but never fixed, see https://github.com/temporalio/sdk-go/pull/780/files#r852206758




---

<a id="903"></a>

### #903: Worker fatal error can cause double worker stop

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/903 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-01 20:15:04.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-02 20:22:05.000 UTC |
| **Closed** | 2022-09-02 20:22:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior

If a fatal error causes worker stop, a user calling worker stop should not panic

## Actual Behavior

Today they panic because Stop is not reentrant


---

<a id="900"></a>

### #900: Log warning on failed serialization of signal input

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/900 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-31 18:25:23.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-31 18:25:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Signals are silently dropped when they can't deserialize

**Describe the solution you'd like**

We want to warn here.

We also need to confirm and document behavior in selectors when that receive callback occurs and the successive receive may not populate the value


---

<a id="896"></a>

### #896: Expose operator service

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/896 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-30 17:04:57.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-01 20:22:07.000 UTC |
| **Closed** | 2022-09-01 20:22:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Add raw operator service getter to client interface.


---

<a id="882"></a>

### #882: Remove poll failure log on explicit worker stop

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/882 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-09 18:01:50.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-30 13:23:26.000 UTC |
| **Closed** | 2022-08-30 13:23:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now we log:

```
2022-08-09T10:54:28.389-0700	WARN	harness/log.go:50	Failed to poll for task.	{"Namespace": "sdk-features-ns-8fdd637a-5b7f-448f-8ca9-039f8583f829", "TaskQueue": "sdk-features-query/timeout_due_to_no_active_workers-cad8cd2c-5d1d-4983-bd3a-937c88fec7db", "WorkerID": "2107561@monolith-linux@", "WorkerType": "ActivityWorker", "Error": "worker stopping"}
```

We should stop


---

<a id="873"></a>

### #873: Ensure slots available metric is updated on worker stop

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/873 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-01 12:27:31.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-01 12:27:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Slots available added on start are removed on stop

## Actual Behavior

Glancing at the code, these may not be removed properly


---

<a id="871"></a>

### #871: High level API for schedules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/871 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-07-30 00:16:18.000 UTC (3y 5m ago) |
| **Updated** | 2022-11-09 17:15:46.000 UTC |
| **Closed** | 2022-11-09 17:15:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | cretz, Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

Not sure what the Go client has now, I guess some work was already done on this by @dnr since the server and tctl use the Go SDK client but we should review this API before handing it off to users.


---

<a id="870"></a>

### #870: Documentation fixes for error handling

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/870 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-07-29 20:55:35.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-10 18:48:27.000 UTC |
| **Closed** | 2022-08-10 18:48:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

https://pkg.go.dev/go.temporal.io/sdk/workflow#hdr-Error_Handling talks about `error.CustomError()` which is not a thing.

**Describe the solution you'd like**

Make sure none of the error references are stale. Also update workflow run's `Get` to clarify that result and error are mutually exclusive and you'll never get a result and an error.


---

<a id="860"></a>

### #860: Panic in eager activity code when RespondWorkflowTaskCompleted returns error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/860 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-07-20 21:37:25.000 UTC (3y 5m ago) |
| **Updated** | 2022-07-21 16:15:09.000 UTC |
| **Closed** | 2022-07-21 16:15:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Should properly unreserve spots as though the response came back with no activity tasks

## Actual Behavior

Panics because we foolishly assume a response is present in `internal_eager_activity.go`


---

<a id="859"></a>

### #859: Cannot set really short max heartbeat throttle interval

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/859 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-07-20 21:36:08.000 UTC (3y 5m ago) |
| **Updated** | 2022-07-22 20:54:55.000 UTC |
| **Closed** | 2022-07-22 20:54:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Expect to be able to set this to, like, 1 nanosecond and it work

## Actual Behavior

For whatever reason in #660, I put `context.WithTimeout(ctx, i.heartbeatThrottleInterval)` which means that context times out immediately


---

<a id="844"></a>

### #844: Document that valuePtrs passed to ch.Receive/ReceiveAsync or future.Get calls should not be re-used across calls

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/844 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2022-06-30 13:54:28.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-08 13:00:55.000 UTC |
| **Closed** | 2022-07-08 13:00:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Basically, this kind of pattern can lead to unexpected behavior given how json.Unmarshal works (especially if Type contains a map). We should update the comment / documentation to make it clear that sharing an output variable across multiple invocations is almost always an anti-pattern.

BAD
```
var r Type
for {
    ch.Receive(ctx, &r)
    // process r
}
```

GOOD
```

for {
    var r Type
    ch.Receive(ctx, &r)
    // process r
}
```



---

<a id="843"></a>

### #843: Document non-thread-safe callbacks in test suite

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/843 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-06-30 12:27:51.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-08 13:00:55.000 UTC |
| **Closed** | 2022-07-08 13:00:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It is not clear that external mocks that are not part of workflow code do not run on the workflow Goroutine and therefore are not thread safe. Document that callbacks for mocks on activities, local activities, child workflows, signal external workflow, and cancel external workflow are all done on separate goroutines and not thread safe.




---

<a id="822"></a>

### #822: Properly invoke worker OnFatalError callback for users of worker.Start()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/822 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-06-01 19:51:16.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-06 17:42:02.000 UTC |
| **Closed** | 2022-06-06 17:42:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

#800 provided `worker.Options.OnFatalError` but doesn't seem to invoke that for those not using `worker.Run()` like was intended.

**Describe the solution you'd like**

Make sure that callback is invoked for those using `worker.Start()` too and test it.


---

<a id="818"></a>

### #818: Workflow static analyzer tool raises non-deterministic error on workflow.AwaitWithTimeout

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/818 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-05-30 16:21:54.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-31 17:12:08.000 UTC |
| **Closed** | 2022-05-31 17:12:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Related forum post: https://community.temporal.io/t/workflowcheck-alerts-on-using-temporal-sdk-function/4834

Looks as static analyzer raises an error on:

      isNotTimeout, err := workflow.AwaitWithTimeout( ctx, content.ApprovalExpiration, submitSelector.HasPending)

see stack trace in forum post.


---

<a id="794"></a>

### #794: Change default gRPC max message size to 128MB

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/794 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-04-27 21:47:47.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-04 15:29:04.000 UTC |
| **Closed** | 2022-05-04 15:29:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Matches other SDKs


---

<a id="786"></a>

### #786: workflow.GetLastError documentation is wrong

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/786 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-04-20 17:53:29.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-21 20:25:35.000 UTC |
| **Closed** | 2022-04-21 20:25:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Says:

> GetLastError extracts the latest failure from any from previous run for this workflow, if one has failed. If none have failed, nil is returned. 

Should say:

> GetLastError extracts the latest failure only if the last run failed. If it did not fail or there is not a last run, nil is returned.

May also want to clarify that `GetLastCompletionResult` is the last successful run no matter how far back. May also want to update API protos with this info.


---

<a id="768"></a>

### #768: Add TestActivityEnvironment.SetOnActivityHeartbeatListener

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/768 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-03-30 14:37:58.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-13 13:39:18.000 UTC |
| **Closed** | 2022-04-13 13:39:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Should be able to have heartbeat listener in activity environment same as in workflow environment

## Actual Behavior

Not able to set this


---

<a id="758"></a>

### #758: Expose ApplicationError.msg

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/758 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-03-22 21:37:21.000 UTC (3y 9m ago) |
| **Updated** | 2022-03-30 15:20:11.000 UTC |
| **Closed** | 2022-03-30 15:20:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Some users want the string message without the things appended that `Error()` has

**Describe the solution you'd like**

Expose something like `RawMessage()`


---

<a id="755"></a>

### #755: Sticky query invalid state machine transition error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/755 |
| **State** | OPEN |
| **Author** | yycptt (Yichao Yang) |
| **Created** | 2022-03-16 01:29:07.000 UTC (3y 10m ago) |
| **Updated** | 2022-03-16 01:29:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

If temporal server think sdk has the workflow cache and sends a sticky query (whether the query is strongly consistent doesn't matter, as long as the query is dispatched via matching through a query task) to the sdk but the worker doesn't actually have the workflow cache, sdk will call getWorkflowExecutionHistory to rebuild the workflow state. 

Query/workflow task contains a previousStartedEventID which is used to determine which part of the history is in replay mode. When query task calls getWorkflowExecutionHistory to get history, however, the history may already advanced and contains more events than when the query task is first dispatched. This means the previousStartedEventID in the original query task will be outdated. 

Existing SDK implementation will continue to use that outdated previousStartedEventID to run the query task and this will lead to invalid state transition error. (More specifically, sdk will want to move the state machine to Init state directly from Created State, skipping the Sent state.) Check below for a test that can repro the issue.

We don't have the same issue for workflow task because there'll be only one pending workflow task, so the history can't be advanced when we are processing it.

Some idea for fixing the issue:
1. For query tasks, process all events in reply mode
2. Include a nextEventID in query task and truncate history beyond that point (this is the fix done in Cadence)
3. getWorkflowExecutionHistory also return  previousStartedEventID ? not sure.

So far it looks like with approach 1, the entire fix can be done on sdk side. 2 and 3 will involve server change as well. Please let server team know if approach 1 can't work and additional support is needed from server side.

## Expected Behavior
Successfully return a query result

## Actual Behavior
Invalid state machine transition error 

## Steps to Reproduce the Problem

A sample test that can expose the bug (and a potential fix) can be found at
https://github.com/yycptt/sdk-go/commit/7bd7016ea653999a6483b99f227653252cb2b33f
Running the test directly will give the following error message
```
2022/03/15 18:05:15 WARN  Failed to process workflow task. Namespace default TaskQueue query-task-cache-evicted-tl WorkerID test-worker-identity WorkflowType query-task-cache-evicted-workflow WorkflowID query-task-cache-evicted-workflow-id RunID query-task-cache-evicted-workflow-run-id Attempt 0 Error invalid state transition: attempt to handleInitiatedEvent, CommandType: Activity, ID: 10, state=Created, isDone()=false, history=[Created]
```


## Specifications

  - Version:
  - Platform:



---

<a id="750"></a>

### #750: Sync metrics format with OpenMetrics and JavaSDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/750 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-03-10 00:28:26.000 UTC (3y 10m ago) |
| **Updated** | 2022-03-28 17:00:36.000 UTC |
| **Closed** | 2022-03-28 17:00:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Temporal GoSDK should issue metrics in compliance with OpenMetrics specification to allow having a single dashboard and set of Grafana queries for both Java and Go SDKs. 
JavaSDK is already compliant with the spec.
Probably the best solution would be to temporarily expose corrected metrics in addition to the old format. An alternative solution would be to provide an opt-in configuration option to the new format. 

# Counters

**Counter metrics should have `_total` postfix.**

Specification:
- https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#counter 

> A MetricPoint in a Metric with the type Counter MUST have one value called Total.

- https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#counter-1

> The MetricPointâ€™s Total Value Sample MetricName MUST have the suffix _total

# Timers 

**Timer metrics exported as histograms should have `_seconds` postfix before the existing `_bucket` postfix.**

Specification:
- https://prometheus.io/docs/practices/naming/ 

> ...should have a suffix describing the unit, in plural form. Note that an accumulating count has total as a suffix, in addition to the unit if applicable.
>   - http_request_duration_seconds

- https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#unit

> Unit specifies MetricFamily units. If non-empty, it MUST be a suffix of the MetricFamily name separated by an underscore.

# Additional context

## Complete Exposition examples

There is a good example in OpenMetrics of what the correct â€œcomplete expositionâ€ looks like for different types:
https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#overall-structure
~~~~
# TYPE acme_http_router_request_seconds summary
# UNIT acme_http_router_request_seconds seconds
# HELP acme_http_router_request_seconds Latency though all of ACME's HTTP request router.
acme_http_router_request_seconds_sum{path="/api/v1",method="GET"} 9036.32
acme_http_router_request_seconds_count{path="/api/v1",method="GET"} 807283.0
acme_http_router_request_seconds_created{path="/api/v1",method="GET"} 1605281325.0
acme_http_router_request_seconds_sum{path="/api/v2",method="POST"} 479.3
acme_http_router_request_seconds_count{path="/api/v2",method="POST"} 34.0
acme_http_router_request_seconds_created{path="/api/v2",method="POST"} 1605281325.0
# TYPE go_goroutines gauge
# HELP go_goroutines Number of goroutines that currently exist.
go_goroutines 69
# TYPE process_cpu_seconds counter
# UNIT process_cpu_seconds seconds
# HELP process_cpu_seconds Total user and system CPU time spent in seconds.
process_cpu_seconds_total 4.20072246e+06
# EOF
~~~~

## Reference implementation in Micrometer

In Micrometer, the OpenMetrics/Prometheus convention is enforced in `PrometheusNamingConvention` class.

`_total`: https://github.com/micrometer-metrics/micrometer/blob/main/implementations/micrometer-registry-prometheus/src/main/java/io/micrometer/prometheus/PrometheusNamingConvention.java#L66
`_seconds`: https://github.com/micrometer-metrics/micrometer/blob/main/implementations/micrometer-registry-prometheus/src/main/java/io/micrometer/prometheus/PrometheusNamingConvention.java#L73

# Examples of metrics that are currently exported between Go and Java

| Go | Java |
|----|------|
| temporal_request | temporal_request_total |
| temporal_activity_execution_latency_bucket | temporal_activity_execution_latency_seconds_bucket |
| temporal_workflow_canceled | temporal_workflow_canceled_total |
|temporal_workflow_continue_as_new | temporal_workflow_continue_as_new_total|
|temporal_workflow_task_execution_latency_bucket | temporal_workflow_task_execution_latency_seconds_bucket|
|temporal_activity_execution_failed | temporal_activity_execution_failed_total|


---

<a id="742"></a>

### #742: Fix docs for Client.ListWorkflow to clarify ES requirement

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/742 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-25 19:53:33.000 UTC (3y 10m ago) |
| **Updated** | 2022-04-21 20:25:35.000 UTC |
| **Closed** | 2022-04-21 20:25:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Explain some things on the calls work w/ only ES but others don't require ES.

## Actual Behavior

Currently we say ES is required to even call them.


---

<a id="730"></a>

### #730: Set WorkflowStartTime parameter in tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/730 |
| **State** | CLOSED |
| **Author** | naormatania (Naor Matania) |
| **Created** | 2022-02-16 16:12:45.000 UTC (3y 10m ago) |
| **Updated** | 2022-02-22 17:47:07.000 UTC |
| **Closed** | 2022-02-22 17:47:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Running `workflow.GetInfo(ctx).WorkflowStartTime` in real workflows is working as expected and returns the time the workflow as started.
We're using this parameter for a logic that determines how much time we'd like to run in the workflow

However, during test `workflow.GetInfo(ctx).WorkflowStartTime` returns an zero value which makes it hard to test the workflow.
It would be great if we can set it to a value

Since test workflows are not real workflows I expect running `workflow.Now()` at the begging of the workflow to return the same result as `workflow.GetInfo(ctx).WorkflowStartTime` which is ok



---

<a id="728"></a>

### #728: Add Await branch to Selector

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/728 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-02-14 18:16:40.000 UTC (3y 10m ago) |
| **Updated** | 2022-03-15 21:50:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
workflow.Await and AwaitWithTimeout are very convenient as they allow waiting on practically any condition. Selector supports only waiting on Future and Channel. This leads to situations when unexperienced users mix Await with Selector in the same function which leads to suttle bugs. For example this was reported by a user over Slack:

> Hello, is there a small logic error in the Go subscription template/example?
> [This ](https://github.com/temporalio/subscription-workflow-project-template-go/blob/93ce85b52b8c610c21a96f3397bef5b419047e11/workflow.go#L115-L122)AwaitWithTimeout[ will exit early](https://github.com/temporalio/subscription-workflow-project-template-go/blob/93ce85b52b8c610c21a96f3397bef5b419047e11/workflow.go#L115-L122) if the subscription is cancelled, but the cancelSelector.Select(ctx) is not run [until after](https://github.com/temporalio/subscription-workflow-project-template-go/blob/93ce85b52b8c610c21a96f3397bef5b419047e11/workflow.go#L121) the timeout is complete.
> Mostly just asking because I think I introduced this bug in my own code when copying from this example.

**Describe the solution you'd like**
I propose adding the following API:

```go
Selector {
...
  AddAwait(condition func() bool, f func())
}
```
When `Selector.Select` is called, `f` will be called if `condition` returns true.




---

<a id="724"></a>

### #724: Activity cancellation causes history error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/724 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-10 22:05:29.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-18 14:10:18.000 UTC |
| **Closed** | 2022-02-18 14:10:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Should not have internal state errors

## Actual Behavior

Has internal state errors, specifically something like:

    BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event, ScheduledID: 99

## Steps to Reproduce the Problem

<details>
<summary>main.go</summary>

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os/exec"
	"runtime/debug"
	"strings"
	"time"

	"github.com/google/uuid"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

const useTemporalite = true
const taskQueue = "my-task-queue"

func run() error {
	var clientOpts client.Options

	// Create a logger that will break on the error we've been waiting for
	errSeenCh := make(chan struct{})
	clientOpts.Logger = &logger{
		excludeLevels: map[string]bool{"DEBUG": true},
		onMessageContains: map[string]func(level, msg string){
			"BadRequestCancelActivityAttributes": func(level, msg string) {
				debug.PrintStack()
				close(errSeenCh)
			},
		},
	}

	// Use temporalite if desired
	if useTemporalite {
		clientOpts.Namespace = "namespace-" + uuid.NewString()
		clientOpts.HostPort = "localhost:9233"
		cmd := exec.Command("temporalite", "start", "--ephemeral", "--namespace", clientOpts.Namespace, "--port", "9233")
		// cmd.Stdout, cmd.Stderr = os.Stdout, os.Stderr
		if err := cmd.Start(); err != nil {
			return fmt.Errorf("failed starting temporalite: %w", err)
		}
		defer cmd.Process.Kill()
		time.Sleep(200 * time.Millisecond)
	}

	// Create client
	c, err := client.NewClient(clientOpts)
	if err != nil {
		return fmt.Errorf("failed creating client: %w", err)
	}
	defer c.Close()

	// Start workers
	const workerCount = 10
	log.Printf("Starting %v workers", workerCount)
	for i := 0; i < workerCount; i++ {
		w, err := startWorker(c)
		if err != nil {
			return fmt.Errorf("failed starting worker: %w", err)
		}
		defer w.Stop()
	}
	log.Printf("Started %v workers", workerCount)

	// Run "breakers"
	const breakerCount = 10
	log.Printf("Running %v breakers", breakerCount)
	breakerDoneCh := make(chan error, breakerCount)
	for i := 0; i < breakerCount; i++ {
		go func() { breakerDoneCh <- runBreaker(c) }()
	}

	// Wait for them all to finish or error
	for i := 0; i < breakerCount; i++ {
		select {
		case <-errSeenCh:
			return fmt.Errorf("saw BadRequestCancelActivityAttributes")
		case err := <-breakerDoneCh:
			if err != nil {
				return fmt.Errorf("breaker failed: %w", err)
			}
		}
	}
	log.Printf("Breakers done")
	return nil
}

func startWorker(c client.Client) (worker.Worker, error) {
	w := worker.New(c, taskQueue, worker.Options{
		MaxConcurrentActivityExecutionSize: 2,
	})
	w.RegisterWorkflow(SomeWorkflow)
	w.RegisterWorkflow(DoABunchOfActivitiesWorkflow)
	w.RegisterActivity(NoopActivity)
	return w, w.Start()
}

func runBreaker(c client.Client) error {
	for i := 0; i < 20; i++ {
		_, err := c.ExecuteWorkflow(context.Background(), client.StartWorkflowOptions{TaskQueue: taskQueue}, SomeWorkflow)
		if err != nil {
			return fmt.Errorf("failed starting workflow: %w", err)
		}
		time.Sleep(2 * time.Second)
	}
	return nil
}

func SomeWorkflow(ctx workflow.Context) error {
	childCtx, childCancel := workflow.WithCancel(ctx)
	childCtx = workflow.WithChildOptions(childCtx, workflow.ChildWorkflowOptions{
		WorkflowTaskTimeout: time.Minute,
		WaitForCancellation: true,
	})
	childFut := workflow.ExecuteChildWorkflow(childCtx, DoABunchOfActivitiesWorkflow)

	// Wait for start
	if err := childFut.GetChildWorkflowExecution().Get(ctx, nil); err != nil {
		return err
	}

	// Cancel and wait for child done
	childCancel()
	return childFut.Get(ctx, nil)
}

func DoABunchOfActivitiesWorkflow(ctx workflow.Context) error {
	ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		StartToCloseTimeout: 5 * time.Hour,
		HeartbeatTimeout:    20 * time.Second,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:    time.Second,
			BackoffCoefficient: 2,
			MaximumInterval:    time.Minute * 10,
			MaximumAttempts:    5,
		},
		WaitForCancellation: true,
	})

	childCtx, cancelHandler := workflow.WithCancel(ctx)
	sel := workflow.NewSelector(ctx)

	const activityCount = 100

	for i := 0; i < activityCount; i++ {
		sel.AddFuture(workflow.ExecuteActivity(childCtx, NoopActivity), func(f workflow.Future) {
			if err := f.Get(ctx, nil); err != nil {
				// Cancel all activities
				cancelHandler()
			}
		})
	}

	for i := 0; i < activityCount; i++ {
		sel.Select(ctx)
	}

	return nil
}

func NoopActivity(aCtx context.Context) error { return nil }

type logger struct {
	// Called _after_ logged
	onMessageContains map[string]func(level, msg string)
	excludeLevels     map[string]bool
}

func (l *logger) log(level, msg string, keyvals ...interface{}) {
	if l.excludeLevels[level] {
		return
	}
	msg = fmt.Sprint(append([]interface{}{msg}, keyvals...))
	log.Print([]interface{}{level, msg})
	for str, callback := range l.onMessageContains {
		if strings.Contains(msg, str) {
			callback(level, msg)
		}
	}
}

func (l *logger) Debug(msg string, keyvals ...interface{}) { l.log("DEBUG", msg, keyvals...) }
func (l *logger) Info(msg string, keyvals ...interface{})  { l.log("INFO", msg, keyvals...) }
func (l *logger) Warn(msg string, keyvals ...interface{})  { l.log("WARN", msg, keyvals...) }
func (l *logger) Error(msg string, keyvals ...interface{}) { l.log("ERROR", msg, keyvals...) }
```

</details>

Run the `main.go` code above with https://github.com/DataDog/temporalite on the `PATH`. It should break fairly quickly.


---

<a id="720"></a>

### #720: Coroutine/context cancellation race conditions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/720 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-09 16:09:03.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-09 20:30:03.000 UTC |
| **Closed** | 2022-02-09 20:30:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Cancellation inside a workflow of coroutines should not do racy things.

## Actual Behavior

Here are some data races in master as of this writing:

<details>
<summary>Data race 1</summary>

```
WARNING: DATA RACE
Write at 0x00c000236868 by goroutine 11:
  go.temporal.io/sdk/internal.(*cancelCtx).cancel()
      /path/to/temporal-sdk-go/internal/context.go:316 +0xa4
  go.temporal.io/sdk/internal.WithCancel.func1()
      /path/to/temporal-sdk-go/internal/context.go:195 +0x4f
  go.temporal.io/sdk/internal.MyTest1.func1.1.1()
      /path/to/temporal-sdk-go/internal/internal_coroutines_test.go:1393 +0x56
  runtime.deferCallSave()
      /path/to/Go/src/runtime/panic.go:950 +0x81
  go.temporal.io/sdk/internal.(*coroutineState).initialYield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:860 +0xa8
  go.temporal.io/sdk/internal.(*coroutineState).yield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:869 +0x3e4
  go.temporal.io/sdk/internal.(*channelImpl).Receive()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:684 +0x331
  go.temporal.io/sdk/internal.(*futureImpl).Get()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:310 +0x9d
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:976 +0x5e
  go.temporal.io/sdk/internal.Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:971 +0x88
  go.temporal.io/sdk/internal.MyTest1.func1.1()
      /path/to/temporal-sdk-go/internal/internal_coroutines_test.go:1396 +0x11a
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:971 +0x17e
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutineÂ·dwrapÂ·33()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:972 +0x47

Previous read at 0x00c000236868 by goroutine 10:
  go.temporal.io/sdk/internal.propagateCancel()
      /path/to/temporal-sdk-go/internal/context.go:226 +0x11c
  go.temporal.io/sdk/internal.WithCancel()
      /path/to/temporal-sdk-go/internal/context.go:194 +0x144
  go.temporal.io/sdk/internal.MyTest1.func1.1.1()
      /path/to/temporal-sdk-go/internal/internal_coroutines_test.go:1392 +0x47
  runtime.deferCallSave()
      /path/to/Go/src/runtime/panic.go:950 +0x81
  go.temporal.io/sdk/internal.(*coroutineState).initialYield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:860 +0xa8
  go.temporal.io/sdk/internal.(*coroutineState).yield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:869 +0x3e4
  go.temporal.io/sdk/internal.(*channelImpl).Receive()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:684 +0x331
  go.temporal.io/sdk/internal.(*futureImpl).Get()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:310 +0x9d
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:976 +0x5e
  go.temporal.io/sdk/internal.Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:971 +0x88
  go.temporal.io/sdk/internal.MyTest1.func1.1()
      /path/to/temporal-sdk-go/internal/internal_coroutines_test.go:1396 +0x11a
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:971 +0x17e
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutineÂ·dwrapÂ·33()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:972 +0x47
```
</details>

<details>
<summary>Data race 2</summary>

```
WARNING: DATA RACE
Read at 0x00c000234868 by goroutine 11:
  go.temporal.io/sdk/internal.(*cancelCtx).cancel()
      /path/to/temporal-sdk-go/internal/context.go:313 +0x84
  go.temporal.io/sdk/internal.WithCancel.func1()
      /path/to/temporal-sdk-go/internal/context.go:195 +0x4f
  runtime.deferCallSave()
      /path/to/Go/src/runtime/panic.go:950 +0x81
  go.temporal.io/sdk/internal.(*coroutineState).initialYield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:860 +0xa8
  go.temporal.io/sdk/internal.(*coroutineState).yield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:869 +0x3e4
  go.temporal.io/sdk/internal.(*channelImpl).Receive()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:684 +0x331
  go.temporal.io/sdk/internal.(*futureImpl).Get()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:310 +0x9d
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:976 +0x5e
  go.temporal.io/sdk/internal.Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:971 +0x88
  go.temporal.io/sdk/internal.MyTest2.func1.1()
      /path/to/temporal-sdk-go/internal/internal_coroutines_test.go:1418 +0x79
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:971 +0x17e
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutineÂ·dwrapÂ·33()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:972 +0x47

Previous write at 0x00c000234868 by goroutine 14:
  go.temporal.io/sdk/internal.(*cancelCtx).cancel()
      /path/to/temporal-sdk-go/internal/context.go:316 +0xa4
  go.temporal.io/sdk/internal.WithCancel.func1()
      /path/to/temporal-sdk-go/internal/context.go:195 +0x4f
  runtime.deferCallSave()
      /path/to/Go/src/runtime/panic.go:950 +0x81
  go.temporal.io/sdk/internal.(*coroutineState).initialYield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:860 +0xa8
  go.temporal.io/sdk/internal.(*coroutineState).yield()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:869 +0x3e4
  go.temporal.io/sdk/internal.(*channelImpl).Receive()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:684 +0x331
  go.temporal.io/sdk/internal.(*futureImpl).Get()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:310 +0x9d
  go.temporal.io/sdk/internal.(*workflowEnvironmentInterceptor).Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:976 +0x5e
  go.temporal.io/sdk/internal.Sleep()
      /path/to/temporal-sdk-go/internal/workflow.go:971 +0x88
  go.temporal.io/sdk/internal.MyTest2.func1.1()
      /path/to/temporal-sdk-go/internal/internal_coroutines_test.go:1418 +0x79
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutine.func1()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:971 +0x17e
  go.temporal.io/sdk/internal.(*dispatcherImpl).NewCoroutineÂ·dwrapÂ·33()
      /path/to/temporal-sdk-go/internal/internal_workflow.go:972 +0x47
```
</details>

## Steps to Reproduce the Problem

Will add tests to PR.


---

<a id="719"></a>

### #719: Worker silently doing nothing if MaxConcurrentWorkflowTaskPoller set to 1

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/719 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2022-02-09 02:44:41.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-22 14:55:07.000 UTC |
| **Closed** | 2022-02-22 14:55:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Set MaxConcurrentWorkflowTaskPoller to 1 and start the worker, worker will start with no error. But if you try to start a workflow, it won't make any progress. This is because worker prefer sticky queue, so it always pick from sticky queue if max concurrent workflow task poller is limit to 1.
We either need to be smarter and poll from normal queue from time to time, or we need to fail the worker and document that we need at least 2 workflow task poller. 

Current silently doing nothing is not acceptable.


---

<a id="712"></a>

### #712: OpenTracing-enabled workers error when missing OpenTracing spans in headers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/712 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-02-01 18:50:19.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-22 14:43:26.000 UTC |
| **Closed** | 2022-02-22 14:43:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Inbound interceptors extracting a span from headers should not fail if the span is not there.

## Actual Behavior

Calling https://pkg.go.dev/go.opentelemetry.io/otel/propagation#TextMapPropagator `Extract` does not error when not present, but it seems https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer `Extract` does with `ErrSpanContextNotFound`.

So basically with this error we are requiring opentracing-enabled workers to have their workflows started with opentracing-enabled clients which is not cool.


---

<a id="710"></a>

### #710: Verify //workflowcheck:ignore works with Godoc

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/710 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-31 22:46:50.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-22 14:36:31.000 UTC |
| **Closed** | 2022-02-22 14:36:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

They don't interfere

## Actual Behavior

Seems to interfere


---

<a id="707"></a>

### #707: Increase visbiility for poll failures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/707 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-25 19:27:13.000 UTC (3y 11m ago) |
| **Updated** | 2022-01-31 22:11:32.000 UTC |
| **Closed** | 2022-01-31 22:11:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | â¤ï¸ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now, poll failures are logged at `DEBUG` level and even then, only after https://pkg.go.dev/go.temporal.io/sdk/worker#EnableVerboseLogging is set.

**Describe the solution you'd like**

Confirm they aren't noisy then add them at WARN level. If at all possible, only do this on connection failure.


---

<a id="705"></a>

### #705: Make WorkflowServiceStubsOptions#rpcLongPollTimeout configurable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/705 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-23 22:20:47.000 UTC (3y 11m ago) |
| **Updated** | 2022-01-23 22:21:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The original issue in JavaSDK: https://github.com/temporalio/sdk-java/issues/988


---

<a id="701"></a>

### #701: Implement server capabilities and replace health check

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/701 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-20 23:04:06.000 UTC (3y 11m ago) |
| **Updated** | 2022-03-01 19:42:10.000 UTC |
| **Closed** | 2022-03-01 19:42:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Server capabilities are needed for some things like knowing whether to retry certain classes of error

**Describe the solution you'd like**

* Remove health checking and options (including removing the ability to disable health check)
  * This was a subject of much debate, but lazy capabilities lookup is difficult and having a way to opt-out of getting server capabilities is troublesome
  * This causes those that were traditionally using the disable-health-check option to have lazy client connectivity to rework their approach
* Upon client creation, instead of health check, call `getServerInfo` to obtain server capabilities
  * Make sure 404's are handle gracefully as though none of the capabilities were set
  * Errors besides 404, such as server not available, cause client creation to fail just like default health checks do. The difference is we don't have a client-side backoff capability, we fail fast.
* Leverage the `internal_error_differentiation` capability to, if true, stop gRPC retrying internal errors


---

<a id="700"></a>

### #700: Static Analysis Tool for Non-Determinism

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/700 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-19 19:35:10.000 UTC (3y 11m ago) |
| **Updated** | 2022-01-31 16:49:05.000 UTC |
| **Closed** | 2022-01-31 16:49:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

No tooling for detecting non-determinism in workflows.

**Describe the solution you'd like**

* Take https://github.com/cretz/temporal-determinist (may be gone if anyone is reading this issue later) and move to this repo under `contrib/tools/temporal-check` (or some other name)
* Document/integrate with https://github.com/golangci/golangci-lint (see [this](https://golangci-lint.run/contributing/new-linters/))
* Document/integrate with https://staticcheck.io/ (may have to be custom compile)
* Document how to use at least from vscode (ref https://golangci-lint.run/usage/integrations/ or manual via `go.lintTool`)
* Add ability to ignore certain calls or sections of code


---

<a id="692"></a>

### #692: Change heartbeat failure log from debug to warn

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/692 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-10 21:49:09.000 UTC (3y 12m ago) |
| **Updated** | 2022-01-18 19:20:41.000 UTC |
| **Closed** | 2022-01-18 19:20:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now heartbeat failures are debug level

**Describe the solution you'd like**

Should be warn level


---

<a id="685"></a>

### #685: Add SkipLogger interface for logger

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/685 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-01-05 17:49:29.000 UTC (4 years ago) |
| **Updated** | 2023-09-01 14:09:00.000 UTC |
| **Closed** | 2023-09-01 14:09:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

When someone uses a logger at the client level, sometimes we add a replay logger wrapper which changes the caller skip if someone has done a custom skip.

**Describe the solution you'd like**

Like the server does at https://github.com/temporalio/temporal/blob/v1.14.1/common/log/interface.go#L64-L68, we should also have a skip interface that we can call w/ the value of `1` on when replaying.


---

<a id="677"></a>

### #677: Flaky tests with TestCustomResolver and TestOpenTelemetryTracing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/677 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-21 17:35:43.000 UTC (4 years ago) |
| **Updated** | 2022-01-03 18:29:43.000 UTC |
| **Closed** | 2022-01-03 18:29:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

For `TestCustomResolver`, CI is sometimes returning:

```
=== RUN   TestCustomResolver
    grpc_dialer_test.go:206: 
        	Error Trace:	grpc_dialer_test.go:206
        	Error:      	Not equal: 
        	            	expected: 1
        	            	actual  : 2
        	Test:       	TestCustomResolver
--- FAIL: TestCustomResolver (0.12s)
```

And for `TestOpenTelemetryTracing`, CI is sometimes returning:
```
=== CONT  TestIntegrationSuite
    integration_test.go:1610: 
        	Error Trace:	integration_test.go:1610
        	            				integration_test.go:1497
        	Error:      	Not equal: 
        	            	expected: &interceptortest.SpanInfo{Name:"root-span", Children:[]*interceptortest.SpanInfo{(*interceptortest.SpanInfo)(0xc0008a8930), (*interceptortest.SpanInfo)(0xc0008a8990), (*interceptortest.SpanInfo)(0xc0008a89f0)}}
        	            	actual  : &interceptortest.SpanInfo{Name:"root-span", Children:[]*interceptortest.SpanInfo{(*interceptortest.SpanInfo)(0xc0008a8330), (*interceptortest.SpanInfo)(0xc0008a8390), (*interceptortest.SpanInfo)(0xc0008a83f0)}}
        	            	
        	            	Diff:
        	            	--- Expected
        	            	+++ Actual
        	            	@@ -12,3 +12,3 @@
        	            	      Name: (string) (len=29) "RunWorkflow:SignalsAndQueries",
        	            	-     Children: ([]*interceptortest.SpanInfo) (len=4) {
        	            	+     Children: ([]*interceptortest.SpanInfo) (len=5) {
        	            	       (*interceptortest.SpanInfo)({
        	            	@@ -25,2 +25,6 @@
        	            	        }
        	            	+      }),
        	            	+      (*interceptortest.SpanInfo)({
        	            	+       Name: (string) (len=32) "SignalChildWorkflow:start-signal",
        	            	+       Children: ([]*interceptortest.SpanInfo) <nil>
        	            	       }),
        	Test:       	TestIntegrationSuite
=== CONT  TestIntegrationSuite/TestOpenTelemetryTracing
```

Need to fix.


---

<a id="676"></a>

### #676: Document dangers with workflow.WithChildOptions and workflow.WithWorkflowRunTimeout using continue as new

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/676 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-20 17:04:52.000 UTC (4 years ago) |
| **Updated** | 2024-12-17 21:17:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

One might think `workflow.WithChildOptions` would only apply to children, but it actually changes the general workflow options, so could be called `workflow.WithWorkflowOptions`. These general workflow options are used in `NewContinueAsNewError` which may surprise people.

**Describe the solution you'd like**

Since we likely can't change this, we need to document the issue and discourage context reuse in general.


---

<a id="665"></a>

### #665: Allow channel to convert to same type set if pointer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/665 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-09 18:40:53.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-16 19:41:53.000 UTC |
| **Closed** | 2021-12-16 19:41:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now, a channel `Receive` must use a pointer to the type used with `Send`. With futures (ref #593) and in other cases, we allow you to use a pointer to convert from a pointer instead of requiring a pointer to a pointer.

**Describe the solution you'd like**

Support regular pointers when converting pointers in channels instead of always requiring pointers to pointers.


---

<a id="661"></a>

### #661: Workflow ID cannot be set on testsuite with SetStartWorkflowOptions 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/661 |
| **State** | CLOSED |
| **Author** | laniehei (Lanie Hei) |
| **Created** | 2021-12-08 06:38:49.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-16 20:23:48.000 UTC |
| **Closed** | 2021-12-16 20:23:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I would like to rename a workflow in a test environment through the usage of SetStartWorkflowOptions

## Actual Behavior
The workflow is still named default-test-workflow-id

## Steps to Reproduce the Problem

In the test package: 
```
				env.SetStartWorkflowOptions(client.StartWorkflowOptions{
					ID: "some-name",
				})
			}

			env.ExecuteWorkflow(SomeWorkflow, tc.input)
			s.True(env.IsWorkflowCompleted())
			err := env.GetWorkflowError()

```

The workflow itself:
```
SomeWorkflow(ctx workflow.Context) error {
		workflowID := workflow.GetInfo(ctx).WorkflowExecution.ID
		expectedWorkflowID := "some-name"
		if workflowID != expectedWorkflowID {
			return fmt.Errorf("expecting workflow id %s but got %s", expectedWorkflowID, workflowID)
		}

}
```

I believe that the issue exists in this function

```
func (env *testWorkflowEnvironmentImpl) setStartWorkflowOptions(options StartWorkflowOptions) {
	wf := env.workflowInfo
	if options.WorkflowExecutionTimeout > 0 {
		wf.WorkflowExecutionTimeout = options.WorkflowExecutionTimeout
	}
	if options.WorkflowRunTimeout > 0 {
		wf.WorkflowRunTimeout = options.WorkflowRunTimeout
	}
	if options.WorkflowTaskTimeout > 0 {
		wf.WorkflowTaskTimeout = options.WorkflowTaskTimeout
	}
	if len(options.TaskQueue) > 0 {
		wf.TaskQueueName = options.TaskQueue
	}
}
```

If a new ID is passed in, it's not set on the workflowInfo. 




---

<a id="648"></a>

### #648: Expose local boolean from activity.GetInfo

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/648 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-23 17:38:19.000 UTC (4y 1m ago) |
| **Updated** | 2023-07-24 14:23:59.000 UTC |
| **Closed** | 2023-07-24 14:23:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Java exposes whether an activity is local, Go does not.

**Describe the solution you'd like**

Expose the field on `activity.Info`


---

<a id="645"></a>

### #645: Update Tally to help statsd dependency

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/645 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-22 17:16:01.000 UTC (4y 1m ago) |
| **Updated** | 2021-11-23 21:21:54.000 UTC |
| **Closed** | 2021-11-23 21:21:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Right now anyone using this SDK and statsd has to use a `replace` directive. But now that https://github.com/uber-go/tally/pull/171 has been merged and tagged, we should upgrade here and in the server project.


---

<a id="641"></a>

### #641: Expose gRPC

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/641 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-18 15:26:26.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-02 19:57:46.000 UTC |
| **Closed** | 2021-12-02 19:57:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We have traditionally hidden the gRPC client and settings from the user, but the benefit of hiding gRPC no longer outweighs the cost of decreased user flexibility.

Two changes:

1. Add `WorkflowService() workflowservice.WorkflowServiceClient` to `Client`
2. Add `GRPCDialOptions []grpc.DialOption` to `ConnectionOptions` and apply our dial options first so any explicitly provided dial options _could_ override our own if desired.

Questions:

1. Maybe add some form of `GetGRPCContext` so that they can use the same context we use for making a gRPC call?


---

<a id="639"></a>

### #639: Workflows with too few parameters fail

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/639 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-17 23:23:09.000 UTC (4y 1m ago) |
| **Updated** | 2021-11-18 18:04:59.000 UTC |
| **Closed** | 2021-11-18 18:04:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Expect to be able, when calling `ExecuteWorkflow` with a string name, to pass in fewer parameters than are needed.

## Actual Behavior

This works in all released versions, but just regressed in #610 to cause a panic. So fix this in master.


---

<a id="627"></a>

### #627: Should always Set RequestId

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/627 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-11-11 20:02:52.000 UTC (4y 1m ago) |
| **Updated** | 2021-11-16 17:21:04.000 UTC |
| **Closed** | 2021-11-16 17:21:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior
SDK code should always set RequestId to avoid duplicate calls in case of retry.

## Actual Behavior
Some API calls sets the RequestId (like StartWorkflow/SignalWithStartWorkflow), but other places does not (like SignalWorkflow and CancelWorkflow).



---

<a id="623"></a>

### #623: Activity cancellation in certain scenarios causes event handling failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/623 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-09 22:48:45.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-12 13:40:40.000 UTC |
| **Closed** | 2021-11-12 13:40:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior

Activity cancellation should work.

## Actual Behavior

Activity cancellation has an event problem when unwinding. This was introduced in v1.10.0 in #504.

## Steps to Reproduce the Problem

I have not dug _too_ deeply, but https://github.com/temporalio/sdk-go/compare/master...cretz:sdk-history-bug shows the bug (FYI, branch may be deleted later). It shows the commented out lines make the test succeed. This was noticed in a couple scenarios, but we only replicated it when https://github.com/temporalio/sdk-go/issues/481 was updated by a user.


---

<a id="621"></a>

### #621: Local activities do not catch panics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/621 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-09 18:43:52.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-09 23:02:19.000 UTC |
| **Closed** | 2021-11-09 23:02:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior

Local activities, to be subject to retry and such like regular activities, should recover from panics.

## Actual Behavior

Local activities panic inside Goroutine started here is not recovered: https://github.com/temporalio/sdk-go/blob/v1.11.0/internal/internal_task_pollers.go#L537


---

<a id="619"></a>

### #619: Make tracing tags consistent across SDKs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/619 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-08 14:34:24.000 UTC (4y 2m ago) |
| **Updated** | 2024-03-15 04:59:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, external dependency |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Tracing tags are not consistent across SDKs.

**Describe the solution you'd like**

Make tracing tags consistent across SDKs.

**Additional context**

* Java: https://github.com/temporalio/sdk-java/issues/862
* TypeScript: https://github.com/temporalio/sdk-typescript/issues/360




---

<a id="580"></a>

### #580: WorkflowExecutionAlreadyStarted error for child workflows should work with IsWorkflowExecutionAlreadyStartedError

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/580 |
| **State** | CLOSED |
| **Author** | hungcs (hw) |
| **Created** | 2021-10-08 17:05:49.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-14 15:28:44.000 UTC |
| **Closed** | 2021-10-14 15:28:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior
If a childWorkflow encounters an error related to `workflowExecutionAlreadyStarted`, that error, when passed to `IsWorkflowExecutionAlreadyStartedError`, should return true.


## Actual Behavior

I have a child workflow that returns the error `child workflow execution error (type: xWorkflow, workflowID: x-id, runID: , initiatedEventID: 11, startedEventID: 0): workflow execution already started`
but `temporal.IsWorkflowExecutionAlreadyStartedError(err)` never returns true, even when the err is cast to `ChildWorkflowExecutionError` and unwrapped. However, the string message indicates that it is a workflow execution already started error.


## Steps to Reproduce the Problem

```
if err := workflow.ExecuteChildWorkflow(suspendChildCtx, xWorkflow, engineID).
		GetChildWorkflowExecution().
		Get(childCtx, nil); err != nil {
			var childWorkflowErr *temporal.ChildWorkflowExecutionError
			if errors.As(err, &childWorkflowErr) {
				unwrappedErr := err.(*temporal.ChildWorkflowExecutionError).Unwrap()

				// temporal.IsWorkflowExecutionAlreadyStartedError(unwrappedErr) does not work
				if unwrappedErr.Error() == "workflow execution already started" {
					return nil
				}
                 }
}
```

## Specifications

go.temporal.io/api v1.5.0
go.temporal.io/sdk v1.10.0



---

<a id="576"></a>

### #576: Fix errors in documentation comments

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/576 |
| **State** | CLOSED |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2021-10-07 16:02:34.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-12 19:45:22.000 UTC |
| **Closed** | 2021-10-12 19:45:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | cretz, flossypurse |
| **Milestone** | None |

#### Description

There are many leftovers from old Thrift errors in documentation comments: `EntityNotExistsError`, `BadRequestError`, `InternalServiceError` and others do not exist anymore and needs to be replaced with new errors actually returned by the code.


---

<a id="571"></a>

### #571: NewWorkflowReplayer does not support custom data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/571 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-10-04 21:35:54.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-18 20:32:41.000 UTC |
| **Closed** | 2021-10-18 20:32:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior
NewWorkflowReplayer should be able to replay history json file with custom data converter

## Actual Behavior
There is no option to set custom data converter for NewWorkflowReplayer.

## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:



---

<a id="556"></a>

### #556: TestBasic is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/556 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 07:35:37.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-04 14:38:56.000 UTC |
| **Closed** | 2021-10-04 14:38:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

```
=== CONT  TestIntegrationSuite
    integration_test.go:1268: 
        	Error Trace:	integration_test.go:1268
        	            				integration_test.go:187
        	Error:      	Not equal: 
        	            	expected: int(5)
        	            	actual  : int64(9)
        	Test:       	TestIntegrationSuite
        	Messages:   	Expected value doesn't match actual value for counter temporal_request
2021/09/24 00:35:18 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestBasic WorkerID 84580@arch@
--- FAIL: TestIntegrationSuite (11.32s)
=== RUN   TestIntegrationSuite/TestBasic
2021/09/24 00:35:08 INFO  Started Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestBasic WorkerID 84580@arch@
2021/09/24 00:35:11 INFO  calling ExecuteActivity Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestBasic WorkerID 84580@arch@ WorkflowType Basic WorkflowID test-basic RunID 0a66bd82-8639-45db-a43f-45f780e4c592 Attempt 1
2021/09/24 00:35:11 DEBUG ExecuteActivity Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestBasic WorkerID 84580@arch@ WorkflowType Basic WorkflowID test-basic RunID 0a66bd82-8639-45db-a43f-45f780e4c592 Attempt 1 ActivityID 5 ActivityType Prefix_ToUpperWithDelay
2021/09/24 00:35:15 DEBUG ExecuteActivity Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestBasic WorkerID 84580@arch@ WorkflowType Basic WorkflowID test-basic RunID 0a66bd82-8639-45db-a43f-45f780e4c592 Attempt 1 ActivityID 11 ActivityType Prefix_ToUpper
=== CONT  TestIntegrationSuite/TestBasic
    testing.go:1169: test executed panic(nil) or runtime.Goexit: subtest may have called FailNow on a parent test
    --- FAIL: TestIntegrationSuite/TestBasic (10.14s)



Expected :int(5)
Actual   :int64(9)
```



---

<a id="547"></a>

### #547: TestActivityRetryOnError is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/547 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-24 06:27:07.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-04 14:38:56.000 UTC |
| **Closed** | 2021-10-04 14:38:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

```
TestIntegrationSuite
    integration_test.go:331: 
        	Error Trace:	integration_test.go:331
        	Error:      	Not equal: 
        	            	expected: []string{"fail", "fail", "fail"}
        	            	actual  : []string{"fail", "fail"}
        	            	
        	            	Diff:
        	            	--- Expected
        	            	+++ Actual
        	            	@@ -1,3 +1,2 @@
        	            	-([]string) (len=3) {
        	            	- (string) (len=4) "fail",
        	            	+([]string) (len=2) {
        	            	  (string) (len=4) "fail",
        	Test:       	TestIntegrationSuite
2021/09/23 23:26:39 INFO  Stopped Worker Namespace integration-test-namespace TaskQueue tq-1-TestIntegrationSuite/TestActivityRetryOnError WorkerID 69614@arch@
--- FAIL: TestIntegrationSuite (13.53s)
```


---

<a id="530"></a>

### #530: ByteSliceConverter should accept interface{} in FromPayload

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/530 |
| **State** | CLOSED |
| **Author** | jackieli-tes (Jackie Li) |
| **Created** | 2021-09-09 11:04:37.000 UTC (4y 4m ago) |
| **Updated** | 2021-09-15 16:48:45.000 UTC |
| **Closed** | 2021-09-15 16:48:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I'd like to have an activity that accepts anything using `interface{}`. Accepting proto or json payload both work. However, accepting bytes panics. Like this one:

```go
func Dump(anything interface{}) error {
    fmt.Println(anything)
    return nil
}
```

**Describe the solution you'd like**
`ByteSliceConverter` be able to convert `[]byte` payload to `interface{}`. But it actually panics instead.

**Describe alternatives you've considered**
No alternatives possible

**Additional context**
N/A



---

<a id="526"></a>

### #526: Add open tracing support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/526 |
| **State** | CLOSED |
| **Author** | vitarb (Vitali) |
| **Created** | 2021-09-02 17:53:03.000 UTC (4y 4m ago) |
| **Updated** | 2021-11-15 17:52:25.000 UTC |
| **Closed** | 2021-11-15 17:52:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

See related discussion in #515 


---

<a id="524"></a>

### #524: Client interface comments don't mention Postgres

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/524 |
| **State** | CLOSED |
| **Author** | bouk (Bouke van der Bijl) |
| **Created** | 2021-09-01 17:34:12.000 UTC (4y 4m ago) |
| **Updated** | 2023-08-04 17:00:55.000 UTC |
| **Closed** | 2023-08-04 17:00:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hi, I was reading the docs of the `Client` interface and they mention Cassandra and MySQL in some cases:

https://github.com/temporalio/sdk-go/blob/0c69423d6b98508c910f65ddad17fbe1967cd8d7/client/client.go#L252-L253

I assume that this should read '[...] will return BadRequestError when using Cassandra, MySQL or Postgres'? Or is `ListWorkflow` supported on Postgres without Elasticsearch?


---

<a id="514"></a>

### #514: TestActivityEnvironment.ExecuteActivity requires RegisterActivity when invoking activity by function

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/514 |
| **State** | OPEN |
| **Author** | dynajoe (Joe Andaverde) |
| **Created** | 2021-08-10 22:05:13.000 UTC (4y 5m ago) |
| **Updated** | 2021-10-28 13:46:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | cretz |
| **Milestone** | None |

#### Description

## Expected Behavior

I expect this code to work without the commented section:


```go
type FooActivityTestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
}
```

```go
func (s *FooActivityTestSuite) TestFoo() {
	a := NewFooActivities()
	env := s.NewTestActivityEnvironment()
	// env.RegisterActivity(a.FooActivity)
	_, err := env.ExecuteActivity(a.FooActivity, FooActivityInput{})
}
```

## Actual Behavior

The above results in a test panic:

```
 no activity is registered for taskqueue 'default-test-taskqueue'
```

## Specifications

  - Version: go sdk 1.8.0



---

<a id="505"></a>

### #505: Non-retryable errors in sessions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/505 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2021-08-02 16:18:10.000 UTC (4y 5m ago) |
| **Updated** | 2024-12-16 20:49:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

Some errors need to be non-retryable in sessions, for example heartbeat failures and panics that bring down the worker shouldn't be retried because the worker's state will have been lost. It appears cadence supports this in retry policy settings for sessions but we don't. More context on our internal slack here: https://temporaltechnologies.slack.com/archives/C01FG4BRQVB/p1620110340297700


---

<a id="503"></a>

### #503: Unhandled timer fired commands during workflow cancelations can cause SDK to issue cancel cmd for already-resolved timer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/503 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2021-07-31 00:03:36.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-07 01:04:51.000 UTC |
| **Closed** | 2021-08-07 01:04:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior
We should never send a timer cancel command for a timer that has already fired

## Actual Behavior
We do :(

## Steps to Reproduce the Problem
Repro history in associated PR




---

<a id="491"></a>

### #491: Testsuite Workflow Retry not working

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/491 |
| **State** | OPEN |
| **Author** | leowmjw |
| **Created** | 2021-07-17 23:41:38.000 UTC (4y 5m ago) |
| **Updated** | 2021-07-17 23:41:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

TestSuite should mimic actual behavior when workflow returns ApplicationError; which is to retry

## Actual Behavior

Only one run happens, no retry

## Steps to Reproduce the Problem

Code:
```
func (s *WorkflowTestSuiteUnitTest) Test_WorkflowRetry() {
	trackFailure := 0
	workflowFn := func(ctx Context) (string, error) {
		trackFailure++
		// Happy path ..
		if trackFailure > 1 {
			return "s1s2", nil
		}
		return "", NewApplicationError("unlucky", "retry", false, errors.New("try again"))
	}

	env := s.NewTestWorkflowEnvironment()
	env.SetStartWorkflowOptions(StartWorkflowOptions{
		RetryPolicy: &RetryPolicy{
			InitialInterval: time.Second,
			MaximumAttempts: 5,
		},
	})
	env.ExecuteWorkflow(workflowFn)

	s.True(env.IsWorkflowCompleted())
	s.NoError(env.GetWorkflowError())
	var result string
	_ = env.GetWorkflowResult(&result)
	s.Equal("s1s2", result)
}

```

Error:
```
=== RUN   TestUnitTestSuite/Test_WorkflowRetry
    internal_workflow_testsuite_test.go:2670: 
        	Error Trace:	internal_workflow_testsuite_test.go:2670
        	Error:      	Received unexpected error:
        	            	workflow execution error (type: func1, workflowID: default-test-workflow-id, runID: default-test-run-id): unlucky (type: retry, retryable: true): try again
        	Test:       	TestUnitTestSuite/Test_WorkflowRetry

```

## Specifications

  - Version: v1.8.0
  - Platform: OSX



---

<a id="483"></a>

### #483: Propagation of cancellations to child workflows can cause state machine panic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/483 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2021-07-02 16:40:23.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-12 18:24:41.000 UTC |
| **Closed** | 2021-07-12 18:24:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Child workflows all cancel successfully 

## Actual Behavior
One or more children can fail to terminate w/ `"BadRequestCancelActivityAttributes: invalid history builder state for action: add-activitytask-cancel-requested-event"`

## Steps to Reproduce the Problem
See https://community.temporal.io/t/error-in-child-workflow-when-parent-is-cancelled/2492

## Specifications
  - Version: 1.7.0
  - Platform:

It looks like this could be related to https://github.com/temporalio/sdk-go/issues/481 which produces the same error. Ideally both can be fixed at once.



---

<a id="482"></a>

### #482: Workflow query hangs if the temporal workflow execution panics (is not available)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/482 |
| **State** | OPEN |
| **Author** | ingyamilmolinar (ymolinar) |
| **Created** | 2021-06-30 21:40:45.000 UTC (4y 6m ago) |
| **Updated** | 2021-06-30 21:40:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The client should timeout within a reasonable time and NOT hang if a workflow execution result is unavailable for whatever reason (such as an execution panicking). A sane timeout default and an option to configure it should be provided.

## Actual Behavior
The client hangs while running a query for a workflow execution that is not available (ex: panicking). We tried setting the `QueryRejectCondition` option to different values with no success. The client still hangs forever.

Interestingly, making the same query through `tctl` will timeout in 5 seconds. This means that the `tctl` codebase does have a default timeout of 5 seconds and the Go SDK does not.

## Steps to Reproduce the Problem

  1. Create a workflow that can panic or that can be unavailable for some reason.
  2. Create a query within the workflow
  3. Run the workflow and make it panic
  4. Use the Go client to run the query for that workflow and see how it hangs

## Specifications

  - Version: 1.4.1
  - Platform: Linux 5.7.0-0.bpo.2-amd64 #1 SMP Debian 5.7.10-1~bpo10+1 (2020-07-30) x86_64 GNU/Linux



---

<a id="470"></a>

### #470: Test to support ParentClosePolicy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/470 |
| **State** | CLOSED |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-06-17 20:40:20.000 UTC (4y 6m ago) |
| **Updated** | 2021-06-18 18:47:11.000 UTC |
| **Closed** | 2021-06-18 18:47:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Test framework does not respect ParentClosePolicy set on child workflow. For example, if set child workflow's ParentClosePolicy to PARENT_CLOSE_POLICY_ABANDON, which means when parent workflow closed, its child workflow should continue executing. 

**Describe the solution you'd like**
The unit test framework should respect ParentClosePolicy. 

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
Reported by user:
https://community.temporal.io/t/best-way-to-create-an-async-child-workflow/114/6


---

<a id="465"></a>

### #465: Activity stays in started state when ActivityType is not registered

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/465 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2021-06-15 17:50:47.000 UTC (4y 6m ago) |
| **Updated** | 2021-06-17 05:29:28.000 UTC |
| **Closed** | 2021-06-17 05:29:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
Worker should fail the activity immediately with "Activity type not registered" error if it picks up the task from task queue and not able to find registered type.

## Actual Behavior
If activity start_to_close timeout is large than activity stays stuck in the started state.  Basically worker picks up the task and silently fails it without reporting anything back to the service.

## Steps to Reproduce the Problem

  1.  Start workflow which schedules an activity where type is not registered
  1.  Start worker which polls on the task queue
  1.  Worker picks up the activity task and fails silently

## Specifications

  - Version:
  - Platform:



---

<a id="449"></a>

### #449: Activity Latency Metrics Missing Task Queue Name

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/449 |
| **State** | CLOSED |
| **Author** | keelerm84 (Matthew M. Keeler) |
| **Created** | 2021-05-26 01:33:59.000 UTC (4y 7m ago) |
| **Updated** | 2021-05-28 04:07:39.000 UTC |
| **Closed** | 2021-05-28 04:07:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Activity latency metrics like `activity_schedule_to_start_latency` and `activity_endtoend_latency` should be tagged with the task queue name like the Java SDK does.

## Actual Behavior

The activity latency metrics have `none` set for the task queue value.

## Steps to Reproduce the Problem

  1. Export prometheus metrics from an application running activity workers
  1. Search for the `activity_schedule_to_start_latency` metric and verify the task queue name is not set.

## Specifications

  - Version: v1.6.0
  - Platform: Linux



---

<a id="447"></a>

### #447: worker.Start should fail after worker.Stop was called

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/447 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-05-24 15:47:39.000 UTC (4y 7m ago) |
| **Updated** | 2021-05-26 06:24:33.000 UTC |
| **Closed** | 2021-05-26 06:24:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A user tried to "restart" a worker by calling worker.Stop/worker.Start. It didn't behave like he expected.

**Describe the solution you'd like**
Panic on worker.Start after the worker.Stop was called.

**Describe alternatives you've considered**
Keep it as it is.

**Additional context**
[This forum topic](https://community.temporal.io/t/worker-does-not-start-activity-after-restart/2178/15).


---

<a id="437"></a>

### #437: Cancel activity context on service not being reachable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/437 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-05-10 15:54:55.000 UTC (4y 8m ago) |
| **Updated** | 2021-06-07 17:11:44.000 UTC |
| **Closed** | 2021-06-07 17:11:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Activity context is canceled (Done channel is closed) if it cannot reach the service for the duration of the heartbeat timeout.

## Actual Behavior
The error is logged and a new heartbeat is issued after the heartbeat timeout. This can create problems as the activity cannot rely on being notified about issues after the heartbeat timeout interval.

## Relevant forum post

https://community.temporal.io/t/best-practices-for-long-running-activities/934/6


---

<a id="427"></a>

### #427: Test that an activity wasn't called

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/427 |
| **State** | CLOSED |
| **Author** | app/ |
| **Created** | 2021-05-04 23:35:26.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-05 22:34:21.000 UTC |
| **Closed** | 2021-05-05 22:34:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

For a workflow in which I have few branches, I'd like to assert that an activity wasn't called

I found this entry

https://community.temporal.io/t/workflow-unit-tests-questions-why-use-dummy-activities-how-to-ensure-activity-was-not-called-how-to-create-an-instance-of-workflow-context/756

## Expected Behavior

```go
env.OnActivity("activity a", mock.Anything).Panic(":( this activity shouldn't  be called")
```

Should return an error if the activity was called and the assert should **pass** if the activity wasn't called.

## Actual Behavior

The assert is failing if the activity isn't called.

## Steps to Reproduce the Problem

  1. Create a Workflow with at least one conditional branch
  2. Call a different activity on each branch
  3. Create a test for one the branches adding an OnActivity(...).Panic(...) to test that the activity in the other branch is not called
  4. Execute the test
  
Here is an example

```go
package dummy

import (
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/activity"
	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/workflow"
	"testing"
	"time"
)

const (
	ActivityA = "Activity_a"
	ActivityB = "Activity_b"
	ActivityC = "Activity_c"
)

type Result struct {
	Value string
}

func Process(ctx workflow.Context, b bool) error {

	var r Result

	aCtx := workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
		ScheduleToStartTimeout: time.Second,
		ScheduleToCloseTimeout: time.Second,
	})

	if b {
		if err := workflow.ExecuteActivity(aCtx, ActivityA, "foo").Get(ctx, &r); err != nil {
			return err
		}
	} else {
		if err := workflow.ExecuteActivity(aCtx, ActivityB, "bar").Get(ctx, &r); err != nil {
			return err
		}
	}

	return workflow.ExecuteActivity(aCtx, ActivityC, r).Get(ctx, nil)
}

type Suite struct {
	suite.Suite
	testsuite.WorkflowTestSuite

	env      *testsuite.TestWorkflowEnvironment
}

func TestSuite(t *testing.T) {
	suite.Run(t, new(Suite))
}

func (s *Suite) AfterTest(suiteName, testName string) {
	s.env.AssertExpectations(s.T())
}

func (s *Suite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()

	dummy := func(interface{}) (interface{}, error) { return nil, nil }

	s.env.RegisterActivityWithOptions(dummy, activity.RegisterOptions{
		Name: ActivityA,
	})

	s.env.RegisterActivityWithOptions(dummy, activity.RegisterOptions{
		Name: ActivityB,
	})

	s.env.RegisterActivityWithOptions(func(interface{}) error { return nil }, activity.RegisterOptions{
		Name: ActivityC,
	})
}

func (s *Suite) TestBranchA() {
	s.env.OnActivity(ActivityA, mock.Anything).Return(&Result{Value: "A Result OK"}, nil).Once()
	s.env.OnActivity(ActivityB, mock.Anything).Panic(":( unexpected activity call")
	s.env.OnActivity(ActivityC, mock.Anything).Return(nil).Once()

	s.env.ExecuteWorkflow(Process, true)
	s.True(s.env.IsWorkflowCompleted())
	s.Nil(s.env.GetWorkflowError())
}
```

```
2021/05/04 22:09:54 DEBUG handleActivityResult: *workflowservice.RespondActivityTaskCompletedRequest. ActivityID 1 ActivityType Activity_a
2021/05/04 22:09:54 DEBUG handleActivityResult: *workflowservice.RespondActivityTaskCompletedRequest. ActivityID 2 ActivityType Activity_c
    workflow_testsuite.go:793: PASS:	Activity_a(string)
    workflow_testsuite.go:793: FAIL:	Activity_b(string)
        		at: [workflow_testsuite.go:308 dummt_test.go:80]
    workflow_testsuite.go:793: PASS:	Activity_c(string)
    workflow_testsuite.go:793: FAIL: 2 out of 3 expectation(s) were met.
        	The code you are testing needs to make 1 more call(s).
        	at: [workflow_testsuite.go:793 dummt_test.go:57 suite.go:137 suite.go:159]
--- FAIL: TestSuite (0.00s)
    --- FAIL: TestSuite/TestBranchA (0.00s)

```

## Specifications

  - Version: 1.6.0



---

<a id="411"></a>

### #411: ChildWorkflowExecution Future doesn't return error on WORKFLOW_ALREADY_EXISTS

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/411 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-04-21 00:07:54.000 UTC (4y 8m ago) |
| **Updated** | 2021-06-07 06:03:05.000 UTC |
| **Closed** | 2021-06-07 06:03:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
The following code
```go
	err := workflow.ExecuteChildWorkflow(ctx, SampleChildWorkflow, "World").GetChildWorkflowExecution().Get(ctx, nil)
```
has to return an error if a child start failed due to CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS.

## Actual Behavior
Nothing is returned.

## Steps to Reproduce the Problem
The following code reproduces the problem:
```go
func SampleParentWorkflow(ctx workflow.Context) (string, error) {
	logger := workflow.GetLogger(ctx)

	cwo := workflow.ChildWorkflowOptions{WorkflowID: "child1", ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON}
	ctx = workflow.WithChildOptions(ctx, cwo)

	var result string
	err := workflow.ExecuteChildWorkflow(ctx, SampleChildWorkflow, "World").GetChildWorkflowExecution().Get(ctx, nil)
	if err != nil {
		logger.Error("Parent execution received child execution failure.", "Error", err)
		return "", err
	}
	logger.Info("Parent execution completed.", "Result", result)
	return result, nil
}
```
Relevant history:
![Screen Shot 2021-04-20 at 5 06 53 PM](https://user-images.githubusercontent.com/1463622/115478365-d60cef80-a1fa-11eb-9b52-ec50d68cfb09.png)

I verified through stack trace that workflow is blocked on the `Future.Get` call.



---

<a id="390"></a>

### #390: Add support for querying child workflows in unit tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/390 |
| **State** | CLOSED |
| **Author** | nadilas |
| **Created** | 2021-03-27 11:56:14.000 UTC (4y 9m ago) |
| **Updated** | 2021-03-31 05:55:44.000 UTC |
| **Closed** | 2021-03-31 05:55:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Missing feature:
`func (e *TestWorkflowEnvironment) QueryWorkflowByID(workflowID, queryType string, args ...interface{}) (converter.EncodedValue, error)`

**Describe the solution you'd like**
add as new feature



---

<a id="378"></a>

### #378: Workflow panics after cleanup activity, if cancel occurs during workflow sleep

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/378 |
| **State** | CLOSED |
| **Author** | chooilow |
| **Created** | 2021-03-05 22:30:32.000 UTC (4y 10m ago) |
| **Updated** | 2021-03-16 17:39:17.000 UTC |
| **Closed** | 2021-03-16 17:39:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior
Workflow should finish in a Canceled state.

## Actual Behavior
Workflow remains stuck in a Running state.

Worker logs:

```
2021/03/05 15:00:47 INFO  cancel workflow started Namespace default TaskQueue cancel-activity WorkerID 1228@DESKTOP-N6GI56U@ WorkflowType Workflow WorkflowID workflowID-to-cancel RunID 64579d93-9785-4a09-80c3-216935e67981 Attempt 1
2021/03/05 15:00:47 DEBUG NewTimer Namespace default TaskQueue cancel-activity WorkerID 1228@DESKTOP-N6GI56U@ WorkflowType Workflow WorkflowID workflowID-to-cancel RunID 64579d93-9785-4a09-80c3-216935e67981 Attempt 1 TimerID 5 Duration 1m0s
2021/03/05 15:00:56 DEBUG RequestCancelTimer Namespace default TaskQueue cancel-activity WorkerID 1228@DESKTOP-N6GI56U@ WorkflowType Workflow WorkflowID workflowID-to-cancel RunID 64579d93-9785-4a09-80c3-216935e67981 Attempt 1 TimerID 5
2021/03/05 15:00:56 DEBUG ExecuteActivity Namespace default TaskQueue cancel-activity WorkerID 1228@DESKTOP-N6GI56U@ WorkflowType Workflow WorkflowID workflowID-to-cancel RunID 64579d93-9785-4a09-80c3-216935e67981 Attempt 1 ActivityID 10 ActivityType CleanupActivity
2021/03/05 15:00:56 INFO  cleanupActivity started Namespace default TaskQueue cancel-activity WorkerID 1228@DESKTOP-N6GI56U@ ActivityID 10 ActivityType CleanupActivity Attempt 1 WorkflowType Workflow WorkflowID workflowID-to-cancel RunID 64579d93-9785-4a09-80c3-216935e67981
2021/03/05 15:00:56 ERROR Workflow panic Namespace default TaskQueue cancel-activity WorkerID 1228@DESKTOP-N6GI56U@ WorkflowType Workflow WorkflowID workflowID-to-cancel RunID 64579d93-9785-4a09-80c3-216935e67981 Attempt 1 Error lookup failed for scheduledEventID to activityID: scheduleEventID: 11, activityID: 10 StackTrace process event for cancel-activity [panic]:
go.temporal.io/sdk/internal.panicIllegalState(...)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_decision_state_machine.go:393
go.temporal.io/sdk/internal.(*commandsHelper).handleActivityTaskScheduled(0xc00006e640, 0xc00054e050, 0x2, 0xb)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_decision_state_machine.go:878 +0x171
go.temporal.io/sdk/internal.(*workflowExecutionEventHandlerImpl).ProcessEvent(0xc00055ab40, 0xc00055e200, 0x4e5140001, 0x0, 0x0)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_event_handlers.go:800 +0x41e
go.temporal.io/sdk/internal.(*workflowExecutionContextImpl).ProcessWorkflowTask(0xc0000787e0, 0xc000366540, 0x1ef2c20, 0xc0000f0150, 0xc0000787e0, 0x0)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_handlers.go:876 +0x73c
go.temporal.io/sdk/internal.(*workflowTaskHandlerImpl).ProcessWorkflowTask(0xc000430210, 0xc000366540, 0xc000571ef0, 0x0, 0x0, 0x0, 0x0)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_handlers.go:727 +0x759
go.temporal.io/sdk/internal.(*workflowTaskPoller).processWorkflowTask(0xc00040e270, 0xc000366540, 0x0, 0x0)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_pollers.go:288 +0x4ae
go.temporal.io/sdk/internal.(*workflowTaskPoller).ProcessTask(0xc00040e270, 0x17af4a0, 0xc000366540, 0x19ff500, 0xc000401da0)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_task_pollers.go:259 +0x87
go.temporal.io/sdk/internal.(*baseWorker).processTask(0xc000446000, 0x17af060, 0xc0005600c0)
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_worker_base.go:343 +0xc6
created by go.temporal.io/sdk/internal.(*baseWorker).runTaskDispatcher
        C:/Users/chooi/go/pkg/mod/go.temporal.io/sdk@v1.5.0/internal/internal_worker_base.go:270 +0x106
```
## Steps to Reproduce the Problem
Add a simple workflow.Sleep to the cancelactivity sample code, and cancel the workflow before the timer expires:
```
func Workflow(ctx workflow.Context) error {
	ao := workflow.ActivityOptions{
		ScheduleToStartTimeout: time.Minute,
		StartToCloseTimeout:    time.Minute * 30,
		HeartbeatTimeout:       time.Second * 5,
		WaitForCancellation:    true,
	}
	logger := workflow.GetLogger(ctx)
	logger.Info("cancel workflow started")

	ctx = workflow.WithActivityOptions(ctx, ao)

	var a *Activities // Used to call activities by function pointer
	defer func() {
		// When workflow is canceled, it has to get a new disconnected context to execute any activities
		newCtx, _ := workflow.NewDisconnectedContext(ctx)
		workflow.ExecuteActivity(newCtx, a.CleanupActivity).Get(ctx, nil)
	}()

	if err := workflow.Sleep(ctx, time.Minute * 1); err != nil {
		return err
	}

	var result string
	err := workflow.ExecuteActivity(ctx, a.ActivityToBeCanceled).Get(ctx, &result)
	logger.Info(fmt.Sprintf("activityToBeCanceled returns %v, %v", result, err))

	err = workflow.ExecuteActivity(ctx, a.ActivityToBeSkipped).Get(ctx, nil)
	logger.Error("Error from activityToBeSkipped", "Error", err)

	logger.Info("Workflow completed.")

	return nil
}
```

## Specifications

  - Version: Latest sdk-go 1.5.0 on temporal service 1.7.0
  - Platform: Windows



---

<a id="362"></a>

### #362: Tracer do not export workflow trace

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/362 |
| **State** | CLOSED |
| **Author** | nicolasgere |
| **Created** | 2021-02-11 22:54:47.000 UTC (4y 11m ago) |
| **Updated** | 2021-02-11 23:12:13.000 UTC |
| **Closed** | 2021-02-11 23:12:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Using tracer, we should be able to have trace for the workflow with child trace for activities

## Actual Behavior
We just have the child activity traces

## Steps to Reproduce the Problem

  1. Set temporal/jaerger locally using docker
  2. Check the code there https://gist.github.com/nicolasgere/acaf010e505fdbefdef704b74d26cea2

## Specifications

  - Version: SDK 1.3/1.4
  - Platform: Linux



---

<a id="354"></a>

### #354: Allow string activity names in `workflow.ExecuteLocalActivity`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/354 |
| **State** | CLOSED |
| **Author** | benjaminsky (Ben Campbell) |
| **Created** | 2021-02-08 21:47:33.000 UTC (4y 11m ago) |
| **Updated** | 2021-04-01 22:05:01.000 UTC |
| **Closed** | 2021-04-01 22:05:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We have a DSL use-case and without this functionality, it requires multiple files changes when adding an activity unless we implement the reflection-based solution ourselves.

**Describe the solution you'd like**
Allow string `activity` parameter values for `workflow.ExecuteLocalActivity` the same way `workflow.ExecuteActivity` allows it currently.

**Describe alternatives you've considered**
We could implement the reflection based call ourselves but currently we make the calls in a switch statement.

**Additional context**




---

<a id="346"></a>

### #346: RequestCancelExternalWorkflow(...).Get(ctx, nil) blocks forever with workflow exits with ErrCanceled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/346 |
| **State** | OPEN |
| **Author** | shaunco (Shaun) |
| **Created** | 2021-01-21 11:25:25.000 UTC (4y 11m ago) |
| **Updated** | 2021-01-21 11:25:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`RequestCancelExternalWorkflow(...).Get(ctx, nil)` should block until the workflow exits, regardless of what workflow returns.

## Actual Behavior
If the workflow being canceled returns `nil`, `RequestCancelExternalWorkflow(...).Get(ctx, nil)` properly blocks until the canceled workflow has exited, but if the canceled workflow returns `ErrCanceled` then `Get()` never returns. Weirdly, if the `Get(ctx, nil)` is changed to:
```go
var wfErr error
RequestCancelExternalWorkflow(...).Get(ctx, &wfErr)
```
then `Get()` properly returns once the canceled workflow exits, but `wfErr` is always nil.

Sample:
```go
const TestWorkflowId = "MyTestWorkflow"

func StartTestWorkflow(ctx workflow.Context) error {
	cwo := workflow.ChildWorkflowOptions{
		WorkflowIDReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE,
		ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,
		WorkflowID: TestWorkflowId,
		TaskQueue: "MY_TASK_QUEUE",
	}

	ctx = workflow.WithChildOptions(ctx, cwo)

	// Start this receiver's workflow
	future := workflow.ExecuteChildWorkflow(ctx, TestWorkflow)

	var childWE tworkflow.Execution
	err := future.GetChildWorkflowExecution().Get(ctx, &childWE)
	if err != nil {
		return err
	}

	return nil
}

func CancelTestWorkflow(ctx workflow.Context) error {
	// This will block forever, unless TestWorkflow returns nil
	err := workflow.RequestCancelExternalWorkflow(ctx, TestWorkflowId, "").Get(ctx, nil)
	if err != nil {
		return err
	}

	return nil
}

func TestWorkflow(ctx workflow.Context) error {
	// Wait until canceled
	canceled := false
	s := workflow.NewSelector(ctx)
	s.AddReceive(ctx.Done(), func(c workflow.ReceiveChannel, more bool) {
		c.Receive(ctx, nil)
		canceled = true
	})

	// Block until an event signal is received
	s.Select(ctx)

	// If we were canceled, immediately exit
	if canceled {
		// Switch to return nil
		return workflow.ErrCanceled
	}

	// Loop foever
	return workflow.NewContinueAsNewError(ctx, TestWorkflow, nil)
}
```

## Steps to Reproduce the Problem

  1. Use the above code by executing the `StartTestWorkflow` and `CancelTestWorkflow` workflows

## Specifications

  - Version: sdk-gov1.3.0, server v1.5.1
  - Platform: Ubuntu



---

<a id="343"></a>

### #343: Invalid state transition panic when cancelling a child workflow, and a parent workflow consecutively

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/343 |
| **State** | CLOSED |
| **Author** | MrSaints (Ian L.) |
| **Created** | 2021-01-20 02:34:22.000 UTC (4y 11m ago) |
| **Updated** | 2021-01-21 00:31:47.000 UTC |
| **Closed** | 2021-01-21 00:31:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

## Expected Behavior

Cancelling a child workflow, and a parent workflow consecutively should not result in an irrecoverable (possibly?) workflow panic.

As for context as to why we are doing this, frankly, we discovered this by chance as we implemented our own cancellation logic which only runs under certain conditions. It is initiated through a signal, and uses `workflow.WithCancel` to perform the "cancellation". We signalled to the child workflow to cancel, but accidentally called `CancelWorkflow` on the parent workflow directly after, resulting in the panic described in this bug report.


## Actual Behavior

The child workflow is successfully cancelled, but the parent workflow fails to be cancelled.

```
PanicError: invalid state transition: attempt to handleCompletionEvent, CommandType: ChildWorkflow,
ID: adc6a828-0e7c-4435-beba-a5f45dccbc0f_5, state=Unknown, isDone()=false, history=[Created handleCommandSent CommandSent handleInitiatedEvent Initiated handleStartedEvent Started cancel CanceledAfterStarted handleCommandSent CancellationCommandSent handleCancelInitiatedEvent handleExternalWorkflowExecutionCancelRequested Unknown]
```


## Steps to Reproduce the Problem

I've modified the `child-workflow` sample to demonstrate the failure scenario.

https://github.com/MrSaints/samples-go/commit/d089fdd684c4519d70bfeb6a07836efe99e3e3ba

I've added a _blocking_ signal channel to mimic some relatively slow clean up behaviour that we do on our own child workflow. 

Assuming Temporal is running locally, in the `child-workflow` directory, run:

- `go run worker/main.go`
- `go run starter/main.go`

The parent workflow should now be stuck, unable to cancel properly. It can however, be terminated.


## Specifications

  - Version: 1.3.0
  - Platform: Linux




---

<a id="335"></a>

### #335: Original Failure source is lost when ConvertFailureToError invoked

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/335 |
| **State** | OPEN |
| **Author** | wolfy-j (Anton Tsitou) |
| **Created** | 2021-01-12 17:39:34.000 UTC (4y 12m ago) |
| **Updated** | 2021-01-12 17:39:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Keep the original source.

## Actual Behavior
Sets GoSDK


---

<a id="301"></a>

### #301: Add Selector.HasPending

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/301 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-11-29 18:18:39.000 UTC (5y 1m ago) |
| **Updated** | 2020-12-29 00:15:50.000 UTC |
| **Closed** | 2020-12-29 00:15:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently to guarantee that every signal is delivered all channels have to be drained using ReadAsync before completing a workflow. This leads to code that looks like:
```go
type channelConfig struct {
  channel workflow.ReceiveChannel
  val interface{}
  handler func()  // do something with val
}

channels := []*channelConfig{
  {
    channel: workflow.GetSignalChannel(...)
    val: "",
    handler func() {
      // do something with val
    },
  },
  // etc
}

s := workflow.NewSelector(ctx)
for _, cc := range channels {
  s.AddReceive(cc.channel, func (c workflow.ReceiveChannel, _ bool) {
    c.Receive(ctx, &cc.val)
    cc.handler()
  })
}

for keepGoing {
  s.Select(ctx)
  // not safe to return here
}

// Now I want to return but first I need to make sure that no signals are pending
canReturn := false
for !canReturn {
  canReturn = true
  for _, cc := range channels {
    if ok := c.ReceiveAsync(&cc.val); ok {
      canReturn = false
      cc.handler()
    }
  }
}
```

**Describe the solution you'd like**
Add Selector.HasPending method that returns true if Selector.Select is not going to block if called. This would simplify the above code to:
```go
type channelConfig struct {
  channel workflow.ReceiveChannel
  val interface{}
  handler func()  // do something with val
}

channels := []*channelConfig{
  {
    channel: workflow.GetSignalChannel(...)
    val: "",
    handler func() {
      // do something with val
    },
  },
  // etc
}

s := workflow.NewSelector(ctx)
for _, cc := range channels {
  s.AddReceive(cc.channel, func (c workflow.ReceiveChannel, _ bool) {
    c.Receive(ctx, &cc.val)
    cc.handler()
  })
}

for keepGoing || s.HasPending {
  s.Select(ctx)
}

// safe complete workflow here
```


**Describe alternatives you've considered**
Add Channel.HasPending or ReceiveChannel.Peek. But it wouldn't help with Select and still require code complications.

**Additional context**
https://community.temporal.io/t/continueasnew-signals/1008/25


---

<a id="291"></a>

### #291: Expose previous run failure though workflow context API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/291 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-11-17 02:44:25.000 UTC (5y 1m ago) |
| **Updated** | 2020-11-24 21:53:39.000 UTC |
| **Closed** | 2020-11-24 21:53:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Current we expose getLastCompletionResult api used for communicating the result of
previous workflow run to next run. But we don't have similar api which exposes last
failure.

**Describe the solution you'd like**
Expose lastFailure api which exposes failure of previous run but we still did a
continueAsNew because of cron or retry policy. LastCompletionResult is still carried over
from earlier run even when previous run fails due to an error.

**Additional context**
https://community.temporal.io/t/bug-on-getlastcompletionresult-returns-null-if-previous-run-timeout-or-fail/997



---

<a id="279"></a>

### #279: StartWorkflow and OnWorkflowTaskStarted triggered twice on the same worker on QueryWorkflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/279 |
| **State** | CLOSED |
| **Author** | wolfy-j (Anton Tsitou) |
| **Created** | 2020-11-02 18:46:12.000 UTC (5y 2m ago) |
| **Updated** | 2020-12-29 17:50:05.000 UTC |
| **Closed** | 2020-12-29 17:50:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Temporal should either use existing workflow env or destroy the previous version before queriing it.

## Actual Behavior
Temporal Go SDK issues a second workflow version without destroying previous state which corrupts the workflow state if external memory used. 

We are using extension API (**go.temporal.io/sdk/internalbindings**).


---

<a id="277"></a>

### #277: Expose access to grpc.ServiceClient so we can create default golang client and get access to underlying GRPC client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/277 |
| **State** | OPEN |
| **Author** | wolfy-j (Anton Tsitou) |
| **Created** | 2020-10-28 18:56:44.000 UTC (5y 2m ago) |
| **Updated** | 2020-10-28 18:56:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
For the PHP SDK, we have to generate proper client code.

**Describe the solution you'd like**
Expose access to grpc.ServiceClient so we can create default golang client and get access to underlying GRPC client.

**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="276"></a>

### #276: Reduce the severnity of "no activities/workflow registered" message by Temporal worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/276 |
| **State** | CLOSED |
| **Author** | wolfy-j (Anton Tsitou) |
| **Created** | 2020-10-26 17:51:13.000 UTC (5y 2m ago) |
| **Updated** | 2020-12-29 19:14:53.000 UTC |
| **Closed** | 2020-12-29 19:14:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We are running separate workers for activities and workflows (server/client model with PHP), seeing this message is pretty annoying and does not bring any value.

**Describe the solution you'd like**
Keep the message but use DEBUG level.

**Additional context**
http://prntscr.com/v7a9r4



---

<a id="272"></a>

### #272: Get RunId using WorkflowClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/272 |
| **State** | CLOSED |
| **Author** | agnithin (Nithin) |
| **Created** | 2020-10-14 08:00:23.000 UTC (5y 2m ago) |
| **Updated** | 2020-11-24 19:56:19.000 UTC |
| **Closed** | 2020-11-24 19:56:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
https://community.temporal.io/t/how-to-get-last-runid/658

**Describe the solution you'd like**
Add a way to get the run id (and maybe workflow status) directly using the WorkflowClient.
Right now the only way is to use DescribeWorkflowExecution call




---

<a id="247"></a>

### #247: Retrieved String Search Attribute includes quotation characters

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/247 |
| **State** | OPEN |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-09-15 00:20:44.000 UTC (5y 3m ago) |
| **Updated** | 2020-09-15 00:20:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | potential-bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

All details are here: https://github.com/temporalio/temporal/issues/524.


---

<a id="238"></a>

### #238: RecordActivityHeartbeat signature should be modified to return an error if activity has been canceled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/238 |
| **State** | OPEN |
| **Author** | mastermanu |
| **Created** | 2020-08-25 04:16:30.000 UTC (5y 4m ago) |
| **Updated** | 2020-08-25 04:16:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently RecordActivityHeartbeat doesn't return an error and is basically a "no-op." If the Activity is canceled, the user has to still do a select on the context to see if it is Done. It would be convenient if the RecordActivityHeartbeat invocation did this check internally and returned an error if there were a problem.


---

<a id="213"></a>

### #213: Cancellation of Child Workflows leads to an apparent deadlock

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/213 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2020-07-27 22:05:56.000 UTC (5y 5m ago) |
| **Updated** | 2020-07-28 21:42:59.000 UTC |
| **Closed** | 2020-07-28 21:42:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | samarabbas, mastermanu |
| **Milestone** | None |

#### Description

./tctl workflow show -w pandemic-4-0-0
2020/07/27 15:02:48 INFO  No logger configured for temporal client. Created default one.
   1  WorkflowExecutionStarted                         {WorkflowType:{Name:config-driven-workflow},                                                        
                                                       ParentInitiatedEventId:0, TaskQueue:{Name:temporal-bench,                                           
                                                       Kind:Normal}, Input:[{BuiltIn:pandemic                                                              
                                                       ContinueAsNewCount:0 CumulativeSignalCount:0                                                        
                                                       CumulativeStepCount:0 CumulativeTimeInSeconds:0                                                     
                                                       FileName: Pandemic:map[Depth:4 Fanout:3 Type:cancel]                                                
                                                       RemainingDurationInSeconds:0 RemainingSignalCount:0                                                 
                                                       RootConfigDrivenWorkflowID:pandemic-4-0-0                                                           
                                                       SignalCarryOverCount:0 StatsWorkflowID:}],                                                          
                                                       WorkflowExecutionTimeoutSeconds:315360000,                                                          
                                                       WorkflowRunTimeoutSeconds:86400,                                                                    
                                                       WorkflowTaskTimeoutSeconds:10,                                                                      
                                                       Initiator:Workflow, LastCompletionResult:[],                                                        
                                                       OriginalExecutionRunId:b2e46378-1686-43bb-9d45-1aa70c5f8352,                                        
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       FirstExecutionRunId:b2e46378-1686-43bb-9d45-1aa70c5f8352,                                           
                                                       Attempt:1, WorkflowExecutionExpirationTimestamp:0,                                                  
                                                       FirstWorkflowTaskBackoffSeconds:0, Header:{Fields:map{}}}                                           
   2  WorkflowTaskScheduled                            {TaskQueue:{Name:temporal-bench,                                                                    
                                                       Kind:Normal},                                                                                       
                                                       StartToCloseTimeoutSeconds:10,                                                                      
                                                       Attempt:1}                                                                                          
   3  WorkflowTaskStarted                              {ScheduledEventId:2,                                                                                
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       RequestId:31d18d04-3b80-44af-bd3d-e7d5e0a668a8}                                                     
   4  WorkflowTaskCompleted                            {ScheduledEventId:2, StartedEventId:3,                                                              
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                    
   5  ActivityTaskScheduled                            {ActivityId:5,                                                                                      
                                                       ActivityType:{Name:config-get-test-step},                                                           
                                                       TaskQueue:{Name:temporal-bench,                                                                     
                                                       Kind:Normal}, Header:{Fields:map{}},                                                                
                                                       Input:[{BuiltIn:pandemic                                                                            
                                                       ContinueAsNewCount:0                                                                                
                                                       CumulativeSignalCount:0                                                                             
                                                       CumulativeStepCount:0                                                                               
                                                       CumulativeTimeInSeconds:0 FileName:                                                                 
                                                       Pandemic:map[Depth:4 Fanout:3                                                                       
                                                       Type:cancel] RemainingDurationInSeconds:0                                                           
                                                       RemainingSignalCount:0                                                                              
                                                       RootConfigDrivenWorkflowID:pandemic-4-0-0                                                           
                                                       SignalCarryOverCount:0                                                                              
                                                       StatsWorkflowID:}],                                                                                 
                                                       ScheduleToCloseTimeoutSeconds:86400,                                                                
                                                       ScheduleToStartTimeoutSeconds:600,                                                                  
                                                       StartToCloseTimeoutSeconds:600,                                                                     
                                                       HeartbeatTimeoutSeconds:10,                                                                         
                                                       WorkflowTaskCompletedEventId:4,                                                                     
                                                       RetryPolicy:{InitialIntervalInSeconds:1,                                                            
                                                       BackoffCoefficient:1.2,                                                                             
                                                       MaximumIntervalInSeconds:0,                                                                         
                                                       MaximumAttempts:0,                                                                                  
                                                       NonRetryableErrorTypes:[len=0]}}                                                                    
   6  ActivityTaskStarted                              {ScheduledEventId:5,                                                                                
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       RequestId:173df282-6124-4966-9ff2-2c88432963fd,                                                     
                                                       Attempt:1}                                                                                          
   7  ActivityTaskCompleted                            {Result:[{ContinueAsNew:<nil>                                                                       
                                                       Describe:<nil>                                                                                      
                                                       InfiniteSequential:<nil>                                                                            
                                                       Local:<nil> Name:                                                                                   
                                                       Parallel:<nil>                                                                                      
                                                       Query:<nil> Remote:<nil>                                                                            
                                                       RepeatedParallel:<nil>                                                                              
                                                       RepeatedSequential:<nil>                                                                            
                                                       SendSignal:<nil>                                                                                    
                                                       SendStats:<nil>                                                                                     
                                                       Sequential:map[Name:root                                                                            
                                                       Steps:[map[ContinueAsNew ...                                                                        
                                                       StatsWorkflowID:]] Timer:<nil>                                                                      
                                                       WaitForSignal:<nil>]]                                                                               
                                                       RepeatedSequential:<nil>                                                                            
                                                       SendSignal:<nil>                                                                                    
                                                       SendStats:<nil>                                                                                     
                                                       Sequential:<nil>                                                                                    
                                                       StartAndWaitForChild:<nil>                                                                          
                                                       Timer:<nil>                                                                                         
                                                       WaitForSignal:<nil>]]]                                                                              
                                                       StartAndWaitForChild:<nil>                                                                          
                                                       Timer:<nil>                                                                                         
                                                       WaitForSignal:<nil>}],                                                                              
                                                       ScheduledEventId:5,                                                                                 
                                                       StartedEventId:6,                                                                                   
                                                       Identity:3332380@temporal-dev@}                                                                     
   8  WorkflowTaskScheduled                            {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                 
                                                       Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                             
   9  WorkflowTaskStarted                              {ScheduledEventId:8,                                                                                
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       RequestId:1c06023e-a0a6-4ec0-8b09-17ccf2797443}                                                     
  10  WorkflowTaskCompleted                            {ScheduledEventId:8, StartedEventId:9,                                                              
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                    
  11  MarkerRecorded                                   {MarkerName:SideEffect,                                                                             
                                                       Details:map{side-effect-id:<*common.Payloads                                                        
                                                       Value>, data:<*common.Payloads Value>},                                                             
                                                       WorkflowTaskCompletedEventId:10}                                                                    
  12  StartChildWorkflowExecutionInitiated             {Namespace:default,                                                                                 
                                                       WorkflowId:pandemic-4-0-0-height-3-child-959f876b-13ee-4db7-974b-9b4ce76125e6,                      
                                                       WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                         
                                                       Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                         
                                                       CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                             
                                                       FileName: Pandemic:map[Depth:3 Fanout:3 Type:cancel]                                                
                                                       RemainingDurationInSeconds:300000 RemainingSignalCount:0                                            
                                                       RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                    
                                                       StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                        
                                                       WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                   
                                                       ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                   
                                                       WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                      
                                                       BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                              
                                                       NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                             
  13  MarkerRecorded                                   {MarkerName:SideEffect,                                                                             
                                                       Details:map{data:<*common.Payloads                                                                  
                                                       Value>, side-effect-id:<*common.Payloads                                                            
                                                       Value>}, WorkflowTaskCompletedEventId:10}                                                           
  14  StartChildWorkflowExecutionInitiated             {Namespace:default,                                                                                 
                                                       WorkflowId:pandemic-4-0-0-height-3-child-0eb51032-3553-4016-a60b-2ad990c5ae46,                      
                                                       WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                         
                                                       Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                         
                                                       CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                             
                                                       FileName: Pandemic:map[Depth:3 Fanout:3 Type:cancel]                                                
                                                       RemainingDurationInSeconds:300000 RemainingSignalCount:0                                            
                                                       RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                    
                                                       StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                        
                                                       WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                   
                                                       ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                   
                                                       WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                      
                                                       BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                              
                                                       NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                             
  15  MarkerRecorded                                   {MarkerName:SideEffect,                                                                             
                                                       Details:map{data:<*common.Payloads                                                                  
                                                       Value>, side-effect-id:<*common.Payloads                                                            
                                                       Value>}, WorkflowTaskCompletedEventId:10}                                                           
  16  StartChildWorkflowExecutionInitiated             {Namespace:default,                                                                                 
                                                       WorkflowId:pandemic-4-0-0-height-3-child-5e7c381b-b443-4970-8a02-97d8dc9f1f35,                      
                                                       WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                         
                                                       Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                         
                                                       CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                             
                                                       FileName: Pandemic:map[Depth:3 Fanout:3 Type:cancel]                                                
                                                       RemainingDurationInSeconds:300000 RemainingSignalCount:0                                            
                                                       RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                    
                                                       StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                        
                                                       WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                   
                                                       ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                   
                                                       WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                      
                                                       BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                              
                                                       NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                             
  17  ChildWorkflowExecutionStarted                    {Namespace:default, InitiatedEventId:16,                                                            
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-5e7c381b-b443-4970-8a02-97d8dc9f1f35,   
                                                       RunId:b734752d-6ca8-41b7-9d57-730727427b42}, WorkflowType:{Name:config-driven-workflow},            
                                                       Header:{Fields:map{}}}                                                                              
  18  WorkflowTaskScheduled                            {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                 
                                                       Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                             
  19  ChildWorkflowExecutionStarted                    {Namespace:default, InitiatedEventId:12,                                                            
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-959f876b-13ee-4db7-974b-9b4ce76125e6,   
                                                       RunId:e35f3684-e160-4f16-af53-5839c92e135c}, WorkflowType:{Name:config-driven-workflow},            
                                                       Header:{Fields:map{}}}                                                                              
  20  ChildWorkflowExecutionStarted                    {Namespace:default, InitiatedEventId:14,                                                            
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-0eb51032-3553-4016-a60b-2ad990c5ae46,   
                                                       RunId:e2b336d7-4ad2-4d7e-9f89-033126c93d83}, WorkflowType:{Name:config-driven-workflow},            
                                                       Header:{Fields:map{}}}                                                                              
  21  WorkflowTaskStarted                              {ScheduledEventId:18,                                                                               
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       RequestId:f5b426f3-fcde-453b-b0c9-01dc156e81b1}                                                     
  22  WorkflowTaskCompleted                            {ScheduledEventId:18, StartedEventId:21,                                                            
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                    
  23  WorkflowExecutionCancelRequested                 {ExternalInitiatedEventId:0,                                                                        
                                                       Identity:3332380@temporal-dev@}                                                                     
  24  WorkflowTaskScheduled                            {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                 
                                                       Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                             
  25  WorkflowTaskStarted                              {ScheduledEventId:24,                                                                               
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       RequestId:request-from-RespondWorkflowTaskCompleted}                                                
  26  WorkflowTaskCompleted                            {ScheduledEventId:24, StartedEventId:25,                                                            
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                    
  27  RequestCancelExternalWorkflowExecutionInitiated  {WorkflowTaskCompletedEventId:26, Namespace:default,                                                
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-959f876b-13ee-4db7-974b-9b4ce76125e6},  
                                                       ChildWorkflowOnly:true}                                                                             
  28  RequestCancelExternalWorkflowExecutionInitiated  {WorkflowTaskCompletedEventId:26, Namespace:default,                                                
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-0eb51032-3553-4016-a60b-2ad990c5ae46},  
                                                       ChildWorkflowOnly:true}                                                                             
  29  RequestCancelExternalWorkflowExecutionInitiated  {WorkflowTaskCompletedEventId:26, Namespace:default,                                                
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-5e7c381b-b443-4970-8a02-97d8dc9f1f35},  
                                                       ChildWorkflowOnly:true}                                                                             
  30  ExternalWorkflowExecutionCancelRequested         {InitiatedEventId:29, Namespace:default,                                                            
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-5e7c381b-b443-4970-8a02-97d8dc9f1f35}}  
  31  WorkflowTaskScheduled                            {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                 
                                                       Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                             
  32  ExternalWorkflowExecutionCancelRequested         {InitiatedEventId:27, Namespace:default,                                                            
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-959f876b-13ee-4db7-974b-9b4ce76125e6}}  
  33  ExternalWorkflowExecutionCancelRequested         {InitiatedEventId:28, Namespace:default,                                                            
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-0eb51032-3553-4016-a60b-2ad990c5ae46}}  
  34  WorkflowTaskStarted                              {ScheduledEventId:31,                                                                               
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       RequestId:67bcae6e-95e0-4179-a4da-70555113b225}                                                     
  35  WorkflowTaskCompleted                            {ScheduledEventId:31, StartedEventId:34,                                                            
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                    
  36  ChildWorkflowExecutionCanceled                   {Details:[], Namespace:default,                                                                     
                                                       WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-0eb51032-3553-4016-a60b-2ad990c5ae46,   
                                                       RunId:e2b336d7-4ad2-4d7e-9f89-033126c93d83}, WorkflowType:{Name:config-driven-workflow},            
                                                       InitiatedEventId:14, StartedEventId:20}                                                             
  37  WorkflowTaskScheduled                            {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                 
                                                       Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                             
  38  WorkflowTaskStarted                              {ScheduledEventId:37,                                                                               
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       RequestId:6cd1d5c0-2de3-4cf7-9ef0-ce5ce95d8752}                                                     
  39  WorkflowTaskCompleted                            {ScheduledEventId:37, StartedEventId:38,                                                            
                                                       Identity:3332380@temporal-dev@,                                                                     
                                                       BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}  


For the child workflow, the workflow cancellation request is received between initiation, but before the child workflow is actually started:
./tctl wf show -w pandemic-4-0-0-height-3-child-5e7c381b-b443-4970-8a02-97d8dc9f1f35
2020/07/27 15:03:59 INFO  No logger configured for temporal client. Created default one.
   1  WorkflowExecutionStarted              {WorkflowType:{Name:config-driven-workflow},                                                       
                                            ParentWorkflowNamespace:default,                                                                   
                                            ParentWorkflowExecution:{WorkflowId:pandemic-4-0-0,                                                
                                            RunId:b2e46378-1686-43bb-9d45-1aa70c5f8352},                                                       
                                            ParentInitiatedEventId:16, TaskQueue:{Name:temporal-bench,                                         
                                            Kind:Normal}, Input:[{BuiltIn:pandemic                                                             
                                            ContinueAsNewCount:0 CumulativeSignalCount:0                                                       
                                            CumulativeStepCount:0 CumulativeTimeInSeconds:0                                                    
                                            FileName: Pandemic:map[Depth:3 Fanout:3 Type:cancel]                                               
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0                                           
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0                                                          
                                            SignalCarryOverCount:0 StatsWorkflowID:}],                                                         
                                            WorkflowExecutionTimeoutSeconds:3000000,                                                           
                                            WorkflowRunTimeoutSeconds:3000000,                                                                 
                                            WorkflowTaskTimeoutSeconds:10,                                                                     
                                            Initiator:Workflow, LastCompletionResult:[],                                                       
                                            OriginalExecutionRunId:b734752d-6ca8-41b7-9d57-730727427b42,                                       
                                            FirstExecutionRunId:b734752d-6ca8-41b7-9d57-730727427b42,                                          
                                            RetryPolicy:{InitialIntervalInSeconds:1,                                                           
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0,                                                
                                            MaximumAttempts:0, NonRetryableErrorTypes:[len=0]},                                                
                                            Attempt:1, WorkflowExecutionExpirationTimestamp:0,                                                 
                                            FirstWorkflowTaskBackoffSeconds:0, Header:{Fields:map{}}}                                          
   2  WorkflowTaskScheduled                 {TaskQueue:{Name:temporal-bench,                                                                   
                                            Kind:Normal},                                                                                      
                                            StartToCloseTimeoutSeconds:10,                                                                     
                                            Attempt:1}                                                                                         
   3  WorkflowTaskStarted                   {ScheduledEventId:2,                                                                               
                                            Identity:3332380@temporal-dev@,                                                                    
                                            RequestId:36094483-81c5-427a-a482-33454ba18d0b}                                                    
   4  WorkflowTaskCompleted                 {ScheduledEventId:2, StartedEventId:3,                                                             
                                            Identity:3332380@temporal-dev@,                                                                    
                                            BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                   
   5  ActivityTaskScheduled                 {ActivityId:5,                                                                                     
                                            ActivityType:{Name:config-get-test-step},                                                          
                                            TaskQueue:{Name:temporal-bench,                                                                    
                                            Kind:Normal}, Header:{Fields:map{}},                                                               
                                            Input:[{BuiltIn:pandemic                                                                           
                                            ContinueAsNewCount:0                                                                               
                                            CumulativeSignalCount:0                                                                            
                                            CumulativeStepCount:0                                                                              
                                            CumulativeTimeInSeconds:0                                                                          
                                            FileName: Pandemic:map[Depth:3                                                                     
                                            Fanout:3 Type:cancel]                                                                              
                                            RemainingDurationInSeconds:300000                                                                  
                                            RemainingSignalCount:0                                                                             
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0                                                          
                                            SignalCarryOverCount:0                                                                             
                                            StatsWorkflowID:}],                                                                                
                                            ScheduleToCloseTimeoutSeconds:3000000,                                                             
                                            ScheduleToStartTimeoutSeconds:600,                                                                 
                                            StartToCloseTimeoutSeconds:600,                                                                    
                                            HeartbeatTimeoutSeconds:10,                                                                        
                                            WorkflowTaskCompletedEventId:4,                                                                    
                                            RetryPolicy:{InitialIntervalInSeconds:1,                                                           
                                            BackoffCoefficient:1.2,                                                                            
                                            MaximumIntervalInSeconds:0,                                                                        
                                            MaximumAttempts:0,                                                                                 
                                            NonRetryableErrorTypes:[len=0]}}                                                                   
   6  ActivityTaskStarted                   {ScheduledEventId:5,                                                                               
                                            Identity:3332380@temporal-dev@,                                                                    
                                            RequestId:3aacea43-448e-4fb5-9b63-1fb2c1666400,                                                    
                                            Attempt:1}                                                                                         
   7  ActivityTaskCompleted                 {Result:[{ContinueAsNew:<nil>                                                                      
                                            Describe:<nil>                                                                                     
                                            InfiniteSequential:<nil>                                                                           
                                            Local:<nil> Name:                                                                                  
                                            Parallel:<nil>                                                                                     
                                            Query:<nil> Remote:<nil>                                                                           
                                            RepeatedParallel:<nil>                                                                             
                                            RepeatedSequential:<nil>                                                                           
                                            SendSignal:<nil>                                                                                   
                                            SendStats:<nil>                                                                                    
                                            Sequential:map[Name:root                                                                           
                                            Steps:[map[ContinueAsNew ...                                                                       
                                            StatsWorkflowID:]] Timer:<nil>                                                                     
                                            WaitForSignal:<nil>]]                                                                              
                                            RepeatedSequential:<nil>                                                                           
                                            SendSignal:<nil>                                                                                   
                                            SendStats:<nil>                                                                                    
                                            Sequential:<nil>                                                                                   
                                            StartAndWaitForChild:<nil>                                                                         
                                            Timer:<nil>                                                                                        
                                            WaitForSignal:<nil>]]]                                                                             
                                            StartAndWaitForChild:<nil>                                                                         
                                            Timer:<nil>                                                                                        
                                            WaitForSignal:<nil>}],                                                                             
                                            ScheduledEventId:5,                                                                                
                                            StartedEventId:6,                                                                                  
                                            Identity:3332380@temporal-dev@}                                                                    
   8  WorkflowTaskScheduled                 {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                
                                            Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                            
   9  WorkflowTaskStarted                   {ScheduledEventId:8,                                                                               
                                            Identity:3332380@temporal-dev@,                                                                    
                                            RequestId:3c961c3f-d61b-44a8-897a-5674d75aea6a}                                                    
  10  WorkflowTaskCompleted                 {ScheduledEventId:8, StartedEventId:9,                                                             
                                            Identity:3332380@temporal-dev@,                                                                    
                                            BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                   
  11  MarkerRecorded                        {MarkerName:SideEffect,                                                                            
                                            Details:map{side-effect-id:<*common.Payloads                                                       
                                            Value>, data:<*common.Payloads Value>},                                                            
                                            WorkflowTaskCompletedEventId:10}                                                                   
  12  StartChildWorkflowExecutionInitiated  {Namespace:default,                                                                                
                                            WorkflowId:pandemic-4-0-0-height-2-child-0ec6edc0-aa02-44f9-826b-fb14775a9c3c,                     
                                            WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                        
                                            Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                        
                                            CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                            
                                            FileName: Pandemic:map[Depth:2 Fanout:3 Type:cancel]                                               
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0                                           
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                   
                                            StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                       
                                            WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                  
                                            ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                  
                                            WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                     
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                             
                                            NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                            
  13  MarkerRecorded                        {MarkerName:SideEffect,                                                                            
                                            Details:map{side-effect-id:<*common.Payloads                                                       
                                            Value>, data:<*common.Payloads Value>},                                                            
                                            WorkflowTaskCompletedEventId:10}                                                                   
  14  StartChildWorkflowExecutionInitiated  {Namespace:default,                                                                                
                                            WorkflowId:pandemic-4-0-0-height-2-child-8cbfaecb-4586-4a7b-8791-8785eebae15e,                     
                                            WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                        
                                            Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                        
                                            CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                            
                                            FileName: Pandemic:map[Depth:2 Fanout:3 Type:cancel]                                               
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0                                           
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                   
                                            StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                       
                                            WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                  
                                            ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                  
                                            WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                     
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                             
                                            NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                            
  15  MarkerRecorded                        {MarkerName:SideEffect,                                                                            
                                            Details:map{side-effect-id:<*common.Payloads                                                       
                                            Value>, data:<*common.Payloads Value>},                                                            
                                            WorkflowTaskCompletedEventId:10}                                                                   
  16  StartChildWorkflowExecutionInitiated  {Namespace:default,                                                                                
                                            WorkflowId:pandemic-4-0-0-height-2-child-9909a823-d337-45bd-8434-103c9487f812,                     
                                            WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                        
                                            Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                        
                                            CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                            
                                            FileName: Pandemic:map[Depth:2 Fanout:3 Type:cancel]                                               
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0                                           
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                   
                                            StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                       
                                            WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                  
                                            ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                  
                                            WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                     
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                             
                                            NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                            
  17  WorkflowExecutionCancelRequested      {ExternalInitiatedEventId:29,                                                                      
                                            ExternalWorkflowExecution:{WorkflowId:pandemic-4-0-0,                                              
                                            RunId:b2e46378-1686-43bb-9d45-1aa70c5f8352},                                                       
                                            Identity:history-service}                                                                          
  18  WorkflowTaskScheduled                 {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                
                                            Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                            
  19  ChildWorkflowExecutionStarted         {Namespace:default, InitiatedEventId:12,                                                           
                                            WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-2-child-0ec6edc0-aa02-44f9-826b-fb14775a9c3c,  
                                            RunId:2bc01675-5845-4e80-bdf6-89fb231694a6}, WorkflowType:{Name:config-driven-workflow},           
                                            Header:{Fields:map{}}}                                                                             
  20  ChildWorkflowExecutionStarted         {Namespace:default, InitiatedEventId:14,                                                           
                                            WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-2-child-8cbfaecb-4586-4a7b-8791-8785eebae15e,  
                                            RunId:761d2d85-b3c5-45cd-8aea-a30fcac46803}, WorkflowType:{Name:config-driven-workflow},           
                                            Header:{Fields:map{}}}                                                                             
  21  ChildWorkflowExecutionStarted         {Namespace:default, InitiatedEventId:16,                                                           
                                            WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-2-child-9909a823-d337-45bd-8434-103c9487f812,  
                                            RunId:7a635e77-ee0d-4b57-9461-973aded49629}, WorkflowType:{Name:config-driven-workflow},           
                                            Header:{Fields:map{}}}                                                                             
  22  WorkflowTaskStarted                   {ScheduledEventId:18,                                                                              
                                            Identity:3332380@temporal-dev@,                                                                    
                                            RequestId:619131fb-f4b2-473e-80ec-677a08116c52}                                                    
  23  WorkflowTaskCompleted                 {ScheduledEventId:18, StartedEventId:22,                                                           
                                            Identity:3332380@temporal-dev@,                                                                    
                                            BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482} 

And then THAT child's workflow doesn't even get a cancellation event in the first place:

2020/07/27 15:04:57 INFO  No logger configured for temporal client. Created default one.
   1  WorkflowExecutionStarted              {WorkflowType:{Name:config-driven-workflow}, ParentWorkflowNamespace:default,                            
                                            ParentWorkflowExecution:{WorkflowId:pandemic-4-0-0-height-3-child-5e7c381b-b443-4970-8a02-97d8dc9f1f35,  
                                            RunId:b734752d-6ca8-41b7-9d57-730727427b42}, ParentInitiatedEventId:12, TaskQueue:{Name:temporal-bench,  
                                            Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0 CumulativeSignalCount:0                      
                                            CumulativeStepCount:0 CumulativeTimeInSeconds:0 FileName: Pandemic:map[Depth:2 Fanout:3 Type:cancel]     
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0 RootConfigDrivenWorkflowID:pandemic-4-0-0       
                                            SignalCarryOverCount:0 StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                      
                                            WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10, Initiator:Workflow,                    
                                            LastCompletionResult:[], OriginalExecutionRunId:2bc01675-5845-4e80-bdf6-89fb231694a6,                    
                                            FirstExecutionRunId:2bc01675-5845-4e80-bdf6-89fb231694a6, RetryPolicy:{InitialIntervalInSeconds:1,       
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0, NonRetryableErrorTypes:[len=0]},  
                                            Attempt:1, WorkflowExecutionExpirationTimestamp:0, FirstWorkflowTaskBackoffSeconds:0,                    
                                            Header:{Fields:map{}}}                                                                                   
   2  WorkflowTaskScheduled                 {TaskQueue:{Name:temporal-bench,                                                                         
                                            Kind:Normal},                                                                                            
                                            StartToCloseTimeoutSeconds:10,                                                                           
                                            Attempt:1}                                                                                               
   3  WorkflowTaskStarted                   {ScheduledEventId:2,                                                                                     
                                            Identity:3332380@temporal-dev@,                                                                          
                                            RequestId:ae36e3f3-9c2f-4325-ab79-edf16a22ef42}                                                          
   4  WorkflowTaskCompleted                 {ScheduledEventId:2, StartedEventId:3,                                                                   
                                            Identity:3332380@temporal-dev@,                                                                          
                                            BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                         
   5  ActivityTaskScheduled                 {ActivityId:5,                                                                                           
                                            ActivityType:{Name:config-get-test-step},                                                                
                                            TaskQueue:{Name:temporal-bench,                                                                          
                                            Kind:Normal}, Header:{Fields:map{}},                                                                     
                                            Input:[{BuiltIn:pandemic                                                                                 
                                            ContinueAsNewCount:0                                                                                     
                                            CumulativeSignalCount:0                                                                                  
                                            CumulativeStepCount:0                                                                                    
                                            CumulativeTimeInSeconds:0                                                                                
                                            FileName: Pandemic:map[Depth:2                                                                           
                                            Fanout:3 Type:cancel]                                                                                    
                                            RemainingDurationInSeconds:300000                                                                        
                                            RemainingSignalCount:0                                                                                   
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0                                                                
                                            SignalCarryOverCount:0                                                                                   
                                            StatsWorkflowID:}],                                                                                      
                                            ScheduleToCloseTimeoutSeconds:3000000,                                                                   
                                            ScheduleToStartTimeoutSeconds:600,                                                                       
                                            StartToCloseTimeoutSeconds:600,                                                                          
                                            HeartbeatTimeoutSeconds:10,                                                                              
                                            WorkflowTaskCompletedEventId:4,                                                                          
                                            RetryPolicy:{InitialIntervalInSeconds:1,                                                                 
                                            BackoffCoefficient:1.2,                                                                                  
                                            MaximumIntervalInSeconds:0,                                                                              
                                            MaximumAttempts:0,                                                                                       
                                            NonRetryableErrorTypes:[len=0]}}                                                                         
   6  ActivityTaskStarted                   {ScheduledEventId:5,                                                                                     
                                            Identity:3332380@temporal-dev@,                                                                          
                                            RequestId:28e65db2-a184-4606-b128-4d3f2e712805,                                                          
                                            Attempt:1}                                                                                               
   7  ActivityTaskCompleted                 {Result:[{ContinueAsNew:<nil>                                                                            
                                            Describe:<nil>                                                                                           
                                            InfiniteSequential:<nil>                                                                                 
                                            Local:<nil> Name:                                                                                        
                                            Parallel:<nil>                                                                                           
                                            Query:<nil> Remote:<nil>                                                                                 
                                            RepeatedParallel:<nil>                                                                                   
                                            RepeatedSequential:<nil>                                                                                 
                                            SendSignal:<nil>                                                                                         
                                            SendStats:<nil>                                                                                          
                                            Sequential:map[Name:root                                                                                 
                                            Steps:[map[ContinueAsNew ...                                                                             
                                            StatsWorkflowID:]] Timer:<nil>                                                                           
                                            WaitForSignal:<nil>]]                                                                                    
                                            RepeatedSequential:<nil>                                                                                 
                                            SendSignal:<nil>                                                                                         
                                            SendStats:<nil>                                                                                          
                                            Sequential:<nil>                                                                                         
                                            StartAndWaitForChild:<nil>                                                                               
                                            Timer:<nil>                                                                                              
                                            WaitForSignal:<nil>]]]                                                                                   
                                            StartAndWaitForChild:<nil>                                                                               
                                            Timer:<nil>                                                                                              
                                            WaitForSignal:<nil>}],                                                                                   
                                            ScheduledEventId:5,                                                                                      
                                            StartedEventId:6,                                                                                        
                                            Identity:3332380@temporal-dev@}                                                                          
   8  WorkflowTaskScheduled                 {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                      
                                            Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                                  
   9  WorkflowTaskStarted                   {ScheduledEventId:8,                                                                                     
                                            Identity:3332380@temporal-dev@,                                                                          
                                            RequestId:55863fc7-57a1-4e1a-ac91-3413c9b9a6b0}                                                          
  10  WorkflowTaskCompleted                 {ScheduledEventId:8, StartedEventId:9,                                                                   
                                            Identity:3332380@temporal-dev@,                                                                          
                                            BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}                                                         
  11  MarkerRecorded                        {MarkerName:SideEffect,                                                                                  
                                            Details:map{data:<*common.Payloads                                                                       
                                            Value>, side-effect-id:<*common.Payloads                                                                 
                                            Value>}, WorkflowTaskCompletedEventId:10}                                                                
  12  StartChildWorkflowExecutionInitiated  {Namespace:default,                                                                                      
                                            WorkflowId:pandemic-4-0-0-height-1-child-45b57b4e-acda-4482-a6ce-8043ac2eaeb3,                           
                                            WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                              
                                            Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                              
                                            CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                                  
                                            FileName: Pandemic:map[Depth:1 Fanout:3 Type:cancel]                                                     
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0                                                 
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                         
                                            StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                             
                                            WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                        
                                            ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                        
                                            WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                           
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                                   
                                            NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                                  
  13  MarkerRecorded                        {MarkerName:SideEffect,                                                                                  
                                            Details:map{side-effect-id:<*common.Payloads                                                             
                                            Value>, data:<*common.Payloads Value>},                                                                  
                                            WorkflowTaskCompletedEventId:10}                                                                         
  14  StartChildWorkflowExecutionInitiated  {Namespace:default,                                                                                      
                                            WorkflowId:pandemic-4-0-0-height-1-child-e0466857-7523-4fa4-b201-d8460f783b07,                           
                                            WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                              
                                            Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                              
                                            CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                                  
                                            FileName: Pandemic:map[Depth:1 Fanout:3 Type:cancel]                                                     
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0                                                 
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                         
                                            StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                             
                                            WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                        
                                            ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                        
                                            WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                           
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                                   
                                            NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                                  
  15  MarkerRecorded                        {MarkerName:SideEffect,                                                                                  
                                            Details:map{side-effect-id:<*common.Payloads                                                             
                                            Value>, data:<*common.Payloads Value>},                                                                  
                                            WorkflowTaskCompletedEventId:10}                                                                         
  16  StartChildWorkflowExecutionInitiated  {Namespace:default,                                                                                      
                                            WorkflowId:pandemic-4-0-0-height-1-child-3f00898f-1088-47c4-884d-fd83a0ede9e9,                           
                                            WorkflowType:{Name:config-driven-workflow}, TaskQueue:{Name:temporal-bench,                              
                                            Kind:Normal}, Input:[{BuiltIn:pandemic ContinueAsNewCount:0                                              
                                            CumulativeSignalCount:0 CumulativeStepCount:0 CumulativeTimeInSeconds:0                                  
                                            FileName: Pandemic:map[Depth:1 Fanout:3 Type:cancel]                                                     
                                            RemainingDurationInSeconds:300000 RemainingSignalCount:0                                                 
                                            RootConfigDrivenWorkflowID:pandemic-4-0-0 SignalCarryOverCount:0                                         
                                            StatsWorkflowID:}], WorkflowExecutionTimeoutSeconds:3000000,                                             
                                            WorkflowRunTimeoutSeconds:3000000, WorkflowTaskTimeoutSeconds:10,                                        
                                            ParentClosePolicy:RequestCancel, WorkflowTaskCompletedEventId:10,                                        
                                            WorkflowIdReusePolicy:AllowDuplicate, RetryPolicy:{InitialIntervalInSeconds:1,                           
                                            BackoffCoefficient:1.2, MaximumIntervalInSeconds:0, MaximumAttempts:0,                                   
                                            NonRetryableErrorTypes:[len=0]}, Header:{Fields:map{}}}                                                  
  17  ChildWorkflowExecutionStarted         {Namespace:default, InitiatedEventId:12,                                                                 
                                            WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-1-child-45b57b4e-acda-4482-a6ce-8043ac2eaeb3,        
                                            RunId:b88c5c96-7b33-4b4b-a287-ce9714d6795d}, WorkflowType:{Name:config-driven-workflow},                 
                                            Header:{Fields:map{}}}                                                                                   
  18  WorkflowTaskScheduled                 {TaskQueue:{Name:temporal-dev:f06b2a91-64b8-4d1a-94df-30fc18040672,                                      
                                            Kind:Sticky}, StartToCloseTimeoutSeconds:10, Attempt:1}                                                  
  19  ChildWorkflowExecutionStarted         {Namespace:default, InitiatedEventId:14,                                                                 
                                            WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-1-child-e0466857-7523-4fa4-b201-d8460f783b07,        
                                            RunId:4ed0a6f3-cd76-40fe-b8bc-8b77421e4a00}, WorkflowType:{Name:config-driven-workflow},                 
                                            Header:{Fields:map{}}}                                                                                   
  20  ChildWorkflowExecutionStarted         {Namespace:default, InitiatedEventId:16,                                                                 
                                            WorkflowExecution:{WorkflowId:pandemic-4-0-0-height-1-child-3f00898f-1088-47c4-884d-fd83a0ede9e9,        
                                            RunId:7eb4b500-2823-4563-8e5d-15f7f7afc356}, WorkflowType:{Name:config-driven-workflow},                 
                                            Header:{Fields:map{}}}                                                                                   
  21  WorkflowTaskStarted                   {ScheduledEventId:18,                                                                                    
                                            Identity:3332380@temporal-dev@,                                                                          
                                            RequestId:427c01cd-60fb-4bc5-9b63-bc85442881d1}                                                          
  22  WorkflowTaskCompleted                 {ScheduledEventId:18, StartedEventId:21,                                                                 
                                            Identity:3332380@temporal-dev@,                                                                          
                                            BinaryChecksum:a1b7abd6fd40fe7926a215c0f7f57482}    

MutableState indicates the grandchild never got the cancel event, but the parent and grandparent did.


---

<a id="198"></a>

### #198: Add support for doing backward incompatible changes to workflow and activity function signatures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/198 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-07-16 18:16:45.000 UTC (5y 5m ago) |
| **Updated** | 2020-07-16 18:16:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
There is no way to change workflow or activity function signature in a nonbackward compatible way.

**Describe the solution you'd like**
A way to support backward-incompatible changes that support callers that use the old signature.

**Describe alternatives you've considered**
Do not provide such capability or force use of input and output structures for activities and workflows.

**Additional context**
https://community.temporal.io/t/migrating-a-workflow-activity-argument-to-a-propagated-context-field/202



---

<a id="191"></a>

### #191: Add ability to register a single generic workflow and activity implementation for multiple types

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/191 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-07-13 23:39:23.000 UTC (5y 6m ago) |
| **Updated** | 2025-08-25 15:15:26.000 UTC |
| **Closed** | 2025-08-25 15:15:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Temporal SDK is used as a base for various frameworks. Some of those frameworks have need to dynamically load and unload workflow and activity implementations without stopping a Go worker. [Proposed PHP SDK](https://github.com/temporalio/proposals/blob/master/php/php-rr-sdk.md) which will be built on top of Go worker is one of such frameworks.

**Describe the solution you'd like**
A generic workflow implementation handler that receives the workflow type (or activity type) as an argument.

**Describe alternatives you've considered**
Another option is to provide registration API that can be called after worker has started. The drawback of this approach that it is not going to work with dynamic code loading. For example, a workflow task with an unknown workflow type can automatically look up a new implementation in a remote implementation artifact storage by its name.





---

<a id="186"></a>

### #186: Worker reports validation error on processing of transient decision

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/186 |
| **State** | OPEN |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-07-10 07:17:48.000 UTC (5y 6m ago) |
| **Updated** | 2025-02-04 18:48:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, potential-bug |
| **Assignees** | Sushisource |
| **Milestone** | Code Complete |

#### Description

## Expected Behavior
No error during processing of transient decision

## Actual Behavior
If transient decision is scheduled after decision failed then go-sdk reports following error during processing:

```
"error": "history_events: premature end of stream, expectedLastEventID=55 but no more events after eventID=53"
```

## Steps to Reproduce the Problem
History of workflow execution resulting in this error:
https://pastebin.com/raw/zjZUNhyV

## Specifications
* Version: 
* Platform:




---

<a id="125"></a>

### #125: Remove need to register mocked activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/125 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-10 18:50:14.000 UTC (5y 8m ago) |
| **Updated** | 2020-05-10 18:50:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

From Slack:

> I find it quite odd/hard to use in cadence that I have to register an activity before mocking it with On Activity. Right now I register a dummy activity in SetupSuite:
```
func (s *KubernetesWorkflowTestSuite) SetupSuite() {
	activity.RegisterWithOptions(
		func(ctx context.Context, input coreV1NodesListActivityInput) (*coreV1NodesListActivityOutput, error) {
			return nil, nil
		},
		activity.RegisterOptions{Name: coreV1NodesListActivityName},
	)
}
```
> Is this going to change in temporal?


---

<a id="120"></a>

### #120: Activity error is lost when ScheduleToCloseTimeout is expired during retries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/120 |
| **State** | CLOSED |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-05-04 19:03:11.000 UTC (5y 8m ago) |
| **Updated** | 2020-06-05 18:42:00.000 UTC |
| **Closed** | 2020-06-05 18:42:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | mfateev |
| **Milestone** | None |

#### Description

If activity returns permanent error and Temporal retries the activity, exit condition is the following:
1. `MaxAttempts` is exceeded, or
2. `ScheduleToCloseTimeout` is expired.

Currently only 1st case will return actual activity error but 2nd will return `TimeoutType: ScheduleToClose` error w/o information about original error. Integration test `TestActivityRetryOnTimeoutStableError` is supposed to test this but it currently(#119) tests the 1st case (`MaxAttempts`).


---

<a id="108"></a>

### #108: Fix race condition in testWorkflowEnvironmentImpl

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/108 |
| **State** | OPEN |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-04-24 17:56:26.000 UTC (5y 8m ago) |
| **Updated** | 2024-12-17 21:17:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently it bypassed by workaround: https://github.com/temporalio/temporal-go-sdk/blob/master/internal/internal_workflow_testsuite_test.go#L1751 but it must be properly fixed.


---

<a id="91"></a>

### #91: Build of the freshly checked out repo fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/91 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-09 03:26:57.000 UTC (5y 9m ago) |
| **Updated** | 2020-04-09 05:30:39.000 UTC |
| **Closed** | 2020-04-09 05:30:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

```
temporal$ git clone git@github.com:mfateev/temporal-go-sdk.git
Cloning into 'temporal-go-sdk'...
remote: Enumerating objects: 345, done.
remote: Counting objects: 100% (345/345), done.
remote: Compressing objects: 100% (236/236), done.
remote: Total 7851 (delta 197), reused 179 (delta 96), pack-reused 7506
Receiving objects: 100% (7851/7851), 6.06 MiB | 4.18 MiB/s, done.
Resolving deltas: 100% (5534/5534), done.
temporal$ cd temporal-go-sdk/
temporal-go-sdk[master]$ make
GO111MODULE=off go get -u golang.org/x/lint/golint
GO111MODULE=off go get -u github.com/kisielk/errcheck
errcheck ./...
internal/cmd/tools/copyright/licensegen.go:141:9:	f.Close()
make: *** [errcheck] Error 1
temporal-go-sdk[master]$
```


---

<a id="77"></a>

### #77: Remove WorkerOptions.Disable[Activity|Workflow]Worker option

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/77 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-03-26 02:24:05.000 UTC (5y 9m ago) |
| **Updated** | 2020-07-23 17:40:25.000 UTC |
| **Closed** | 2020-07-23 17:40:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | alexshtin |
| **Milestone** | Code Complete |

#### Description

It was needed due to global registration. Now as both activities and workflows are registered with the worker this option is excessive.


---

<a id="60"></a>

### #60: Migrate service_wrapper_test to interceptor_test

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/60 |
| **State** | CLOSED |
| **Author** | alexshtin (Alex Shtin) |
| **Created** | 2020-03-13 19:38:41.000 UTC (5y 10m ago) |
| **Updated** | 2020-07-14 00:34:01.000 UTC |
| **Closed** | 2020-07-14 00:34:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`service_wrapper` was replaced with gRPC interceptor (#58) and tests needs to be migrated too.


---

<a id="29"></a>

### #29: Fix context propagation in testsuite

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-go/issues/29 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-01-13 17:51:08.000 UTC (5y 12m ago) |
| **Updated** | 2020-11-24 02:01:17.000 UTC |
| **Closed** | 2020-11-24 02:01:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | alexshtin |
| **Milestone** | None |

#### Description

Currently the headers have to be injected directly into the `WorkflowTestSuite` through `WorkflowTestSuite#SetHeader`.

I propose to add `TestWorkflowEnvironment.setContext(...)` method which reads header from the context using configured `ContextPropagators`.

It also looks like the context propagation to child workflows might be broken in testsuite.


