{"assignees":[],"author":{"id":"MDQ6VXNlcjk1NTk2NTU=","is_bot":false,"login":"gregbrowndev","name":"Greg Brown"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\n\r\nHi, \r\n\r\nThis may admittedly be more of a question than a feature request as there might already be a simple solution I missed. But nonetheless, this may be a topic worth documenting for users new to async/temporal.\r\n\r\nI'm looking for a way to pass request/job-specific dependencies into the activity functions, such as the DB session. One idea described below uses a factory to create the worker, like you'd see in some other frameworks. The problem is creating a closure around the activities makes it impossible to import those activities into the workflows throwing away type-safety.\r\n\r\n### Describe the solution you'd like\r\n\r\n<!-- A clear and concise description of what you want to happen. SCREENSHOTS OR CODE SAMPLES ARE VERY HELPFUL -->\r\n\r\nHere's an example of how I initially tried to solve the issue:\r\n\r\n```py\r\n# main.py\r\ndef create_worker() -> Worker:\r\n    my_app: MyApp = bootstrap()\r\n\r\n    @activity.defn\r\n    async def task1(user_id: uuid.UUID) -> str:\r\n        return my_app.task1(\r\n            user_id=user_id\r\n        )\r\n\r\n    @activity.defn\r\n    async def task2(user_id: uuid.UUID) -> str:\r\n        return my_app.task2(\r\n            user_id=user_id\r\n        )\r\n\r\n    @activity.defn\r\n    async def task3(user_id: uuid.UUID) -> str:\r\n        return my_app.task3(\r\n            user_id=user_id\r\n        )\r\n    \r\n    client = await Client.connect(\"http://localhost:7233\")\r\n    return Worker(\r\n        client,\r\n        task_queue=\"my-task-queue\",\r\n        workflows=[MyWorkflow],\r\n        activities=[\r\n            task1,\r\n            task2,\r\n            task3,\r\n        ],\r\n    )\r\n\r\n\r\nasync def main():\r\n    worker = create_worker()\r\n    await worker.run()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n``` \r\n\r\nThis is similar to how you might write a Flask API's `create_app` factory. Another framework, FastAPI, supports async and has full DI around its route handlers.\r\n\r\nI don't have a great deal of experience building async apps in Python, so it isn't completely clear to me whether the above solution would even be safe. The `MyApp` object returned by `bootstrap` handles transaction management and all the business logic (follows a Hexagonal approach), so it definitely shouldn't be used for more than one activity at a time. \r\n\r\nI'm going to feel silly now after writing all of this if the simplest solution is just to call `bootstrap` within the activity like below:\r\n\r\n```py\r\n@activity.defn\r\nasync def task1(user_id: uuid.UUID) -> str:\r\n    my_app = bootstrap()\r\n    return my_app.task1(\r\n        user_id=user_id\r\n    )\r\n```\r\n\r\nI've always thought this would be bad to repeatedly throw away the internal DB session and various HTTP/SDK clients after each \"request\". But I guess that only works in sync frameworks because it processes one request at a time.\r\n\r\n### Additional context\r\n\r\n<!-- Add any other context or screenshots about the feature request here. -->\r\n\r\nI think I may have just rubber-ducked the problem to myself, but it would be good to see some guidance on the best practice here.\r\n\r\nThanks! \r\n","closedAt":"2022-07-14T14:56:35Z","comments":[{"id":"IC_kwDOGusT1c5GUS9V","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"Actually, some form of DI probably would be quite useful, as I now have a circular dependency:\r\n\r\n```mermaid\r\n  graph TD;\r\n      activities.py-->bootstrap.py;\r\n      bootstrap.py-->adapter.py;\r\n      adapter.py-->workflow.py;\r\n      workflow.py-->activities.py;\r\n```\r\n\r\nHopefully, it's clear enough knowing I'm building a hexagonal-style app without seeing all the source code, but I'll try to explain:\r\n\r\n* `activities.py` contains the Temporal activity definitions\r\n* `bootstrap.py` is a composition root, it builds all the dependencies of `MyApp`, i.e. each outbound adapter and their dependencies and returns an instance of `MyApp`\r\n* `adapter.py` is an outbound adapter that exposes workflow functions to `MyApp`, e.g. APIs to start the workflow, run signals and queries without the app depending directly on the Temporal workflow\r\n* `workflow.py` contains the Temporal workflow definition\r\n\r\nFor now, I think the only way to break the circular dependency is to use the string form of `execute_activity`.","createdAt":"2022-07-10T13:06:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/68#issuecomment-1179725653","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5GUias","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"Also, it is interesting to find and read the discussion about [workflow/activity contracts](https://github.com/temporalio/proposals/blob/master/python/phase-2.md#workflow-contracts). For me at least it wouldn't be a problem if the contract didn't include the signal/query decorators, since that is how I plan to expose those functions on the adapter interface to my app anyway:\r\n\r\n```py\r\nclass IPriceChangeWorkflowAdapter(t.Protocol):\r\n    async def run(self, price_change: PriceChange) -> None:\r\n        ...\r\n\r\n    async def query_some_state(self, price_change: PriceChange) -> Foo:\r\n        ...\r\n    \r\n    async def send_some_signal(self, price_change: PriceChange) -> None:\r\n        ...\r\n```\r\n\r\nand the concrete impl would look like:\r\n\r\n```py\r\nclass PriceChangeWorkflowAdapter(IPriceChangeWorkflowAdapter):\r\n    client: Client\r\n\r\n    def __init__(self, client: Client):\r\n        self.client = client\r\n\r\n    async def run(self, price_change: PriceChange) -> None:\r\n        price_change_id = str(price_change.price_change_id)\r\n        await self.client.start_workflow(\r\n            PriceChangeWorkflow.run,\r\n            price_change_id,\r\n            id=price_change_id,\r\n            task_queue=\"my-task-queue\",\r\n        )\r\n    \r\n    async def query_some_state(self, price_change: PriceChange) -> Foo:\r\n        # get workflow object\r\n        # send query \r\n\r\n    async def send_some_signal(self, price_change: PriceChange) -> None:\r\n        # get workflow object\r\n        # send signal \r\n```","createdAt":"2022-07-10T19:58:10Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/68#issuecomment-1179788972","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5GWpr_","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> it isn't completely clear to me whether the above solution would even be safe\r\n\r\nIt is safe.\r\n\r\nWe are actively working on #52 which will solve your problem here. You'll be able to more-easily register methods on a class instance or a class with `__call__` as an activity. Then, you can just store your externally needed state on the class (you can do this today, but it's a bit confusing from the workflow caller side, see discussion at #66).","createdAt":"2022-07-11T12:21:57Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/68#issuecomment-1180343039","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5riWDO","author":{"login":"vaidik"},"authorAssociation":"NONE","body":"I think I am in kind of a similar situation but not able to wrap my head around how to make it work on the basis of @cretz 's response.\r\n\r\nMy situation is this:\r\n\r\nI have a FastAPI app. It is structured like so:\r\n* Controllers (as in MVC) - get executed on an incoming HTTP request. Sanitize the incoming payload and perform the business logic.\r\n* Services - actually wrap the business logic as well as the calls to the database (models). So controllers handle the HTTP request and then call services. Services can do one or more of these things:\r\n  * Wrap all the business logic\r\n  * Perform one or more database operations (CRUD)\r\n  * Execute part of the business logic asynchronously using Temporal by executing a workflow\r\n\r\nSo for example, there is an HTTP API to create a user and then send a message on slack to someone. Ideally, sending a message to someone/some channel on Slack happens asynchronously using a Temporal workflow, which executes a Temporal activity. Now what I want to achieve is that I want to keep the logic of sending message on Slack also on the service class to keep everything related to creating a user colocated. Here is the pseudo code:\r\n\r\n\r\nuser_service.py:\r\n```py\r\nfrom create_user_workflow import CreateUserWorkflow\r\n\r\nclass UserService:\r\n\r\n   def __init__(self):\r\n      self.db = get_db()\r\n      self.temporal_client = Client(...)\r\n\r\n   async def create_user(self, username):\r\n      user = User(username=username)\r\n      self.db.add(user)\r\n      self.db.commit()\r\n      await self.temporal_client.start_workflow(\r\n         CreateUserWorkflow,\r\n         ...\r\n      )\r\n\r\n    def notify_on_slack(self, username):\r\n      ....\r\n      # Do something to send message on slack about the new user\r\n```\r\n\r\n\r\ncreate_user_workflow.py:\r\n```py\r\nfrom user_service import UserService\r\n\r\n@activity.defn(name=\"notify_on_slack\")\r\nasync def notify_on_slack(username):\r\n  user_service = UserService()\r\n  user_service.notify_on_slack(username)\r\n\r\n@workflow.defn(name=\"CreateUserWorkflow\")\r\nclass CreateUserWorkflow:\r\n\r\n  @workflow.run\r\n  def run(self, params):\r\n    await workflow.start_activity(\r\n      notify_on_slack\r\n    )\r\n```\r\n\r\nBut this leads to Cyclic Import in Python.\r\n\r\nMy current workaround is that I have just moved the logic of sending a message to Slack from the `UserService` to the workflow module, but I am not too happy about that.\r\n\r\nWhat's the right way to do this?","createdAt":"2023-11-09T16:33:32Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/68#issuecomment-1804165326","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5rkKNs","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"@vaidik - feel free to join us on Slack or the forums. It can be a bit hard to get good answers on closed issues. In your case, it doesn't make much sense to put an activity in a workflow file. There are general ways to avoid this kind of circular import in Python, it's not really specific to Temporal (imagine you had FastAPI service A depending on B which depended on C which depended on A, how would you solve?)","createdAt":"2023-11-09T20:32:01Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/68#issuecomment-1804641132","viewerDidAuthor":false}],"createdAt":"2022-07-10T12:13:31Z","labels":[{"id":"LA_kwDOGusT1c7gQgHN","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":68,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"CLOSED","title":"[Feature Request] Inject dependencies into activities","updatedAt":"2023-11-09T20:34:02Z","url":"https://github.com/temporalio/sdk-python/issues/68"}
