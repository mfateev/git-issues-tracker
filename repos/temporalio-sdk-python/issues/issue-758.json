{"assignees":[],"author":{"id":"MDQ6VXNlcjE5MTIwMjg=","is_bot":false,"login":"spacether","name":"Justin Black"},"body":"### Is your feature request related to a problem? Please describe.\n\nCreating activities and decorating them is easy using activy.def in python\nMaking sure that they are all included in worker launch is more difficult.\n\n### Describe the solution you'd like\n\nIt would be helpful if a utility was provided that allowed\n- extracting activities from a class\n- extracting activities from a class instance\n- extracting activities from a module\n\nBelow is a sample implementation for extraction from class and class instances, assuming async method implementations that uses ast and inspection.\n\nIt looks like one could find which methods are decorate by checking if `fn.__temporal_activity_definition` but that is a private variable name and is not exposed in the temporalio activity.py module. Code that uses __temporal_activity_definition would be simpler and not invoking `ast.parse(inspect.getsource(cls))` is preferrable.\n```\nimport ast\nimport inspect\nimport typing\n\n\nclass _MyNodeVisitor(ast.NodeVisitor):\n    def __init__(self):\n        self.fn_name_to_decorators: dict[str, set[str]] = {}\n\n    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):\n        self.fn_name_to_decorators[node.name] = set()\n        for decorator in node.decorator_list:\n            print(decorator)\n            if isinstance(decorator, ast.Call):\n                # noinspection PyUnresolvedReferences\n                name = (\n                    decorator.func.attr\n                    if isinstance(decorator.func, ast.Attribute)\n                    else decorator.func.id\n                )\n            else:\n                # noinspection PyUnresolvedReferences\n                name = (\n                    decorator.value.id + \".\" + decorator.attr\n                    if isinstance(decorator, ast.Attribute)\n                    else decorator.id\n                )\n\n            self.fn_name_to_decorators[node.name].add(name)\n\n    def get_fn_name_to_decorators(self) -> dict[str, set[str]]:\n        return self.fn_name_to_decorators\n\n\nclass ActivitiesListProvider:\n    @classmethod\n    def __get_activities(\n        cls,\n        instance: typing.Union[\n            type[\"ActivitiesListProvider\"], \"ActivitiesListProvider\"\n        ],\n    ) -> list[typing.Callable]:\n        visitor = _MyNodeVisitor()\n        visitor.visit(ast.parse(inspect.getsource(cls)))\n        fn_name_to_decorators: dict[str, set[str]] = visitor.get_fn_name_to_decorators()\n\n        activities = []\n        for fn_name, decorators in fn_name_to_decorators.items():\n            if \"activity.defn\" in decorators:\n                method = getattr(instance, fn_name)\n                activities.append(method)\n        return activities\n\n    def get_activities_from_instance(self) -> list[typing.Callable]:\n        return self.__get_activities(self)\n\n    @classmethod\n    def get_activities_from_cls(cls) -> list[typing.Callable]:\n        return cls.__get_activities(cls)\n```\nAnd some Tests:\n```\nfrom workflow_metrics.temporal_tools import activities_class\n\nfrom temporalio import activity\n\n\nclass SomeActivities(activities_class.ActivitiesListProvider):\n    @activity.defn\n    async def instance_method_activity(self):\n        pass\n\n    @activity.defn\n    async def class_method_activity(self):\n        pass\n\n    @staticmethod\n    @activity.defn\n    async def static_method_activity():\n        pass\n\n\ndef test_get_activities_from_cls():\n    assert SomeActivities.get_activities_from_cls() == [\n        SomeActivities.instance_method_activity,\n        SomeActivities.class_method_activity,\n        SomeActivities.static_method_activity,\n    ]\n\n\nclass ActivitiesClassThatNeedsInstance(activities_class.ActivitiesListProvider):\n    @activity.defn\n    async def instance_method_activity(self):\n        pass\n\n    @activity.defn\n    async def class_method_activity(self):\n        pass\n\n    @staticmethod\n    @activity.defn\n    async def static_method_activity():\n        pass\n\n\ndef test_get_activities_from_instance():\n    inst = ActivitiesClassThatNeedsInstance()\n    assert inst.get_activities_from_instance() == [\n        inst.instance_method_activity,\n        inst.class_method_activity,\n        inst.static_method_activity,\n    ]\n```\n\n### Additional context\n\nIn code that I am working on activities are mainly defined in one module when they are fns and in class methods.\n","closedAt":null,"comments":[{"id":"IC_kwDOGusT1c6c2meN","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Sorry, just noticed this feature issue. Having discussion if viability on PR at https://github.com/temporalio/sdk-python/pull/759#discussion_r1939572982. Also circulating with team.","createdAt":"2025-02-03T16:58:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/758#issuecomment-2631559053","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6c25o4","author":{"login":"dandavison"},"authorAssociation":"MEMBER","body":"Hi @spacether, thanks for the input here. Before getting into implementation, can you expand on the problem that you want to see solved and what you see as the requirements for possible solutions? I.e. expand on this\n\n> Making sure that they are all included in worker launch is more difficult.\n\nE.g. what is it that you don't like currently, and, without speculating about specific implementations, what sorts of behaviors / semantics regarding activities would you like users to be able to express when starting a worker? It might help if you sketch some Worker launch code featuring imaginary APIs / function calls that would give you the semantics that you want.","createdAt":"2025-02-03T17:32:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/758#issuecomment-2631637560","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6c3Mi_","author":{"login":"spacether"},"authorAssociation":"NONE","body":"So right now it is entirely up to a develop to manually build an explicit list of activities in python. Our activities are already segregated by the kind fo work that they do into a python modules and activity classes. So then when we need to use them in a worker, one has to to list every activity decorated funcction in that module and in one or two classes when we already know that the activities I need come from these 3 sources: 1 module, and two classes. Adding these utilities lets me vend activities from those sources easily.\n\nI would like:\n```\nworker = Worker(\n  activities=[*ActivitiesClass.get_acitivities(), *get_activities(activities_module)]\n)\n```\nor\n```\nworker = Worker(\n  activities_classes=(ActivitiesClass,)\n  activities_modules=(activities_module),\n)\n```\nor\n```\nworker = Worker(\n  activities=[ActivitiesClass, activities_module, etc...]\n)\n```\nOne could make activities accept a list of (callables or a module or a class that has activities methods in it), where all of the activities from the class or module would be loaded into the worker.","createdAt":"2025-02-03T18:09:04Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/758#issuecomment-2631715007","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6c9iCh","author":{"login":"noxasaxon"},"authorAssociation":"NONE","body":"I recently came to the same conclusion as @spacether and made a similar function for collecting activities as part of a utility library for enforcing best practices at test time to avoid runtime failures. \n\nMy developers use a collection function in a worker.py file so that they don't forget to add an activity method to the worker every time they write a new one.\n\nI also have a function that is intended to run in a test, you just import your project's temporal directory module and it gets every @activity.defn method in the module and submodules and so that we can validate everything automatically:\n\nRepo is very much a work in progress still, not much documentation for the function-based validation as opposed to inheriting from a special validator class but the collection methods are here:\n\nhttps://github.com/noxasaxon/temporal_utils_python/blob/main/src/temporal_utils/collectors.py","createdAt":"2025-02-04T09:43:31Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/758#issuecomment-2633375905","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6vY0SJ","author":{"login":"charlesmelby"},"authorAssociation":"NONE","body":"I've resorted more than once to wrapping temporal's activity and workflow decorators in my own to make activity and workflow collection easy.\n\nTypically speaking, I have two needs:\n1. be able to import activities easily from a file or folder\n2. be able to put some filters in place -- e.g. allow certain test-oriented activities to be co-located with standard activities to avoid a fragmented codebase.\n\nManual import is messy because\n1. it is error-prone, especially in the case of things like feature flags\n2. it makes for poor separation of concerns, since the worker needs to be *explicitly* aware of every piece of functionality it serves.\n\nPersonally I'd be just as happy with a method that provides for easy collection, e.g.\n```py\nfrom temporalio import worker\nimport my_activities\nfrom other_activities import ActivityClass\n\nw = worker.Worker(\n  ...,\n  activities=worker.collect_activities(\n    \"path/to/activity/folder\",\n    my_activities,\n    ActivityClass\n  ), ...\n)\n```\ntogether with some simple filters.\nOne that would be useful is a skip directive in the activity decorator, which causes collection to be skipped (but doesn't prevent it from being registered explicitly with a worker):\n```py\n@activity.defn(skip=True)\nasync def my_activity():\n    ...\n```\nThis would facilitate e.g. test cases, dev/prod feature flags, and the like.\n\nMore flexible and comprehensive would be the ability to configure tags (this could easily be used in lieu of `skip`):\n```py\n@activity.defn(tags=[\"dev\", \"e2e\"])\nasync def prototyped_task():\n    ...\n```\ntogether with filtering directives in the collect_activities function:\n```py\nactivities = worker.collect_activities(module, tags=[\"prod\"])\nactivities = worker.collect_activities(module, exclude_tags=[\"test\"])\n```\nFinally, some kind of name pattern filter might be nice (though once again this could generally be handled by tags):\n```py\nactivities = worker.collect_activities(module, regex=r\".*_v[45]|database_.*\")\n```\n\nMy activities are usually bare functions so I don't have a real opinion on the best approach for activities that are owned by a class or class instance.","createdAt":"2025-06-05T02:11:34Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/758#issuecomment-2942518409","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6vZANH","author":{"login":"charlesmelby"},"authorAssociation":"NONE","body":"As a side note, one important issue to address is being able to deal effectively with mocks for tests.\nWith my current wrappers I actually just collect the activities at definition time (optionally grouped by worker name), but also provide facilities to override them inside tests: \n```py\n@flows.activity\nasync def real_activity():\n  ...\n\n@flows.activity(worker=\"other_worker\")\nasync def other_activity():\n  ...\n\nasync def real_activity_mock():\n  ...\n\nasync def other_activity_mock():\n  ...\n\n@flows.testing.case\n@flows.testing.provide(activities={\"real_activity\": other_activity_mock})\n@pytest.mark.asyncio\nasync def test_with_mock_other_activity(flow_runner):\n  await flow_runner.execute_workflow(my_workflow, ...)\n\n# actually mainly used to mock activities handled by remote workers,\n# but can be used with other workers in the same process\n@flows.testing.case\n@flows.testing.provide(\"other_worker\", activities={\"other_activity\": other_activity_mock})\n@pytest.mark.asyncio\nasync def test_with_mock_other_activity(flow_runner):\n  await flow_runner.execute_workflow(multi_worker_workflow, ...)\n```\n\nWith collection by a function as above configuring concise declarative tests might be more challenging.\nIncluding an override directive could be helpful for this, e.g.\n```py\nworker.collect_activities(module, overrides={\"my_activity\": my_activity_mock})\n```","createdAt":"2025-06-05T02:41:48Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/758#issuecomment-2942567239","viewerDidAuthor":false}],"createdAt":"2025-01-31T19:52:04Z","labels":[{"id":"LA_kwDOGusT1c7gQgHN","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":758,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"OPEN","title":"[Feature Request] Suggest Providing activities extraction utilities to get them from a class and a module","updatedAt":"2025-06-05T02:42:36Z","url":"https://github.com/temporalio/sdk-python/issues/758"}
