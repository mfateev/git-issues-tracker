{"assignees":[],"author":{"id":"U_kgDOChd1BQ","is_bot":false,"login":"Chengdyc","name":""},"body":"### What are you really trying to do?\r\n\r\nWe're using Temporal to build a chat application and we have a parent-child workflow set up that models the conversation (session) and each conversation turn (request+response). The conversation is a long running entity workflow, and each input is submitted via a 'workflow update' which starts a child workflow to generate the response.\r\n\r\nwe'd want to write a unit test for the conversation workflow to verify it's behavior. In the unit test, we mock the child workflow so we don't need to mock the logic and activities within the child workflow.\r\n\r\n### Describe the bug\r\n\r\nWhen we run the unit test, the test get stuck starting the child workflow. We added print statements before calling execute_child_workflow and at the start of the child workflow. It appears that Temporal test environment is unable to start the child workflow.\r\n\r\n<!-- If applicable, add screenshots or code blocks to help explain your problem. You can also use [Loom](http://loom.com/) to do short, free video bug reports. -->\r\n\r\n### Minimal Reproduction\r\n\r\nunit test to reproduce the bug. there are 3 test cases here.\r\n1. send 'workflow update' to parent workflow that starts a child workflow. this test will get stuck, remove the pytest.mark.skip annotation to run it\r\n2. send 'signal' to parent workflow that starts a child workflow. this test succeeds\r\n3. send 'workflow update' to workflow that starts an activity (no child workflow involved). this test succeeds.\r\n\r\nI'm using Temporal Python SDK version 1.7.1\r\n\r\n```\r\nimport asyncio\r\nimport logging\r\nimport uuid\r\nfrom datetime import timedelta\r\n\r\nimport pytest\r\nfrom temporalio import activity, workflow\r\nfrom temporalio.common import RetryPolicy\r\nfrom temporalio.testing import WorkflowEnvironment\r\nfrom temporalio.worker import Worker\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\n@workflow.defn\r\nclass ParentWorkflow:\r\n    def __init__(self) -> None:\r\n        self.input = None\r\n        self.output = None\r\n\r\n    @workflow.run\r\n    async def run(self):\r\n        while True:\r\n            try:\r\n                await workflow.wait_condition(\r\n                    lambda: self.input is not None,\r\n                    timeout=timedelta(minutes=60)\r\n                )\r\n            except TimeoutError:\r\n                workflow.logger.info(\"we're done\")\r\n                return\r\n\r\n            workflow.logger.info(\"exited wait, starting child workflow\")\r\n            self.output = await workflow.execute_child_workflow(\r\n                ChildWorkflow.run,\r\n                args=[self.input],\r\n                task_queue=workflow.info().task_queue,\r\n            )\r\n            workflow.logger.info(\"child workflow complete, got output\")\r\n            self.input = None\r\n    \r\n    @workflow.update\r\n    async def process_update(self, input: str):\r\n        self.input = input\r\n        self.output = None\r\n        logger.info(\"waiting for output\")\r\n        await workflow.wait_condition(\r\n            lambda: self.output is not None\r\n        )\r\n        return self.output\r\n    \r\n    @workflow.signal\r\n    async def signal(self, input: str):\r\n        self.input = input\r\n        self.output = None\r\n    \r\n\r\n@workflow.defn\r\nclass ChildlessWorkflow:\r\n    def __init__(self) -> None:\r\n        self.input = None\r\n        self.output = None\r\n\r\n    @workflow.run\r\n    async def run(self):\r\n        while True:\r\n            try:\r\n                await workflow.wait_condition(\r\n                    lambda: self.input is not None,\r\n                    timeout=timedelta(minutes=60)\r\n                )\r\n            except TimeoutError:\r\n                workflow.logger.info(\"we're done\")\r\n                return\r\n\r\n            workflow.logger.info(\"exited wait, starting activity\")\r\n            self.output = await workflow.execute_activity_method(\r\n                Activities.child_activity,\r\n                args=[self.input],\r\n                task_queue=workflow.info().task_queue,\r\n                schedule_to_close_timeout=timedelta(\r\n                    seconds=60\r\n                ),\r\n                retry_policy=RetryPolicy(maximum_attempts=1)\r\n            )\r\n            workflow.logger.info(\"child workflow complete, got output\")\r\n            self.input = None\r\n    \r\n    @workflow.update\r\n    async def process_update(self, input: str):\r\n        self.input = input\r\n        self.output = None\r\n        logger.info(\"waiting for output\")\r\n        await workflow.wait_condition(\r\n            lambda: self.output is not None\r\n        )\r\n        return self.output\r\n\r\n\r\nclass Activities:\r\n    @activity.defn\r\n    async def child_activity(\r\n        self,\r\n        name: str\r\n    ) -> str:\r\n        return f\"child activity {name}\"\r\n\r\n\r\n@workflow.defn\r\nclass ChildWorkflow:\r\n    @workflow.run\r\n    async def run(self, name: str):\r\n        return await workflow.execute_activity_method(\r\n            Activities.child_activity,\r\n            args=[name],\r\n            schedule_to_close_timeout=timedelta(\r\n                seconds=60\r\n            ),\r\n            task_queue=workflow.info().task_queue,\r\n            retry_policy=RetryPolicy(maximum_attempts=1)\r\n       )\r\n\r\n\r\n@workflow.defn(name=\"ChildWorkflow\")\r\nclass MockChildWorkflow:\r\n    @workflow.run\r\n    async def run(self, name: str):\r\n        await asyncio.sleep(60)\r\n        return f\"mock {name} done\"\r\n    \r\npytestmark = pytest.mark.asyncio\r\n\r\n\r\n@pytest.mark.skip(\r\n    reason=\"test will get stuck\"\r\n)\r\nasync def test_workflow_update():\r\n    \"\"\" Test to show that if we use workflow update together with child workflow execution we'll trigger the bug. This test will get stuck \"\"\"\r\n    tmp_task_queue = f\"task_queue-{uuid.uuid4()}\"\r\n    activities = Activities()\r\n    async with await WorkflowEnvironment.start_time_skipping() as env:\r\n        async with Worker(\r\n            env.client,\r\n            task_queue=tmp_task_queue,\r\n            workflows=[ParentWorkflow, MockChildWorkflow],\r\n            activities=[activities.child_activity],\r\n        ):\r\n            # env is WorkflowEnvironment with time-skipping\r\n            handle = await env.client.start_workflow(\r\n                ParentWorkflow.run,\r\n                args=[],\r\n                task_queue=tmp_task_queue,\r\n                id=str(uuid.uuid4())\r\n            )\r\n            logger.info(\"executing update\")\r\n            update_result = await handle.execute_update(\r\n                ParentWorkflow.process_update,\r\n                args=[\"my name\"]\r\n            )\r\n            logger.info(f\"got result: {update_result}, waiting for termination\")\r\n            # do some other verification with workflow handle\r\n            # wait for workflow to finish\r\n            result = await handle.result()\r\n            print(result)\r\n\r\n\r\nasync def test_workflow_signal():\r\n    \"\"\" Test to show that if we are NOT sending workflow update, the bug is not triggered. This test will succeed \"\"\"\r\n    tmp_task_queue = f\"task_queue-{uuid.uuid4()}\"\r\n    activities = Activities()\r\n    async with await WorkflowEnvironment.start_time_skipping() as env:\r\n        async with Worker(\r\n            env.client,\r\n            task_queue=tmp_task_queue,\r\n            workflows=[ParentWorkflow, MockChildWorkflow],\r\n            activities=[activities.child_activity],\r\n        ):\r\n            # env is WorkflowEnvironment with time-skipping\r\n            handle = await env.client.start_workflow(\r\n                ParentWorkflow.run,\r\n                args=[],\r\n                task_queue=tmp_task_queue,\r\n                id=str(uuid.uuid4())\r\n            )\r\n            logger.info(\"executing update\")\r\n            update_result = await handle.signal(\r\n                ParentWorkflow.signal,\r\n                args=[\"my name\"]\r\n            )\r\n            logger.info(f\"got result: {update_result}, waiting for termination\")\r\n            # do some other verification with workflow handle\r\n            # wait for workflow to finish\r\n            result = await handle.result()\r\n            print(result)\r\n\r\n\r\nasync def test_childless_workflow():\r\n    \"\"\" Test to show that if we use workflow update and there is no child workflow, the bug is not triggered. this test will succeed \"\"\"\r\n    tmp_task_queue = f\"task_queue-{uuid.uuid4()}\"\r\n    activities = Activities()\r\n    async with await WorkflowEnvironment.start_time_skipping() as env:\r\n        async with Worker(\r\n            env.client,\r\n            task_queue=tmp_task_queue,\r\n            workflows=[ChildlessWorkflow],\r\n            activities=[activities.child_activity],\r\n        ):\r\n            # env is WorkflowEnvironment with time-skipping\r\n            handle = await env.client.start_workflow(\r\n                ChildlessWorkflow.run,\r\n                args=[],\r\n                task_queue=tmp_task_queue,\r\n                id=str(uuid.uuid4())\r\n            )\r\n            logger.info(\"executing update\")\r\n            update_result = await handle.execute_update(\r\n                ChildlessWorkflow.process_update,\r\n                args=[\"my name\"]\r\n            )\r\n            logger.info(f\"got result: {update_result}, waiting for termination\")\r\n            # do some other verification with workflow handle\r\n            # wait for workflow to finish\r\n            result = await handle.result()\r\n            print(result)\r\n```\r\n\r\nCommand to run this:\r\n```\r\npoetry run pytest -rA -s test_mock_child.py\r\n```\r\n\r\n### Environment/Versions\r\n\r\n<!-- Please complete the following information where relevant. -->\r\n\r\n- OS and processor: Linux (WSL2)\r\n- Temporal Version: 1.7.1 \r\n- Are you using Docker or Kubernetes or building Temporal from source? No\r\n\r\n### Additional context\r\n\r\n\r\n","closedAt":"2024-10-21T16:35:19Z","comments":[{"id":"IC_kwDOGusT1c6PCIvg","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Thanks for the report! We will investigate.","createdAt":"2024-10-08T12:25:00Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/661#issuecomment-2399701984","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6PM6dw","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Automatic time skipping only works when you're waiting on the workflow result. If you start the workflow and do not wait on the result, the automatic time skipping will not occur. From https://github.com/temporalio/sdk-python?tab=readme-ov-file#automatic-time-skipping:\r\n\r\n> Anytime a workflow result is waited on, the time-skipping server automatically advances to the next event it can\r\n\r\nIf, before `logger.info(\"executing update\")` you had `result_task = asyncio.create_task(handle.result())` that would wait for the result in the background and ensure automatic time skipping. Granted that would immediately trigger the 60s timeout. You can also enable auto-time-skipping with `with env.time_skipping_unlocked():`. I will confer with the team if we want to also enable automatic time skipping when waiting on update result.","createdAt":"2024-10-09T14:36:25Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/661#issuecomment-2402527088","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6Qq7Wj","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"We have opened #675 to enable auto time skipping when waiting on an update result. Closing this issue in favor of that one (you can still do the workaround of waiting on the workflow in the background to enable auto-skipping).","createdAt":"2024-10-21T16:35:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/661#issuecomment-2427172259","viewerDidAuthor":false}],"createdAt":"2024-10-08T03:46:55Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":661,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Child workflow execution stuck when running in testing.WorkflowEnvironment and workflow update is involved.","updatedAt":"2024-10-21T16:35:19Z","url":"https://github.com/temporalio/sdk-python/issues/661"}
