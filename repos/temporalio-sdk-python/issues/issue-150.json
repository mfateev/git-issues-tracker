{"assignees":[],"author":{"id":"MDQ6VXNlcjg0Njg1ODc=","is_bot":false,"login":"nediamond","name":""},"body":"### What are you really trying to do?\r\n\r\nI am trying to execute activities in parallel with retries disabled, following the pattern from [this example](https://github.com/temporalio/samples-python/blob/main/hello/hello_parallel_activity.py)\r\n\r\nWhen one activity execution fails, I would expect that successful activity completions are still saved to workflow history\r\n\r\n### Describe the bug\r\n\r\nI am observing that when an activity from the `asyncio.gather(` fails, it then fails the workflow & causes the remaining activity results to be dropped / not saved to workflow history.\r\n\r\nIt also gives this warning on subsequent activity completion after the initial failure:\r\n```\r\nWARN temporal_sdk_core::worker::activities: Activity not found on completion. This may happen if the activity has already been cancelled but completed anyway., task_token: TaskToken(CiQwNmI4MTAyZC02NzUzLTQxODctYjI3My1jNDVkMzVhOGIxMGESEXdlaWJvLXByb2ZpbGUtNTk3GiQ5ODdlMjAxMy0yNGYwLTRiMmMtOGFhNi1lODUyMjIxMjE5NGMgEygBMgE1Qgxwcm9jZXNzX2l0ZW1KCAgBEMWAQBgB), details: Status { code: NotFound, message: \"workflow execution already completed\", details: b\"\\x08\\x05\\x12$workflow execution already completed\\x1aB\\n@type.googleapis.com/temporal.api.errordetails.v1.NotFoundFailure\", metadata: MetadataMap { headers: {\"content-type\": \"application/grpc\"} }, source: None }\r\n```\r\n\r\nIn Temporal UI, this presents as having both `ActivityTaskFailed` and `WorkflowExecutionFailed` in the event history but many pending activities are still listed indefinitely at the top.\r\n\r\n### Minimal Reproduction\r\nBased on https://github.com/temporalio/samples-python/blob/main/hello/hello_parallel_activity.py\r\nDisabled retries, increased activity duration, added failing activity\r\n```\r\nimport asyncio\r\nfrom datetime import timedelta\r\nfrom typing import List\r\n\r\nfrom temporalio import activity, workflow\r\nfrom temporalio.client import Client\r\nfrom temporalio.common import RetryPolicy\r\nfrom temporalio.worker import Worker\r\n\r\n\r\nNO_RETRY = RetryPolicy(maximum_attempts=1)\r\n\r\n\r\n@activity.defn\r\nasync def say_hello_activity(name: str) -> str:\r\n    await asyncio.sleep(20)\r\n    return f\"Hello, {name}!\"\r\n\r\n\r\n@activity.defn\r\nasync def bad_activity() -> str:\r\n    return 1/0\r\n\r\n\r\n@workflow.defn\r\nclass SayHelloWorkflow:\r\n    @workflow.run\r\n    async def run(self) -> List[str]:\r\n        # Run 5 activities at the same time\r\n        results = await asyncio.gather(\r\n            workflow.execute_activity(\r\n                bad_activity, retry_policy=NO_RETRY, start_to_close_timeout=timedelta(minutes=20)\r\n            ),\r\n            workflow.execute_activity(\r\n                say_hello_activity, \"user2\", retry_policy=NO_RETRY, start_to_close_timeout=timedelta(minutes=20)\r\n            ),\r\n            workflow.execute_activity(\r\n                say_hello_activity, \"user3\", retry_policy=NO_RETRY, start_to_close_timeout=timedelta(minutes=20)\r\n            ),\r\n            workflow.execute_activity(\r\n                say_hello_activity, \"user4\", retry_policy=NO_RETRY, start_to_close_timeout=timedelta(minutes=20)\r\n            ),\r\n            workflow.execute_activity(\r\n                say_hello_activity, \"user5\", retry_policy=NO_RETRY, start_to_close_timeout=timedelta(minutes=20)\r\n            ),\r\n        )\r\n        # Sort the results because they can complete in any order\r\n        return list(sorted(results))\r\n\r\n\r\nasync def main():\r\n    # Start client\r\n    client = await Client.connect(\"temporal:7233\")\r\n\r\n    # Run a worker for the workflow\r\n    async with Worker(\r\n        client,\r\n        task_queue=\"hello-parallel-activity-task-queue\",\r\n        workflows=[SayHelloWorkflow],\r\n        activities=[say_hello_activity, bad_activity],\r\n    ):\r\n\r\n        # While the worker is running, use the client to run the workflow and\r\n        # print out its result. Note, in many production setups, the client\r\n        # would be in a completely separate process from the worker.\r\n        result = await client.execute_workflow(\r\n            SayHelloWorkflow.run,\r\n            id=\"hello-parallel-activity-workflow-id\",\r\n            task_queue=\"hello-parallel-activity-task-queue\",\r\n        )\r\n        print(f\"Result: {result}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n\r\n```\r\n\r\n### Environment/Versions\r\n\r\n<!-- Please complete the following information where relevant. -->\r\n\r\n- i9 Mac\r\n- Temporal Version: docker image `temporalio/auto-setup:1.18.0` \r\n- Running using docker compose\r\n\r\n### Additional context\r\n\r\n- Noticed when doing the minimal reproduction that activity latency is a significant factor\r\n","closedAt":"2022-10-11T18:34:31Z","comments":[{"id":"IC_kwDOGusT1c5MAIYi","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> When one activity execution fails, I would expect that successful activity completions are still saved to workflow history\r\n\r\nWhen a workflow completes, all activities are cancelled. This is Temporal server behavior. The workflow is complete when an exception is thrown out of it. I think that WARN may be ignored, but I will check with that team (and we'll lower the log level if so).\r\n\r\nFrom https://docs.python.org/3/library/asyncio-task.html#asyncio.gather:\r\n\r\n> If return_exceptions is False (default), the first raised exception is immediately propagated to the task that awaits on gather().\r\n\r\nThis means in your code, while all 5 activities may start, `bad_activity` will raise, causing `gather` to raise, causing the workflow to complete with a failure, causing all other activities and anything outstanding on the workflow to be \"cancelled\".\r\n\r\nLet me know if I am misunderstanding the concern.","createdAt":"2022-10-11T18:25:16Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/150#issuecomment-1275102754","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5MAKyK","author":{"login":"nediamond"},"authorAssociation":"NONE","body":">>If return_exceptions is False (default), the first raised exception is immediately propagated to the task that awaits on gather().\r\n\r\n>This means in your code, while all 5 activities may start, bad_activity will raise, causing gather to raise, causing the workflow to complete with a failure, causing all other activities and anything outstanding on the workflow to be \"cancelled\".\r\n\r\nAh I tried that option earlier but think I ruled it out quickly out of confusion - definitely seems appropriate. Thanks!\r\n\r\n","createdAt":"2022-10-11T18:34:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/150#issuecomment-1275112586","viewerDidAuthor":false}],"createdAt":"2022-10-11T18:06:44Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":150,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Potential issue with parallel activities","updatedAt":"2022-10-11T18:34:31Z","url":"https://github.com/temporalio/sdk-python/issues/150"}
