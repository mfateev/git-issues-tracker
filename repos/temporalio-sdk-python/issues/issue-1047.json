{"assignees":[],"author":{"id":"MDQ6VXNlcjk1NTk2NTU=","is_bot":false,"login":"gregbrowndev","name":"Greg Brown"},"body":"### Is your feature request related to a problem? Please describe.\n\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\n\nHeartbeat timeout failures can be a major pain point when working with async Temporal activities. It would be great if the OpenTelemetry [`TracingInterceptor`](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/contrib/opentelemetry.py#L272-L295) contrib were able to mark spans as failed for cancellations due to heartbeat timeouts, so we can identify workers with heartbeat issues more easily and assess the scale of the issue.\n\nThe SDK metrics also don't help much in this case, since [activity_execution_failed](https://docs.temporal.io/references/sdk-metrics#activity_execution_failed) doesn't provide a reason/code label. \n\n### Describe the solution you'd like\n\n<!-- A clear and concise description of what you want to happen. SCREENSHOTS OR CODE SAMPLES ARE VERY HELPFUL -->\n\nSomething like this works for the async/threaded cases, though it doesn't distinguish different kinds of cancellation reasons. It doesn't work for sync, multi-processed activities since they don't raise cancellation errors.\n\n```py\nclass _TracingActivityInboundInterceptor(\n    temporalio.worker.ActivityInboundInterceptor\n):\n    def __init__(\n        self,\n        next: temporalio.worker.ActivityInboundInterceptor,\n        root: TracingInterceptor,\n    ) -> None:\n        super().__init__(next)\n        self.root = root\n\n    async def execute_activity(\n        self, input: temporalio.worker.ExecuteActivityInput\n    ) -> Any:\n        info = temporalio.activity.info()\n        with self.root.tracer.start_as_current_span(\n            f\"RunActivity:{info.activity_type}\",\n            context=self.root._context_from_headers(input.headers),\n            attributes={\n                \"temporalWorkflowID\": info.workflow_id,\n                \"temporalRunID\": info.workflow_run_id,\n                \"temporalActivityID\": info.activity_id,\n            },\n            kind=opentelemetry.trace.SpanKind.SERVER,\n        ) as span:\n            try:\n                return await super().execute_activity(input)\n            except BaseException as e:\n                # Catch heartbeat cancellation errors to mark span as failed\n                # Note: asyncio.CancelledError extends BaseException which would be ingored by span\n                if isinstance(e, asyncio.CancelledError):\n                    span.record_exception(e)\n                    span.set_status(\n                        opentelemetry.trace.Status(\n                            status_code=opentelemetry.trace.StatusCode.ERROR,\n                            description=f\"{type(e).__name__}: {e}\",\n                        )\n                    )\n                raise e\n```\n\n### Additional context\n\n<!-- Add any other context or screenshots about the feature request here. -->\n\nThis only really applies in the case where the worker/activities are blocked for some reason and fail to heartbeat. Since the activity is still actually running, they receive a cancellation request from the server on their next, eventual heartbeat.  If the worker completely died, I wouldn't expect to see any spans at all. \n\n**The problem** is `asyncio.CancelledError` extends `BaseException`, but the OTEL Tracer's [`start_as_current_span`](https://github.com/open-telemetry/opentelemetry-python/blob/1aaa2a25872c36aee208442ff654a67f5daa5736/opentelemetry-sdk/src/opentelemetry/sdk/trace/__init__.py#L1077) only catches `Exception` type errors ([reference](https://github.com/open-telemetry/opentelemetry-python/blob/1aaa2a25872c36aee208442ff654a67f5daa5736/opentelemetry-api/src/opentelemetry/trace/__init__.py#L593-L596)), since exceptions directly subclassing `BaseException` are usually not considered errors, e.g. `GeneratorExit`, `KeyboardInterrupt`, `CancelledError` (according to that code). \n\nHowever, in this context, a `CancelledError` (both async and the sync Temporal kind) can **represent a major failure of the system to behave as intended**.\n\n**The second problem** is that it doesn't look like there is enough context in the `TracingInterceptor` to distinguish different kinds of cancellation reasons, including:\n\n- cancelled by user (e.g. in Temporal UI, SDK, or CLI) - shouldn't be marked as failed\n- cancelled by workflow due to a failure in some other parallel branch, e.g. `await asyncio.gather(activity1, activity2, ...)` - probably not a failure for this activity?\n- cancelled by heartbeat timeout - IMO is a failure\n- cancelled by activity timeout - could be context specific, leaning towards a failure though\n- cancelled due to activity pause - not a failure\n- cancelled due to worker shutdown event - not a failure\n\nI'm not sure what the correct semantics should be for each of these cases. It would probably help to align them with the existing SDK metrics, e.g. [`activity_execution_cancelled`](https://docs.temporal.io/references/sdk-metrics#activity_execution_cancelled) and [`activity_execution_failed`](https://docs.temporal.io/references/sdk-metrics#activity_execution_failed) (Note: I've not actually seen any `activity_execution_cancelled` in my app as its Java only...) so not sure if all these cancellation errors are currently being emitted as `activity_execution_failed` or not? If that is the case, then it might make sense to simply make all cancellations fail the span (though I do think it should be more refined than that, e.g. involuntary cancellations due to something bad happening, vs voluntary cancellations initiated by the user/system). \n\nThe `_Context` object's `cancellation_details` doesn't seem to contain anything useful, as its not set during the `_ActivityWorker`'s [`_heartbeat_async`](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L242) method, and the interceptor doesn't have access to the info in `_RunningActivity`, from what I could tell. Updating the `cancellation_details` when a heartbeat error is received could solve this part of the issue since we can access it in the interceptor via `_Context` / [`cancellation_details`](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/activity.py#L324-L326) accessor.\n\n**Lastly**, it doesn't look like cancellation happens at all in multi-process workers. After debugging, I saw that even after the whole workflow failed, the sync activity continued until completion. The `thread_event=manager.new_event()` event set in `_ActivityWorker` doesn't seem to be actively used yet.  The result returned through the `TracingInterceptor` was the expected return value, not an exception, so these aren't even caught as exception events. However, I rarely have issues with the multi-processor worker, since I do its auto-heartbeating in a background thread. Though, I have seen these fail occasionally, maybe due to GIL blocking or CPU throttling. \n\nIt would be nice if cancellations could be applied properly to sync, multi-processed activities to save time and resources. I've raised that as a separate issue: https://github.com/temporalio/sdk-python/issues/1048.\n\n\nSince this fix isn't likely that straight-forward, I'll likely patch this in my own interceptor for now. This has been suggested in these other tracing related issues:\n\n- https://github.com/temporalio/sdk-python/pull/1017\n- https://github.com/temporalio/sdk-python/issues/1041\n\n\nCheers,\n\nI'm happy to contribute towards all the issues mentioned in this area, if the solution/requirements are clarified. I also want to extend the SDK's runtime metrics support to sync, mp activities too. So I'm not shy to pick up fairly challenging bits of work to help out üôèüèª \n\n\n\n\n\n\n","closedAt":"2025-10-21T19:59:06Z","comments":[{"id":"IC_kwDOGusT1c6_7D4H","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"Further thoughts on implementation:\n\n- I noticed there is some inconsistency in how spans handle cancellation between async and sync-threaded workers. \n\n  - Since the threaded worker raises a `temporalio.exceptions.CancelledError`, which extends `Exception`, the root span created by this interceptor and any downstream childspans created by the user will be marked automatically as failed. \n  - However, for the async worker, the `asyncio.CancelledError` isn't treated as a failure at all. This PR fixes the behaviour in the root span, but childspans will be inconsistent, unless they apply the same `try/exception` same logic.\n  - This also suggests that the interceptor should treat all `asyncio.CancelledError` errors as failures (regardless of the reason), to be consistent with the sync case, as is. Alternatively, the handling of `temporalio.exceptions.CancelledError` could be updated to make it consistent with `asyncio.CancelledError`. \n\n- Since https://github.com/temporalio/sdk-python/issues/1041 aims to treat `ApplicationError(category=BENIGN)` encoded errors (which derives from `Exception`) as none-failures, this too should probably be handled consistently in the interceptor and user activity implement (if that behaviour is what we want).\n\nBoth of these cases suggest it might be a good idea to provide a modified `Tracer` in `activity.py`, similar to the [`metric_meter`](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/activity.py#L469-L484) helper, that applies Temporal specific behaviours when making a span. This would make the interceptor and downstream childspans consistent. However, this would be a much bigger change to create a similar ABC in [common.py](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/common.py#L566) to avoid bundling the OTEL SDK as a core dependency.\n\nWhat do you think?","createdAt":"2025-08-25T11:39:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1047#issuecomment-3219930631","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7Bx2vn","author":{"login":"tconley1428"},"authorAssociation":"MEMBER","body":"@gregbrowndev appreciate your thoughts. I'm still coming to terms with the details of the OTel ecosystem here. If I follow correctly, the idea of providing a modified `Tracer` would be to allow the activity author to easily handle span generation in the same way that we would be doing after some of these changes, correct? In that case, I'm not sure I totally follow why we would provide a new abstraction over it inside of the core SDK package. Wouldn't it be possible for the otel integration to provide a modified tracer, and allow the author to set that in otel itself?","createdAt":"2025-09-03T23:03:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1047#issuecomment-3251071975","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7CCsA0","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"If I understand correctly, the concern is that cancellation exceptions for threaded vs asyncio are different? This is a Python issue where they chose to make an asyncio cancellation concept that was not portable. Then they went and changed the base class of their asyncio cancellation exception in 3.8.\n\nWe recognize there are a great many differences in how cancellation behavior/exceptions are treated in threaded vs async and the code author may have to account for those. One is that they have different base classes, making libraries like OTel treat them differently (and maybe Sentry and maybe loggers and maybe any number of Python libraries that react to `BaseException` vs not).\n\nI am not sure trying to make async and threaded cancellation exceptions consistent is worth the confusion to users of each individually. The former expects to do things the Python way. The latter has no Python way, so Temporal does as libraries do and extends `Exception`. But we do not blindly assume every asyncio cancellation exception raised from an activity is an activity cancellation, we check whether there is a server exception first.\n\nLibraries like OTel choose to treat built-in `BaseException`s differently than user/library defined `Exception`s. Same as if you wrote `catch Exception` and didn't catch asyncio exceptions in any code. I would rather let OTel's behavior be the predictable user behavior that OTel users understand rather than us treat this special asyncio cancelled exception differently than OTel chose to. This comes at the unfortunate cost of different activity types handling exceptions differently, but that happens anyways with loggers, Sentry, homemade metrics doing `catch Exception`, and, yes OTel context managers etc. But one can have their own interceptor if you want asyncio exceptions to be treated differently than OTel's default.","createdAt":"2025-09-04T20:22:35Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1047#issuecomment-3255484468","viewerDidAuthor":false}],"createdAt":"2025-08-23T23:34:50Z","labels":[{"id":"LA_kwDOGusT1c7gQgHN","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1047,"reactionGroups":[],"state":"CLOSED","title":"[Feature Request] Set OpenTelemetry span status to failed for heartbeat timeout cancellations","updatedAt":"2025-10-21T19:59:06Z","url":"https://github.com/temporalio/sdk-python/issues/1047"}
