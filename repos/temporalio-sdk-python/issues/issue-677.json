{"assignees":[],"author":{"id":"MDQ6VXNlcjUyNjI2NTIx","is_bot":false,"login":"sarnikowski","name":"Philip Tamimi-Sarnikowski"},"body":"When one normally wants to override the writing of uncaught exceptions in python, you can use the `excepthook` of sys.\r\nBelow is an example of how one can do this in temporal:\r\n```python\r\nimport asyncio\r\nimport datetime as dt\r\nimport logging\r\nimport sys\r\nimport traceback\r\n\r\nfrom temporalio import activity, workflow\r\nfrom temporalio.client import Client\r\nfrom temporalio.common import RetryPolicy\r\nfrom temporalio.testing import WorkflowEnvironment\r\nfrom temporalio.worker import Worker\r\n\r\nlogging.basicConfig(\r\n    level=logging.ERROR,\r\n    format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n)\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\ndef log_exception(exc_type, exc_value, exc_traceback):\r\n    tb_lines = traceback.format_exception(exc_type, exc_value, exc_traceback)\r\n    tb_text = \"\".join(tb_lines)\r\n    logger.error(\"Uncaught exception:\\n%s\", tb_text)\r\n\r\n@activity.defn\r\nasync def say_hello(name: str) -> str:\r\n    raise Exception(\"ohh no, I could not say hello\")\r\n\r\n@workflow.defn\r\nclass GreetingWorkflow:\r\n    @workflow.run\r\n    async def run(self, name: str) -> str:\r\n        return await workflow.execute_activity(\r\n            say_hello,\r\n            name,\r\n            start_to_close_timeout=dt.timedelta(seconds=10),\r\n            retry_policy=RetryPolicy(\r\n                initial_interval=dt.timedelta(seconds=0),\r\n                maximum_attempts=1,\r\n            ),\r\n        )\r\n\r\nasync def start_temporal_server():\r\n    return await WorkflowEnvironment.start_local(namespace=\"default\", dev_server_log_level=\"error\")\r\n\r\nasync def run_workflow(client: Client):\r\n    async with Worker(\r\n        client,\r\n        task_queue=\"hello-task-queue\",\r\n        workflows=[GreetingWorkflow],\r\n        activities=[say_hello],\r\n    ):\r\n        result = await client.execute_workflow(\r\n            GreetingWorkflow.run,\r\n            \"World\",\r\n            id=\"greeting-workflow\",\r\n            task_queue=\"hello-task-queue\",\r\n        )\r\n        print(f\"Workflow result: {result}\")\r\n\r\nasync def main():\r\n    sys.excepthook = log_exception\r\n    server = await start_temporal_server()\r\n    await run_workflow(server.client)\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```\r\n\r\nHowever, if the workers are running using for example a threadpool executor, this does not work because the hook of  `sys.excepthook` is not propagated to these threads (ref: https://github.com/python/cpython/pull/13515). \r\n\r\nI have an application where we do not want to print exceptions and their stacktraces to stderr, but rather log all uncaught exceptions. The problem is that if I want to do this for threads, the usual approach is to simply catch the exception and log the errors instead of raising an exception. However, if I want the temporal workflow to pick up the fact that an activity has failed, I believe I cannot do this ? So in essence I would like:\r\n1. To log all uncaught exceptions instead of printing these to stderr.\r\n2. Have temporal read the exceptions and stacktrace etc. so that it is readable on a workflow in the UI for example.\r\n3. Have activities and workflows behave as usual, with errors triggering retries etc.\r\n\r\nIs there a way to achieve this ?","closedAt":"2024-10-30T12:44:58Z","comments":[{"id":"IC_kwDOGusT1c6RhyOv","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Yes, you should look into interceptors. For instance, [this sample](https://github.com/temporalio/samples-python/tree/main/sentry) sends errors to Sentry. You can make an activity interceptor that logs and re-raises.\r\n\r\nAlso, feel free to join us on our forums or `#python-sdk` on [Slack](https://t.mp/slack) with general questions.","createdAt":"2024-10-28T13:12:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/677#issuecomment-2441552815","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6R2pwf","author":{"login":"sarnikowski"},"authorAssociation":"NONE","body":"For posterity, I ended up with the following solution:\r\n\r\nI added a structlog interceptor, as suggested by @cretz:\r\n```python\r\nfrom typing import Any, override\r\n\r\nimport structlog\r\nfrom temporalio.worker import (\r\n    ActivityInboundInterceptor,\r\n    ExecuteActivityInput,\r\n    ExecuteWorkflowInput,\r\n    Interceptor,\r\n    WorkflowInboundInterceptor,\r\n    WorkflowInterceptorClassInput,\r\n)\r\n\r\nlogger = structlog.get_logger()\r\n\r\n\r\nclass _StructlogActivityInboundInterceptor(ActivityInboundInterceptor):\r\n    @override\r\n    async def execute_activity(self, input: ExecuteActivityInput) -> Any:\r\n        try:\r\n            return await super().execute_activity(input)\r\n        except Exception as e:\r\n            logger.exception(\"uncaught exception in activity\")\r\n            raise e\r\n\r\n\r\nclass _StructlogWorkflowInboundInterceptor(WorkflowInboundInterceptor):\r\n    @override\r\n    async def execute_workflow(self, input: ExecuteWorkflowInput) -> Any:\r\n        try:\r\n            return await super().execute_workflow(input)\r\n        except Exception as e:\r\n            logger.exception(\"uncaught exception in workflow\")\r\n            raise e\r\n\r\n\r\nclass StructlogInterceptor(Interceptor):\r\n    \"\"\"Temporal Interceptor class which will log workflow & activity exceptions to stdout.\"\"\"\r\n\r\n    @override\r\n    def intercept_activity(self, next: ActivityInboundInterceptor) -> ActivityInboundInterceptor:\r\n        return _StructlogActivityInboundInterceptor(super().intercept_activity(next))\r\n\r\n    @override\r\n    def workflow_interceptor_class(\r\n        self, input: WorkflowInterceptorClassInput\r\n    ) -> type[WorkflowInboundInterceptor] | None:\r\n        return _StructlogWorkflowInboundInterceptor\r\n```\r\n\r\nHowever, this only ensured that uncaught exceptions would be written to stdout, using structlog. To suppress the exception being written to stderr, I ended up redirecting stderr to `/dev/null`, which I don't think is an ideal solution. To limit the scope of the redirect, I made a context manager, that I am using on my threadpool executor. The manager looks like this:\r\n\r\n```python\r\nclass RedirectStdErrToDevNull:\r\n    \"\"\"A context manager that pipes stderr output to /dev/null.\r\n\r\n    Example:\r\n        >>> import sys\r\n        >>> with StdErrToDevNull():\r\n        >>>     print(\"quack\", file=sys.stderr)\r\n        >>>     # No quacking will be written to stderr.\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        self._devnull: TextIO | None = None\r\n        self._stderr_redirector: contextlib.redirect_stderr[TextIO] | None = None\r\n\r\n    def __enter__(self) -> \"RedirectStdErrToDevNull\":\r\n        self._devnull = open(os.devnull, \"w\")\r\n        self._stderr_redirector = contextlib.redirect_stderr(self._devnull)\r\n        self._stderr_redirector.__enter__()\r\n        return self\r\n\r\n    def __exit__(\r\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\r\n    ) -> None:\r\n        if self._stderr_redirector is not None:\r\n            self._stderr_redirector.__exit__(exc_type, exc_val, exc_tb)\r\n        if self._devnull is not None:\r\n            self._devnull.close()\r\n```","createdAt":"2024-10-30T12:44:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/677#issuecomment-2447023135","viewerDidAuthor":false}],"createdAt":"2024-10-28T11:47:24Z","labels":[],"milestone":null,"number":677,"reactionGroups":[],"state":"CLOSED","title":"Question: Logging of uncaught exceptions when running under a threadpool executor","updatedAt":"2024-10-30T12:44:58Z","url":"https://github.com/temporalio/sdk-python/issues/677"}
