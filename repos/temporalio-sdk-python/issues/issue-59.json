{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\nUsers on an older version of gevent (1.5.0) reported that running `gevent.monkey.patch_all()` breaks workflow asyncio.\r\n\r\n### Describe the solution you'd like\r\n\r\n* Replicate the error on that gevent version (a simple workflow is probably fine)\r\n* Upgrade gevent to see if it still occurs\r\n  * If not, essentially bisect to find offending version minimum and maybe document in README\r\n  * If so, find workaround and document in README","closedAt":"2023-10-24T13:20:42Z","comments":[{"id":"IC_kwDOGusT1c5Fv68-","author":{"login":"alecgorge"},"authorAssociation":"NONE","body":"Does this mean gevent with Temporal is meant to be a supported configuration? Do you need to use synchronous Activities to use gevent code?\r\n\r\nIs there any documentation on the usage together? I tried looking for some earlier and couldn’t find it.","createdAt":"2022-06-29T16:13:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1170190142","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5Fv-PS","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> Does this mean gevent with Temporal is meant to be a supported configuration?\r\n\r\nNo, the SDK does not use gevent in any way nor depend on it in any way. This is just a case where a user had an old gevent library in their existing code and it clashed with Temporal due to some bug in gevent's global side-effecting code that may have since been fixed. This issue is simply me acknowledging it so I can test and if necessary add a warning to the README for users of older gevent libraries.\r\n\r\n> Do you need to use synchronous Activities to use gevent code? Is there any documentation on the usage together? I tried looking for some earlier and couldn’t find it.\r\n\r\nYou may have to and there is no Temporal documentation here (nor is there with any Python async library integration beyond builtin `asyncio`). Synchronous activities are just normal functions that can do anything you'd do in a normal Python call, so yes you do have to use those for non-`async def` functions. I suppose you may technically be able to use something like https://github.com/gfmio/asyncio-gevent but I have not tested and in general would not recommend altering the built-in `asyncio` event loop implementation (or doing any of gevent's global \"magic\"/\"patching\" if you can avoid it).","createdAt":"2022-06-29T16:23:06Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1170203602","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5Fwgse","author":{"login":"alecgorge"},"authorAssociation":"NONE","body":"Thanks for the context. I am planning on testing our gevent setup with Temporal. I will report back the results w/gevent version once I have done so","createdAt":"2022-06-29T18:26:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1170344734","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5Hcxgu","author":{"login":"alecgorge"},"authorAssociation":"NONE","body":"As a follow-up, we use gevent 1.3.7 and ran into a number of issues. We haven't done a full investigation but here are some of the things we did:\r\n* Only used synchronous activities\r\n* Set `activity_executor` to an instance of a gevent monekypatched `concurrent.future.ThreadPoolExecutor`\r\n* Avoided usage of any `WorkflowHandle.result()` calls (including `execute_workflow`) and prevented any gevent greenlets from executing\r\n\r\nWhen things worked, it was awesome! Unfortunately, in general we experienced unpredictable behavior in our code where it would mysteriously hang indefinitely (usually around monkeypatched IO calls). We haven't had time to dig in and identify exactly where the incompatibility is. We have a general sense of uneasiness of using gevent monkeypatched code with asyncio code.\r\n\r\nIf I have time, I'm going to try an experiment where I run Temporal in a process forked off before gevent monkeypatching and using a cross-process executor. I don't expect it to work, but it is a fun exercise!","createdAt":"2022-07-28T23:34:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1198725166","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5L09cx","author":{"login":"reallistic"},"authorAssociation":"NONE","body":"This is still failing on latest gevent (21.12.0) and temporalio (0.1b2).\r\n\r\n## Minimal code to reproduce:\r\n```\r\nfrom gevent.monkey import patch_thread; patch_thread()\r\n\r\nimport asyncio\r\nfrom datetime import timedelta\r\n\r\nfrom temporalio import activity\r\nfrom temporalio import workflow\r\nfrom temporalio.client import Client\r\nfrom temporalio.service import RPCError, RPCStatusCode\r\nfrom temporalio.worker import Worker\r\n\r\n@activity.defn\r\nasync def get_name(prefix: str) -> str:\r\n    return f\"{prefix} angela\"\r\n\r\n\r\n@workflow.defn\r\nclass SimpleWorkflow:\r\n    @workflow.run\r\n    async def run(self) -> str:\r\n        return await workflow.execute_activity(\r\n            get_name,\r\n            \"Dear\",\r\n            start_to_close_timeout=timedelta(seconds=10),\r\n        )\r\n\r\n\r\nasync def start_temporal():\r\n    temporal_client = await Client.connect(\"localhost:7233\")\r\n    try:\r\n        await temporal_client.start_workflow(\r\n            SimpleWorkflow.run,\r\n            id=\"simple_workflow\",\r\n            task_queue=\"test-queue\",\r\n        )\r\n    except RPCError as e:\r\n        if e.status is not RPCStatusCode.ALREADY_EXISTS:\r\n            raise\r\n\r\n    worker = Worker(\r\n        temporal_client,\r\n        task_queue=\"test-queue\",\r\n        workflows=[SimpleWorkflow],\r\n        activities=[get_name],\r\n    )\r\n    await worker.run()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(start_temporal())\r\n\r\n```\r\n\r\n## Error\r\n```\r\nFailed handling activation on workflow with run ID f5df1f62-b1b3-4a84-8af8-0837c77e7208\r\nTraceback (most recent call last):\r\n  File \"/Users/michase/workspace/ntflx/fastapi_temporal_poc/.venv/lib/python3.9/site-packages/temporalio/worker/workflow.py\", line 186, in _handle_activation\r\n    completion = await asyncio.wait_for(\r\n  File \"/Users/michase/.newt-cache/pyenv/versions/cpython-3.9.14/lib/python3.9/asyncio/tasks.py\", line 435, in wait_for\r\n    loop = events.get_running_loop()\r\nRuntimeError: no running event loop\r\nFailed completing activation on workflow with run ID f5df1f62-b1b3-4a84-8af8-0837c77e7208\r\nTraceback (most recent call last):\r\n  File \"/Users/michase/workspace/ntflx/fastapi_temporal_poc/.venv/lib/python3.9/site-packages/temporalio/worker/workflow.py\", line 234, in _handle_activation\r\n    await self._bridge_worker().complete_workflow_activation(completion)\r\n  File \"/Users/michase/workspace/ntflx/fastapi_temporal_poc/.venv/lib/python3.9/site-packages/temporalio/bridge/worker.py\", line 98, in complete_workflow_activation\r\n    await self._ref.complete_workflow_activation(comp.SerializeToString())\r\nRuntimeError: no running event loop\r\n```\r\n\r\n## Explanation\r\n**NOTE** that only threading needs to be patched\r\n\r\nI believe there is something funky with how gevent patches thread locals and how thread locals are used to store the current event loop.\r\n\r\nThe code [here](https://github.com/temporalio/sdk-python/blob/main/temporalio/worker/workflow_instance.py#L1190) that calls `asyncio._set_running_loop(None)` is overwriting the loop on the main thread instead of in the thread in use from spawning the workflow in a thread pool executor [here](https://github.com/temporalio/sdk-python/blob/main/temporalio/worker/workflow.py#L178). This happens on the main thread because the worker thread pool executor spawns greenlets instead of true threads. The greenlets run on the main thread. Under the hood, pure-python uses a [thread local](https://github.com/python/cpython/blob/3.9/Lib/asyncio/events.py#L673-L677) to manage the running loop and gevent should be patching that. However, cpython manages this using a [c specific implementation](https://github.com/python/cpython/blob/3.9/Modules/_asynciomodule.c#L292) that gevent cannot patch.\r\n\r\n\r\nSimilar to @alecgorge I tried to pass in a `gevent.threadpool.ThreadPoolExecutor` to the worker but the futures it returns are not asyncio compliant and raise `ValueError` for calls such as `asyncio.ensure_future` (which is invoked under [`wait_for`](https://github.com/temporalio/sdk-python/blob/main/temporalio/worker/workflow.py#L186)). There may be a way to patch the gevent `ThreadPoolExecutor` in a simple subclass but I have not looked into that.\r\n\r\n\r\n## Potential fix\r\nUse `set_event_loop` and `get_event_loop` instead. Those implementations do still use the underlying c calls for `get_running_loop`. However, with this I can push the worker into a real thread. The base event loop policy does not create a new loop in the non-main thread so it should prevent `_get_running_loop` from returning a value and, instead the event loop policy will be used for managing the loop. That maintains a thread local that can be patched.\r\n\r\nI will add an example with this soon.","createdAt":"2022-10-08T00:19:34Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1272174385","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5L6iLZ","author":{"login":"reallistic"},"authorAssociation":"NONE","body":"After a deep dive into the asyncio code I found that a running loop always sets the c specific thread local and there is no (easy) way around that.\r\n\r\nThat said, I was able to get the gevent `ThreadPoolExecutor` working with the following:\r\n```\r\n    worker = Worker(\r\n        temporal_client,\r\n        task_queue=\"test-queue\",\r\n        workflows=[SimpleWorkflow],\r\n        activities=[get_name],\r\n        workflow_task_executor=CFGThreadPool(4)\r\n    )\r\n    await worker.run()\r\n\r\nclass CFGThreadPool(gevent.threadpool.ThreadPoolExecutor):\r\n    def _set_result_and_wake(self, fut, loop, result, exc_info):\r\n        if fut.cancelled():\r\n            return\r\n\r\n        # call_soon_threadsafe wakes up the loop under the hood\r\n        if exc_info is not None:\r\n            loop.call_soon_threadsafe(fut.set_exception, exc_info)\r\n        else:\r\n            loop.call_soon_threadsafe(fut.set_result, result)\r\n\r\n    def submit(self, func, *args, **kwargs):\r\n        loop = asyncio.get_running_loop()\r\n        fut = concurrent.futures.Future()\r\n\r\n        @functools.wraps(func)\r\n        def wrapper(*w_args, **w_kwargs) -> None:\r\n\r\n            result = None\r\n            exc_info = None\r\n\r\n            try:\r\n                result = func(*w_args, **w_kwargs)\r\n            except Exception as ex:\r\n                exc_info = ex\r\n\r\n            self._set_result_and_wake(fut, loop, result, exc_info)\r\n\r\n            return result\r\n\r\n\r\n        super().submit(wrapper, *args, **kwargs)\r\n        return fut\r\n\r\n\r\n```","createdAt":"2022-10-10T17:42:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1273635545","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5L6koo","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"@reallistic - Thanks for this deep dive. I have this on my schedule to dig into and even write an integration test for (if isolatable, i.e. can \"unpatch\" afterwards). \r\n\r\n> Use `set_event_loop` and `get_event_loop` instead.\r\n\r\nI think this is the right approach and we should do this if it in fact fixes it. Who knows who else is setting default event loops on threads somehow. I just set to `None` because I thought I was in control of the thread.","createdAt":"2022-10-10T17:53:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1273645608","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5L6qlV","author":{"login":"reallistic"},"authorAssociation":"NONE","body":"> I just set to `None` because I thought I was in control of the thread. \r\n\r\nThis is 100% sane and reasonable. The issue is that gevent monkey patches pure python threading but not the c implementation.\r\n\r\nAlso, changing `_(s|g)et_running_loop` to `(s|g)et_event_loop` is a good idea to prevent changes in the private API from breaking things.\r\n\r\nHowever, using those apis does not help out with gevent. This is because the main loop used to connect the client and run the `Worker` (not the `_WorkflowInstanceImpl `) has to be running via either `asyncio.run` or `loop.run_until_complete`. Both implementations call `_set_running_loop` which sets the loop directly on the c thread local. The public `get_event_loop` call first calls `_get_running_loop` prior to consulting `get_event_loop_policy().get_event_loop()`. Thus, when gevent monkey patches threading, the main loop will always be returned effectively ignoring the public `set_event_loop`.\r\n\r\nThe only approach I can think of to allow gevent to work would be to use regular asyncio calls instead of a custom event loop. I recognize though that doing such an implementation would require a decent amount of work and you would lose the safeguards of preventing multi-threading etc.","createdAt":"2022-10-10T18:23:50Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1273669973","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5L60Bb","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> Also, changing _(s|g)et_running_loop to (s|g)et_event_loop is a good idea to prevent changes in the private API from breaking things.\r\n\r\nCompletely agree, but there was something w/ the default event loop policy on some platform I think was causing me problems. But I forget what and I didn't document it, so will definitely try to move back to all public API.\r\n\r\n> The only approach I can think of [...]\r\n\r\nWe really have to keep our custom event loop. It's the underpinning of what makes workflows work well.\r\n\r\nMaybe we can have a similar monkey patch that overrides gevent for the life of the run_once and then puts it back after. I'll have to check gevent, but surely we're not the first that have wanted to do advanced asyncio loop management in a gevent-enabled process. I'll have to dig into what they really do. I only need a short synchronous window to own the loop on a thread run.\r\n","createdAt":"2022-10-10T19:09:34Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1273708635","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5oy79h","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"I am happy to report I have succeeded combining gevent and Temporal: https://github.com/temporalio/samples-python/pull/84. @reallistic - I basically took your approach but I created a _separate_ executor for running the asyncio event loop in a native gevent thread (separate from the executor that is used to execute workflow/activity tasks).\r\n\r\nI will have to update the README in this repo with the update and then I'll be able to close this out I think unless I'm missing something.","createdAt":"2023-10-11T17:47:32Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/59#issuecomment-1758183265","viewerDidAuthor":false}],"createdAt":"2022-06-29T14:29:00Z","labels":[{"id":"LA_kwDOGusT1c7gQgHN","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":59,"reactionGroups":[],"state":"CLOSED","title":"Investigate issues with gevent.monkey.patch_all()","updatedAt":"2023-10-24T13:20:42Z","url":"https://github.com/temporalio/sdk-python/issues/59"}
