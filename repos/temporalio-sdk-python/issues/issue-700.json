{"assignees":[],"author":{"id":"MDQ6VXNlcjUzMDgwMjQ=","is_bot":false,"login":"andmis","name":"Andrey Mishchenko"},"body":"### What are you really trying to do?\r\n\r\n<!-- \r\nTell us at a high level what you're doing, to avoid XY problem (https://en.wikipedia.org/wiki/XY_problem) \r\n-->\r\n\r\nStart an activity from a workflow, cancel it, wait for clean cancellation acknowledgement, exit the workflow.\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n<!-- If applicable, add screenshots or code blocks to help explain your problem. You can also use [Loom](http://loom.com/) to do short, free video bug reports. -->\r\n\r\nThere appear to be several issues.\r\n1. If you call `handle.cancel()` on an activity handle from the workflow, the `CancelledError` will only be raised in the activity _after_ an `activity.heartbeat()` call, _followed_ by an `await something()` call. Otherwise the activity itself doesn't seem to receive `CancelledError`. This kinda sucks -- both that you need to call `heartbeat()` for cancellation requests to get through, and the fact that long-running coros do not get interrupted correctly. I don't understand the underlying implementation, but if the reason we need to `heartbeat()` is that workers don't want to poll for cancellation, still, when you call `activity.heartbeat()`, the client library could check for cancellation and immediately call `task.cancel()` on the task running the activity, no? Currently the work-around seems to be to litter activity code with `asyncio.sleep(0.1)`.\r\n2. From the workflow code, if you want to cleanly wait for the activity cancellation, you have to catch `ActivityError`, which is a broader exception type than I actually want to catch (presumably there are other `ActivityError`s which I don't want to catch).\r\n3. If you use `WAIT_CANCELLATION_COMPLETED`, if you try to cancel an activity that's currently awaiting a long-running coro (like `asyncio.sleep(10)`), the activity won't receive a `CancelledError` until it sends a heartbeat, which it can't do until the coro it's waiting on finishes, so your workflow won't finish until the activity's long-running coro finishes.\r\n\r\n### Minimal Reproduction\r\n\r\n<!-- \r\nModify our hello world templates to demonstrate:\r\n\r\n- TypeScript: https://github.com/temporalio/samples-typescript/tree/main/hello-world\r\n- Go: https://github.com/temporalio/money-transfer-project-template-go\r\n- Java: https://github.com/temporalio/money-transfer-project-template-java\r\n- PHP: https://github.com/temporalio/samples-php#samples\r\n-->\r\n\r\nhttps://github.com/andmis/snippets/tree/temporal-python-sdk-cannot-cleanly-cancel-activities\r\n\r\nUsing `python run_workflow.py` with no args, the workflow exits promptly, but the activity never receives `CancelledError`, completes, and we get warning log spam:\r\n```\r\n2024-12-09 19:44:06.116611+00:00 (Workflow) Starting, use_sleep=False use_wait=False\r\n2024-12-09 11:44:06.124587 (Activity) Running sandbox_activity\r\n2024-12-09 19:44:07.130422+00:00 (Workflow) Cancelling activity\r\n2024-12-09 19:44:07.130422+00:00 (Workflow) Activity cancelled\r\n2024-12-09 19:44:07.130422+00:00 (Workflow) Exiting\r\n2024-12-09 11:44:12.868185 (Activity) Completing sandbox_activity\r\n2024-12-09T19:44:12.881460Z  WARN temporal_sdk_core::worker::activities: Activity not found on completion. This may happen if the activity has already been cancelled but completed anyway. task_token=TaskToken(CiRhOTc2ZWZkMy1iM2NiLTQwZmMtOWYzZi1jNjk0MzU2NjMzN2ESEHNhbmRib3gtd29ya2Zsb3caJDVhMjAyNWI3LWRhY2MtNDg4OC04NjA5LWI3NGQ3MzI2MzA3YyAFKAEyATFCEHNhbmRib3hfYWN0aXZpdHlKCAgBEIeKQBgB) details=Status { code: NotFound, message: \"workflow execution already completed\", details: b\"\\x08\\x05\\x12$workflow execution already completed\\x1aB\\n@type.googleapis.com/temporal.api.errordetails.v1.NotFoundFailure\", metadata: MetadataMap { headers: {\"content-type\": \"application/grpc\"} }, source: None }\r\n```\r\n\r\nUsing `python run_workflow.py -w`, the workflow waits until the activity's long-running `sleep` finishes, despite the activity being cancelled (note timestamps), and the activity completes rather than being cancelled:\r\n```\r\n2024-12-09 19:45:15.119427+00:00 (Workflow) Starting, use_sleep=False use_wait=True\r\n2024-12-09 11:45:15.127826 (Activity) Running sandbox_activity\r\n2024-12-09 19:45:16.130733+00:00 (Workflow) Cancelling activity\r\n2024-12-09 11:45:24.371849 (Activity) Completing sandbox_activity\r\n2024-12-09 19:45:24.384356+00:00 (Workflow) Exiting\r\n```\r\n\r\nUsing `python run_workflow.py -w -s`, the workflow waits for the long-running coro in the activity to finish, which is bad, and the activity does cancel rather than completing, but `-s` sucks:\r\n```\r\n2024-12-09 19:47:00.283375+00:00 (Workflow) Starting, use_sleep=True use_wait=True\r\n2024-12-09 11:47:00.291593 (Activity) Running sandbox_activity\r\n2024-12-09 19:47:01.301447+00:00 (Workflow) Cancelling activity\r\n2024-12-09 11:47:06.547612 (Activity) Cancelling sandbox_activity\r\n2024-12-09 19:47:06.551643+00:00 (Workflow) Activity cancelled\r\n2024-12-09 19:47:06.551643+00:00 (Workflow) Exiting\r\n```\r\n\r\nUsing `python run_workflow.py -s` results in the workflow exiting cleanly and promptly (since we aren't using `WAIT_CANCELLATION_COMPLETED`), and the activity cancels rather than completing, but still waits on the long-running coro:\r\n```\r\n2024-12-09 19:48:40.102363+00:00 (Workflow) Starting, use_sleep=True use_wait=False\r\n2024-12-09 11:48:40.110083 (Activity) Running sandbox_activity\r\n2024-12-09 19:48:41.121725+00:00 (Workflow) Cancelling activity\r\n2024-12-09 19:48:41.121725+00:00 (Workflow) Activity cancelled\r\n2024-12-09 19:48:41.121725+00:00 (Workflow) Exiting\r\n2024-12-09 11:48:47.629316 (Activity) Cancelling sandbox_activity\r\n```\r\n\r\n## Environment/Versions\r\n\r\nOS and processor: macOS, M1\r\nTemporal version: 1.1.2\r\nPython SDK version: 1.8.0\r\nAre you using Docker or Kubernetes or building Temporal from source? No\r\n","closedAt":null,"comments":[{"id":"IC_kwDOGusT1c6WwoW5","author":{"login":"andmis"},"authorAssociation":"NONE","body":"Sorry if this report is a bit garbled -- I'd say the real issue is \"there does not seem to be a clean, blessed way of doing this\".","createdAt":"2024-12-09T20:04:34Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2529330617","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6Ww5vN","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> If you call handle.cancel() on an activity handle from the workflow, the CancelledError will only be raised in the activity after an activity.heartbeat() call, followed by an await something() call. Otherwise the activity itself doesn't seem to receive CancelledError.\r\n\r\nThis is how Python asyncio cancellation works. It only can issue a cancel at the await point. The snippet you show completes the activity immediately after calling the non-blocking heartbeat, so I would not expect it to fail because it has completed.\r\n\r\n> From the workflow code, if you want to cleanly wait for the activity cancellation, you have to catch ActivityError, which is a broader exception type than I actually want to catch (presumably there are other ActivityErrors which I don't want to catch).\r\n\r\nUse the `__cause__` (aliased as `cause`) to differentiate\r\n\r\n> the activity won't receive a CancelledError until it sends a heartbeat, which it can't do until the coro it's waiting on finishes, so your workflow won't finish until the activity's long-running coro finishes.\r\n\r\nThis is the nature of heartbeating. The server only relays cancellation on heartbeating to the worker, so if you're not heartbeating you're not receiving cancellation. You can run heartbeating in a background task or you can do something like sleep for a short period and heartbeat every so often. Also, heartbeats are throttled to within 0.8 times the heartbeat timeout anyways but you are not setting the heartbeat timeout so it uses a really high default.\r\n\r\nSee:\r\n\r\n* https://docs.temporal.io/develop/python/failure-detection#activity-heartbeats\r\n* https://docs.temporal.io/encyclopedia/detecting-activity-failures#activity-heartbeat\r\n* https://github.com/temporalio/sdk-python?tab=readme-ov-file#heartbeating-and-cancellation\r\n\r\nEtc to better understand how heartbeating and activity cancellation work together.","createdAt":"2024-12-09T20:41:04Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2529401805","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6Ww7JM","author":{"login":"andmis"},"authorAssociation":"NONE","body":"**edit:** ignore this post, i misunderstood something above.\r\n\r\n---\r\n\r\n> This is how Python asyncio cancellation works. It only can issue a cancel at the await point. The snippet you show completes the activity immediately after calling the non-blocking heartbeat, so I would not expect it to fail because it has completed.\r\n\r\nIt's possible for `task.cancel()` to interrupt a coro such as `sleep`:\r\n\r\n<img width=\"406\" alt=\"image\" src=\"https://github.com/user-attachments/assets/b6d1891e-76cc-4065-bbd1-703811c8e031\">\r\n","createdAt":"2024-12-09T20:44:24Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2529407564","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6Ww_iU","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> It's possible for task.cancel() to interrupt a coro such as sleep:\r\n\r\nRight, if `use_sleep` is set, that makes sense, it was just a bit strange to see an activity that could heartbeat and then complete immediately. But regardless, to the later point, in this case you are choosing to sleep without heartbeating which means the worker never even gets notified while sleeping that the activity is cancelling. You should heartbeat while sleeping if you want to cancel while sleeping.","createdAt":"2024-12-09T20:54:15Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2529425556","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6WxCtl","author":{"login":"andmis"},"authorAssociation":"NONE","body":"IIUC the point of the activity issuing a heartbeat is to let the server know it's still healthy. it sounds like your advice is that i could create a separate `asyncio.Task` and heartbeat from that task, and then i would get `CancelledError` interrupting my long-running coro.\r\n\r\nso IIUC, `activity.heartbeat()` basically means `send_heartbeat_to_server_and_check_for_cancellation()`. is that right?","createdAt":"2024-12-09T21:01:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2529438565","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6WxFSK","author":{"login":"andmis"},"authorAssociation":"NONE","body":"i'd suggest noting in the docs the exact semantics here.\r\n\r\nthese docs make it sound like you can just `handle.cancel()` and that will work: https://python.temporal.io/temporalio.workflow.ActivityHandle.html\r\n\r\nit sounds like the semantics are something like this, i'd appreciate clarification as well:\r\n- call `handle.cancel()`\r\n- from your activity code, call `activity.heartbeat()`\r\n- after `handle.cancel()` followed by `acvitity.heartbeat()`, we will call `task.cancel()` on the root `asyncio.Task` running your activity","createdAt":"2024-12-09T21:06:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2529449098","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6WxqHw","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> these docs make it sound like you can just handle.cancel() and that will work\r\n\r\nIn Python asyncio, calling cancel on a task doesn't immediately cancel always (or at all), it's up to the implementation for how to handle. Some tasks may swallow cancel, some shield, some may do cleanup first, or in our case we communicate it with a server. But it does work in that the request is sent to the server and put on history (assuming activity is not complete), it's just not necessarily processed immediately. We will see about clarifying in the docs that Python asyncio Task cancellation (and explicit Temporal workflow activity cancellation in all Temporal languages) is actually a cancellation request.\r\n\r\n> after handle.cancel() followed by acvitity.heartbeat(), we will call task.cancel() on the root asyncio.Task running your activity\r\n\r\nYes, though there are of course caveats concerning heartbeat throttling so it's not always immediately on heartbeating.","createdAt":"2024-12-09T21:50:58Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2529599984","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6k9wL1","author":{"login":"spacether"},"authorAssociation":"NONE","body":"It looks like [activity file handles extend asyncio.Task](https://python.temporal.io/temporalio.workflow.ActivityHandle.html).\nSo can one use workflow.wait_condition until activity_handle.canceled() is True?\nhmm that did not work for us, but checking for activity_handle.done worked","createdAt":"2025-03-31T23:35:42Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2767651573","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6lEHzy","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":">  So can one use workflow.wait_condition until activity_handle.canceled() is True?\n\nThe proper way is to wait on the activity task/handle itself, catching the `ActivityError` and checking that the `cause` is `CancelledError`, though yes `done()` may work. As for cancelled helpers on activity and child workflow tasks, I opened #810 on that.","createdAt":"2025-04-01T13:13:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2769321202","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6roXar","author":{"login":"teije01"},"authorAssociation":"NONE","body":"The way we went about this is the following:\n\n```python\ntry:\n    await workflow.execute_xxx(...)\nexcept exceptions.ActivityError as e:\n    if e.retry_state == exceptions.RetryState.CANCEL_REQUESTED:\n        handle_explicit_cancellation_teardown()\n```\n\nor for a full activity example (heartbeat util from: https://github.com/temporalio/samples-python/blob/main/custom_decorator/activity_utils.py)\n```python\nimport asyncio\nimport datetime as dt\n\nfrom temporalio import activity, exceptions, workflow\n\nclass HelloGoodbyeActivities:\n    def __init__(self):\n        pass\n\n    @activity.defn\n    @heartbeat_utils.periodic_heartbeater\n    async def say_hello(self):\n        \"\"\"Demo activity for saying hello.\"\"\"\n        activity.logger.info(\"activity=say_hello fired\")\n        for _ in range(5):\n            activity.logger.info(\"Hello!\")\n            await asyncio.sleep(10)\n\n    @activity.defn\n    async def say_goodbye(self):\n        \"\"\"Demo activity for saying goodbye.\"\"\"\n        activity.logger.info(\"Goodbye!\")\n\n    @classmethod\n    async def hello_goodbye(cls):\n        try:\n            await workflow.execute_activity_method(\n                cls.say_hello,\n                start_to_close_timeout=dt.timedelta(minutes=1),\n                heartbeat_timeout=dt.timedelta(seconds=10),\n            )\n            await workflow.execute_activity_method(\n                cls.say_goodbye, start_to_close_timeout=dt.timedelta(seconds=10)\n            )\n        except exceptions.ActivityError as e:\n            if e.retry_state == exceptions.RetryState.CANCEL_REQUESTED:\n                workflow.logger.exception(\n                    f\"Workflow canceled: {type(e.cause)}({e}), {e.retry_state=}\"\n                )\n                await workflow.execute_activity_method(\n                    cls.say_goodbye, start_to_close_timeout=dt.timedelta(seconds=10)\n                )\n            else:\n                workflow.logger.exception(\n                    f\"Workflow failed: {e.cause} {type(e.cause)}({e}), {e.retry_state=}\"\n                )\n            raise\n        except Exception as e:\n            workflow.logger.exception(f\"Unknown exception: {e}, {e.__dict__}\")\n\n\n\n@workflow.defn\nclass SayHello:\n    @workflow.run\n    async def run(self) -> None:\n        return await HelloGoodbyeActivities.hello_goodbye()\n```\n\nThis example would always get to the say_goodbye activity, no matter when it was cancelled (even after a worker restart).","createdAt":"2025-05-14T09:27:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/700#issuecomment-2879485611","viewerDidAuthor":false}],"createdAt":"2024-12-09T19:54:17Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":700,"reactionGroups":[],"state":"OPEN","title":"[Bug] No clean way to cancel an activity and wait until it's cancelled","updatedAt":"2025-05-14T09:27:41Z","url":"https://github.com/temporalio/sdk-python/issues/700"}
