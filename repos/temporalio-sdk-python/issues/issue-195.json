{"assignees":[],"author":{"id":"MDQ6VXNlcjE0MDMwNzQ=","is_bot":false,"login":"mikedh","name":"Michael Dawson-Haggerty"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\nThanks for the great work on this project! I'm not sure if this is possible using temporal, but if it is not precluded by design it would be nice to have intermediate results from long-running iterable functions. I think this has a number of applications, i.e. something like someone uploads a zip file of images and a processing engine iterates through them generating thumbnails. \r\n\r\nI tried a whole bunch of ways (unsuccessfully), using both the latest wheels on `pip` and bleeding edge ones from an actions build (`temporalio-0.1b2-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl`, post-#175). I was able to get it to work just fine returning `list` after completion, but was not able to have intermediate results returned. Happy to PR an example if this is at all possible!\r\n\r\n### Describe the solution you'd like\r\n\r\nIt would be nice to have a few examples in the repo, like `examples/iterable/serve.py`. Here's a working snippet based off the one in the readme: \r\n\r\n`serve.py`:\r\n```\r\nimport asyncio\r\nfrom datetime import timedelta\r\nfrom temporalio import workflow, activity\r\nfrom temporalio.client import Client\r\nfrom temporalio.worker import Worker\r\n\r\nimport time\r\nfrom typing import AsyncIterator\r\n\r\n\r\n@activity.defn\r\nasync def say_hello(name: str) -> AsyncIterator[str]:\r\n    for letter in name:\r\n        # some long-running task, probably synchronous\r\n        time.sleep(1.0)\r\n        # this example works with a \"return\" but it would\r\n        # be nice to be able to do:\r\n        # `yield letter`\r\n        return letter\r\n\r\n\r\n@workflow.defn\r\nclass SayHello:\r\n    @workflow.run\r\n    async def run(self, name: str) -> str:\r\n        return await workflow.execute_activity(\r\n            say_hello,\r\n            name,\r\n            schedule_to_close_timeout=timedelta(seconds=5))\r\n\r\n\r\nasync def main():\r\n    # Create client connected to server at the given address\r\n    client = await Client.connect(\"localhost:7233\")\r\n\r\n    # Run the worker\r\n    worker = Worker(\r\n        client,\r\n        task_queue=\"my-task-queue\",\r\n        workflows=[SayHello],\r\n        activities=[say_hello])\r\n    await worker.run()\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```\r\n\r\n`run.py`:\r\n```\r\nimport asyncio\r\nfrom uuid import uuid4\r\nfrom temporalio.client import Client\r\n\r\n# Import the workflow from the previous code\r\nfrom serve import SayHello\r\n\r\n\r\nasync def main():\r\n    # Create client connected to server at the given address\r\n    client = await Client.connect(\"localhost:7233\")\r\n\r\n    result = await client.execute_workflow(\r\n        SayHello.run,\r\n        \"my name\",\r\n        task_queue='my-task-queue',\r\n        id=str(uuid4()))\r\n    print(f\"Result: {result}\")\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```\r\n","closedAt":"2022-11-14T17:28:07Z","comments":[{"id":"IC_kwDOGusT1c5OTeFq","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> I was able to get it to work just fine returning list after completion, but was not able to have intermediate results returned.\r\n\r\nThe way Temporal works for activities is to run the activity and serialize its results back to the workflow. There is no concept of \"intermediate results\" in Temporal I am afraid. You'll have to rework your code if you need something different.\r\n\r\nIf you must have a long-running activity communicate with the workflow before the activity is complete, some people resort to signalling back to the calling workflow from the activity using a Temporal client (can make the Temporal client a member of a class and the activity a method on the class and use start/execute_activity_method). Don't forget to set a heartbeat timeout and perform heartbeats on non-immediate activities.","createdAt":"2022-11-14T13:38:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/195#issuecomment-1313726826","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5OU-uG","author":{"login":"mikedh"},"authorAssociation":"NONE","body":"> signalling back to the calling workflow \r\n\r\nThanks for the suggestion! I'll give that a try.","createdAt":"2022-11-14T17:28:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/195#issuecomment-1314122630","viewerDidAuthor":false}],"createdAt":"2022-11-11T20:43:32Z","labels":[{"id":"LA_kwDOGusT1c7gQgHN","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":195,"reactionGroups":[],"state":"CLOSED","title":"[Feature Request] Iterable Intermediate Results","updatedAt":"2022-11-14T17:28:07Z","url":"https://github.com/temporalio/sdk-python/issues/195"}
