{"assignees":[],"author":{"id":"U_kgDOC4PsuA","is_bot":false,"login":"xih1919","name":""},"body":"My activity tasks are concurrent with 10. If the number of ExecuteWorkflow declarations is greater than 10 at the same time, for example 20, my first 10 activities will be executed normally, and the next 10 activities will be Cancelled before the start_to_close_timeout is reached.\n\nIt looks like self._bridge_worker().poll_activity_task() in temporalio/worker/_activity.py gets the activity task, and after getting it, the start timer starts. Since the thread pool is full, the subsequent tasks will be blocked, but they will continue to time, causing the subsequent tasks to be canceled before reaching the start_to_close_time.\n\n\nThe following is my approximate configuration：\n```\n    // golang ExecuteWorkflow\n\tworkflowOptions := client.StartWorkflowOptions{\n\t\tID:        req.TaskId,\n\t\tTaskQueue: Queue, // 队列名\n\t}\n\tTask := models.Task{\n\t\tTaskID:      req.TaskId,\n\t}\n\n\t_, err := TemporalClient.ExecuteWorkflow(\n\t\tcontext.Background(), workflowOptions, task.Workflow, Task)\n\t\n\t\n\t// python Worker and execute_activity\n\twith ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:\n        worker = Worker(\n            temporal_client.client,\n            task_queue=TASK_QUEUE,\n            workflows=[TaskClass],\n            activity_executor=executor,\n            activities=[task_activity],\n            workflow_runner=custom_runner,\n        )\n        await worker.run()\n\t\t\n\t\t\n\t@workflow.defn(name=\"workflow-test\")\n    class TaskClass:\n\t\t@workflow.run\n\t\tasync def run(self, task: Task):\n\t\t\ttask_retry_policy = RetryPolicy(\n\t\t\t\tinitial_interval=timedelta(\n\t\t\t\t\tseconds=TEMPORAL_CONFIG.task_initial_interval // 15s\n\t\t\t\t),\n\t\t\t\tmaximum_attempts=TEMPORAL_CONFIG.task_maximum_attempts, // 2\n\t\t\t)\n\t\t\tawait workflow.execute_activity(\n\t\t\t\tactivity=task_activity,\n\t\t\t\targ=task,\n\t\t\t\tstart_to_close_timeout=timedelta(\n\t\t\t\t\tseconds=TEMPORAL_CONFIG.task_execute_time # 120s \n\t\t\t\t),\n\t\t\t\tretry_policy=task_retry_policy,\n\t\t\t)\n```\n\n\n```\n2025-10-09 12:41:14,340.340 12112 INFO ../task_activity.py:19:task_activity() start task_activity: 9135dc0b-fb8d-42a2-a81b-9007361170aa\n2025-10-09 12:41:58,395.395 12112 ERROR ../my_task_activity.py:61:handle_cancelled_error() task 9135dc0b-fb8d-42a2-a81b-9007361170aa execute exceeds 120.0 s\n[trace-0a46e1632c9f41ef]Traceback (most recent call last):\n[trace-0a46e1632c9f41ef][trace-0a46e1632c9f41ef]  File \"../task_activity.py\", line 20, in task_activity\n[trace-0a46e1632c9f41ef]    task.strategy.execute_task()\n[trace-0a46e1632c9f41ef][trace-0a46e1632c9f41ef]  File \"../strategy.py\", line 46, in execute_task\n[trace-0a46e1632c9f41ef]    self.execute(task_id=self.task_id)\n[trace-0a46e1632c9f41ef][trace-0a46e1632c9f41ef]  File \"../strategy.py\", line 145, in execute\n[trace-0a46e1632c9f41ef]    self.flow_result = alarm_run(task_id)\n[trace-0a46e1632c9f41ef][trace-0a46e1632c9f41ef]  File \"../flow.py\", line 396, in alarm_run\n[trace-0a46e1632c9f41ef]    time.sleep(1)\n[trace-0a46e1632c9f41ef][trace-0a46e1632c9f41ef]temporalio.exceptions.CancelledError: Cancelled\n\n\n\n{\n  \"events\": [\n    {\n      \"eventId\": \"1\",\n      \"eventTime\": \"2025-10-09T12:39:50.253818124Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_EXECUTION_STARTED\",\n      \"taskId\": \"2928672812\",\n      \"workflowExecutionStartedEventAttributes\": {\n        \"workflowType\": {\n          \"name\": \"workflow-test\"\n        },\n        \"taskQueue\": {\n          \"name\": \"queue-test\",\n          \"kind\": \"TASK_QUEUE_KIND_NORMAL\"\n        },\n        \"input\": {\n          \"payloads\": [\n            {\n              \"metadata\": {\n                \"encoding\": \"anNvbi9wbGFpbg==\"\n              },\n              \"data\": {\n                \"task_id\": \"9135dc0b-fb8d-42a2-a81b-9007361170aa\",\n                \"trigger_type\": \"alarm\"\n              }\n            }\n          ]\n        },\n        \"workflowExecutionTimeout\": \"0s\",\n        \"workflowRunTimeout\": \"0s\",\n        \"workflowTaskTimeout\": \"10s\",\n        \"originalExecutionRunId\": \"0c8517cd-d3f7-4b02-a607-2d613dd8269b\",\n        \"identity\": \"122992@api-kt@\",\n        \"firstExecutionRunId\": \"0c8517cd-d3f7-4b02-a607-2d613dd8269b\",\n        \"attempt\": 1,\n        \"firstWorkflowTaskBackoff\": \"0s\",\n        \"header\": {},\n        \"workflowId\": \"9135dc0b-fb8d-42a2-a81b-9007361170aa\"\n      }\n    },\n    {\n      \"eventId\": \"2\",\n      \"eventTime\": \"2025-10-09T12:39:50.253854783Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_TASK_SCHEDULED\",\n      \"taskId\": \"2928672813\",\n      \"workflowTaskScheduledEventAttributes\": {\n        \"taskQueue\": {\n          \"name\": \"queue-test\",\n          \"kind\": \"TASK_QUEUE_KIND_NORMAL\"\n        },\n        \"startToCloseTimeout\": \"10s\",\n        \"attempt\": 1\n      }\n    },\n    {\n      \"eventId\": \"3\",\n      \"eventTime\": \"2025-10-09T12:39:52.742335867Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_TASK_STARTED\",\n      \"taskId\": \"2928672854\",\n      \"workflowTaskStartedEventAttributes\": {\n        \"scheduledEventId\": \"2\",\n        \"identity\": \"12112@tmp-kt\",\n        \"requestId\": \"d153ab16-84a5-4a27-9636-b9bb7db5ebe4\",\n        \"historySizeBytes\": \"403\"\n      }\n    },\n    {\n      \"eventId\": \"4\",\n      \"eventTime\": \"2025-10-09T12:39:52.777696270Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_TASK_COMPLETED\",\n      \"taskId\": \"2928672860\",\n      \"workflowTaskCompletedEventAttributes\": {\n        \"scheduledEventId\": \"2\",\n        \"startedEventId\": \"3\",\n        \"identity\": \"12112@tmp-kt\",\n        \"workerVersion\": {\n          \"buildId\": \"14de874560c3a2202fb30bb2b7483138\"\n        },\n        \"sdkMetadata\": {\n          \"coreUsedFlags\": [\n            1,\n            3,\n            2\n          ],\n          \"sdkName\": \"temporal-python\",\n          \"sdkVersion\": \"1.14.1\"\n        },\n        \"meteringMetadata\": {}\n      }\n    },    \n    {\n      \"eventId\": \"5\",\n      \"eventTime\": \"2025-10-09T12:39:52.777784956Z\",\n      \"eventType\": \"EVENT_TYPE_ACTIVITY_TASK_SCHEDULED\",\n      \"taskId\": \"2928672861\",\n      \"activityTaskScheduledEventAttributes\": {\n        \"activityId\": \"1\",\n        \"activityType\": {\n          \"name\": \"task_activity\"\n        },\n        \"taskQueue\": {\n          \"name\": \"queue-test\",\n          \"kind\": \"TASK_QUEUE_KIND_NORMAL\"\n        },\n        \"header\": {},\n        \"input\": {\n          \"payloads\": [\n            {\n              \"metadata\": {\n                \"encoding\": \"anNvbi9wbGFpbg==\"\n              },\n              \"data\": {\n                \"task_id\": \"9135dc0b-fb8d-42a2-a81b-9007361170aa\",\n                \"trigger_type\": \"alarm\"\n              }\n            }\n          ]\n        },\n        \"scheduleToCloseTimeout\": \"0s\",\n        \"scheduleToStartTimeout\": \"0s\",\n        \"startToCloseTimeout\": \"120s\",\n        \"heartbeatTimeout\": \"0s\",\n        \"workflowTaskCompletedEventId\": \"4\",\n        \"retryPolicy\": {\n          \"initialInterval\": \"15s\",\n          \"backoffCoefficient\": 2,\n          \"maximumInterval\": \"1500s\",\n          \"maximumAttempts\": 2\n        },\n        \"useWorkflowBuildId\": true\n      }\n    },\n    {\n      \"eventId\": \"6\",\n      \"eventTime\": \"2025-10-09T12:42:07.837531112Z\",\n      \"eventType\": \"EVENT_TYPE_ACTIVITY_TASK_STARTED\",\n      \"taskId\": \"2928672919\",\n      \"activityTaskStartedEventAttributes\": {\n        \"scheduledEventId\": \"5\",\n        \"identity\": \"12112@tmp-kt\",\n        \"requestId\": \"685edd23-7c8f-4d8c-9c22-a3d9af4a086e\",\n        \"attempt\": 2,\n        \"lastFailure\": {\n          \"message\": \"activity StartToClose timeout\",\n          \"source\": \"Server\",\n          \"timeoutFailureInfo\": {\n            \"timeoutType\": \"TIMEOUT_TYPE_START_TO_CLOSE\"\n          }\n        }\n      }\n    },\n    {\n      \"eventId\": \"7\",\n      \"eventTime\": \"2025-10-09T12:42:07.917188550Z\",\n      \"eventType\": \"EVENT_TYPE_ACTIVITY_TASK_COMPLETED\",\n      \"taskId\": \"2928672920\",\n      \"activityTaskCompletedEventAttributes\": {\n        \"result\": {\n          \"payloads\": [\n            {\n              \"metadata\": {\n                \"encoding\": \"YmluYXJ5L251bGw=\"\n              },\n              \"data\": null\n            }\n          ]\n        },\n        \"scheduledEventId\": \"5\",\n        \"startedEventId\": \"6\",\n        \"identity\": \"12112@tmp-kt\"\n      }\n    },\n    {\n      \"eventId\": \"8\",\n      \"eventTime\": \"2025-10-09T12:42:07.917199061Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_TASK_SCHEDULED\",\n      \"taskId\": \"2928672921\",\n      \"workflowTaskScheduledEventAttributes\": {\n        \"taskQueue\": {\n          \"name\": \"12112@tmp-kt-12e959e874744652ae08109ffb2fb9bc\",\n          \"kind\": \"TASK_QUEUE_KIND_STICKY\",\n          \"normalName\": \"queue-test\"\n        },\n        \"startToCloseTimeout\": \"10s\",\n        \"attempt\": 1\n      }\n    },\n        {\n      \"eventId\": \"9\",\n      \"eventTime\": \"2025-10-09T12:42:08.039527045Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_TASK_STARTED\",\n      \"taskId\": \"2928672929\",\n      \"workflowTaskStartedEventAttributes\": {\n        \"scheduledEventId\": \"8\",\n        \"identity\": \"12112@tmp-kt\",\n        \"requestId\": \"6f02fe0a-cc3a-4208-bb93-0a11eb104e35\",\n        \"historySizeBytes\": \"1196\"\n      }\n    },\n    {\n      \"eventId\": \"10\",\n      \"eventTime\": \"2025-10-09T12:42:08.120574717Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_TASK_COMPLETED\",\n      \"taskId\": \"2928672939\",\n      \"workflowTaskCompletedEventAttributes\": {\n        \"scheduledEventId\": \"8\",\n        \"startedEventId\": \"9\",\n        \"identity\": \"12112@tmp-kt\",\n        \"workerVersion\": {\n          \"buildId\": \"14de874560c3a2202fb30bb2b7483138\"\n        },\n        \"sdkMetadata\": {},\n        \"meteringMetadata\": {}\n      }\n    },\n    {\n      \"eventId\": \"11\",\n      \"eventTime\": \"2025-10-09T12:42:08.120635997Z\",\n      \"eventType\": \"EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED\",\n      \"taskId\": \"2928672940\",\n      \"workflowExecutionCompletedEventAttributes\": {\n        \"result\": {\n          \"payloads\": [\n            {\n              \"metadata\": {\n                \"encoding\": \"YmluYXJ5L251bGw=\"\n              },\n              \"data\": null\n            }\n          ]\n        },\n        \"workflowTaskCompletedEventId\": \"10\"\n      }\n    }\n  ]\n}\n\n```","closedAt":"2025-10-17T18:36:07Z","comments":[{"id":"IC_kwDOGusT1c7Lpjad","author":{"login":"tconley1428"},"authorAssociation":"MEMBER","body":"This is an intended behavior. `start_to_close_timeout` refers to the time allowed after a worker has accepted a task. This doesn't necessarily guarantee that the user code has reached an particular point of execution, which would not really be achievable in the general case. \n\nIn order to restrict the number of activities a worker can process at once, you should use Temporal provided tuning mechanisms, many of which are detailed in https://docs.temporal.io/develop/worker-performance. In Python, you can use the `max_concurrent_activities` argument on a worker. For more complex situations, you can look at slot suppliers. A fixed size slot supplier for activities would likely be what you are trying to accomplish.","createdAt":"2025-10-17T18:36:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1168#issuecomment-3416667805","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7LtsBY","author":{"login":"xih1919"},"authorAssociation":"NONE","body":"> This is an intended behavior. `start_to_close_timeout` refers to the time allowed after a worker has accepted a task. This doesn't necessarily guarantee that the user code has reached an particular point of execution, which would not really be achievable in the general case.这是预期的行为。`start_to_close_timeout` 是指工作人员接受任务后允许的时间。这并不一定保证用户代码已达到特定的执行点，这在一般情况下是无法实现的。\n> \n> In order to restrict the number of activities a worker can process at once, you should use Temporal provided tuning mechanisms, many of which are detailed in https://docs.temporal.io/develop/worker-performance. In Python, you can use the `max_concurrent_activities` argument on a worker. For more complex situations, you can look at slot suppliers. A fixed size slot supplier for activities would likely be what you are trying to accomplish.为了限制工作程序一次可以处理的活动数量，您应该使用 Temporal 提供的调优机制，其中许多机制在 https://docs.temporal.io/develop/worker-performance 中进行了详细说明。在 Python 中，您可以在工作程序上使用 `max_concurrent_activities` 参数。对于更复杂的情况，您可以查看插槽供应商。用于活动的固定尺寸插槽供应商可能是您想要实现的目标。\n\n\nThis is very useful for me, thanks","createdAt":"2025-10-18T03:15:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1168#issuecomment-3417751640","viewerDidAuthor":false}],"createdAt":"2025-10-17T03:46:10Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1168,"reactionGroups":[],"state":"CLOSED","title":"[Bug] When the task volume is greater than the number of concurrent activities, the subsequent activity execution time does not reach the start_to_close_timeout and is directly canceled","updatedAt":"2025-10-18T03:15:14Z","url":"https://github.com/temporalio/sdk-python/issues/1168"}
