{"assignees":[],"author":{"id":"MDQ6VXNlcjEyNTg1NzY=","is_bot":false,"login":"cpnielsen","name":"Christian PalmhÃ¸j Nielsen"},"body":"### What are you really trying to do?\n\nI want to make use of [asyncio.TaskGroup](https://docs.python.org/3/library/asyncio-task.html#task-groups) to execute a number of child workflows in parallel. However, if one of the child workflows fail, it does **not** cause the parent workflow to fail, but instead continues to run forever.\n\nThe expected behavior would be for child workflow execution failure to cause the parent workflow to fail as well, using default configuration.\n\n### Describe the bug\n\nWhen a child workflow fails it raises a [ChildWorkflowError](https://python.temporal.io/temporalio.exceptions.ChildWorkflowError.html). However, when using `TaskGroup` it is encapsulated in an `ExceptionGroup` and raised, which does _not_ fail the calling workflow, causing it to run forever as per the documented error logic (https://docs.temporal.io/references/failures#errors-in-workflows).\n\nAt a glance it looks like the Temporal code never considers `ExceptionGroup` or other inner exceptions that are of the [FailureError](https://python.temporal.io/temporalio.exceptions.FailureError.html) type that triggers an upstream failure.\n\nNote, that if I instead use [asyncio.gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) it works as expected. This is expected, as `asyncio.gather` raises the first exception raised directly, passing the raw failure up which correctly triggers an overall failure.\n\n### Minimal Reproduction\n\n```python\n# workflows.py\nimport asyncio\nfrom datetime import timedelta\nfrom typing import List\n\nfrom temporalio import workflow\nfrom temporalio.common import RetryPolicy\n\n# Import activity, passing it through the sandbox without reloading the module\nwith workflow.unsafe.imports_passed_through():\n    from activities import say_hello\n\n\n@workflow.defn\nclass SayHello:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            say_hello, name, start_to_close_timeout=timedelta(seconds=5), retry_policy=RetryPolicy(maximum_attempts=3)\n        )\n\n\n@workflow.defn\nclass MasterWorkflow:\n    @workflow.run\n    async def run(self, names: List[str]) -> List[str]:\n        tasks: List[asyncio.Task[str]] = []\n        async with asyncio.TaskGroup() as tg:\n            for name in names:\n                tasks.append(\n                    tg.create_task(\n                        workflow.execute_child_workflow(\n                            SayHello.run, name, id=f\"say-hello-{name}\", retry_policy=RetryPolicy(maximum_attempts=1)\n                        )\n                    )\n                )\n\n        greetings = [task.result() for task in tasks]\n\n        return greetings\n```\n\n```python\n# activities.py\nfrom temporalio import activity\n\n\n@activity.defn\nasync def say_hello(name: str) -> str:\n    if name == \"fail\":\n        raise Exception(\"Uh-oh\")\n    return f\"Hello, {name}!\"\n```\n\n```python\n# run_workflow.py\nimport asyncio\n\nfrom temporalio.client import Client\n\nfrom run_worker import MasterWorkflow\n\n\nasync def main():\n    # Create client connected to server at the given address\n    client = await Client.connect(\"localhost:7233\")\n\n    # Execute a workflow\n    result = await client.execute_workflow(\n        MasterWorkflow.run, [\"ok\", \"fail\", \"okay\", \"cool\"], id=\"master-workflow\", task_queue=\"hello-task-queue\"\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n```python\n# run_worker.py\nimport asyncio\n\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n\nfrom activities import say_hello\nfrom workflows import MasterWorkflow, SayHello\n\n\nasync def main():\n    client = await Client.connect(\"localhost:7233\", namespace=\"default\")\n    # Run the worker\n    worker = Worker(\n        client, task_queue=\"hello-task-queue\", workflows=[MasterWorkflow, SayHello], activities=[say_hello]\n    )\n    await worker.run()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nThe exception raised from the workflow is of type `ExceptionGroup` with the message `unhandled errors in a TaskGroup (1 sub-exception)`.\n\nChanging the code to user `asyncio.gather` instead correctly registers as a \"Child Workflow Execution Failure\".\n\n### Environment/Versions\n\n- OS and processor: M2 Macbook Pro, x64 Linux\n- Temporal Version: 1.12.0 (client+worker)\n- Tested consistently locally (Macbook), but observed running in kubernetes as well.\n\nAs the nature of the bug is \"working as intended\", I expect it to behave identically across environments.\n\n### Additional context\n\nI am happy to provide a PR (with tests) if you can point me to some good starting point. I checked for places where the code handles/raises `FailureError`, but I don't feel sure enough to just dive in.\n","closedAt":"2025-08-06T09:21:45Z","comments":[{"id":"IC_kwDOGusT1c68Q66e","author":{"login":"cpnielsen"},"authorAssociation":"NONE","body":"After looking at the code again, I think the following might solve it:\n\n```python\n# temporalio/worker/_workflow_instance.py\n\n# <-- IMPORTS -->\n\nLOG_IGNORE_DURING_DELETE = False\n\nif sys.version_info < (3, 11):\n    from exceptiongroup import ExceptionGroup\n\n# <-- MORE CODE -->\n\n    def _is_workflow_failure_exception(self, err: BaseException) -> bool:\n        # An exception is a failure instead of a task fail if it's already a\n        # failure error or if it is a timeout error or if it is an instance of\n        # any of the failure types in the worker or workflow-level setting\n        wf_failure_exception_types = self._defn.failure_exception_types\n        if self._dynamic_failure_exception_types is not None:\n            wf_failure_exception_types = self._dynamic_failure_exception_types\n        return (\n            isinstance(err, temporalio.exceptions.FailureError)\n            or self._is_exception_group_failure(err)\n            or isinstance(err, asyncio.TimeoutError)\n            or any(isinstance(err, typ) for typ in wf_failure_exception_types)\n            or any(\n                isinstance(err, typ)\n                for typ in self._worker_level_failure_exception_types\n            )\n        )\n\n    def _is_exception_group_failure(self, err: BaseException) -> bool:\n        if isinstance(err, ExceptionGroup):\n            return any(self._is_workflow_failure_exception(e) for e in err.exceptions)\n\n        return False\n\n# <-- MORE CODE -->\n```\n","createdAt":"2025-08-06T09:21:44Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1020#issuecomment-3158552222","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c68Q8mm","author":{"login":"cpnielsen"},"authorAssociation":"NONE","body":"@cretz Could you re-open this please, I accidentally hit a hotkey to close the issue ðŸ¤¦ ","createdAt":"2025-08-06T09:22:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1020#issuecomment-3158559142","viewerDidAuthor":false}],"createdAt":"2025-08-06T08:52:26Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1020,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"CLOSED","title":"[Bug] Using TaskGroup for child workflow execution does not correctly detect failure","updatedAt":"2025-08-06T09:22:44Z","url":"https://github.com/temporalio/sdk-python/issues/1020"}
