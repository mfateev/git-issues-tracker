{"assignees":[],"author":{"id":"U_kgDOCvmjbQ","is_bot":false,"login":"jkk-playon","name":"Joe Koberg"},"body":"### What are you really trying to do?\n\nFirst time quickstart, running python worker. Just trying to start it up with a trivial workflow.\n\n\n### Describe the bug\n\nReceive this message from the worker process, which does not exit.  Client hangs on connect:\n\n```\nthread '<unnamed>' panicked at src/worker.rs:527:14:\nmust only be set once: TaskLocals { event_loop: Py(0x1165b6120), context: Py(0x116ad1d40) }\nstack backtrace:\n   0:        0x123b2d6ac - <std::sys::backtrace::BacktraceLock::print::DisplayBacktrace as core::fmt::Display>::fmt::hf35f9734f9a29483\n   1:        0x123865f54 - core::fmt::write::h60ec6633daab7b35\n   2:        0x123b2d044 - std::io::Write::write_fmt::hc29709fdab2e34e2\n   3:        0x123b2d56c - std::sys::backtrace::BacktraceLock::print::hca95bffd78053951\n   4:        0x123b2cc4c - std::panicking::rust_panic_with_hook::h557a23724a5de839\n   5:        0x123b537f4 - std::panicking::begin_panic_handler::{{closure}}::h269cace6208fef05\n   6:        0x123b53764 - std::sys::backtrace::__rust_end_short_backtrace::h5be0da278f3aaec7\n   7:        0x123b544c8 - __rustc[de2ca18b4c54d5b8]::rust_begin_unwind\n   8:        0x1247f5d90 - core::panicking::panic_fmt::h477ff48eff31ffa4\n   9:        0x1247f6180 - core::result::unwrap_failed::h61c3c2f1df5908ff\n  10:        0x123850d54 - temporal_sdk_bridge::worker::WorkerRef::__pymethod_validate__::h0d5c2056c6b1c4b7\n  11:        0x12381e470 - pyo3::impl_::trampoline::trampoline::hbce46ba09996ee98\n  12:        0x123850008 - temporal_sdk_bridge::worker::<impl pyo3::impl_::pyclass::PyMethods<temporal_sdk_bridge::worker::WorkerRef> for pyo3::impl_::pyclass::PyClassImplCollector<temporal_sdk_bridge::worker::WorkerRef>>::py_methods::ITEMS::trampoline::h5af5b64b656159ef\n  13:        0x1051b6f0c - __PyEval_EvalFrameDefault\n  14:        0x1050a2a5c - _gen_send_ex2\n  15:        0x10563adc0 - _task_step_impl\n  16:        0x10563ab98 - _task_step\n  17:        0x105080be8 - __PyObject_MakeTpCall\n  18:        0x1051e42d4 - _context_run\n  19:        0x1051ba144 - __PyEval_EvalFrameDefault\n  20:        0x1051b3754 - _PyEval_EvalCode\n  21:        0x10522f958 - _run_mod\n  22:        0x10522e034 - _pyrun_file\n  23:        0x10522d5b8 - __PyRun_SimpleFileObject\n  24:        0x10522d21c - __PyRun_AnyFileObject\n  25:        0x10525caf8 - _pymain_run_file_obj\n  26:        0x10525c840 - _pymain_run_file\n  27:        0x10525bd80 - _Py_RunMain\n  28:        0x10525c218 - _pymain_main\n  29:        0x10525c2b4 - _Py_BytesMain\n```\n\n\n### Minimal Reproduction\n\n\n### Environment/Versions\n\nUsing uv, python3.14, non-sandboxed with snowflake and kafka connectors spun up.\nuname: `Darwin ip-192-168-1-131.ec2.internal 24.6.0 Darwin Kernel Version 24.6.0: Mon Jul 14 11:30:30 PDT 2025; root:xnu-11417.140.69~1/RELEASE_ARM64_T6020 arm64`\n\n\"temporalio>=1.18.2\"\n\nserver running with `temporal server start-dev`\n\ntemporal installed via brew, latest version.\n\n","closedAt":"2025-11-14T23:45:51Z","comments":[{"id":"IC_kwDOGusT1c7SrDIP","author":{"login":"jkk-playon"},"authorAssociation":"NONE","body":"Minimal reproduction:\n\n```python\nimport asyncio\nfrom dataclasses import dataclass\n\nfrom temporalio.client import Client as TemporalClient\nfrom temporalio import activity, workflow\n\nfrom temporalio.worker import Worker\n\n@dataclass\nclass FileArrivalArgs:\n    msg_key: str\n    msg_body: str\n\n\n@dataclass\nclass Activities:\n    \n    @activity.defn\n    async def run_process(self, event: FileArrivalArgs) -> None:\n        await asyncio.sleep(5)\n    \n@workflow.defn\nclass FileArrival:    \n    @workflow.run\n    async def run(self, arg: FileArrivalArgs):\n        await asyncio.sleep(30)\n\n\nasync def run_temporal_worker() -> None:\n    activities = Activities()\n    async with Worker(\n        await TemporalClient.connect(\"localhost:7233\"),\n        task_queue=\"default\",\n        activities=[activities.run_process],\n        workflows=[FileArrival],\n    ) as  temporal_worker:\n        await temporal_worker.run()\n                    \n\n\nif __name__ == \"__main__\":\n    asyncio.run(run_temporal_worker())\n\n```","createdAt":"2025-11-14T20:45:19Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1215#issuecomment-3534500367","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7SrLp3","author":{"login":"tconley1428"},"authorAssociation":"MEMBER","body":"That could use a better error condition, but I think the problem is that you are running the worker twice. `async with Worker` already runs the worker for the duration of that context. Using `run` again tries to redo things and results in the failure.","createdAt":"2025-11-14T20:59:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1215#issuecomment-3534535287","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7StOEw","author":{"login":"jkk-playon"},"authorAssociation":"NONE","body":"Yes, that seemed to fix it.  But, I wonder what I'm expected to be doing once the worker has started its background task and yielded - sleep? `await temporal_worker._shutdown_complete_event.wait()` ?  I do want to use the context manager pattern to ensure resource safety.","createdAt":"2025-11-14T23:45:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1215#issuecomment-3535069488","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7StR_Y","author":{"login":"tconley1428"},"authorAssociation":"MEMBER","body":"The context manager is really just for use when you have things you want to do with that worker. So you would just use it, execute workflows, etc. You could theoretically wait on some sort of application level cancellation depending on your scenario, but if you just want the process to be a perpetual worker, there's no reason to use the context manager.","createdAt":"2025-11-14T23:53:00Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1215#issuecomment-3535085528","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7StTi9","author":{"login":"jkk-playon"},"authorAssociation":"NONE","body":"Right - it never exits.  The thing is, when a service offers the context manager protocol, I assume there is some cleanup on exception unwind.  I use that pattern almost exclusively for any kind of long-lived stateful facility.","createdAt":"2025-11-14T23:56:50Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1215#issuecomment-3535091901","viewerDidAuthor":false}],"createdAt":"2025-11-14T20:31:23Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1215,"reactionGroups":[],"state":"CLOSED","title":"[Bug] must only be set once: TaskLocals { event_loop: Py(0x1165b6120), context: Py(0x116ad1d40) }","updatedAt":"2025-11-14T23:58:33Z","url":"https://github.com/temporalio/sdk-python/issues/1215"}
