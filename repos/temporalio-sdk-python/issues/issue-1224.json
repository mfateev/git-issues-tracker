{"assignees":[],"author":{"id":"MDQ6VXNlcjE0NzQxMjc=","is_bot":false,"login":"pinkynrg","name":"Francesco Meli"},"body":"### What are you really trying to do?\n\nI'm building an AI agent workflow using Temporal and the OpenAI Agents SDK. Users can start long-running agent conversations and need the ability to cancel them mid-execution using Temporal's built-in `.cancel()` method. When a user requests cancellation, I want to:\n\n1. Stop the agent execution immediately (or as soon as possible)\n2. Execute my `handle_cancellation()` method to perform cleanup (save interrupt tag, notify frontend, clear session)\n3. Have the cancellation handler run reliably every time\n\nThe agent execution happens via `await Runner.run()` from the OpenAI Agents SDK, which can take several minutes to complete.\n\n### Describe the bug\n\nWhen a user requests workflow cancellation via Temporal's `.cancel()` method, there's a race condition where the workflow gets marked as \"Cancelled\" by Temporal before my exception handler can execute `handle_cancellation()`. \n\nMore or less 10% of the time, **no `CancelledError` exception was raised** during the workflow task execution, so my `except` block never ran to call `handle_cancellation()`. The workflow was cancelled, after the task completed successfully.\n\nFor the workflow result I get:\n\n```\n{\n  \"type\": \"workflowExecutionCanceledEventAttributes\",\n  \"workflowTaskCompletedEventId\": \"41\"\n}\n```\n\n**Expected behavior:**\n\nThe `except` block should catch the cancellation and execute `handle_cancellation()`:\n\n```python\nexcept Exception as e:\n    if is_cancelled_exception(e) or (e.__cause__ and is_cancelled_exception(e.__cause__)):\n        workflow.logger.info(\"AgentWorkflow cancelled by user\")\n        return await self.handle_cancellation(topic, session, payload)\n```\n\n**Actual behavior:**\n\nThe workflow is cancelled by Temporal before the exception handler runs, so `handle_cancellation()` never executes and:\n- Event log shows \"Workflow cancelled\" instead of showing cleanup activities\n- No interrupt tag is saved to OpenSearch\n- Frontend never receives cancellation notification\n- Session is not cleared\n- Workflow status shows \"Cancelled\" instead of \"Completed\"\n\n### Minimal Reproduction\n\n```python\nfrom temporalio import workflow\nfrom temporalio.exceptions import is_cancelled_exception\nfrom agents import Runner\n\n@workflow.defn\nclass AgentWorkflow:\n    async def handle_cancellation(self, topic: str, session, payload):\n        \"\"\"\n        Critical cleanup:\n        - Save interrupt tag to message history\n        - Notify frontend\n        - Clear session\n        \"\"\"\n        workflow.logger.info(\"Cleanup executed\")\n        interrupt_tag = \"<interrupt />\"\n        \n        # Save interrupt tag to OpenSearch\n        await workflow.execute_activity(\n            activity=OpenSearchActivities.save_agent_message_history,\n            args=(SaveAgentMessageHistory(\n                workflow_id=workflow.info().workflow_id,\n                session_id=session.session_id,\n                messages=[{\"content\": interrupt_tag, \"role\": \"assistant\", \"type\": \"message\"}]\n            ),),\n            start_to_close_timeout=DEFAULT_START_TO_CLOSE_TIMEOUT,\n            retry_policy=DEFAULT_RETRY_POLICY,\n        )\n        \n        # Notify frontend\n        await notify_frontend(\n            topic=topic,\n            message=MessageAgentFinalResponseToFrontend(value=interrupt_tag, session_id=session.session_id),\n        )\n        \n        return interrupt_tag\n    \n    @workflow.run\n    async def run(self, payload) -> str | None:\n        try:\n            topic = f\"agent_{payload.uid}_{payload.mcp_session_id}\"\n            info = workflow.info()\n            session = AgentSession(info.workflow_id, session_id=str(workflow.uuid4()))\n            \n            # Long-running agent execution with internal activities\n            result = await Runner.run(\n                starting_agent=agent,\n                input=user_input,\n                session=session,\n                max_turns=30,\n            )\n            \n            return result.final_output\n            \n        except Exception as e:\n            if is_cancelled_exception(e) or (e.__cause__ and is_cancelled_exception(e.__cause__)):\n                # This never executes when cancellation arrives\n                # between activity completion and workflow task start\n                return await self.handle_cancellation(topic, session, payload)\n            raise e\n```\n\n**Steps to reproduce:**\n\n1. Start the workflow with a long-running `Runner.run()` call\n2. Wait for `Runner.run()` to complete an internal activity\n3. Call `workflow_handle.cancel()` immediately after the activity completes (within ~13ms window)\n4. Observe that the workflow gets cancelled by Temporal before `handle_cancellation()` runs\n\n### Environment/Versions\n\n- OS and processor: M3 Mac (Apple Silicon)\n- Temporal SDK: Python SDK version ~1.8.0~1.19.0\n- Python: 3.12\n- OpenAI Agents SDK: 0.0.11\n\n### Additional context\n\nThe `handle_cancellation()` method performs critical cleanup:\n- Saves interrupt tag to OpenSearch (so conversation history shows the cancellation)\n- Sends notifications to frontend via Lightstreamer\n- Clears the agent session\n- Updates Langfuse trace with cancellation info\n\nWhen it doesn't run, the system is left in an inconsistent state and users see incomplete or confusing behavior.\n\n**Questions:**\n\n1. Is there a way to ensure `CancelledError` is raised during the workflow task when cancellation is pending?\n2. Should I be using a different pattern (e.g., `CancellationScope`, signals, or polling) for handling cancellation in workflows with long-running operations like `Runner.run()`?\n3. Is there a way to guarantee cleanup code runs even when the workflow is cancelled at a task boundary?\n","closedAt":"2025-12-05T19:21:25Z","comments":[{"id":"IC_kwDOGusT1c7VL2yb","author":{"login":"tconley1428"},"authorAssociation":"MEMBER","body":"Ensuring a user facing exception appears is more difficult in Python than other languages due to the use of `asyncio`, but we try to do that as much as possible. In the case of an activity with the default cancellation method, it should be guaranteed. I would recommend a few things.\n\n1. Due to the general difficulty of ensuring the exceptions propagate appropriately in Python (child workflows or changing the cancellation type can cause different scenarios), it is often advisable to use signals to move the workflow into a cleanup state rather than rely on the exceptions.\n\n2. We would be interested in determining why you aren't seeing an exception in this particular case, but we would need a replication, as I don't think the code provided would actually run as is. `agent` doesn't exist for instance. Additionally, we would be fixing any issues on the latest SDK version, and you are using one that is over a year old. It would be good to see if the issue still exists on the latest version `1.19.0`.\n\n3. Not exactly to your question, but I would look at https://github.com/temporalio/sdk-python/tree/main/temporalio/contrib/openai_agents if you haven't. We built an integration to do some of the things it sounds like you are doing manually.","createdAt":"2025-11-25T17:05:18Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1224#issuecomment-3576655003","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7VQzUF","author":{"login":"pinkynrg"},"authorAssociation":"NONE","body":"Thanks for the detailed response @tconley1428\n\nA quick correction: the SDK version is actually `1.19.0`. I used an agent to summarize my original post and it hallucinated an older version number. My bad, I’ll update the issue so it’s accurate.\n\nI can share the real workflow code if needed, but I’d prefer to do that through a more private channel since it includes business logic I don’t want to post directly in a GitHub issue.\n\nAnd yes, we’re already using `temporalio.contrib.openai_agents`. I’m curious which parts you think we might be reinventing, if there’s something in the contrib package that can simplify our cancellation/cleanup logic, I’d love to know.\n\nIn the meantime, I might dig a bit deeper into signals. I originally skipped them because handling the cancellation exception seemed more straightforward, but given this behavior, it might be worth revisiting.","createdAt":"2025-11-25T23:00:56Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1224#issuecomment-3577951493","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7Vir6w","author":{"login":"tconley1428"},"authorAssociation":"MEMBER","body":"Gotcha, the old versions would have ruled out `temporalio.contrib.openai_agents`, so I assumed you would be reinventing the activity separation to make it work. If you'd like me to look into this particular repro, you can send me details in the community slack. There are other scenarios that may mean signal is more straighfoward though.","createdAt":"2025-11-26T18:15:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1224#issuecomment-3582639792","viewerDidAuthor":false}],"createdAt":"2025-11-25T09:14:00Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1224,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"state":"CLOSED","title":"Cannot reliably catch workflow cancellation with try/except pattern","updatedAt":"2025-12-05T19:21:25Z","url":"https://github.com/temporalio/sdk-python/issues/1224"}
