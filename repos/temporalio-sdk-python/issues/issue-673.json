{"assignees":[],"author":{"id":"MDQ6VXNlcjkwODYzMTU=","is_bot":false,"login":"cbrewster","name":"Connor Brewster"},"body":"### What are you really trying to do?\r\n\r\nI have a workflow which runs various activities depending on signals/updates from the user. The workflow keeps track of the current state (running, stopped) using a counter to keep track of how many activities are currently running. There is a resume update which we only want to start an activity if there isn't already an activity running.\r\n\r\nI've implemented this but during replays we are seeing non-determinism errors. I've made a minimal reproduction of this.\r\n\r\n### Describe the bug\r\n\r\nWe're seeing workflow replays that cause events to be processed in a different order than how the events originally came in:\r\n\r\nOriginal order of events:\r\n```\r\n- start workflow\r\n- start timer\r\n- signal start\r\n- start activity 1 (state = \"running\", running_count = 1)\r\n- activity 1 finishes (state = \"stopped\", running_count = 0)\r\n- update resume\r\n- start activity 2 (state = \"running\", running_count = 1)\r\n- activity 2 finishes (state = \"stopped\", running_count = 0)\r\n- update returns\r\n- timer completes, workflow done\r\n```\r\n\r\nDuring replay we get a different order which causes the NDE:\r\n\r\n```\r\n- start workflow\r\n- start timer\r\n- signal start\r\n- start activity 1 (state = \"running\", running_count = 1)\r\n- update resume <--- This update gets ran before we process the completion of activity 1\r\n- resume returns early because state is \"running\"\r\n- activity 1 finishes (state = \"stopped\", running_count = 0)\r\n- NDE because we didn't end up scheduling activity 2\r\n```\r\n\r\n### Minimal Reproduction\r\n\r\nThis reproduction runs the workflow and then automatically replays the workflow to demonstrate the nondeterminism error.\r\n\r\n```python\r\nimport asyncio\r\nfrom datetime import timedelta\r\nfrom uuid import uuid4\r\n\r\nfrom temporalio import workflow\r\nfrom temporalio import activity\r\nfrom temporalio.client import Client\r\nfrom temporalio.worker import Replayer, Worker\r\n\r\n\r\n@activity.defn\r\nasync def test_activity() -> None:\r\n    return\r\n\r\n\r\n@workflow.defn\r\nclass TestWorkflow:\r\n    def __init__(self) -> None:\r\n        self.running_count = 0\r\n        self.state = \"stopped\"\r\n\r\n    @workflow.run\r\n    async def run(self) -> None:\r\n        await asyncio.sleep(1)\r\n\r\n    @workflow.signal\r\n    async def start(self) -> None:\r\n        await self.run_one()\r\n\r\n    @workflow.update\r\n    async def resume(self) -> None:\r\n        if self.state == \"running\":\r\n            return\r\n        await self.run_one()\r\n\r\n    async def run_one(self):\r\n        self.running_count += 1\r\n        self.state = \"running\"\r\n        await workflow.execute_activity(\r\n            test_activity,\r\n            start_to_close_timeout=timedelta(seconds=1),\r\n        )\r\n        self.running_count -= 1\r\n        if self.running_count == 0:\r\n            self.state = \"stopped\"\r\n\r\n\r\nasync def main() -> None:\r\n    id = str(uuid4())\r\n    client = await Client.connect(\"localhost:7233\")\r\n    async with Worker(\r\n        client=client,\r\n        task_queue=\"test\",\r\n        workflows=[TestWorkflow],\r\n        activities=[test_activity],\r\n    ):\r\n        workflow_handle = await client.start_workflow(\r\n            TestWorkflow.run,\r\n            id=id,\r\n            task_queue=\"test\",\r\n        )\r\n        await workflow_handle.signal(TestWorkflow.start)\r\n        await asyncio.sleep(0.5)\r\n        await workflow_handle.execute_update(TestWorkflow.resume)\r\n        await workflow_handle.result()\r\n\r\n    workflows = client.list_workflows(f\"WorkflowId = '{id}'\")\r\n    histories = workflows.map_histories()\r\n    replayer = Replayer(workflows=[TestWorkflow])\r\n    await replayer.replay_workflows(histories)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n\r\n```\r\n\r\n### Environment/Versions\r\n\r\n<!-- Please complete the following information where relevant. -->\r\n\r\n- OS and processor: Linux\r\n- Temporal Version: Server 1.24.2, UI 2.28.0, sdk-python 1.8.0\r\n- Using temporal CLI\r\n\r\n### Additional Comments\r\n\r\nReplacing the update with a signal instead does not have the same issue.","closedAt":"2024-10-23T18:43:14Z","comments":[{"id":"IC_kwDOGusT1c6QF1Q3","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Thanks for the detailed report! The activity completion definitely should be delivered before update on replay if it was originally. We will likely treat this as a high priority (granted updates are not yet GA for these kinds of reasons).","createdAt":"2024-10-16T17:18:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HEART","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/673#issuecomment-2417447991","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c6Q9qpV","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"While the linked PR there fixes the issue, note that the fix will not be available until the next Python release that includes the next Core upgrade.","createdAt":"2024-10-23T13:02:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/673#issuecomment-2432084565","viewerDidAuthor":false}],"createdAt":"2024-10-16T16:23:21Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":673,"reactionGroups":[{"content":"HEART","users":{"totalCount":1}}],"state":"CLOSED","title":"[Bug] NondeterminismError when replaying overlapping signals and updates","updatedAt":"2024-10-23T18:43:14Z","url":"https://github.com/temporalio/sdk-python/issues/673"}
