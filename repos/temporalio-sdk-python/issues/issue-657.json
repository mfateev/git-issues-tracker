{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"### Describe the bug\r\n\r\nOur check that the runtime is the same on the replaced client as is on the worker does not work if the runtime is not set on the client (i.e. lazily uses the default). We need to either more eagerly set the runtime default on the client config for the service, or use a different way to obtain the runtime of the bridge service client when comparing.\r\n\r\nReplication:\r\n\r\n```python\r\nimport asyncio\r\nfrom dataclasses import dataclass\r\nfrom datetime import timedelta\r\n\r\nfrom temporalio import activity, workflow\r\nfrom temporalio.client import Client\r\nfrom temporalio.worker import Worker\r\n\r\n\r\n# While we could use multiple parameters in the activity, Temporal strongly\r\n# encourages using a single dataclass instead which can have fields added to it\r\n# in a backwards-compatible way.\r\n@dataclass\r\nclass ComposeGreetingInput:\r\n    greeting: str\r\n    name: str\r\n\r\n\r\n# Basic activity that logs and does string concatenation\r\n@activity.defn\r\nasync def compose_greeting(input: ComposeGreetingInput) -> str:\r\n    activity.logger.info(\"Running activity with parameter %s\" % input)\r\n    return f\"{input.greeting}, {input.name}!\"\r\n\r\n\r\n# Basic workflow that logs and invokes an activity\r\n@workflow.defn\r\nclass GreetingWorkflow:\r\n    @workflow.run\r\n    async def run(self, name: str) -> str:\r\n        workflow.logger.info(\"Running workflow with parameter %s\" % name)\r\n        return await workflow.execute_activity(\r\n            compose_greeting,\r\n            ComposeGreetingInput(\"Hello\", name),\r\n            start_to_close_timeout=timedelta(seconds=10),\r\n        )\r\n\r\n\r\nasync def main():\r\n    # Uncomment the lines below to see logging output\r\n    # import logging\r\n    # logging.basicConfig(level=logging.INFO)\r\n\r\n    # Start client\r\n    client = await Client.connect(\"localhost:7233\")\r\n\r\n    client_2 = await Client.connect(\"localhost:7233\")\r\n\r\n\r\n    # Run a worker for the workflow\r\n    async with Worker(\r\n        client,\r\n        task_queue=\"hello-activity-task-queue\",\r\n        workflows=[GreetingWorkflow],\r\n        activities=[compose_greeting],\r\n    ) as worker:\r\n\r\n        worker.client = client_2\r\n\r\n        # While the worker is running, use the client to run the workflow and\r\n        # print out its result. Note, in many production setups, the client\r\n        # would be in a completely separate process from the worker.\r\n        result = await client.execute_workflow(\r\n            GreetingWorkflow.run,\r\n            \"World\",\r\n            id=\"hello-activity-workflow-id\",\r\n            task_queue=\"hello-activity-task-queue\",\r\n        )\r\n        print(f\"Result: {result}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```\r\n\r\nIn the meantime, simply using `default=temporalio.runtime.Runtime.default()` in the client `connect` calls will work around the issue.","closedAt":null,"comments":[],"createdAt":"2024-09-30T18:11:41Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":657,"reactionGroups":[],"state":"OPEN","title":"[Bug] Cannot replace worker client if default Runtime is used","updatedAt":"2024-09-30T18:11:41Z","url":"https://github.com/temporalio/sdk-python/issues/657"}
