{"assignees":[],"author":{"id":"U_kgDOCGUniA","is_bot":false,"login":"ntessman-capsule","name":"Nate Tessman"},"body":"### What are you really trying to do?\r\n\r\nSplit a list of incoming events into concurrently executed activity streams. The repro below mimics a stripped down version of the original code structure.\r\n\r\n### Describe the bug\r\n\r\nWhen using `asyncio.wait()` with a list of async method calls, which contain a series of activity executions, an error can occur which results in later activities receiving the return values of different concurrent executions.\r\n\r\nHere is a table to illustrate what I mean. Given an activity that executes `f(x) -> x`, if we pass the numbers 1-3 concurrently, we might see this:\r\n\r\n|Activity Input|Expected Output|Actual Output|\r\n|-------------|---------|-------|\r\n|1                    |1              |1         |\r\n|2                   |2              |3         |\r\n|3                    |3              |2         |\r\n\r\nThis issue is random, and rare. The reproduction below is designed to maximize the chance of running into it.\r\n\r\n### Minimal Reproduction\r\n\r\nBelow is a self-contained reproduction of the issue. Using this input should encounter the error fairly consistently, a little less than once per run:\r\n\r\n```json\r\n{\"execution_iterations\": 20,\"activity_iterations\": 5,\"concurrency\": 100,\"wait_time\": 0.1}\r\n```\r\n\r\nThe temporal setup I used to reproduce this issue is a vanilla Temporal server install running via `temporal server start-dev`, with two worker instances running the below python file using `python -m main`. I primarily tested using Python 3.8.\r\n\r\nWhen there is a mismatch, it is printed to the console.\r\n\r\n```python\r\nimport asyncio\r\nfrom datetime import timedelta\r\nfrom typing import List\r\nfrom temporalio import workflow, activity\r\nfrom temporalio.worker import Worker\r\nfrom temporalio.client import Client\r\n\r\nfrom dataclasses import dataclass\r\n\r\n@dataclass\r\nclass EchoRequest:\r\n    execution_iteration: int\r\n    activity_iteration: int\r\n    input: str\r\n    wait_time: float\r\n\r\n@dataclass\r\nclass EchoResponse:\r\n    output: str\r\n\r\n@activity.defn(name=\"echo\")\r\nasync def echo(\r\n    echo: EchoRequest\r\n) -> EchoResponse:\r\n    await asyncio.sleep(echo.wait_time)\r\n    return EchoResponse(output=echo.input)\r\n\r\n\r\n@dataclass\r\nclass RaceConditionIteration:\r\n    execution_id: int\r\n    iterations: int\r\n    wait_time: float\r\n\r\n\r\n@dataclass\r\nclass RaceConditionTestInput:\r\n    execution_iterations: int\r\n    activity_iterations: int\r\n    concurrency: int\r\n    wait_time: float\r\n\r\n\r\n@activity.defn(name=\"race_condition_get_input_events\")\r\nasync def race_condition_get_input_events(\r\n    input: RaceConditionTestInput\r\n) -> List[RaceConditionIteration]:\r\n    return [\r\n        RaceConditionIteration(\r\n            execution_id=id,\r\n            iterations=input.activity_iterations,\r\n            wait_time=input.wait_time,\r\n        )\r\n        for id in range(input.concurrency)\r\n    ]\r\n\r\n\r\n@workflow.defn(name=\"RaceConditionTestWorkflow\")\r\nclass RaceConditionTestWorkflow:\r\n    @workflow.run\r\n    async def run(self, event: RaceConditionTestInput) -> str:\r\n        print('Starting workflow...')\r\n        \r\n        # Simulate a list of input events\r\n        generated_input_data = await workflow.execute_activity(\r\n            race_condition_get_input_events,\r\n            event,\r\n            start_to_close_timeout=timedelta(seconds=10),\r\n            schedule_to_close_timeout=timedelta(seconds=60)\r\n        )\r\n\r\n        for iteration in range(event.execution_iterations):\r\n            _, _ = await asyncio.wait(\r\n                [\r\n                    self.execute_activities(\r\n                        iteration=iteration,\r\n                        input=input\r\n                    )\r\n                    for input in generated_input_data\r\n                ],\r\n                return_when=asyncio.ALL_COMPLETED\r\n            )\r\n        \r\n        return \"Done.\"\r\n\r\n    async def execute_activities(\r\n        self,\r\n        iteration: int,\r\n        input: RaceConditionIteration,\r\n    ) -> None:\r\n        for iter in range(input.iterations):\r\n            iter_id = f\"{iteration}.{input.execution_id}.{iter}\"\r\n            result = await workflow.execute_activity(\r\n                echo,\r\n                EchoRequest(\r\n                    execution_iteration=iteration,\r\n                    activity_iteration=iter,\r\n                    input=iter_id,\r\n                    wait_time=input.wait_time\r\n                ),\r\n                start_to_close_timeout=timedelta(seconds=10),\r\n                schedule_to_close_timeout=timedelta(seconds=60)\r\n            )\r\n\r\n            if iter_id != result.output:\r\n                print(f\"Expected: {iter_id}, Actual: {result.output}\")\r\n            \r\n\r\nasync def main():\r\n    client = await Client.connect(\"localhost:7233\")\r\n\r\n    worker = Worker(\r\n        client,\r\n        task_queue=\"race-condition\",\r\n        workflows=[RaceConditionTestWorkflow],\r\n        activities=[echo, race_condition_get_input_events],\r\n    )\r\n\r\n    print('Starting worker...')\r\n\r\n    await worker.run()\r\n\r\nif __name__ == '__main__':\r\n    asyncio.run(main())\r\n```\r\n\r\n### Environment/Versions\r\n\r\n- OS and processor: Tested on M2 Mac, Linux\r\n- Temporal SDK Versions: Tested on 1.13, 1.14\r\n- Python: <3.11 (mitigated in 3.11 due to disallowing coroutines, see below)\r\n- Occurs within Kubernetes deployment as well as local install\r\n\r\n### Additional context\r\n\r\nIt appears that this bug occurs after this warning is printed to the worker console:\r\n\r\n```\r\n2023-11-15T05:38:09.387580Z  WARN temporal_sdk_core::worker::workflow: Task not found when completing error=status: NotFound, message: \"Workflow task not found.\", details: [8, 5, 18, 24, 87, 111, 114, 107, 102, 108, 111, 119, 32, 116, 97, 115, 107, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 46, 26, 66, 10, 64, 116, 121, 112, 101, 46, 103, 111, 111, 103, 108, 101, 97, 112, 105, 115, 46, 99, 111, 109, 47, 116, 101, 109, 112, 111, 114, 97, 108, 46, 97, 112, 105, 46, 101, 114, 114, 111, 114, 100, 101, 116, 97, 105, 108, 115, 46, 118, 49, 46, 78, 111, 116, 70, 111, 117, 110, 100, 70, 97, 105, 108, 117, 114, 101], metadata: MetadataMap { headers: {\"content-type\": \"application/grpc\"} } run_id=\"eb9b8aed-c730-4fe6-a7e5-a772f6757be2\"\r\n```\r\n\r\nI can't confirm whether this warning was also appearing when this issue was happening in the real code. It also appears to result in the workflow task restarting, which seems correlated with the determinism breakdown.\r\n\r\nAdditionally, it appears that this issue has indirectly been mitigated in 3.11, as `asyncio.wait()` [no longer allows passing coroutines directly](https://github.com/python/cpython/issues/78971). When the method is wrapped in `asyncio.create_task()`, this issue disappears. The above warning is still printed, but doesn't result in disordered activity results.\r\n\r\nThis code change in the workflow removes the issue:\r\n\r\n```diff\r\n_, _ = await asyncio.wait(\r\n    [\r\n-      self.execute_activities(\r\n+      asyncio.create_task(self.execute_activities(\r\n            iteration=iteration,\r\n            input=input\r\n-       )\r\n+       ))\r\n        for input in generated_input_data\r\n    ],\r\n    return_when=asyncio.ALL_COMPLETED\r\n)","closedAt":"2024-06-04T14:07:09Z","comments":[{"id":"IC_kwDOGusT1c5s7BKK","author":{"login":"HillaShx"},"authorAssociation":"NONE","body":"I'm facing this same issue, it seems, by the logs. I, too, use asyncio for concurrent activity execution (by multiple workers separated by threads).\r\n\r\nEnvironment/Versions\r\nOS and processor: M2 Mac, MacOS Ventura 13.5.1\r\nTemporal SDK Versions: 1.3.0\r\nPython: 3.9.6\r\nOccurs within Temporal Cluster service deployment, with the workers deployed to an Azure Web App.\r\nLMK what other context might help in resolving this.\r\n","createdAt":"2023-11-27T09:06:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/429#issuecomment-1827410570","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5s-qzU","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Hrmm, I was only able to get the mismatch after replay (replay was being forced due to overgrowing history size I think). I am still investigating here...","createdAt":"2023-11-27T18:12:12Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/429#issuecomment-1828367572","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5s_A37","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Turns out `asyncio.wait` is non-deterministic. Here is the problem: https://github.com/python/cpython/blob/967f2a3052c2d22e31564b428a9aa8cc63dc2a9f/Lib/asyncio/tasks.py#L443\r\n\r\nThis is not a Temporal-specific issue. What is the output of the following?\r\n\r\n```python\r\n    async def do_something(name: str) -> None:\r\n        print(f\"Run {name}\")\r\n    await asyncio.wait([\r\n        do_something(\"something1\"),\r\n        do_something(\"something2\"),\r\n        do_something(\"something3\"),\r\n    ])\r\n    await asyncio.wait([\r\n        do_something(\"something4\"),\r\n        do_something(\"something5\"),\r\n        do_something(\"something6\"),\r\n    ])\r\n```\r\n\r\nIn 3.10, ignoring deprecation warnings, it may be something like (but it can change with only slight code alterations):\r\n\r\n```\r\nRun something1\r\nRun something2\r\nRun something3\r\nRun something6\r\nRun something4\r\nRun something5\r\n```\r\n\r\nWhy was that output not predictable?\r\n\r\nUnfortunately, Python in `asyncio.wait` non-deterministically converts the input to a `set` (which unlike even dict, does not have any reliable ordering). This means the coroutines are not even started in the same order. This problem does not exist with `start_activity` because that is a sync function that returns an awaitable (so it is called when you invoke it not when awaited), but `execute_activity` is an async function (so it is called when it's awaited not when it's invoked). This means that `foo = workflow.execute_activity(...)` does nothing until `await foo` is run.\r\n\r\nThe reason this works with `create_task` is because `create_task` starts the coroutine immediately when `create_task` is run, so the coroutines run in a deterministic order.\r\n\r\nSo, basically we need to educate people that `asyncio.wait` is non-deterministic when used with coroutines instead of tasks (which isn't allowed in 3.11+). I was originally going to open a CPython issue to stop converting to a set (digging through git blame, this was done way back in at least 3.4), but that would only apply to new versions (doubt they'd cherry pick this), so you'd be forced to use tasks anyways.\r\n\r\nDoes this make sense? I will add a README note/warning. We could offer our own deterministic form of this function, but we'd probably require tasks anyways like Python does now. Any alternative suggestions or ways we can approach this?","createdAt":"2023-11-27T19:11:40Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"ROCKET","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-python/issues/429#issuecomment-1828457979","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c5xw2kp","author":{"login":"ntessman-capsule"},"authorAssociation":"NONE","body":"Thanks for your investigation @cretz. I'll leave this open for comment in case anyone has a better idea, but for my purposes this issue is resolved through the use of tasks. Personally, I think the only thing that can be done is provide a warning. It's a gotcha that is on Python's shoulders, not the SDK, and as you said it's unlikely that a fix will be applied retroactively.","createdAt":"2024-01-24T17:46:36Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/temporalio/sdk-python/issues/429#issuecomment-1908631849","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7cWW-y","author":{"login":"kshitij-g"},"authorAssociation":"NONE","body":"Does this mean that asyncio.gather for multiple execute_activity is deterministic or not?","createdAt":"2025-12-29T15:40:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/429#issuecomment-3696848818","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7dFd2g","author":{"login":"ntessman-capsule"},"authorAssociation":"NONE","body":"It appears that `asyncio.gather` uses a dictionary internally for its futures so it's probably safe to use. If you're unsure however, it's easy enough to wrap your tasks in a list and pass it to `workflow.wait` instead.","createdAt":"2026-01-05T07:10:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/429#issuecomment-3709197728","viewerDidAuthor":false}],"createdAt":"2023-11-15T06:19:10Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":429,"reactionGroups":[{"content":"ROCKET","users":{"totalCount":1}}],"state":"CLOSED","title":"[Bug] asyncio.wait is non-deterministic when used with coroutines instead of tasks","updatedAt":"2026-01-05T07:10:20Z","url":"https://github.com/temporalio/sdk-python/issues/429"}
