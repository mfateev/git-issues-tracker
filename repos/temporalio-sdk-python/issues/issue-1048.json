{"assignees":[],"author":{"id":"MDQ6VXNlcjk1NTk2NTU=","is_bot":false,"login":"gregbrowndev","name":"Greg Brown"},"body":"### Is your feature request related to a problem? Please describe.\n\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\n\nCurrently, activities running on a multi-processed worker can not be cancelled, either voluntarily by the user/workflow or involuntarily e.g. by a missed heartbeat (or activity timeout, I think?).\n\nThis leads to wasted resources and potential pool starvation, as the activity will run to completion anyway just to get the error below and subsequently retried:\n\n> Activity not found on completion. This may happen if the activity has already been cancelled but completed anyway. \n\nAdditionally, in the case of missed heartbeats / timeout, the server will show the activity has failed and will retry the activity. Users might not expect or protect against this behaviour, leading to possible data corruption (e.g. if the activity was trying to write to a specific file) or duplicate side effects (e.g. if the activity did something at the end, like send an email). \n\nReproduction: [hello_cancellation.py](https://github.com/gregbrowndev/samples-python/blob/4f61efdb875ca3d4f92c69ff6fa172ab858611cb/hello/hello_cancellation.py#L66-L81) shows a sync, multi-processed activity running forever in a while loop, preventing the worker from shutting down after the workflow was cancelled.\n\n### Describe the solution you'd like\n\n<!-- A clear and concise description of what you want to happen. SCREENSHOTS OR CODE SAMPLES ARE VERY HELPFUL -->\n\n- Cancellation should be best effort in sync, multi-processed workers, like it is for async and multithreaded workers, with the known expectation that a cancellation cannot be received unless the activity is instrumented with heartbeats. \n\n- Provide clearer documentation in [Interrupt a Workflow Execution](https://docs.temporal.io/develop/python/cancellation#cancellation) and/or [Python SDK sync-vs-async](https://docs.temporal.io/develop/python/python-sdk-sync-vs-async) that sync, multiprocess workers do not currently support cancellation\n- Provide guidance to avoid problematic side effects in such activities, e.g.\n  - ensure output is written to a unique location or some kind of resource lock is acquired by the activity, \n  - trigger \"only-once\" side effects in subsequent activities in the workflow, e.g. sending an email (and that this requires a separate async or multithreaded worker / task queue)\n  - etc.\n\n### Additional context\n\n<!-- Add any other context or screenshots about the feature request here. -->\n\nOther relevant work/issues:\n\n- https://github.com/temporalio/sdk-python/pull/217\n- https://github.com/temporalio/sdk-python/issues/1047\n\nRoot cause:\n\n- Activity cancellation upon a missed heartbeat or timeout happens here in [_ActivityWorker](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L276)\n- This sets various cancellation properties/events in [_RunningActivity](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L628-L629)\n- For sync, multiprocessed activities, the `cancelled_event` is [initialised with a multiprocessing Manager event](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L451-L459) that can communicate across the process boundary.\n- Multi-threaded activities initialise the `_ThreadExceptionRaiser` in [_execute_sync_activity](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L817-L820) with the thread ID, but this isn't done for the multi-processed case (I imagine it doesn't work the same way).\n- So it looks like the `cancelled_event` is set and can be observed within the child process via [_Context](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L831-L833), but there is currently no built-in way for the user activity implementation to react to this event.\n\nI also assume this affects the [\"cancelled due to activity pause\"](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L319-L336), at least after the activity has already started?\n\nOut of interest, how does the the [_handle_start_activity_task](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L319-L336) work in this case? Does the `_ActivityWorker` continue to poll for tasks for an activity it has already picked up, as seems to be [suggested by the cancel task](https://github.com/temporalio/sdk-python/blob/607641bf1e8250699b9c7ae0e87230d43b26c2ff/temporalio/worker/_activity.py#L166-L168)? Does the server somehow ensure these cancel tasks are sticky, so the correct worker instance that picked up the start task can process them? I'm assuming this mechanism only works for newly picked up activities, so `start` was never triggered. If not though, why isn't this mechanism also used for heartbeat failures?\n\nCheers,\n\nI hope this assessment is accurate ðŸ™ðŸ» \n\n","closedAt":null,"comments":[{"id":"IC_kwDOGusT1c7AKsNm","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"For cancel, we leverage interruption. It is easy for us to cancel/interrupt asyncio and we use an advanced Python C function to interrupt a thread, but for non-thread-pool executors, there is no clear way to interrupt processing. But utilities like `activity.is_cancelled()` and `activity.wait_for_cancelled_sync()` should work. If you use multiprocess activities, you'll have to manually check for cancellation due to there being no clear way to interrupt non-thread-pool executor (of which process-pool is one type).","createdAt":"2025-08-26T12:43:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3224028006","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7ARXlB","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"thanks @cretz for the explanation. \n\nJust so I understand, the reason the `_ThreadExceptionRaiser` / underlying C function approach cannot be used for the multi-processed worker is because:\n\n1. We cannot serialise `_ThreadExceptionRaiser` across the process pool, or\n2. The C function only works in the current Python process (i.e. in the parent process where it is called)? or\n3. The exception raised by `_ThreadExceptionRaiser` requires a kind of wait point, similar to the asyncio `CancelledError`. Since CPU bound work may take a long time before hitting a OS call, e.g. `sleep`, etc. we wouldn't able to rely on this to interrupt the thread in a timely manner?\n\nThe problem with manually checking if the task is cancelled is because it might not be viable to do so, e.g. in a tight loop (check every iteration?) or calling into some long-running library function outside of your control. For the same reason, I do the heartbeats in a separate thread following the async autoheartbeater example, so I can send one periodically. But then you still have the same issue, how to interrupt the main cpu-bound thread from the io-bound heartbeat/cancellation-checking thread?\n\nOne possible solution could be to use [signals](https://docs.python.org/3/library/signal.html) to interrupt the child process? This seems to work fairly well:\n\nhttps://gist.github.com/gregbrowndev/ea3e699224185591c10c4f68fb0e65b9\n\n","createdAt":"2025-08-26T21:23:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3225778497","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7AaJkb","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> Just so I understand, the reason the _ThreadExceptionRaiser / underlying C function approach cannot be used for the multi-processed worker is because\n\nI think the reason is more simply - we don't know what executor is being used so we can't guess at how to interrupt code.\n\n> For the same reason, I do the heartbeats in a separate thread following the async autoheartbeater example, so I can send one periodically. But then you still have the same issue, how to interrupt the main cpu-bound thread from the io-bound heartbeat/cancellation-checking thread?\n\nThis is general purpose code at this point, and only you know how best to interrupt your Python code. How might you interrupt this Python code if it weren't a Temporal activity? _Technically_ you maybe can reuse `temporalio.bridge.runtime.Runtime._raise_in_thread`, though it is untested in child process and we can't guarantee compatibility. You might be able to signal the child.\n\n> One possible solution could be to use [signals](https://docs.python.org/3/library/signal.html) to interrupt the child process?\n\nWe can't even be sure the user is using multiprocessing, this code path is just for the non-threadpool executor, not specifically process pool executor.","createdAt":"2025-08-27T12:48:50Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3228080411","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7BFF9D","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"Thanks again for explaining. I think the penny just dropped for me that you're talking about third-party, possibly distributed executors rather than just the standard library ones (I didn't know there were any others).\n\nI do think it would be sensible and valuable for the SDK to support both standard library executors equally in time and add missing features such as this. Particularly now that I know its technically possible, its just the code path treats all the other executors as sync, non-threaded.\n\nI can see this issue, like the other ProcessPool executor features I requested, will a bit further back on the priority list for the time being. So happy to leave it here. But let me know if contributions are welcome and I could pick it up.\n","createdAt":"2025-08-30T15:18:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3239337795","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7Bdrd_","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> I think the penny just dropped for me that you're talking about third-party, possibly distributed executors rather than just the standard library ones\n\nIt's not just that there are third party executors, even with process pool executor, there is no obvious, single interruption approach in Python I don't believe. How would you interrupt a process-pool executor based function/task in normal Python if Temporal weren't involved? Is the approach universally what people would want? It is also important that it can be traditionally caught, shielded from, etc.\n\nIf you need advanced logic beyond the default, what you may want is to use an `async def` activity and make your own `run_in_executor` call to your process pool executor, and wait for cancellation and apply it to your process-pool-based future how you prefer best. This is effectively what we do, with some added capabilities to send heartbeats and back to the parent process and cancel info to the child process.","createdAt":"2025-09-02T15:17:10Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3245782911","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7BsYJW","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"I understand the concern, but I think there's a reasonable solution simply flipping your argument around:\n\nWhy not handle `ProcessPoolExecutor` out of the box in a somewhat opinionated, Temporal-aware way, and then if the user requires more advanced executor logic beyond the default, they can run a custom executor within an async/threaded worker?\n\n---\n\nI think all of the issues you raised are solvable without too much change:\n\n> How would you interrupt a process-pool executor based function/task in normal Python if Temporal weren't involved? \n\nI think they should be interrupted in an analogous way as the async and threaded workers, i.e. the interruption is hands off, driven by the cancellation message received by the ActivityWorker, and doesn't require user code to explicitly check which may be infeasible. \n\nLike I showed in the Gist above, using `os.pkill(pid, SIGINT)` looks as analogous to me as what the threaded worker's  `_ThreadExceptionRaiser` low-level C function is doing. All it does it raise a `KeyboardInterrupt` in process specified by the `pid`. It doesn't destroy the actual process, it can be reused for further work. Its no different from any other uncaught exception in the task. We could go further and register a `SIGINT` signal handler in the process raise a `temporalio.exceptions.CancelledError` to be consistent with the sync, threaded approach.\n\n> Is the approach universally what people would want?\n\nI think this would be a sensible default, consistent with the behaviour of the other workers. If its not the exact approach the user wants, they could run their own executor within a async/threaded worker as mentioned. I find it hard to imagine this behaviour wouldn't be the expectation of most users coming from the other two main worker types.\n\n> It is also important that it can be traditionally caught, shielded from, etc.\n\nThe exception raised by `os.pkill(pid, SIGINT)` in the child process would be a `KeyboardInterrupt` by default, but can be handled to raise a different exception. Its raised in the main thread of the process, and can be caught, ignored, reraised, etc. by normal Python code.\n\nIn the gist, I didn't handle shielding but this could be handled by backing the shield depth with the `multiprocess.Manager`. ","createdAt":"2025-09-03T15:03:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3249635926","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7Bs6ba","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> Why not handle ProcessPoolExecutor out of the box in a somewhat opinionated, Temporal-aware way, and then if the user requires more advanced executor logic beyond the default, they can run a custom executor within an async/threaded worker?\n\nThere hasn't really been enough desire for explicit process pool executor support. It's a fairly significant challenge to maintain these abstractions if they are rarely used.\n\nThere is actually some regret in supporting non-thread-pool based executors because they are much less commonly used and it's usually best for a user to control how they want to handle multiprocessing instead of Temporal choose. No other Temporal SDK supports multiprocessing. By having Temporal just execute a function and a user choose how to delegate their logic (multiprocess, sidecars, microservices, etc), we prevent issues such as our existing opinionated abstraction not sharing the same opinions as different users (e.g. not choosing a specific interruption approach, or not choosing to explicitly support process pools, or not making OTel work natively across a process boundary, etc).\n\nThere is concern about heaping on additional logic/expectations onto this lesser used non-thread-pool abstraction compared to just documenting its limitations and encouraging users to exercise more explicit control over the delegation of work/interruption/contexts from their own functions.","createdAt":"2025-09-03T15:41:09Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3249776346","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7QRkvp","author":{"login":"ikseek"},"authorAssociation":"NONE","body":"We use billiard.Pool adapted to ProcessPoolExecutor interface to run temporal sync activities that can segfault.\nIs there a supported way I can hook into activity cancelation in such worker to send a SIGINT or in worst case SIGKILL to the subprocess executing the sync activity?\nThanks.","createdAt":"2025-11-06T00:35:56Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3494267881","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7Qyw1t","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Inside the activity itself, you can wait on cancellation via `activity.wait_for_cancellation_sync()` in a background thread. It will return when the activity has been cancelled (worker shutdown or server-sent cancel assuming you are properly heartbeating) at which point the process can exit itself if it'd like. There is no way outside the activity to get the cancel, but you can use a regular `async def` activity and do https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor to your process pool executor yourself and on asyncio cancellation do something to that started execution (or just use `def` and process pool executor or subprocessing in asyncio or threaded directly).","createdAt":"2025-11-07T14:43:53Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3502968173","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7Q4evY","author":{"login":"ikseek"},"authorAssociation":"NONE","body":"@cretz Thanks for the response!\nUnfortunately wait_for_cancelled_sync raises `RuntimeError(\"Not in activity context\")` when called not in the thread where activity executes.","createdAt":"2025-11-07T19:25:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3504466904","viewerDidAuthor":false},{"id":"IC_kwDOGusT1c7Q6LRF","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> Unfortunately wait_for_cancelled_sync raises RuntimeError(\"Not in activity context\") when called not in the thread where activity executes.\n\nThis is touched on kinda at https://github.com/temporalio/sdk-python?tab=readme-ov-file#activity-context where it mentions the activity context uses https://docs.python.org/3/library/contextvars.html which do not span threads by default. You will have to use something like `copy_context` + `.run` to run code inside the same context.","createdAt":"2025-11-07T20:55:03Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/1048#issuecomment-3504911429","viewerDidAuthor":false}],"createdAt":"2025-08-24T12:17:29Z","labels":[{"id":"LA_kwDOGusT1c7gQgHN","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1048,"reactionGroups":[],"state":"OPEN","title":"[Feature Request] Support raising cancellation in sync multiprocessed activities","updatedAt":"2025-11-07T20:55:03Z","url":"https://github.com/temporalio/sdk-python/issues/1048"}
