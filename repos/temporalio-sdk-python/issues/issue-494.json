{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"### Describe the bug\r\n\r\nIt appears during GC, finally clauses in Python will end up on a different workflow's even loop. This is very bad. Here is a replication:\r\n\r\n```python\r\nimport asyncio\r\nimport logging\r\nimport time\r\nfrom concurrent.futures import ThreadPoolExecutor\r\nfrom datetime import timedelta\r\nfrom uuid import uuid4\r\n\r\nfrom temporalio import activity, workflow\r\nfrom temporalio.client import Client, WorkflowHandle\r\nfrom temporalio.worker import Worker\r\n\r\n\r\n@activity.defn\r\ndef waiting_activity() -> str:\r\n    time.sleep(1)\r\n    return \"done\"\r\n\r\n\r\n@activity.defn\r\ndef unrelated_activity() -> str:\r\n    return \"I should only be in FinallyWorkflow\"\r\n\r\n\r\n@workflow.defn\r\nclass DummyWorkflow:\r\n    @workflow.run\r\n    async def run(self) -> None:\r\n        await workflow.start_activity(\r\n            waiting_activity, start_to_close_timeout=timedelta(seconds=10)\r\n        )\r\n        await workflow.start_activity(\r\n            waiting_activity, start_to_close_timeout=timedelta(seconds=10)\r\n        )\r\n\r\n\r\n@workflow.defn\r\nclass FinallyWorkflow:\r\n    @workflow.run\r\n    async def run(self) -> None:\r\n        try:\r\n            await workflow.start_activity(\r\n                waiting_activity, start_to_close_timeout=timedelta(seconds=10)\r\n            )\r\n            await workflow.start_activity(\r\n                waiting_activity, start_to_close_timeout=timedelta(seconds=10)\r\n            )\r\n        finally:\r\n            await workflow.start_activity(\r\n                unrelated_activity, start_to_close_timeout=timedelta(seconds=10)\r\n            )\r\n\r\n\r\nasync def main():\r\n    logging.basicConfig(level=logging.INFO)\r\n\r\n    task_queue = f\"tq-{uuid4()}\"\r\n    logging.info(f\"Starting on task queue {task_queue}\")\r\n\r\n    # Connect\r\n    client = await Client.connect(\"localhost:7233\")\r\n\r\n    # Run with worker\r\n    with ThreadPoolExecutor(100) as activity_executor:\r\n        async with Worker(\r\n            client=client,\r\n            task_queue=task_queue,\r\n            workflows=[FinallyWorkflow, DummyWorkflow],\r\n            activities=[waiting_activity, unrelated_activity],\r\n            activity_executor=activity_executor,\r\n            max_concurrent_workflow_tasks=5,\r\n            max_cached_workflows=10,\r\n        ):\r\n\r\n            # Create 1000 dummy and finally workflows\r\n            dummy_handles: list[WorkflowHandle] = []\r\n            logging.info(\"Starting dummy and finally workflows\")\r\n            for i in range(1000):\r\n                dummy_handles.append(\r\n                    await client.start_workflow(\r\n                        DummyWorkflow.run, id=f\"dummy-{uuid4()}\", task_queue=task_queue\r\n                    )\r\n                )\r\n                await client.start_workflow(\r\n                    FinallyWorkflow.run, id=f\"finally-{uuid4()}\", task_queue=task_queue\r\n                )\r\n\r\n            # Wait on every dummy handle, which basically waits forever if/when\r\n            # one hits non-determinism\r\n            logging.info(\"Checking dummy and finally workflows\")\r\n            for _, handle in enumerate(dummy_handles):\r\n                logging.info(f\"Checking dummy result for {handle.id}\")\r\n                await handle.result()\r\n            logging.info(\"No dummy workflows had finally activities\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```\r\n\r\nRunning that against a localhost server will start to spit out non-determinism errors. And after a few seconds, if you look at the still-running `DummyWorkflow`s, you'll see they run `unrelated_activity` which is not even in their code. It is suspected this is caused by `GeneratorExit` happening with finally upon cache eviction, and that is being interleaved in the same thread as another workflow that has `asyncio._set_running_loop` on the thread.\r\n\r\nWe may need to implement a special async gen capture/finalizer, see https://peps.python.org/pep-0525/#finalization.","closedAt":"2024-04-05T14:00:14Z","comments":[{"id":"IC_kwDOGusT1c543bsl","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"An update - so basically there's no way for us to intercept GC to make sure it only runs on a certain thread. There are ways if we wanted to \"stop the world\" (i.e. disable GC and such), but nothing specific to a workflow. Can't use any form of weakref ref/finalize before/after on the higher level event loop to confirm GC of transitive coroutines. Can't disable the `GeneratorExit` behavior on GC of Coroutine in any way in Python that we can find (coroutine wrapper long since deprecated/removed, event loop not told about every coroutine, etc). Async generator capture/finalizer does nothing for general coroutines.\r\n\r\nSo what is clear is that we need to force tasks to complete before we try to GC. This is similar to what we do in other SDKs on eviction where we tell coroutines to complete and just ignore any commands or side effects they may have. The first attempt at this is promising on [this commit](https://github.com/cretz/temporal-sdk-python/commit/13d06adfd677bc661917bb7f6b6b35bc95f87d17), but it is a scary change, because if for some reason a user's code can't have its tasks torn down, it will never get evicted which means the memory never gets reclaimed and a slot is used on that worker forever and it can't run anything for that run ID again either. This is technically preferable to running code on the wrong workflow of course, but we may need a better approach here (e.g. moving the workflow to a different place).\r\n\r\nWe are still researching here.","createdAt":"2024-03-29T22:39:01Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-python/issues/494#issuecomment-2027797285","viewerDidAuthor":false}],"createdAt":"2024-03-26T16:26:46Z","labels":[{"id":"LA_kwDOGusT1c7gQgHK","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":494,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Commands sent during finally of a cache eviction may cross workflow contexts","updatedAt":"2024-04-05T14:00:14Z","url":"https://github.com/temporalio/sdk-python/issues/494"}
