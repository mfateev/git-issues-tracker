{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNTA0MDQ5","is_bot":false,"login":"Quinn-With-Two-Ns","name":"Quinn Klassen"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\nAdd `WorkflowIdConflictPolicy` in child workflow options\r\n\r\n### Additional context\r\n\r\nhttps://github.com/temporalio/features/issues/437\r\n\r\nServer must be done first: https://github.com/temporalio/temporal/issues/6799\r\n\r\n### Per-SDK Tickets\r\n\r\n<!-- Add links here once the tickets are created (no need to create them immediately). -->\r\n\r\n- [ ] Go - \r\n- [ ] Java - https://github.com/temporalio/sdk-java/issues/2308\r\n- [ ] Core - \r\n- [ ] TypeScript - \r\n- [ ] Python - \r\n- [ ] .NET - \r\n- [ ] Ruby - \r\n- [ ] PHP - \r\n- [ ] Temporal CLI - \r\n","closedAt":null,"comments":[{"id":"IC_kwDOGflYbs6pXL0X","author":{"login":"john-behm-bertelsmann"},"authorAssociation":"NONE","body":"bump for Go SDK","createdAt":"2025-04-30T09:49:11Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-2841427223","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs6wdsEK","author":{"login":"prakharb10"},"authorAssociation":"NONE","body":"Ran into this today for the Python SDK","createdAt":"2025-06-10T21:01:48Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-2960572682","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69UJzi","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"I want to make a comment here for other users reading on why use-existing may not make technical sense...\n\nThere are two situations where you might want conflict policy on children: 1) to apply to sibling children in that same parent workflow, or 2) to apply to all workflows across the namespace. For the former, a parent starts the child workflow, it can keep track if it was already started and/or is done. For the latter, reattaching some other workflow now as a child of this one if conflict does occur doesn't make sense (what if 10 workflows had this conflict policy, does the already-existing workflow now have 10 parents?).","createdAt":"2025-08-11T17:58:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3176176866","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69UXPi","author":{"login":"lukeramsden"},"authorAssociation":"NONE","body":"I'm not convinced that's a sufficiently good reason to not do it - you can already do this from _outside_ Temporal workflows via the client, you just can't do it _inside_. USE_EXISTING from inside a workflow does not necessarily have to re-parent the targeted workflow, surely? Are there internal limitations in the cluster that would absolutely require all workflows that communicate to have a parental relationship? The workarounds for this are both ugly and more operationally complex, and it crops up quite often for us.","createdAt":"2025-08-11T18:07:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3176231906","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69U_rX","author":{"login":"madhav2302"},"authorAssociation":"NONE","body":"I agree with @lukeramsden\nI am not convinced with the argument provided as well. \n\nChildWorkflows are more of a reference for our use-case, rather than real parent-child relation. \n\nIt is easier to build DAG based workload if we can simply re-attach existing running workflow, rather than going through the ugly workaround of signals, and running child workflow from an activity. \n\n","createdAt":"2025-08-11T18:59:06Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3176397527","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69VgOl","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> USE_EXISTING from inside a workflow does not necessarily have to re-parent the targeted workflow, surely?\n\nIt does, because the lifetimes (e.g. parent close policy) and cancellation events concerning child workflows are very specific to child workflows and are expected to apply to whatever start/execute child workflow returns. Child workflows are bound to their parents. I suppose we could say \"if you use 'abandon' parent close policy and promise to never need to cancel the child workflow, then you could use use-existing conflict policy\" but at that point, why are you using child workflows instead of top-level workflows started via a Temporal client in an activity? If you do want to react to a \"workflow already exists\" conflict for children in whatever way, all SDKs already provide a very specific error for this that is returned when you try to start a child. The use-existing conflict policy just becomes sugar that doesn't even support all child features.\n\nIt would be confusing for users to turn off half the child handle features because it happened to not actually be a child despite the \"start child\" call returning a success as if it was.","createdAt":"2025-08-11T19:19:37Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3176530853","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69Vwps","author":{"login":"madhav2302"},"authorAssociation":"NONE","body":"> I suppose we could say \"if you use 'abandon' parent close policy and promise to never need to cancel the child workflow, then you could use use-existing conflict policy\"\n\nYes, it can be mandatory if using child workflows with workflow id conflict policy for child workflows. \n\n> at that point, why are you using child workflows instead of top-level workflows started via a Temporal client in an activity?\n\nThe idea is to have cleaner interface, and readability of flow instead of using activity and signals as workaround, which is fine if you use it for very small use-case, but it makes very sense to have it for major business use-case. \n\n> If you do want to react to a \"workflow already exists\" conflict for children in whatever way, all SDKs already provide a very specific error for this that is returned when you try to start a child.\n\nIt's not being reactive, but usually DAG workload needs to wait until the child completes. \n\nOf-course, above use case of starting workflow and waiting can be solved if you use `updateWithStart`, but still it needs to be supported via workflow code. Also it had it's own limitations related to inflight updates. ","createdAt":"2025-08-11T19:33:34Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3176598124","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69V0-f","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> The idea is to have cleaner interface, and readability of flow instead of using activity and signals as workaround, which is fine if you use it for very small use-case, but it makes very sense to have it for major business use-case.\n\nArguably it is not cleaner if most of the child handle things don't work. It is more confusing to users if sometimes stuff just doesn't work for children because it's not really a child even though we returned a success from start child. You can't even get the result ([here](https://github.com/temporalio/api/blob/d96bd55e87799e9f6a33a1c40a56cfa932566bdf/temporal/api/history/v1/message.proto#L1062-L1066) are the child completion events that would now just only work if you're lucky enough to not have a conflict).\n\n> It's not being reactive, but usually DAG workload needs to wait until the child completes.\n\nWaiting for child to complete is not supported for non-children (such as those that may be returned on use-existing conflict policy). Supporting waiting on unrelated workflow result inside a workflow is a possible feature Temporal can build, but is a separate feature (like signaling an unrelated workflow which is supported).","createdAt":"2025-08-11T19:36:16Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3176615839","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69eBj3","author":{"login":"lukeramsden"},"authorAssociation":"NONE","body":"> Supporting waiting on unrelated workflow result inside a workflow is a possible feature Temporal can build, but is a separate feature (like signaling an unrelated workflow which is supported).\n\nI think this is what we're actually wanting here, yes. I have a very similar DAG usecase (or it sounds like I do) to @madhav2302 and they are not child workflows, but I do want to wait on the result of them (and the parent cancellation policies etc are irrelevant)","createdAt":"2025-08-12T10:35:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3178764535","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69fUIN","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"That is a separate issue at https://github.com/temporalio/temporal/issues/680","createdAt":"2025-08-12T12:23:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3179102733","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69fana","author":{"login":"lukeramsden"},"authorAssociation":"NONE","body":"> That is a separate issue at [temporalio/temporal#680](https://github.com/temporalio/temporal/issues/680)\n\nThis does not cover starting the workflow or re-using the already running workflow in an atomic way though, which is what USE_EXISTING does","createdAt":"2025-08-12T12:29:45Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3179129306","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69h1zD","author":{"login":"madhav2302"},"authorAssociation":"NONE","body":"@cretz Ideally, we would want an atomic way of starting (if not exist) and waiting for the result. ChildWorkflow with WorkflowIdConflictPolicy sounded like the idea, but we have no issues if we can simply start another workflow with WorkflowIdConflictPolicy option from workflow code and we don't call it child workflow. ","createdAt":"2025-08-12T15:09:31Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}},{"content":"HEART","users":{"totalCount":1}}],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3179764931","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69jQl4","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> This does not cover starting the workflow or re-using the already running workflow in an atomic way though, which is what USE_EXISTING does [...] Ideally, we would want an atomic way of starting\n\nRight, you would need to start via activity (or we'd have to introduce a primitive for starting a non-child from a workflow). Overall though, the need to atomically start a workflow and/or wait for a workflow's result from inside the workflow is not the same as a child workflow. A child workflow has many expectations beyond just this.\n\nIn the meantime, I would recommend if you need this behavior to look in to Nexus operations if your language supports it (we are bringing this to all languages soon). Having a Nexus operation backed by a workflow w/ a conflict policy is the ideal way to have one workflow atomically/optionally start and wait on the result of another. Also, as a bonus, workflow-backed Nexus operations can work across namespaces, something child cannot in cloud.","createdAt":"2025-08-12T16:28:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3180136824","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69jXza","author":{"login":"prasek"},"authorAssociation":"MEMBER","body":"more info on ☝️ https://docs.temporal.io/nexus/operations#attaching-multiple-nexus-callers","createdAt":"2025-08-12T16:39:13Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3180166362","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69kYmL","author":{"login":"madhav2302"},"authorAssociation":"NONE","body":"> In the meantime, I would recommend if you need this behavior to look in to Nexus operations if your language supports it (we are bringing this to all languages soon). Having a Nexus operation backed by a workflow w/ a conflict policy is the ideal way to have one workflow atomically/optionally start and wait on the result of another. Also, as a bonus, workflow-backed Nexus operations can work across namespaces, something child cannot in cloud.\n\nWe are using java, are there examples of it we can refer to? ","createdAt":"2025-08-12T18:03:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3180431755","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs69koc-","author":{"login":"madhav2302"},"authorAssociation":"NONE","body":"> or we'd have to introduce a primitive for starting a non-child from a workflow\n\nThis would be the best thing, and simple one from user perspective as well. \n\nUsing nexus have it's complexity of maintaining a new component. We will surely look into it. ","createdAt":"2025-08-12T18:23:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3180496702","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs7AQjy0","author":{"login":"prasek"},"authorAssociation":"MEMBER","body":"> We are using java, are there [Nexus] examples of it we can refer to?\n\n[Here’s the tutorial](https://docs.temporal.io/develop/java/nexus) and [sample](https://github.com/temporalio/samples-java/tree/main/core/src/main/java/io/temporal/samples/nexus). The conflict policy belongs on the `WorkflowOptions` in the [Nexus Service implementation](https://github.com/temporalio/samples-java/blob/main/core/src/main/java/io/temporal/samples/nexus/handler/NexusServiceImpl.java#L50)\n\n```\n.setWorkflowIdConflictPolicy(\n    WorkflowIdConflictPolicy.WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING)\n```\n\nas mentioned in [the docs](https://docs.temporal.io/nexus/operations#attaching-multiple-nexus-callers):\n> Nexus Operations that start a Workflow with the [New-Workflow-Run-Operation](https://docs.temporal.io/nexus/operations#sdk-support) SDK helper will automatically attach a completion Callback on the handler Workflow, so the Nexus caller receives the result. Additional Nexus callers may attach to the same handler Workflow if the Nexus handler uses a [Conflict-Policy of Use-Existing](https://docs.temporal.io/workflow-execution/workflowid-runid#workflow-id-conflict-policy).\n\n> A single handler Workflow Execution has a [Workflow Callback limit](https://docs.temporal.io/workflow-execution/limits#workflow-execution-callback-limits) that governs how many Nexus callers can be attached. Nexus callers that exceed the limit will receive an error.\n\nNote this this is not a Nexus limitation, but the Workflow Callback limit (currently 32) affects how many Nexus callers can attach to the same underlying handler Workflow Execution. Workflow Callbacks support state-based delivery with auto-retries, circuit breaking, rate limiting and so on.\n\nIn the near future we're looking to support > 32 Nexus callers with manual Nexus completion callback delivery. This will allow you to opt-out of the built-in Workflow Callback mechanism by manually storing the Nexus callback tokens in a handler Workflow variable (or external storage), and then manually delivering Nexus completion callbacks via a new Temporal SDK `CompleteNexusOperation` method that should be called just prior to handler Workflow completion. Note this approach will scale to a very large number of Nexus callers.\n\nLonger term we're looking to significantly raise the built-in [Workflow Callback limit](https://docs.temporal.io/workflow-execution/limits#workflow-execution-callback-limits), which should cover all but the largest scenarios and provide the best ergonomics.\n\nIn short:\n1. there's a limit of 32 Nexus callers that can attach to a single handler Workflow Execution today\n2. we're working on supporting > 32 Nexus callers with manual Nexus completion callback delivery\n3. longer term we're looking into substantially increasing the number of built-in Workflow Callbacks supported","createdAt":"2025-08-26T20:03:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3225566388","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs7AQqbe","author":{"login":"lukeramsden"},"authorAssociation":"NONE","body":"This is okay but still ultimately a hacky workaround and is not a quick lift for those of us not already using Nexus. \n\nNot having this built-in requires us to explicitly think about all failure cases for our 'infinite-retry' activities that start workflows, and to do that in a way that doesn't cause issues like for example infinitely restarting a broken/bugged workflow is tricky.\n\nThis ultimately breaks the 'durable execution' promise: \"Failures happen. Temporal makes them irrelevant. Build applications that never lose state, even when everything else fails.\"\n\n```typescript\n    private readonly infiniteActivities = proxyActivities({\n      startToCloseTimeout: '1h',\n      heartbeatTimeout: '10s',\n      allowEagerDispatch: true,\n      retry: {\n        maximumAttempts: Infinity, // we retry infinitely\n        initialInterval: '100ms', // immediately retries on another server, useful if it was just a single node crash\n        backoffCoefficient: 5, // very high because we want to immediately back off to the 5s interval\n        maximumInterval: '5s',\n        nonRetryableErrorTypes: ['WorkflowFailedError'] // don't retry if the workflow failed, it's probably a bug and not a transient issue\n      },\n    })\n```\n\nThis is how I currently do it. \n\nShould we split this issue in to the 'child workflow reparenting' feature and the 'waiting on result of unrelated workflow' feature?","createdAt":"2025-08-26T20:13:19Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3225593566","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs7Awv6k","author":{"login":"madhav2302"},"authorAssociation":"NONE","body":"> This will allow you to opt-out of the built-in Workflow Callback mechanism by manually storing the Nexus callback tokens in a handler Workflow variable (or external storage), and then manually delivering Nexus completion callbacks via a new Temporal SDK CompleteNexusOperation method that should be called just prior to handler Workflow completion. Note this approach will scale to a very large number of Nexus callers.\n\nDoes this mean it's a manual signal way implementation where the user needs to maintain it? It sounds very similar to me as a signal.\n\nIt will defeat the purpose of atomic completion of caller workflow , as what if the called workflow terminated due to any reason, and now it's not able to send the completion signal back. The caller workflow will keep waiting indefinitely. \n\nAlso, the opt-out is also not nice due to 99% of our workload can be satisfies the limits and we have no way to determine which workload needs to be opt in or opt out when they start. \n\nIt would be nice if we you can convert it into automatic manual handler when we hit the limit, and if that's not implemented, simply throw an error. \n\n> longer term we're looking into substantially increasing the number of built-in Workflow Callbacks supported\n\nWould be nice to put some timelines on it, as it will help us plan our efforts accordingly. ","createdAt":"2025-08-28T15:36:01Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3234004644","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs7IPHyR","author":{"login":"lukeramsden"},"authorAssociation":"NONE","body":"I've found another issue that working around this limitation / the workaround of using an activity causes, which is that propagating cancellation is now a lot more complex (we want to cancel the entire stack of workflows from the root, but now there are activities between them)","createdAt":"2025-10-02T06:46:01Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3359407249","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs7XnwWr","author":{"login":"sovanny"},"authorAssociation":"NONE","body":"I did the following workaround for `TERMINATE_EXISTING`:\n\nWhen starting the parent workflow that will start the child workflows whose IDs already have running child workflows elsewhere, for each of the ID get the external handle and cancel.\n```\nawait Promise.allSettled(\n  workflowIdsToCancel.map((workflowId) => {\n    const handle = getExternalWorkflowHandle(workflowId);\n    return handle.cancel();\n  }),\n);\n```\n\nAs for how to get the IDs, we first considered using `listWorkflowExecutions`, but as they are eventually consistent, we had to rely on information from our db, where we keep track of if a workflow is running or not (updating it before starting and in the last activity). So we first fetch those and provide as input to the parent workflow.\n\nAny input on this workaround is appreciated.","createdAt":"2025-12-05T16:08:00Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/558#issuecomment-3617523115","viewerDidAuthor":false}],"createdAt":"2024-11-05T15:58:54Z","labels":[{"id":"LA_kwDOGflYbs7XtLc6","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":558,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":3}}],"state":"OPEN","title":"Add WorkflowIdConflictPolicy in child workflow options","updatedAt":"2025-12-05T16:08:00Z","url":"https://github.com/temporalio/features/issues/558"}
