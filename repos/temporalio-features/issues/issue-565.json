{"assignees":[],"author":{"id":"MDQ6VXNlcjQwNDk3NDQ5","is_bot":false,"login":"Noot-tooN","name":"Aleksa Novcic"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\nImagine that you want to guarantee a chain of events for some user as they come in the workflow.\r\nFirst created event (lets call it event `A`) inside the workflow will have no parent\r\nSecond created event (event `B`) inside the workflow should have event `A` as parent, etc...\r\n\r\nYou can imagine the following pseudo code:\r\n1. Get latest from DB\r\n2. Run a long lasting `if` branch if result from step 1 fulfills some constraints\r\n3. Create row in DB with parent from step 1 if its not null\r\n\r\nWe would need to guarantee that for some user id `Get` from second workflow doesn't execute before the `Create` from first workflow is finished.\r\n\r\n### Describe the solution you'd like\r\n\r\nI would like to have some workflow function that i could simply call to Lock or Unlock critical sections of the code.\r\nFor example, taking in the previous example\r\n1. `workflow.Lock(ctx, \"someLockKey\")`\r\n2. Get latest from DB\r\n3. Run a long lasting `if` branch if result from step 1 fulfills some constraints\r\n4. Create row in DB with parent from step 1 if its not null\r\n5. `workflow.Unlock(ctx, \"someLockKey\")`\r\n\r\nThe `Lock` and `Unlock` functionality should be able to lock based on some key. In my case that would be some `userId` for example, but i believe that should be general enough for any use case.\r\nThe mechanism would need to guarantee FIFO order.\r\n\r\n### Additional context\r\n\r\n<!-- Add any other context or screenshots about the feature request here. -->\r\n\r\n### Per-SDK Tickets\r\n\r\n<!-- Add links here once the tickets are created (no need to create them immediately). -->\r\n\r\n- [ ] Go - \r\n- [ ] Java - \r\n- [ ] Core - \r\n- [ ] TypeScript - \r\n- [ ] Python - \r\n- [ ] .NET - \r\n- [ ] Ruby - \r\n- [ ] PHP - \r\n- [ ] Temporal CLI - \r\n","closedAt":"2024-12-06T22:48:19Z","comments":[{"id":"IC_kwDOGflYbs6WQ7be","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> I would like to have some workflow function that i could simply call to Lock or Unlock critical sections of the code.\r\n\r\nMutex support that mimics the language's standard library equivalent (or reuses it) should already exist now in all SDKs as part of #500. For example, `workflow.NewMutex` now exists to return a `workflow.Mutex` that can be used similar to `sync.Mutex` in the standard library. If you need key-specific mutexes, you can do that the same way you would with `sync.Mutex`.","createdAt":"2024-12-05T17:35:40Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/565#issuecomment-2521020126","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs6WXG_5","author":{"login":"Noot-tooN"},"authorAssociation":"NONE","body":"I am not sure if this can be achieved with a regular mutex.\r\n\r\nIf i were to just use a mutex it would lock a specific workflow type for all other workers, and that's not what i want to achieve. If one user was waiting on something i don't want other users to wait for that as well.\r\n\r\nIn order to achieve the key-specific mutex i think that i would have to implement some kind of never ending for loop in a separate workflow (it would act as a centralised lock manager) that would have a `map[string]MutexQueue` and 2 channels 1 for locking and 1 for unlocking and perform async actions on the appropriate queues from the map.\r\nBut i think this is an anti-pattern in Temporal. Also that would probably get filled up quickly because there is a limit of 50k events per workflow. At that point in time i would probably have to perform continue-as-new but that would lose the potentially filled up queues in the map.\r\n\r\nAm i missing something?","createdAt":"2024-12-06T09:31:02Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/565#issuecomment-2522640377","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs6WZg-b","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"> If i were to just use a mutex it would lock a specific workflow type for all other workers, and that's not what i want to achieve\r\n\r\nNo, the mutex I mentioned is only for inside the single workflow run. Are you looking for a mutex that works across workflows? If so, https://github.com/temporalio/samples-go/tree/main/mutex may be what you are looking for. It does accept a key name.","createdAt":"2024-12-06T13:35:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/features/issues/565#issuecomment-2523271067","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs6Wad5n","author":{"login":"Noot-tooN"},"authorAssociation":"NONE","body":"First of all thanks!\r\n\r\nTried out the sample code and it seems to be working with some errors, which are probably from my bad implementation. When i have have some workflows waiting on the lock when the lock gets freed, the workflows get duplicated for some reason. There is only 1 activity before the lock which always finishes successfully. Would appreciate help if you can assume what's going on, but i'll probably figure it out on my own after some trial and error.\r\n\r\nAlthough there is currently a sample how to achieve something like this i still think it would be more convenient if we simply had something like `workflow.Lock(ctx, key)` or maybe `AtomicChildWorkflow(key)` but i guess that `workflow.Lock` is more universal.\r\nSome benefits i see from this:\r\n- It could probably avoid showing up in the temporal history in the UI\r\n- No manual creation of workers for \"mutex\" queue. I guess that \"mutex\" queue is hardcoded in the mutex package for a reason to separate from other queues (or it may as well not be, not sure).\r\n- Easier for devs to use, i probably wouldn't have this duplication of workflows happening :smile: \r\n- Temporal would guarantee that this works as intended","createdAt":"2024-12-06T15:40:05Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/features/issues/565#issuecomment-2523520615","viewerDidAuthor":false},{"id":"IC_kwDOGflYbs6WbCmU","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"The benefit of Temporal workflows being a primitive is you can do anything you want here instead of Temporal providing some rigid primitive. What if you wanted a semaphore instead of a single item lock? Or what if you wanted some different logic on lock release? Or what if you wanted some other kind of critical section barrier across workflows that uses some other custom logic beyond naive lock/unlock? This is why we offer this as a sample so each can customize as they need, even if your current need is just for a simple lock/unlock.\r\n\r\nIt is possible in the future we may provide cross-workflow built-ins like this, but there are no near term plans to do so.","createdAt":"2024-12-06T16:23:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/features/issues/565#issuecomment-2523670932","viewerDidAuthor":false}],"createdAt":"2024-12-05T13:47:40Z","labels":[{"id":"LA_kwDOGflYbs7XtLc6","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":565,"reactionGroups":[],"state":"CLOSED","title":"Create FIFO mutex mechanism for locking access to some part of a workflow","updatedAt":"2024-12-06T22:48:19Z","url":"https://github.com/temporalio/features/issues/565"}
