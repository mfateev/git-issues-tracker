{"assignees":[],"author":{"id":"MDQ6VXNlcjUzMjEwOA==","is_bot":false,"login":"Spikhalskiy","name":"Dmitry Spikhalsky"},"body":"## Objective\n\nTo reduce the latency between `WorkflowClient#start` call and the dispatching of the workflow task to the worker, a new Server feature that performs an \"Eager Workflow Task Dispatch\" on a start call was implemented.\nSee relevant Server PRs for details:\nhttps://github.com/temporalio/temporal/pull/3835 \nhttps://github.com/temporalio/temporal/pull/3928\n\nTL;DR\nA `WorkflowClient` that is aware of an existing local workflow worker can request an eager Workflow Task on the `start` call and get the first Workflow Task of the Workflow Execution back immediately in the Start call response. This allows Server to\n- skip matching for this workflow task\n- use one transaction instead of two for persisting both the `WorkflowExecutionStarted+WorkflowTaskScheduled` events and `WorkflowTaskStarted` event.\n\n## Start Call\n\n```mermaid\nsequenceDiagram\n    actor C as UserCode\n    participant Stub as WorkflowStub\n    participant WC as WorkfkflowClient\n    participant WF as WorkerFactory \n    participant W as Worker\n    participant S as Server\n\n    C->>WF: getWorkflowClient\n    C->>+WC: start(eagerDispatch=true[default])\n    WC->>WF: getWorker(taskQueue)\n    alt there is a worker for the task queue\n        WC->>+W: reserveWorkflowExecutor\n        W-->>-WC: wftDispatchHandle [optional]\n\n        opt if reserved a worker slot\n            rect rgba(191, 223, 255, 0.4)  \n                WC->>+S: start(eagerDispatch=true)\n                S-->>-WC: eager WFT [optional]\n                opt Server gave us back an eager task\n                    WC->>W: wftDispatchHandle.dispatch(wft)\n                  \n                end\n            end    \n\n            WC->>WC: wftDispatchHandle.release()\n            Note right of WC: .release() should be a no-op if .dispatch(wft) was called\n            \n        end\n    else no worker or no free worker slot\n        rect rgba(250, 50, 50, 0.3)\n            WC->>S: start(eager=false)\n        end   \n    end\n    WC-->>-C: WorkflowStub(execution)\n```\n\n## WorkflowClient awareness of WorkerFactory\n\n1.  `WorkerFactory` should `register` itself on the `WorkflowClient` the last thing during start and `deregister` itself as the first step during a shutdown.\n2. `WorkflowClient` implementation should maintain a set of registered `WorkflowFactory`.\n3. When routing an eager task `WorkflowClient` MUST try `WorkflowFactory` from the registered ones in random order. \n    1. It‚Äôs not enough to just select one random `WorkflowFactory`, as its corresponding worker can be paused or get into a shutdown state right after selection. If this happens, `Worker#reserveWorkflowExecution` will return a null or another token meaning unsuccessful reservation and the next random `WorkflowFactory` SHOULD be used in an attempt to get the reservation.\n    2. In normal use cases, `WorkflowClient` should have one `WorkflowFactory` at a time. So the performance of this random selection is not that important. Legitimate situations when `WorkflowClient` has several registered `WorkerFactory`:\n        1. User ‚Äúrestarts‚Äù a WorkerFactory. With different sets of workers or different options. Users would typically start a new WorkerFactory first and shut down an old one after that. This will lead to a period of time with two active Worker fleets.\n        2. Users use several `WorkerFactory` as means of ‚Äúhorizontal‚Äù scaling. It doesn‚Äôt make much sense to do. Instead, users should be scaling workers up. But it‚Äôs totally allowed by the current API at the moment. And it‚Äôs not an illegitimate approach. We don‚Äôt want all eager tasks from a WorkflowClient to be dispatched to only one WorkerFactory out of all assigned to the WorkflowClient.\n\n## Eager Dispatch Flow implementation notes\n\n1. `WorkflowOptions` gets a `disableEagerExecution` flag that is ‚Äúfalse‚Äù by default.\n2. Eager Dispatch is ‚Äúbest effort‚Äù. If it doesn‚Äôt go through, an old-style dispatch is used. `WorkflowOptions#disableEagerExecution==false``is not a guarantee for an eager dispatch. \n    1. The same instance of `WorkflowClient` that was used to create `WorkerFactory` SHOULD be used for `WorkflowClient#start` call to be performed with a local eager dispatch. This `WorkflowClient` MAY also be obtained from `WorkflowFactory`\n    2. A corresponded worker MAY decline eager dispatch for any reason by \n        1. Not providing a `WFTDispatchHandle` on `Worker#reserveWorkflowExecutor` call. WorkflowClient shouldn‚Äôt request eager dispatch from the Server then.\n        2. Responding with `false` to `WFTDispatchHandle#dispatch` call on an already obtained reservation.\n        \n        It SHOULD decline if \n        \n        1. there are no free workflow task executor slots \n        2. it is in any other state that is not `ACTIVE` (Considering `NOT_STARTED`, `ACTIVE`, `PAUSED`, `SHUTDOWN`, `TERMINATED`)\n        3. it is unhealthy (definition may vary by SDK)\n\n### Local Workflow Completion\n\nThe original proposal included the concept of Local Workflow Completion. The idea was that a worker after receiving an eagerly dispatched workflow task may return a workflow completion promise that will be completed once the workflow is completed locally. \n\nLater it was taken out because it was understood that this concept will provide little to no benefits. Reasoning: to provide local completion consistently with persisted history, the local completion should be filled by the worker only after receiving a response from the Server on the workflow task completion request. There is currently no reason to assume that this response will be received much earlier than a completion of a long poll opened by the Workflow Client for a workflow completion event. Both should typically be arriving on a single server ‚Üí client trip.\n\n## SDKs supports\n\n- [x] https://github.com/temporalio/sdk-java/issues/1646 \n- [x] GoSDK\n- [x] Core\n- [x] TsSDK\n- [x] PythonSDK\n- [x] .NetSDK","closedAt":"2025-09-03T22:41:20Z","comments":[{"id":"IC_kwDOGflYbs7Bxtfy","author":{"login":"Sushisource"},"authorAssociation":"MEMBER","body":"Done in all SDKs! Yay!\n\n(ps: Hey @Spikhalskiy üòÑ )","createdAt":"2025-09-03T22:41:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HOORAY","users":{"totalCount":1}},{"content":"HEART","users":{"totalCount":1}}],"url":"https://github.com/temporalio/features/issues/242#issuecomment-3251034098","viewerDidAuthor":false}],"createdAt":"2023-03-07T03:42:46Z","labels":[{"id":"LA_kwDOGflYbs7XtLc6","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":242,"reactionGroups":[],"state":"CLOSED","title":"[Feature Request] Eager Workflow Task Dispatch on SDKs","updatedAt":"2025-09-03T22:41:20Z","url":"https://github.com/temporalio/features/issues/242"}
