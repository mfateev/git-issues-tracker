{
  "generatedAt": "2026-01-22T20:28:21.429Z",
  "totalCards": 388,
  "cards": [
    {
      "summary": "Add support for the 'as-is' scheduled workflow ID field to programmatic SDK interfaces. This field was previously added to the API but needs to be exposed across all Temporal SDKs.",
      "category": "feature",
      "subcategory": "scheduling",
      "apis": [
        "SchedulePolicy"
      ],
      "components": [
        "schedule-policy",
        "sdk-interfaces",
        "api-bindings"
      ],
      "concepts": [
        "scheduling",
        "workflow-id",
        "schedule-options",
        "api-alignment"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure as-is scheduled workflow IDs through SDK programmatic interfaces until this feature is implemented across all SDKs.",
      "rootCause": null,
      "proposedFix": "Add the new field to schedule policy in all SDKs (Go, Java, TypeScript, Python, .NET, Ruby, PHP) to match the API change from api#357",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This was added a while back in API at https://github.com/temporalio/api/pull/357 but never to our programmatic interfaces. Just need this new field on schedule policy.",
      "number": 727,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-22T20:28:18.812Z"
    },
    {
      "summary": "Add comprehensive versioning support for OSS v1.30 GA release, including exposing RoutingConfigUpdateState, Upgrade-on-CaN option, Backlog Stats, TaskQueue information in DescribeVersion/DescribeTaskQueue, and making Pinned Version optional for pinned workflow overrides.",
      "category": "feature",
      "subcategory": "versioning",
      "apis": [
        "DescribeVersion",
        "DescribeTaskQueue",
        "StartWorkflow",
        "UpdateWorkflow",
        "ResetWorkflow"
      ],
      "components": [
        "versioning-system",
        "task-queue-management",
        "deployment-info",
        "api-definitions"
      ],
      "concepts": [
        "versioning",
        "upgrade-on-can",
        "routing-config",
        "task-queue-stats",
        "pinned-override",
        "backlog-stats"
      ],
      "severity": "high",
      "userImpact": "Users need full versioning support including upgrade options and task queue statistics to fully adopt versioning for GA and manage workflow deployments effectively.",
      "rootCause": null,
      "proposedFix": "Expose RoutingConfigUpdateState in DeploymentInfo, add Upgrade-on-CaN option and ContinueAsNewSuggestedReasons, expose Backlog Stats in DescribeVersion, add TaskQueueStats/TaskQueueConfig to DescribeTaskQueue, and make Pinned Version optional for pinned workflow overrides.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2162
      ],
      "keyQuote": "Need to support versioning more fully to announce GA. Also need to expose upgrade-on-CaN option",
      "number": 726,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-22T20:28:21.359Z"
    },
    {
      "summary": "SDKs should validate payload sizes before submission and fail workflow tasks gracefully when payloads exceed known limits, rather than submitting requests that will fail. This allows workflows to be updated and resumed without wasting network bandwidth.",
      "category": "feature",
      "subcategory": "payload-validation",
      "apis": [
        "StartWorkflow",
        "SignalWorkflow"
      ],
      "components": [
        "sdk-client",
        "workflow-task-handler",
        "payload-validator"
      ],
      "concepts": [
        "payload-size-limits",
        "error-handling",
        "workflow-recovery",
        "network-optimization",
        "data-compression",
        "graceful-failure"
      ],
      "severity": "medium",
      "userImpact": "Users can proactively handle oversized payloads by updating workflows to compress or externalize data, avoiding failed workflow runs and unnecessary network uploads.",
      "rootCause": "SDKs currently do not validate payload sizes before submission, causing entire requests to fail when limits are exceeded rather than failing the task gracefully.",
      "proposedFix": "SDKs should know the payload size limits and submit workflow task failures instead of completions with oversized payloads, allowing workflows to continue if updated.",
      "workaround": "Users can manually compress data or move large payloads to external storage before submitting to Temporal.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If the SDK knows the error limits for payloads, it can submit a workflow task failure rather than submitting a completion that contains oversized payloads.",
      "number": 723,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-22T20:28:18.942Z"
    },
    {
      "summary": "Add workflowId to HTTP headers for workflow requests to enable API gateways and frontends to route requests to the correct active cluster without decoding the request payload. SDKs need to include workflowId in headers for initiated actions (StartWorkflow, SignalWorkflow) and attach headers from poll responses for action-after-poll requests (RespondWorkflow/ActivityTask).",
      "category": "feature",
      "subcategory": "http-routing",
      "apis": [
        "StartWorkflow",
        "SignalWorkflow",
        "TerminateWorkflow",
        "RespondWorkflowTask",
        "RespondActivityTask",
        "PollWorkflowTaskQueue",
        "PollActivityTaskQueue"
      ],
      "components": [
        "http-client",
        "request-headers",
        "sdk-core",
        "api-gateway-routing"
      ],
      "concepts": [
        "request-routing",
        "cluster-selection",
        "http-headers",
        "workflow-identity",
        "load-balancing",
        "api-gateway"
      ],
      "severity": "medium",
      "userImpact": "Enables API gateways and frontends to efficiently route workflow requests to correct active clusters without decoding request payloads.",
      "rootCause": null,
      "proposedFix": "SDK adds workflowId to request headers for SDK-initiated actions; SDK attaches headers from poll responses to action-after-poll requests; server adds header at poll response.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Include workflowId in the header will enable the api gateway/frontend route the workflow request to correct active cluster without having to decode/open the request payload",
      "number": 721,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-22T20:28:02.715Z"
    },
    {
      "summary": "WorkflowInfo.Priority field is currently immutable and does not reflect updates made via the new priority override capability introduced in api#610. The Priority in WorkflowInfo needs to be updated to reflect the current status when modified.",
      "category": "bug",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "priority-management"
      ],
      "concepts": [
        "workflow-metadata",
        "priority-override",
        "state-synchronization",
        "immutability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot see the current priority of their workflow in WorkflowInfo after updating it, causing confusion about the actual priority being used.",
      "rootCause": "Priority field in WorkflowInfo is marked as immutable and not updated when priority is changed after workflow execution starts.",
      "proposedFix": "Make Priority in WorkflowInfo mutable and ensure it reflects the current priority status when updated.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        610
      ],
      "keyQuote": "Priority in WorkflowInfo needs to reflect the current status; ie be changed when it was updated.",
      "number": 720,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-22T20:28:00.825Z"
    },
    {
      "summary": "Logs emitted in query handler functions are dropped when using the replay-safe logger, because `workflow.unsafe.is_replaying()` returns true during query execution. This prevents developers from logging diagnostic information in query handlers.",
      "category": "bug",
      "subcategory": "logging-queries",
      "apis": [
        "workflow.logger",
        "workflow.query",
        "workflow.unsafe.is_replaying"
      ],
      "components": [
        "logger",
        "query-handler",
        "replay-detection"
      ],
      "concepts": [
        "logging",
        "queries",
        "replay-safety",
        "side-effects",
        "diagnostics"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use replay-safe logging in query handlers, forcing them to switch to regular loggers or lose logging capability in queries.",
      "rootCause": "The `is_replaying()` function returns true during query execution, and the replay-safe logger uses this to filter out logs, but queries should allow logging as a side effect.",
      "proposedFix": "Modify the replay detection logic or logger behavior to allow logging in query handlers while maintaining replay safety elsewhere.",
      "workaround": "Use a normal logger (logging.getLogger(...)) instead of the replay-safe logger inside query handlers.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1274,
        594,
        378,
        1887
      ],
      "keyQuote": "It's intentional that `is_replaying` is true, but the side effect of not emitting logs isn't.",
      "number": 718,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-22T20:28:05.030Z"
    },
    {
      "summary": "Feature request to add custom metadata support for workers in Temporal, allowing users to attach operational information like environment, version, and team ownership that can be viewed in the UI and CLI.",
      "category": "feature",
      "subcategory": "worker-metadata",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "worker-registration",
        "temporal-ui",
        "temporal-cli"
      ],
      "concepts": [
        "metadata",
        "worker-identity",
        "operational-visibility",
        "worker-deployment",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users without worker deployments or versioning features lack operational visibility into worker-specific metadata in the UI and CLI.",
      "rootCause": null,
      "proposedFix": "Add setMetadata() method to WorkerOptions to allow setting custom metadata during worker registration, with display support in UI and CLI describe task queue commands.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workers currently only support identity information, which appears in the UI and CLI via temporal describe task queue. There's no way to attach custom metadata to workers.",
      "number": 715,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:06:10.924Z"
    },
    {
      "summary": "The TypeScript SDK has migrated from npm to pnpm for builds, but the features repo still uses npm when building TS workers from source. This causes `npm ci` to fail because it expects package-lock.json but pnpm uses pnpm-lock.yaml instead.",
      "category": "bug",
      "subcategory": "build-system",
      "apis": [],
      "components": [
        "typescript-worker",
        "build-script",
        "dependency-management"
      ],
      "concepts": [
        "package-manager",
        "build-automation",
        "source-build",
        "lock-file",
        "npm-migration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot build TypeScript workers from source after the SDK's migration to pnpm, causing build failures.",
      "rootCause": "The build script in the features repo hardcodes npm commands but the TypeScript SDK now uses pnpm with pnpm-lock.yaml, creating a mismatch.",
      "proposedFix": "Replace npm commands with pnpm equivalents in the build script (pnpm ci instead of npm ci, pnpm run build instead of npm run build).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1793
      ],
      "keyQuote": "npm ci fails because it expects `package-lock.json` but now that we use `pnpm`, we have `pnpm-lock.yaml`",
      "number": 712,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:06:00.188Z"
    },
    {
      "summary": "Feature request to support executing activities without a workflow context. Clients and workers need new APIs to start, manage, and retrieve activity results independently of workflows.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [
        "StartActivity",
        "GetActivityResult",
        "ManageActivity"
      ],
      "components": [
        "client",
        "worker",
        "activity-executor",
        "server-api"
      ],
      "concepts": [
        "activity-execution",
        "standalone-activities",
        "workflow-independence",
        "activity-lifecycle",
        "server-api",
        "client-api"
      ],
      "severity": "high",
      "userImpact": "Enables users to execute and manage activities independently without requiring a workflow wrapper, expanding Temporal's use cases.",
      "rootCause": null,
      "proposedFix": "Implement new server APIs (per PR #640) and corresponding client/worker support across all SDKs for independent activity execution.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        640,
        2124,
        2741,
        1070,
        1851,
        1230,
        568,
        367
      ],
      "keyQuote": "Allow executing activities without a workflow. The clients must support the new (upcoming) server APIs for starting, managing and getting results of activities.",
      "number": 706,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:06:00.902Z"
    },
    {
      "summary": "Feature request to add SDK warnings when workflow history exceeds a configurable size threshold, emitted once per workflow and only during execution (not replay) to alert users before the server terminates workflows.",
      "category": "feature",
      "subcategory": "workflow-history",
      "apis": [],
      "components": [
        "worker",
        "workflow-executor",
        "history-manager"
      ],
      "concepts": [
        "history-size",
        "performance",
        "replay",
        "server-limits",
        "configuration",
        "warnings"
      ],
      "severity": "medium",
      "userImpact": "Users running on managed Temporal servers lack visibility into workflow history size problems until the server terminates their workflows, causing production issues.",
      "rootCause": null,
      "proposedFix": "Implement SDK-level detection of workflow history size with configurable warning threshold as a worker option, emitting warnings once per workflow during execution (not replay).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently users not hosting there own Temporal server receive no notification that there history size is a problem",
      "number": 705,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:06:02.649Z"
    },
    {
      "summary": "Feature request to support setting Temporal headers through CLI and GUI for workflow restarts. Currently, headers set by ContextPropagator are lost when restarting failed workflows from the GUI.",
      "category": "feature",
      "subcategory": "headers-context-propagation",
      "apis": [
        "ContextPropagator"
      ],
      "components": [
        "cli",
        "gui",
        "context-propagation",
        "workflow-restart"
      ],
      "concepts": [
        "headers",
        "context-propagation",
        "metadata",
        "workflow-restart",
        "MDC",
        "client-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users lose contextual headers when restarting failed workflows from GUI, breaking tracing and debugging workflows that depend on propagated context.",
      "rootCause": "Headers set by ContextPropagator on the client are not persisted or accessible when restarting workflows through CLI/GUI interfaces.",
      "proposedFix": "Add support for setting temporal headers through CLI and GUI restart mechanisms.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed because it doesn't have SDK-specific aspects. Separate issues were opened for CLI (cli#876) and UI (ui#3029) projects.",
      "related": [
        876,
        3029
      ],
      "keyQuote": "When a workflow fails and we attempt to restart it from GUI, the headers set by the ContextPropagator are no longer available.",
      "number": 703,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:47.374Z"
    },
    {
      "summary": "Request to add activity_fail_endtoend_latency metric to complement the existing activity_succeed_endtoend_latency metric, allowing users to monitor activity failures after all retries without needing custom metrics.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "sdk-core"
      ],
      "concepts": [
        "activity-failure",
        "monitoring",
        "retry",
        "latency-tracking",
        "observability",
        "endtoend-latency"
      ],
      "severity": "medium",
      "userImpact": "Users need to monitor activity failures after all retries but currently must implement custom metrics or use workarounds to track this important operational metric.",
      "rootCause": null,
      "proposedFix": "Add activity_fail_endtoend_latency metric that tracks the time from activity execution start to final failure after all retries are exhausted.",
      "workaround": "Users can push custom metrics from workflow code or workflow interceptors, or subtract activity_succeed_endtoend_latency from activity_execution_latency to estimate failures.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "add corresponding metric users can monitor for activity failures after all retries",
      "number": 702,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:48.717Z"
    },
    {
      "summary": "SDKs should warn users when they attempt to send payloads exceeding a configurable size threshold (default 512 KB), similar to server-side warnings. This helps users catch payload size violations early on the client side before requests fail.",
      "category": "feature",
      "subcategory": "payload-validation",
      "apis": [
        "StartWorkflow",
        "SignalWorkflow"
      ],
      "components": [
        "sdk-client",
        "payload-validator",
        "codec-processor"
      ],
      "concepts": [
        "payload-size-limit",
        "validation",
        "warning",
        "codec",
        "transaction-limit"
      ],
      "severity": "medium",
      "userImpact": "Users will be warned about oversized payloads during development, preventing runtime failures on self-hosted or cloud Temporal instances.",
      "rootCause": null,
      "proposedFix": "Implement client-side payload size checking after codec processing, with configurable threshold and ability to disable warnings.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Warn if the SDK detects a payload above a certain size (default 512 KB) like the Temporal server does today.",
      "number": 701,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:45.879Z"
    },
    {
      "summary": "Implement a worker heartbeating mechanism that allows users to query worker information from the server, enabling better worker debugging and visibility into runtime status across namespaces and clients.",
      "category": "feature",
      "subcategory": "worker-heartbeating",
      "apis": [],
      "components": [
        "worker",
        "nexus-integration",
        "server-communication",
        "heartbeat-system"
      ],
      "concepts": [
        "worker-discovery",
        "debugging",
        "heartbeat",
        "monitoring",
        "runtime-status",
        "namespace-isolation"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to query and monitor active workers on the server, improving visibility and debugging capabilities for distributed Temporal systems.",
      "rootCause": null,
      "proposedFix": "Build a new background nexus worker that sends runtime, namespace, and client level heartbeats to the server.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2094,
        2716,
        953,
        1038,
        1810,
        1196,
        551,
        354,
        868
      ],
      "keyQuote": "This will allow users to query the list of workers that server is aware of, to help with worker debugging, as well as seeing some basic info regarding each worker.",
      "number": 696,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:32.756Z"
    },
    {
      "summary": "Add support for setting `GrpcMessageTooLarge` as a failure reason on the `temporal_workflow_task_execution_failed` metric when workflow tasks fail due to gRPC message size limits. This enhancement should help users identify and diagnose large message issues without significantly increasing metric cardinality.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-execution",
        "gRPC"
      ],
      "concepts": [
        "failure-reason",
        "message-size",
        "cardinality",
        "observability",
        "diagnostics"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to identify workflow task failures caused by gRPC message size limits through metrics, improving observability and debugging capabilities.",
      "rootCause": "Lack of specific failure reason categorization for gRPC message too large errors in workflow task execution metrics",
      "proposedFix": "Set `GrpcMessageTooLarge` as the `failure_reason` value on `temporal_workflow_task_execution_failed` metric when applicable",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2114,
        2732,
        1065
      ],
      "keyQuote": "If the workflow task failure is due to gRPC message too large, set `GrpcMessageTooLarge` as `failure_reason` on `temporal_workflow_task_execution_failed`",
      "number": 695,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:34.530Z"
    },
    {
      "summary": "Allow users to override the Worker Deployment Version when invoking a Child Workflow, enabling pre-deployment testing scenarios. This feature should work the same way as version override does when creating a Workflow from a client.",
      "category": "feature",
      "subcategory": "child-workflow-versioning",
      "apis": [
        "ExecuteChildWorkflow",
        "CreateWorkflowOptions"
      ],
      "components": [
        "child-workflow",
        "worker-deployment",
        "versioning"
      ],
      "concepts": [
        "deployment-version",
        "pre-deployment-testing",
        "version-override",
        "child-workflow-execution",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test child workflows with specific deployment versions before production release, limiting pre-deployment testing capabilities.",
      "rootCause": null,
      "proposedFix": "Add version override parameter to child workflow invocation APIs matching the existing implementation for client workflow creation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2108,
        2726,
        1057,
        1824,
        1209,
        558,
        361
      ],
      "keyQuote": "Users want to override the target version on a workflow, especially when doing pre-deployment testing. This should work the same as it does when creating a Workflow from a client.",
      "number": 694,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:35.530Z"
    },
    {
      "summary": "Nexus samples and documentation currently use request ID as workflow ID, which contradicts the documented best practice of using business-meaningful IDs. The request is to update samples and docs to demonstrate proper workflow ID usage.",
      "category": "docs",
      "subcategory": "nexus-samples",
      "apis": [],
      "components": [
        "nexus",
        "samples",
        "documentation"
      ],
      "concepts": [
        "workflow-id",
        "request-id",
        "best-practices",
        "code-examples",
        "documentation-accuracy"
      ],
      "severity": "low",
      "userImpact": "Users learning Nexus from samples and docs may adopt incorrect patterns for workflow ID assignment, deviating from recommended practices.",
      "rootCause": "Samples demonstrate using request ID for workflow ID despite documentation recommending business-meaningful IDs",
      "proposedFix": "Update Nexus samples and documentation to use business-meaningful IDs for workflows instead of request IDs",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Today Nexus samples and docs use request ID for workflow ID even though they document that you should use a \"business-meaningful ID\"",
      "number": 692,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:21.870Z"
    },
    {
      "summary": "Deployment versioning feature tests are timing out during Go docker builds, failing multiple routing-related test scenarios including auto-upgrade, pinned versions, overrides, and ramp deployments.",
      "category": "bug",
      "subcategory": "deployment-versioning-testing",
      "apis": [],
      "components": [
        "docker-build",
        "go-sdk",
        "feature-tests",
        "deployment-versioning"
      ],
      "concepts": [
        "timeout",
        "test-failure",
        "docker",
        "deployment",
        "versioning",
        "routing"
      ],
      "severity": "high",
      "userImpact": "Feature deployment tests are failing in CI/CD, preventing validation of versioning and routing functionality in Go deployments.",
      "rootCause": "Timeout condition not being met in feature test execution during docker build workflow",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, likely resolved through test infrastructure improvements or timeout adjustments",
      "related": [],
      "keyQuote": "Feature deployment_versioning/routing_auto_upgrade failed: timeout waiting for condition to be met",
      "number": 691,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:21.208Z"
    },
    {
      "summary": "Assume TLS is enabled when an API key is provided in SDKs to improve security by default. This is a backwards-incompatible change that affects self-hosted deployments without TLS, requiring explicit configuration to disable TLS when using API keys.",
      "category": "feature",
      "subcategory": "tls-configuration",
      "apis": [],
      "components": [
        "sdk-client",
        "connection-config",
        "tls-handler"
      ],
      "concepts": [
        "tls",
        "api-key",
        "security",
        "configuration",
        "backwards-compatibility",
        "self-hosting"
      ],
      "severity": "medium",
      "userImpact": "Self-hosted users without TLS who use API keys will need to explicitly disable TLS to maintain current behavior, or upgrade to enable secure TLS connections by default.",
      "rootCause": null,
      "proposedFix": "Modify SDKs to assume TLS is enabled when an API key is provided, unless explicitly set otherwise. Some SDKs like Go may need a TLSDisabled field.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across multiple SDKs (Go, Java, TypeScript, Python, .NET, Ruby) and Temporal CLI, with PHP pending implementation.",
      "related": [],
      "keyQuote": "assume if an API key is provided, that TLS is enabled unless explicitly set otherwise",
      "number": 687,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:19.104Z"
    },
    {
      "summary": "Feature request to prevent sensitive HTTP headers in HostedMCPTool from being serialized into activity input and visible in Temporal UI and worker logs. Users need a way to omit or lazily resolve these headers to avoid exposing secrets.",
      "category": "feature",
      "subcategory": "security-serialization",
      "apis": [],
      "components": [
        "activity-serialization",
        "hosted-mcp-tool",
        "payload-codec"
      ],
      "concepts": [
        "security",
        "secrets-management",
        "payload-redaction",
        "sensitive-data",
        "serialization",
        "ui-visibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot securely use HostedMCPTool with sensitive headers because secrets are exposed in Temporal UI and worker logs despite using payload codecs.",
      "rootCause": "HTTP headers are serialized into activity input/history as part of tool config, making them visible in UI and logs regardless of codec encryption.",
      "proposedFix": "Implement a mechanism to omit headers from serialization or lazily resolve them at activity execution time, or allow codec servers to redact specific payload portions before UI display.",
      "workaround": "Use a payload codec server that omits sensitive portions from payloads in its response, preventing them from appearing in the UI.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "the tokens still show up in plain text when someone browses the Temporal UI â€” which isn't ideal from a security perspective",
      "number": 685,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:07.048Z"
    },
    {
      "summary": "SDKs should expose contrib/extra integrations (like OpenTelemetry) as plugin implementations, leveraging the plugin system introduced in #652 to standardize how integrations are configured across all Temporal SDKs.",
      "category": "feature",
      "subcategory": "plugin-system",
      "apis": [],
      "components": [
        "plugins",
        "integrations",
        "contrib",
        "interceptors",
        "metrics"
      ],
      "concepts": [
        "plugin-architecture",
        "opentelemetry",
        "extensibility",
        "integration-framework",
        "standardization"
      ],
      "severity": "medium",
      "userImpact": "Users gain a standardized, plugin-based approach to integrating extensions like OpenTelemetry across all SDKs instead of manual implementations.",
      "rootCause": null,
      "proposedFix": "Expose contrib/extra libraries as plugin implementations once #652 is complete, replacing manual implementations of interceptors and metrics handlers.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        652
      ],
      "keyQuote": "SDKs should expose these things as plugins even if many of them may be just one aspect (configuring interceptors)",
      "number": 684,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:07.759Z"
    },
    {
      "summary": "Add support for Nexus CONFLICT and REQUEST_TIMEOUT handler error types across all Temporal SDKs as specified in the Nexus RPC specification.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [],
      "components": [
        "nexus-handler",
        "error-types",
        "sdk-implementations"
      ],
      "concepts": [
        "nexus-rpc",
        "error-handling",
        "handler-errors",
        "conflict-resolution",
        "timeout-handling"
      ],
      "severity": "medium",
      "userImpact": "SDK users need these error types to properly handle Nexus operation failures according to the specification.",
      "rootCause": null,
      "proposedFix": "Implement CONFLICT and REQUEST_TIMEOUT handler error types in each SDK following the Nexus RPC API specification.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Completed implementations across all SDKs: Go (PR#56), Java (issue#37), TypeScript (issue#23), Python (issue#22), .NET (issue#9)",
      "related": [],
      "keyQuote": "As specified in the SPEC: https://github.com/nexus-rpc/api/blob/dc2055899501f338f5483c776020fdbd3eae762b/SPEC.md#predefined-handler-errors",
      "number": 683,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:05:04.063Z"
    },
    {
      "summary": "Remove fetchResult and fetchInfo APIs from Nexus SDKs across all languages. These APIs were recently removed from the Nexus RPC specification and need to be removed from the Go, Java, TypeScript, Python, and .NET SDK implementations.",
      "category": "feature",
      "subcategory": "nexus-api",
      "apis": [],
      "components": [
        "nexus-sdk-go",
        "nexus-sdk-java",
        "nexus-sdk-typescript",
        "nexus-sdk-python",
        "nexus-sdk-dotnet"
      ],
      "concepts": [
        "api-cleanup",
        "spec-compliance",
        "backward-incompatible-change",
        "multi-sdk-coordination"
      ],
      "severity": "medium",
      "userImpact": "Users will need to update their Nexus SDK implementations to remove deprecated fetchResult and fetchInfo methods from their Handler implementations.",
      "rootCause": "APIs were removed from the Nexus RPC specification in nexus-rpc/api#25, requiring corresponding SDK updates.",
      "proposedFix": "Remove [Get|Fetch]Info and [Get|Fetch]Result requests at all Handler levels; remove associated Operation Context types; remove OperationStillRunning error type.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "All five SDK implementations completed removal of fetchResult and fetchInfo APIs as tracked in per-SDK tickets.",
      "related": [],
      "keyQuote": "Remove [Get|Fetch]Info and [Get|Fetch]Result requests at all Handler levels.",
      "number": 682,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:53:29.341Z"
    },
    {
      "summary": "User requests exposure of client identity information to workflows for auditing purposes. Currently, identity information is available in the WorkflowExecutionStarted event but workflows cannot access it without making additional API calls.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowExecutionStarted"
      ],
      "components": [
        "workflow",
        "workflow-context",
        "history-events"
      ],
      "concepts": [
        "auditing",
        "user-identity",
        "client-identity",
        "workflow-metadata",
        "security",
        "access-control"
      ],
      "severity": "medium",
      "userImpact": "Users need to manually call the Temporal API from an activity to retrieve client identity information for audit logging of user-initiated workflows.",
      "rootCause": null,
      "proposedFix": "Add the identity field from WorkflowExecutionStarted event to the Workflow info, potentially as user identity information accessible from within workflows.",
      "workaround": "Create an activity that calls the Temporal API to retrieve the identity information from the WorkflowExecutionStarted event.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed in favor of temporalio/temporal#8538 which tracks the broader request for exposing user identity from UI-triggered workflows.",
      "related": [
        8538
      ],
      "keyQuote": "Add the identity field of the WorkflowExecutionStarted event somewhere in the Workflow info.",
      "number": 681,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:53:27.972Z"
    },
    {
      "summary": "Remove deprecated tctl references from SDK codebases (Go, Python, TypeScript) and replace them with CLI tool mentions, as tctl is no longer maintained.",
      "category": "feature",
      "subcategory": "documentation",
      "apis": [],
      "components": [
        "documentation",
        "examples",
        "comments"
      ],
      "concepts": [
        "deprecation",
        "migration",
        "tooling",
        "sdk-maintenance"
      ],
      "severity": "low",
      "userImpact": "Developers may encounter outdated documentation or comments referencing deprecated tctl tool instead of the current CLI alternative.",
      "rootCause": null,
      "proposedFix": "Switch all mentions of tctl in comments and documentation across Go, Python, and TypeScript SDKs to reference the CLI tool instead.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the tctl references were updated or removed in favor of CLI references.",
      "related": [],
      "keyQuote": "We should probably switch over to using CLI instead, since tctl is deprecated.",
      "number": 680,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T07:04:53.308Z"
    },
    {
      "summary": "Add Nexus service and operation information to the serialization context provided to converters and codecs, enabling users to access Nexus-specific metadata during serialization similar to existing workflow and activity context.",
      "category": "feature",
      "subcategory": "nexus-serialization",
      "apis": [],
      "components": [
        "nexus",
        "converters",
        "codecs",
        "serialization"
      ],
      "concepts": [
        "serialization-context",
        "nexus-operations",
        "metadata-passing",
        "codec-customization",
        "cross-sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to access Nexus service and operation information within their custom converters and codecs for context-aware serialization.",
      "rootCause": null,
      "proposedFix": "Extend the serialization context to include Nexus service and operation information, maintaining consistency across SDK implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        434
      ],
      "keyQuote": "users need some Nexus info as well. Likely this is only \"service\" and \"operation\" due to our requirement of having the same contextual information on both sides",
      "number": 678,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:53:11.375Z"
    },
    {
      "summary": "Request for a unique identifier that persists across activity retries to enable idempotent activity execution. Currently, activities lack a globally unique identifier independent of workflow context, making it difficult to implement idempotency patterns.",
      "category": "feature",
      "subcategory": "activity-idempotency",
      "apis": [],
      "components": [
        "activity-executor",
        "workflow-execution",
        "retry-mechanism"
      ],
      "concepts": [
        "idempotency",
        "retry",
        "activity-identity",
        "side-effects",
        "state-persistence"
      ],
      "severity": "medium",
      "userImpact": "Users must implement custom idempotency logic outside the SDK, increasing complexity and error-prone code when retrying activities.",
      "rootCause": null,
      "proposedFix": "Add a globally unique activity identifier at the Cadence/Temporal SDK level that persists across retries and is independent of workflow context.",
      "workaround": "Generate UUIDs using UUIDv5(runId, activityId) within activity code and maintain idempotency state in external datastore.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "there isn't an identifier that uniquely identifies a specific activity...it would be very handy to have at the Cadence level",
      "number": 677,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:53:16.933Z"
    },
    {
      "summary": "Standardize error messages across SDKs by appending non-'details' properties to failure messages for activity, child workflow, Nexus, timeout, and application failures. Some SDKs (Java, Go) already implement this partially, while others lack it entirely.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "activity-executor",
        "workflow-executor",
        "nexus-handler",
        "error-messages"
      ],
      "concepts": [
        "error-messaging",
        "failure-details",
        "exception-handling",
        "consistency",
        "user-debugging"
      ],
      "severity": "medium",
      "userImpact": "Users get more detailed error information across all SDKs, improving debugging and troubleshooting of workflow failures.",
      "rootCause": null,
      "proposedFix": "Append all non-'details' properties to error messages for activity failure, application failure, child workflow failure, Nexus handler failure, Nexus operation failure, and timeout failure across all SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we should append all non-\"details\" properties to the message",
      "number": 676,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:53:14.387Z"
    },
    {
      "summary": "Feature request to optionally hide or suppress the Temporal server startup banner that appears in test logs. The banner displays CLI version, server info, and metrics URLs which clutters test output.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "start_local"
      ],
      "components": [
        "cli",
        "test-utilities",
        "logging"
      ],
      "concepts": [
        "test-logging",
        "banner-suppression",
        "configuration",
        "startup-output",
        "test-isolation"
      ],
      "severity": "low",
      "userImpact": "Developers testing with local Temporal servers experience cluttered test logs from startup banners, making test output harder to read.",
      "rootCause": "The temporal CLI outputs a startup banner by default that cannot be suppressed, affecting all SDK tests using local server.",
      "proposedFix": "Add a switch or configuration option to suppress the startup banner in start_local or related functions.",
      "workaround": "Use a single ephemeral server instance across multiple test cases instead of starting a new server per test.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be great if this banner could be suppressed by default (or at least have a switch to mute it)?",
      "number": 675,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:53:00.070Z"
    },
    {
      "summary": "TypeScript SDK needs to expose Temporal Nexus operation info (namespace and task queue) to Nexus operation authors, similar to how activity and workflow info are provided to their respective authors. This feature has been implemented in Go, Java, Python, and .NET SDKs but is still pending for TypeScript and Ruby/PHP (which don't have Nexus yet).",
      "category": "feature",
      "subcategory": "nexus-operations",
      "apis": [],
      "components": [
        "nexus-operation-handler",
        "operation-info",
        "typescript-sdk"
      ],
      "concepts": [
        "nexus-operations",
        "operation-context",
        "namespace",
        "task-queue",
        "sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "TypeScript Nexus operation authors cannot access runtime context information (namespace and task queue) that is available in other SDKs, limiting their ability to implement context-aware operations.",
      "rootCause": null,
      "proposedFix": "Expose a Nexus operation info object containing namespace and task queue to TypeScript Nexus operation handlers, consistent with the implementation in Python and .NET SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2053,
        2657
      ],
      "keyQuote": "Like we provide activity info to activity authors and workflow info to workflow authors, we need to provide Temporal-specific Nexus operation info to Temporal Nexus operation authors.",
      "number": 674,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:52:57.128Z"
    },
    {
      "summary": "All Temporal SDKs should expose the Nexus request deadline in the Nexus context. This provides a consistent way for developers to access request timeout information across all supported languages and is needed for proper deadline-aware programming.",
      "category": "feature",
      "subcategory": "nexus-integration",
      "apis": [
        "Nexus",
        "NexusContext"
      ],
      "components": [
        "nexus-sdk",
        "context",
        "sdk-core"
      ],
      "concepts": [
        "deadline",
        "request-timeout",
        "nexus-rpc",
        "context-propagation",
        "timeout-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers using Nexus across different SDKs need consistent access to request deadlines for proper timeout and deadline-aware programming patterns.",
      "rootCause": null,
      "proposedFix": "Expose request deadline in the Nexus context for all SDKs (Go, Java, TypeScript, Python, .NET, Ruby). Coordinate with Core SDK to expose deadline to language bindings.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "All SDKs should make the \"request deadline\" available in the Nexus context. Note, this is intentionally deadline and not timeout",
      "number": 673,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:52:58.116Z"
    },
    {
      "summary": "Feature request to add tests across SDKs that verify custom slot suppliers receive slot info objects with properly set fields. Currently most SDKs lack test coverage for this functionality.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "custom-slot-supplier",
        "slot-info",
        "test-coverage"
      ],
      "concepts": [
        "testing",
        "slot-management",
        "worker-configuration",
        "test-validation",
        "SDK-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users implementing custom slot suppliers may not have confidence that slot info fields are correctly populated across different SDK implementations.",
      "rootCause": null,
      "proposedFix": "Add tests to each SDK to confirm that slot info passed to custom slot suppliers has all required fields properly set.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2045,
        2650,
        1782,
        1079,
        519,
        225
      ],
      "keyQuote": "In many (all?) SDKs, there are not tests confirming that the fields are properly set on slot infos passed to custom slot suppliers.",
      "number": 672,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:35.127Z"
    },
    {
      "summary": "Core SDKs need support for gRPC binary metadata keys (with `-bin` suffix) to allow passing bytes as RPC metadata values, matching native gRPC library capabilities. Currently, Core SDKs only support string values as ASCII headers, causing Tonic to fail when binary headers are attempted.",
      "category": "feature",
      "subcategory": "rpc-metadata",
      "apis": [],
      "components": [
        "rpc-metadata",
        "grpc-client",
        "tonic",
        "core-sdk"
      ],
      "concepts": [
        "binary-headers",
        "metadata-handling",
        "grpc-protocol",
        "interoperability",
        "protocol-compliance"
      ],
      "severity": "medium",
      "userImpact": "Users cannot pass binary metadata in RPC calls across most Core SDKs, limiting interoperability with systems that require binary header support.",
      "rootCause": "Core SDKs assume string values as ASCII headers without support for the gRPC `-bin` key convention for binary data, while native gRPC libraries already support this standard.",
      "proposedFix": "Accept bytes as RPC metadata values and update Tonic to set those as binary headers on the metadata map for `-bin` keys.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        991,
        1778,
        1063,
        512,
        329
      ],
      "keyQuote": "We need to accept bytes as RPC metadata values and need to update code to have Tonic set those as binary headers on the metadata map for `-bin` keys.",
      "number": 671,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:38.293Z"
    },
    {
      "summary": "Feature request to reclassify benign application errors in OpenTelemetry across multiple SDKs. Exceptions should still be recorded in telemetry but not marked as errors to better distinguish between expected failures and actual problems.",
      "category": "feature",
      "subcategory": "observability",
      "apis": [],
      "components": [
        "opentelemetry",
        "error-handling",
        "telemetry"
      ],
      "concepts": [
        "observability",
        "error-classification",
        "exception-handling",
        "telemetry",
        "monitoring",
        "benign-errors"
      ],
      "severity": "medium",
      "userImpact": "Users see application errors in OpenTelemetry that are not actual failures, cluttering error dashboards and making it harder to identify real problems.",
      "rootCause": "Current implementation marks all exceptions as errors in OpenTelemetry regardless of whether they are expected application behavior or actual failures.",
      "proposedFix": "Reclassify benign application errors to not be marked as errors in OpenTelemetry while still recording them for observability.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1041,
        2034,
        2643,
        1776,
        510,
        328,
        648
      ],
      "keyQuote": "Exceptions should still be recorded, but not marked as error.",
      "number": 670,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:35.802Z"
    },
    {
      "summary": "Feature request to add timer options (like summary) to higher-level timer calls such as `.sleep` and `.await`, currently only available on `.newTimer`. Implementation approach (TimerOptions, dedicated options classes, or overloads) to be determined.",
      "category": "feature",
      "subcategory": "timer-options",
      "apis": [
        "newTimer",
        "sleep",
        "await"
      ],
      "components": [
        "timer",
        "workflow-api",
        "sdk-interfaces"
      ],
      "concepts": [
        "timer",
        "options",
        "summary",
        "configuration",
        "workflow-execution"
      ],
      "severity": "low",
      "userImpact": "Users cannot set timer metadata like summary on higher-level timer calls, limiting visibility into workflow execution details.",
      "rootCause": null,
      "proposedFix": "Add timer options to `.sleep`, `.await`, and potentially other timer calls via TimerOptions, dedicated options classes (SleepOptions/AwaitOptions), or method overloads accepting summary strings.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently timer options are available on `.newTimer` which allows setting summary, but there is a desire to add on `.sleep`, `.await`, and maybe others.",
      "number": 669,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:24.072Z"
    },
    {
      "summary": "Request to add BadScheduleActivityAttributes failure_reason to the temporal_workflow_task_execution_failed metric to help differentiate failure causes, such as when activity payload exceeds size limits.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-execution",
        "activity-scheduling"
      ],
      "concepts": [
        "failure-reasons",
        "metric-tags",
        "cardinality",
        "payload-limits",
        "diagnostics"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily differentiate failure reasons in metrics when scheduling activities fails, requiring them to rely on logs instead.",
      "rootCause": "Current metric implementation limits failure_reason tag to two values due to cardinality constraints in metric systems.",
      "proposedFix": "Either add BadScheduleActivityAttributes failure_reason to the temporal_workflow_task_execution_failed metric, or discuss including all possible reasons from the failed_cause.proto enum.",
      "workaround": "Rely on logs to differentiate all failure reasons instead of using metrics.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDKs have limited this tag in the metrics to only two values and have suggested relying on logs to differentiate all of the reasons.",
      "number": 666,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:20.890Z"
    },
    {
      "summary": "Users need clear documentation and samples showing how to map a single Nexus Operation input to multiple Workflow arguments. Currently this information is only available for Java SDK and scattered across Slack discussions, but should be documented across all SDK dev guides with consistent examples.",
      "category": "docs",
      "subcategory": "nexus",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "nexus-operation",
        "workflow-arguments",
        "documentation"
      ],
      "concepts": [
        "parameter-mapping",
        "multi-argument-binding",
        "nexus-handler",
        "cross-sdk-consistency",
        "developer-guide"
      ],
      "severity": "medium",
      "userImpact": "Users struggle to understand and implement Nexus Operation input-to-workflow-argument mapping across SDK languages due to incomplete or missing documentation.",
      "rootCause": null,
      "proposedFix": "Create Nexus multi-arg samples for all SDKs, add documentation sections in all Nexus SDK dev guides mirroring the Java SDK guide, and ensure dev guide samples link to code examples.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed indicating that the documentation and samples were created across SDKs.",
      "related": [],
      "keyQuote": "This knowledge is often passed along on Slack DMs but should be broadly available to all users.",
      "number": 665,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:19.187Z"
    },
    {
      "summary": "Users need working Nexus operation examples and documentation for synchronous operations that interact with workflows (signals, signal-with-start, updates, queries) across SDKs. Currently examples are sparse or buried, making it unclear how to implement these patterns.",
      "category": "docs",
      "subcategory": "nexus-operations",
      "apis": [
        "SignalWorkflow",
        "SignalWithStartWorkflow",
        "UpdateWorkflow",
        "QueryWorkflow",
        "GetWorkflowHandle"
      ],
      "components": [
        "nexus-service",
        "sync-operations",
        "workflow-client",
        "sdk-samples"
      ],
      "concepts": [
        "nexus-operations",
        "workflow-signaling",
        "workflow-querying",
        "workflow-updates",
        "service-handlers",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot easily discover or implement Nexus operations for common workflow interaction patterns, increasing time-to-productivity and causing confusion across SDKs.",
      "rootCause": "Lack of comprehensive examples and dedicated documentation sections for sync Nexus operations that interact with workflows (signaling, querying, updating).",
      "proposedFix": "Provide working Nexus sample code in each SDK repository demonstrating signal, signal-with-start, update, and query operations; add dedicated Nexus dev guide sections with examples for each operation type.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be helpful to include Python examples of how to define Nexus operations for sending signals, updates, etc. I don't see it on GitHub or official doc",
      "number": 664,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:07.257Z"
    },
    {
      "summary": "Feature request to record headers on LocalActivities in EventHistory. Currently, RecordMarkerCommandAttributes supports headers but they are not set for LocalActivities, preventing visibility in EventHistory as users have requested.",
      "category": "feature",
      "subcategory": "local-activity-headers",
      "apis": [
        "RecordMarkerCommandAttributes"
      ],
      "components": [
        "local-activity-executor",
        "command-state-machine",
        "event-history"
      ],
      "concepts": [
        "headers",
        "event-history",
        "local-activities",
        "markers",
        "metadata-propagation"
      ],
      "severity": "low",
      "userImpact": "Users cannot see LocalActivity headers in EventHistory, limiting visibility into activity execution context and metadata propagation.",
      "rootCause": "LocalActivity marker recording does not populate the Headers field in RecordMarkerCommandAttributes, though the field is available in the command structure.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Hrmm, usually for local activity input we don't record it in history since we're usually only concerned with the output.",
      "number": 663,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:04.773Z"
    },
    {
      "summary": "Nexus operation authors need a testing environment to mock and trigger scenarios without server involvement, similar to the activity testing framework. This feature should be built into non-Temporal Nexus SDKs first, then integrated into Temporal SDKs across all language implementations.",
      "category": "feature",
      "subcategory": "testing",
      "apis": [],
      "components": [
        "nexus-testing",
        "test-framework",
        "operation-executor"
      ],
      "concepts": [
        "testing",
        "mocking",
        "nexus-operations",
        "environment",
        "integration-testing"
      ],
      "severity": "medium",
      "userImpact": "Nexus operation developers cannot effectively test their operations without server involvement, limiting their ability to develop and debug robust Nexus integrations.",
      "rootCause": null,
      "proposedFix": "Build a Nexus operation testing environment in non-Temporal SDKs that allows mocking and triggering scenarios, similar to existing activity test environments, then add Temporal SDK features.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Nexus operation authors, like activity authors, need an environment to test their Nexus operations. It's probably just the ability to mock and trigger certain situations without server involvement",
      "number": 658,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:35:06.741Z"
    },
    {
      "summary": "Feature request to provide additional metadata when starting or executing workflows, including whether a workflow actually started, its current status, whether it was eagerly started, and workflow links. Requires research into implementing mutable placeholders in start options across SDKs.",
      "category": "feature",
      "subcategory": "workflow-start-execution",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-starter",
        "start-options",
        "result-metadata"
      ],
      "concepts": [
        "workflow-metadata",
        "start-conflict-policy",
        "eager-start",
        "workflow-status",
        "workflow-links"
      ],
      "severity": "medium",
      "userImpact": "Users can now access detailed information about workflow start operations, improving visibility into workflow creation outcomes and enabling better conflict handling.",
      "rootCause": null,
      "proposedFix": "Implement mutable placeholders in start options across SDKs to allow start calls to set additional details like actual start confirmation, status, eager start flag, and links.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users may need ability to see some details about workflow start/execute beyond just the normal result they get.",
      "number": 657,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:18:21.001Z"
    },
    {
      "summary": "Establish consistent metrics for unregistered activities across all Temporal SDKs. Currently only Go implements temporal_unregistered_activity_invocation; this issue tracks standardizing this metric and potentially adding metrics for other unregistered operations across all SDK implementations.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "worker"
      ],
      "concepts": [
        "observability",
        "monitoring",
        "unregistered-activities",
        "cross-sdk-consistency",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot consistently monitor unregistered activity invocations across different SDKs, making it difficult to detect configuration or registration issues in heterogeneous deployments.",
      "rootCause": null,
      "proposedFix": "Implement temporal_unregistered_activity_invocation metric across all SDKs (Go, Java, Core, TypeScript, Python, .NET, Ruby, PHP) and consider adding metrics for other unregistered operations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Make metrics concerning unregistered activities (and maybe other things) consistent across SDKs.",
      "number": 656,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:18:19.778Z"
    },
    {
      "summary": "User requests support for mapping Microsoft Entra ID security groups directly to Temporal namespace permissions instead of managing individual user access. This would simplify permission management in organizations using SSO with Entra ID.",
      "category": "feature",
      "subcategory": "authentication-authorization",
      "apis": [],
      "components": [
        "authentication",
        "authorization",
        "namespace-management"
      ],
      "concepts": [
        "sso",
        "group-management",
        "entra-id",
        "scim",
        "access-control",
        "permissions"
      ],
      "severity": "medium",
      "userImpact": "Organizations using Entra ID SSO can simplify permission management by leveraging existing group structures instead of manually assigning permissions to individual users.",
      "rootCause": null,
      "proposedFix": "Implement support for SCIM with Entra ID for user and group management integration with Temporal",
      "workaround": "SCIM with Entra can solve the user/group management (available end of July per comment)",
      "resolution": "fixed",
      "resolutionDetails": "SCIM with Entra ID integration was identified as a solution to address the group-based permission management requirement",
      "related": [],
      "keyQuote": "SCIM with Entra can solve the user/group management. This feature release will be available end of July.",
      "number": 655,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:18:18.147Z"
    },
    {
      "summary": "Feature request for a plugin model that allows users to configure multiple SDK configuration points at once (dataconverters, sandboxes, activities, interceptors, etc.) rather than having to set them individually.",
      "category": "feature",
      "subcategory": "plugin-system",
      "apis": [
        "Client",
        "Worker",
        "ClientConfig",
        "WorkerConfig",
        "Interceptor"
      ],
      "components": [
        "client",
        "worker",
        "configuration",
        "plugin-system",
        "interceptor"
      ],
      "concepts": [
        "plugin-architecture",
        "configuration-management",
        "dataconverter",
        "activity-registration",
        "interceptor-chain"
      ],
      "severity": "medium",
      "userImpact": "Users need a simpler way to apply multiple configuration changes across client and worker setup, reducing boilerplate and improving integration patterns.",
      "rootCause": null,
      "proposedFix": "Implement a Plugin interface for both client and worker that follows an interceptor chain pattern, allowing plugins to hook into connect_client, create_client, create_worker, and run_worker lifecycle methods.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2020,
        1764,
        950,
        1011,
        507,
        318,
        644,
        2626
      ],
      "keyQuote": "A plugin model to allow configuring all these points at once.",
      "number": 652,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:18:07.771Z"
    },
    {
      "summary": "Request for a metric to distinguish when poll rate is limited by client-side constraints (e.g., maximum parallel tasks reached) versus service latency or connection issues. This would help developers understand polling bottlenecks.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "poller",
        "worker",
        "metrics"
      ],
      "concepts": [
        "polling",
        "rate-limiting",
        "metrics",
        "throughput",
        "client-side-constraints",
        "performance-monitoring"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot distinguish between client-side polling limits and service/network bottlenecks, making performance debugging harder.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently there is no metric which can indicate that poll rate is limited by client (for example maximum number of parallel tasks is reached)",
      "number": 651,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:18:04.700Z"
    },
    {
      "summary": "Request for an API to complete or fail a workflow from any location, not just the @WorkflowMethod. Currently workflows can only be completed/failed from the main workflow method or by throwing exceptions.",
      "category": "feature",
      "subcategory": "workflow-lifecycle",
      "apis": [
        "Workflow.complete",
        "Workflow.fail"
      ],
      "components": [
        "workflow-engine",
        "workflow-execution",
        "api"
      ],
      "concepts": [
        "workflow-completion",
        "error-handling",
        "control-flow",
        "async-operations",
        "workflow-state"
      ],
      "severity": "medium",
      "userImpact": "Users cannot complete or fail workflows from helper functions or other threads, limiting workflow control flow patterns.",
      "rootCause": null,
      "proposedFix": "Introduce Workflow.complete(result) and Workflow.fail(Exception) APIs callable from any context within the workflow",
      "workaround": "Complete/fail workflow only from the @WorkflowMethod or throw exceptions for failure",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Sometimes it is convenient to complete or fail workflow from some other function or even thread.",
      "number": 650,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:18:07.911Z"
    },
    {
      "summary": "Feature request to enable unit testing of workflow versioning and upgrade scenarios. Currently, the unit testing framework always takes the code path of the latest version with no way to force execution of older code paths, making it impossible to verify that versioned code upgrades work correctly.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "unit-testing",
        "workflow-versioning",
        "version-management"
      ],
      "concepts": [
        "workflow-versioning",
        "code-upgrade",
        "unit-testing",
        "version-compatibility",
        "backwards-compatibility",
        "testing-framework",
        "scenario-testing"
      ],
      "severity": "high",
      "userImpact": "Users cannot verify that workflow versioning upgrades work correctly through unit tests, forcing them to rely on integration testing only.",
      "rootCause": "The unit testing framework always executes the latest version of code with no mechanism to simulate or force older code paths.",
      "proposedFix": "Add support to execute different upgrade scenarios through the unit testing framework, allowing developers to test version transitions.",
      "workaround": "Use integration testing only to verify upgrade scenarios.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently there is no way to test version upgrades of code through unit testing framework.",
      "number": 649,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:17:50.346Z"
    },
    {
      "summary": "Create comprehensive test suite for worker shutdown functionality across all SDK languages to validate that activities properly handle graceful shutdown with varied responses (accept cancel, complete successfully, fail, or ignore cancel with hard timeout).",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "shutdown-handler",
        "cancellation-mechanism"
      ],
      "concepts": [
        "worker-shutdown",
        "graceful-termination",
        "activity-cancellation",
        "timeout",
        "error-handling",
        "testing"
      ],
      "severity": "medium",
      "userImpact": "Users need reliable tests to verify their SDKs properly handle worker shutdown scenarios with correct activity behavior.",
      "rootCause": null,
      "proposedFix": "Write tests for each SDK language following the specification in features/activity/shutdown/README.md with activities demonstrating varied shutdown responses.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tests were implemented across SDK languages following the worker shutdown feature specification.",
      "related": [
        261
      ],
      "keyQuote": "The activities should varyingly accept the cancel, complete successfully, complete with failure, and ignore the cancel. The one which ignores the cancel should eventually encounter a hard timeout.",
      "number": 648,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:17:53.171Z"
    },
    {
      "summary": "Request to add an unregistered_activity_invocation metric or indicator to track when workers fail to handle activities because they don't have the activity registered. Go SDK already has this metric; the feature request is to implement it across all non-Go SDKs.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "metrics"
      ],
      "concepts": [
        "activity-registration",
        "metrics",
        "monitoring",
        "failure-detection",
        "production-alerting",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Enables operators to detect and alert on unregistered activity mistakes in production environments before they cause widespread activity failures.",
      "rootCause": null,
      "proposedFix": "Add either a new metric counter or a flag to activity_task_failed indicating the failure was due to an unregistered activity on the worker.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Having this metric is pretty useful to have and alert in prod envs where a small mistake of registering activity can lead to activity failure after all retries.",
      "number": 639,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:17:55.151Z"
    },
    {
      "summary": "Request to add a Summary field to LocalActivityOptions across all SDKs. This is a cross-SDK feature enhancement to provide better metadata and documentation capabilities for local activities.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity-executor",
        "activity-options",
        "sdk-options"
      ],
      "concepts": [
        "metadata",
        "activity-documentation",
        "activity-configuration",
        "summary-field",
        "cross-sdk-parity"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to document and describe local activities with summary information, improving code clarity and activity metadata across all SDK languages.",
      "rootCause": null,
      "proposedFix": "Add Summary field to LocalActivityOptions struct in all SDK implementations following the pattern used in Go SDK.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1988,
        2580,
        978,
        298,
        499,
        1746,
        638,
        960
      ],
      "keyQuote": "Request is to add Summary to local activity options struct",
      "number": 637,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:17:36.913Z"
    },
    {
      "summary": "Feature request to add task_queue name to long_request_latency metrics to help identify which task_queue is experiencing latency issues.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "long_request_latency"
      ],
      "concepts": [
        "observability",
        "task_queue",
        "latency",
        "monitoring",
        "debugging"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily identify which task_queue is reporting low latency without additional task_queue context in the metrics.",
      "rootCause": null,
      "proposedFix": "Include task_queue name as a dimension in the long_request_latency metric.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be great to have the task_queue name in the metrics, as it helps identify which task_queue is reporting low latency.",
      "number": 636,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:17:34.978Z"
    },
    {
      "summary": "Add support for accessing the last result and last failure from workflows that are continued from cron or schedule executions. This data comes from workflow history but should be exposed through the SDK workflow context in a consistent way across all SDKs.",
      "category": "feature",
      "subcategory": "workflow-context",
      "apis": [
        "GetWorkflowInfo",
        "WorkflowContext"
      ],
      "components": [
        "workflow-context",
        "history-processing",
        "cron-schedule"
      ],
      "concepts": [
        "cron-scheduling",
        "workflow-continuation",
        "last-result",
        "failure-handling",
        "immutable-data"
      ],
      "severity": "medium",
      "userImpact": "Users working with cron or scheduled workflows need a standard way to access continuation data (last result and failure) across all SDK languages.",
      "rootCause": null,
      "proposedFix": "Expose last_result and last_failure as properties on the workflow context, with clear differentiation between null values and absence of data, similar to Go and Java implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        383,
        489,
        281
      ],
      "keyQuote": "Go, Java, and TypeScript all provide a way to get the \"last result\" and \"last failure\" if this was via cron or schedule",
      "number": 635,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:17:38.858Z"
    },
    {
      "summary": "Add UnhandledCommand as a failure_reason value to the workflow_task_execution_failed metric to enable better alerting and debugging of issues related to high signal rates to executions.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-execution",
        "signal-handling"
      ],
      "concepts": [
        "failure-reason",
        "alerting",
        "debugging",
        "signal-rate",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to detect and debug failures caused by unhandled commands through improved metric visibility.",
      "rootCause": null,
      "proposedFix": "Add UnhandledCommand to the failure_reason field in the workflow_task_execution_failed metric alongside existing NonDeterminismError and WorkflowError values.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add UnhandledCommand as well which can help alert and debug any issues with things like high signal rate to executions",
      "number": 634,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:01:40.458Z"
    },
    {
      "summary": "Activity heartbeat throttling currently starts after the first heartbeat is sent, but users want it to start from activity begin time so the first actual heartbeat is delayed until 4/5 of the heartbeat timeout. This is especially important for cloud customers where heartbeats are billable.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "ExecuteActivity",
        "HeartbeatTimeout"
      ],
      "components": [
        "worker",
        "activity-executor",
        "heartbeat-throttling"
      ],
      "concepts": [
        "heartbeat",
        "throttling",
        "timeout",
        "billing",
        "activity-lifecycle",
        "performance"
      ],
      "severity": "medium",
      "userImpact": "Users cannot efficiently control heartbeat timing from activity start, leading to unnecessary billable heartbeat calls and delayed activity details reporting.",
      "rootCause": "Heartbeat throttling counter starts after the first heartbeat is sent rather than at activity start time, causing the first actual heartbeat to be sent immediately instead of at 4/5 of the timeout.",
      "proposedFix": "Treat activity start as the first heartbeat time so throttling delays begin from activity initialization. Alternatively, add a 'force heartbeat' flag to guarantee synchronous heartbeat calls without waiting for throttling delay.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "heartbeat throttling should be started at activity start...This is especially critical for cloud customers where heartbeat is a billable action.",
      "number": 633,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:01:40.195Z"
    },
    {
      "summary": "Request to add StartDelay option to ContinueAsNewOptions for workflows. Currently StartDelay is available in workflow options but not when continuing a workflow as new.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "ContinueAsNewOptions"
      ],
      "components": [
        "workflow-options",
        "continue-as-new",
        "workflow-execution"
      ],
      "concepts": [
        "start-delay",
        "workflow-continuation",
        "timing-control",
        "workflow-options",
        "scheduling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot specify a start delay when continuing workflows as new, limiting scheduling flexibility for continued workflow executions.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Request is to add it also to continue-as-new options.",
      "number": 632,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:01:42.570Z"
    },
    {
      "summary": "gRPC message-too-large errors should fail tasks gracefully instead of being retried. This requires creating a new WorkflowTaskFailedCause enum, updating SDKs to capture and convert these errors to non-retryable failures, and adding validation tests across platforms.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "worker",
        "gRPC-client",
        "task-executor"
      ],
      "concepts": [
        "message-size-limit",
        "retry-logic",
        "error-handling",
        "resource-exhaustion",
        "graceful-failure"
      ],
      "severity": "high",
      "userImpact": "Currently large task messages cause workflows to fail with confusing retryable errors instead of clear, non-retryable failures, leading to workflow execution hangs or unexpected behavior.",
      "rootCause": "gRPC enforces message size limits at the protocol boundary, returning resource-exhausted errors that are retried by the gRPC client rather than failing the task immediately.",
      "proposedFix": "1) Create new WorkflowTaskFailedCause enum for gRPC-message-too-large, 2) Update SDKs to detect this error and convert to non-retryable failure, 3) Add SDK tests validating the behavior, 4) Validate behavior against Temporal Cloud.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        995,
        1585,
        462,
        970,
        7777,
        198
      ],
      "keyQuote": "we should 1) create a new WorkflowTaskFailedCause for gRPC-message-too-large, and 2) update SDKs to capture the error in clients and convert to non-retryable failure",
      "number": 624,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:01:25.596Z"
    },
    {
      "summary": "Feature request to implement activity reset support across all Temporal SDKs. When an activity is reset, it should restart from the beginning, with optional heartbeat clearing. The implementation should handle reset events similarly to pause and cancel operations, allowing users to write exception handlers that can differentiate between interruption types.",
      "category": "feature",
      "subcategory": "activity-reset",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-handler",
        "exception-handler"
      ],
      "concepts": [
        "activity-reset",
        "heartbeat-clearing",
        "exception-handling",
        "interruption",
        "cleanup",
        "consistency"
      ],
      "severity": "high",
      "userImpact": "Users need a consistent mechanism to handle activity resets across all SDKs, allowing them to clean up resources and differentiate between cancellation, pause, and reset scenarios.",
      "rootCause": null,
      "proposedFix": "Implement activity reset support that: (1) restarts activity from the beginning, (2) optionally clears heartbeats, (3) throws an error to notify user code, (4) works consistently with pause and cancel operations, (5) allows exception handlers to differentiate interruption types",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        254,
        1693,
        847,
        605,
        1931,
        464,
        2488
      ],
      "keyQuote": "Users should be able to write a simple exception handler that cleans up after *any* interruption, including cancellation, pausing, and reset.",
      "number": 620,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:01:24.450Z"
    },
    {
      "summary": "ExecuteWorkflow API needs to expose fields from StartWorkflowExecutionResponse, particularly the Started boolean for UseExisting conflict policy and links for Nexus WorkflowRunOperation integration.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflowExecution"
      ],
      "components": [
        "workflow-client",
        "api-response-handling",
        "nexus-integration"
      ],
      "concepts": [
        "workflow-id-conflict",
        "response-visibility",
        "workflow-started-detection",
        "links",
        "result-information"
      ],
      "severity": "medium",
      "userImpact": "Users cannot determine if a workflow actually started when using UseExisting conflict policy and cannot access links needed for Nexus operations.",
      "rootCause": "ExecuteWorkflow wrapper does not expose StartWorkflowExecutionResponse fields to callers.",
      "proposedFix": "Add optional StartWorkflowResultInfo object pointer to StartWorkflowOptions that SDK internals can populate with response data like Link and Started boolean.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        563
      ],
      "keyQuote": "ExecuteWorkflow wraps StartWorkflowExecution call, and don't provide visibility to the StartWorkflowExecutionResponse.",
      "number": 619,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T06:01:22.239Z"
    },
    {
      "summary": "Proposal to issue warnings when server-provided task start times differ significantly from when the SDK begins processing the task, which could indicate clock skew between server and worker or worker processing delays.",
      "category": "feature",
      "subcategory": "monitoring-diagnostics",
      "apis": [],
      "components": [
        "worker",
        "task-processor",
        "polling"
      ],
      "concepts": [
        "clock-skew",
        "time-synchronization",
        "diagnostics",
        "worker-health",
        "task-processing-delay"
      ],
      "severity": "low",
      "userImpact": "Users would receive warnings to diagnose timing issues like clock misalignment or worker delays that could affect task execution reliability.",
      "rootCause": null,
      "proposedFix": "Issue a warning when task start time differs by Â±1 minute from current worker system time when task processing begins, implementation required per SDK.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Rejected as too niche - the maintainers decided not to implement this feature.",
      "related": [
        1926,
        2484,
        1688,
        839,
        459,
        250,
        603
      ],
      "keyQuote": "We're not gonna do this. Too niche.",
      "number": 616,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:43:51.536Z"
    },
    {
      "summary": "Add retry policy information to activity info exposed to activities, similar to how it's available for workflows. The retry policy can be updated in future features but only applies to successive tasks, not the current one.",
      "category": "feature",
      "subcategory": "activity-info",
      "apis": [
        "ActivityInfo",
        "GetInfo"
      ],
      "components": [
        "activity-executor",
        "info-provider",
        "proto-binding"
      ],
      "concepts": [
        "retry-policy",
        "activity-info",
        "task-configuration",
        "failure-handling",
        "metadata"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently access retry policy information within their activity implementations, limiting their ability to understand task failure handling behavior.",
      "rootCause": null,
      "proposedFix": "Expose retry policy on activity info the same way it is exposed for workflows through proto and core bindings.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1919,
        2481,
        1680,
        831,
        457,
        248,
        602,
        6502
      ],
      "keyQuote": "Retry policy is available via proto (and core) on activity tasks, need to make it available for activities the same way it is available for workflows.",
      "number": 615,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:43:57.854Z"
    },
    {
      "summary": "Introduce ApplicationErrorCategory to enable SDKs to categorize application failures and apply corresponding logging and metrics behavior. This is a cross-SDK feature requiring implementation across multiple SDK languages.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "error-handling",
        "logging",
        "metrics",
        "sdk-framework"
      ],
      "concepts": [
        "error-categorization",
        "logging-behavior",
        "metrics-behavior",
        "application-failures",
        "error-classification",
        "standardization"
      ],
      "severity": "medium",
      "userImpact": "Users can now categorize their application failures and have corresponding logging and metrics behavior automatically applied across all SDKs.",
      "rootCause": null,
      "proposedFix": "Implement ApplicationErrorCategory in each SDK and apply the specified logging and metrics behavior based on the category assigned to failures.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1908,
        2475,
        897,
        1672,
        820,
        448,
        242,
        632
      ],
      "keyQuote": "Apply the corresponding logging and metrics from the given `ApplicationErrorCategory` in our SDKs",
      "number": 614,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:43:55.089Z"
    },
    {
      "summary": "SDKs need testing infrastructure for pre-patched workflow code to ensure patches work correctly across different workflow versions and replay scenarios. Current testing only covers new workflows with the latest patch/getVersion code.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "workflow-executor",
        "patch-system",
        "replay-engine",
        "test-framework"
      ],
      "concepts": [
        "patch-testing",
        "workflow-versioning",
        "code-replay",
        "backward-compatibility",
        "event-history"
      ],
      "severity": "medium",
      "userImpact": "Users cannot verify that their workflow patches correctly handle pre-patched code paths during workflow replay, risking compatibility issues in production.",
      "rootCause": "SDKs lack testing mechanisms to replay workflow executions against older pre-patched code paths, making it difficult to validate patch behavior.",
      "proposedFix": "Implement a testing approach that allows replaying a certain amount of commands/events to trigger pre-patched code paths, while assuming some commands have already replayed.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Investigate (and implement) an approach to testing the pre-patched code. There are struggles with this such as the fact that some people patch with the expectation all pre-patched workflow runs are past a certain point.",
      "number": 613,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:43:40.017Z"
    },
    {
      "summary": "The @grpc/grpc-js library version 1.13.0 fails to connect to the custom HTTP proxy used in TypeScript harness testing, causing proxy-related tests to fail. An override to version 1.10.10 was added as a workaround, but needs investigation to determine if this is a proxy artifact or a broader compatibility issue.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "grpc-js",
        "http-proxy",
        "test-harness"
      ],
      "concepts": [
        "dependency-pinning",
        "version-compatibility",
        "proxy-connection",
        "testing-infrastructure"
      ],
      "severity": "medium",
      "userImpact": "TypeScript harness users cannot upgrade to the latest gRPC library without breaking proxy-based tests.",
      "rootCause": "Compatibility issue between @grpc/grpc-js 1.13.0 and the custom HTTP proxy implementation used for testing",
      "proposedFix": "Investigate the root cause of the incompatibility between gRPC 1.13.0 and the proxy to enable removal of the version pin",
      "workaround": "Pin @grpc/grpc-js to version 1.10.10",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by pinning the dependency; investigation is pending to determine if removal of the pin is possible",
      "related": [
        611
      ],
      "keyQuote": "The latest @grpc/grpc-js library 1.13.0 fails to connect to our custom http proxy for testing, and two related proxy features fail.",
      "number": 612,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:43:39.227Z"
    },
    {
      "summary": "Add Summary field to Nexus operations, similar to the existing Summary support for activities and child workflows. This cross-SDK feature request seeks consistent access to operation metadata across all SDK implementations.",
      "category": "feature",
      "subcategory": "nexus-operations",
      "apis": [
        "Summary"
      ],
      "components": [
        "nexus-operation",
        "sdk-core",
        "operation-metadata"
      ],
      "concepts": [
        "operation-context",
        "metadata-exposure",
        "cross-sdk-consistency",
        "nexus-api"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access summary information for Nexus operations, limiting visibility into operation context compared to activities and child workflows.",
      "rootCause": null,
      "proposedFix": "Expose Summary field in Nexus operation metadata across all SDKs, consistent with how it is currently exposed for activities and child workflows.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add `Summary` to Nexus operation like we have for activities or child workflow",
      "number": 610,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:26:24.591Z"
    },
    {
      "summary": "Implement Nexus support across all Temporal SDKs and CLI. This is an umbrella tracking issue for implementing a generic Nexus common library for each language and language-specific Temporal SDK implementations.",
      "category": "feature",
      "subcategory": "nexus-implementation",
      "apis": [],
      "components": [
        "nexus-library",
        "sdk-implementation",
        "temporal-cli"
      ],
      "concepts": [
        "nexus-rpc",
        "cross-language",
        "sdk-support",
        "async-workflow",
        "service-integration"
      ],
      "severity": "high",
      "userImpact": "Users can build Nexus-based service interactions across all supported Temporal SDK languages.",
      "rootCause": null,
      "proposedFix": "Implement Nexus common library and SDK-specific implementations for each language based on Nexus specifications and existing implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        232,
        580
      ],
      "keyQuote": "Each language needs a generic Nexus common library in https://github.com/nexus-rpc and each language needs a Temporal-specific Nexus implementation in the Temporal SDK",
      "number": 609,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:26:08.763Z"
    },
    {
      "summary": "SDKs should check if an activity has already completed or timed out before sending the final buffered heartbeat to avoid unnecessary temporal_request_failure metric noise.",
      "category": "other",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-mechanism",
        "metrics"
      ],
      "concepts": [
        "heartbeat",
        "activity-completion",
        "timeout",
        "metric-noise",
        "server-state-checking"
      ],
      "severity": "low",
      "userImpact": "Users see spurious temporal_request_failure metrics when activities complete while buffered heartbeats are pending.",
      "rootCause": "SDKs lack a pre-send check for activity completion/timeout status before transmitting the final buffered heartbeat.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDKs should try to check if activity is completed or timed out before sending last buffered heartbeat",
      "number": 608,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:26:14.276Z"
    },
    {
      "summary": "Cross-SDK metrics standardization initiative to identify and reduce unintentional deviation in metrics reporting across different Temporal SDK languages, ensuring consistent observability for multi-language users.",
      "category": "feature",
      "subcategory": "metrics-standardization",
      "apis": [],
      "components": [
        "metrics-reporter",
        "worker",
        "runtime"
      ],
      "concepts": [
        "metrics",
        "observability",
        "cross-sdk-consistency",
        "standardization",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Multi-language users experience inconsistent metrics across SDKs, making it harder to understand and monitor behavior across their distributed workers.",
      "rootCause": null,
      "proposedFix": "Create per-SDK tickets to document and standardize metrics reporting with non-default configuration where needed to achieve consistency.",
      "workaround": "Configure each SDK with non-default settings to emit consistent metrics, though this requires language-specific knowledge.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "much of this may be an exercise in documenting how to get each SDK to emit consistent metrics with each other",
      "number": 607,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:26:12.749Z"
    },
    {
      "summary": "Users should be able to configure custom bucket sizes for histogram metrics emitted by Temporal SDKs. This feature was already available in some SDKs (Go, Java, PHP) but needed implementation in Core-based SDKs (TypeScript, Python, .NET, Ruby).",
      "category": "feature",
      "subcategory": "metrics-configuration",
      "apis": [],
      "components": [
        "metrics",
        "histogram",
        "configuration"
      ],
      "concepts": [
        "metrics",
        "histogram",
        "bucket-sizing",
        "observability",
        "customization"
      ],
      "severity": "low",
      "userImpact": "Users can now customize histogram metric bucket sizes to better match their monitoring needs across all SDK implementations.",
      "rootCause": null,
      "proposedFix": "Implement custom bucket size configuration in Core-based SDKs (TypeScript, Python, .NET, Ruby) following the implementation pattern already available in Go and Java SDKs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature has been completed across all SDK implementations. Core SDK implementation was done in PR #844, with a follow-up bug fix in issue #873.",
      "related": [
        1634,
        777,
        416,
        228,
        873
      ],
      "keyQuote": "Yes, this has been done for some time",
      "number": 606,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:25:57.390Z"
    },
    {
      "summary": "SDKs need to expose root workflow execution information (workflow ID and run ID) from both workflow info and workflow execution objects, similar to how parent execution is currently exposed. The API now provides this data but SDKs have not yet implemented the exposure across all supported languages.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowInfo",
        "WorkflowExecution",
        "DescribeWorkflow"
      ],
      "components": [
        "workflow-info",
        "workflow-execution",
        "sdk-api"
      ],
      "concepts": [
        "root-workflow",
        "workflow-execution",
        "execution-chain",
        "parent-child-workflows",
        "workflow-metadata"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently access root workflow execution identifiers from workflow info or execution objects, limiting their ability to track execution hierarchies in complex workflow scenarios.",
      "rootCause": null,
      "proposedFix": "Expose root workflow execution workflow ID and run ID from workflow info and workflow execution objects following the same pattern used for parent execution exposure.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1848,
        2430,
        881,
        1633,
        774,
        415,
        227,
        576,
        763,
        366
      ],
      "keyQuote": "SDKs should do the following: Expose root workflow execution workflow ID and run ID from workflow info in a similar fashion to how is done with parent execution",
      "number": 605,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:25:58.224Z"
    },
    {
      "summary": "Built-in query responses need to return RawValue from default converters instead of structures to avoid requiring users to have a specific converter configured. This is a backwards-incompatible change affecting multiple SDKs.",
      "category": "feature",
      "subcategory": "query-responses",
      "apis": [
        "Query",
        "RawValue"
      ],
      "components": [
        "query-handler",
        "converter",
        "metadata-query"
      ],
      "concepts": [
        "serialization",
        "converter-configuration",
        "backwards-compatibility",
        "query-response",
        "default-converter",
        "type-conversion"
      ],
      "severity": "medium",
      "userImpact": "Users will need to explicitly convert RawValue payloads to the expected metadata type when using built-in metadata queries after this change.",
      "rootCause": "Built-in queries currently return structures that expect a certain form of converter the user may not have configured, causing failures when users have custom converter setups.",
      "proposedFix": "Return RawValue from default converters for all built-in queries instead of structures, limiting this backwards-incompatible change to the built-in metadata query.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        603,
        1843,
        2426,
        1630,
        773,
        414,
        224,
        575
      ],
      "keyQuote": "this is a backwards incompatible change and should be limited to the built-in metadata query only",
      "number": 604,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:25:55.755Z"
    },
    {
      "summary": "SDKs need to support a 'RawValue' wrapper that passes payloads through codec processing without applying traditional payload conversion, enabling dynamic deserialization and built-in queries like workflow metadata.",
      "category": "feature",
      "subcategory": "payload-conversion",
      "apis": [],
      "components": [
        "payload-converter",
        "codec",
        "activity-context",
        "workflow-context"
      ],
      "concepts": [
        "payload-conversion",
        "codec",
        "dynamic-deserialization",
        "type-handling",
        "payload-wrapper"
      ],
      "severity": "medium",
      "userImpact": "Enables developers to handle dynamically-typed payloads and access built-in query responses without conversion overhead across all SDKs.",
      "rootCause": null,
      "proposedFix": "Implement RawValue class/wrapper in each SDK that bypasses traditional payload conversion in the converter chain while maintaining codec application.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        201,
        604,
        1231,
        2425,
        1629,
        574
      ],
      "keyQuote": "SDKs need to support a payload wrapper called \"raw value\" that is just a payload but it is passed through the conversion stage (but still applies to codec).",
      "number": 603,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:09:10.217Z"
    },
    {
      "summary": "Feature request to interrupt long-running heartbeating activities when paused via `temporal activity pause` command. Users should be able to distinguish pause interruption from cancellation, as they may require different handling logic.",
      "category": "feature",
      "subcategory": "activity-pause",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat",
        "pause-handler"
      ],
      "concepts": [
        "activity-pause",
        "heartbeat",
        "interruption",
        "cancellation",
        "long-running-activities",
        "exception-handling"
      ],
      "severity": "medium",
      "userImpact": "Users can now pause long-running heartbeating activities without predicting the need in advance, with pause-specific interruption behavior distinct from cancellation.",
      "rootCause": null,
      "proposedFix": "Throw a cancel-like exception (language-appropriate) that is distinguishable from regular cancellation, allowing different handling based on whether activity is ending completely or pausing temporarily.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        812,
        2465,
        441,
        1899,
        1665,
        241,
        895
      ],
      "keyQuote": "Always, for now - We can add a flag later to turn it off if people ask for it (but they probably won't). It's important that by default, pause 'just works'",
      "number": 602,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:09:09.193Z"
    },
    {
      "summary": "Need to establish a formal testing approach to verify that workflow histories remain compatible across SDK versions and will continue to be in the future. Current practices are fragmented across different SDKs and languages.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "history-replay",
        "testing-framework",
        "sdk-compatibility",
        "workflow-execution"
      ],
      "concepts": [
        "history-compatibility",
        "workflow-replay",
        "cross-version-testing",
        "regression-testing",
        "async-utilities",
        "coroutine-order"
      ],
      "severity": "high",
      "userImpact": "Users need assurance that upgrading to newer SDK versions won't break replaying old workflow histories, which is critical for long-running distributed systems.",
      "rootCause": null,
      "proposedFix": "Leverage existing patterns from features repo (--generate-history), Go/Java SDK unit test histories, omes fuzzer for history generation, and ensure replay testing includes language-specific async utilities.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Need a more formal way to test that history is compatible across SDK versions and will continue to be.",
      "number": 598,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:09:06.817Z"
    },
    {
      "summary": "Server truncates oversized failures but cannot truncate stack traces in encoded attributes, dropping the entire message and trace. Need SDK-side stack trace truncation with configurable limits and a smart algorithm that removes middle frames while preserving context.",
      "category": "feature",
      "subcategory": "failure-handling",
      "apis": [],
      "components": [
        "failure-converter",
        "stack-trace-handler",
        "error-encoding"
      ],
      "concepts": [
        "failure-truncation",
        "stack-trace-management",
        "payload-size",
        "error-serialization",
        "middle-frame-omission"
      ],
      "severity": "high",
      "userImpact": "Ruby users (and potentially other SDK users) experience complete loss of failure messages and stack traces when failures exceed server size limits, making debugging failures impossible.",
      "rootCause": "Server cannot truncate stack traces in encoded_attributes payloads, so oversized encoded failures are dropped entirely instead of being partially truncated.",
      "proposedFix": "Implement SDK-side stack trace truncation using a tiered algorithm: try preserving 10 lines, then 4 lines, then none, removing only middle frames and replacing with '...<X frames omitted>...' placeholder. Make max failure size customizable in failure converter options with 'no max' option.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        319
      ],
      "keyQuote": "the server can't truncate a stack trace for an \"encoded\" failure so that entire set of payloads is dropped which means the entire message and stack trace is gone",
      "number": 597,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:52.753Z"
    },
    {
      "summary": "Expose the cancellation cause/reason from WorkflowExecutionCancelRequestedEventAttributes to SDK users, both when workflows receive cancellations and when clients issue cancellations. This feature needs implementation across all Temporal SDKs.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [
        "WorkflowExecutionCancelRequestedEventAttributes",
        "CancelWorkflowExecution"
      ],
      "components": [
        "workflow-runtime",
        "client-api",
        "event-handling"
      ],
      "concepts": [
        "cancellation",
        "workflow-lifecycle",
        "event-attributes",
        "cross-sdk-feature"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access the reason why their workflows were cancelled, limiting their ability to implement cancellation-aware business logic.",
      "rootCause": null,
      "proposedFix": "Expose the cause field from WorkflowExecutionCancelRequestedEventAttributes as part of the cancellation signal/exception received by workflows, and add cause parameter to client-side workflow cancellation methods.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        764,
        1626,
        2414,
        412,
        1817,
        567
      ],
      "keyQuote": "WorkflowExecutionCancelRequestedEventAttributes has a cause field that should be exposed when workflows receive cancels, and we should additionally expose this as an input when users are issuing cancels from clients or commands",
      "number": 596,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:54.151Z"
    },
    {
      "summary": "Add a features test for cloud API key authentication over the data plane. The test should run a workflow using Temporal Cloud with an API key for authentication without manually setting namespace headers.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflow"
      ],
      "components": [
        "test-framework",
        "cloud-client",
        "authentication",
        "data-plane"
      ],
      "concepts": [
        "api-key-authentication",
        "cloud-api",
        "namespace-configuration",
        "test-coverage",
        "data-plane",
        "client-configuration"
      ],
      "severity": "medium",
      "userImpact": "Ensures SDK implementations can authenticate with Temporal Cloud using API keys over the data plane without manual namespace configuration.",
      "rootCause": null,
      "proposedFix": "Create a test that uses TEMPORAL_CLIENT_CLOUD_API_KEY and TEMPORAL_CLIENT_NAMESPACE environment variables to connect to us-west-2.aws.api.temporal.io:7233 and execute a workflow.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "use it and `TEMPORAL_CLIENT_NAMESPACE` env var to test against `us-west-2.aws.api.temporal.io:7233`... with just the API key from a user POV",
      "number": 595,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:55.716Z"
    },
    {
      "summary": "Add native support for musl-based environments across Temporal SDKs and tooling. This includes publishing musl-specific libraries for core-based SDKs, building musl binaries for the time-skipping test server, and updating temporal.download to support musl platform detection.",
      "category": "feature",
      "subcategory": "build-infrastructure",
      "apis": [],
      "components": [
        "sdk-core",
        "test-server",
        "temporal.download",
        "ci-infrastructure"
      ],
      "concepts": [
        "musl-libc",
        "platform-support",
        "binary-distribution",
        "ci-setup",
        "environment-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users in musl-based environments (Alpine Linux, etc.) can use Temporal SDKs and tooling natively without requiring glibc compatibility layers.",
      "rootCause": null,
      "proposedFix": "Publish musl-based libraries for core SDKs, build musl test server binaries, add musl=true URL parameter support to temporal.download, and update Core to detect and flag musl compilation",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2402,
        1621,
        761,
        408,
        215,
        872
      ],
      "keyQuote": "For any core-based SDKs, publish musl-based libraries and have musl-based CI",
      "number": 594,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:37.294Z"
    },
    {
      "summary": "Feature request to implement task queue priority options/annotations across SDKs. The API changes were introduced in api#513 and Go SDK has a reference implementation in sdk-go#1792. This requires passing through new priority-related options to the task queue in all SDK implementations.",
      "category": "feature",
      "subcategory": "task-queue-priority",
      "apis": [
        "StartWorkflowOptions",
        "TaskQueueOptions"
      ],
      "components": [
        "task-queue",
        "worker",
        "client"
      ],
      "concepts": [
        "priority",
        "task-scheduling",
        "queue-management",
        "options",
        "SDK-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to control task queue priority settings across all SDKs, enabling better control over workflow task execution order.",
      "rootCause": null,
      "proposedFix": "Pass through priority options from API layer to task queue implementation, following the Go SDK reference implementation (sdk-go#1792).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented across SDKs with per-SDK tracking issues completed (Go, Java, TypeScript, Python, .NET, Ruby, PHP).",
      "related": [
        513,
        1792,
        2399,
        871,
        1620,
        760,
        403,
        210,
        559
      ],
      "keyQuote": "Support setting those options in SDKs. This is all fairly straightforward pass-through of some new options.",
      "number": 593,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:40.848Z"
    },
    {
      "summary": "Add a `temporalNamespace` tag to all distributed tracing spans across SDKs to provide namespace context in observability data.",
      "category": "feature",
      "subcategory": "tracing",
      "apis": [],
      "components": [
        "tracing",
        "spans",
        "observability"
      ],
      "concepts": [
        "namespace",
        "distributed-tracing",
        "observability",
        "span-tags",
        "context",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to better identify and filter distributed traces by namespace, improving observability and debugging capabilities.",
      "rootCause": null,
      "proposedFix": "Include a `temporalNamespace` tag in all tracing spans across all SDK implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Spans have several tags but not the namespace. Based on user request, we should consider including a `temporalNamespace` tag in all spans.",
      "number": 592,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:37.570Z"
    },
    {
      "summary": "Standardize the `patched()` and `deprecatePatch()` APIs across all Temporal SDKs with consistent behavior (memoized), while maintaining backward compatibility with existing versioning APIs like `GetVersion()`. The memoized flag should be stored in workflow history markers and inconsistent usage should trigger non-determinism errors.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "patched",
        "deprecatePatch",
        "GetVersion"
      ],
      "components": [
        "workflow-versioning",
        "history-markers",
        "workflow-execution",
        "determinism-checker"
      ],
      "concepts": [
        "memoization",
        "backward-compatibility",
        "workflow-history",
        "non-determinism",
        "api-standardization",
        "versioning-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users will have a consistent, simplified API for workflow versioning across all SDKs, reducing confusion and making migration between SDKs easier.",
      "rootCause": "Inconsistent implementation of workflow versioning APIs across different SDKs (GetVersion in Go/Java/PHP vs patched() in Python/.NET/Ruby vs non-memoized patched() in TypeScript) creates confusion and incompatibility.",
      "proposedFix": "Implement uniform `patched(patchId, memoized): boolean` and `deprecatePatch(patchId, memoized): boolean` APIs in all SDKs with memoized flag stored in Marker commands. Deprecate existing inconsistent APIs while maintaining backward compatibility. Core SDK implements first, then other SDKs mirror the implementation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1796,
        2393,
        869,
        1616,
        754,
        398,
        209,
        558
      ],
      "keyQuote": "Support the `patched(patchId, memoized): boolean` and `deprecatePatch(patchId, memoized): boolean` APIs in all SDKs",
      "number": 591,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:26.142Z"
    },
    {
      "summary": "User requests a describe() method for ExternalWorkflowHandle to retrieve workflow status without requiring an extra activity. Feature requires server-side support before SDK implementation.",
      "category": "feature",
      "subcategory": "workflow-client",
      "apis": [
        "ExternalWorkflowHandle",
        "WorkflowHandle"
      ],
      "components": [
        "workflow-client",
        "external-workflow",
        "api"
      ],
      "concepts": [
        "workflow-status",
        "workflow-introspection",
        "external-workflow",
        "describe",
        "client-api"
      ],
      "severity": "low",
      "userImpact": "Users currently need to implement extra activities to check workflow status when using external workflow handles.",
      "rootCause": "Server does not support the describe command for external workflows yet.",
      "proposedFix": "Add describe() method to ExternalWorkflowHandle similar to the one in WorkflowHandle, after server support is implemented.",
      "workaround": "Implement an extra activity to retrieve workflow status.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed as server-driven feature request. Moved to platform-level tracking in temporalio/features repo and linked to server issue #3261.",
      "related": [
        3261
      ],
      "keyQuote": "I personally need it to get the workflow status, and it would remove the necessity to add extra activity to receive it.",
      "number": 590,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:21.777Z"
    },
    {
      "summary": "Add a utility function to classify exceptions as either workflow-exiting or task-failing exceptions. This helps developers distinguish between exceptions that terminate the workflow versus those that cause automatic retries.",
      "category": "feature",
      "subcategory": "exception-handling",
      "apis": [],
      "components": [
        "exception-handling",
        "failure-handling",
        "workflow-execution"
      ],
      "concepts": [
        "exception-classification",
        "workflow-exit",
        "task-failure",
        "retry-behavior",
        "failure-handling"
      ],
      "severity": "low",
      "userImpact": "Developers can more easily determine whether an exception will cause their workflow to exit or trigger an automatic retry.",
      "rootCause": null,
      "proposedFix": "Implement a utility function like `is_workflow_exit_exception()` that checks if an exception is of a type that causes workflow exit (e.g., asyncio.CancelledError, FailureError) versus task failure.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "True if the exception is of a type that will cause the workflow to exit. This is as opposed to exceptions that cause a workflow task failure, which are retried automatically by Temporal.",
      "number": 589,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:22.577Z"
    },
    {
      "summary": "Allow users to specify a custom UI port when enabling the dev server in programmatic configuration. Currently, SDKs don't expose the UI port customization option even though it's available in the underlying implementation.",
      "category": "feature",
      "subcategory": "dev-server",
      "apis": [],
      "components": [
        "dev-server",
        "ui-configuration",
        "sdk-configuration"
      ],
      "concepts": [
        "dev-server",
        "ui-port",
        "configuration",
        "customization",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers using the dev server cannot customize the UI port, limiting their ability to configure the development environment to their needs.",
      "rootCause": null,
      "proposedFix": "Expose the UI port configuration option across SDKs to match the Core and Temporal CLI implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1788,
        1611,
        748,
        396,
        205
      ],
      "keyQuote": "Most (all?) SDKs with dev server allow enabling the UI but do not allow customizing the UI port even though the option is available.",
      "number": 588,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:06.916Z"
    },
    {
      "summary": "Add Ruby as a first-class supported language in the temporalio-features repository, including implementation of example features in Ruby to guide users and demonstrate SDK capabilities.",
      "category": "feature",
      "subcategory": "language-support",
      "apis": [],
      "components": [
        "features-repo",
        "ruby-sdk",
        "documentation"
      ],
      "concepts": [
        "language-support",
        "sdk-parity",
        "examples",
        "first-class-citizen",
        "feature-showcase"
      ],
      "severity": "medium",
      "userImpact": "Ruby developers will have access to feature examples and guides in the temporalio-features repository, improving their ability to understand and use the Temporal Ruby SDK.",
      "rootCause": null,
      "proposedFix": "Implement Ruby support in the features repository and create example implementations of several features in Ruby.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add Ruby support to the repo as a first-class citizen (and implement a couple of features in Ruby as a guide)",
      "number": 585,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:10.251Z"
    },
    {
      "summary": "The continue_as_new/continue_as_same feature fails in cloud environments with deadline exceeded and workflow execution already started exceptions. The workflow exits prematurely and assertions fail before completion, indicating timing issues with the feature's cloud integration.",
      "category": "bug",
      "subcategory": "continue-as-new",
      "apis": [],
      "components": [
        "workflow-execution",
        "cloud-integration",
        "test-harness"
      ],
      "concepts": [
        "deadline",
        "workflow-continuation",
        "cloud-testing",
        "state-management",
        "task-queue",
        "workflow-id-reuse"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test or use continue_as_new/continue_as_same workflows in cloud environments due to timeout and execution conflicts.",
      "rootCause": "Workflow type 'Workflow' is used globally across all task queues in test harness, causing conflicts and race conditions when multiple workflows with the same name try to execute. Additionally, cloud implementation has timing issues causing premature workflow exit.",
      "proposedFix": "Use unique workflow names per task queue to avoid naming conflicts in the test harness.",
      "workaround": "Set a unique name for the Workflow to avoid conflicts with Workflows of the same name from other TaskQueues.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed by updating test harness to use unique workflow identifiers per task queue.",
      "related": [
        481
      ],
      "keyQuote": "With this bug, all Harness tests might be flaky because the Workflow type 'Workflow' is used everywhere (but with different TaskQueues)",
      "number": 582,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:08:10.137Z"
    },
    {
      "summary": "A workaround environment variable `TEMPORAL_FEATURES_DISABLE_WORKFLOW_COMPLETION_CHECK` was introduced to bypass test failures in cloud where workflows appear to still be running according to ListWorkflow APIs even after they complete. This workaround needs to be removed by properly resolving the underlying stale data issue.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ListOpenWorkflowExecutions",
        "ListClosedWorkflowExecutions",
        "ListWorkflow"
      ],
      "components": [
        "test-framework",
        "workflow-completion",
        "cloud-compatibility"
      ],
      "concepts": [
        "stale-data",
        "workflow-status",
        "test-validation",
        "timing-issue",
        "cloud-behavior"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably run integration tests against Temporal Cloud due to stale workflow status data causing test assertions to fail incorrectly.",
      "rootCause": "Cloud APIs return stale data indicating workflows are still running even after they complete and confirm completion within milliseconds; the issue persists even after switching from ListOpenWorkflowExecutions/ListClosedWorkflowExecutions to the preferred ListWorkflow API.",
      "proposedFix": "Properly resolve the underlying stale data issue in the cloud APIs or test framework rather than working around it with environment variables.",
      "workaround": "Environment variable `TEMPORAL_FEATURES_DISABLE_WORKFLOW_COMPLETION_CHECK` was introduced to skip the workflow completion check during tests.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        577,
        579
      ],
      "keyQuote": "The workflows were completing (in milliseconds) but even after 5s these were returning stale data in cloud saying that status was still running.",
      "number": 581,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:53.706Z"
    },
    {
      "summary": "PHP schedule/basic test fails when run against cloud due to marshalling errors with ScheduleSpec.jitter field, which appears to be receiving null values that cannot be properly deserialized.",
      "category": "bug",
      "subcategory": "schedule-marshalling",
      "apis": [
        "Schedule",
        "ScheduleListEntry",
        "ScheduleSpec"
      ],
      "components": [
        "php-sdk",
        "schedule-client",
        "marshaller"
      ],
      "concepts": [
        "serialization",
        "deserialization",
        "null-handling",
        "cloud-compatibility",
        "type-conversion"
      ],
      "severity": "high",
      "userImpact": "PHP applications using schedules fail in cloud environments due to unmarshalling errors when null jitter values are encountered.",
      "rootCause": "ScheduleSpec.jitter field receives null values that the marshaller cannot properly deserialize/handle",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by handling null jitter values in ScheduleSpec marshalling logic",
      "related": [
        577
      ],
      "keyQuote": "Unable to unmarshal field `jitter` of class Temporal\\Client\\Schedule\\Spec\\ScheduleSpec",
      "number": 580,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:56.123Z"
    },
    {
      "summary": "All SDKs need to prevent registration of workflows, activities, Nexus operations, task queues, signals, queries, and updates with the reserved `__temporal_` prefix, and handle reserved queries like `__stack_trace` without interceptors.",
      "category": "feature",
      "subcategory": "reserved-names",
      "apis": [],
      "components": [
        "workflow-registration",
        "activity-registration",
        "signal-registration",
        "query-registration",
        "update-registration",
        "task-queue",
        "interceptors",
        "nexus"
      ],
      "concepts": [
        "reserved-names",
        "namespace-collision",
        "built-in-features",
        "registration-validation",
        "query-handling",
        "interceptor-bypass"
      ],
      "severity": "medium",
      "userImpact": "SDKs must consistently prevent users from registering handlers with reserved prefixes and handle built-in queries specially to avoid conflicts and unexpected behavior.",
      "rootCause": null,
      "proposedFix": "Implement validation at registration time to reject names starting with `__temporal_`, special handling for `__stack_trace` and `__enhanced_stack_trace` queries, and bypass interceptors for reserved query names.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1779,
        2368,
        1599,
        731,
        391,
        195,
        552
      ],
      "keyQuote": "Disallow workflows, activities, Nexus operations/services, task queues, signals, queries, and updates to be registered that start with `__temporal_`",
      "number": 576,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:54.588Z"
    },
    {
      "summary": "Request for fine-grained control over workflow cache eviction policies. Users want to optimize memory usage by evicting long-running workflows and keeping recently-queried workflows cached to avoid expensive history replay on post-close queries.",
      "category": "feature",
      "subcategory": "workflow-cache",
      "apis": [],
      "components": [
        "workflow-cache",
        "cache-eviction",
        "query-executor"
      ],
      "concepts": [
        "cache-eviction",
        "memory-optimization",
        "workflow-lifecycle",
        "post-close-queries",
        "LRU-strategy",
        "sticky-queue"
      ],
      "severity": "medium",
      "userImpact": "Users gain control over cache eviction strategy to optimize memory usage and reduce latency for post-close workflow queries.",
      "rootCause": "Current LRU cache eviction strategy doesn't account for workflow characteristics (sleep duration, query patterns) or post-close query needs.",
      "proposedFix": "Implement pluggable cache eviction policies and server-side changes to support keeping closed workflows in cache for post-close queries via sticky queue.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        4463
      ],
      "keyQuote": "They may want to control how long the workflow will be stored in the cache after the workflow is closed to prevent the extra latency that comes with fetch + replay",
      "number": 573,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:42.103Z"
    },
    {
      "summary": "Request to expose workflow and activity instances created by Temporal from their respective contexts, allowing users (e.g., via interceptors) to access the actual class instance. Needs implementation across Java, Python, .NET, Ruby, and PHP SDKs, with future support for Nexus.",
      "category": "feature",
      "subcategory": "context-access",
      "apis": [
        "WorkflowContext",
        "ActivityContext"
      ],
      "components": [
        "workflow-context",
        "activity-context",
        "interceptor",
        "instance-management"
      ],
      "concepts": [
        "instance-access",
        "context-exposure",
        "dependency-injection",
        "lifecycle-management",
        "framework-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access the actual workflow or activity instance from context, limiting interceptor functionality and runtime introspection capabilities.",
      "rootCause": null,
      "proposedFix": "Make workflow instance accessible via workflow context and activity instance accessible via activity context where applicable by SDK language.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2361,
        720,
        388,
        180,
        546
      ],
      "keyQuote": "For instances created by Temporal, they should be accessible from the context. Users want to access the actual class instance of a workflow from, say, an interceptor.",
      "number": 572,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:38.916Z"
    },
    {
      "summary": "Users need a thread-local-like mechanism to access and mutate workflow-specific values across SDKs. This feature already exists in Java but needs to be implemented in Go, Python, .NET, Ruby, and PHP to provide a consistent way to manage state within workflows and interceptors.",
      "category": "feature",
      "subcategory": "workflow-context",
      "apis": [],
      "components": [
        "workflow-runtime",
        "interceptor-system",
        "context-management"
      ],
      "concepts": [
        "thread-local",
        "workflow-scope",
        "state-management",
        "context-isolation",
        "library-integration",
        "interceptor-access"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily access and manage workflow-specific state in reusable libraries and interceptors across multiple SDKs, limiting code reusability and cross-cutting concerns.",
      "rootCause": null,
      "proposedFix": "Implement workflow-local value storage mechanism similar to Java implementation across Go, Python, .NET, Ruby, and PHP SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1760,
        719,
        387,
        179,
        545
      ],
      "keyQuote": "Users need a thread-local-like way to access/mutate workflow-specific values.",
      "number": 571,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:39.908Z"
    },
    {
      "summary": "Feature request for a native query builder in Temporal SDKs to safely construct visibility API queries instead of string concatenation. The user has already open-sourced a working Go implementation and advocates for including it in official repositories for better discoverability and support.",
      "category": "feature",
      "subcategory": "visibility-api",
      "apis": [
        "ListWorkflowExecutions"
      ],
      "components": [
        "visibility-api",
        "query-builder",
        "search-attributes"
      ],
      "concepts": [
        "query-construction",
        "string-safety",
        "visibility-filtering",
        "search-attributes",
        "api-usability",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Users currently must manually build visibility query strings which is error-prone; a native builder would provide type-safe query construction.",
      "rootCause": null,
      "proposedFix": "Implement a query builder across all SDKs supporting logical operators and list filters, similar to SQL builders. Example: QueryBuilder().StartQuery(attr, operator, value).And(...).Encode() returns query string.",
      "workaround": "Use external community package like https://github.com/OpeOnikute/temporal-go-querybuilder or manual string formatting with fmt.Sprintf",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A simple to use query builder that supports all the defined logical operators and list filters",
      "number": 568,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:27.499Z"
    },
    {
      "summary": "SDKs need to implement support for full query failure structure in the new `failure` field on query responses. Workers should set converted query failures while maintaining backward compatibility by keeping `error_message` aligned with `failure.message`. Clients should check for `QueryFailedFailure` gRPC details and set them as the cause of returned errors.",
      "category": "feature",
      "subcategory": "query-handling",
      "apis": [],
      "components": [
        "worker",
        "client",
        "query-executor",
        "error-handling"
      ],
      "concepts": [
        "query-failure",
        "error-structure",
        "backward-compatibility",
        "failure-details",
        "gRPC",
        "error-cause"
      ],
      "severity": "medium",
      "userImpact": "Users will have access to detailed query failure information with proper error cause chains while maintaining backward compatibility with existing error handling code.",
      "rootCause": null,
      "proposedFix": "Set converted query failures on the new `failure` field in query responses, maintain `error_message` alignment, and check for `QueryFailedFailure` in client gRPC failures to set as error cause.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        503,
        6947
      ],
      "keyQuote": "SDK clients need to check for this `QueryFailedFailure` gRPC failure details on query response gRPC failure and if present, need to set that as the cause",
      "number": 566,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:27.928Z"
    },
    {
      "summary": "Feature request for a FIFO mutex mechanism to lock critical sections of workflow code based on a key. The request seeks built-in support for cross-workflow locking to ensure sequential execution of operations for specific users or entities (e.g., preventing concurrent DB updates for the same user across different workflow instances).",
      "category": "feature",
      "subcategory": "concurrency-control",
      "apis": [
        "Lock",
        "Unlock",
        "NewMutex"
      ],
      "components": [
        "workflow-engine",
        "synchronization",
        "cross-workflow-coordination"
      ],
      "concepts": [
        "mutex",
        "locking",
        "FIFO-queue",
        "critical-section",
        "concurrency",
        "cross-workflow-state",
        "serialization"
      ],
      "severity": "medium",
      "userImpact": "Users must currently implement complex custom solutions (like separate mutex workflows) to ensure FIFO-ordered access to shared resources across multiple workflow instances, when simple built-in lock/unlock primitives would suffice.",
      "rootCause": null,
      "proposedFix": "Add workflow-level primitives like `workflow.Lock(ctx, key)` and `workflow.Unlock(ctx, key)` that guarantee FIFO ordering for cross-workflow mutual exclusion, similar to language-standard mutex implementations.",
      "workaround": "Implement a custom mutex workflow pattern as shown in https://github.com/temporalio/samples-go/tree/main/mutex - a separate workflow that manages a map of lock queues and coordinates lock/unlock requests via channels.",
      "resolution": "wontfix",
      "resolutionDetails": "Temporal team decided not to provide this as a built-in primitive, preferring to leave complex concurrency patterns as user-implementable samples. The rationale is that workflows are powerful primitives allowing customization for various scenarios (semaphores, custom barriers, etc.) beyond simple locks.",
      "related": [
        500
      ],
      "keyQuote": "The benefit of Temporal workflows being a primitive is you can do anything you want here instead of Temporal providing some rigid primitive.",
      "number": 565,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:27.142Z"
    },
    {
      "summary": "Feature request to provide a flag indicating whether an update handler is being invoked from a re-applied update during workflow reset/replay. This is needed to prevent activity failures when updates are retried after being marked as admitted to the client.",
      "category": "feature",
      "subcategory": "update-handler",
      "apis": [],
      "components": [
        "update-handler",
        "workflow-context",
        "workflow-task",
        "activity-retry"
      ],
      "concepts": [
        "update-reapply",
        "workflow-reset",
        "activity-retry",
        "admitted-event",
        "replay",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot safely handle retried updates after reset without risking activity failures, forcing them to use workarounds for correct error handling behavior.",
      "rootCause": "SDK does not expose information about whether an update is being reapplied from an Admitted event, preventing handlers from distinguishing initial attempts from reset replays.",
      "proposedFix": "SDK should provide a flag or context property indicating the update request came from re-applying an Admitted event.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        5873,
        1776
      ],
      "keyQuote": "SDK should know this info (the update is from Admitted event), just provide a flag to us.",
      "number": 564,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:09.883Z"
    },
    {
      "summary": "Request to add exception type tagging to the workflow_failed counter metric to allow users to filter and alert on unexpected failures while distinguishing intentional business logic failures.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-execution",
        "failure-handling"
      ],
      "concepts": [
        "metrics-tagging",
        "observability",
        "alerting",
        "exception-types",
        "business-failures",
        "filtering"
      ],
      "severity": "medium",
      "userImpact": "Users cannot effectively alert on unexpected workflow failures because metric cardinality issues prevent tagging exception types, forcing workarounds with custom search attributes.",
      "rootCause": "The workflow_failed counter metric lacks exception type tags, making it impossible to distinguish between business-intentional failures and unexpected failures for alerting purposes.",
      "proposedFix": "Add exception type as a tag to the workflow_failed counter metric; alternatively, allow specifying exception severity levels that can be tagged and filtered in metrics.",
      "workaround": "Users currently resort to custom search attributes with upserted business failure values or custom metrics, though not all SDKs support custom metric tags.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1229
      ],
      "keyQuote": "tag workflow_failed counter metric with the application failure type that caused workflow to fail",
      "number": 563,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:11.457Z"
    },
    {
      "summary": "Request for Sessions support in TypeScript SDK, similar to the Go SDK implementation. Sessions provide concurrency control and worker-specific task queue patterns for managing activity execution affinity.",
      "category": "feature",
      "subcategory": "sessions",
      "apis": [
        "ExecuteActivity",
        "StartWorkflow"
      ],
      "components": [
        "worker",
        "task-queue",
        "activity-executor"
      ],
      "concepts": [
        "session",
        "worker-affinity",
        "concurrency-control",
        "sticky-activities",
        "task-queue",
        "load-balancing"
      ],
      "severity": "medium",
      "userImpact": "TypeScript SDK users cannot implement session-based patterns for activity execution affinity and worker-specific concurrency control that Go SDK users have access to.",
      "rootCause": "TypeScript SDK lacks the Sessions API that exists in Go SDK, though worker-specific task queues provide alternative pattern.",
      "proposedFix": "Implement Sessions API in TypeScript SDK with concurrency control similar to Go SDK, or provide clearer documentation on using worker-specific task queue pattern as alternative.",
      "workaround": "Use worker-specific task queues with maxConcurrentWorkflowTaskExecutions and maxConcurrentActivityTaskExecutions configuration for session-like behavior.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This appears to have been transferred from the TypeScript SDK issue tracker, but for those wondering, all SDKs support a concept of \"worker-specific task queues\" which basically provides session behavior.",
      "number": 562,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:07:13.464Z"
    },
    {
      "summary": "Feature request to add mutable side effect support in core-based SDKs. The discussion evaluates whether mutable side effects provide sufficient value over local activities, with community debate on use cases and implementation priorities.",
      "category": "feature",
      "subcategory": "workflow-side-effects",
      "apis": [
        "MutableSideEffect"
      ],
      "components": [
        "sdk-core",
        "workflow-engine",
        "determinism-tracking"
      ],
      "concepts": [
        "determinism",
        "caching",
        "workflow-safety",
        "non-deterministic-actions",
        "local-activities",
        "side-effects"
      ],
      "severity": "low",
      "userImpact": "Users asking for safer workflows could use mutable side effects to cache deterministic function results, though local activities are presented as the current recommended approach.",
      "rootCause": null,
      "proposedFix": "Implement mutable side effect API based on Go SDK's MutableSideEffect pattern after evaluating core SDK support requirements.",
      "workaround": "Use local activities or pass values as workflow arguments instead of side effects.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Side-effect will probably not be implemented in newer SDKs, we should consider implementing mutable side effects.",
      "number": 561,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:55.621Z"
    },
    {
      "summary": "Add a `pendingActivities` field to `WorkflowExecutionInfo` that provides all activity payload fields fully decoded and timestamps converted to appropriate formats.",
      "category": "feature",
      "subcategory": "workflow-execution-info",
      "apis": [
        "WorkflowExecutionInfo"
      ],
      "components": [
        "client",
        "workflow-execution-api",
        "data-structures"
      ],
      "concepts": [
        "pending-activities",
        "activity-payloads",
        "data-decoding",
        "timestamp-conversion",
        "workflow-state"
      ],
      "severity": "medium",
      "userImpact": "Users can more easily inspect pending activities in a workflow with properly decoded data and formatted timestamps, improving debugging and monitoring capabilities.",
      "rootCause": null,
      "proposedFix": "Add `pendingActivities` field to `WorkflowExecutionInfo` interface with decoded payloads and converted timestamps",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add WorkflowExecutionInfo .pendingActivities that has all the fields payloads decoded and timestamps converted",
      "number": 560,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:56.224Z"
    },
    {
      "summary": "Implement structured command/event diff representation in non-determinism errors across SDKs. Currently, error messages are obscure and don't clearly explain what command was expected versus what actually occurred during workflow replay.",
      "category": "feature",
      "subcategory": "error-messages",
      "apis": [],
      "components": [
        "non-determinism detection",
        "error details",
        "workflow replay",
        "command/event tracking"
      ],
      "concepts": [
        "determinism",
        "workflow replay",
        "error reporting",
        "serialization",
        "command/event diffs",
        "history reconciliation"
      ],
      "severity": "medium",
      "userImpact": "Users receive unclear error messages when workflow code is non-deterministic, making it difficult to diagnose and fix the underlying issues.",
      "rootCause": "Error detail payloads don't include structured information about expected vs actual commands/events during replay.",
      "proposedFix": "Define an explicit structure for command/event types in the SDK package of the API repo, then have Go, Java, and Core emit lists of expected and actual command/events as serialized non-determinism error details.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "During replay, workflow history (event ID 8) implies that a StartTimer command should have been emitted by the replayed code, but no such command was emitted.",
      "number": 559,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:57.920Z"
    },
    {
      "summary": "Feature request to add WorkflowIdConflictPolicy support in child workflow options across all SDKs. Currently, developers lack built-in support for handling workflow ID conflicts in child workflows, requiring complex workarounds and manual conflict resolution.",
      "category": "feature",
      "subcategory": "child-workflows",
      "apis": [
        "StartWorkflow",
        "WorkflowIdConflictPolicy",
        "ChildWorkflowOptions"
      ],
      "components": [
        "child-workflow-executor",
        "workflow-options",
        "conflict-resolution"
      ],
      "concepts": [
        "workflow-id-conflict",
        "child-workflows",
        "durable-execution",
        "failure-handling",
        "idempotency",
        "workflow-reuse"
      ],
      "severity": "high",
      "userImpact": "Developers must implement complex manual workarounds to handle workflow ID conflicts in child workflows, breaking the durable execution promise and increasing operational complexity.",
      "rootCause": "WorkflowIdConflictPolicy is not exposed in child workflow options, forcing developers to use activities or external state management for conflict resolution.",
      "proposedFix": "Add WorkflowIdConflictPolicy to child workflow options across all SDKs, allowing developers to specify conflict behavior (USE_EXISTING, FAIL, TERMINATE_EXISTING) natively.",
      "workaround": "Use activities with infinite retry and external workflow handles for conflict detection/termination, or maintain external state to track running workflows and manage cancellation manually.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        437,
        6799,
        2308
      ],
      "keyQuote": "This ultimately breaks the 'durable execution' promise: Failures happen. Temporal makes them irrelevant.",
      "number": 558,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:44.327Z"
    },
    {
      "summary": "Add support for setting a 'summary' metadata field on scheduled Nexus operations in workflows, similar to existing support for timers, child workflows, and activities.",
      "category": "feature",
      "subcategory": "nexus-operations",
      "apis": [],
      "components": [
        "nexus-operations",
        "workflow-execution",
        "metadata"
      ],
      "concepts": [
        "metadata",
        "nexus",
        "scheduled-operations",
        "workflow-context",
        "operation-tracking"
      ],
      "severity": "low",
      "userImpact": "Users cannot add summary metadata to Nexus operations, limiting observability and operational context compared to other scheduled operations.",
      "rootCause": null,
      "proposedFix": "Add an additional option to Nexus operations in workflows to set a summary field, consistent with timers, child workflows, and activities.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #610 by maintainer Sushisource",
      "related": [
        486,
        610
      ],
      "keyQuote": "Add a fixed \"summary\" metadata to scheduled Nexus operations like we have for timers, child workflows and activities.",
      "number": 557,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:41.463Z"
    },
    {
      "summary": "Feature request to allow the reset API to bring new signals as an atomic operation. This would enable use cases like skipping activities post-reset, selectively preserving specific signals, or notifying workflows they're in a reset state.",
      "category": "feature",
      "subcategory": "workflow-reset",
      "apis": [
        "ResetWorkflow"
      ],
      "components": [
        "reset-handler",
        "signal-processor",
        "workflow-execution"
      ],
      "concepts": [
        "atomic-operation",
        "signal-preservation",
        "workflow-state",
        "reset-behavior",
        "signal-filtering"
      ],
      "severity": "medium",
      "userImpact": "Users currently cannot selectively preserve signals during reset or inject signals atomically with reset, limiting their ability to handle complex reset scenarios.",
      "rootCause": null,
      "proposedFix": "Extend reset API to accept a list of signals to be delivered atomically as part of the reset operation, allowing workflows to adjust behavior accordingly.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1203
      ],
      "keyQuote": "allow reset API to bring a few new signals as atomic operation",
      "number": 553,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:42.384Z"
    },
    {
      "summary": "Feature request to auto-skip time when waiting on update results in time-skipping test environments, similar to existing behavior for workflow results. Team discussion concluded this approach is problematic due to race conditions and concurrent update execution, with focus shifting to alternative solutions like server-side time-skipping control or documentation.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "test-framework",
        "time-skipping",
        "update-handler",
        "workflow-executor"
      ],
      "concepts": [
        "time-skipping",
        "testing",
        "update-results",
        "race-conditions",
        "concurrent-execution"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows with updates in time-skipping environments cannot automatically skip time for update results, requiring manual control that may not cover all scenarios.",
      "rootCause": "Client-side time-skipping control creates race conditions between receiving update results and stopping time-skipping, and updates execute concurrently with other workflow activities making it unsafe to automatically skip time.",
      "proposedFix": "Either move time-skipping control to server-side handling, or document that users must manually control time-skipping based on their specific scenario needs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2283,
        1549,
        675,
        360
      ],
      "keyQuote": "this is problematic because the client is the one who says \"start/stop skipping time\", so there is a race between the client receiving the update result and time-skipping being stopped",
      "number": 551,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:27.421Z"
    },
    {
      "summary": "Allow replayers to execute queries at specific task boundaries (event numbers), enabling query execution at every task boundary during workflow replay.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replayer",
        "query-execution",
        "task-boundary"
      ],
      "concepts": [
        "replay",
        "query",
        "task-boundary",
        "event-number",
        "temporal-cli"
      ],
      "severity": "medium",
      "userImpact": "Users gain the ability to run queries at specific points during workflow replay, enabling more flexible testing and debugging of workflow executions.",
      "rootCause": null,
      "proposedFix": "Replayers should accept a query parameter and task boundary identifier to execute queries at specified event numbers or at every task boundary.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Replayers should allow users to provide a query and a certain task boundary to run it. Each query should effectively be a promise that is fulfilled during replay.",
      "number": 550,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:29.181Z"
    },
    {
      "summary": "Add workflow annotations for versioning-3 to mark workflows as pinned, preventing immediate migration to new versions and allowing short-running workflows to avoid patching when pinned. Requires language-specific annotations or a programmatic API invoked during the first workflow task.",
      "category": "feature",
      "subcategory": "versioning",
      "apis": [],
      "components": [
        "worker",
        "versioning-system",
        "workflow-executor",
        "workflow-annotation"
      ],
      "concepts": [
        "workflow-versioning",
        "pinning",
        "backward-compatibility",
        "worker-migration",
        "garbage-collection",
        "code-annotations"
      ],
      "severity": "high",
      "userImpact": "Allows short-running workflows marked as pinned to avoid patching when worker versions change, reducing maintenance burden for SDK users.",
      "rootCause": "Versioning-3 implementation lacks workflow annotation mechanism to mark pinned workflows, causing unnecessary immediate migration to new versions.",
      "proposedFix": "Implement language-specific code annotations where supported, with fallback to programmatic API invoked during first workflow task execution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Workflow annotations implemented across SDKs via language-specific decorators/attributes and programmatic APIs. All SDKs except PHP have linked PRs/issues.",
      "related": [
        1832,
        2458,
        889,
        1659,
        793,
        437,
        237,
        586
      ],
      "keyQuote": "short-running workflows, marked as pinned, do not need to get patched",
      "number": 548,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:28.454Z"
    },
    {
      "summary": "Implement calls to the new server-side ShutdownWorker API when workers shut down, with proper error handling to ignore unimplemented errors while logging other failures.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "ShutdownWorker"
      ],
      "components": [
        "worker",
        "shutdown-handler",
        "api-client"
      ],
      "concepts": [
        "graceful-shutdown",
        "server-api",
        "error-handling",
        "lifecycle-management",
        "multi-sdk-coordination"
      ],
      "severity": "medium",
      "userImpact": "Ensures proper worker cleanup and communication with the server during shutdown across all Temporal SDKs.",
      "rootCause": null,
      "proposedFix": "Call new ShutdownWorker API on worker shutdown, ignoring unimplemented errors and logging other errors.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across multiple SDKs (Go, Java, Core) with API and Server support; TypeScript, Python, .NET, Ruby, and PHP marked as N/A.",
      "related": [
        443,
        6511,
        1645,
        2236,
        822
      ],
      "keyQuote": "New server-side shutdown worker API is being made. Make sure to ignore unimplemented errors (and only log on any other errors).",
      "number": 542,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:14.186Z"
    },
    {
      "summary": "Python SDK is missing several metrics that are available in Java SDK. Out of 32 metrics, only 18 are currently available for Python, creating an incompleteness in the SDK's observability capabilities.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "python-sdk",
        "metrics",
        "observability"
      ],
      "concepts": [
        "metrics-parity",
        "observability",
        "sdk-consistency",
        "monitoring",
        "feature-completeness"
      ],
      "severity": "medium",
      "userImpact": "Python SDK users cannot access the full set of metrics available in Java, limiting their ability to monitor and observe Temporal workflow execution.",
      "rootCause": "Python SDK metrics implementation lags behind Java SDK, with only 18 out of 32 metrics currently implemented.",
      "proposedFix": "Implement all metrics available in Java SDK in the Python SDK to achieve feature parity.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as a duplicate of issue #607 in the temporalio-features repository.",
      "related": [
        607,
        796
      ],
      "keyQuote": "All the metrics available in Java are available in core/python.",
      "number": 539,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:15.674Z"
    },
    {
      "summary": "Allow SDKs to connect to multiple endpoints for Multi-region Namespaces and perform health checks on both endpoints. SDKs should dynamically route requests to the active endpoint based on namespace failover information from the Temporal server.",
      "category": "feature",
      "subcategory": "multi-region-failover",
      "apis": [],
      "components": [
        "client",
        "connection-pool",
        "health-check",
        "namespace-routing"
      ],
      "concepts": [
        "multi-region",
        "failover",
        "endpoint-discovery",
        "load-balancing",
        "health-check",
        "namespace-management"
      ],
      "severity": "high",
      "userImpact": "Enables Temporal Cloud customers with multi-region namespaces to automatically handle region failovers without manual worker reconfiguration, improving resilience during incidents.",
      "rootCause": "SDKs currently support only single-endpoint connections, requiring users to manually reconfigure workers when a namespace fails over to a standby region.",
      "proposedFix": "Implement per-region endpoint support in SDKs with three key features: (1) connect to multiple endpoints per namespace, (2) route requests to active endpoint based on namespace info from server, (3) health check both endpoints to prevent post-failover connection errors.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDKs to natively handle failovers instead of relying on manual user setup",
      "number": 538,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:12.367Z"
    },
    {
      "summary": "Add support for bidirectional linking of workflows started from activities, allowing users to maintain the relationship between parent and child workflows when starting them via activity clients instead of child workflows. Links should be established in activity completion events and support signals/updates as well.",
      "category": "feature",
      "subcategory": "workflow-linking",
      "apis": [
        "RespondActivityTaskCompleted",
        "RespondActivityTaskCompletedById"
      ],
      "components": [
        "activity-executor",
        "workflow-engine",
        "history-events",
        "nexus-integration"
      ],
      "concepts": [
        "workflow-linking",
        "history-events",
        "bidirectional-references",
        "child-workflows",
        "activity-client",
        "workflow-relationships"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to maintain relationship tracking between parent and child workflows started from activities, improving workflow visibility and debugging.",
      "rootCause": null,
      "proposedFix": "Extend history event linking mechanism (added for Nexus) to support links in activity completion events (RespondActivityTaskCompleted/RespondActivityTaskCompletedById APIs), with configuration to limit links per activity and optional automatic linking when using client from activity.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        203
      ],
      "keyQuote": "Links are bidirectional, which means the local activity marker event or ActivityTaskCompleted events should include a link back from any Temporal primitives initiated by the activity.",
      "number": 534,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:01.691Z"
    },
    {
      "summary": "The features repository has hardcoded dynamic config values in run.go and a separate docker.yaml file. This issue requests consolidating these into a single YAML configuration file to ensure consistency and allow the server team to reference the same options for nightly pipeline testing.",
      "category": "feature",
      "subcategory": "test-configuration",
      "apis": [],
      "components": [
        "embedded-server",
        "docker-configuration",
        "dynamic-config"
      ],
      "concepts": [
        "configuration-management",
        "centralization",
        "testing-infrastructure",
        "consistency",
        "yaml-configuration",
        "server-setup"
      ],
      "severity": "medium",
      "userImpact": "Developers and server operators can use a single, consistent dynamic config file for both local testing and CI/nightly pipeline environments.",
      "rootCause": null,
      "proposedFix": "Consolidate hardcoded dynamic config values from run.go and docker.yaml into a single YAML configuration file that both the embedded server and Docker-based testing can reference.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed after consolidating the dynamic configuration into a single file format.",
      "related": [],
      "keyQuote": "We should use one file, I suppose keep the yaml format, so that we always use the same options.",
      "number": 529,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:06:00.300Z"
    },
    {
      "summary": "Add support for describing task queues with stats from the high-level client. The feature requires a new describe call that returns task queue information including pollers and statistics, with configurable options for reporting stats and poller info.",
      "category": "feature",
      "subcategory": "task-queue-management",
      "apis": [
        "DescribeTaskQueue"
      ],
      "components": [
        "task-queue-client",
        "high-level-api",
        "stats-reporting"
      ],
      "concepts": [
        "task-queue-description",
        "poller-info",
        "build-id-stats",
        "task-queue-types",
        "server-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Enables developers to monitor and analyze task queue performance and poller distribution from the high-level client API.",
      "rootCause": null,
      "proposedFix": "Implement describe task queue call with options for stats and poller reporting, returning task queue types (worker, activity, nexus) with associated info including pollers and stats, compatible with Temporal Server 1.25+",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1553
      ],
      "keyQuote": "describe task queue from the high-level client and access stats information. This information is only available in server 1.25.",
      "number": 525,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:58.422Z"
    },
    {
      "summary": "Align local_activity_ metrics in Core with Go and Java SDKs by making them separate from activity_ metrics by default, with an opt-in option to revert to current behavior. All Core-based SDKs must expose this option and include clear release notes about the metric behavior change.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "core",
        "sdk-wrappers"
      ],
      "concepts": [
        "metrics",
        "local-activity",
        "activity",
        "sdk-alignment",
        "behavioral-change",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users will see local_activity_ metrics separated from activity_ metrics by default in Core-based SDKs, with an option to maintain previous behavior.",
      "rootCause": "Core combines local_activity_ and activity_ metrics while Go and Java keep them separate, causing inconsistency across SDKs.",
      "proposedFix": "Align Core's metric behavior with Go and Java by default, provide opt-in for previous behavior, ensure all Core-based SDKs expose the option, and document the change in release notes.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was accepted and tracked across SDKs (Core, TypeScript, Python, .NET) with implementation status tracked via checkbox list.",
      "related": [
        796
      ],
      "keyQuote": "Align local_activity_ metrics in Core with Go and Java by default. Have an opt-in option that can be set to revert to today's behavior.",
      "number": 522,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:45.818Z"
    },
    {
      "summary": "Add feature tests for .NET HTTP proxy support following the implementation in sdk-dotnet#318. Tests needed for both basic HTTP proxy and HTTP proxy authentication scenarios.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "http-proxy",
        "client",
        "test-framework",
        "dotnet-sdk"
      ],
      "concepts": [
        "http-proxy",
        "authentication",
        "client-configuration",
        "feature-testing",
        "proxy-support"
      ],
      "severity": "medium",
      "userImpact": "Users need comprehensive feature tests to validate HTTP proxy functionality works correctly in .NET SDK implementations.",
      "rootCause": null,
      "proposedFix": "Create feature tests in the features repository for http_proxy and http_proxy_auth directories to match the .NET SDK implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tests were implemented and committed at commit 2376f0dcde96dabe2ffb6dfcd8c9a1c86d72b0a9",
      "related": [
        318
      ],
      "keyQuote": "Need tests at https://github.com/temporalio/features/tree/main/features/client/http_proxy and http_proxy_auth now that sdk-dotnet#318 has landed.",
      "number": 521,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:43.798Z"
    },
    {
      "summary": "Request for easier signal handler upgrades in long-running workflows. Currently, workflow.GetVersion locks into a specific behavior, but users want a way to upgrade signal handler code so new signals use the latest version while replaying history with the version used at that time.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "GetVersion"
      ],
      "components": [
        "workflow-engine",
        "signal-handler",
        "versioning-system"
      ],
      "concepts": [
        "backwards-compatibility",
        "workflow-upgrade",
        "signal-processing",
        "history-replay",
        "version-management"
      ],
      "severity": "medium",
      "userImpact": "Users managing long-running workflows with signal handlers cannot safely upgrade handler code without locking into specific behavior versions.",
      "rootCause": "GetVersion always returns the same value throughout workflow execution, preventing selective version upgrades for specific code paths like signal handlers.",
      "proposedFix": "Introduce an alternative GetVersion that switches to the latest version once history replay completes, or similar solution allowing version flexibility for specific handlers.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #591 which has more concrete thinking around this feature.",
      "related": [
        591
      ],
      "keyQuote": "It would be great if there was an alternative GetVersion, which would switch to the latest version once the history has been replayed",
      "number": 518,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:47.141Z"
    },
    {
      "summary": "Request to expose start delay option for child workflows to match client workflow functionality. This would allow delayed child workflow execution without requiring long timers at the top level, preserving parent-child relationships and UI traceability.",
      "category": "feature",
      "subcategory": "child-workflow-options",
      "apis": [
        "StartChildWorkflow",
        "ChildWorkflowOptions"
      ],
      "components": [
        "child-workflow-executor",
        "workflow-options",
        "api-server"
      ],
      "concepts": [
        "start-delay",
        "child-workflow",
        "delayed-execution",
        "workflow-traceability",
        "history-compatibility",
        "feature-parity"
      ],
      "severity": "medium",
      "userImpact": "Users cannot delay child workflow execution without workarounds that lose parent-child relationships and UI traceability.",
      "rootCause": null,
      "proposedFix": "Expose start delay in child workflow options across API, server, and all SDKs.",
      "workaround": "Starting workflows from an activity instead of as child workflows, though this loses parent-child relationship and traceability.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This can be done today by starting the workflow from an activity but that loses the parent-child relationship and traceability in the UI.",
      "number": 515,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:30.498Z"
    },
    {
      "summary": "Add support for updating search attributes on schedules during schedule update operations. This feature allows schedules to have their search attributes modified, similar to how workflow start actions could be updated.",
      "category": "feature",
      "subcategory": "schedule-management",
      "apis": [
        "UpdateSchedule"
      ],
      "components": [
        "schedule-service",
        "search-attributes",
        "schedule-update"
      ],
      "concepts": [
        "schedule-updates",
        "search-attributes",
        "metadata-management",
        "schedule-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to update search attributes on existing schedules without having to recreate them.",
      "rootCause": null,
      "proposedFix": "Add search attribute update capability to schedule update API calls across all SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1561,
        2152,
        1475,
        594,
        314,
        478,
        629
      ],
      "keyQuote": "Schedules can have their search attributes updated... We need to make sure they can be updated in schedule update calls.",
      "number": 512,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:30.773Z"
    },
    {
      "summary": "Users cannot replay workflows past the last WORKFLOW_TASK_COMPLETED event, making it difficult to debug workflow task failures. The feature request asks for replay capability beyond the last successful task completion.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replayer",
        "workflow-task",
        "history"
      ],
      "concepts": [
        "replay",
        "debugging",
        "workflow-task-completion",
        "history",
        "failure-analysis"
      ],
      "severity": "medium",
      "userImpact": "Users cannot effectively debug workflow task failures without the ability to replay past the last successful task completion.",
      "rootCause": "The replayer is limited to replaying only tasks with associated WORKFLOW_TASK_COMPLETED events in the history.",
      "proposedFix": "Extend replay capability to work past the last workflow task completion, potentially adjusting the isReplaying flag behavior and handling commands generated after history ends.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Make it possible to \"replay\" past the last workflow task completion.",
      "number": 506,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:32.811Z"
    },
    {
      "summary": "Add support for the `query` option when listing schedules across all SDKs, matching the existing functionality available for listing workflows.",
      "category": "feature",
      "subcategory": "schedule-management",
      "apis": [
        "ListSchedules"
      ],
      "components": [
        "schedule-client",
        "query-filter",
        "list-schedules"
      ],
      "concepts": [
        "querying",
        "filtering",
        "schedule-listing",
        "search",
        "cross-sdk-feature"
      ],
      "severity": "medium",
      "userImpact": "Users can filter schedules by query parameters when listing, enabling more efficient schedule discovery and management across SDKs.",
      "rootCause": null,
      "proposedFix": "Implement query parameter support in ListSchedules API across all SDK implementations (Go, Java, TypeScript, Python, .NET, PHP) to match workflow listing functionality.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented across SDKs with tracking tickets completed for Go, Java, TypeScript, Python, .NET, and CLI; PHP implementation pending.",
      "related": [
        1539,
        2139,
        1457,
        573,
        300,
        472,
        616
      ],
      "keyQuote": "Need to support the `query` option when listing schedules same as we do when listing workflows.",
      "number": 505,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:17.215Z"
    },
    {
      "summary": "Child workflows started via CAN (continue as new) do not receive explicit cancel and signal requests from parent workflows, even though they should propagate through the child chain. The server should treat run_id with child_workflow_only flag the same way as first_execution_run_id in client APIs.",
      "category": "bug",
      "subcategory": "child-workflows",
      "apis": [
        "RequestCancelExternalWorkflowExecution",
        "SignalExternalWorkflow"
      ],
      "components": [
        "workflow-execution",
        "child-workflow-handler",
        "cancellation-logic",
        "signal-propagation"
      ],
      "concepts": [
        "child-workflows",
        "continue-as-new",
        "cancellation",
        "signal-propagation",
        "workflow-hierarchy",
        "run-id",
        "parent-close-policy"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably cancel or signal child workflows after a child has executed continue-as-new, breaking expected behavior for workflow orchestration patterns.",
      "rootCause": "Server does not treat RequestCancelExternalWorkflowExecutionCommandAttributes with run_id and child_workflow_only=true the same way as first_execution_run_id, preventing propagation to child-of-child workflows.",
      "proposedFix": "Server should treat run_id with child_workflow_only=true identically to first_execution_run_id in client APIs to propagate cancellations and signals through the child workflow chain.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "One would reasonably expect Workflow B to receive the cancellation (same for signals). In fact, this is what indeed happens _after the parent workflow closes_",
      "number": 503,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:17.519Z"
    },
    {
      "summary": "Add warnings when activities dangle (remain unresolved) after a workflow closes or continues as new, similar to existing warnings for signals and updates. The request also suggests considering similar warnings for child workflows, external signals, nexus, and other async operations that should not be abandoned.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-executor",
        "activity-manager",
        "async-handler"
      ],
      "concepts": [
        "dangling-activities",
        "resource-cleanup",
        "warning-system",
        "workflow-termination",
        "async-abandonment",
        "user-guidance"
      ],
      "severity": "medium",
      "userImpact": "Users will receive warnings when activities dangle after workflow closure, helping prevent silent failures and resource leaks from abandoned async operations.",
      "rootCause": null,
      "proposedFix": "Implement a warning system similar to existing signal/update dangle warnings for activities, and extend to child workflows, external signals, nexus, and other async operations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We're adding warnings when signals and updates dangle after the workflow closes or continues as new. We should consider providing a similar warning when activities dangle.",
      "number": 501,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:19.212Z"
    },
    {
      "summary": "Cross-SDK feature for deterministic, reentrant concurrency control (mutex/semaphore) designed to work within workflow coroutines, signal handlers, and update handlers.",
      "category": "feature",
      "subcategory": "concurrency-control",
      "apis": [],
      "components": [
        "workflow-coroutine",
        "signal-handler",
        "update-handler",
        "concurrency-primitives"
      ],
      "concepts": [
        "mutex",
        "semaphore",
        "concurrency-control",
        "reentrancy",
        "determinism",
        "workflow-safe"
      ],
      "severity": "medium",
      "userImpact": "Users can now safely synchronize access to shared state within workflows across multiple coroutines using language-appropriate concurrency primitives.",
      "rootCause": null,
      "proposedFix": "Implement workflow-friendly mutex/semaphore mechanisms across all SDKs (PHP, TypeScript, Go, Java, .NET, Python) that are reentrant and deterministic.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented across all six SDKs as indicated by the completed checkboxes for PHP (#462), TypeScript (#1446), Go (#1521), Java (#2116), .NET (#281), and Python (#554).",
      "related": [
        462,
        1446,
        1521,
        2116,
        281,
        554
      ],
      "keyQuote": "We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.",
      "number": 500,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:02.819Z"
    },
    {
      "summary": "Request to add warnings or errors when update handlers are not properly awaited and dangle across cancellation or workflow exit points, preventing resource leaks and unhandled state changes.",
      "category": "feature",
      "subcategory": "update-handlers",
      "apis": [],
      "components": [
        "update-handler",
        "workflow-execution",
        "cancellation"
      ],
      "concepts": [
        "dangling-handlers",
        "resource-cleanup",
        "workflow-exit",
        "cancellation",
        "error-handling",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Users may inadvertently create update handlers that dangle across cancellation or workflow exit, leading to unhandled state changes and resource leaks.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1499,
        2090,
        1434,
        538,
        261,
        446
      ],
      "keyQuote": "Warn or error when update handlers dangle across CAN or workflow exit",
      "number": 499,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:02.425Z"
    },
    {
      "summary": "Request to enable listing and filtering workflows based on current failures, allowing batch operations like reset or pause on workflows matching specific failure patterns. Proposes adding search attributes to track failures such as activity retry counts, error types, and stuck duration.",
      "category": "feature",
      "subcategory": "workflow-visibility",
      "apis": [],
      "components": [
        "workflow-visibility",
        "search-attributes",
        "failure-tracking",
        "batch-operations"
      ],
      "concepts": [
        "workflow-failure",
        "search-filtering",
        "batch-operations",
        "failure-patterns",
        "stuck-workflows",
        "activity-retry",
        "task-failure"
      ],
      "severity": "medium",
      "userImpact": "Users cannot efficiently query and bulk-operate on workflows experiencing specific failure patterns, requiring manual identification for batch operations.",
      "rootCause": null,
      "proposedFix": "Write search attributes when certain conditions are met (e.g., > N retries of an activity or task failure, or workflow stuck for certain time), capturing activity type and error class information.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Perhaps you could write a search attribute when certain conditions are met, such as > N retries of an activity or task failure, or when the workflow has been stuck for a certain amount of time.",
      "number": 498,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:05:04.726Z"
    },
    {
      "summary": "Feature request to add easy search attribute registration to the dev server via CLI, with SDK implementations needed across TypeScript, Go, and other languages. This is a cross-SDK initiative with per-language tracking tickets.",
      "category": "feature",
      "subcategory": "dev-server-search-attributes",
      "apis": [],
      "components": [
        "dev-server",
        "cli",
        "test-server",
        "search-attributes"
      ],
      "concepts": [
        "development-tools",
        "testing",
        "search-attributes",
        "operator-service",
        "cli-commands",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users need easier ways to register search attributes in the dev server without manual configuration, improving developer experience during testing and development.",
      "rootCause": null,
      "proposedFix": "Add CLI flags for dev server easy search attribute registration; SDK implementations should expose search attribute options that translate to operator service calls for test servers.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1523,
        1447,
        558,
        282,
        465,
        206,
        6475
      ],
      "keyQuote": "CLI dev server easy search attribute registration via CLI. Languages using CLI dev server expose search attribute option",
      "number": 494,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:49.649Z"
    },
    {
      "summary": "Add comprehensive feature tests across all SDKs for the Update + Workflow Reset functionality, including tests for reapplied updates being accepted/rejected after reset and updates reapplied before completion.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "Update",
        "WorkflowReset"
      ],
      "components": [
        "test-framework",
        "workflow-reset",
        "update-handler"
      ],
      "concepts": [
        "update",
        "workflow-reset",
        "reapply",
        "feature-tests",
        "sdk-parity"
      ],
      "severity": "medium",
      "userImpact": "Users need reliable tests to verify Update + Workflow Reset behavior works correctly across all SDKs.",
      "rootCause": null,
      "proposedFix": "Create feature tests in the features repo covering: reapplied update acceptance/rejection after reset, and update reapplication before completion.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add feature tests in this repo for all SDKs for Update + Workflow Reset. Should include the reapplied update being accepted and rejected after reset as well as the update being reapplied before completion.",
      "number": 492,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:51.373Z"
    },
    {
      "summary": "Request for a sample demonstrating per-workflow interceptor configuration. Currently, interceptors are registered globally at the worker factory level, but users need the ability to apply different interceptor behavior to specific workflows or subsets of workflows.",
      "category": "docs",
      "subcategory": "interceptors",
      "apis": [],
      "components": [
        "interceptor",
        "worker",
        "workflow-execution"
      ],
      "concepts": [
        "conditional-logic",
        "workflow-filtering",
        "configuration-patterns",
        "task-queue-routing",
        "namespace-isolation"
      ],
      "severity": "low",
      "userImpact": "Developers who need different interceptor behavior for different workflows lack clear documentation on how to implement this using existing conditional logic.",
      "rootCause": "Lack of sample code showing how to use interceptor conditions (workflow type, task queue, namespace, workflow ID prefix) to achieve per-workflow behavior.",
      "proposedFix": "Create a sample showing how to conditionally apply interceptor logic based on workflow type or other discriminators.",
      "workaround": "Implement conditional logic within the interceptor itself to check workflow type, task queue, namespace, or workflow ID prefix and apply different behavior accordingly.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If a sample is needed to show how to only do something in an interceptor based on a certain condition, we can show that.",
      "number": 489,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:51.017Z"
    },
    {
      "summary": "GetWorkflowHistory can return a single page of history that exceeds gRPC payload limits (e.g., 4MB), putting workflows into an unrecoverable state. The request seeks solutions such as smaller pagination or a payload store.",
      "category": "feature",
      "subcategory": "workflow-history",
      "apis": [
        "GetWorkflowHistory"
      ],
      "components": [
        "workflow-history",
        "grpc",
        "pagination",
        "payload-handling"
      ],
      "concepts": [
        "payload-size",
        "pagination",
        "grpc-limits",
        "large-payloads",
        "history-retrieval",
        "error-recovery"
      ],
      "severity": "high",
      "userImpact": "Users with large workflow history payloads can encounter unrecoverable workflow states when history pages exceed gRPC limits, blocking workflow access and management.",
      "rootCause": "GetWorkflowHistory returns unbounded page sizes that can exceed gRPC payload limits when history contains large payloads like activity arguments.",
      "proposedFix": "Implement pagination through smaller pages if size problem detected, or implement a payload store to decouple history size from gRPC limits.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A workflow page with large payloads can exceed the GRPC limit...it could be larger than that limit. This gets the workflow into a state that's difficult-to-impossible to recover from.",
      "number": 487,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:34.540Z"
    },
    {
      "summary": "Feature request to add user-provided metadata that's visible in UI/CLI for workflows, including static metadata at workflow start, updateable current details, metadata queries with signal/query/update information, and metadata for timers and activities.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [
        "StartWorkflow",
        "Signal",
        "Query",
        "Update"
      ],
      "components": [
        "workflow-execution",
        "metadata-storage",
        "query-handler",
        "ui-cli"
      ],
      "concepts": [
        "metadata",
        "visibility",
        "workflow-description",
        "signal-registration",
        "query-registration",
        "update-registration"
      ],
      "severity": "high",
      "userImpact": "Users can now provide custom metadata visible in UI/CLI to better identify and track workflows, timers, and activities with descriptive information.",
      "rootCause": null,
      "proposedFix": "Implement metadata fields including static summary/details on workflow start, updateable current details, metadata query API, and metadata for timers and activities. Text format to use mini markdown.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        51,
        1565,
        1673,
        2216,
        335,
        2268,
        830,
        1544,
        670,
        359,
        217,
        517,
        690,
        371,
        5857,
        6412,
        6413
      ],
      "keyQuote": "Users need to provide certain bits of user metadata that is visible in the UI/CLI.",
      "number": 486,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:36.587Z"
    },
    {
      "summary": "Create a common SDK exception for workflow updates that wraps gRPC CANCELED and DEADLINE_EXCEEDED status codes, representing RPC timeout or cancellation rather than update-specific timeout.",
      "category": "feature",
      "subcategory": "workflow-updates",
      "apis": [
        "StartUpdate",
        "PollUpdateAsync"
      ],
      "components": [
        "update-client",
        "grpc-error-handling",
        "exception-mapping"
      ],
      "concepts": [
        "timeout",
        "cancellation",
        "rpc-errors",
        "exception-wrapping",
        "error-handling",
        "cross-language-consistency"
      ],
      "severity": "medium",
      "userImpact": "Developers will have a consistent, language-specific exception to catch when workflow updates fail due to RPC timeout or cancellation, improving error handling across all SDKs.",
      "rootCause": "gRPC status codes (CANCELED, DEADLINE_EXCEEDED) from update operations need to be wrapped in SDK-level exceptions for better developer ergonomics and consistency.",
      "proposedFix": "Add WorkflowUpdateRPCTimeoutOrCanceled exception in each SDK that inherits from a base RPCTimeoutOrCanceled exception when possible, thrown when start/poll update returns Canceled or DeadlineExceeded status.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented WorkflowUpdateRPCTimeoutOrCanceled exception across SDKs to wrap gRPC timeout/cancel errors, with base class inheritance where supported by the language.",
      "related": [
        1479,
        2069,
        1422,
        529,
        250,
        436
      ],
      "keyQuote": "Have a new `WorkflowUpdateRPCTimeoutOrCanceled` exception/error in every language... thrown when start update or poll for update returns either `Canceled` or `DeadlineExceeded` status codes",
      "number": 483,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:38.811Z"
    },
    {
      "summary": "Clarify and standardize how SDKs handle exceptions when both workflow functions and signal handlers throw exceptions in the same task, determining precedence and consistency across implementations.",
      "category": "feature",
      "subcategory": "signal-handling",
      "apis": [],
      "components": [
        "signal-handler",
        "workflow-execution",
        "error-handling"
      ],
      "concepts": [
        "exception-precedence",
        "signal-processing",
        "failure-handling",
        "task-execution",
        "error-semantics"
      ],
      "severity": "medium",
      "userImpact": "Users need clear, consistent behavior across SDKs when both workflow and signal handler exceptions occur simultaneously to avoid unpredictable failure behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        481
      ],
      "keyQuote": "Currently exceptions in signal handlers are treated as if they were thrown in the main workflow function. But what happens when workflow function and signal handler both throw an exception in the same task?",
      "number": 482,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:14.359Z"
    },
    {
      "summary": "Core-based SDKs currently set workflow completion immediately upon return and discard post-completion commands, unlike Go/Java SDKs which allow coroutines to settle first. This issue proposes adopting the Go/Java behavior to handle post-completion commands correctly using SDK flags for backwards compatibility.",
      "category": "feature",
      "subcategory": "workflow-completion",
      "apis": [],
      "components": [
        "workflow-executor",
        "command-buffer",
        "coroutine-manager"
      ],
      "concepts": [
        "workflow-completion",
        "post-completion-commands",
        "backwards-compatibility",
        "SDK-flags",
        "coroutine-settlement",
        "command-handling"
      ],
      "severity": "medium",
      "userImpact": "Users may lose post-completion commands in core-based SDKs, whereas Go/Java SDKs properly handle them, creating inconsistent behavior across SDKs.",
      "rootCause": "Core-based SDKs discard post-completion commands instead of allowing all coroutines to settle before marking workflow as complete.",
      "proposedFix": "Implement Option 1: Store workflow result and buffer commands on return, then on completion with settled coroutines, conditionally set SDK flag and reorder completion command to end.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        778,
        1421,
        528,
        249,
        305
      ],
      "keyQuote": "In Go/Java, we let the coroutines all complete even if they make commands and then set workflow completion _after_ that. We should do the same in core-based SDKs.",
      "number": 481,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:23.466Z"
    },
    {
      "summary": "Add namespace validation on worker startup by calling describe namespace to ensure the user has access to the namespace and it exists. This is a consistency enhancement across SDKs, with Go already implemented and Java needing completion.",
      "category": "feature",
      "subcategory": "worker-initialization",
      "apis": [
        "DescribeNamespace"
      ],
      "components": [
        "worker",
        "initialization",
        "namespace-validation",
        "client"
      ],
      "concepts": [
        "namespace-access",
        "validation",
        "startup-check",
        "error-handling",
        "configuration",
        "authentication"
      ],
      "severity": "medium",
      "userImpact": "Users will get early feedback if they lack namespace access or the namespace doesn't exist, preventing silent failures later.",
      "rootCause": null,
      "proposedFix": "Call describe namespace API during worker initialization",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2060,
        738
      ],
      "keyQuote": "Worker start should call describe namespace on start just to make sure user has access to the namespace and that it exists.",
      "number": 477,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:04:10.652Z"
    },
    {
      "summary": "Add a Temporal-Namespace header (gRPC metadata) to every namespace-specific gRPC request across all SDKs. This requires extracting the namespace from request objects and setting it via interceptors, with validation to ensure new RPCs don't miss this header.",
      "category": "feature",
      "subcategory": "grpc-metadata",
      "apis": [],
      "components": [
        "grpc-client",
        "interceptors",
        "request-handling"
      ],
      "concepts": [
        "namespace-isolation",
        "grpc-metadata",
        "cross-namespace-calls",
        "header-extraction",
        "future-proofing"
      ],
      "severity": "medium",
      "userImpact": "Ensures proper namespace context is propagated in gRPC requests, improving request routing and isolation across Temporal clients.",
      "rootCause": "gRPC requests were not consistently including namespace metadata, requiring a standardized approach across all SDKs.",
      "proposedFix": "Use SDK-specific interceptors to extract namespace from request objects (interface assertion in Go, reflection in Java, etc.) and set temporal-namespace header on all requests.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across all SDKs with per-SDK solutions appropriate to each language's capabilities.",
      "related": [
        1458,
        2058,
        736,
        1697
      ],
      "keyQuote": "Every gRPC request that contains a namespace should have a `Temporal-Namespace` header set on the request with the namespace value.",
      "number": 475,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:59.465Z"
    },
    {
      "summary": "Feature request to add support for failing tests when workflow task failures occur in TestWorkflowEnvironment. Needs clarification on scope (SDK coverage) and whether this should be a worker option rather than environment configuration.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-environment",
        "worker",
        "workflow-task-handler"
      ],
      "concepts": [
        "testing",
        "failure-handling",
        "task-execution",
        "test-configuration",
        "worker-options"
      ],
      "severity": "medium",
      "userImpact": "Test authors cannot currently fail tests when workflow tasks fail, making it difficult to validate error handling in tests.",
      "rootCause": null,
      "proposedFix": "Implement a worker option (potentially also available through TestWorkflowEnvironment) to fail tests on workflow task failures, with clarification on SDK scope.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        322
      ],
      "keyQuote": "Feature request to fail tests on workflow task failures.",
      "number": 472,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:55.754Z"
    },
    {
      "summary": "Users need the ability to update TLS certificates for a running worker without requiring a shutdown. This is a cross-SDK feature request to enable certificate rotation on active worker instances.",
      "category": "feature",
      "subcategory": "tls-certificate-management",
      "apis": [],
      "components": [
        "worker",
        "tls-client",
        "connection-management"
      ],
      "concepts": [
        "certificate-rotation",
        "tls-security",
        "runtime-updates",
        "connection-refresh",
        "zero-downtime"
      ],
      "severity": "medium",
      "userImpact": "Users currently cannot update TLS certificates without shutting down their workers, preventing certificate rotation and renewal without service disruption.",
      "rootCause": null,
      "proposedFix": "Implement worker client replacement capability or certificate update mechanism across SDKs (already supported in Go and Java via client replacement in Core SDK).",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #11",
      "related": [
        11,
        1412,
        513,
        235
      ],
      "keyQuote": "Users need to be able to change TLS certificate for a running worker without shutting the worker down",
      "number": 471,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:56.710Z"
    },
    {
      "summary": "Add CI tests across SDKs to verify that dev-server and test-server processes are properly shut down when requested. Various reports indicate processes are not being killed on shutdown across different languages and OS/arch combinations.",
      "category": "feature",
      "subcategory": "test-infrastructure",
      "apis": [],
      "components": [
        "dev-server",
        "test-server",
        "subprocess-management",
        "process-lifecycle"
      ],
      "concepts": [
        "process-termination",
        "cleanup",
        "resource-management",
        "ci-testing",
        "cross-platform",
        "shutdown-verification"
      ],
      "severity": "medium",
      "userImpact": "Improper shutdown of dev/test servers can cause resource leaks, port binding issues, and test failures across SDKs on different operating systems.",
      "rootCause": null,
      "proposedFix": "Add CI tests for all SDKs with subprocess management to confirm that after shutdown the PID is gone.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        731
      ],
      "keyQuote": "Various reports in various languages and across different OS/arch combinations are reporting that the process is not killed upon shutdown.",
      "number": 470,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:44.134Z"
    },
    {
      "summary": "The start_update API is synchronous and blocks waiting for the remote worker to accept the update, which misleads users into thinking it's fully asynchronous like start_activity and start_workflow. Users should be forced to explicitly specify what stage they're waiting for (ACCEPTED or COMPLETED) to make the blocking behavior clear.",
      "category": "feature",
      "subcategory": "updates-api",
      "apis": [
        "StartUpdate"
      ],
      "components": [
        "update-handler",
        "worker",
        "client"
      ],
      "concepts": [
        "synchronous-blocking",
        "worker-availability",
        "async-semantics",
        "explicit-configuration",
        "durable-execution"
      ],
      "severity": "medium",
      "userImpact": "Users may unknowingly create dependencies on remote worker availability, potentially causing outages in critical services.",
      "rootCause": "The API defaults to synchronous behavior (waiting for worker acceptance) without requiring explicit configuration, making the blocking nature non-obvious.",
      "proposedFix": "Force customers to explicitly pass a wait_for_stage flag (ACCEPTED/COMPLETED) when calling start_update, and clarify in comments that the remote worker must be present.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented required wait_for_stage flag across SDKs to make synchronous behavior explicit.",
      "related": [
        431,
        432,
        1449,
        2045,
        1403,
        514,
        231,
        426,
        597
      ],
      "keyQuote": "force customers to explicitly pass in a flag saying what's being awaited",
      "number": 469,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:43.539Z"
    },
    {
      "summary": "Users need a standardized utility across all Temporal SDKs to decode all payloads in a history object. Currently only Go and Ruby have this functionality exposed through payload visitors, and other SDKs lack this capability.",
      "category": "feature",
      "subcategory": "payload-decoding",
      "apis": [
        "VisitPayloads"
      ],
      "components": [
        "payload-codec",
        "history-decoder",
        "sdk-utilities"
      ],
      "concepts": [
        "payload-decoding",
        "history-traversal",
        "encryption",
        "cross-sdk-consistency",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Users across different SDKs lack a consistent and accessible way to decode all payloads in a history object, limiting their ability to inspect and work with encrypted data.",
      "rootCause": null,
      "proposedFix": "Expose a payload visitor or create a more specific decode-history method as a utility across all SDKs (Go, Java, TypeScript, Python, .NET, Ruby, PHP, and Temporal CLI).",
      "workaround": "Go and Ruby users can access existing VisitPayloads/PayloadVisitor APIs, though they are not prominently exposed in the SDK documentation.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users need to decode all payloads in a history object. This could be exposed as a payload visitor or as a more specific decode-history method.",
      "number": 468,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:41.610Z"
    },
    {
      "summary": "Updates getting dropped after continue-as-new in workflows. The issue occurs when near-simultaneous updates race with workflow continuation, and the SDK doesn't prevent or clearly inform users about this behavior. Users need better SDK support or facilities to track outstanding updates.",
      "category": "feature",
      "subcategory": "updates-continue-as-new",
      "apis": [],
      "components": [
        "workflow-execution",
        "update-handler",
        "signal-update-serialization"
      ],
      "concepts": [
        "continue-as-new",
        "update-delivery",
        "race-condition",
        "workflow-continuation",
        "external-signals",
        "serialization"
      ],
      "severity": "medium",
      "userImpact": "Users experience dropped updates when using continue-as-new, requiring complex manual workarounds to track outstanding updates and avoid data loss.",
      "rootCause": "Updates are not serialized relative to workflow continuation and other concurrent operations (signals, updates, workflow code), causing race conditions.",
      "proposedFix": "SDK should either prevent updates from being dropped after continue-as-new or provide built-in facilities to track outstanding updates so users can wait for them before continuation.",
      "workaround": "Manually track running updates with a counter (num_running_updates) and wait for it to reach zero before continue-as-new using wait_condition.",
      "resolution": "fixed",
      "resolutionDetails": "Partially addressed through the addition of mutexes to serialize updates and prevent races.",
      "related": [],
      "keyQuote": "I don't have a specific solution in mind, but I'd ideally like the SDK to prevent this from happening, or at least inform me that it is happening",
      "number": 467,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:29.786Z"
    },
    {
      "summary": "Users need better logging context to identify which handler (update, signal, query) is executing and the update ID, making it easier to debug and correlate logs with specific operations in production environments.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logger",
        "update-handler",
        "signal-handler",
        "query-handler"
      ],
      "concepts": [
        "logging-context",
        "observability",
        "debugging",
        "handler-identification",
        "update-id",
        "tracing"
      ],
      "severity": "medium",
      "userImpact": "Users struggle to identify which handler executed in logs and cannot easily grep for specific update/signal/query invocations, complicating production debugging.",
      "rootCause": "SDK loggers do not include handler type and update ID in the logging context by default, requiring manual workarounds.",
      "proposedFix": "Add handler type and update ID to the logging context implicitly across all SDKs in a language-idiomatic way (e.g., contextvars in Python, scoped loggers in other languages).",
      "workaround": "Users can manually add handler information to logs using language-specific mechanisms like Python's `extra` parameter or creating custom logger adapters.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented across all SDKs to include handler context and update ID in logging.",
      "related": [
        1648,
        351,
        648,
        1532,
        2237,
        512
      ],
      "keyQuote": "I'd love if the context or prefix listed which handler it's in somehow and perhaps whether it was a signal/update/query. In the case of an update, I'd like to see the update ID.",
      "number": 466,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:28.540Z"
    },
    {
      "summary": "Feature request to add SDK samples demonstrating how to replace mTLS certificates at runtime without application restart. Useful for certificate rotation and updates in production environments.",
      "category": "feature",
      "subcategory": "sample-code",
      "apis": [],
      "components": [
        "sample-code",
        "mTLS",
        "certificate-management",
        "client-configuration"
      ],
      "concepts": [
        "certificate-rotation",
        "mTLS",
        "client-replacement",
        "runtime-updates",
        "zero-downtime-deployment"
      ],
      "severity": "medium",
      "userImpact": "Customers need guidance on rotating mTLS certificates in production without restarting applications, impacting operational continuity.",
      "rootCause": null,
      "proposedFix": "Add sample code to each SDK's sample repository demonstrating certificate replacement patterns, with language-specific variations (e.g., Python uses full client replacement on Worker).",
      "workaround": "For Python SDK, full client replacement can be set via the `client` property setter on the `Worker`.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        11
      ],
      "keyQuote": "Add samples to each SDKs sample repo showing how to replace certificates without restarting the application.",
      "number": 464,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:30.026Z"
    },
    {
      "summary": "Users need a way to customize or disable implicit activity failure logging to support patterns like activity-retry-based-polling where some failures are intentional. The request is to allow users to control logging behavior while still enabling their own custom logging approaches.",
      "category": "feature",
      "subcategory": "activity-logging",
      "apis": [],
      "components": [
        "activity-executor",
        "logging",
        "error-handling"
      ],
      "concepts": [
        "logging",
        "error-handling",
        "customization",
        "activity-failure",
        "observability",
        "metrics"
      ],
      "severity": "medium",
      "userImpact": "Users currently cannot prevent SDK-forced activity failure logging, limiting their ability to handle intentional failures or implement custom logging strategies.",
      "rootCause": "SDKs implicitly log all activity failures without exposing a way for users to disable or customize this behavior, preventing users from deferring to their own logging code.",
      "proposedFix": "Allow users to disable implicit logging of activity failures so they can use their own logging/interceptor code for complete customization.",
      "workaround": "Users can implement custom error handlers or interceptors, though this doesn't prevent SDK-level logging.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "allow users to disable our currently-forced implicit logging of activity failures so they can defer to their own logging code to do whatever they want",
      "number": 463,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:14.927Z"
    },
    {
      "summary": "Feature request to expose the number of activity attempts in `ActivityFailure` so workflows can access retry information. Currently, this data exists in the `ActivityTaskStarted` event but isn't exposed to users.",
      "category": "feature",
      "subcategory": "activity-failure",
      "apis": [
        "ActivityFailure",
        "ActivityTaskStarted"
      ],
      "components": [
        "activity-executor",
        "history-events",
        "error-handling"
      ],
      "concepts": [
        "retry-attempts",
        "activity-failure",
        "error-information",
        "workflow-context",
        "debugging"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently determine how many times an activity was retried before failure, limiting debugging and observability capabilities in workflows.",
      "rootCause": null,
      "proposedFix": "Expose an attempts field in `ActivityFailure` that is populated from the `ActivityTaskStarted` event data when an activity fails or is canceled.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Today there's no way in a workflow to know how many attempts an activity made before failing.",
      "number": 462,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:12.375Z"
    },
    {
      "summary": "Accidental issue created due to clicking the wrong button in the UI. No actual feature request or bug report.",
      "category": "other",
      "subcategory": "invalid",
      "apis": [],
      "components": [],
      "concepts": [],
      "severity": "low",
      "userImpact": "No actual impact; this was a mistaken issue creation that was immediately identified and closed.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Accidental creation due to clicking the auto-create sub-issue icon. Closed by the original author.",
      "related": [],
      "keyQuote": "No, it was an accidental click of that icon next to the checkboxes that auto-creates a sub-issue, sorry. Closing.",
      "number": 461,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:15.064Z"
    },
    {
      "summary": "Add an option to drain sticky task queue during graceful worker shutdown. This allows the worker to stop polling the normal task queue and only poll the sticky task queue to complete workflows while shutting down, improving shutdown behavior.",
      "category": "feature",
      "subcategory": "worker-shutdown",
      "apis": [],
      "components": [
        "worker",
        "task-queue",
        "graceful-shutdown"
      ],
      "concepts": [
        "sticky-task-queue",
        "graceful-shutdown",
        "polling",
        "workflow-completion",
        "drain"
      ],
      "severity": "medium",
      "userImpact": "Allows workers to complete in-progress workflows from sticky task queues before fully shutting down, improving reliability during deployments.",
      "rootCause": null,
      "proposedFix": "Implement a StickyTaskQueueDrainTimeout option that stops normal task queue polling while continuing sticky task queue polling during shutdown.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Worker will stop polling on the normal task queue and only poll on the stick task queue to complete workflows while the worker is shutting down.",
      "number": 460,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:03:00.754Z"
    },
    {
      "summary": "Feature request to provide worker status information across all SDKs, allowing users to check worker health and programmatically react to status changes like activity/workflow slot usage, cache size, polling status, and server reachability.",
      "category": "feature",
      "subcategory": "worker-status",
      "apis": [],
      "components": [
        "worker",
        "client",
        "health-monitoring"
      ],
      "concepts": [
        "worker-health",
        "status-monitoring",
        "activity-slots",
        "workflow-cache",
        "server-connectivity",
        "failure-backoff"
      ],
      "severity": "medium",
      "userImpact": "Users can programmatically monitor worker health and respond to status changes instead of relying solely on logs and metrics.",
      "rootCause": null,
      "proposedFix": "Implement worker status API across all SDKs to expose: activity slots in use, workflow cache size, worker type status (polling/full/failure backoff), error information, and server reachability with optional status change notifications.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        696
      ],
      "keyQuote": "Users need to get worker status to at least check worker health and programmatically react to information we often only make available via logs/metrics.",
      "number": 456,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:57.983Z"
    },
    {
      "summary": "Feature request to treat TLS handshake failures as worker-fatal errors instead of retrying indefinitely. TLS failures should be differentiated from normal connection failures and cause the worker to fail after normal retry logic is exhausted.",
      "category": "feature",
      "subcategory": "worker-tls",
      "apis": [],
      "components": [
        "worker",
        "connection",
        "tls",
        "poll"
      ],
      "concepts": [
        "tls",
        "handshake",
        "failure",
        "retry",
        "worker-fatal",
        "connection"
      ],
      "severity": "high",
      "userImpact": "Workers currently retry TLS handshake failures indefinitely, preventing proper failure detection and worker shutdown when TLS configuration is misconfigured.",
      "rootCause": null,
      "proposedFix": "Differentiate TLS handshake failures from normal connection failures and treat TLS failures as worker-fatal after normal retry logic is exhausted.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "On any TLS failure do the normal retry we should do for all worker poll calls, then consider it a fatal error to fail the worker.",
      "number": 455,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:58.975Z"
    },
    {
      "summary": "Add a defaultConnection() static method to all SDKs that uses localhost by default but can be configured via environment variables or config files to connect to Temporal Cloud, enabling users to easily switch samples between local and cloud environments.",
      "category": "feature",
      "subcategory": "connection-configuration",
      "apis": [],
      "components": [
        "client",
        "connection",
        "configuration"
      ],
      "concepts": [
        "connection-management",
        "environment-configuration",
        "cloud-compatibility",
        "sample-infrastructure",
        "configuration-file",
        "localhost-default"
      ],
      "severity": "medium",
      "userImpact": "Users can run samples locally without modification and seamlessly switch to cloud by adding a configuration file, reducing setup complexity.",
      "rootCause": null,
      "proposedFix": "Implement a defaultConnection() static method in all SDKs that reads from ~/.config/temporalconnection or environment variables to determine whether to connect to localhost or cloud.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of design work in issue #441 with per-SDK implementation tickets created and tracked.",
      "related": [
        441
      ],
      "keyQuote": "We should have a defaultConnection() type static method in all the SDKs that uses localhost by default but, if some file path/env vars/etc are provided, will use those to connect to cloud.",
      "number": 454,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:43.556Z"
    },
    {
      "summary": "Feature request for SDK test coverage confirming that workflow updates are processed with higher priority than the main workflow completion, including handling of unhandled commands and proper coroutine ordering when updates arrive during task processing.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "workflow.run",
        "workflow.update",
        "workflow.signal",
        "workflow.wait_condition"
      ],
      "components": [
        "test-framework",
        "workflow-execution",
        "update-handler",
        "signal-handler"
      ],
      "concepts": [
        "unhandled-command",
        "coroutine-ordering",
        "task-processing",
        "priority",
        "replay",
        "cache",
        "concurrency"
      ],
      "severity": "medium",
      "userImpact": "Ensures SDKs properly handle updates sent during workflow task processing, preventing data loss and maintaining correct execution order.",
      "rootCause": "Need for comprehensive feature test coverage across SDKs to verify update priority and unhandled command behavior during workflow execution.",
      "proposedFix": "Create two feature tests: one verifying updates processed before completion with unhandled command assertion, and another testing signal/update ordering in same task on cached workflow.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "make sure an update is sent while the initial task is processed, causing unhandled command, and that the workflow result is properly updated",
      "number": 451,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:45.607Z"
    },
    {
      "summary": "Customer request for Temporal Schedules to support running on the last day of each month. This requires extending the Schedule feature to handle this specific recurring pattern, which is not currently supported.",
      "category": "feature",
      "subcategory": "schedules",
      "apis": [
        "Schedule"
      ],
      "components": [
        "schedules",
        "cron-like-scheduling"
      ],
      "concepts": [
        "scheduling",
        "recurring-patterns",
        "calendar-based-execution",
        "month-end-tasks",
        "temporal-expressions"
      ],
      "severity": "medium",
      "userImpact": "Users cannot schedule workflows to run on the last day of each month, requiring workarounds for a common business requirement.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We have the same ask from customers",
      "number": 446,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:46.791Z"
    },
    {
      "summary": "Implement history compatibility testing for all SDKs (TypeScript, Python, .NET) and all features to ensure new SDK releases maintain compatibility with older SDK-recorded histories. Currently supported only in Go and Java.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "history-recording",
        "history-comparison",
        "ci-validation",
        "sdk-testing"
      ],
      "concepts": [
        "history-compatibility",
        "backward-compatibility",
        "cross-sdk-testing",
        "test-automation",
        "version-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot verify that new SDK releases maintain history compatibility across all SDKs and features, risking silent compatibility breaks.",
      "rootCause": null,
      "proposedFix": "Add history recording and comparison support to TypeScript, Python, and .NET SDKs; implement CI check to validate all features have recorded histories.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed across all SDKs with history recording and comparison support added to TypeScript, Python, and .NET.",
      "related": [],
      "keyQuote": "Support was added for Go and Java tests to record histories and compare them to histories created during a run.",
      "number": 444,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:30.500Z"
    },
    {
      "summary": "User requests the ability to limit the number of activity tasks that a worker polls, enabling graceful shutdown and non-multi-tenant configurations. The feature would prevent workers from accepting new tasks while long-running activities complete without losing progress.",
      "category": "feature",
      "subcategory": "activity-polling",
      "apis": [],
      "components": [
        "worker",
        "activity-poller",
        "slot-supplier"
      ],
      "concepts": [
        "polling",
        "graceful-shutdown",
        "concurrency-limits",
        "task-queueing",
        "long-running-activities",
        "non-blocking-pause"
      ],
      "severity": "medium",
      "userImpact": "Users cannot gracefully shutdown workers with long-running activities without losing progress or implement single-slot polling for non-multi-tenant services.",
      "rootCause": "The activity poller lacks a configurable limit on concurrent polling tasks and doesn't support pausing after slot acquisition to enable graceful shutdown.",
      "proposedFix": "Implement MaximumPollTaskPerPoller configuration or add a PauseableSlotSupplier interface that pauses polling after acquiring a slot, with discussion of more sophisticated semantics like invalidating unused slots.",
      "workaround": "Shutdown the worker as the last action in an activity's finally block to stop polling before the slot is released.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be nice number of times an activity worker can poll tasks, as our service is currently not multi-tenant, and we would like to set it to 1.",
      "number": 443,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:30.956Z"
    },
    {
      "summary": "Feature request to allow activities to specify backoff intervals for retries when returning failures, leveraging server-side support already implemented.",
      "category": "feature",
      "subcategory": "activity-retry",
      "apis": [],
      "components": [
        "activity-executor",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "backoff",
        "failure-handling",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently control retry backoff intervals from activity failures, limiting fine-grained retry behavior configuration.",
      "rootCause": null,
      "proposedFix": "Implement activity-side support for specifying backoff intervals on failure returns, aligned with existing server-side capability.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of #419",
      "related": [
        419,
        1515
      ],
      "keyQuote": "Allow activity to specify backoff interval for next retry when return failure. This is now supported by server",
      "number": 442,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:32.443Z"
    },
    {
      "summary": "Feature request to support environment variable and file-based configuration for CLI and SDKs across all Temporal language implementations. This unified configuration approach should allow both env vars and config files (with vars overriding files) to initialize client connections.",
      "category": "feature",
      "subcategory": "external-client-configuration",
      "apis": [],
      "components": [
        "cli",
        "client-configuration",
        "connection-options",
        "config-loader"
      ],
      "concepts": [
        "environment-variables",
        "configuration-management",
        "client-initialization",
        "cross-sdk-standardization",
        "config-files",
        "profile-management"
      ],
      "severity": "medium",
      "userImpact": "Users will have a standardized way to configure Temporal clients across all SDKs and CLI using environment variables or configuration files.",
      "rootCause": null,
      "proposedFix": "Implement unified environment and file-based configuration system with JSON format (not YAML) for config files, supporting environment variable overrides, and a single SDK call to create connection options. CLI can mutate config files.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1815,
        2562,
        1727,
        835,
        490,
        287,
        628,
        751
      ],
      "keyQuote": "We want CLI to be able to use same environment variables and same config files as all SDKs",
      "number": 441,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:15.549Z"
    },
    {
      "summary": "Feature request to integrate the Cloud Ops API client into Temporal SDKs. This involves creating high-level cloud clients separate from existing SDK clients while sharing underlying gRPC service mechanisms across all language SDKs.",
      "category": "feature",
      "subcategory": "cloud-api-client",
      "apis": [],
      "components": [
        "cloud-client",
        "grpc-service",
        "connection-management",
        "rpc-metadata"
      ],
      "concepts": [
        "cloud-operations",
        "api-integration",
        "sdk-client",
        "high-level-wrapper",
        "multi-language-support",
        "service-mechanism"
      ],
      "severity": "high",
      "userImpact": "Enables users to interact with Temporal Cloud operations through native SDK clients in all supported languages.",
      "rootCause": null,
      "proposedFix": "Create separate high-level cloud clients per SDK language that share underlying gRPC logic but maintain independence from namespace-specific clients. Integrate metrics and RPC metadata handling consistently across SDKs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Approach was deprecated in favor of creating separate Cloud SDKs per language (cloud-sdk-go started). Cloud service APIs in existing SDKs will be removed once language-specific cloud SDKs are available.",
      "related": [
        1459,
        2059,
        737,
        1416,
        522,
        244,
        476,
        378,
        20
      ],
      "keyQuote": "We are making Cloud SDKs in each language. We have started with cloud-sdk-go and will be making others.",
      "number": 440,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:17.902Z"
    },
    {
      "summary": "Feature request to enable users to see source code mappings for workflow events in the UI, allowing them to relate events back to their source code for easier debugging. TypeScript SDK already has this capability via enhanced stack traces; other language implementations need standardization.",
      "category": "feature",
      "subcategory": "debugging-observability",
      "apis": [],
      "components": [
        "workflow-history-ui",
        "stack-trace-generation",
        "query-service",
        "replay-engine"
      ],
      "concepts": [
        "source-mapping",
        "stack-traces",
        "debugging",
        "workflow-execution",
        "code-location",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users can more easily debug workflow issues by seeing the exact source code location where each event was generated during workflow execution.",
      "rootCause": null,
      "proposedFix": "Standardize enhanced stack trace interface across all language SDKs (TS already implements this); add query capability to return stack traces for commands/events during replay.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be nice if we could provide enough info from an active workflow to enable users to see where in the code the workflow was when each event was generated",
      "number": 439,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:18.357Z"
    },
    {
      "summary": "Add support for the new WorkflowIdConflictPolicy field in Start Workflow and Signal-with-Start APIs across all SDKs. This policy controls behavior when a workflow ID conflicts with running workflows, complementing the existing WorkflowIdReusePolicy which applies to closed workflows.",
      "category": "feature",
      "subcategory": "workflow-api",
      "apis": [
        "StartWorkflow",
        "SignalWithStart"
      ],
      "components": [
        "api",
        "workflow-client",
        "sdk-core"
      ],
      "concepts": [
        "workflow-id-conflict",
        "policy",
        "workflow-execution",
        "api-design",
        "cross-sdk-feature"
      ],
      "severity": "high",
      "userImpact": "Users need standardized support across all SDKs to handle workflow ID conflicts with running workflows, ensuring consistent behavior across the Temporal ecosystem.",
      "rootCause": null,
      "proposedFix": "Add a new field/parameter in each SDK's Start Workflow and Signal-With-Start API struct/function to support WorkflowIdConflictPolicy, with documentation clarifying the distinction from WorkflowIdReusePolicy.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented across all SDKs (Go, Java, TypeScript, Python, .NET, PHP) and CLI with tracking issues created in each repository.",
      "related": [
        1447,
        2033,
        715,
        1392,
        504,
        217,
        316,
        528,
        416
      ],
      "keyQuote": "Support for the new policy in both APIs is needed. Furthermore, the comments should emphasize that WorkflowIdReusePolicy is for _closed_ Workflows, and WorkflowIdConflictPolicy is for _running_ Workflows.",
      "number": 437,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:03.693Z"
    },
    {
      "summary": "Feature request to add serialization context to codecs and converters, allowing users to access payload context details (like workflow ID) during serialization/deserialization. This enables use cases such as signing payloads with workflow IDs to protect against replay attacks, similar to existing Java SDK implementation.",
      "category": "feature",
      "subcategory": "serialization-context",
      "apis": [],
      "components": [
        "codec",
        "converter",
        "serialization",
        "workflow-context",
        "activity-client"
      ],
      "concepts": [
        "serialization",
        "deserialization",
        "security",
        "replay-attack-protection",
        "context-awareness",
        "payload-signing"
      ],
      "severity": "medium",
      "userImpact": "Users can implement enhanced security measures by accessing serialization context to sign payloads and protect against replay attacks.",
      "rootCause": null,
      "proposedFix": "Implement serialization context similar to Java SDK PR #1695, making context available to both codecs and converters, including async activity clients.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1352,
        1661,
        796,
        438,
        238,
        587
      ],
      "keyQuote": "users payload codec/converter may want to know details about the payloads context... can be useful if the users want to sign the payload with the workflowID to help protect against replay attacks",
      "number": 434,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:01.470Z"
    },
    {
      "summary": "SDKs currently return update handles even when the update hasn't reached the desired lifecycle stage, which is dangerous because updates aren't durable until accepted. The fix requires SDKs to poll the update request until it reaches the desired state before returning the handle to the user.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "UpdateWorkflowExecution",
        "PollWorkflowExecutionUpdate"
      ],
      "components": [
        "workflow-update",
        "client-sdk",
        "polling-mechanism"
      ],
      "concepts": [
        "durability",
        "lifecycle-stages",
        "polling",
        "state-management",
        "timeout-handling"
      ],
      "severity": "high",
      "userImpact": "Users can receive update handles for non-durable updates that may be lost, leading to incorrect assumptions about update state and potential data loss.",
      "rootCause": "SDKs pass the desired lifecycle stage option to gRPC but don't handle server internal timeouts that return empty responses, immediately returning a handle instead of polling.",
      "proposedFix": "SDKs should poll the update request when the server returns an empty response or a response not in the desired lifecycle stage until it reaches the desired state before returning the handle.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Server-side support was merged to properly handle update lifecycle states and return specific errors for lost updates. SDKs implement polling logic per alexshtin's protocol.",
      "related": [
        1414,
        2002,
        1372,
        485,
        199
      ],
      "keyQuote": "updates are not durable until accepted so it is possible to return a handle to a non durable update that can be lost",
      "number": 432,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:02:01.984Z"
    },
    {
      "summary": "SDK clients should automatically generate and set an UpdateID on update requests even when users don't provide one, enabling proper deduplication of retried requests across all Temporal SDKs.",
      "category": "feature",
      "subcategory": "update-request-handling",
      "apis": [
        "UpdateRequest"
      ],
      "components": [
        "sdk-client",
        "update-handler",
        "request-sender"
      ],
      "concepts": [
        "deduplication",
        "retries",
        "idempotency",
        "request-tracking",
        "update-workflow"
      ],
      "severity": "medium",
      "userImpact": "Without automatic UpdateID generation, users cannot reliably deduplicate retried update requests, risking duplicate executions in production systems.",
      "rootCause": "UpdateID field is optional in the update request protocol, but leaving it empty prevents proper deduplication of retried requests.",
      "proposedFix": "SDK clients should automatically generate a unique UpdateID before sending update requests if the user has not provided one.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in Go SDK (PR #1106), Java SDK (already implemented), with corresponding issues tracked for TypeScript (#1371), Python (#484), and .NET (#198).",
      "related": [
        1371,
        484,
        198
      ],
      "keyQuote": "leaving this field empty is a bad idea as there is no way to deduplicate retried update request",
      "number": 431,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:47.533Z"
    },
    {
      "summary": "Add a dashboard to expose the action metrics that the server is emitting, similar to existing dashboards.",
      "category": "feature",
      "subcategory": "metrics-dashboard",
      "apis": [],
      "components": [
        "metrics",
        "dashboards",
        "server"
      ],
      "concepts": [
        "metrics",
        "observability",
        "dashboard",
        "monitoring",
        "action-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users can better monitor and visualize action metrics from the Temporal server.",
      "rootCause": null,
      "proposedFix": "Expose server's action metrics in the dashboards repository",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented via dashboards pull request #53",
      "related": [],
      "keyQuote": "Server is emitting `action` metrics. It would be valuable to expose that to our dashboards",
      "number": 430,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:48.520Z"
    },
    {
      "summary": "Users need an SLA dashboard to monitor error codes and SDK/worker metrics, helping track Service Level Agreements based on real SDK metrics in a metrics visualization tool.",
      "category": "feature",
      "subcategory": "metrics-monitoring",
      "apis": [],
      "components": [
        "metrics",
        "sdk",
        "worker",
        "dashboard"
      ],
      "concepts": [
        "SLA",
        "error-tracking",
        "metrics-visualization",
        "monitoring",
        "observability",
        "worker-health"
      ],
      "severity": "medium",
      "userImpact": "Users lack visibility into SLA compliance and error patterns across their Temporal deployments, making it difficult to monitor and track service level objectives.",
      "rootCause": null,
      "proposedFix": "Add metrics dashboard to https://github.com/temporalio/dashboards to track SLA based on SDK metrics and error codes received by workers.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users of temporal want to be able to see the SLA based on error codes received by SDK/workers.",
      "number": 429,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:45.823Z"
    },
    {
      "summary": "Add a GetStatus() method to workflow update handles that allows users to check the current status of an update and optionally wait for it to reach a specific stage, with WorkflowUpdateInfo returning the stage and result if available.",
      "category": "feature",
      "subcategory": "workflow-updates",
      "apis": [
        "PollWorkflowExecutionUpdate",
        "GetStatus",
        "GetResult",
        "WorkflowUpdateInfo"
      ],
      "components": [
        "update-handle",
        "workflow-execution",
        "status-polling"
      ],
      "concepts": [
        "status-tracking",
        "async-waiting",
        "stage-progression",
        "long-polling",
        "non-blocking"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to query the status of workflow updates and optionally block until they reach a desired stage, improving the developer experience for update handling.",
      "rootCause": null,
      "proposedFix": "Implement GetStatus(waitForStage? = dontWait) -> WorkflowUpdateInfo on the update handle that loops on long-poll timeout, with GetResult as a thin wrapper waiting for COMPLETED stage.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "GetStatus(waitForStage? = dontWait) -> WorkflowUpdateInfo call on the update handle...waits until that stage is reached (looping if needed)",
      "number": 428,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:32.247Z"
    },
    {
      "summary": "SDKs currently handle unknown SDK flags inconsistently on replayâ€”some fail the workflow task while others ignore the flag. The request is to standardize behavior across all SDKs to prevent workflows from entering inconsistent states.",
      "category": "feature",
      "subcategory": "sdk-flags",
      "apis": [],
      "components": [
        "sdk-flag-handling",
        "replay-engine",
        "worker"
      ],
      "concepts": [
        "downgrade",
        "replay",
        "consistency",
        "backward-compatibility",
        "flag-validation",
        "workflow-state"
      ],
      "severity": "high",
      "userImpact": "Users experience inconsistent behavior when downgrading SDKs, with some SDKs failing workflows while others silently ignore unknown flags, creating operational unpredictability.",
      "rootCause": "Lack of standardized behavior across SDKs for handling unknown flags during replay.",
      "proposedFix": "Establish consistent behavior across all SDKs (either fail or ignore unknown flags uniformly) to prevent workflow inconsistency.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDKs should behave consistently...Currently the SDKs behave differently: Fail the workflow task (Go and Java) or Ignore the unknown flag (Core)",
      "number": 427,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:34.965Z"
    },
    {
      "summary": "Add API key client option to all SDKs and CLI tools that creates a Bearer token Authorization header. This feature is needed for self-hosted setups and cloud deployments where API key authentication is required.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [],
      "components": [
        "client",
        "connection",
        "authentication",
        "http-headers"
      ],
      "concepts": [
        "api-key",
        "authentication",
        "authorization",
        "bearer-token",
        "client-option",
        "cloud-deployment",
        "self-hosted"
      ],
      "severity": "high",
      "userImpact": "Users can now authenticate with Temporal Server using API keys as Bearer tokens without manually setting RPC metadata headers.",
      "rootCause": null,
      "proposedFix": "Add an API key client option to all SDKs (Go, Java, TypeScript, Python, .NET, PHP) and CLI that sets the Authorization header with Bearer <api-key>.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented across all SDK clients and CLI with consistent API key option support.",
      "related": [
        1401,
        478,
        1997,
        695,
        1367,
        482,
        191,
        410
      ],
      "keyQuote": "Every place that creates a client should have an option to accept an API key which becomes the Authorization header of Bearer <api-key>.",
      "number": 426,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:33.047Z"
    },
    {
      "summary": "Request to allow workflows to force complete the current workflow task when local activities finish, enabling faster query and signal processing. Currently workflow tasks wait up to 80% of the timeout (10s) before completing, causing delays.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "workflow-task",
        "local-activity",
        "task-heartbeat"
      ],
      "concepts": [
        "timeout",
        "workflow-task-boundary",
        "local-activity-retry",
        "query-processing",
        "signal-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot efficiently handle scenarios with many sequential or parallel local activities, forcing them to wait for workflow task timeout before processing queries or signals.",
      "rootCause": "Workflow tasks are designed to wait until 80% of the timeout before completing, which delays query and signal processing when multiple local activities are executed sequentially or in parallel.",
      "proposedFix": "Add a flag to LocalActivityOptions to force complete the workflow task when the local activity completes/fails, or provide an API like activity.forceCompleteWorkflowTask() for user code to invoke.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This will then make it possible to process query task, or new signals by letting user workflow decide when to report task completed and get a new workflow task.",
      "number": 424,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:17.553Z"
    },
    {
      "summary": "When workflows are triggered via scheduler, only RunActivity spans are reported in distributed tracing instead of all expected spans (StartWorkflow, RunWorkflow, StartActivity, RunActivity, CompleteWorkflow) that appear when workflows are started manually.",
      "category": "bug",
      "subcategory": "distributed-tracing",
      "apis": [
        "create_schedule",
        "start_workflow",
        "execute_workflow"
      ],
      "components": [
        "tracing",
        "scheduler",
        "workflow-execution",
        "span-generation"
      ],
      "concepts": [
        "observability",
        "distributed-tracing",
        "spans",
        "jaeger",
        "opentelemetry",
        "schedule-triggered-workflows",
        "manual-workflow-start"
      ],
      "severity": "medium",
      "userImpact": "Users cannot establish comprehensive distributed tracing observability for scheduled workflows, making it difficult to monitor and debug schedule-triggered executions.",
      "rootCause": "For scheduled workflows, the server invokes start workflow rather than the client SDK, so the SDK's tracing interceptors cannot apply the outer span context that would normally be created during client-side workflow start.",
      "proposedFix": "Consider creating an outer span when the workflow is first run server-side, potentially using the WorkflowRunId to generate consistent trace IDs across schedule executions.",
      "workaround": "Implement a custom TracingWorkflowInboundInterceptor that generates a trace_id based on WorkflowRunId and sets the context globally using an IdempotentIdGenerator.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The problem is that for schedules the server invokes start workflow and not your client. Therefore the server can't possibly know what OTel server you've setup with your SDK to send spans to.",
      "number": 422,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:20.227Z"
    },
    {
      "summary": "Features test suite failed to catch a TS SDK bug involving null activity timeouts that was introduced by proto changes. The bug is reproducible with the exact same SDK version and code in a hello world sample but not when running the same code within the features test framework.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "features-test-suite",
        "activity-timeouts",
        "typescript-sdk",
        "test-coverage"
      ],
      "concepts": [
        "test-coverage",
        "timeout-handling",
        "proto-changes",
        "dependency-management",
        "test-isolation"
      ],
      "severity": "medium",
      "userImpact": "Test suite gaps prevented detection of a breaking SDK bug that affected TypeScript users, potentially delaying bug fixes.",
      "rootCause": "Unclear why features tests don't reproduce the null activity timeout bug that occurs in standalone samples; possibly related to dependency management or test environment differences.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The underlying TS SDK bug was fixed via referenced PRs, but the root cause of the test suite gap remains unclear.",
      "related": [
        5444,
        5445
      ],
      "keyQuote": "It still should've been caught. It's unclear why it wasn't.",
      "number": 421,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:15.760Z"
    },
    {
      "summary": "Add support for exposing next retry delay on ApplicationFailure across all Temporal SDKs and local activities. This feature was added to the API but needs to be implemented in Python, PHP SDKs and verified in other SDKs.",
      "category": "feature",
      "subcategory": "activity-retry",
      "apis": [
        "ApplicationFailureInfo"
      ],
      "components": [
        "activity-executor",
        "retry-policy",
        "failure-handling",
        "local-activities"
      ],
      "concepts": [
        "retry",
        "delay",
        "failure-handling",
        "application-failure",
        "SDK-parity",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Users need consistent access to next retry delay across all SDKs to implement custom retry logic and failure handling strategies.",
      "rootCause": null,
      "proposedFix": "Expose the next_retry_delay field from ApplicationFailureInfo in SDK APIs for both regular and local activities.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1319,
        1983,
        1349,
        468,
        186,
        395,
        1454,
        2054,
        735
      ],
      "keyQuote": "We recently added the ability for an activity to specify the next retry delay on failure via a field on ApplicationFailureInfo",
      "number": 419,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:04.049Z"
    },
    {
      "summary": "Request for a new PanicPolicy option to automatically restart workflows from the beginning when non-deterministic errors occur, particularly useful for finite-state machine workflows with frequent small changes.",
      "category": "feature",
      "subcategory": "workflow-restart-policy",
      "apis": [],
      "components": [
        "workflow-engine",
        "panic-policy",
        "error-handling"
      ],
      "concepts": [
        "non-determinism",
        "workflow-restart",
        "panic-policy",
        "signal-replay",
        "deterministic-execution",
        "error-recovery"
      ],
      "severity": "medium",
      "userImpact": "Users with frequently-changing finite-state-machine workflows could avoid complex versioning by automatically restarting workflows on non-deterministic errors.",
      "rootCause": "Non-deterministic panics occurring in workflows due to code changes, which would normally require complex versioning or manual intervention to resolve.",
      "proposedFix": "Add a new PanicPolicy option called RestartWorkflow that restarts the workflow from the beginning (ideally with signal replay) when non-deterministic errors occur.",
      "workaround": "Use versioning to handle non-deterministic errors, though this becomes unmaintainable with frequent small changes.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Want to have a new PanicPolicy option called RestartWorkflow, if this option is selected, the workflow will be restarted from the beginning when a non-deterministic error happens",
      "number": 417,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:02.555Z"
    },
    {
      "summary": "Server does not properly rate limit eager activities. SDKs need to disable eager activities when task queue rate limits are configured until the server can address this limitation.",
      "category": "feature",
      "subcategory": "eager-activities",
      "apis": [],
      "components": [
        "eager-activities",
        "task-queue",
        "rate-limiting",
        "worker"
      ],
      "concepts": [
        "rate-limiting",
        "eager-activities",
        "task-queue",
        "performance",
        "backpressure"
      ],
      "severity": "high",
      "userImpact": "Users with task queue rate limits enabled cannot use eager activities, limiting performance optimization options.",
      "rootCause": "Server does not properly rate limit eager activities, causing conflicts with task queue rate limit settings.",
      "proposedFix": "Disable eager activities in SDKs when task queue rate limit is active, until server resolves the underlying issue.",
      "workaround": "Use task queue rate limiting without eager activities, or disable rate limiting to use eager activities.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented in Go SDK (PR #1350), Java SDK (Issue #1978), and Core SDK (Issue #840) by disabling eager activities when rate limits are set.",
      "related": [
        6800
      ],
      "keyQuote": "Until server can address this we have agreed to disable eager activities if the task queue rate limit is active",
      "number": 405,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:01:00.564Z"
    },
    {
      "summary": "Request for a WorkflowService API to allow dynamic updates to activity rate limits on a task queue. Currently, rate limits are set by activity pollers via TaskQueueMetadata, causing inconsistency when different workers have different configurations.",
      "category": "feature",
      "subcategory": "task-queue-configuration",
      "apis": [],
      "components": [
        "task-queue",
        "activity-poller",
        "workflow-service"
      ],
      "concepts": [
        "rate-limiting",
        "task-queue-configuration",
        "worker-configuration",
        "activity-polling",
        "versioning"
      ],
      "severity": "medium",
      "userImpact": "Users with heterogeneous worker configurations experience unpredictable rate limit behavior on task queues due to conflicting settings.",
      "rootCause": "Rate limits are set by individual activity pollers rather than being configured server-side, leading to flapping values when workers have different configurations.",
      "proposedFix": "Implement a general UpdateTaskQueue API for task queue configuration management, integrating versioning and build IDs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If different workers have different limits configured, this value will flap server-side.",
      "number": 402,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:44.682Z"
    },
    {
      "summary": "Add workflow initialization support that allows workflows to run setup code before start to configure handlers and use workflow input, without returning values. Feature needs implementation across SDKs (PHP, TypeScript, Java, Python, Go) with language-specific approaches.",
      "category": "feature",
      "subcategory": "workflow-initialization",
      "apis": [
        "WorkflowInit",
        "WorkflowConstructor",
        "workflow.init"
      ],
      "components": [
        "workflow-runtime",
        "handler-registration",
        "workflow-lifecycle",
        "constructor-execution"
      ],
      "concepts": [
        "initialization",
        "handler-setup",
        "state-management",
        "workflow-input",
        "lifecycle-hooks",
        "pre-execution-setup"
      ],
      "severity": "medium",
      "userImpact": "Developers can now initialize workflow state and register handlers before workflow execution, reducing boilerplate and enabling better use of workflow input in signal/update handlers.",
      "rootCause": "Workflows lacked a mechanism to run initialization code that could access workflow input before handlers need to be registered.",
      "proposedFix": "Add language-specific initialization methods: @WorkflowInitMethod/@WorkflowConstructor (Java), @workflow.init on __init__ (Python), register option or Init() method (Go), @WorkflowInit (PHP), file-level code (TypeScript), [WorkflowInit] (already implemented in .NET)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed across SDKs with language-specific patterns. .NET already had support; other SDKs implemented according to their design patterns.",
      "related": [
        480,
        1483,
        865,
        600,
        1576
      ],
      "keyQuote": "Workflows need a way to run code before start to setup handlers and anything else they may want.",
      "number": 400,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:49.537Z"
    },
    {
      "summary": "Request to add custom marker events to workflow history/timeline for recording workflow-specific decisions and pivotal events without the constraints of signals or activities. Currently users work around this by exposing information through queries.",
      "category": "feature",
      "subcategory": "workflow-history",
      "apis": [],
      "components": [
        "history",
        "timeline",
        "marker-recording"
      ],
      "concepts": [
        "workflow-state",
        "event-recording",
        "history-growth",
        "workflow-visibility",
        "debugging"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily record custom metadata about workflow decisions in history, forcing them to use workarounds like queries or dummy activities that impact performance.",
      "rootCause": "The system lacks a mechanism for recording opaque marker events without the constraints of signals (which require actual workflow handling) or activities (which impact performance).",
      "proposedFix": "Add a way to record custom MarkerRecorded events that are opaque for the server, allowing developers to annotate workflow history with custom information.",
      "workaround": "Use queries to expose workflow-specific information, or use noop activities with payloads (though this impacts history growth and recovery time).",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        682
      ],
      "keyQuote": "A way to record custom MarkerRecorded Events that are opaque for the server would be a suitable solution.",
      "number": 399,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:47.172Z"
    },
    {
      "summary": "Feature request to allow activities to omit StartToClose or ScheduleToClose timeouts when a Heartbeat timeout is configured, enabling indefinite/long-running activities without requiring arbitrary large timeout values.",
      "category": "feature",
      "subcategory": "activity-timeouts",
      "apis": [],
      "components": [
        "activity-executor",
        "timeout-handler"
      ],
      "concepts": [
        "timeout",
        "activity-lifecycle",
        "heartbeat",
        "long-running-activities",
        "resource-management"
      ],
      "severity": "medium",
      "userImpact": "Users can now define long-running activities with heartbeat monitoring without being forced to set arbitrary large timeout values for other timeout types.",
      "rootCause": "Current implementation requires explicit StartToClose or ScheduleToClose timeouts even for indefinite activities, forcing users to work around the limitation.",
      "proposedFix": "Relax the requirement for other timeouts whenever a Heartbeat timeout is set, as heartbeat provides a mechanism to kill and reschedule non-progressing activities.",
      "workaround": "Users currently set large timeout values as a workaround for indefinite activities.",
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #377 to consolidate discussion.",
      "related": [
        377
      ],
      "keyQuote": "Relax the requirement for other timeouts whenever a Heartbeat timeout is set, as that indicates that the activity is long running",
      "number": 397,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:31.940Z"
    },
    {
      "summary": "Enable macOS M1/ARM runners for CI testing across all Temporal SDKs. GitHub Actions now supports M1 runners with reasonable costs, and SDKs should test on all supported platforms including macOS ARM.",
      "category": "feature",
      "subcategory": "ci-testing",
      "apis": [],
      "components": [
        "ci-testing",
        "github-actions",
        "macos-runners"
      ],
      "concepts": [
        "platform-support",
        "test-coverage",
        "arm-architecture",
        "ci-infrastructure",
        "macos-m1"
      ],
      "severity": "medium",
      "userImpact": "Users get confidence that SDKs are tested and working correctly on macOS ARM64 architecture, reducing potential platform-specific issues.",
      "rootCause": null,
      "proposedFix": "Enable M1/ARM macOS runners in CI workflow for all SDKs (Go, Java, TypeScript, Python, .NET, CLI, SDK Core).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1421,
        497,
        2017,
        710,
        1381,
        495,
        210
      ],
      "keyQuote": "M1 runners are now available, cost should not be a major concern so we should go and enable these on all SDKs.",
      "number": 396,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:33.791Z"
    },
    {
      "summary": "User requests support for a Rust SDK for Temporal. The team acknowledges this is on their radar but hasn't committed to a production release yet, directing users to track the core SDK issue for updates.",
      "category": "feature",
      "subcategory": "sdk-support",
      "apis": [],
      "components": [
        "sdk",
        "language-support"
      ],
      "concepts": [
        "language-binding",
        "sdk-development",
        "rust",
        "production-readiness",
        "sdk-expansion"
      ],
      "severity": "medium",
      "userImpact": "Users who want to build Temporal workflows in Rust cannot do so until an official SDK is released.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed as the team indicated this is on their radar but not committed to production, with users directed to track the core SDK repository instead.",
      "related": [
        222
      ],
      "keyQuote": "we haven't yet decided to commit to a production release of a Rust SDK but it's very much on our radar",
      "number": 395,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:30.149Z"
    },
    {
      "summary": "Feature request to have worker tracing interceptors automatically create spans for schedules/workflows and upsert them into workflow headers, with options to opt-out. After discussion, the team identified implementation challenges around span lifecycle, lack of universal interceptor hooks for persisting data, and header mutation constraints across SDKs.",
      "category": "feature",
      "subcategory": "tracing-interceptors",
      "apis": [],
      "components": [
        "tracing-interceptor",
        "worker",
        "workflow-header"
      ],
      "concepts": [
        "span-creation",
        "header-mutation",
        "interceptor-hooks",
        "distributed-tracing",
        "workflow-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users need better control over tracing span creation and propagation for schedules/workflows, but SDK limitations make this difficult to implement universally.",
      "rootCause": "No universal place in all SDKs for interceptors to persist durable data; only some SDKs have side effect capabilities, local activities can't be used due to registration requirements, and header mutation has lookahead problems preventing atomic updates to history.",
      "proposedFix": "Initially proposed creating spans for schedules and setting them on workflow headers with opt-out capability. Later discussions explored creating spans per workflow on first run instead, but implementation was found to be infeasible.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1334,
        1963,
        1331,
        454,
        171
      ],
      "keyQuote": "upsert header has a lookahead problem since we can't mutate the header, only mark that we have updated it within history",
      "number": 394,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:18.767Z"
    },
    {
      "summary": "Request to expose a total worker task slots metric alongside the existing available slots metric to enable better visualization and monitoring of task slot utilization across worker nodes.",
      "category": "feature",
      "subcategory": "metrics-observability",
      "apis": [],
      "components": [
        "worker",
        "metrics",
        "task-slots"
      ],
      "concepts": [
        "resource-utilization",
        "monitoring",
        "metrics",
        "observability",
        "capacity-planning",
        "dashboard-visualization",
        "alerting"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily build generic dashboards to visualize worker task slot utilization without manually tracking the configured total slots separately.",
      "rootCause": null,
      "proposedFix": "Expose total possible task slots as a metric (temporal_worker_task_slots_total) that SDKs can publish alongside the existing available slots metric.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        334,
        388
      ],
      "keyQuote": "Providing a means to retrieve the total possible slots would make it trivial to graph the utilization percent using an 'available/total' approach.",
      "number": 392,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:15.038Z"
    },
    {
      "summary": "Feature request to allow users to dynamically modify worker configurations (such as number of pollers and slots) while a worker is running, with tracking across multiple SDK implementations.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "worker",
        "configuration",
        "polling"
      ],
      "concepts": [
        "dynamic-configuration",
        "runtime-modification",
        "worker-scaling",
        "resource-management",
        "pollers",
        "slots"
      ],
      "severity": "medium",
      "userImpact": "Users cannot adjust worker resource allocation without restarting the worker, limiting operational flexibility.",
      "rootCause": null,
      "proposedFix": "Implement dynamic worker configuration API that allows modifying pollers and slots at runtime, potentially using Nexus as a transport mechanism.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed due to unclear implementation approach and architectural changes (Nexus development). Feature implementation deferred pending further design clarity.",
      "related": [
        334,
        1323,
        1955,
        661
      ],
      "keyQuote": "Unclear what/how we want to do this, and a lot has changed since this was opened (e.g. we are building Nexus now, which could be a transport for config changes)",
      "number": 388,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:13.913Z"
    },
    {
      "summary": "Feature request to add a whitelist mechanism for retryable error types in RetryPolicy, allowing developers to specify which error types should trigger retries instead of only blacklisting non-retryable errors.",
      "category": "feature",
      "subcategory": "retry-policy",
      "apis": [
        "RetryPolicy"
      ],
      "components": [
        "retry-policy",
        "error-handling",
        "dotnet-sdk"
      ],
      "concepts": [
        "retry",
        "error-types",
        "whitelist",
        "error-handling",
        "policy-configuration"
      ],
      "severity": "low",
      "userImpact": "Users would have more granular control over which error types trigger retries, enabling more precise retry behavior for their workflows.",
      "rootCause": null,
      "proposedFix": "Add a RetryableErrorTypes property to RetryPolicy that accepts a list of error type names to whitelist for retry handling.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed without implementation. The team questioned the use case, noting that the existing NonRetryableErrorTypes blacklist approach is generally sufficient since all errors are retryable by default unless explicitly marked otherwise.",
      "related": [],
      "keyQuote": "Generally all errors are retryable unless the error says not to retry it or the retry policy says so through `NonRetryableErrorTypes`.",
      "number": 387,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T05:00:01.551Z"
    },
    {
      "summary": "Two high-severity vulnerabilities (CVE-2023-6481, CVE-2023-6378) in logback-classic 1.2.9 and logback-core 1.2.9 allow Denial-of-Service attacks via poisoned serialized data. Both vulnerabilities have CVSS scores of 7.5 and can be fixed by upgrading to logback 1.2.13.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "logback-classic",
        "logback-core",
        "build-gradle"
      ],
      "concepts": [
        "denial-of-service",
        "serialization-vulnerability",
        "dependency-upgrade",
        "network-attack"
      ],
      "severity": "critical",
      "userImpact": "Applications using this version are vulnerable to network-based Denial-of-Service attacks that can crash the service without authentication.",
      "rootCause": "Serialization vulnerability in logback receiver component that allows processing of poisoned data leading to DoS conditions.",
      "proposedFix": "Upgrade logback-classic and logback-core to version 1.2.13 or later.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A serialization vulnerability in logback receiver component allows an attacker to mount a Denial-Of-Service attack by sending poisoned data.",
      "number": 384,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:58.071Z"
    },
    {
      "summary": "Request to enable dynamic display names for activities in Temporal Go SDK to differentiate multiple invocations of the same activity method with different parameters, improving visibility and management in the Temporal UI.",
      "category": "feature",
      "subcategory": "activity-ui-metadata",
      "apis": [
        "RegisterActivityWithOptions"
      ],
      "components": [
        "activity-registration",
        "ui-display",
        "worker"
      ],
      "concepts": [
        "display-name",
        "activity-identification",
        "ui-visibility",
        "metadata",
        "runtime-configuration",
        "activity-invocation"
      ],
      "severity": "medium",
      "userImpact": "Developers struggle to identify and manage specific activity executions when the same activity is invoked multiple times with different purposes, reducing observability in the Temporal UI.",
      "rootCause": null,
      "proposedFix": "Introduce a new option or method within RegisterActivityWithOptions to allow dynamic setting of display names for activities during runtime.",
      "workaround": null,
      "related": [
        141
      ],
      "keyQuote": "Enable dynamic setting of the display name for activities to improve visibility and distinguish between multiple invocations of the same activity method.",
      "resolution": null,
      "resolutionDetails": null,
      "number": 383,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:58.896Z"
    },
    {
      "summary": "Feature request to expose a gRPC API that allows clients to query which features (schedules, versioning, sync update) are enabled for a specific namespace, since these features can be toggled on and off per namespace but there's currently no way for clients to discover this information.",
      "category": "feature",
      "subcategory": "feature-discovery",
      "apis": [],
      "components": [
        "gRPC-API",
        "namespace-management",
        "feature-flags"
      ],
      "concepts": [
        "feature-discovery",
        "namespace-configuration",
        "feature-toggles",
        "client-visibility",
        "server-capabilities",
        "configuration-querying"
      ],
      "severity": "medium",
      "userImpact": "Clients cannot determine which namespace-level features are enabled, making it impossible to know what capabilities are available without trial-and-error or documentation.",
      "rootCause": null,
      "proposedFix": "Add a gRPC endpoint to expose the list of enabled features for a given namespace, available in both on-premise Temporal and Temporal Cloud.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There is no way for a client to know if a server feature is enabled for a given namespace.",
      "number": 381,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:45.252Z"
    },
    {
      "summary": "Feature request to create DataDog integration samples for all Temporal SDKs demonstrating metrics and tracing integration with DataDog agents. Currently users struggle to integrate DataDog metrics (via Prometheus) and distributed tracing without clear examples.",
      "category": "feature",
      "subcategory": "observability-samples",
      "apis": [],
      "components": [
        "samples",
        "metrics",
        "tracing",
        "datadog-agent"
      ],
      "concepts": [
        "observability",
        "metrics-integration",
        "distributed-tracing",
        "prometheus",
        "monitoring",
        "sdk-samples"
      ],
      "severity": "medium",
      "userImpact": "Users currently struggle to integrate DataDog metrics and tracing with Temporal SDKs, requiring significant effort to figure out integration patterns without clear guidance.",
      "rootCause": null,
      "proposedFix": "Create DataDog sample applications for all SDKs (Go, Java, TypeScript, Python, .NET) demonstrating both metrics and tracing integration with DataDog agents, with educational documentation on the integration approach.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "People are doing this today, but they are struggling or have to figure a lot out themselves. It is important that the metrics _and_ tracing be demonstrated from workers/clients using the DataDog agent.",
      "number": 380,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:43.585Z"
    },
    {
      "summary": "Feature request to allow Continue-as-New from update handlers, similar to how it works in signal handlers. The feature was requested across multiple SDKs but was ultimately decided against due to design concerns around precedence and exception handling.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "update-handler",
        "workflow-execution",
        "signal-handler"
      ],
      "concepts": [
        "continue-as-new",
        "update-handler",
        "signal-handler",
        "workflow-completion",
        "exception-handling",
        "control-flow"
      ],
      "severity": "low",
      "userImpact": "Users who want to use Continue-as-New patterns in update handlers are unable to do so, limiting workflow control flow options.",
      "rootCause": "Design decision: continue-as-new from update handlers creates ambiguity when both the workflow method and update handler complete in the same workflow task.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Decided against implementation. For languages where continue-as-new is an exception, it will be treated like any other exception or may eagerly fail.",
      "related": [
        439,
        161
      ],
      "keyQuote": "We have since decided against doing this. In languages where continue as new is an exception, may just want to treat it like any other exception the user may raise",
      "number": 379,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:42.496Z"
    },
    {
      "summary": "Feature request to add built-in timer jitter utility to SDKs. Users currently must implement their own jitter functions to prevent large numbers of timers from firing simultaneously, which often leads to non-deterministic issues.",
      "category": "feature",
      "subcategory": "timer-utilities",
      "apis": [],
      "components": [
        "timer",
        "workflow-execution",
        "sdk-utilities"
      ],
      "concepts": [
        "jitter",
        "determinism",
        "timer-coordination",
        "performance",
        "concurrency",
        "scheduling"
      ],
      "severity": "medium",
      "userImpact": "Users must implement custom jitter logic for timers at scale, risking non-deterministic behavior and increased complexity.",
      "rootCause": null,
      "proposedFix": "Add a jitter parameter to timer creation APIs in SDKs that ensures deterministic jitter application.",
      "workaround": "Users can create their own jitter functions, though this risks non-determinism.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users currently have to create their own jitter functions which can often lead to non-deterministic issues.",
      "number": 378,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:27.769Z"
    },
    {
      "summary": "Request for a first-class way to disable StartToClose and ScheduleToClose timeouts in Activities to support indefinitely running Activities that execute until explicitly canceled.",
      "category": "feature",
      "subcategory": "activity-timeout",
      "apis": [
        "StartToClose",
        "ScheduleToClose"
      ],
      "components": [
        "activity-executor",
        "timeout-manager",
        "activity-options"
      ],
      "concepts": [
        "timeout",
        "activity-lifecycle",
        "cancellation",
        "duration",
        "long-running-operations"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily express indefinitely running Activities without using awkward workarounds like ChronoUnit.FOREVER that throw exceptions.",
      "rootCause": "SDK API design requires explicit durations for all timeout options; no first-class support for \"run until canceled\" pattern.",
      "proposedFix": "Provide a convenient Duration \"MAX\" type compatible with Temporal or allow timeout options to remain unspecified.",
      "workaround": "Use ChronoUnit.FOREVER or set an effectively unreachable max duration value.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        397
      ],
      "keyQuote": "Temporal is really good at this use case, other than a bit of awkwardness around expressing it.",
      "number": 377,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:27.524Z"
    },
    {
      "summary": "Request to add metrics for tracking payload sizes of workflow/activity input/output/signals to help users monitor approaching the 2MB size limit before hitting it, with optional logging for which workflow IDs and events are approaching the limit.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "payload-handling",
        "monitoring"
      ],
      "concepts": [
        "payload-size",
        "limit-monitoring",
        "threshold-alerting",
        "workflow-execution",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Users can proactively monitor payload sizes and redesign applications before hitting the 2MB size limit, improving operational visibility.",
      "rootCause": null,
      "proposedFix": "Add a metric like `history_event_payload_size` and optionally log workflow IDs and events approaching size limits",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal enforce 2MB size limit by default. But it would be too late when users run into this. It will be better to let user set up a monitor on the size with a lower threshold like 1MB",
      "number": 376,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:29.420Z"
    },
    {
      "summary": "User requests guidance on using Temporal with Elixir through community SDKs. Asks for either a maintained list of community SDK implementations or documentation on generating unofficial clients from gRPC definitions.",
      "category": "feature",
      "subcategory": "community-sdks",
      "apis": [],
      "components": [
        "grpc-api",
        "sdk-ecosystem",
        "documentation"
      ],
      "concepts": [
        "community-contribution",
        "sdk-implementation",
        "protobuf-generation",
        "language-support",
        "grpc-client"
      ],
      "severity": "low",
      "userImpact": "Users evaluating Temporal with unsupported languages lack clear guidance on using community SDKs or generating unofficial clients from gRPC definitions.",
      "rootCause": null,
      "proposedFix": "Maintain a list of working/popular community SDKs/wrappers or publish documentation on generating unofficial clients from gRPC definitions",
      "workaround": "Use existing community wrappers like temporalio.ex for Elixir, or manually generate gRPC clients from the Temporal API repository",
      "resolution": "wontfix",
      "resolutionDetails": "Resolved by pointing to awesome-temporal repository for community SDK list and noting that protobuf generation guide is the extent of official support; detailed SDK guide is beyond scope",
      "related": [
        266
      ],
      "keyQuote": "it would be cool if the Temporal team could either maintain a list of working/popular community SDKs/wrappers that the community could contribute to",
      "number": 373,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:13.409Z"
    },
    {
      "summary": "Add an end-to-end test for Eager Workflow Start (EWS) in Cloud that verifies the first workflow task is eagerly dispatched to a local worker without matching delays or database round trips.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "worker",
        "cloud-deployment",
        "test-framework",
        "task-dispatch"
      ],
      "concepts": [
        "eager-dispatch",
        "latency-optimization",
        "workflow-start",
        "e2e-testing",
        "task-matching",
        "local-worker"
      ],
      "severity": "medium",
      "userImpact": "Users running Temporal Cloud workflows need verification that eager workflow start optimization works correctly to reduce first-task latency.",
      "rootCause": null,
      "proposedFix": "Reuse client connection for starter and worker, initiate workflow with eager flag set to true, verify first task is immediately returned without retries.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test was implemented to validate eager workflow start functionality in Cloud environment.",
      "related": [
        242
      ],
      "keyQuote": "EWS in Cloud is currently blocked on the need of an end-to-end test that demonstrates that the first workflow task is eagerly dispatched to a local worker.",
      "number": 368,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:14.427Z"
    },
    {
      "summary": "Security vulnerability CVE-2023-39325 (CVSS 7.5) in golang.org/x/net v0.14.0 transitive dependency causes excessive server resource consumption through malicious HTTP/2 client requests. The vulnerability affects go.temporal.io/api-v1.24.0 with no direct remediation available in the direct dependency.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "go-mod",
        "http2-server",
        "grpc",
        "dependency-management"
      ],
      "concepts": [
        "security-vulnerability",
        "http2",
        "denial-of-service",
        "resource-exhaustion",
        "transitive-dependency",
        "cvss-score"
      ],
      "severity": "high",
      "userImpact": "Applications using go.temporal.io/api-v1.24.0 are vulnerable to denial-of-service attacks through malicious HTTP/2 client connections that can cause excessive server resource consumption.",
      "rootCause": "HTTP/2 servers using golang.org/x/net v0.14.0 do not properly bound the number of simultaneously executing handler goroutines, allowing attackers to reset in-progress requests and create new ones to exhaust server resources.",
      "proposedFix": "Upgrade golang.org/x/net to v0.17.0 or later, or upgrade Go to version 1.20.10 or 1.21.3+",
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory.",
      "related": [],
      "keyQuote": "A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption.",
      "number": 367,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:59:12.026Z"
    },
    {
      "summary": "Two vulnerabilities detected in transitive dependencies of xunit.assert 2.5.3 used in the .NET SDK features project. CVE-2019-0820 (severity 7.5) affects System.Text.RegularExpressions 4.3.0 causing denial of service, and CVE-2018-8292 (severity 5.3) affects System.Net.Http 4.3.0 exposing authentication information in redirects.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "system.text.regularexpressions",
        "system.net.http",
        "xunit.assert",
        "netstandard.library"
      ],
      "concepts": [
        "security vulnerability",
        "dependency management",
        "denial of service",
        "information disclosure",
        "transitive dependency"
      ],
      "severity": "high",
      "userImpact": "Users of the .NET SDK are exposed to security vulnerabilities through transitive dependencies that could lead to denial of service attacks or authentication credential exposure.",
      "rootCause": "Outdated transitive dependencies (System.Text.RegularExpressions 4.3.0 and System.Net.Http 4.3.0) pulled in by xunit.assert 2.5.3 contain known security vulnerabilities.",
      "proposedFix": "Upgrade System.Text.RegularExpressions to 4.3.1 and System.Net.Http to 4.3.4 or newer versions that contain the security fixes.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A denial of service vulnerability exists when .NET Framework and .NET Core improperly process RegEx strings",
      "number": 366,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:58.045Z"
    },
    {
      "summary": "gRPC message size limits cause task completion failures when completing many medium-payload activities in a single task. The proposed solution is to implement multi-RPC partial task completion support.",
      "category": "feature",
      "subcategory": "task-completion",
      "apis": [],
      "components": [
        "task-completion",
        "grpc",
        "activity-executor"
      ],
      "concepts": [
        "message-size-limit",
        "partial-completion",
        "multi-rpc",
        "payload-handling",
        "grpc-protocol"
      ],
      "severity": "high",
      "userImpact": "Users cannot complete tasks with many medium-payload activities due to gRPC message size constraints.",
      "rootCause": "gRPC has a maximum message size limit that is exceeded when task completion includes many medium-input-payload activities.",
      "proposedFix": "Implement support for multi-RPC partial task completion to allow completion messages to be split across multiple RPC calls.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Task completion of many medium-input-payload activities in one task will cause issue with gRPC max message size.",
      "number": 363,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:55.241Z"
    },
    {
      "summary": "The features harness for TypeScript doesn't provide an API for feature authors to configure client interceptors in WorkflowClientOptions, unlike the Go implementation which allows passing client options when instantiating the feature.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowClientOptions"
      ],
      "components": [
        "features-harness",
        "typescript-sdk",
        "client-configuration"
      ],
      "concepts": [
        "client-interceptors",
        "configuration",
        "feature-testing",
        "api-consistency",
        "harness-api"
      ],
      "severity": "medium",
      "userImpact": "Feature authors cannot configure client interceptors when writing tests for the TypeScript SDK, limiting their ability to test interceptor functionality.",
      "rootCause": "The features harness instantiates the client without exposing a way to pass client options, unlike the Go implementation.",
      "proposedFix": "Add an API to the TypeScript features harness to allow passing client options (including interceptors) when instantiating the feature, similar to the Go implementation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently, the features harness for Typescript instantiates the client when instantiating the runner, and no API is available to feature authors for passing client options.",
      "number": 353,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:54.520Z"
    },
    {
      "summary": "HTTP/2 vulnerability (CVE-2023-39325) in golang.org/x/net-v0.14.0 affecting gRPC-v1.57.0 allows malicious clients to consume excessive server resources through rapid request creation and reset. The issue was auto-closed as the vulnerable library was removed from the dependency inventory.",
      "category": "bug",
      "subcategory": "security-vulnerability",
      "apis": [],
      "components": [
        "grpc",
        "http2",
        "golang.org/x/net",
        "dependency-management"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "denial-of-service",
        "resource-exhaustion",
        "http2",
        "stream-concurrency",
        "dependency-upgrade"
      ],
      "severity": "high",
      "userImpact": "Users running features service are vulnerable to DoS attacks that can exhaust server resources through malicious HTTP/2 clients creating and resetting requests rapidly.",
      "rootCause": "golang.org/x/net-v0.14.0 does not properly bound simultaneously executing HTTP/2 handler goroutines to the stream concurrency limit, allowing attackers to exhaust resources.",
      "proposedFix": "Upgrade golang.org/x/net to v0.17.0 or use go1.20.10/go1.21.3+. HTTP/2 servers should bound handler goroutines to MaxConcurrentStreams and queue excess requests.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Automatically closed as the vulnerable library (golang.org/x/net-v0.14.0) was removed from the Mend dependency inventory.",
      "related": [],
      "keyQuote": "A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption.",
      "number": 352,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:40.366Z"
    },
    {
      "summary": "Request to expose AdminService API in SDKs for programmatic access to internal admin operations like task refresh. Team decided this cannot be exposed as it's internal server API, but users can generate gRPC clients or use the Go server as a library as a workaround.",
      "category": "feature",
      "subcategory": "admin-api",
      "apis": [],
      "components": [
        "sdk",
        "admin-service",
        "grpc-client"
      ],
      "concepts": [
        "internal-api",
        "admin-operations",
        "task-refresh",
        "workflow-execution",
        "server-api"
      ],
      "severity": "medium",
      "userImpact": "Users needing programmatic access to admin operations like task refresh must use workarounds instead of a standardized SDK interface.",
      "rootCause": "AdminService is an internal server API not exposed through the official public API repository (temporalio/api), so SDKs cannot officially support it.",
      "proposedFix": "Expose refresh task API or other needed admin operations through the public Temporal API (temporalio/api repo) if the team decides to support them officially.",
      "workaround": "Users can generate gRPC client from protos directly, call temporal CLI programmatically, or for Go use 'import \"go.temporal.io/server/api/adminservice/v1\"' with a gRPC connection.",
      "resolution": "wontfix",
      "resolutionDetails": "Team decided AdminService cannot be exposed in SDKs as it's internal server API. Workarounds provided instead.",
      "related": [],
      "keyQuote": "Our SDKs only support official API at https://github.com/temporalio/api, but that API is internal API that we happened to expose previously",
      "number": 348,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:43.602Z"
    },
    {
      "summary": "Feature request to add worker pause/unpause functionality that allows workers to stop polling for new work without shutting down, useful for scenarios like managing resource constraints dynamically.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "Worker.pause",
        "Worker.unpause"
      ],
      "components": [
        "worker",
        "task-poller",
        "worker-lifecycle"
      ],
      "concepts": [
        "polling",
        "resource-management",
        "graceful-pause",
        "concurrent-work-limits"
      ],
      "severity": "low",
      "userImpact": "Users need ability to temporarily stop workers from accepting new work without full shutdown for dynamic resource management.",
      "rootCause": null,
      "proposedFix": "Add pause() and unpause() methods on the worker, possibly with a method to check pause state",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "People want to finish work but stop their workers from accepting more work for whatever reason.",
      "number": 343,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:40.321Z"
    },
    {
      "summary": "Feature request to allow SDKs to create Schedule specs from JSON structures (like tctl uses) instead of requiring cumbersome object construction. This would enable consistent schedule definitions across languages, easier configuration management, and reduced risk of misconfiguration.",
      "category": "feature",
      "subcategory": "schedule-creation",
      "apis": [
        "ScheduleSpec"
      ],
      "components": [
        "schedule-sdk",
        "schedule-parser",
        "schedule-api"
      ],
      "concepts": [
        "schedule-configuration",
        "json-deserialization",
        "cross-sdk-consistency",
        "configuration-management",
        "declarative-definition"
      ],
      "severity": "medium",
      "userImpact": "Users must write verbose, language-specific code to define schedules instead of using simple JSON, making it harder to maintain consistency across SDKs and languages.",
      "rootCause": "SDKs lack a method to deserialize schedule specifications from JSON format, forcing users to construct objects programmatically with verbose builder patterns.",
      "proposedFix": "Add methods like ScheduleSpec.fromJson(json) to all SDKs that parse JSON schedule specifications (matching tctl's format) and construct the appropriate ScheduleSpec objects.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Merged with issue #118 which is tracking the ability to create schedules from declarative languages (YAML/JSON) with a unified format across all SDKs.",
      "related": [
        118
      ],
      "keyQuote": "This would allow for potential extraction of schedule definition to a config file, meaning source code doesn't need to be changed whilst making changes to a schedule.",
      "number": 341,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:26.056Z"
    },
    {
      "summary": "Feature request to simplify encryption setup in Temporal SDKs by providing built-in codec helpers. Users find the current encryption implementation complex and would prefer a more plug-and-play approach with just key and algorithm configuration.",
      "category": "feature",
      "subcategory": "encryption",
      "apis": [],
      "components": [
        "codec",
        "client",
        "encryption"
      ],
      "concepts": [
        "encryption",
        "security",
        "codec",
        "configuration",
        "key-management",
        "plugin-architecture"
      ],
      "severity": "medium",
      "userImpact": "Users struggle with complex encryption setup and seek simpler, more accessible SDK-provided encryption features.",
      "rootCause": null,
      "proposedFix": "Add SDK-provided encryption codec with simplified configuration (key and algorithm parameters), possibly with optional codec server deployment.",
      "workaround": "Users can follow the existing example in samples-typescript repository for encryption setup.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It feelsâ€¦ like a lot of setup. Am I missing something? Is there nothing more plug-and-play that we can use?",
      "number": 339,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:25.957Z"
    },
    {
      "summary": "Feature request to add a delay/start delay field to workflow start options, allowing workflows to be scheduled to start at a future time. This capability exists in the Temporal API but is missing from SDK workflow options across all language SDKs.",
      "category": "feature",
      "subcategory": "workflow-start-options",
      "apis": [
        "StartWorkflow",
        "WorkflowOptions",
        "SignalWithStart"
      ],
      "components": [
        "workflow-client",
        "workflow-options",
        "start-delay"
      ],
      "concepts": [
        "scheduling",
        "delayed-execution",
        "start-time",
        "workflow-lifecycle",
        "timing-control"
      ],
      "severity": "medium",
      "userImpact": "Users cannot schedule workflows to start at a future time, limiting scheduling flexibility and requiring workarounds.",
      "rootCause": null,
      "proposedFix": "Add a new field to WorkflowOptions named 'startDelay' or 'delayStartBy' to specify the delay before workflow execution begins.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1243,
        1863,
        1262,
        404,
        145
      ],
      "keyQuote": "I think \"start delay\" is the simplest yet clearest terminology for this across languages. Also note, this applies to signal-with-start too",
      "number": 338,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:22.592Z"
    },
    {
      "summary": "Feature request to implement typed search attributes across all Temporal SDKs (Go, Java, TypeScript, Python, .NET, PHP). This enhancement provides type-safe search attribute handling following a cross-SDK proposal.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [
        "SearchAttributes",
        "UpsertSearchAttributes"
      ],
      "components": [
        "search-attributes",
        "workflow-info",
        "client-api",
        "type-safety"
      ],
      "concepts": [
        "type-safety",
        "search-attributes",
        "workflow-metadata",
        "api-design",
        "cross-sdk-consistency",
        "deprecation"
      ],
      "severity": "medium",
      "userImpact": "Enables developers to use type-safe search attributes across all SDKs, though migration from deprecated APIs can be challenging without clear documentation and examples.",
      "rootCause": null,
      "proposedFix": "Implement typed search attributes API across all SDK implementations following the provided proposal specification.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was successfully implemented across all six SDK implementations (Go, Java, TypeScript, Python, .NET, PHP) as tracked by completed checkboxes.",
      "related": [
        1218,
        1855,
        1232,
        381,
        132,
        516
      ],
      "keyQuote": "ensure that there are code samples included with major feature PRs (especially when deprecating old APIs)",
      "number": 336,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:07.085Z"
    },
    {
      "summary": "Feature request for worker auto-tuning to maximize resource utilization by automatically configuring worker slots and polling parameters. Design still needs to be finalized with implementations planned across all SDKs (Go, Java, Core, TypeScript, Python, .NET).",
      "category": "feature",
      "subcategory": "worker-performance",
      "apis": [],
      "components": [
        "worker",
        "poller",
        "slot-management",
        "resource-utilization"
      ],
      "concepts": [
        "auto-tuning",
        "resource-optimization",
        "worker-configuration",
        "polling",
        "performance-tuning",
        "load-balancing"
      ],
      "severity": "high",
      "userImpact": "Users currently require manual worker tuning with inconsistent behavior across SDKs, creating significant operational burden for dev teams.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1322,
        1956,
        662
      ],
      "keyQuote": "this is quite a pain point for customersâ€”dev-success folks are having to help out a lot with tuning, and having differences in behavior/semantics across different SDKs is only making things harder",
      "number": 334,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:07.904Z"
    },
    {
      "summary": "Two security vulnerabilities (CVE-2019-0205 and CVE-2019-0210) were discovered in the Apache Thrift library (version 0.12.0 and earlier) as a transitive dependency through uber-go/tally. Both vulnerabilities have high severity (CVSS 7.5) and affect availability.",
      "category": "bug",
      "subcategory": "security",
      "apis": [],
      "components": [
        "dependency-management",
        "build-process"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-security",
        "denial-of-service",
        "Apache-Thrift",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Users of the features repository are exposed to denial-of-service vulnerabilities in Apache Thrift through the uber-go/tally transitive dependency.",
      "rootCause": "Apache Thrift versions up to 0.12.0 have vulnerabilities that cause endless loops or panics when fed with specific or invalid input data in JSON protocol implementations.",
      "proposedFix": "Upgrade Apache Thrift to version 0.13.0 or later.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "The issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory in the specific branch(es).",
      "related": [],
      "keyQuote": "This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.",
      "number": 333,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:58:10.418Z"
    },
    {
      "summary": "Feature request to implement codec support for headers across all SDKs. Currently, .NET and Ruby SDKs support this, but Go, Java, TypeScript, and Python need investigation or implementation to align behavior.",
      "category": "feature",
      "subcategory": "codec-headers",
      "apis": [],
      "components": [
        "codec-system",
        "headers",
        "sdk-core"
      ],
      "concepts": [
        "codecs",
        "headers",
        "cross-sdk-compatibility",
        "data-serialization",
        "encoding"
      ],
      "severity": "medium",
      "userImpact": "Users across different SDKs have inconsistent header encoding behavior, requiring manual codec application in some languages.",
      "rootCause": null,
      "proposedFix": "Implement codec support for headers in Go, Java, TypeScript, and Python SDKs to match .NET and Ruby implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        514,
        925
      ],
      "keyQuote": "We need to align behavior with what we're doing in .Net and Ruby.",
      "number": 331,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:50.656Z"
    },
    {
      "summary": "The 'bugs/go/child_workflow_cancel_panic' feature test flakes intermittently with a nondeterministic workflow error during replay. The error indicates an extra CancelTimer command is being replayed, causing the test to fail.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "workflow-worker",
        "replay-engine",
        "timer-management"
      ],
      "concepts": [
        "flakiness",
        "nondeterministic",
        "replay",
        "child-workflow",
        "cancellation",
        "timer"
      ],
      "severity": "medium",
      "userImpact": "Test suite experiences intermittent failures, making it difficult to validate child workflow cancellation behavior in Go SDK.",
      "rootCause": "Extra replay command for CancelTimer is being executed during workflow replay, indicating a mismatch between recorded history and replay execution logic.",
      "proposedFix": null,
      "workaround": null,
      "related": [
        329
      ],
      "resolution": null,
      "resolutionDetails": null,
      "keyQuote": "nondeterministic workflow: extra replay command for CancelTimer: (TimerId:5)",
      "number": 330,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:52.384Z"
    },
    {
      "summary": "Standardize gRPC retry periods across all Temporal SDKs to handle namespace migrations and ensure consistent behavior. Currently, retry durations vary significantly between SDKs (TypeScript Client: ~2s, Java Client: 60s), and some SDKs don't retry initial connections.",
      "category": "feature",
      "subcategory": "grpc-retry",
      "apis": [],
      "components": [
        "client",
        "grpc-retry",
        "connection-management"
      ],
      "concepts": [
        "retry",
        "connection",
        "timeout",
        "namespace-migration",
        "unavailability",
        "latency",
        "error-recovery"
      ],
      "severity": "high",
      "userImpact": "Inconsistent retry behavior across SDKs can lead to unexpected failures during namespace migrations or transient outages, affecting application reliability and cloud deployment experience.",
      "rootCause": "Each SDK has independently implemented retry logic with different strategies, thresholds, and coverage (some don't retry initial connections).",
      "proposedFix": "Establish unified default retry period of at least 10s + buffer across all SDKs, coordinate with Server and Cloud teams on expected behavior, and ensure all SDKs retry initial connections.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        27
      ],
      "keyQuote": "Figure out what default retry period we want Clients to have & apply it across the board. IMO it should be at least 10s + some buffer.",
      "number": 326,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:49.716Z"
    },
    {
      "summary": "Support passing and retrieving reason/details for both Terminate and Cancel workflow APIs. Currently, Terminate allows passing a reason that is stored in the terminate event, but the Client cannot retrieve it; Cancel doesn't support reasons at all.",
      "category": "feature",
      "subcategory": "workflow-lifecycle",
      "apis": [
        "TerminateWorkflow",
        "CancelWorkflow",
        "GetWorkflowResult"
      ],
      "components": [
        "client",
        "workflow-api",
        "workflow-execution"
      ],
      "concepts": [
        "workflow-termination",
        "workflow-cancellation",
        "error-details",
        "api-consistency",
        "user-feedback"
      ],
      "severity": "medium",
      "userImpact": "Users cannot pass or retrieve reason information when terminating or canceling workflows, making it harder to track why workflows were stopped.",
      "rootCause": null,
      "proposedFix": "Extend both Terminate and Cancel APIs to accept a reason/details parameter, and allow retrieving this information when getting workflow results through WorkflowFailure.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Passing a reason/details [and] Get the reason/details back when getting the workflow result(WorkflowFailure)",
      "number": 325,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:37.804Z"
    },
    {
      "summary": "Feature request to add HTTP CONNECT proxy support across Temporal SDKs. Most SDKs already have support but need documentation; TypeScript and .NET implementations are still pending.",
      "category": "feature",
      "subcategory": "networking-http-proxy",
      "apis": [],
      "components": [
        "http-client",
        "proxy-configuration",
        "grpc-transport"
      ],
      "concepts": [
        "http-proxy",
        "connect-method",
        "networking",
        "client-configuration",
        "worker-setup",
        "sdk-integration"
      ],
      "severity": "medium",
      "userImpact": "Users need HTTP CONNECT proxy support for SDK clients and workers, which is currently missing or undocumented in some SDKs.",
      "rootCause": null,
      "proposedFix": "Implement HTTP CONNECT proxy support in TypeScript and .NET SDKs; document existing support in Go and Java; align with Core SDK implementation",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        501,
        714,
        215,
        521,
        448,
        5279
      ],
      "keyQuote": "Users need HTTP CONNECT proxies for SDK clients and workers. Some libraries have native support, some don't.",
      "number": 323,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:35.006Z"
    },
    {
      "summary": "Feature request to allow users configure which exception types should fail workflows versus tasks across SDKs. Go and Java partially implement this; Java, TypeScript, and Python still need worker-level configuration options.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "WorkflowPanicPolicy",
        "RegisterOptions",
        "WorkerOptions",
        "WorkflowImplementationOptions",
        "WorkerConfig",
        "WorkflowAttribute"
      ],
      "components": [
        "worker",
        "workflow-execution",
        "error-handling",
        "task-failure"
      ],
      "concepts": [
        "exception-types",
        "failure-handling",
        "nondeterminism",
        "workflow-failure",
        "task-failure",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot consistently control which exceptions fail the entire workflow versus just the current task, leading to different failure semantics across SDKs.",
      "rootCause": "Inconsistent implementation across SDKs of which exception types should trigger workflow-level failures rather than task failures.",
      "proposedFix": "Add configurable exception type options to Worker and Workflow definition APIs across all SDKs (Go, Java, TS, Python, .NET, Core).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1387,
        1987,
        656,
        1358,
        446,
        166
      ],
      "keyQuote": "We need to let users choose what fails the workflow vs what just fails the task today. Go and Java already have some form of this.",
      "number": 322,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:37.578Z"
    },
    {
      "summary": "Add SDK name and version metadata to workflow tasks, similar to the client-name and client-version gRPC headers. This allows tracking which SDK version processed each task.",
      "category": "feature",
      "subcategory": "metadata",
      "apis": [],
      "components": [
        "workflow-task",
        "sdk-metadata",
        "grpc-headers"
      ],
      "concepts": [
        "sdk-version",
        "metadata",
        "task-tracking",
        "client-identification",
        "sdk-compatibility"
      ],
      "severity": "low",
      "userImpact": "Users can identify which SDK version created each workflow task for better debugging and monitoring.",
      "rootCause": null,
      "proposedFix": "Set SDK name and version on workflow task proto when values change from previous version, mirroring the client-name and client-version gRPC headers approach.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across API, Go SDK, Java SDK, and SDK Core with coordinated updates to propagate SDK metadata through the system.",
      "related": [
        306,
        1194,
        1838,
        588
      ],
      "keyQuote": "Add the same value we do on `client-name` and `client-version` gRPC header on the workflow task.",
      "number": 321,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:22.000Z"
    },
    {
      "summary": "Stale workflows are accumulating in the sdk-ci.a2dd6 namespace and need cleanup. Additionally, a reasonable schedule-to-close timeout (e.g., 1 day) should be set on all workflows to prevent future accumulation.",
      "category": "bug",
      "subcategory": "test-infrastructure",
      "apis": [],
      "components": [
        "test-workflow-execution",
        "workflow-timeout",
        "namespace-management"
      ],
      "concepts": [
        "workflow-cleanup",
        "stale-workflows",
        "schedule-to-close-timeout",
        "test-stability",
        "resource-management"
      ],
      "severity": "medium",
      "userImpact": "Accumulating stale workflows in the test namespace can degrade test infrastructure performance and consume resources.",
      "rootCause": "Missing schedule-to-close timeout on workflows allows them to accumulate indefinitely in the sdk-ci.a2dd6 namespace.",
      "proposedFix": "Set a reasonable schedule-to-close timeout (1 day) on all workflows and clean up existing stale workflows.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "set a reasonable schedule-to-close timeout on all workflows (say, 1 day)",
      "number": 315,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:23.269Z"
    },
    {
      "summary": "Feature request for a non-blocking method to check workflow result status. Users currently must wait for `workflowHandle.result()` to complete; they need a way to make a single request that returns immediately with an error if the workflow hasn't completed yet.",
      "category": "feature",
      "subcategory": "workflow-result-handling",
      "apis": [
        "workflowHandle.result()"
      ],
      "components": [
        "client",
        "workflow-handle",
        "result-retrieval"
      ],
      "concepts": [
        "non-blocking",
        "polling",
        "workflow-completion",
        "result-status",
        "error-handling"
      ],
      "severity": "low",
      "userImpact": "Users need an alternative to blocking result retrieval for use cases where they want to check workflow status without waiting for completion.",
      "rootCause": null,
      "proposedFix": "Add a `tryGettingResult()` method that makes a single request and throws a `WorkflowIncomplete` error if no result is available, or returns the result if the workflow is complete.",
      "workaround": "Call raw `GetWorkflowHistory` with filter type set to close event and long poll set to false, then manually translate the completed event.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A method that makes a single request and throws/returns an error if no result.",
      "number": 314,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:20.943Z"
    },
    {
      "summary": "Feature request to prevent workflow commands from being produced in read-only contexts (query handlers and update validators). Should fail the workflow task gracefully through language-appropriate errors (panic in Go, exceptions in Java) rather than failing the entire workflow.",
      "category": "feature",
      "subcategory": "workflow-validation",
      "apis": [],
      "components": [
        "query-handler",
        "update-validator",
        "workflow-task-processor"
      ],
      "concepts": [
        "read-only-context",
        "command-blocking",
        "error-handling",
        "workflow-execution",
        "validation"
      ],
      "severity": "medium",
      "userImpact": "Prevents silent failures and unexpected behavior when developers accidentally issue workflow commands in read-only contexts.",
      "rootCause": null,
      "proposedFix": "Implement language-appropriate blocking mechanisms: panic in Go, throw exceptions in Java, with graceful workflow task failure rather than full workflow failure.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1000,
        1748
      ],
      "keyQuote": "Block users, in some language appropriate way, from producing workflow commands in a read only context",
      "number": 305,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:04.462Z"
    },
    {
      "summary": "Prototype pollution vulnerability in protobufjs 7.1.2 (CVE-2023-36665) with CVSS 5.5 severity, allowing attackers to pollute Object.prototype through untrusted protobuf messages.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "protobufjs",
        "package-dependencies",
        "npm-dependencies"
      ],
      "concepts": [
        "security",
        "prototype-pollution",
        "dependency-vulnerability",
        "code-execution",
        "untrusted-input",
        "object-pollution"
      ],
      "severity": "medium",
      "userImpact": "Applications using protobufjs 7.1.2 are vulnerable to prototype pollution attacks that could lead to availability impact through untrusted protobuf message processing.",
      "rootCause": "protobufjs versions 6.10.0 through 7.x before 7.2.4 lack proper validation when parsing untrusted protobuf messages, allowing modification of Object.prototype via constructor property.",
      "proposedFix": "Upgrade protobufjs to version 7.2.4 or later",
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Issue was automatically closed by Mend dependency scanner because the vulnerable library was either marked as ignored or removed from the inventory in the specified branch.",
      "related": [],
      "keyQuote": "protobuf.js allows Prototype Pollution via user-controlled protobuf messages by adding and overwriting Object.prototype data and functions",
      "number": 304,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:06.582Z"
    },
    {
      "summary": "Tracking cross-SDK implementation of Workflow Update feature for public preview. This meta-issue tracks the feature across Go, Java, TypeScript, Python, .NET, PHP, and Ruby SDKs, including critical requirements for determinism when replaying updates.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "HandleWorkflowUpdate",
        "StartWorkflow"
      ],
      "components": [
        "workflow-update-handler",
        "workflow-replay",
        "history-replay",
        "test-framework"
      ],
      "concepts": [
        "workflow-update",
        "determinism",
        "replay",
        "history-matching",
        "lazy-registration",
        "nondeterminism-detection"
      ],
      "severity": "high",
      "userImpact": "SDKs must correctly implement workflow update handling to support this new feature across all Temporal SDKs, particularly ensuring deterministic replay behavior.",
      "rootCause": "SDKs need to ensure workflow function runs at least once during replay before processing updates to allow update handler registration, preventing false nondeterminism errors when replaying with canned histories.",
      "proposedFix": "SDKs should avoid lazy update handler registration; instead ensure workflow function executes first during replay to register handlers before processing update jobs in activation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature successfully implemented across all tracked SDKs (Go, Java, TypeScript, Python, .NET, PHP, Ruby)",
      "related": [
        1160,
        336,
        100,
        323,
        141
      ],
      "keyQuote": "If the SDK supports lazily registering update handlers... the SDK must take care to ensure that the workflow function is run at least once first so that the update handler has a chance to be registered.",
      "number": 296,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:57:09.198Z"
    },
    {
      "summary": "Public preview of the Safe Deploys API for worker versioning, enabling safe deployment of workflow and activity code changes across all Temporal SDKs.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "worker",
        "versioning",
        "deployment"
      ],
      "concepts": [
        "safe-deploy",
        "worker-versioning",
        "code-deployment",
        "compatibility",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Enables users to safely deploy workflow and activity code changes without breaking running workflows across all SDK implementations.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        335,
        99,
        322,
        140
      ],
      "keyQuote": "Safe Deploys API - Public Preview",
      "number": 294,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:53.103Z"
    },
    {
      "summary": "Feature request to expose UpdateID in workflow update handlers, allowing users to access the unique identifier of an update request within handler logic for use cases like continue-as-new, targeted update cancellation, and business process tracking.",
      "category": "feature",
      "subcategory": "update-handler",
      "apis": [
        "SetUpdateHandlerWithOptions",
        "GetUpdateInfo"
      ],
      "components": [
        "workflow-update",
        "update-handler",
        "workflow-context"
      ],
      "concepts": [
        "update-id",
        "handler-context",
        "update-request",
        "workflow-state",
        "continue-as-new"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently access the UpdateID within update handlers, limiting their ability to track specific updates or perform update-dependent operations.",
      "rootCause": null,
      "proposedFix": "Add GetUpdateInfo(ctx) function similar to existing GetWorkflowInfo/GetActivityInfo that returns UpdateID and potentially other update metadata; also consider exposing UpdateID in interceptors.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1317
      ],
      "keyQuote": "Add a way for users to obtain an update requests `UpdateID` in a handler.",
      "number": 293,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:50.869Z"
    },
    {
      "summary": "Feature request to add test cases demonstrating update deduplication in Java and Go SDKs. Updates with duplicate IDs targeting the same workflow should only execute once.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "workflow-update",
        "test-framework",
        "sdk-java",
        "sdk-go"
      ],
      "concepts": [
        "deduplication",
        "idempotency",
        "update-handler",
        "workflow-state",
        "duplicate-detection"
      ],
      "severity": "low",
      "userImpact": "Developers need test examples to understand and verify that update deduplication works correctly in their applications.",
      "rootCause": null,
      "proposedFix": "Add Java and Go feature tests that demonstrate update deduplication behavior",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implementation was completed to add update deduplication tests to Java and Go SDKs",
      "related": [],
      "keyQuote": "Updates that reuse the update ID, and target the same workflow, should only be performed once.",
      "number": 290,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:52.040Z"
    },
    {
      "summary": "Guava 31.1-jre contains a high-severity vulnerability (CVE-2023-2976) in FileBackedOutputStream that allows unauthorized file access via the shared Java temporary directory on Unix systems. Upgrade to version 32.0.1-android to resolve.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "build-gradle",
        "file-handling"
      ],
      "concepts": [
        "security-vulnerability",
        "temporary-files",
        "privilege-escalation",
        "file-permissions",
        "unix-systems",
        "dependency-upgrade"
      ],
      "severity": "high",
      "userImpact": "Users of temporalio-features are exposed to a high-severity vulnerability that could allow other users on the system to access files created by the Java application.",
      "rootCause": "Java's default temporary directory in Guava 31.1-jre lacks proper file access restrictions, allowing other users and apps with access to the temp directory to read files created by FileBackedOutputStream.",
      "proposedFix": "Upgrade Guava from 31.1-jre to 32.0.1-android (or later), which fixes the vulnerability.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Use of Java's default temporary directory for file creation in FileBackedOutputStream in Google Guava versions 1.0 to 31.1 on Unix systems allows other users and apps on the machine to access the files created.",
      "number": 288,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:39.956Z"
    },
    {
      "summary": "The features harness history checker breaks on compatible changes like adding new fields to history events. Users need an easy way to mark certain fields as acceptable additions to current history that weren't in stored static history.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "features-harness",
        "history-checker",
        "history-validation"
      ],
      "concepts": [
        "backwards-compatibility",
        "history-replay",
        "schema-evolution",
        "test-validation",
        "field-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users must manually work around false failures when new fields are added to history events, slowing down feature development and maintenance.",
      "rootCause": null,
      "proposedFix": "Add a mechanism to mark certain fields as optional in history validation, allowing them to be present in current history but absent in stored static history.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "An easy way to mark certain fields as \"it's ok if this is present in current history and not in stored static history\"",
      "number": 279,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:36.883Z"
    },
    {
      "summary": "Feature request to fail the entire workflow when a Temporal error occurs in a converter or codec, rather than just failing the individual task. Currently most SDKs only fail the task, but the desired behavior is workflow-level failure.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "converter",
        "codec",
        "workflow-execution",
        "error-handling"
      ],
      "concepts": [
        "error-propagation",
        "workflow-failure",
        "task-failure",
        "data-serialization",
        "error-scope"
      ],
      "severity": "medium",
      "userImpact": "Users experience inconsistent error handling behavior when converters or codecs fail, potentially allowing workflows to continue executing when they should stop.",
      "rootCause": null,
      "proposedFix": "SDKs should be updated to fail the workflow (not just the task) when Temporal errors occur in converters and codecs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1139,
        321
      ],
      "keyQuote": "Need to fail workflow if Temporal error comes back from converter or codec. Today (most) SDKs fail the task.",
      "number": 273,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:35.587Z"
    },
    {
      "summary": "Feature request to add SDK-side metrics for the Update API, including UpdateRejected, UpdateAccepted, UpdateCompletedSuccess, and UpdateCompletedFailure. Discussion centers on whether these metrics are useful enough to add given the existing metric quantity and consistency with other features like signals and queries.",
      "category": "feature",
      "subcategory": "metrics-update",
      "apis": [
        "Update"
      ],
      "components": [
        "metrics",
        "sdk-core",
        "update-api"
      ],
      "concepts": [
        "metrics",
        "observability",
        "update-lifecycle",
        "consistency",
        "feature-parity"
      ],
      "severity": "low",
      "userImpact": "Users would gain visibility into Update API execution patterns through SDK-side metrics, but the team is cautious about adding metrics without clear demand.",
      "rootCause": null,
      "proposedFix": "Implement UpdateRejected, UpdateAccepted, UpdateCompletedSuccess, and UpdateCompletedFailure metrics on the SDK side.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I'm inclined to say we shouldn't add these until we have explicit asks for them. We already have such an overwhelming quantity of metrics.",
      "number": 268,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:20.578Z"
    },
    {
      "summary": "Add feature tests for the update workflow capability across multiple SDK languages (Go, Java, TypeScript, Python, and .NET). Some SDKs already have tests implemented, while others still need them.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "update-workflow",
        "feature-tests"
      ],
      "concepts": [
        "testing",
        "workflow-update",
        "cross-sdk-compatibility",
        "ci-integration"
      ],
      "severity": "medium",
      "userImpact": "Users need comprehensive feature tests for the update workflow across all supported SDK languages to ensure consistent behavior and reliability.",
      "rootCause": "Missing test implementations for update workflow feature in some SDK languages; server version compatibility issues detected in CI",
      "proposedFix": "Implement update workflow feature tests for remaining SDKs (particularly .NET) and ensure server version compatibility",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tests were implemented for Go, Java, TypeScript, and Python. .NET tests remain incomplete but the primary request was addressed.",
      "related": [
        150
      ],
      "keyQuote": "I noticed that the update tests are failing in CI because the server version is too old.",
      "number": 266,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:24.100Z"
    },
    {
      "summary": "Write a specification for graceful worker shutdown behavior that is consistent across all SDKs. Different SDKs currently handle graceful shutdown differently, particularly regarding when activities are canceled and how the grace period is applied.",
      "category": "docs",
      "subcategory": "worker-shutdown",
      "apis": [
        "Worker.run"
      ],
      "components": [
        "worker",
        "activity-executor",
        "shutdown-handler"
      ],
      "concepts": [
        "graceful-shutdown",
        "activity-cancellation",
        "grace-period",
        "SDK-consistency",
        "signal-handling"
      ],
      "severity": "medium",
      "userImpact": "Users experience inconsistent worker shutdown behavior across SDKs, making it difficult to write portable code and potentially causing activity retry delays and operational confusion.",
      "rootCause": "Different SDKs have evolved different interpretations of graceful shutdown semantics, with TypeScript and others treating grace period as a cancellation delay while Go doesn't wait for activities to complete.",
      "proposedFix": "Create a consistent specification for graceful worker shutdown that all SDKs should follow, clarifying when grace periods apply, when activities are canceled, and ensuring all Core-based SDKs wait for activities to complete.",
      "workaround": "See activity-specific error handling and context cancellation patterns documented in Go SDK; can use custom retry logic to handle worker shutdown scenarios.",
      "resolution": "fixed",
      "resolutionDetails": "A specification was developed and documented for consistent graceful worker shutdown behavior across SDKs.",
      "related": [],
      "keyQuote": "By default all Core based SDKs now will wait for activities to complete before returning from Worker.run.",
      "number": 261,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:22.331Z"
    },
    {
      "summary": "Feature request to expose TemporalScheduledStartTime search attribute as a typed datetime in workflow info instead of requiring users to work with string names.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "search-attributes",
        "sdk-api"
      ],
      "concepts": [
        "search-attributes",
        "typed-access",
        "datetime",
        "workflow-metadata"
      ],
      "severity": "low",
      "userImpact": "Users must currently work with string-based search attribute names instead of having language-friendly typed access to TemporalScheduledStartTime.",
      "rootCause": null,
      "proposedFix": "Expose TemporalScheduledStartTime as a typed datetime field in the workflow info API across SDKs.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed in favor of issue #243, which addresses the same requirement.",
      "related": [
        243
      ],
      "keyQuote": "This info is already available as a search attribute, need language-friendly exposure of it instead of requiring they use string names.",
      "number": 258,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:04.433Z"
    },
    {
      "summary": "The Update API currently writes failure events to history even when external calls fail without workflow mutations, causing rapid history bloat. The request is to support a pattern where failed external calls don't generate history events, enabling scalable \"short update\" operations that act like RPCs.",
      "category": "feature",
      "subcategory": "update-api",
      "apis": [
        "UpdateHandler",
        "UpdateHandlerOptions",
        "LocalActivity"
      ],
      "components": [
        "update-handler",
        "history-management",
        "local-activity",
        "state-machine"
      ],
      "concepts": [
        "history-bloat",
        "external-calls",
        "local-activity",
        "update-validation",
        "workflow-state-mutation",
        "scalability",
        "idempotency"
      ],
      "severity": "high",
      "userImpact": "Without this feature, frequent update failures with external calls cause uncontrolled history growth that limits workflow scalability in production systems.",
      "rootCause": "Update API writes all failure events to history regardless of workflow state impact, and replaying to recover from cache invalidation causes significant service load.",
      "proposedFix": "Allow validators or pre-update local activities that execute without persisting history events; if they fail, no state changes occur; if they succeed, results pass to the update handler.",
      "workaround": "Users can call external systems before invoking the Update API and pass results directly, but this requires handling additional edge cases and race conditions.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "this failure event will blow up the history very quickly. Hence this will become a scalability issue to use with Temporal.",
      "number": 257,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:05.692Z"
    },
    {
      "summary": "Feature request to include workflow input in the describe() response. Currently users must separately fetch history and decode payloads to get input parameters; the request proposes adding input as a decoded array to the describe() call response.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "describe",
        "DescribeWorkflow",
        "DescribeWorkflowExecutionResponse"
      ],
      "components": [
        "workflow-client",
        "api-response",
        "history-fetch"
      ],
      "concepts": [
        "workflow-input",
        "payload-decoding",
        "api-convenience",
        "workflow-metadata"
      ],
      "severity": "low",
      "userImpact": "Users currently need to make multiple API calls and manual decoding to retrieve workflow input, making it harder to look up input based on workflow ID.",
      "rootCause": "The describe() API only returns execution metadata but not the input payloads, which are considered part of workflow history rather than basic execution information.",
      "proposedFix": "Either: (1) Have describe() call both DescribeWorkflow and fetch history to return input, or (2) Have the server add input field to DescribeWorkflowExecutionResponse",
      "workaround": "Call describe() and then separately fetch history and decode payloads manually",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We offer users the ability to do describe and history fetch, we don't need to combine the calls for them.",
      "number": 256,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:56:01.992Z"
    },
    {
      "summary": "The temporalio-features repository has 2 security vulnerabilities in json-path-2.6.0.jar and its transitive dependency json-smart-2.4.7.jar. CVE-2023-1370 is a high-severity stack overflow in JSON parsing, while CVE-2023-51074 is a medium-severity stack overflow in the Criteria.parse() method.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "json-path",
        "json-smart",
        "build-system"
      ],
      "concepts": [
        "security-vulnerability",
        "stack-overflow",
        "denial-of-service",
        "dependency-management",
        "nested-parsing"
      ],
      "severity": "high",
      "userImpact": "Users are exposed to denial-of-service attacks through stack overflow vulnerabilities when processing malformed JSON input.",
      "rootCause": "json-smart-2.4.7.jar lacks limits on nesting depth of arrays/objects causing stack exhaustion; json-path-2.6.0.jar has similar issue in Criteria.parse() method",
      "proposedFix": "Upgrade json-path to version 2.9.0 (fixes both CVE-2023-1370 via json-smart upgrade to 2.4.9 and CVE-2023-51074)",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "nesting too many of them can cause a stack exhaustion (stack overflow) and crash the software",
      "number": 254,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:55:46.806Z"
    },
    {
      "summary": "Feature request to expose build ID via WorkflowInfo to help users handle workflow determinism breaks. Users need to identify which build version generated a workflow history so they can conditionally apply logic without using versioning APIs when multiple build versions coexist.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "worker",
        "core-sdk"
      ],
      "concepts": [
        "build-id",
        "determinism",
        "workflow-versioning",
        "deployment",
        "history",
        "binary-checksum"
      ],
      "severity": "medium",
      "userImpact": "Users dealing with bad deployments that break determinism can now identify workflow build versions and conditionally apply logic without versioning APIs.",
      "rootCause": "Build ID information stored on workflow task completions was not exposed to user code, forcing fallback to heuristics like start time when determinism breaks.",
      "proposedFix": "Expose build ID through WorkflowInfo API in all language SDKs, using naming convention like 'latest build ID' or 'most recent build ID'.",
      "workaround": "Users had to use start time or other heuristics to switch between old and new workflow logic, or terminate/reset workflows.",
      "resolution": "fixed",
      "resolutionDetails": "Build ID was exposed via WorkflowInfo in all SDK implementations (Java, Go, and other language SDKs).",
      "related": [],
      "keyQuote": "Expose build ID via WorkflowInfo so that users can switch based on it and unblock both new and old workflows.",
      "number": 253,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:55:44.917Z"
    },
    {
      "summary": "A ReDoS vulnerability (CVE-2022-25883) was identified in the semver package v7.3.8, a transitive dependency of @temporalio/worker v1.5.2. The vulnerability allows denial of service through the Range function when processing untrusted input.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "worker",
        "dependency-management",
        "semver-parser"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "regex-redos",
        "dependency-upgrade",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Applications using @temporalio/worker v1.5.2 are exposed to a denial of service vulnerability through the semver parsing library.",
      "rootCause": "Regular Expression Denial of Service (ReDoS) vulnerability in semver package versions before 7.5.2 when processing untrusted range input.",
      "proposedFix": "Upgrade @temporalio/worker to version 1.7.0 or later, which upgrades the transitive semver dependency to version 7.5.2.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend after the vulnerable library was either marked as ignored or removed from the Mend inventory, indicating the dependency was upgraded.",
      "related": [],
      "keyQuote": "Versions of the package semver before 7.5.2 are vulnerable to Regular Expression Denial of Service (ReDoS) via the function new Range",
      "number": 249,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:55:49.619Z"
    },
    {
      "summary": "Transitive dependency vulnerability in golang.org/x/net-v0.5.0 (CVE-2022-41723) causes excessive CPU consumption in HPACK decoder, enabling denial of service attacks via maliciously crafted HTTP/2 streams.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "grpc",
        "http2",
        "hpack-decoder",
        "dependencies",
        "go.temporal.io/api"
      ],
      "concepts": [
        "denial-of-service",
        "cpu-consumption",
        "http2",
        "security-vulnerability",
        "dependency-management",
        "transitive-dependency",
        "network-attack"
      ],
      "severity": "high",
      "userImpact": "Users of go.temporal.io/api-v1.16.0 are vulnerable to denial of service attacks through maliciously crafted HTTP/2 requests.",
      "rootCause": "Vulnerability in golang.org/x/net-v0.5.0 HPACK decoder that can be exploited by maliciously crafted HTTP/2 streams to cause excessive CPU consumption.",
      "proposedFix": "Upgrade golang.org/x/net to v0.7.0 or later.",
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "The vulnerable library was either marked as ignored or is no longer part of the Mend inventory, so the issue was automatically closed.",
      "related": [],
      "keyQuote": "A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service from a small number of small requests.",
      "number": 248,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:55:31.851Z"
    },
    {
      "summary": "Request for an official Swift SDK for the Temporal workflow framework. The author inquires about plans to support Swift and offers to contribute if there's interest.",
      "category": "feature",
      "subcategory": "sdk-support",
      "apis": [],
      "components": [
        "sdk-core",
        "swift-sdk"
      ],
      "concepts": [
        "language-support",
        "sdk-development",
        "cross-platform",
        "community-contribution"
      ],
      "severity": "low",
      "userImpact": "Swift developers interested in using Temporal workflows would need an official SDK or community-maintained implementation.",
      "rootCause": null,
      "proposedFix": "Base Swift SDK development on the Rust Core SDK, following patterns from recent SDK implementations (Python, .NET).",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "No official plan to support a Swift SDK. Team recommended community-driven approach using Rust Core SDK as foundation, similar to other SDKs.",
      "related": [],
      "keyQuote": "There currently is no plan to officially support a Swift SDK. If you were to take this on, I would go over some of these proposals for reference",
      "number": 245,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:55:27.668Z"
    },
    {
      "summary": "Feature request to expose schedule-specific information (scheduled start time and schedule ID) through a dedicated workflow API instead of requiring users to access it via search attributes.",
      "category": "feature",
      "subcategory": "schedule-integration",
      "apis": [
        "GetInfo",
        "GetTypedSearchAttributes"
      ],
      "components": [
        "workflow-context",
        "search-attributes",
        "schedule-system"
      ],
      "concepts": [
        "schedule",
        "search-attributes",
        "workflow-metadata",
        "temporal-info",
        "discoverability"
      ],
      "severity": "medium",
      "userImpact": "Users currently must access schedule information through search attributes, which is difficult to discover and work with across different SDKs.",
      "rootCause": "Schedule-specific information is stored only as search attributes without a dedicated API, making it hard for users to access and requiring knowledge of internal implementation details.",
      "proposedFix": "Expose a separate API to return schedule information if the workflow was started by a schedule.",
      "workaround": "Use the deprecated GetInfo API to access search attributes directly, or use GetTypedSearchAttributes with SearchAttributeKeyTime from the temporal package.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        6364
      ],
      "keyQuote": "A separate API to return this information if the workflow was started by a schedule.",
      "number": 243,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:55:28.910Z"
    },
    {
      "summary": "Implement eager workflow task dispatch on SDKs to reduce latency between WorkflowClient start call and task dispatch to worker. The server can dispatch the first workflow task immediately in the start response, eliminating a transaction and improving performance.",
      "category": "feature",
      "subcategory": "workflow-dispatch",
      "apis": [
        "WorkflowClient",
        "WorkerFactory",
        "Worker",
        "WorkflowStub",
        "WorkflowOptions"
      ],
      "components": [
        "workflow-client",
        "worker-factory",
        "worker",
        "task-dispatch"
      ],
      "concepts": [
        "eager-dispatch",
        "latency-reduction",
        "task-scheduling",
        "transaction-optimization",
        "local-worker-awareness"
      ],
      "severity": "medium",
      "userImpact": "Users can achieve lower latency for workflow starts by enabling eager task dispatch when a local worker is available to process tasks immediately.",
      "rootCause": "Standard workflow task dispatch requires two transactions and a matching step, adding latency between start call and task execution.",
      "proposedFix": "Add disableEagerExecution flag to WorkflowOptions (default false), implement WorkerFactory registration with WorkflowClient, add reserveWorkflowExecutor and WFTDispatchHandle to Worker, and enable Server to return eager task in start response.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across all SDKs (Java, Go, TypeScript, Python, .NET) with server-side support already in place.",
      "related": [
        1646
      ],
      "keyQuote": "skip matching for this workflow task; use one transaction instead of two for persisting both the WorkflowExecutionStarted+WorkflowTaskScheduled events and WorkflowTaskStarted event",
      "number": 242,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:55:12.010Z"
    },
    {
      "summary": "Add support for LastHeartbeatDetails field on RespondActivityTaskFailedRequest across all Temporal SDKs to enable better error handling and diagnostics when activities fail with heartbeat information.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "RespondActivityTaskFailedRequest"
      ],
      "components": [
        "activity-executor",
        "worker",
        "error-handling",
        "api-proto"
      ],
      "concepts": [
        "heartbeat",
        "activity-failure",
        "error-details",
        "diagnostics",
        "cross-sdk-parity"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access heartbeat details when activities fail, limiting visibility into failure context and error diagnostics.",
      "rootCause": null,
      "proposedFix": "Implement LastHeartbeatDetails field support in RespondActivityTaskFailedRequest for all SDK implementations",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Support this field in all SDKs",
      "number": 241,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:54:08.235Z"
    },
    {
      "summary": "Workflows should fail immediately when given invalid arguments instead of hanging indefinitely. Currently, workflows with bad arguments hang forever with no recovery option other than manual termination, and argument schema changes need to maintain backward compatibility across deployments.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-executor",
        "argument-validation",
        "workflow-runtime"
      ],
      "concepts": [
        "error-handling",
        "argument-validation",
        "backward-compatibility",
        "workflow-failure",
        "deployment"
      ],
      "severity": "high",
      "userImpact": "Users whose workflows receive invalid arguments experience indefinite hangs with no way to recover except manual termination, blocking workflow execution and requiring operational intervention.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflows should fail if the arguments cannot be converted",
      "number": 240,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:54:06.964Z"
    },
    {
      "summary": "Feature request to add an API method across all SDKs to count workflow executions, similar to the existing list API but returning a count instead of an iterator. Go SDK already supports this with CountWorkflow, and implementation should follow the .NET SDK PR #206 as a reference.",
      "category": "feature",
      "subcategory": "workflow-api",
      "apis": [
        "CountWorkflow",
        "CountWorkflowExecutions"
      ],
      "components": [
        "workflow-service",
        "client-api",
        "sdk-core"
      ],
      "concepts": [
        "workflow-querying",
        "count-operation",
        "api-parity",
        "cross-sdk-feature"
      ],
      "severity": "medium",
      "userImpact": "Users can efficiently count workflow executions across all SDKs without needing to iterate through all results.",
      "rootCause": null,
      "proposedFix": "Implement CountWorkflow method across all SDKs (Java, TypeScript, Python, .NET, PHP, Ruby) following the approach used in .NET SDK PR #206, supporting responses with many values as per API PR #303.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented across all tracked SDKs as indicated by the completed checklist items.",
      "related": [
        1685,
        1069,
        294,
        30,
        291,
        303,
        206
      ],
      "keyQuote": "The .NET PR at https://github.com/temporalio/sdk-dotnet/pull/206 provides a good approach to follow here",
      "number": 234,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:54.850Z"
    },
    {
      "summary": "The replayer API currently discards the workflow execution result when replaying workflows to validate determinism. Users need the replayer to return the result of the replayed workflow so they can verify both determinism and result consistency.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replayer",
        "workflow-execution",
        "test-framework"
      ],
      "concepts": [
        "determinism",
        "workflow-validation",
        "result-verification",
        "replay-testing",
        "workflow-result"
      ],
      "severity": "low",
      "userImpact": "Users cannot fully validate workflow changes by confirming that replayed workflows produce identical results alongside deterministic behavior.",
      "rootCause": null,
      "proposedFix": "Add a new replayer API that returns the replayed workflow result.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A new replayer API that returns the replayed workflow result.",
      "number": 233,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:55.056Z"
    },
    {
      "summary": "Request to include SDK name and version in the WorkflowTaskCompleted event for debugging purposes. This would be stored in the sdk_metadata field and sent only when the SDK version changes between workflow tasks to minimize storage overhead.",
      "category": "feature",
      "subcategory": "sdk-metadata",
      "apis": [],
      "components": [
        "workflow-task-completed",
        "history-event",
        "sdk-metadata"
      ],
      "concepts": [
        "debugging",
        "sdk-version",
        "event-metadata",
        "storage-optimization",
        "troubleshooting"
      ],
      "severity": "low",
      "userImpact": "Enables developers and Temporal support to identify which SDK version was used during workflow execution for better troubleshooting of version-specific issues.",
      "rootCause": null,
      "proposedFix": "Add SDK name and version to the sdk_metadata field of WorkflowTaskCompleted events, sending them only when changed since the previous workflow task.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #321",
      "related": [
        321
      ],
      "keyQuote": "knowing the exact SDK version might help in troubleshooting certain failure scenarios",
      "number": 232,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:52.650Z"
    },
    {
      "summary": "Add a 'failure_reason' tag to workflow_task_execution_failed metrics that indicates whether the failure was due to a WorkflowError or NonDetermismError. This feature was requested across multiple SDKs (Go, Java, and Core).",
      "category": "feature",
      "subcategory": "metrics-tagging",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-executor",
        "error-handling"
      ],
      "concepts": [
        "observability",
        "failure-classification",
        "error-tagging",
        "workflow-execution",
        "metrics"
      ],
      "severity": "medium",
      "userImpact": "Users can better diagnose and monitor workflow task failures by filtering metrics based on specific error types.",
      "rootCause": null,
      "proposedFix": "Add 'failure_reason' tag to workflow_task_execution_failed metric with values 'WorkflowError' or 'NonDetermismError', with provisions for future expansion.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in all SDKs (Go, Java, and Core) as indicated by related issues and completion comment.",
      "related": [
        1289,
        1929,
        730
      ],
      "keyQuote": "Add a tag to `workflow_task_execution_failed` called `failure_reason` that can be equal to `WorkflowError| NonDetermismError`",
      "number": 231,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:42.026Z"
    },
    {
      "summary": "Feature request to provide SDK-level auto-heartbeating helpers that automatically send periodic heartbeats without requiring manual heartbeat code in activities. Users commonly wrap activities with async timers for this purpose, and SDKs should provide a standardized solution.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "StartAutoHeartbeat"
      ],
      "components": [
        "activity-executor",
        "heartbeat-manager",
        "context"
      ],
      "concepts": [
        "heartbeat",
        "keep-alive",
        "timeout",
        "activity-lifecycle",
        "async-helper"
      ],
      "severity": "medium",
      "userImpact": "Provides a built-in mechanism for activities to maintain heartbeats without manual implementation, reducing boilerplate and preventing activity timeout during long-running operations.",
      "rootCause": null,
      "proposedFix": "Each SDK should implement a StartAutoHeartbeat helper that sends periodic heartbeats at intervals based on heartbeat timeout, with exceptions thrown if manual heartbeats are attempted concurrently.",
      "workaround": "Users can manually wrap activities with async timers that start and stop heartbeating around activity execution.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Each SDK should provide an auto-heartbeating helper... The auto heartbeater should automatically send a heartbeat sans details every X of the heartbeat timeout",
      "number": 229,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:39.331Z"
    },
    {
      "summary": "Feature request to add test coverage ensuring workflow changes are evaluated consistently across all Temporal SDKs regarding determinism. Test should verify that if a code change is non-deterministic in one language, it's non-deterministic in all others.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "workflow-execution",
        "determinism-detection"
      ],
      "concepts": [
        "determinism",
        "non-determinism",
        "cross-language-compatibility",
        "workflow-replay",
        "test-coverage",
        "code-changes"
      ],
      "severity": "medium",
      "userImpact": "Users need confidence that determinism rules are consistently enforced across language SDKs to ensure reliable workflow execution.",
      "rootCause": null,
      "proposedFix": "Create a general-purpose test workflow accepting two parameters (non-replay behavior, replay behavior), with a helper to run to completion, query for non-determinism errors, and test various code change combinations across all SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Can be a general purpose test workflow that takes two params saying what to do on non-replay and what to do on replay.",
      "number": 228,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:40.329Z"
    },
    {
      "summary": "Request to add code samples demonstrating the three workflow versioning strategies across all Temporal SDKs (Go, Java, Python, TypeScript, and .NET). This would provide developers with practical examples of implementing versioning in their workflows.",
      "category": "docs",
      "subcategory": "versioning-samples",
      "apis": [],
      "components": [
        "sdk-go",
        "sdk-java",
        "sdk-python",
        "sdk-typescript",
        "sdk-dotnet"
      ],
      "concepts": [
        "versioning",
        "workflow-versioning",
        "versioning-strategies",
        "code-samples",
        "documentation",
        "best-practices"
      ],
      "severity": "medium",
      "userImpact": "Developers need practical guidance on implementing workflow versioning patterns to safely evolve workflows over time.",
      "rootCause": null,
      "proposedFix": "Create code examples for each of the three versioning strategies for all five SDKs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Samples were created demonstrating the three versioning strategies across the supported SDKs.",
      "related": [],
      "keyQuote": "Code examples showing the three versioning strategy",
      "number": 227,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:26.564Z"
    },
    {
      "summary": "Feature request to add .NET SDK support for building and running features tests. This is needed to complete the .NET SDK implementation as referenced in sdk-dotnet issue #23.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "features-repository",
        "sdk-dotnet",
        "test-framework"
      ],
      "concepts": [
        "testing",
        "sdk-support",
        "feature-coverage",
        "dotnet-runtime"
      ],
      "severity": "medium",
      "userImpact": ".NET SDK users cannot run feature tests, blocking complete SDK validation and feature parity assessment.",
      "rootCause": null,
      "proposedFix": "Implement .NET SDK support in the features repository to allow building and running feature tests for the .NET SDK.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature has been implemented as the .NET SDK is now fully tracked and supported in the features repository.",
      "related": [
        23
      ],
      "keyQuote": "Need to support building/running .NET SDK features. Needed for temporalio/sdk-dotnet#23",
      "number": 226,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:26.019Z"
    },
    {
      "summary": "Request for an SDK metric to track when an activity invocation has failed and exhausted all retries, distinct from the existing activity_execution_failed metric which fires even when activities recover via retries.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "retry-handler"
      ],
      "concepts": [
        "monitoring",
        "retry",
        "activity-failure",
        "metrics",
        "observability",
        "resilience"
      ],
      "severity": "medium",
      "userImpact": "Users need a reliable metric to monitor when activities permanently fail after exhausting retries, separate from transient failures that recover.",
      "rootCause": null,
      "proposedFix": "Add a new SDK metric for final activity failures after retry exhaustion, complementing the existing activity_execution_failed metric.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A single data point that indicates when an activity invocation has failed and exhausted retries would be useful for monitoring.",
      "number": 223,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:28.168Z"
    },
    {
      "summary": "The workflow_completed and workflow_continue_as_new metric counters are incremented when a workflow method completes, including during replays and rejected completions, instead of only after the server confirms successful acceptance of the completion report.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "worker",
        "completion-reporting"
      ],
      "concepts": [
        "metrics-accuracy",
        "server-confirmation",
        "workflow-completion",
        "replay",
        "counter-reporting"
      ],
      "severity": "medium",
      "userImpact": "Users receive inaccurate metric counts that overcount workflow completions, making it difficult to understand actual completion rates and system behavior.",
      "rootCause": "Metrics are logged when workflow method code execution completes rather than after server confirmation of the completion report.",
      "proposedFix": "Move metric logging to occur only after successful completion report acknowledgment from the server.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2111,
        1590,
        1084
      ],
      "keyQuote": "A worker should log these metrics only after reporting the completion of the workflow task to the server and getting a confirmation from the server that the completion was not rejected.",
      "number": 222,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:13.132Z"
    },
    {
      "summary": "Unregistered local activities should fail the workflow task rather than retrying indefinitely, allowing workers to be redeployed with the correct implementation. This prevents workflow failures caused by deployment issues and enables task redistribution to workers with the registered activity.",
      "category": "feature",
      "subcategory": "local-activity",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "workflow-task-handler",
        "activity-registry"
      ],
      "concepts": [
        "deployment",
        "activity-registration",
        "workflow-task-failure",
        "error-handling",
        "worker-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users with unregistered local activities experience workflow failures or infinite retries instead of getting clear feedback to redeploy their workers.",
      "rootCause": "SDKs do not validate that local activities are registered before attempting execution, leading to retry loops instead of task failures.",
      "proposedFix": "Core-based SDKs should check on the workflow side before sending to Core if the local activity is not found, so they can fail the task appropriately.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Java and TypeScript SDKs implement the fix. Go and Python still need implementation. .NET and Ruby issues opened separately.",
      "related": [
        1561,
        845,
        463,
        253
      ],
      "keyQuote": "If Local Activity is not registered, it's pointless to keep retrying on the same worker. It will not be fixed without worker redeployment.",
      "number": 221,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:14.769Z"
    },
    {
      "summary": "SDK workers intentionally timeout failed workflow tasks to implement backoff, which makes retry behavior opaque to users. The proposal is to add a server capability and disable this timeout behavior when the server supports backoff, improving visibility into workflow task retries.",
      "category": "feature",
      "subcategory": "workflow-task-retry",
      "apis": [],
      "components": [
        "worker",
        "workflow-task-executor",
        "retry-mechanism"
      ],
      "concepts": [
        "timeout",
        "retry",
        "backoff",
        "workflow-task",
        "system-resilience",
        "visibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot clearly see that workflow tasks are being retried, and the number of retry attempts and failure reasons are not exposed, making debugging and monitoring difficult.",
      "rootCause": "Worker intentionally times out workflow tasks on retry attempts as the mechanism for implementing backoff, which obscures retry behavior and lacks transparency.",
      "proposedFix": "Add a server capability check and disable worker timeout behavior for failed workflow tasks when the server supports backoff.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It is not clear that workflow task is being retried. Number of attempts is not exposed as well as the last failure that caused the task failure.",
      "number": 219,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:11.553Z"
    },
    {
      "summary": "Go and Java SDKs currently fatal the worker on errors like InvalidArgument and NamespaceNotFound without retry, but these should be considered recoverable with retry logic similar to core's behavior.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "worker",
        "error-handler",
        "server-communication"
      ],
      "concepts": [
        "retry",
        "fatal-error",
        "error-recovery",
        "graceful-degradation",
        "worker-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Workers crash unexpectedly on transient server errors, causing service interruptions for users.",
      "rootCause": "InvalidArgument and NamespaceNotFound errors are incorrectly classified as unrecoverable when they can be transient (e.g., gRPC deadline too close to now).",
      "proposedFix": "All SDKs should implement retry logic for fatal errors with a configurable retry period before actually fataling, similar to core's behavior.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Every SDK should react the same to seeing a worker error. They should probably mimic core in that they retry for so long, even fatal ones, before actually being fatal.",
      "number": 218,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:53:00.493Z"
    },
    {
      "summary": "Docker-compose shutdown is failing intermittently with 'No such file or directory' error when trying to start a bash process in the features directory path. The issue appears to be a sporadic flake in the CI workflow that has resolved itself.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "docker-compose",
        "ci-workflow",
        "test-runner"
      ],
      "concepts": [
        "working-directory",
        "process-spawning",
        "ci-flake",
        "shutdown",
        "path-resolution"
      ],
      "severity": "low",
      "userImpact": "CI tests fail intermittently during docker-compose shutdown, requiring workflow re-runs.",
      "rootCause": "Unclear - appears to be a race condition or timing issue during docker-compose shutdown affecting working directory resolution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Investigation found all subsequent runs against main were passing or failing for unrelated reasons, suggesting the issue was transient and self-resolved.",
      "related": [],
      "keyQuote": "I looked at runs against `main` in the last month, and all of them seem to be passing, or failing for unrelated reasons.",
      "number": 216,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:56.905Z"
    },
    {
      "summary": "A transitive dependency vulnerability (CVE-2022-41721) in golang.org/x/net v0.1.0 affecting the Go SDK v1.19.0 through grpc-middleware. The vulnerability allows HTTP/2 request smuggling attacks via MaxBytesHandler that doesn't fully consume request bodies.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "grpc-middleware",
        "golang.org/x/net",
        "dependency-management"
      ],
      "concepts": [
        "vulnerability",
        "security",
        "http2",
        "request-smuggling",
        "dependency-chain",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Users of Go SDK v1.19.0 are exposed to potential HTTP/2 request smuggling attacks through a vulnerable transitive dependency.",
      "rootCause": "golang.org/x/net v0.1.0 MaxBytesHandler does not fully consume HTTP request bodies, allowing attackers to manipulate remaining data to represent arbitrary HTTP/2 frames.",
      "proposedFix": "Upgrade golang.org/x/net to a patched version that properly consumes request bodies in MaxBytesHandler.",
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Automatically closed by Mend bot because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory, indicating the vulnerability was likely addressed through dependency updates.",
      "related": [],
      "keyQuote": "A request smuggling attack is possible when using MaxBytesHandler. When the server attempts to read HTTP2 frames from the connection, it will instead be reading the body of the HTTP request",
      "number": 215,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:59.774Z"
    },
    {
      "summary": "TypeScript tests in the features repository are experiencing flakiness, with workflow processes still running after 5 seconds during schedule/backfill testing, causing intermittent test failures.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "scheduler",
        "workflow-executor"
      ],
      "concepts": [
        "flakiness",
        "race-condition",
        "timeout",
        "workflow-execution",
        "backfill",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Test suite is unreliable, making it difficult to validate TypeScript SDK functionality and blocking continuous integration workflows.",
      "rootCause": "Workflow processes not completing within expected 5-second timeout during backfill operations, indicating potential timing issues or race conditions in the test setup.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through fixes to the test framework or timing logic.",
      "related": [],
      "keyQuote": "after 5s, 1 workflow(s) are still running: schedule-backfill-...",
      "number": 210,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:43.078Z"
    },
    {
      "summary": "Dependency security vulnerabilities in uber-go/tally v4.1.7 related to Apache Thrift CVE-2019-0205 and CVE-2019-0210, both with CVSS 7.5 severity. These transitive dependencies can cause server/client endless loops or panics when fed invalid input data.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "tally",
        "thrift",
        "dependency-management"
      ],
      "concepts": [
        "security-vulnerability",
        "cve",
        "dependency-chain",
        "availability",
        "denial-of-service",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Applications using the features module are exposed to remote denial-of-service vulnerabilities through outdated transitive dependencies.",
      "rootCause": "github.com/uber-go/tally/v4 v4.1.7 depends on Apache Thrift versions (0.9.3-0.12.0) containing CVE-2019-0205 and CVE-2019-0210 vulnerabilities that cause endless loops or panics on invalid input.",
      "proposedFix": "Upgrade apache.org/thrift to version 0.13.0 or later",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was marked as ignored or no longer part of the Mend inventory in the specific branches.",
      "related": [],
      "keyQuote": "In Apache Thrift all versions up to and including 0.12.0, a server or client may run into an endless loop when feed with specific input data.",
      "number": 208,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:45.765Z"
    },
    {
      "summary": "Users struggle with context propagation in SDKs that lack native support for the concept (TypeScript, Python). This feature request asks for context propagators to be added across all SDKs, leveraging interceptor infrastructure to maintain simplicity.",
      "category": "feature",
      "subcategory": "context-propagation",
      "apis": [],
      "components": [
        "interceptors",
        "client-options",
        "worker-options"
      ],
      "concepts": [
        "context-propagation",
        "interceptors",
        "cross-language-parity",
        "sdk-configuration",
        "user-extensibility"
      ],
      "severity": "medium",
      "userImpact": "Users in TypeScript and Python need explicit context propagators to handle cross-cutting concerns that other languages support natively.",
      "rootCause": null,
      "proposedFix": "Implement context propagators using the existing interceptor infrastructure, potentially with configurable hooks in client and worker options classes.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Context propagators can be implemented using interceptors and we will likely want to leverage that for the implementation to avoid adding complexity",
      "number": 206,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:41.278Z"
    },
    {
      "summary": "Feature request to expose the currently configured payload converter to workflow code, enabling access for use cases like headers and interceptors across all Temporal SDKs.",
      "category": "feature",
      "subcategory": "payload-conversion",
      "apis": [],
      "components": [
        "payload-converter",
        "workflow-context",
        "interceptors"
      ],
      "concepts": [
        "serialization",
        "payload-handling",
        "configuration-access",
        "headers",
        "interceptors",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access the currently configured payload converter from within workflow code, limiting their ability to implement custom serialization strategies and interceptors.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1007
      ],
      "keyQuote": "Expose currently configured payload converter to workflow code",
      "number": 204,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:28.476Z"
    },
    {
      "summary": "Feature request to provide Temporal client access from activity context across all SDKs. This would allow activity authors to more easily use the client within their activities, with implementation status varying by SDK (Go, Java, Python, .NET, Ruby complete; TypeScript and PHP pending).",
      "category": "feature",
      "subcategory": "activity-client-access",
      "apis": [
        "Client",
        "Activity"
      ],
      "components": [
        "activity-context",
        "client-sdk",
        "worker"
      ],
      "concepts": [
        "activity-execution",
        "client-integration",
        "developer-experience",
        "sdk-consistency",
        "context-injection"
      ],
      "severity": "medium",
      "userImpact": "Activities currently lack convenient access to the Temporal client, forcing developers to manage client creation separately rather than having it injected into the activity context.",
      "rootCause": null,
      "proposedFix": "Provide a Temporal client to the activity context of each SDK, making it available through the activity context similar to how it's available in workflows.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1761,
        2362,
        721,
        389,
        181
      ],
      "keyQuote": "Provide a Temporal client to the activity context of each SDK so activity authors can more easily use the client.",
      "number": 203,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:30.896Z"
    },
    {
      "summary": "Feature request to verify that all SDKs properly expose the scheduled execution properties (TemporalScheduledStartTime and TemporalScheduledById search attributes, plus timestamp in Workflow ID) when workflows are triggered by schedules.",
      "category": "feature",
      "subcategory": "schedule-workflows",
      "apis": [],
      "components": [
        "schedule",
        "workflow-execution",
        "search-attributes"
      ],
      "concepts": [
        "scheduling",
        "search-attributes",
        "workflow-properties",
        "schedule-id",
        "timestamp",
        "sdk-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users need to verify that scheduled workflow executions properly set all required search attributes and properties across different SDKs for consistent behavior.",
      "rootCause": null,
      "proposedFix": "Verify this information is present and accessible on all SDKs",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Verify this information is present and accessible on all SDKs",
      "number": 202,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:27.202Z"
    },
    {
      "summary": "Feature request to add support for dynamic (catch-all) handlers in all SDKs for workflows, activities, signals, queries, and updates. These handlers would be invoked when a specific handler isn't registered, allowing opt-in flexibility. Java already supports this; Go, TypeScript, Python, and .NET need implementation.",
      "category": "feature",
      "subcategory": "dynamic-handlers",
      "apis": [
        "ExecuteActivity",
        "StartWorkflow",
        "RegisterWorkflow",
        "RegisterActivity",
        "RegisterSignal",
        "RegisterQuery",
        "RegisterUpdate"
      ],
      "components": [
        "worker",
        "workflow-handler",
        "activity-handler",
        "signal-handler",
        "query-handler"
      ],
      "concepts": [
        "dynamic-dispatch",
        "catch-all-handler",
        "registration",
        "opt-in",
        "payload-handling",
        "cross-sdk-feature-parity"
      ],
      "severity": "medium",
      "userImpact": "SDKs without dynamic handlers lack flexibility for handling workflows and activities that aren't pre-registered, limiting use cases for dynamic workload execution.",
      "rootCause": null,
      "proposedFix": "Implement dynamic handler support in Go, TypeScript, Python, and .NET SDKs, accepting raw payloads (decoded for workflows/signals/queries, encoded for activities) without JSON assumptions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        543,
        997,
        993,
        1015,
        242,
        27
      ],
      "keyQuote": "All SDKs should support \"dynamic\" workflows, activities, signals, and queries which are opt-in catch-alls when ones aren't registered",
      "number": 201,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:16.848Z"
    },
    {
      "summary": "Request for a versioning mechanism that allows SDKs to fix issues affecting workflow execution without adding marker events for every change. Proposes adding an incremental integer to WorkflowTaskCompletedRequest or VersionId, with server capability signaling to support conditional SDK fixes on replay.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "RespondWorkflowTaskCompletedRequest",
        "WorkflowTaskCompletedEventAttributes",
        "VersionId"
      ],
      "components": [
        "workflow-execution",
        "history-events",
        "capability-negotiation"
      ],
      "concepts": [
        "versioning",
        "backward-compatibility",
        "replay",
        "server-capabilities",
        "event-tracking"
      ],
      "severity": "medium",
      "userImpact": "SDKs can implement targeted fixes for workflow execution bugs without the cost of adding marker events for every SDK version change.",
      "rootCause": null,
      "proposedFix": "Add an incremental integer field to either RespondWorkflowTaskCompletedRequest/WorkflowTaskCompletedEventAttributes or VersionId to track SDK versions, with server capability signaling to enable conditional fix application during replay.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented with versioning support added to the Temporal API for internal SDK version tracking.",
      "related": [],
      "keyQuote": "We should get to leverage the same type of versioning/patching our users do. However, it may be a bit unreasonable to add a new marker event for every single workflow henceforth",
      "number": 200,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:15.950Z"
    },
    {
      "summary": "Feature request to allow stack trace queries to use custom data converters across all SDKs. Currently stack trace queries bypass custom converters, but this request seeks an opt-in mechanism to apply converters consistently.",
      "category": "feature",
      "subcategory": "data-converter",
      "apis": [
        "Query"
      ],
      "components": [
        "data-converter",
        "stack-trace-query",
        "serialization"
      ],
      "concepts": [
        "custom-serialization",
        "query-execution",
        "stack-trace",
        "encoding",
        "data-conversion",
        "remote-encoding"
      ],
      "severity": "low",
      "userImpact": "Users cannot apply custom data converters to stack trace queries, limiting consistency in how query data is serialized across different query types.",
      "rootCause": "Stack trace queries are handled specially and bypass the custom data converter pipeline to avoid complexity with remote encoders and proxies.",
      "proposedFix": "Make stack trace query custom converter support opt-in, particularly for Java SDK which currently doesn't encode stack traces.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Won't implement due to complexity with remote encoders and proxies. Java SDK will have opt-in support instead.",
      "related": [
        996,
        1586,
        1014,
        241
      ],
      "keyQuote": "Won't do this due to complexity with remote encoders and proxies. We'll need to address Java, it's the only SDK that doesn't encode stack trace query, can make it opt-in there.",
      "number": 199,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:13.473Z"
    },
    {
      "summary": "gRPC messages exceeding the 4MB limit trigger ResourceExhausted errors with automatic retry logic, but these should fail immediately without retry. Different SDKs need specific implementations to detect and fail on oversized messages.",
      "category": "feature",
      "subcategory": "grpc-communication",
      "apis": [],
      "components": [
        "grpc-client",
        "error-handling",
        "retry-logic"
      ],
      "concepts": [
        "message-size-limit",
        "resource-exhaustion",
        "retry-behavior",
        "error-detection",
        "grpc-protocol"
      ],
      "severity": "high",
      "userImpact": "Users experience unnecessary retries and delayed failures when workflows or activities produce messages larger than 4MB, preventing immediate error detection.",
      "rootCause": "Auto-retry logic treats all ResourceExhausted errors the same way, but message size violations should be treated as non-retryable errors.",
      "proposedFix": "Detect message size exceeded errors in gRPC responses and fail the workflow task immediately without retrying.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of features #624",
      "related": [
        995,
        1585,
        462,
        624
      ],
      "keyQuote": "grpc: received message larger than max (10248653 vs. 4194304) - We auto-retry resource exhausted, but we shouldn't retry _this_ resource exhausted",
      "number": 198,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:52:02.229Z"
    },
    {
      "summary": "SDK logic needs a standard versioning mechanism to handle history-incompatible behavior changes internally, similar to the existing getVersion and patched APIs available for user logic. The feature proposes adding fields to WorkflowTaskCompleted event and CompleteWorkflowTaskRequest proto messages to encode internal SDK versions without creating new history events.",
      "category": "feature",
      "subcategory": "versioning",
      "apis": [
        "getVersion",
        "patched"
      ],
      "components": [
        "workflow-task-handler",
        "proto-messages",
        "history-compatibility"
      ],
      "concepts": [
        "versioning",
        "history-compatibility",
        "SDK-behavior",
        "backwards-compatibility",
        "internal-versioning"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably modify SDK behavior in breaking ways without history compatibility issues, limiting SDK evolution.",
      "rootCause": null,
      "proposedFix": "Add fields to WorkflowTaskCompleted event and CompleteWorkflowTaskRequest proto messages to encode internal SDK version information.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed in favor of the more detailed issue #200",
      "related": [
        200
      ],
      "keyQuote": "We do not have a standard mechanism for doing this in our SDKs apart from TypeScript where we use the patched API.",
      "number": 197,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:59.874Z"
    },
    {
      "summary": "Define standardized behavior across all Temporal SDKs when a Worker receives an Activity Task for an unregistered Activity Type. Currently unclear what each SDK does and what the desired behavior should be.",
      "category": "feature",
      "subcategory": "activity-registration",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "activity-registry"
      ],
      "concepts": [
        "activity-types",
        "unregistered-handler",
        "error-handling",
        "standardization",
        "sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users get inconsistent error messages and behavior across different SDKs when workers encounter unregistered activity types.",
      "rootCause": null,
      "proposedFix": "Error with a list of known activity types; coordinate with #201 for standardizing dynamic workflows and activities behavior",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        201
      ],
      "keyQuote": "We want to error with a list of known activity types.",
      "number": 195,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:57.783Z"
    },
    {
      "summary": "SDKs have inconsistent behavior when scheduling timers with duration <= 0. The server rejects duration <= 0, while different SDKs either throw errors, apply minimums, or skip scheduling entirely. The feature request asks for consistent cross-SDK behavior to handle zero-duration timers properly.",
      "category": "feature",
      "subcategory": "timer-scheduling",
      "apis": [
        "StartTimer",
        "ScheduleTimer"
      ],
      "components": [
        "timer-scheduler",
        "sdk-server-interaction",
        "workflow-execution"
      ],
      "concepts": [
        "timer-duration",
        "consistency",
        "non-determinism",
        "edge-cases",
        "input-mutation",
        "backward-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Developers face inconsistent behavior across SDKs when scheduling timers with zero or negative durations, requiring special handling and potentially causing non-determinism issues on replay.",
      "rootCause": "Server enforces duration > 0 constraint while SDKs handle this inconsistently (throwing, applying minimums, or skipping), creating cross-SDK compatibility issues.",
      "proposedFix": "Server should allow duration 0 to avoid special handling. SDKs should always schedule the timer to prevent non-determinism issues if timer duration changes on replay.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1579,
        378
      ],
      "keyQuote": "Ideally, the server should allow duration 0 to avoid special handling and mutation of user input on the SDK.",
      "number": 194,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:47.719Z"
    },
    {
      "summary": "Ensure that ClientOptions.identity is consistently set across all client API calls (terminate, cancel, start, signal, signalWithStart) in all SDKs. Currently, the identity is not being set on terminate calls in Java.",
      "category": "feature",
      "subcategory": "client-options",
      "apis": [
        "terminate",
        "cancel",
        "start",
        "signal",
        "signalWithStart"
      ],
      "components": [
        "client",
        "workflow-client",
        "identity-handling"
      ],
      "concepts": [
        "client-options",
        "identity",
        "consistency",
        "cross-sdk-parity",
        "client-calls"
      ],
      "severity": "medium",
      "userImpact": "Users may not have their configured client identity properly propagated across all workflow operations, leading to inconsistent identity tracking and potential audit/logging issues.",
      "rootCause": "Incomplete implementation of identity propagation across all client API methods; identity is set in some methods (TS) but not others (Java terminate).",
      "proposedFix": "Audit all SDK implementations and ensure ClientOptions.identity is set on all client calls including terminate, cancel, start, signal, and signalWithStart.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Put it in this repo so that we'd ensure consistent behavior across SDKs",
      "number": 193,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:43.283Z"
    },
    {
      "summary": "Python features test for query timeout is not checking for the correct deadline exceeded error type, unlike implementations in other languages. This is a leftover from manual client-side timeout handling that needs to be fixed.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "features-test",
        "python-sdk",
        "query-handler"
      ],
      "concepts": [
        "timeout",
        "deadline",
        "error-handling",
        "cross-language-consistency",
        "test-validation"
      ],
      "severity": "medium",
      "userImpact": "Test cases may not properly validate timeout behavior, potentially masking issues in query timeout handling across language implementations.",
      "rootCause": "Manual client-side timeout implementation left as legacy code without proper deadline exceeded error type checking",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Updated the test to check for the correct deadline exceeded error type consistent with other language implementations",
      "related": [],
      "keyQuote": "Other langs check for the right error type, this one does not because it was left over from manual client-side timeout",
      "number": 184,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:44.446Z"
    },
    {
      "summary": "List API calls using visibility (ES-based) are eventually consistent, meaning results may not immediately reflect recent inserts/updates. Specs need to document this behavior, and tests should retry list calls to handle eventual consistency.",
      "category": "docs",
      "subcategory": "visibility-eventual-consistency",
      "apis": [
        "ListWorkflows",
        "ListSchedules"
      ],
      "components": [
        "visibility",
        "list-api",
        "elasticsearch",
        "test-framework"
      ],
      "concepts": [
        "eventual-consistency",
        "visibility",
        "list-operations",
        "retry",
        "cloud-behavior",
        "elasticsearch"
      ],
      "severity": "medium",
      "userImpact": "Users need to understand that list operations may not immediately reflect recent changes when using ES-based visibility, requiring retry logic in their code.",
      "rootCause": "Elasticsearch-based visibility implementation exhibits eventual consistency behavior where list operations don't immediately reflect recent mutations.",
      "proposedFix": "Document eventual consistency behavior in specs and update tests to retry list calls until expected results are returned instead of failing on first attempt.",
      "workaround": "Retry loop in schedule/basic/feature.go to handle delayed list results.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "list API calls which make use of visibility are eventually consistent when using advanced (ES) based visibility. This means that calls of the pattern insert/update thing then list that thing may not return results reflecting the change",
      "number": 182,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:28.128Z"
    },
    {
      "summary": "Feature test harness needs to enforce timeout requirements on all started workflows. Currently workflows may start without timeouts, which is problematic for regular cloud testing. All workflows should have a default 1-hour timeout unless shorter timeouts are needed for specific tests.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-harness",
        "workflow-execution",
        "timeout-management"
      ],
      "concepts": [
        "timeout",
        "workflow-lifecycle",
        "test-reliability",
        "cloud-testing",
        "test-defaults"
      ],
      "severity": "medium",
      "userImpact": "Tests may fail unpredictably or hang indefinitely when workflows lack proper timeout configuration in cloud environments.",
      "rootCause": "Test harness does not enforce or apply default timeouts to workflows started during feature testing.",
      "proposedFix": "Apply a default 1-hour timeout to all workflows started in the test harness, with ability to override for specific tests.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #315, consolidating timeout enforcement work into a single tracking issue.",
      "related": [
        315
      ],
      "keyQuote": "every started workflow needs a reasonable timeout attached. All workflows should get something like a 1hr timeout by default",
      "number": 181,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:32.291Z"
    },
    {
      "summary": "The getVersion API is memoized by default to coordinate patches across code, but there's a request to add an opt-in non-memoized version option. TypeScript accidentally implemented non-memoized by default, which has benefits like being embeddable in loops, and this feature explores making that an official option across SDKs.",
      "category": "feature",
      "subcategory": "versioning-api",
      "apis": [
        "getVersion"
      ],
      "components": [
        "workflow-versioning",
        "sdk-core",
        "typescript-sdk"
      ],
      "concepts": [
        "memoization",
        "versioning",
        "patches",
        "coordination",
        "workflow-api"
      ],
      "severity": "medium",
      "userImpact": "Users would have more flexibility in how they use versioning APIs, enabling use cases like embedding version checks in loops or workflow conditions without memoization constraints.",
      "rootCause": null,
      "proposedFix": "Add an opt-in option to disable memoization for the getVersion API call across SDKs, making it non-memoized when explicitly requested.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to add non-memoized versioning API option across SDK implementations.",
      "related": [
        1016
      ],
      "keyQuote": "In TS we accidentally implemented a non-memoized version by default which has some nice benefits like being embeddable in a loop or condition",
      "number": 179,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:29.777Z"
    },
    {
      "summary": "Feature request to add GetSignalInfo API that provides metadata about received signals (timestamp, event ID) from within signal handlers. Currently, this information is not accessible to workflows, limiting signal handling capabilities.",
      "category": "feature",
      "subcategory": "signal-handling",
      "apis": [
        "GetSignalInfo",
        "GetSignalWithInfoChannel"
      ],
      "components": [
        "signal-handler",
        "workflow-execution",
        "event-metadata"
      ],
      "concepts": [
        "signal-info",
        "event-id",
        "event-timestamp",
        "signal-metadata",
        "in-order-processing",
        "event-information"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot access signal timing and event metadata within signal handlers, limiting their ability to implement sophisticated signal processing logic.",
      "rootCause": null,
      "proposedFix": "Add GetSignalInfo API for retrieving signal metadata. For Go, propose GetSignalWithInfoChannel returning Channel with Signal structures including info and value.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Some information about signals is not available within a signal handler. Example of this information is a time the signal was received by a workflow and signal eventId.",
      "number": 178,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:14.748Z"
    },
    {
      "summary": "Prevent SDK APIs that generate workflow commands from being invoked within workflow side effects, as this causes non-deterministic errors during workflow replay. Extended concern about restricting any operations that cause thread/coroutine yielding.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-executor",
        "side-effect-handler",
        "command-generator"
      ],
      "concepts": [
        "determinism",
        "workflow-replay",
        "side-effects",
        "command-generation",
        "thread-yielding",
        "non-deterministic-errors"
      ],
      "severity": "high",
      "userImpact": "Users experience non-deterministic failures when workflow replay occurs if they accidentally invoke command-generating APIs within side effects.",
      "rootCause": "APIs that generate commands or yield thread/coroutine control within side effects violate workflow determinism requirements and cause replay failures.",
      "proposedFix": "Add validation to prevent invocation of command-generating APIs and operations that yield thread/coroutine control from within side effect blocks.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This leads to non-deterministic errors on internal wf replay. Feature request is to no allow any apis that generate commands to be invoked from inside side effects.",
      "number": 177,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:16.912Z"
    },
    {
      "summary": "Cron workflow executions report inaccurate end-to-end latency metrics because they include the firstWorkflowTaskBackoff delay. Request to either adjust the metric calculation or create new metrics that distinguish between start-to-close latency and schedule-to-close latency.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-executor",
        "cron-workflows"
      ],
      "concepts": [
        "latency",
        "metrics",
        "cron",
        "timing",
        "workflow-execution",
        "task-scheduling"
      ],
      "severity": "medium",
      "userImpact": "Users monitoring cron workflow performance see artificially inflated end-to-end latency metrics that don't reflect actual worker processing time.",
      "rootCause": "workflow_endtoend_latency is calculated from WorkflowExecutionStarted event, which precedes the firstWorkflowTaskBackoff delay in cron workflows, inflating the reported latency.",
      "proposedFix": "Either subtract firstWorkflowTaskBackoff duration from workflow_endtoend_latency for cron workflows, or introduce new metrics: workflow_scheduletoclose_latency (current behavior), workflow_starttoclose_latency (adjusted), or workflow_cron_execution_latency.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "For cron workflows this can lead to very large endtoend latencies as the first workflow task is not added to tq until firstWorkflowTaskBackoff timer fires.",
      "number": 175,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:13.450Z"
    },
    {
      "summary": "Request to support higher-level activity options configuration across SDKs. TypeScript and Java already support workflow-level or type-level activity options, but Go and Python lack these capabilities, creating inconsistency in how developers can configure activity behavior.",
      "category": "feature",
      "subcategory": "activity-options",
      "apis": [],
      "components": [
        "activity-executor",
        "workflow-implementation",
        "sdk-configuration"
      ],
      "concepts": [
        "activity-options",
        "workflow-level-configuration",
        "type-level-options",
        "default-options",
        "api-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users of Go and Python SDKs cannot configure activity options at the workflow or type level, forcing them to pass options at call sites or use workarounds like partial functions.",
      "rootCause": "Different SDK implementations have evolved with different approaches to activity option configuration; Go and Python SDKs lack the higher-level abstractions present in TypeScript and Java.",
      "proposedFix": "Consider adding workflow-level or type-level activity option support to Go and Python SDKs, potentially with a more generalized solution allowing definition-site configuration of workflow and activity options.",
      "workaround": "In Python, developers can use `partial` functions to bake options into activity functions, providing semantics similar to TypeScript and Java proxies.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I would prefer a more generalized solution where workflow and activity options can be defined on the implementation side.",
      "number": 174,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:00.950Z"
    },
    {
      "summary": "Test suite experiencing intermittent failures in TypeScript and Java implementations, particularly with query type validation returning unexpected error types. Issue was resolved by upgrading the SDK.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "query-validation",
        "error-handling",
        "test-suite"
      ],
      "concepts": [
        "flaky-tests",
        "error-type-mismatch",
        "query-registration",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Test suite reliability is compromised, affecting continuous integration and development workflow validation.",
      "rootCause": "SDK version mismatch causing query type validation to return ServiceError instead of expected QueryNotRegisteredError",
      "proposedFix": "Upgrade the SDK to a version with correct error type handling",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by upgrading the SDK to resolve the error type mismatch in query validation",
      "related": [],
      "keyQuote": "The error is expected to be an instance of \"QueryNotRegisteredError\". Received \"ServiceError\"",
      "number": 172,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:02.088Z"
    },
    {
      "summary": "Feature request to add worker-side enforcement of activity timeouts (start-to-close, schedule-to-close, heartbeat) by notifying the activity implementation when a timeout has expired, reducing the risk of duplicate activity executions.",
      "category": "feature",
      "subcategory": "activity-timeouts",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "heartbeat-mechanism"
      ],
      "concepts": [
        "timeout",
        "activity-lifecycle",
        "cancellation",
        "duplicate-execution",
        "server-synchronization",
        "worker-enforcement"
      ],
      "severity": "medium",
      "userImpact": "Workers cannot reliably notify activities of timeout expiration, increasing the risk of duplicate activity executions for sensitive workloads.",
      "rootCause": "SDKs lack worker-side timeout notification mechanism; only heartbeating provides timeout awareness, and SDK throttles heartbeats without notifying activity implementation.",
      "proposedFix": "Implement SDK-specific timeout notification mechanisms: Go should cancel the context, Java should throw from heartbeat method, and core-based SDKs should propagate via their cancellation mechanism. Respect all three timeout types (start-to-close, schedule-to-close, heartbeat).",
      "workaround": "Make activity implementations reentrant to handle potential duplicate executions, though this adds complexity for sensitive workloads.",
      "resolution": "fixed",
      "resolutionDetails": "Feature request was accepted with implementation guidance defined for each SDK. Decision made to respect all three timeout types without replying to server about timeout (since it should already be timed out server-side).",
      "related": [],
      "keyQuote": "adding the worker side timeout notification lowers the chance of duplicate activity executions",
      "number": 170,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:51:00.419Z"
    },
    {
      "summary": "SDK-core local activities may lose progress when completing near the workflow task timeout. If a local activity completes and the response to the workflow takes longer than remaining timeout, the WFT will timeout before the completion is acknowledged, potentially causing workflows to get stuck.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "sdk-core",
        "local-activity",
        "workflow-task-handler"
      ],
      "concepts": [
        "timeout",
        "heartbeat",
        "activity-completion",
        "progress-flushing",
        "workflow-task"
      ],
      "severity": "high",
      "userImpact": "Workflows can timeout and become unable to progress when local activity completions occur near the workflow task timeout boundary.",
      "rootCause": "SDK-core does not flush local activity progress or issue heartbeats until the workflow has been notified and activated with the completion, leaving a window where progress can be lost if the notification takes too long.",
      "proposedFix": "Always flush completed local work and issue a workflow task heartbeat when nearing the workflow task timeout to ensure progress is not lost.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If these timing are consistent enough, the workflow will be stuck and not be able to progress.",
      "number": 168,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:46.886Z"
    },
    {
      "summary": "The metric name local_activity_execution_failed is inconsistent across SDKs. Go SDK uses one naming convention while Java and other SDKs use a different one. This inconsistency needs to be aligned across all SDKs.",
      "category": "feature",
      "subcategory": "metrics-alignment",
      "apis": [],
      "components": [
        "metrics",
        "local-activity",
        "sdk-alignment"
      ],
      "concepts": [
        "metric-naming",
        "consistency",
        "observability",
        "cross-sdk-alignment",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users working with multiple SDKs experience inconsistent metric names, making it difficult to standardize monitoring and observability across their Temporal deployments.",
      "rootCause": "Different SDKs implemented the local activity execution failed metric with different names without cross-SDK coordination.",
      "proposedFix": "Standardize the metric name across all SDKs to use a consistent naming convention (as documented in the SDK metrics reference).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        966
      ],
      "keyQuote": "Please align local_activity_failed / local_activity_execution_failed across SDKs. Currently there is a difference between Go and Java SDKs",
      "number": 167,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:44.901Z"
    },
    {
      "summary": "Request to add `--version latest` support across all Temporal SDKs to enable using the latest version tag. This would leverage language-specific mechanisms and could be integrated into CI workflows.",
      "category": "feature",
      "subcategory": "sdk-tooling",
      "apis": [],
      "components": [
        "sdk-build",
        "version-management",
        "ci-cd"
      ],
      "concepts": [
        "versioning",
        "sdk-tooling",
        "ci-automation",
        "dependency-management",
        "release-process"
      ],
      "severity": "medium",
      "userImpact": "Users would be able to easily reference the latest SDK version without manually tracking version numbers, simplifying SDK dependency management.",
      "rootCause": null,
      "proposedFix": "Implement language-dependent mechanisms to resolve `--version latest` to the actual latest version tag for each SDK.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Need `--version latest` support for all SDKs. This should use language-dependent ways to use the latest tag.",
      "number": 166,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:48.091Z"
    },
    {
      "summary": "SDK replayers need to support both the current hacked JSON format (with CONSTANT_CASE enums converted to CamelCase) and valid proto3 JSON format to allow programmatic history downloads via tooling like web UI and CLI.",
      "category": "feature",
      "subcategory": "history-replay",
      "apis": [],
      "components": [
        "replayer",
        "history-serialization",
        "proto-json-conversion"
      ],
      "concepts": [
        "proto-json",
        "enum-encoding",
        "history-export",
        "format-compatibility",
        "tooling-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot download histories programmatically in valid proto3 JSON format; they are limited to the hacked JSON format or non-programmatic exports.",
      "rootCause": "Generated Go API uses a custom patch that converts CONSTANT_CASE enum values to CamelCase, violating proto3 JSON spec. SDKs have custom conversion code to handle this non-standard format.",
      "proposedFix": "SDK replayers should support both hacked JSON output and valid proto JSON output. Eventually remove hacked JSON generation and revert custom conversion code in all SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDK replayers should support the hacked JSON output as well as valid proto JSON output to allow downloading histories programmatically",
      "number": 164,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:31.766Z"
    },
    {
      "summary": "Request to add a test specification that verifies SDKs can run a workflow-only worker that does not poll for activities or request eager activity executions.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "worker",
        "activity-polling"
      ],
      "concepts": [
        "workflow-execution",
        "worker-mode",
        "activity-execution",
        "test-specification",
        "SDK-feature"
      ],
      "severity": "medium",
      "userImpact": "Users need to verify their SDKs support workflow-only workers without activity polling overhead.",
      "rootCause": null,
      "proposedFix": "Add a spec to verify that SDKs can run a workflow only worker that does not poll for activities or request eager activity executions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add a spec to verify that SDKs can run a workflow only worker. The worker should not poll for activities or request eager activity executions.",
      "number": 160,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:34.175Z"
    },
    {
      "summary": "Update encryption samples across all SDK repositories to demonstrate encrypting failure messages and stack traces as part of the encryption feature implementation.",
      "category": "feature",
      "subcategory": "encryption-samples",
      "apis": [],
      "components": [
        "encryption-samples",
        "sample-repositories"
      ],
      "concepts": [
        "encryption",
        "failure-handling",
        "security",
        "stack-traces",
        "documentation"
      ],
      "severity": "low",
      "userImpact": "Users need updated sample code to understand how to properly encrypt sensitive failure information in their Temporal workflows.",
      "rootCause": null,
      "proposedFix": "Update encryption sample code in TypeScript, Go, Python, Java, and PHP sample repositories to opt-in to encrypted failure messages and stack traces.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Update the encryption sample in all of the sample repos to opt-in to encrypted failure messages and stack traces.",
      "number": 159,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:32.568Z"
    },
    {
      "summary": "Feature request for an SDK-agnostic test for the failure converter feature, which handles encoding attributes in failure scenarios. Implementation is complete for Go, TypeScript, and Python SDKs, with Java pending.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "failure-converter",
        "test-framework",
        "encoding"
      ],
      "concepts": [
        "failure-handling",
        "encoding",
        "attribute-conversion",
        "cross-sdk-testing",
        "error-serialization"
      ],
      "severity": "medium",
      "userImpact": "Ensures consistent failure encoding behavior across all Temporal SDKs through comprehensive test coverage.",
      "rootCause": null,
      "proposedFix": "Implement SDK-feature test for encoding attributes in failure converter across all supported SDKs",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "sdk-feature test for encoding attributes.",
      "number": 155,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:20.933Z"
    },
    {
      "summary": "Feature request to implement Schedule API support across Temporal SDKs. Tracks implementation status for Go, TypeScript, Java, Python, Ruby, and .NET SDKs.",
      "category": "feature",
      "subcategory": "schedule-api",
      "apis": [
        "Schedule"
      ],
      "components": [
        "sdk-go",
        "sdk-typescript",
        "sdk-java",
        "sdk-python",
        "sdk-ruby",
        "sdk-dotnet"
      ],
      "concepts": [
        "scheduling",
        "workflow-scheduling",
        "api-feature",
        "cross-sdk-implementation",
        "feature-parity"
      ],
      "severity": "medium",
      "userImpact": "Users need Schedule API support across all Temporal SDKs for consistent scheduling capabilities.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        73
      ],
      "keyQuote": "Features for https://github.com/temporalio/sdk-features/issues/73.",
      "number": 153,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:18.681Z"
    },
    {
      "summary": "Request to implement nightly CI testing that runs the latest versions of SDK main branches against server main to catch breaking changes and SDK-server incompatibilities before release.",
      "category": "feature",
      "subcategory": "ci-testing",
      "apis": [],
      "components": [
        "ci-pipeline",
        "sdk-testing",
        "server-integration",
        "docker"
      ],
      "concepts": [
        "integration-testing",
        "breaking-changes",
        "version-compatibility",
        "continuous-integration",
        "nightly-builds",
        "regression-detection"
      ],
      "severity": "low",
      "userImpact": "Enables earlier detection of incompatibilities between SDK and server changes, reducing the risk of releasing broken versions to users.",
      "rootCause": null,
      "proposedFix": "Set up nightly CI matrix testing SDK main branches against server main using latest docker images or master releases of temporalite.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The request is to test SDK main branches against server main to catch breaking changes well before they're released.",
      "number": 150,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:18.127Z"
    },
    {
      "summary": "Expose the reason field from workflow cancel requests in high-level SDK clients so users can specify cancellation reasons. This reason should be accessible in whatever mechanism each SDK uses to notify workflow code of cancel requests.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [
        "CancelWorkflow"
      ],
      "components": [
        "workflow-cancellation",
        "client-api",
        "exception-handling"
      ],
      "concepts": [
        "cancellation",
        "reason",
        "workflow-lifecycle",
        "user-notification",
        "api-exposure"
      ],
      "severity": "low",
      "userImpact": "Users can now provide and access cancellation reasons when requesting workflow cancellations across all SDKs.",
      "rootCause": null,
      "proposedFix": "Add optional reason field to workflow cancel request APIs in all high-level clients, making it available through the SDK's cancel notification mechanism.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #596, which is the current version handling this feature request.",
      "related": [
        596
      ],
      "keyQuote": "Add optional reason field to workflow cancel request APIs.",
      "number": 149,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:05.529Z"
    },
    {
      "summary": "Prometheus metrics counters are lazily initialized, causing monitoring solutions to miss error rate alarms on first-time failures. The request is to eagerly initialize counters for registered workflows and activities at registration time to ensure proper rate calculation.",
      "category": "feature",
      "subcategory": "metrics-initialization",
      "apis": [],
      "components": [
        "metrics",
        "worker",
        "activity-registry",
        "workflow-registry"
      ],
      "concepts": [
        "prometheus",
        "monitoring",
        "counters",
        "lazy-initialization",
        "rate-calculation",
        "error-detection"
      ],
      "severity": "medium",
      "userImpact": "Users relying on Prometheus metrics for monitoring workflow failures can miss alerting on the first error occurrence due to undefined rate calculations for newly-appearing counters.",
      "rootCause": "Temporal SDK metrics use lazy initialization for counters, which only start reporting when first incremented, breaking Prometheus rate calculation semantics that expect counters to start at zero.",
      "proposedFix": "Implement eager initialization of counters for known registered workflows and activities at registration time, with an optional worker configuration option (EagerMetricInitialization) that defaults to false for backward compatibility.",
      "workaround": "Use Prometheus query shenanigans and existential metric workarounds as documented in https://www.robustperception.io/existential-issues-with-metrics/",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        3886
      ],
      "keyQuote": "Prometheus monitoring solutions wishing to alarm on error rates can miss this first increment since prometheus's rate calculation depends upon observing change over time",
      "number": 146,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:07.578Z"
    },
    {
      "summary": "Workflow.await/sleep with zero or negative duration produces different event sequences compared to positive durations, causing non-deterministic replay issues when the duration is calculated dynamically in workflow code.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.await",
        "Workflow.sleep"
      ],
      "components": [
        "workflow-execution",
        "event-history",
        "replay-engine"
      ],
      "concepts": [
        "determinism",
        "replay",
        "timer-events",
        "duration-calculation",
        "non-deterministic-failure"
      ],
      "severity": "high",
      "userImpact": "Workflows that calculate sleep duration dynamically fail non-deterministically during replay across SDK implementations.",
      "rootCause": "SDKs produce different event sequences for zero/negative durations versus positive durations - zero duration doesn't generate TimerStarted event, causing history mismatch on replay.",
      "proposedFix": "SDKs should handle zero/negative duration gracefully without failing - either skip timer generation with logging or fail with explicit error message rather than non-deterministic replay failure.",
      "workaround": "Calculate duration inside side effects or local activities/activities so it's not re-calculated on replay.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflow.await / sleep produces different sequence of events if n<=0 and when n>0 (basically if n>0 will have TimerStarted event from command in history, if n<=0 TimerStarted event is not in history)",
      "number": 145,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:50:03.079Z"
    },
    {
      "summary": "Request to add gRPC error status code tags to request metrics to help SDKs expose error information without relying solely on server-side metrics. The team also addressed resource exhausted errors as a related metric.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "gRPC",
        "error-handling"
      ],
      "concepts": [
        "error-codes",
        "status-codes",
        "request-metrics",
        "resource-exhausted",
        "monitoring",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "SDKs can now expose gRPC error status codes in request metrics, allowing users without server-side metric access to monitor and troubleshoot error patterns.",
      "rootCause": null,
      "proposedFix": "Add status_code tag to request_failure metrics using SCREAMING_SNAKE names from gRPC spec; create temporal_request_resource_exhausted counter with cause tag for resource exhaustion tracking.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented status_code tag on request_failure metrics and separate temporal_request_resource_exhausted counter with cause field containing enum string values.",
      "related": [],
      "keyQuote": "Not all user has access to all server side metrics. So this is critical.",
      "number": 144,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:49.385Z"
    },
    {
      "summary": "SDKs should use the worker_may_ignore flag on history events to enable safe handling of new events by older SDK versions. This allows the server to add new events that can be safely ignored by SDKs that don't yet understand them.",
      "category": "feature",
      "subcategory": "event-handling",
      "apis": [],
      "components": [
        "worker",
        "history-event-processor",
        "version-compatibility"
      ],
      "concepts": [
        "backward-compatibility",
        "event-handling",
        "version-management",
        "sdk-upgrade",
        "event-flags",
        "protocol-evolution"
      ],
      "severity": "medium",
      "userImpact": "Without this feature, SDKs cannot safely add new events to the workflow history without breaking older SDK versions, limiting the ability to evolve the Temporal protocol.",
      "rootCause": null,
      "proposedFix": "SDKs should start using the worker_may_ignore flag to check if events can be safely ignored before processing unknown events.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDKs should start using this flag to enable adding new events that are safe to ignore by older SDKs.",
      "number": 143,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:52.212Z"
    },
    {
      "summary": "SDKs should send client capabilities in gRPC metadata to allow the server to make informed decisions about which code paths to use. This enables clean protocol evolution and fixes issues where the server currently relies on unreliable heuristics.",
      "category": "feature",
      "subcategory": "grpc-communication",
      "apis": [],
      "components": [
        "grpc-client",
        "metadata",
        "protocol"
      ],
      "concepts": [
        "capabilities",
        "versioning",
        "protocol-evolution",
        "server-communication",
        "client-state",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Enables users to access advanced features like non-final workflow retry errors and specific cron run results that currently require workarounds.",
      "rootCause": "Server lacks a clean, reliable way to determine which client capabilities are supported, currently relying on heuristics and per-call overhead concerns.",
      "proposedFix": "Send client capabilities in gRPC metadata on connection or per-call; alternatively, add typed proto fields to specific requests that need capability negotiation.",
      "workaround": "Server currently uses an ugly hack and unreliable heuristics to detect when to trigger capability-dependent behavior.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1949
      ],
      "keyQuote": "we need to be able to evolve software and switch to newer code paths when new capabilities are supported",
      "number": 142,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:52.327Z"
    },
    {
      "summary": "Request to add a metadata field to commands and history events for attaching additional troubleshooting and diagramming information, such as thread IDs. After discussion, this evolved into a user metadata system with well-known enumerated keys and encryptable payload values.",
      "category": "feature",
      "subcategory": "metadata-tracking",
      "apis": [],
      "components": [
        "command",
        "history-event",
        "api"
      ],
      "concepts": [
        "metadata",
        "troubleshooting",
        "diagramming",
        "event-tracking",
        "user-defined-data",
        "encryptable-payload"
      ],
      "severity": "medium",
      "userImpact": "Users can now attach custom metadata to workflow commands and events for better observability, troubleshooting, and UI integration.",
      "rootCause": null,
      "proposedFix": "Add WorkflowEventMetadata with enumerated well-known keys and encryptable payload values to Command and HistoryEvent protobuf messages.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as user metadata feature with well-known enumerated keys and payload values. API PR #371 provided the implementation approach.",
      "related": [
        486,
        371,
        259
      ],
      "keyQuote": "Add a metadata field to the Command protobuf. Then SDKs would be able to add use case specific information to commands.",
      "number": 141,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:37.914Z"
    },
    {
      "summary": "Feature request to expose history size bytes to workflow execution info to help workflows determine when to use continue-as-new. The value is available in WorkflowTaskStartedEventAttributes but needs to be accessible through the execution info API.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowExecutionInfo",
        "WorkflowTaskStartedEventAttributes"
      ],
      "components": [
        "workflow-execution",
        "api",
        "history"
      ],
      "concepts": [
        "history-size",
        "continue-as-new",
        "workflow-task",
        "execution-info",
        "search-attributes"
      ],
      "severity": "medium",
      "userImpact": "Workflows cannot efficiently determine when to use continue-as-new without expensive describe calls, impacting workflow scalability and performance.",
      "rootCause": "History size bytes information is available in WorkflowTaskStartedEventAttributes but not exposed through WorkflowExecutionInfo API for workflow access.",
      "proposedFix": "Add history_size_bytes to WorkflowTaskStartedEventAttributes in the poll response, or calculate it in the SDK, making it accessible to workflows.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        16,
        178,
        1114,
        2726,
        242,
        3055
      ],
      "keyQuote": "Since this is for helping with continue as new, they also added `history_size_bytes` and even `suggest_continue_as_new` to `WorkflowTaskStartedEventAttributes`",
      "number": 140,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:36.368Z"
    },
    {
      "summary": "Standardize contextual logging across all Temporal SDKs to ensure identical fields are logged for workflows and activities, with consistent naming conventions and complete propagation to console output by default.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logging",
        "workflow-context",
        "activity-context"
      ],
      "concepts": [
        "contextual-logging",
        "logging-standardization",
        "debugging",
        "observability",
        "context-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users need consistent logging context across different SDKs for better debugging and observability of workflows and activities.",
      "rootCause": null,
      "proposedFix": "Ensure all SDKs log the specified contextual fields (with language-appropriate naming conventions) for workflows and activities, and propagate them to console output by default regardless of debug mode.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This is already the behavior in all of our SDKs (except for Core), need to make sure the contextual information is identical.",
      "number": 138,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:34.148Z"
    },
    {
      "summary": "Request to conduct a comprehensive stress test of eager activity dispatch feature on production-like cluster infrastructure. Test should compare performance with and without eager dispatch across different SDK implementations using serial and parallel activity workflows.",
      "category": "feature",
      "subcategory": "activity-dispatch",
      "apis": [],
      "components": [
        "activity-executor",
        "worker",
        "dispatcher",
        "performance-testing"
      ],
      "concepts": [
        "eager-dispatch",
        "activity-scheduling",
        "performance",
        "stress-testing",
        "concurrency",
        "throughput"
      ],
      "severity": "medium",
      "userImpact": "Understanding eager activity dispatch implications helps users optimize their workflow configurations for better performance and resource utilization.",
      "rootCause": null,
      "proposedFix": "Set up dedicated testing infrastructure to run stress tests with configurable eager activity dispatch (adjusting maximum from default of 3) across both serial and parallel activity scenarios on multiple SDK types.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We may as well try to set this up to be something that can be re-usable for general perf testing as well. We'll want a dedicated host for this too",
      "number": 137,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:20.919Z"
    },
    {
      "summary": "Protobuf 3.20.1 dependency has a parsing vulnerability (CVE-2022-1941) that can cause out-of-memory failures and denial of service through specially crafted MessageSet messages. The issue was automatically closed after the vulnerable library was removed from the inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "protobuf-parser",
        "package-builder"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "memory-exhaustion",
        "dependency-management",
        "cve-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users could be vulnerable to denial-of-service attacks through malicious protobuf messages if using the affected temporalio-0.1b1 release.",
      "rootCause": "Protobuf 3.20.1 parsing logic for MessageSet type allows multiple key-value pairs per element to cause out-of-memory failures",
      "proposedFix": "Upgrade protobuf to version 3.20.2 or later (3.18.3, 3.19.5, 3.20.2, 3.21.6 for protobuf-cpp and 3.18.3, 3.19.5, 3.20.2, 4.21.6 for protobuf-python)",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Automatically closed by Mend because the vulnerable library was either marked as ignored or removed from the dependency inventory",
      "related": [],
      "keyQuote": "A parsing vulnerability for the MessageSet type in the ProtocolBuffers versions prior to and including 3.20.1 can lead to out of memory failures",
      "number": 136,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:24.178Z"
    },
    {
      "summary": "Two transitive dependency vulnerabilities detected in go.temporal.io/sdk-v1.15.0: CVE-2022-27664 (HTTP/2 DoS) and CVE-2022-32149 (Accept-Language parsing DoS), both with CVSS 7.5 severity. Issue was automatically closed as the vulnerable libraries were removed from the Mend inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "go-grpc",
        "golang-x-net",
        "golang-x-text"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "dependency-upgrade",
        "transitive-dependency",
        "cvss-score"
      ],
      "severity": "high",
      "userImpact": "Users of the SDK could be vulnerable to denial-of-service attacks through HTTP/2 connection failures or malformed Accept-Language headers until dependencies are upgraded.",
      "rootCause": "Transitive dependencies golang.org/x/net and golang.org/x/text contained vulnerabilities that were not fixable in the version of go.temporal.io/sdk being used.",
      "proposedFix": "Upgrade golang.org/x/text to v0.3.8 or later; coordinate upstream fixes for golang.org/x/net through google.golang.org/grpc updates.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable libraries were removed from inventory or marked as ignored in the specific branches.",
      "related": [],
      "keyQuote": "This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.",
      "number": 134,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:20.894Z"
    },
    {
      "summary": "Feature request to add specification tests for workflow handles with different run ID types (result run ID, first execution run ID, and generic run ID). The issue identifies a gap in test coverage for how these different run ID types are used in workflow handles.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowHandle"
      ],
      "components": [
        "workflow-handle",
        "test-framework",
        "spec-tests"
      ],
      "concepts": [
        "run-id",
        "workflow-execution",
        "test-coverage",
        "handle-types",
        "specification"
      ],
      "severity": "low",
      "userImpact": "Lack of comprehensive test specifications for workflow handle run ID types may lead to inconsistent implementations across SDKs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We have various run IDs in our workflow handles: run ID for getting a result, first execution run ID, \"just\" run ID. We're missing the spec for how those are used.",
      "number": 133,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:02.431Z"
    },
    {
      "summary": "Feature request to add workflow result interception capability, similar to existing signal, query, and describe interception features available in Temporal SDKs.",
      "category": "feature",
      "subcategory": "interception",
      "apis": [
        "StartWorkflow",
        "GetWorkflowResultHandle"
      ],
      "components": [
        "client",
        "workflow-handle",
        "interception-framework"
      ],
      "concepts": [
        "interception",
        "result-fetching",
        "client-side-hooks",
        "extensibility",
        "handle-creation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot intercept or customize workflow result fetching behavior, limiting extensibility for logging, monitoring, or modifying client-side result handling.",
      "rootCause": null,
      "proposedFix": "Allow interception of workflow results through a standardized interception mechanism, potentially including interception at handle creation time for Python and TypeScript SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We allow signal, query, and (in some SDKs) even describe interception, but we don't allow workflow result interception.",
      "number": 130,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:04.297Z"
    },
    {
      "summary": "Dependency security vulnerability report for go.temporal.io/server-v1.17.4 containing 4 vulnerabilities in transitive dependencies (Apache Thrift 0.10.0 and modernc.org/libc), with the highest severity being 7.5 (CVSS). Issue was automatically closed by Mend.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "server-dependencies",
        "ringpop-go"
      ],
      "concepts": [
        "security-vulnerability",
        "transitive-dependency",
        "cvss-score",
        "apache-thrift",
        "denial-of-service"
      ],
      "severity": "high",
      "userImpact": "Users running go.temporal.io/server-v1.17.4 are exposed to security vulnerabilities that could lead to denial of service attacks or unauthorized file access through vulnerable transitive dependencies.",
      "rootCause": "Apache Thrift 0.10.0 (transitive dependency via ringpop-go) contains multiple CVEs related to endless loops with specific input data and panic conditions in JSON protocol handlers. modernc.org/libc v1.16.10 contains CVE-2020-28928.",
      "proposedFix": "Upgrade Apache Thrift dependency to version 0.13.0 or later (referenced as fix resolution for CVE-2019-0205 and CVE-2019-0210). Update ringpop-go or its dependency chain to use a patched Thrift version.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend as the vulnerable library was marked as ignored or is no longer part of the Mend inventory in the specific branch.",
      "related": [],
      "keyQuote": "Apache Thrift all versions up to and including 0.12.0, a server or client may run into an endless loop when feed with specific input data.",
      "number": 127,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:49:09.004Z"
    },
    {
      "summary": "Feature request to provide dynamic workflow and activity resolution as fallback mechanisms when the SDK does not find matching implementations, similar to Java's DynamicWorkflow and DynamicActivity. Multiple SDKs still lack this functionality.",
      "category": "feature",
      "subcategory": "workflow-activity-resolution",
      "apis": [
        "DynamicWorkflow",
        "DynamicActivity"
      ],
      "components": [
        "worker",
        "workflow-executor",
        "activity-executor",
        "interceptor"
      ],
      "concepts": [
        "dynamic-resolution",
        "fallback-mechanism",
        "workflow-execution",
        "activity-execution",
        "extensibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot dynamically resolve workflows and activities at runtime, limiting SDK flexibility and requiring hardcoded implementations.",
      "rootCause": null,
      "proposedFix": "Either add inbound interceptor methods for resolution (e.g., resolve, prepare, preExecute) or implement a worker option callback mechanism.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Issue consolidated with #201 which tracks dynamic workflow/activity support needed for Go and TypeScript SDKs.",
      "related": [
        201,
        543
      ],
      "keyQuote": "Java has DynamicWorkflow and DynamicActivity that serve as fallback for when the SDK does not find a matching workflow or activity implementation to execute.",
      "number": 125,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:51.981Z"
    },
    {
      "summary": "Enable TCP keep-alive by default for SDK connections to help clients detect closed connections faster, and allow users to customize keep-alive settings to suit their specific network environments.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [],
      "components": [
        "sdk-client",
        "connection-pool",
        "grpc-configuration"
      ],
      "concepts": [
        "keep-alive",
        "tcp-connection",
        "network-reliability",
        "connection-timeout",
        "idle-detection",
        "client-discovery"
      ],
      "severity": "medium",
      "userImpact": "Idle clients will now detect closed TCP connections more quickly, improving reliability and reducing delays in detecting network failures.",
      "rootCause": "Idle clients take a long time to discover when a TCP connection is closed without keep-alive enabled.",
      "proposedFix": "Enable TCP keep-alive by default with gRPC settings: keepalive_permit_without_calls=1, keepalive_time_ms=30000, keepalive_timeout_ms=15000, and expose customization options to users.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across multiple SDKs (TypeScript, Python, .NET, Go, Java) with gRPC keep-alive defaults. TypeScript worker and PHP SDK implementations still pending.",
      "related": [
        362,
        371,
        585,
        1275,
        395,
        125,
        1248,
        1872
      ],
      "keyQuote": "Due to the number of issues we've gotten where idle clients take a long time to discover when a TCP connection is closed we decided to turn keep-alive on by default.",
      "number": 123,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:51.087Z"
    },
    {
      "summary": "The server generates large error messages that exceed gRPC/HTTP2's 8KB header limit, causing cryptic errors on the SDK side. The feature request is to increase maxInboundMetadataSize from 8KB to 4MB across all SDKs to accommodate these unbounded server error messages.",
      "category": "feature",
      "subcategory": "grpc-configuration",
      "apis": [],
      "components": [
        "grpc-client",
        "metadata-handling",
        "error-messaging"
      ],
      "concepts": [
        "header-size-limit",
        "grpc-configuration",
        "error-messages",
        "metadata",
        "server-communication",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users receive cryptic error messages when the server generates large error messages that don't fit in the standard gRPC header size limit.",
      "rootCause": "Server generates unbounded error messages that exceed the 8KB gRPC/HTTP2 header size limit on the SDK side.",
      "proposedFix": "Set maxInboundMetadataSize to 4MB in all SDKs to accommodate large server error messages.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        3284,
        1396
      ],
      "keyQuote": "The server sometimes may generate large (and unbounded) error messages that don't fit into a standard 8Kb limit on headers in gRPC and HTTP/2.",
      "number": 122,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:49.060Z"
    },
    {
      "summary": "SDKs currently perform enum conversion on history JSON even if already done, preventing UI/tctl from outputting proper proto JSON format. Request to make all SDKs idempotent - only converting if not already done - with tests confirming both converted and unconverted JSON work in replay APIs.",
      "category": "feature",
      "subcategory": "history-json-conversion",
      "apis": [
        "replay"
      ],
      "components": [
        "history-json-converter",
        "proto-json-handler",
        "enum-converter"
      ],
      "concepts": [
        "enum-conversion",
        "proto-json-format",
        "idempotent-processing",
        "json-transformation",
        "backwards-compatibility",
        "replay-api"
      ],
      "severity": "medium",
      "userImpact": "Users must manually convert JSON in each SDK to load history objects, creating friction and inconsistency if UI/tctl outputs proper proto JSON.",
      "rootCause": "History JSON converters lack idempotency - they convert enums without checking if conversion was already applied upstream.",
      "proposedFix": "Implement enum conversion detection to skip conversion if already done; ensure all SDKs handle both converted and unconverted JSON in replay APIs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        118
      ],
      "keyQuote": "Make sure all SDKs only perform the enum conversion if not already done. Meaning they should ignore conversion if already done by the incoming JSON.",
      "number": 121,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:38.000Z"
    },
    {
      "summary": "Feature request to add an `upsertMemo` command that allows workflows to modify memo fields from within the workflow, similar to the existing `upsertSearchAttributes` functionality. This is a cross-SDK feature with implementations in progress or completed across multiple SDKs.",
      "category": "feature",
      "subcategory": "workflow-memo",
      "apis": [
        "upsertMemo",
        "upsertSearchAttributes"
      ],
      "components": [
        "workflow",
        "memo-management",
        "sdk-core"
      ],
      "concepts": [
        "observability",
        "workflow-metadata",
        "partial-updates",
        "merging-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users can now dynamically update workflow memo fields from within the workflow execution, improving workflow observability and metadata management capabilities.",
      "rootCause": null,
      "proposedFix": "Implement upsertMemo command across all SDKs with server-side merging of partial upserts using 'last writer wins' strategy, with optimization to batch multiple upserts within an activation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        383,
        1124,
        190,
        883,
        623,
        3047
      ],
      "keyQuote": "User would like to edit `memo` from inside the Workflow, like [`upsertSearchAttributes`](https://docs.temporal.io/application-development/observability?lang=ts#upsert-custom-search-attributes)",
      "number": 119,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:36.805Z"
    },
    {
      "summary": "Feature request for declarative schedule management in Temporal. Users want to define schedules declaratively (e.g., via annotations, configuration files, or Terraform) rather than imperatively through tctl or SDK scripts, enabling better infrastructure-as-code practices and easier maintenance.",
      "category": "feature",
      "subcategory": "schedule-management",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "schedule-service",
        "worker",
        "api-design"
      ],
      "concepts": [
        "declarative-infrastructure",
        "schedule-deployment",
        "configuration-management",
        "terraform-integration",
        "workflow-annotations",
        "upsert-operations"
      ],
      "severity": "medium",
      "userImpact": "Users cannot manage Temporal schedules declaratively, forcing them to use imperative APIs or scripts, which is suboptimal for infrastructure-as-code practices and maintainability.",
      "rootCause": null,
      "proposedFix": "Implement declarative schedule specification through annotations, separate configuration objects, or files (e.g., myWorkflow.schedule.ts). Support upserting schedules on worker startup or via external scripts/Terraform provider. Preserve schedule state (paused/unpaused) during updates.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I shouldn't have to use an imperative api to work with something that should just 'be there'. I want to annotate a workflow with a schedule and have it 'take effect' when I deploy the worker.",
      "number": 118,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:36.081Z"
    },
    {
      "summary": "TemporalChangeVersion search attribute is not being upserted with patch commands in SDKs (Java, TypeScript, Python, PHP), preventing users from querying workflows by change version as documented. Go SDK already implements this correctly.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [
        "UpsertSearchAttributes"
      ],
      "components": [
        "patch-api",
        "search-attributes",
        "workflow-runtime"
      ],
      "concepts": [
        "versioning",
        "patching",
        "search-attributes",
        "workflow-query",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot query workflows by TemporalChangeVersion when using the patch API, breaking documented functionality for tracking workflow versions.",
      "rootCause": "SDK implementations do not automatically upsert TemporalChangeVersion search attribute when patch commands are applied, unlike the Go SDK.",
      "proposedFix": "Add UpsertSearchAttributes with TemporalChangeVersion in patch command implementation for each SDK language.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Decided to implement in language SDKs rather than Core, as it's simpler and allows TemporalChangeVersion to be available in searchAttributes during workflow task processing.",
      "related": [
        587,
        817
      ],
      "keyQuote": "Add an `UpsertSearchAttributes` with `TemporalChangeVersion: <change_id>-<version_id>` with each patch command.",
      "number": 117,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:23.666Z"
    },
    {
      "summary": "Two high-severity vulnerabilities (CVE-2019-0210 and CVE-2019-0205) detected in the Thrift library dependency (uber-go/tally v4.1.1) used by the features project. Both are Apache Thrift issues causing potential DoS through panic or endless loops when fed malformed input data.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "tally-metrics",
        "thrift-library"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-upgrade",
        "denial-of-service",
        "malformed-input",
        "panic-handling"
      ],
      "severity": "high",
      "userImpact": "Systems using this dependency version are vulnerable to denial-of-service attacks through malformed Thrift protocol input.",
      "rootCause": "Apache Thrift versions 0.9.3 to 0.12.0 have insufficient input validation in TJSONProtocol and TSimpleJSONProtocol, causing panic or endless loops.",
      "proposedFix": "Upgrade github.com/uber-go/tally/v4 to a version that depends on Apache Thrift 0.13.0 or later.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "In Apache Thrift 0.9.3 to 0.12.0, a server implemented in Go using TJSONProtocol or TSimpleJSONProtocol may panic when feed with invalid input data.",
      "number": 116,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:22.507Z"
    },
    {
      "summary": "Five high-severity dependency vulnerabilities detected in jackson-databind and protobuf-java libraries used by the temporal-sdk-1.15.0.jar, including resource exhaustion issues with CVSS scores of 7.5.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "jackson-databind",
        "protobuf-java",
        "dependency-management"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-upgrade",
        "resource-exhaustion",
        "deserialization",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Users of temporal-sdk-1.15.0 are exposed to high-severity security vulnerabilities that could lead to denial of service attacks through resource exhaustion.",
      "rootCause": "Outdated transitive dependencies: jackson-databind-2.13.1 lacks checks in deserialization to prevent deeply nested array exploitation, and protobuf-java-3.21.4 has parsing vulnerabilities.",
      "proposedFix": "Upgrade jackson-databind to 2.13.4.1 or later and protobuf-java to a patched version addressing CVE-2022-3509 and CVE-2022-3171.",
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the inventory.",
      "related": [],
      "keyQuote": "resource exhaustion can occur because of a lack of a check in BeanDeserializer._deserializeFromArray to prevent use of deeply nested arrays",
      "number": 115,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:22.090Z"
    },
    {
      "summary": "SDKs populate namespace and task queue with garbage/test data during replay, affecting workflow code. Feature request to accept optional namespace in replay options and derive task queue from history events.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replay-engine",
        "replay-options",
        "history-events"
      ],
      "concepts": [
        "replay",
        "namespace",
        "task-queue",
        "history",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Users experience incorrect namespace and task queue values in workflow code during replay testing, potentially causing logic errors in test scenarios.",
      "rootCause": "SDKs currently populate namespace and task queue with placeholder or test values instead of deriving them from actual history data during replay.",
      "proposedFix": "Accept optional namespace parameter in replay options and extract task queue from the start event in history.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Some SDKs populate these values with garbage or test data during replay which affects people's workflow code",
      "number": 114,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:06.435Z"
    },
    {
      "summary": "Request for documentation on testing approaches across Temporal SDKs, including replay, test server emulation, time-skipping, sandbox environments, debugging, and error handling.",
      "category": "docs",
      "subcategory": "testing-documentation",
      "apis": [
        "WorkflowClient",
        "TestWorkflowClient"
      ],
      "components": [
        "test-server",
        "workflow-testing",
        "time-skipping",
        "sandbox"
      ],
      "concepts": [
        "testing",
        "replay",
        "emulation",
        "debugging",
        "error-handling",
        "documentation"
      ],
      "severity": "medium",
      "userImpact": "Developers need clear, comprehensive documentation to understand how to test workflows effectively across different Temporal SDKs.",
      "rootCause": null,
      "proposedFix": "Create a Testing section in the application development guide following the provided outline covering replay, server emulation, time-skipping, workflow sandbox, debugging, and error handling.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add comments, content, or suggestions. This will be the outline we will follow.",
      "number": 113,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:08.778Z"
    },
    {
      "summary": "Add warning log when client certificate has expired during connection to help users quickly identify certificate expiration as the cause of connection failures, reducing troubleshooting time.",
      "category": "feature",
      "subcategory": "tls-certificates",
      "apis": [],
      "components": [
        "tls-configuration",
        "worker-connection",
        "logging"
      ],
      "concepts": [
        "certificate-expiration",
        "connection-debugging",
        "tls-handshake",
        "error-diagnostics",
        "client-authentication"
      ],
      "severity": "medium",
      "userImpact": "Users experience sudden worker disconnections with unclear error messages and struggle to identify expired certificates as the root cause, leading to extended troubleshooting time.",
      "rootCause": "Expired client certificates are not explicitly detected and logged, forcing users to spend significant time diagnosing connection failures.",
      "proposedFix": "Add warning-level logs during connection attempts or TLS configuration setup to explicitly check and report if the supplied client certificate has already expired.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The goal is to reduce the user's time to detect why their workers cannot connect by adding a warning-level log if the certificate is indeed expired.",
      "number": 111,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:48:04.885Z"
    },
    {
      "summary": "gson-2.8.8 dependency contains two high-severity vulnerabilities (WS-2021-0419 and CVE-2022-25647) that enable Denial of Service attacks via the writeReplace() method. Both vulnerabilities are fixed in gson-2.8.9.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "gradle-build",
        "dependency-management",
        "gson-library"
      ],
      "concepts": [
        "deserialization",
        "denial-of-service",
        "vulnerability",
        "security",
        "dependency-upgrade",
        "cvss-score"
      ],
      "severity": "high",
      "userImpact": "Applications using gson-2.8.8 are vulnerable to DoS attacks through deserialization of untrusted data via the writeReplace() method.",
      "rootCause": "Insecure deserialization handling in gson-2.8.8's writeReplace() method allows attackers to trigger DoS conditions.",
      "proposedFix": "Upgrade gson from 2.8.8 to 2.8.9 to patch both vulnerabilities.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was removed from inventory or marked as ignored in the build configuration.",
      "related": [],
      "keyQuote": "Upgrade version to 2.8.9 (Release Date: 2021-10-11 and 2022-05-01)",
      "number": 109,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:52.261Z"
    },
    {
      "summary": "Dependency security vulnerability in jackson-databind (CVE-2020-36518) affecting temporal-sdk-1.14.0.jar, allowing denial of service through nested object stack overflow.",
      "category": "bug",
      "subcategory": "dependency-vulnerability",
      "apis": [],
      "components": [
        "jackson-databind",
        "dependency-management"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "denial-of-service",
        "dependency",
        "stack-overflow",
        "jackson",
        "deserialization"
      ],
      "severity": "high",
      "userImpact": "Users of temporal-sdk-1.14.0 are exposed to a denial of service vulnerability through malicious input with deeply nested objects.",
      "rootCause": "jackson-databind versions up to 2.13.2 are vulnerable to stack overflow exceptions when processing deeply nested objects during deserialization.",
      "proposedFix": "Upgrade jackson-databind to version 2.12.6.1 or 2.13.2.1",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or no longer part of the Mend inventory.",
      "related": [],
      "keyQuote": "jackson-databind before 2.13.0 allows a Java StackOverflow exception and denial of service via a large depth of nested objects.",
      "number": 108,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:54.254Z"
    },
    {
      "summary": "Create feature specifications and comprehensive tests for worker versioning across all Temporal SDKs. This tracks implementation of versioning support including test cases and specs as a coordinated effort across the SDK ecosystem.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "worker",
        "versioning",
        "testing"
      ],
      "concepts": [
        "worker-versioning",
        "cross-sdk-feature",
        "test-specifications",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users need consistent worker versioning capabilities and test coverage across all Temporal SDKs to safely manage deployment and version upgrades.",
      "rootCause": null,
      "proposedFix": "Implement feature specs and comprehensive test cases for whole worker versioning, with coverage across Go, TypeScript, Python, Java, and .NET SDKs.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because the project pivoted to a completely different versioning approach, making this original plan obsolete.",
      "related": [],
      "keyQuote": "Closing this since we're doing totally different versioning stuff now anyway",
      "number": 107,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:53.717Z"
    },
    {
      "summary": "When an activity has a heartbeat timeout configured but never sends a heartbeat, the server schedules a retry while the old activity continues running. The request is for SDKs to automatically fail activities that don't send heartbeats within the configured timeout.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-handler",
        "context-manager"
      ],
      "concepts": [
        "heartbeat",
        "timeout",
        "activity-failure",
        "fast-fail",
        "retry",
        "context-cancellation"
      ],
      "severity": "medium",
      "userImpact": "Users with buggy activity implementations that don't heartbeat get delayed failures and retries instead of fast failures, leading to inefficient resource usage and longer error recovery times.",
      "rootCause": "Activities lack automatic timeout enforcement for missing heartbeats; the context is only cancelled when the activity attempts to heartbeat rather than at the configured timeout.",
      "proposedFix": "SDK should set a heartbeat timeout and cancel the activity context automatically if no heartbeat is received within the configured interval, allowing the activity to fail fast.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDK should set a heartbeat timeout, and cancel the context so activity could fail fast if it does not try to heartbeat at all.",
      "number": 105,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:40.376Z"
    },
    {
      "summary": "Add CLI support for preparing SDK directories with pre-downloaded dependencies and a flag to use prepared directories in the run command instead of temporary directories.",
      "category": "feature",
      "subcategory": "cli-packaging",
      "apis": [],
      "components": [
        "cli",
        "package-manager",
        "container-preparation"
      ],
      "concepts": [
        "build-preparation",
        "dependency-caching",
        "container-image",
        "offline-installation",
        "directory-setup"
      ],
      "severity": "medium",
      "userImpact": "Enables containerized SDK execution by allowing pre-downloaded dependencies and reusable prepared directories instead of temporary ones.",
      "rootCause": null,
      "proposedFix": "Implement a 'prepare' command that bakes pre-run steps into a container and add --prepared-dir flag to run command.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support preparing SDKs for container deployment with pre-downloaded dependencies.",
      "related": [
        71
      ],
      "keyQuote": "Need a command to \"prepare\" a dir for run the same way we prepare a temp dir during run today",
      "number": 104,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:38.611Z"
    },
    {
      "summary": "Request to create a PHP harness for testing PHP SDK specifications. This would enable the development and validation of PHP SDK features against Temporal test specifications.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "php-sdk",
        "test-harness",
        "spec-runner"
      ],
      "concepts": [
        "testing",
        "sdk-validation",
        "spec-compliance",
        "php-implementation"
      ],
      "severity": "medium",
      "userImpact": "Enables PHP SDK contributors to create and validate PHP specifications using the standard harness approach used by other SDKs.",
      "rootCause": null,
      "proposedFix": "Implement a PHP harness following the pattern established by other SDK harnesses",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "PHP harness was implemented, enabling PHP SDK specification creation and testing",
      "related": [],
      "keyQuote": "So we can start creating PHP specs",
      "number": 103,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:36.841Z"
    },
    {
      "summary": "Request for a new metric `worker_task_slots_total` to expose the total number of configured worker task slots, enabling better monitoring and alerting on task slot availability and utilization.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "metrics"
      ],
      "concepts": [
        "task slots",
        "worker configuration",
        "monitoring",
        "alerting",
        "resource utilization",
        "capacity planning"
      ],
      "severity": "low",
      "userImpact": "Enables users to better tune worker configuration and set up percentage-based alerting on task slot availability.",
      "rootCause": null,
      "proposedFix": "Emit a metric `worker_task_slots_total` that shows the total number of slots the worker is configured for, or alternatively emit `worker_task_slots_usage` showing the ratio of available to configured slots (0-1).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A metric worker_task_slots_total which emits the number of slots the worker is configured for.",
      "number": 98,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:26.446Z"
    },
    {
      "summary": "SDKs should implement more aggressive backoff when encountering ResourceExhaustedError from the server, as continued retry attempts can worsen outages. The request is to add a custom retry policy with larger backoff intervals and smaller max attempt counts specifically for resource exhaustion scenarios.",
      "category": "feature",
      "subcategory": "retry-policy",
      "apis": [],
      "components": [
        "retry-policy",
        "error-handling",
        "backoff-logic"
      ],
      "concepts": [
        "retry",
        "backoff",
        "resource-exhaustion",
        "transient-errors",
        "server-capacity",
        "error-classification",
        "exponential-backoff"
      ],
      "severity": "high",
      "userImpact": "Users experience worse outages when SDKs aggressively retry during server resource exhaustion, instead of backing off more conservatively.",
      "rootCause": "Current retry policy treats ResourceExhaustedError like other transient errors with insufficient backoff, causing aggressive retries that worsen server overload conditions.",
      "proposedFix": "Implement a custom retry behavior for ResourceExhaustedError with larger backoff intervals and smaller max attempt counts. Consider using an attempt-aware backoff calculation method instead of fixed policies.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "aggressive retry will worsen the situation and could lead to more serious outage",
      "number": 96,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:25.423Z"
    },
    {
      "summary": "Feature request to group Temporal-specific log tags in structured logging across SDKs. Currently, log tags are generic/unqualified, and the proposal is to use a structured \"temporal\" object with detailed fields to improve log organization and clarity.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logging",
        "structured-logging",
        "sdk"
      ],
      "concepts": [
        "logging",
        "structured-logging",
        "tags",
        "observability",
        "sdk-standardization"
      ],
      "severity": "low",
      "userImpact": "Users would have better organized and more discoverable Temporal-specific logs through consistent structured logging across SDKs.",
      "rootCause": null,
      "proposedFix": "Use a \"temporal\" object with detailed fields as the structured log info in SDKs that support structured logging (e.g., Go)",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Need to try and use a \"temporal\" object with detailed fields as the structured log info where we can.",
      "number": 94,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:25.613Z"
    },
    {
      "summary": "SDKs need to prefix span and span tag names with 'temporal' or 'io.temporal' for proper namespacing in observability systems. The discussion centers on whether this should be the default behavior or opt-in, considering backwards compatibility implications.",
      "category": "feature",
      "subcategory": "observability-spans",
      "apis": [],
      "components": [
        "span-naming",
        "observability",
        "tracing"
      ],
      "concepts": [
        "observability",
        "tracing",
        "span-tags",
        "backwards-compatibility",
        "namespacing",
        "defaults"
      ],
      "severity": "medium",
      "userImpact": "Users may encounter span name collisions or lack of proper namespacing in observability systems when using Temporal SDKs.",
      "rootCause": null,
      "proposedFix": "Prefix all SDK span and span tag names with 'temporal' or 'io.temporal' by default across all SDKs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Prefix with `temporal` or `io.temporal` in all SDKs. The concern is whether we have to retain backwards compatibility as unprefixed by default.",
      "number": 93,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:09.553Z"
    },
    {
      "summary": "Feature request to provide details about the previous Activity Task failure in retries, including the failure reason (error, timeout types) and the actual failure object when applicable.",
      "category": "feature",
      "subcategory": "activity-retry",
      "apis": [
        "ActivityContext"
      ],
      "components": [
        "activity-executor",
        "retry-handler",
        "workflow-context"
      ],
      "concepts": [
        "retry",
        "failure-reason",
        "timeout",
        "heartbeat",
        "activity-task",
        "error-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently log or access details about why an Activity failed during retries, making it difficult to diagnose retry behavior and log meaningful error information.",
      "rootCause": "ActivityContext lacks fields to expose previous failure reasons and failure objects, which requires changes to both the API and SDK implementations.",
      "proposedFix": "Add `lastFailureReason` (enum: RETURNED_FAILURE, START_TO_CLOSE_TIMEOUT, HEARTBEAT_TIMEOUT) and `lastFailure` (Failure object) fields to ActivityContext.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        3517
      ],
      "keyQuote": "User wants to be able to log why an Activity fails (error vs startToCloseTimeout vs heartbeatTimeout).",
      "number": 92,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:13.290Z"
    },
    {
      "summary": "SDKs need to send a `supported-features` header to the server to enable server-side behavior changes and optimizations based on SDK capabilities. Initial value should be `follows-next-run-id` which all SDKs now support.",
      "category": "feature",
      "subcategory": "sdk-server-communication",
      "apis": [],
      "components": [
        "sdk-client",
        "server-communication",
        "headers"
      ],
      "concepts": [
        "feature-negotiation",
        "backwards-compatibility",
        "sdk-versioning",
        "server-optimization",
        "protocol-headers"
      ],
      "severity": "medium",
      "userImpact": "Enables server to apply SDK-specific optimizations and reduce unnecessary data transmission based on declared SDK capabilities.",
      "rootCause": null,
      "proposedFix": "Add `supported-features` header to all SDK client implementations with initial value of `follows-next-run-id`.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1949
      ],
      "keyQuote": "SDKs should send the `supported-features` header with an initial value of `follows-next-run-id`, since they all support that now.",
      "number": 91,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:47:11.322Z"
    },
    {
      "summary": "Create mTLS sample code with documentation for connecting to Temporal Cloud across all SDK sample repositories. This feature request tracks adding reference implementations for TypeScript, Python, Go, Java, and PHP SDKs to help Cloud customers set up secure connections.",
      "category": "feature",
      "subcategory": "samples-documentation",
      "apis": [],
      "components": [
        "samples-typescript",
        "samples-python",
        "samples-go",
        "samples-java",
        "samples-php"
      ],
      "concepts": [
        "mTLS",
        "security",
        "cloud-connection",
        "authentication",
        "certificates",
        "configuration",
        "reference-implementation"
      ],
      "severity": "medium",
      "userImpact": "Cloud customers have a clear, language-specific reference for implementing mTLS connections to Temporal Cloud.",
      "rootCause": null,
      "proposedFix": "Create mTLS sample in each SDK sample repository with documentation ported to app dev guide, with discussion on whether samples should be individually configurable or single mTLS-focused.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "mTLS samples created across all SDK repositories, with TypeScript sample available at samples-typescript/hello-world-mtls and corresponding samples created for other languages via linked issues.",
      "related": [],
      "keyQuote": "Cloud customers frequently request a sample that they can use as reference for setting up their connection.",
      "number": 89,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:57.668Z"
    },
    {
      "summary": "Prototype Pollution vulnerability (CVE-2022-25878) in protobufjs 6.11.2 transitive dependency with CVSS score 7.5. The vulnerability allows attackers to add/modify Object.prototype properties through untrusted input or .proto file parsing.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "protobufjs",
        "client",
        "dependency-management"
      ],
      "concepts": [
        "prototype-pollution",
        "security-vulnerability",
        "transitive-dependency",
        "object-pollution",
        "code-injection"
      ],
      "severity": "high",
      "userImpact": "Users are exposed to a prototype pollution attack that could allow attackers to compromise application integrity through manipulated protobuf data or .proto files.",
      "rootCause": "protobufjs version 6.11.2 before 6.11.3 contains a prototype pollution vulnerability in util.setProperty and ReflectionObject.setParsedOption functions.",
      "proposedFix": "Upgrade protobufjs to version 6.11.3 or later; upgrade temporalio to version 1.0.0 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory in the specific branch.",
      "related": [],
      "keyQuote": "The package protobufjs before 6.11.3 are vulnerable to Prototype Pollution which can allow an attacker to add/modify properties of the Object.prototype.",
      "number": 88,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:56.156Z"
    },
    {
      "summary": "Feature request to add an HTTP header indicating the Temporal namespace for each request to enable L7 routing, load balancing, and rate limiting decisions, particularly important for multi-tenant environments managing QoS across multiple namespaces.",
      "category": "feature",
      "subcategory": "http-headers",
      "apis": [],
      "components": [
        "http-client",
        "sdk-core",
        "load-balancer",
        "namespace-routing"
      ],
      "concepts": [
        "multi-tenancy",
        "namespace-isolation",
        "L7-load-balancing",
        "rate-limiting",
        "request-routing",
        "QoS-management",
        "HTTP-headers"
      ],
      "severity": "medium",
      "userImpact": "Multi-tenant deployments can implement L7 routing and QoS policies based on namespace without complex DNS and SNI workarounds.",
      "rootCause": null,
      "proposedFix": "Add HTTP header to all SDK requests indicating the associated Temporal namespace, excluding namespace-less operations.",
      "workaround": "Create DNS names per namespace pointing to the same Temporal server and inject SNI info into HTTP headers at the edge.",
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #475 in the same repository.",
      "related": [
        475
      ],
      "keyQuote": "all requests from all SDKs would include an http header that indicates the temporal namespace the request is associated with",
      "number": 86,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:59.171Z"
    },
    {
      "summary": "Go SDK needs to implement opt-in support for build-id based versioning by polling on a specific task queue using the worker ID option. This enables tasks to be routed to appropriate versioned workers while maintaining compatibility.",
      "category": "feature",
      "subcategory": "build-id-versioning",
      "apis": [],
      "components": [
        "worker",
        "task-queue",
        "versioning"
      ],
      "concepts": [
        "build-id-versioning",
        "task-routing",
        "worker-id",
        "opt-in",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Go SDK users cannot use build-id based versioning for safe, zero-downtime deployments until this feature is implemented.",
      "rootCause": null,
      "proposedFix": "Implement opt-in flag that enables polling on task queue with worker ID option as added in api PR #217",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in Go SDK with build-id based versioning support",
      "related": [
        217
      ],
      "keyQuote": "SDKs must opt-in to build-id based versioning. When SDKs enable this, they poll on TQ `foo`, using the worker id option",
      "number": 84,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:44.175Z"
    },
    {
      "summary": "Feature request to implement timer features in the Temporal features specification and SDKs. Timers are a core Temporal abstraction for scheduling delayed workflow operations.",
      "category": "feature",
      "subcategory": "timer",
      "apis": [
        "Timer"
      ],
      "components": [
        "workflow-engine",
        "timer-service",
        "workflow-execution"
      ],
      "concepts": [
        "timer",
        "delay",
        "scheduling",
        "workflow-control",
        "temporal-primitives"
      ],
      "severity": "high",
      "userImpact": "Users need timer capabilities to implement delayed operations and time-based workflow logic.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": null,
      "number": 83,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:43.690Z"
    },
    {
      "summary": "Feature request to implement query features for the Temporal SDK testing framework.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "query-execution",
        "workflow-state"
      ],
      "concepts": [
        "query",
        "testing",
        "workflow-state",
        "feature-implementation"
      ],
      "severity": "medium",
      "userImpact": "Users need query functionality in the test framework to validate workflow state and behavior during testing.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Query features were implemented for the Temporal SDK testing framework.",
      "related": [],
      "keyQuote": null,
      "number": 82,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:45.388Z"
    },
    {
      "summary": "Feature request to implement data_converter functionality for the Temporal SDK features test framework. This involves adding support for custom data serialization and deserialization capabilities across SDK implementations.",
      "category": "feature",
      "subcategory": "data-converter",
      "apis": [],
      "components": [
        "data-converter",
        "serialization",
        "test-framework"
      ],
      "concepts": [
        "serialization",
        "deserialization",
        "data-conversion",
        "custom-converters",
        "payload-encoding",
        "type-safety"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to implement and test custom data converters for serializing workflow and activity parameters across different languages and formats.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Data converter features were implemented and integrated into the SDK test suite.",
      "related": [],
      "keyQuote": null,
      "number": 81,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:32.086Z"
    },
    {
      "summary": "Feature request to implement continue_as_new test features in the Temporal test framework for validating workflow continuation behavior.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "test-framework",
        "workflow-execution",
        "feature-tests"
      ],
      "concepts": [
        "continue-as-new",
        "workflow-continuation",
        "state-reset",
        "testing",
        "feature-validation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot adequately test continue_as_new workflow patterns across different SDK implementations without dedicated feature tests.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": null,
      "number": 80,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:28.663Z"
    },
    {
      "summary": "Feature request to implement child_workflow test features for the Temporal feature test suite.",
      "category": "feature",
      "subcategory": "child-workflow",
      "apis": [
        "StartChildWorkflow"
      ],
      "components": [
        "feature-test",
        "child-workflow",
        "workflow-execution"
      ],
      "concepts": [
        "child workflows",
        "workflow composition",
        "testing framework",
        "feature coverage"
      ],
      "severity": "medium",
      "userImpact": "Enables testing of child workflow functionality across Temporal SDKs to ensure consistent behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": null,
      "number": 79,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:30.456Z"
    },
    {
      "summary": "Feature request to implement signal-related test features for the Temporal SDK features test suite. Referenced PR #101 indicates work on the first sub-feature related to signals.",
      "category": "feature",
      "subcategory": "signals-testing",
      "apis": [
        "Signal"
      ],
      "components": [
        "signals",
        "test-framework",
        "feature-tests"
      ],
      "concepts": [
        "signals",
        "workflow-communication",
        "testing",
        "feature-coverage",
        "async-signaling"
      ],
      "severity": "medium",
      "userImpact": "Users need comprehensive test coverage and examples for signal features to understand and properly implement signal handling in their workflows.",
      "rootCause": null,
      "proposedFix": "Implement signal-related test features as tracked in PR #101",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        101
      ],
      "keyQuote": "https://github.com/temporalio/sdk-features/pull/101 for first sub-feature",
      "number": 78,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:15.661Z"
    },
    {
      "summary": "Feature request to implement activity-related test features for the Temporal SDK test framework. This is foundational testing infrastructure that has already revealed two bugs in the Go SDK.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "activity-executor",
        "sdk-testing"
      ],
      "concepts": [
        "activity-testing",
        "test-coverage",
        "feature-parity",
        "regression-detection",
        "sdk-validation"
      ],
      "severity": "high",
      "userImpact": "Users need comprehensive activity testing features to validate their workflows and ensure reliability across SDK implementations.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        860,
        859
      ],
      "keyQuote": "This has already found two bugs",
      "number": 77,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:18.407Z"
    },
    {
      "summary": "Feature request to add a user-friendly `getHistory()` method on workflow handles instead of requiring direct calls to `workflowService.getWorkflowExecutionHistory()` with verbose configuration. Should throw `WorkflowNotFoundError` instead of generic errors.",
      "category": "feature",
      "subcategory": "workflow-history",
      "apis": [
        "getWorkflowExecutionHistory"
      ],
      "components": [
        "workflow-handle",
        "history-retrieval",
        "error-handling"
      ],
      "concepts": [
        "api-ergonomics",
        "workflow-execution",
        "error-messages",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers must use verbose low-level API calls and handle unclear errors when retrieving workflow history, reducing ease of use.",
      "rootCause": null,
      "proposedFix": "Add a `getHistory()` method to workflow handles that wraps the lower-level API call with simpler syntax and better error handling.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Instead of ... and throwing errors like [...] const history = await workflowHandle.getHistory() and throwing `WorkflowNotFoundError`",
      "number": 76,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:17.800Z"
    },
    {
      "summary": "Feature request to improve the listWorkflowExecutions API by making pagination easier, converting returned executions to friendly types, and providing a list filter query builder. The discussion focuses on designing a filter builder that balances ease of use with support for both basic and advanced visibility filters.",
      "category": "feature",
      "subcategory": "list-workflow-executions",
      "apis": [
        "listWorkflowExecutions",
        "WorkflowExecutionDescription"
      ],
      "components": [
        "visibility",
        "list-api",
        "filter-builder",
        "pagination"
      ],
      "concepts": [
        "pagination",
        "filtering",
        "query-builder",
        "visibility",
        "user-experience",
        "type-conversion"
      ],
      "severity": "medium",
      "userImpact": "Users need a more ergonomic way to list and filter workflow executions with easier pagination handling and type conversions across all SDKs.",
      "rootCause": null,
      "proposedFix": "Design a TypeScript proposal for a filter builder API that handles both basic filters (without advanced visibility) and advanced filters, without building a full AST-based DSL. Reuse WorkflowExecutionDescription for returned types.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        17,
        754
      ],
      "keyQuote": "One of the important things we must capture is that some filters can work without \"advanced visibility\" and some can work with.",
      "number": 75,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:01.225Z"
    },
    {
      "summary": "Separate data converter and encoder concepts in SDKs, ensuring stacktraces and failure information use standard Temporal data conversion without custom encryption by default, while allowing opt-in encryption and treating additional failure payloads as regular user objects.",
      "category": "feature",
      "subcategory": "data-conversion",
      "apis": [],
      "components": [
        "data-converter",
        "payload-codec",
        "failure-handling",
        "encryption"
      ],
      "concepts": [
        "data-conversion",
        "encryption",
        "stacktrace",
        "payload-handling",
        "failure-information",
        "data-encoder"
      ],
      "severity": "medium",
      "userImpact": "Users need clear separation between data conversion and encryption, with stacktraces remaining accessible by default while still allowing opt-in encryption for sensitive information.",
      "rootCause": "Conflation of data converter and encoder concepts, leading to unnecessary encryption of diagnostic information that should be easily accessible in Temporal UI.",
      "proposedFix": "Implement PayloadCodec framework as an abstraction separate from data converters, apply standard conversion to stacktraces/failures by default, and provide opt-in flag for encryption.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of #66, with much of the functionality already implemented in Java SDK via PayloadCodec framework and failure conversion/encryption.",
      "related": [
        66,
        1330,
        1645,
        1586
      ],
      "keyQuote": "Stacktrace query results and stacktraces of Temporal Failures should always be converter using a standard Temporal Data Converter.",
      "number": 74,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:03.294Z"
    },
    {
      "summary": "Request to provide a high-level, SDK-friendly API for the Schedules feature across all Temporal SDKs. Currently only exposed via raw gRPC or tctl, this feature needs language-idiomatic interfaces implemented for TypeScript, Go, Java, Python, .NET, PHP, and Ruby.",
      "category": "feature",
      "subcategory": "schedules-api",
      "apis": [
        "Schedules"
      ],
      "components": [
        "sdk-typescript",
        "sdk-go",
        "sdk-java",
        "sdk-python",
        "sdk-dotnet",
        "sdk-php",
        "sdk-ruby"
      ],
      "concepts": [
        "high-level-api",
        "language-idioms",
        "scheduling",
        "workflow-management",
        "sdk-consistency"
      ],
      "severity": "high",
      "userImpact": "Users must use low-level gRPC or tctl commands instead of convenient SDK methods to manage scheduled workflows.",
      "rootCause": null,
      "proposedFix": "Implement high-level Schedules API across all SDKs following language-specific idioms, with TypeScript proposal as reference (temporalio/proposals/pull/62).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "High-level Schedules APIs have been implemented across all major SDKs (TS, Go, Java, Python, .NET, PHP, Ruby) following the TypeScript reference proposal and adapted to each language's idioms.",
      "related": [
        871,
        1333,
        794,
        87,
        23,
        228
      ],
      "keyQuote": "SDKs should provide a friendly (high level) interface for this.",
      "number": 73,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:46:04.712Z"
    },
    {
      "summary": "Feature request to unify retry logic implementations across all Temporal SDKs (Core, TypeScript, Java, Go, PHP). Currently each SDK has independent retry implementations that should be standardized.",
      "category": "feature",
      "subcategory": "retry-logic",
      "apis": [],
      "components": [
        "grpc-retry",
        "client",
        "service-client",
        "retry-interceptor"
      ],
      "concepts": [
        "retry-policy",
        "error-handling",
        "consistency",
        "client-resilience",
        "unification",
        "cross-sdk"
      ],
      "severity": "medium",
      "userImpact": "Inconsistent retry behavior across SDKs creates confusion for users and makes it harder to migrate between languages.",
      "rootCause": null,
      "proposedFix": "Write a specification for unified retry logic and start a discussion for standardization",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #27",
      "related": [
        27
      ],
      "keyQuote": "Retry logic in all SDKs: ... [lists implementations across Core, TypeScript, Java, Go, PHP]",
      "number": 72,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:45.605Z"
    },
    {
      "summary": "Create test containers from sdk-features test suite for each SDK to enable continuous testing of different SDK versions against Temporal Cloud and OSS deployments. The approach evolved from creating separate containers per SDK version to building a single reusable sdk-features container that can download and test any SDK language/version/commit hash.",
      "category": "feature",
      "subcategory": "test-infrastructure",
      "apis": [],
      "components": [
        "sdk-features",
        "docker",
        "test-runner",
        "sdk-compatibility"
      ],
      "concepts": [
        "containerization",
        "continuous-testing",
        "version-compatibility",
        "e2e-testing",
        "sdk-versions"
      ],
      "severity": "medium",
      "userImpact": "Enables reliable testing of SDK compatibility across versions and deployments, ensuring users can depend on stable SDK behavior across upgrades.",
      "rootCause": null,
      "proposedFix": "Build a single flexible sdk-features container that downloads and runs tests for any SDK language, version, or commit hash, rather than creating separate containers per version.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented by creating a single reusable container that uses a runner to download SDKs and build docker images dynamically for any SDK version.",
      "related": [],
      "keyQuote": "build a separate container per SDK version but make sure to use the runner for downloading the SDK and building the docker image",
      "number": 71,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:47.173Z"
    },
    {
      "summary": "CVE-2022-25858: A Regular Expression Denial of Service (ReDoS) vulnerability in the terser JavaScript parser (version 5.14.1) used as a transitive dependency through webpack. The vulnerability has a CVSS score of 7.5 with high availability impact.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "build-system",
        "dependency-management",
        "webpack"
      ],
      "concepts": [
        "vulnerability",
        "denial-of-service",
        "regular-expression",
        "transitive-dependency",
        "security",
        "remediation"
      ],
      "severity": "high",
      "userImpact": "The build process could be vulnerable to ReDoS attacks through the terser minification tool, potentially causing denial of service during builds.",
      "rootCause": "Insecure usage of regular expressions in terser library versions before 4.8.1 and before 5.14.2",
      "proposedFix": "Upgrade terser to version 4.8.1 or 5.14.2 or later",
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the inventory",
      "related": [],
      "keyQuote": "The package terser before 4.8.1, from 5.0.0 and before 5.14.2 are vulnerable to Regular Expression Denial of Service (ReDoS)",
      "number": 70,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:49.168Z"
    },
    {
      "summary": "Feature request to allow developers to specify reset points directly in workflow code to enable easier workflow rollback. Currently, calculating reset points from history is impractical, especially for batch operations affecting millions of workflows.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "workflow-engine",
        "reset-logic",
        "replayer"
      ],
      "concepts": [
        "workflow-reset",
        "code-rollback",
        "replay",
        "batch-operations",
        "workflow-debugging"
      ],
      "severity": "medium",
      "userImpact": "Users can more easily roll back workflow progress by declaring reset points in code rather than calculating them manually from history.",
      "rootCause": null,
      "proposedFix": "Add a reset() API that marks a point in workflow code where execution should roll back to. Workflows blocked within the reset scope automatically replay from that point when code is redeployed.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Ability to reset workflow to any point by specifying the reset point in the code. Given that in many cases reset point can be reached through different code paths it is practically impossible to find the reset point just looking at a history.",
      "number": 69,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:32.564Z"
    },
    {
      "summary": "Feature request to create compatible encryption libraries across Temporal SDKs. Go and TypeScript encryption samples were incompatible, and the request proposed using NaCl-based encryption instead of AES for better cross-language compatibility.",
      "category": "feature",
      "subcategory": "encryption-compatibility",
      "apis": [],
      "components": [
        "encryption",
        "samples",
        "typescript-sdk",
        "go-sdk"
      ],
      "concepts": [
        "encryption",
        "cross-sdk-compatibility",
        "cryptography",
        "interoperability",
        "authentication"
      ],
      "severity": "medium",
      "userImpact": "Users need compatible encryption implementations across SDKs to securely pass data between workflows in different languages.",
      "rootCause": "Different encryption implementations in TS and Go samples used different algorithms and approaches, making them incompatible with each other.",
      "proposedFix": "Adjust both Go and TS encryption samples to use NaCl-based encryption (specifically secretbox for authenticated encryption) instead of AES-based encryption for cross-language compatibility.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The incompatibility was fixed by adjusting the TS crypto usage in a PR to make it compatible with the Go implementation, without needing to port all samples to nacl.",
      "related": [],
      "keyQuote": "I'd recommend nacl-based encryption instead of AES-based encryption for cross-language compatibility for many reasons.",
      "number": 68,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:33.636Z"
    },
    {
      "summary": "Standardize activity heartbeat throttling behavior across all SDKs by introducing configurable WorkerOptions for maximum and default throttle intervals, with the throttle interval calculated as the minimum of heartbeat timeout (0.8x), default interval, and maximum interval.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "WorkerOption"
      ],
      "components": [
        "worker",
        "activity-executor",
        "heartbeat-throttling"
      ],
      "concepts": [
        "heartbeat",
        "throttling",
        "timeout",
        "configuration",
        "backwards-compatibility",
        "sdk-alignment"
      ],
      "severity": "medium",
      "userImpact": "Users will have explicit control over heartbeat throttling behavior with consistent defaults across all SDKs, reducing confusion from current implicit and inconsistent behavior.",
      "rootCause": "Different SDKs have different implicit defaults and maximums for heartbeat throttling (Java: 30s max/0s default, Go: 10m default/no max), causing inconsistent behavior.",
      "proposedFix": "Add maxHeartbeatThrottleInterval (default 60s) and defaultHeartbeatThrottleInterval (default 30s) WorkerOptions with formula: throttleInterval = min(heartbeat_timeout * 0.8 if provided else defaultHeartbeatThrottleInterval, maxHeartbeatThrottleInterval)",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        656,
        906
      ],
      "keyQuote": "This was already implemented in all SDKs. Leaving it open to add a feature in this repo.",
      "number": 67,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:31.077Z"
    },
    {
      "summary": "Allow failure fields (message, stack_trace, type) to be encrypted through codec. Currently only the details field supports Payloads conversion; other sensitive failure fields are not processed through codecs.",
      "category": "feature",
      "subcategory": "encryption-codec",
      "apis": [],
      "components": [
        "failure-handling",
        "codec",
        "data-converter"
      ],
      "concepts": [
        "encryption",
        "sensitive-data",
        "codec",
        "payload-conversion",
        "security"
      ],
      "severity": "medium",
      "userImpact": "Users cannot encrypt sensitive failure information (error messages, stack traces) in their workflows, creating security risks for sensitive data.",
      "rootCause": "Failure message, stack_trace, and type fields are not converted to Payloads and therefore cannot be processed through configured encryption codecs.",
      "proposedFix": "Convert failure fields (message, stack_trace, type) to Payload types to enable codec processing, similar to how details field is currently handled.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        204
      ],
      "keyQuote": "Failure fields may have sensitive info, including message, stack_trace, and details, and maybe type.",
      "number": 66,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:18.126Z"
    },
    {
      "summary": "Feature request to add information about unresolved commands to workflow task completions, allowing users to understand why a workflow is waiting or stuck by recording counts of executing local activities, signals, timers, and other awaitable items.",
      "category": "feature",
      "subcategory": "workflow-task-completion",
      "apis": [
        "RespondWorkflowTaskCompletedRequest",
        "DescribeWorkflowExecutionResponse",
        "CompletedWorkflowTaskInfo",
        "PendingWorkflowTaskInfo"
      ],
      "components": [
        "workflow-task-completion",
        "history-inspection",
        "workflow-debugging",
        "api-design"
      ],
      "concepts": [
        "workflow-progress-tracking",
        "command-resolution",
        "activity-awaiting",
        "signal-awaiting",
        "timer-awaiting",
        "workflow-stuck-detection",
        "debugging-visibility"
      ],
      "severity": "high",
      "userImpact": "Users will be able to diagnose why workflows are stuck or waiting by examining what unresolved commands and awaitable items are blocking progress.",
      "rootCause": null,
      "proposedFix": "Add a new field to workflow task completions (generic map or dedicated proto CompletedWorkflowTaskInfo) to record counts of executing local activities and awaited items (signals, activities, timers, children), exposed via DescribeWorkflowExecutionResponse.last_completed_workflow_task.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This will allow us to understand why a workflow completed a task with no commands. If it's not waiting on anything, then by definition the workflow is now stuck.",
      "number": 65,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:15.861Z"
    },
    {
      "summary": "Dependency security vulnerability in go-yaml (transitive dependency of testify v1.7.0) with CVE-2022-28948 causing denial of service through YAML deserialization. Issue was autoclosed after vulnerability was addressed.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "testify",
        "go-yaml",
        "dependencies",
        "unmarshal",
        "yaml-parser"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "deserialization",
        "dependency-management",
        "transitive-dependency",
        "cvss-score"
      ],
      "severity": "high",
      "userImpact": "Applications using testify v1.7.0 are vulnerable to denial of service attacks through malformed YAML input.",
      "rootCause": "Unmarshal function in go-yaml v3 crashes when attempting to deserialize invalid YAML input",
      "proposedFix": "Upgrade go-yaml to version 3.0.0 or later",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory in the specific branch",
      "related": [],
      "keyQuote": "An issue in the Unmarshal function in Go-Yaml v3 causes the program to crash when attempting to deserialize invalid input.",
      "number": 60,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:16.792Z"
    },
    {
      "summary": "Feature request to wrap gRPC errors in SDK-specific exception classes (e.g., WorkflowNotFound, ActivityNotFound) instead of rethrowing raw gRPC errors, similar to what other SDKs do. The discussion identified concerns about breaking changes and unclear benefits, leading to the decision to close without implementation.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "error-handling",
        "grpc-client"
      ],
      "concepts": [
        "error-wrapping",
        "exception-hierarchy",
        "breaking-changes",
        "api-compatibility",
        "error-messages"
      ],
      "severity": "low",
      "userImpact": "Users would benefit from SDK-specific exception types for better error handling and consistency across Temporal SDKs.",
      "rootCause": null,
      "proposedFix": "Wrap gRPC errors in SDK-specific exception classes like WorkflowNotFound, ActivityNotFound, or a generic NotFound exception.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed as the team determined that the current error-handling regime has been reasonable and implementing this would be a breaking change without clear benefits.",
      "related": [],
      "keyQuote": "Yeah, I would close this. If we want to revisit and discuss we can",
      "number": 59,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:02.898Z"
    },
    {
      "summary": "Prototype Pollution vulnerability (CVE-2022-25878) discovered in protobufjs 6.11.2, a transitive dependency of temporalio SDK. The vulnerability allows attackers to modify Object.prototype properties through untrusted input or .proto file parsing.",
      "category": "bug",
      "subcategory": "security",
      "apis": [],
      "components": [
        "protobufjs",
        "client",
        "dependency-management"
      ],
      "concepts": [
        "prototype-pollution",
        "security-vulnerability",
        "cvss-7.5",
        "dependency-update",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Users of temporalio SDK version 0.21.1 are exposed to prototype pollution attacks through the vulnerable protobufjs transitive dependency.",
      "rootCause": "protobufjs versions before 6.11.3 contain a prototype pollution vulnerability allowing modification of Object.prototype via untrusted input or .proto file parsing",
      "proposedFix": "Upgrade protobufjs to version 6.11.3 or update temporalio SDK to version 0.22.0 which includes the fix",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed after the vulnerable library was removed from the dependency tree or marked as ignored in the Mend inventory",
      "related": [],
      "keyQuote": "protobufjs before 6.11.3 are vulnerable to Prototype Pollution which can allow an attacker to add/modify properties of the Object.prototype",
      "number": 56,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:59.923Z"
    },
    {
      "summary": "Feature request to implement eager activity dispatch in SDKs by setting ScheduleActivityTaskCommandAttributes.request_eager_execution when workers have available activity slots. This allows the server to dispatch work directly back to the requesting worker for performance optimization.",
      "category": "feature",
      "subcategory": "activity-dispatch",
      "apis": [
        "ScheduleActivityTaskCommandAttributes"
      ],
      "components": [
        "worker",
        "activity-executor",
        "activity-dispatch",
        "server-communication"
      ],
      "concepts": [
        "eager-execution",
        "load-balancing",
        "activity-slots",
        "worker-optimization",
        "performance",
        "dispatch-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users benefit from faster activity dispatch and reduced overhead through optimized server work distribution to available worker resources.",
      "rootCause": null,
      "proposedFix": "Set eager execution boolean when scheduling activities if worker has available slots, add worker option for max eager activities (configurable or disableable), track activity completion from WFT responses to manage slot availability.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented across all SDKs (Core, TypeScript, Go, Python, Java, PHP) with configuration for max eager activities per worker.",
      "related": [
        1339
      ],
      "keyQuote": "Set eager execution boolean when scheduling activity if the worker is known to have activity slots available",
      "number": 55,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:45:02.187Z"
    },
    {
      "summary": "WorkflowInfo.lastCompletionResult API design is inconsistent across SDKs. Some SDKs return a list of Payloads while others return a single result, and the behavior differs between Crons and ContinueAsNew workflows. Documentation and implementation need to be standardized.",
      "category": "feature",
      "subcategory": "workflow-api-design",
      "apis": [
        "GetLastCompletionResult",
        "WorkflowInfo"
      ],
      "components": [
        "workflow-context",
        "sdk-api-surface",
        "continuation"
      ],
      "concepts": [
        "api-consistency",
        "workflow-results",
        "cron-workflows",
        "continue-as-new",
        "payload-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers experience inconsistent behavior across SDKs when accessing the last completion result of a workflow, making cross-SDK code migration difficult.",
      "rootCause": "SDKs implemented lastCompletionResult with different semanticsâ€”some expose the underlying list while others unwrap single values, creating API inconsistency.",
      "proposedFix": "Standardize across all SDKs to return either the list or the single unwrapped value consistently, with matching behavior for Crons and ContinueAsNew.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If I'm right, IMO all should do so. TS does not and it would be breaking.",
      "number": 54,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:47.958Z"
    },
    {
      "summary": "Request for new metrics to distinguish between widespread task failures and individual stuck workflows/activities. Proposes counters tracking consecutive failures at different thresholds (10, 100, 1000 times) to better identify failure patterns.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-executor",
        "activity-executor"
      ],
      "concepts": [
        "failure-tracking",
        "consecutive-failures",
        "observability",
        "metrics-histogram",
        "failure-patterns"
      ],
      "severity": "medium",
      "userImpact": "Users cannot distinguish between isolated failures across many workflows and repeated failures of stuck workflows, limiting debugging and monitoring capabilities.",
      "rootCause": null,
      "proposedFix": "Add counters for activity_failed_10_times, activity_failed_100_times, activity_failed_1000_times and corresponding workflow_task_failed_* metrics, or implement histogram with buckets following OpenMetrics specification.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "it's impossible to distinguish between two situations. A lot of workflows are failing once or twice or there is 1 or 2 workflows that are completely stuck.",
      "number": 53,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:47.055Z"
    },
    {
      "summary": "Feature request to standardize built-in methods for listing workflow queries, signals, and other metadata across SDKs. Currently uses a workaround of sending queries that respond with \"not found\" to list available queries; the proposal is to provide standard built-in queries like \"listQueries\" through the Workflow runtime.",
      "category": "feature",
      "subcategory": "workflow-queries-signals-metadata",
      "apis": [
        "GetUnhandledSignalNames",
        "SetUpdateHandlerWithOptions",
        "SetQueryHandlerWithOptions",
        "DefineSignalChannel"
      ],
      "components": [
        "workflow-runtime",
        "query-handler",
        "signal-handler",
        "metadata-provider",
        "sdk-api"
      ],
      "concepts": [
        "workflow-introspection",
        "dynamic-handlers",
        "metadata-discovery",
        "query-execution",
        "signal-registration",
        "api-standardization"
      ],
      "severity": "medium",
      "userImpact": "Users need standardized ways to discover and list available queries and signals for workflow executions, improving developer experience and UI capabilities across all SDKs.",
      "rootCause": null,
      "proposedFix": "Implement built-in queries like \"listQueries\" provided by the Workflow runtime, with support for describing dynamic query/signal/update handlers through language-specific mechanisms (annotations, decorators, attributes, options).",
      "workaround": "Send queries to workflow that respond with 'query not found' messages containing the list of registered queries, then parse the response to display in UI.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        201,
        336,
        601,
        335,
        1319,
        467,
        185
      ],
      "keyQuote": "A standard way to support listing workflow queries would be to have a \"listQueries\" built-in query provided by the Workflow runtime.",
      "number": 51,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:46.407Z"
    },
    {
      "summary": "Request to implement SAGA pattern helpers as a first-class SDK feature across all language SDKs. While SAGAs are implementable from scratch, adding native support would signal platform capability and provide standardized, safer abstractions for distributed transactions.",
      "category": "feature",
      "subcategory": "workflow-patterns",
      "apis": [],
      "components": [
        "workflow-engine",
        "activity-executor",
        "child-workflows"
      ],
      "concepts": [
        "saga-pattern",
        "distributed-transactions",
        "compensating-actions",
        "workflow-orchestration",
        "error-handling",
        "async-coordination"
      ],
      "severity": "medium",
      "userImpact": "Users implementing distributed transactions would benefit from a standardized SAGA abstraction rather than implementing custom solutions for each use case.",
      "rootCause": "Lack of native SAGA support despite it being a core use case; existing implementations are minimal and incomplete without proper design and abstraction.",
      "proposedFix": "Design and implement a more full-featured SAGA abstraction that covers synchronous and asynchronous scenarios with proper server-side optimizations and best practices guidance.",
      "workaround": "Users can implement SAGAs from scratch using child workflows, signals, and compensating actions as shown in existing samples.",
      "resolution": "wontfix",
      "resolutionDetails": "Team decided against implementing SAGAs as top-level SDK APIs after discussion. Good documentation and blog posts on compensating actions and SAGA patterns were created instead.",
      "related": [
        456
      ],
      "keyQuote": "We pretty much decided we don't want this in the sdks",
      "number": 50,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:32.505Z"
    },
    {
      "summary": "SDKs need to differentiate between NamespaceInvalidState and NamespaceNotFound errors, with workers treating NamespaceNotFound as fatal but not NamespaceInvalidState. Go SDK is already implemented; Java, Core, TypeScript, PHP, and .NET still need this feature.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "worker",
        "error-handling",
        "namespace-management"
      ],
      "concepts": [
        "error-differentiation",
        "namespace-errors",
        "fatal-errors",
        "error-classification",
        "api-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly distinguish between different namespace error states across SDKs, leading to inconsistent error handling and recovery strategies.",
      "rootCause": "SDKs need additional error type differentiation to match server-side error semantics for namespace-related failures.",
      "proposedFix": "Implement separate error types or error codes for NamespaceInvalidState vs NamespaceNotFound, with worker logic treating NamespaceNotFound as fatal.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "the worker should consider `NamespaceNotFound` error a fatal error, but not `NamespaceInvalidState`",
      "number": 47,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:30.586Z"
    },
    {
      "summary": "SDKs should standardize gRPC max receive message size to 128MB across all language implementations. This ensures consistent behavior for handling large server responses like workflow history pages, though the actual limit may be constrained by server-side restrictions.",
      "category": "feature",
      "subcategory": "grpc-configuration",
      "apis": [],
      "components": [
        "grpc-client",
        "worker",
        "configuration"
      ],
      "concepts": [
        "message-size",
        "grpc-limits",
        "server-response",
        "fairness",
        "configuration-default"
      ],
      "severity": "low",
      "userImpact": "Users get consistent, predictable gRPC message size behavior across different SDK language implementations.",
      "rootCause": "Inconsistent default gRPC max receive message size across SDK implementations; Java and Go already set it to 128MB, but other SDKs don't.",
      "proposedFix": "Set gRPC max receive message size default to 128MB in all SDKs (Java, Go, TS, Core) and add corresponding tests in sdk-features repo.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        794
      ],
      "keyQuote": "It will get rejected by server-side limits anyways usually, but that is exposed as a config and this is not so it's set high enough not to be hit hopefully",
      "number": 46,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:33.037Z"
    },
    {
      "summary": "Users need the ability to create a Temporal Client for temporarily unavailable servers without eager health checks and system info calls. The feature requires lazy capability negotiation on first use and explicit health check methods.",
      "category": "feature",
      "subcategory": "client-connectivity",
      "apis": [
        "Client",
        "healthCheck",
        "getSystemInfo",
        "getSystemCapabilities",
        "connect",
        "dial"
      ],
      "components": [
        "client",
        "connection-management",
        "initialization",
        "health-check"
      ],
      "concepts": [
        "lazy-loading",
        "connection-pooling",
        "health-check",
        "system-capabilities",
        "initialization",
        "availability"
      ],
      "severity": "medium",
      "userImpact": "Users can now create clients for temporarily unavailable servers and explicitly control when health checks and capability negotiation occur instead of blocking on client creation.",
      "rootCause": null,
      "proposedFix": "Implement lazy initialization with optional explicit connect/dial methods and expose healthCheck endpoints across SDKs (Java, Go, TypeScript, PHP, Python).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        828,
        793,
        312,
        224,
        92,
        367
      ],
      "keyQuote": "Users should be able to create a Temporal Client for a temporarily unavailable Temporal server.",
      "number": 45,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:17.026Z"
    },
    {
      "summary": "Automated security vulnerability report for Apache Thrift v0.10.0 transitive dependency in temporalio/temporal v1.16.0, identifying 3 CVEs with highest severity 7.5 (CVSS). Issue was auto-closed when the vulnerable dependency was removed from the project inventory.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "thrift-integration",
        "ringpop-go"
      ],
      "concepts": [
        "security-vulnerability",
        "CVE",
        "dependency-upgrade",
        "availability-impact",
        "denial-of-service"
      ],
      "severity": "high",
      "userImpact": "Users of temporalio/temporal v1.16.0 could experience availability issues due to infinite loops or panics caused by malformed input to Thrift RPC protocol handlers.",
      "rootCause": "Apache Thrift versions 0.9.3 to 0.12.0 have unsafe handling of malformed input in TJSONProtocol and TSimpleJSONProtocol, and insufficient bounds checking in core deserialization logic.",
      "proposedFix": "Upgrade Apache Thrift dependency from v0.10.0 to v0.13.0 or later to resolve CVE-2019-0205, CVE-2019-0210, and CVE-2018-11798.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Automatically closed by Mend when the vulnerable library was either marked as ignored or removed from the project dependency inventory.",
      "related": [],
      "keyQuote": "In Apache Thrift 0.9.3 to 0.12.0, a server implemented in Go using TJSONProtocol or TSimpleJSONProtocol may panic when feed with invalid input data.",
      "number": 44,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:15.062Z"
    },
    {
      "summary": "Feature request to add higher-level Activity abstractions for common patterns like resource polling and periodic invocation.",
      "category": "feature",
      "subcategory": "activity-abstractions",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "activity-framework"
      ],
      "concepts": [
        "abstraction",
        "polling",
        "periodic-invocation",
        "resource-readiness",
        "activity-patterns"
      ],
      "severity": "medium",
      "userImpact": "Users would have convenient abstractions for common Activity patterns instead of implementing them manually.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add higher-level Activity abstractions... Trigger. Polls for a resource until it is ready. Periodic invocation",
      "number": 42,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:44:14.522Z"
    },
    {
      "summary": "Three vulnerabilities detected in Apache Thrift 0.10.0 transitive dependency (CVE-2019-0205, CVE-2019-0210, CVE-2018-11798) with CVSS scores up to 7.5. Issue was auto-closed by dependency scanner after vulnerability was addressed.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "ringpop-go",
        "thrift-dependency",
        "dependency-management"
      ],
      "concepts": [
        "vulnerability",
        "security",
        "dependency-upgrade",
        "transitive-dependency",
        "cvss-score",
        "denial-of-service"
      ],
      "severity": "high",
      "userImpact": "Users could experience denial-of-service attacks through vulnerable transitive dependencies in Thrift library.",
      "rootCause": "Apache Thrift 0.10.0 contains three security vulnerabilities: endless loop in protocol handling (CVE-2019-0205), panic in JSON protocol with invalid input (CVE-2019-0210), and path traversal in Node.js web server (CVE-2018-11798).",
      "proposedFix": "Upgrade Apache Thrift from 0.10.0 to 0.13.0 or higher to address all three vulnerabilities.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Auto-closed by WhiteSource after vulnerable library was marked as ignored or removed from inventory.",
      "related": [],
      "keyQuote": "found in base branch: main. Publish Date: 2019-10-29. CVSS 3 Score Details (7.5) - Availability Impact: High",
      "number": 38,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:59.593Z"
    },
    {
      "summary": "Two high-severity vulnerabilities (CVE-2019-0205 and CVE-2019-0210) in Apache Thrift, detected as transitive dependencies through github.com/uber-go/tally/v4, affecting the sdk-features repository. Both vulnerabilities can cause denial of service.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "build-system",
        "sdk-features"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "denial-of-service",
        "dependency",
        "transitive-dependency",
        "thrift",
        "metrics"
      ],
      "severity": "high",
      "userImpact": "Users of sdk-features are potentially exposed to denial-of-service attacks through vulnerable transitive dependencies in the metrics library.",
      "rootCause": "Apache Thrift versions 0.9.3 through 0.12.0 contain vulnerabilities in JSON protocol handling that can be triggered by malformed input.",
      "proposedFix": "Upgrade Apache Thrift to version 0.13.0 or later; upgrade transitive dependencies to remove the vulnerable Thrift version.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or no longer part of the Mend inventory in the tracked branches.",
      "related": [],
      "keyQuote": "A server or client may run into an endless loop when feed with specific input data. Because the issue had already been partially fixed in version 0.11.0",
      "number": 37,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:56.005Z"
    },
    {
      "summary": "A prototype pollution vulnerability (CVE-2021-44906) was discovered in minimist 1.2.5, a transitive dependency of tsconfig-paths. The vulnerability has a CVSS score of 5.0 (medium severity) and allows potential exploitation through argument parsing.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "tsconfig-paths",
        "minimist",
        "dependency-management"
      ],
      "concepts": [
        "prototype-pollution",
        "security-vulnerability",
        "transitive-dependency",
        "argument-parsing",
        "version-upgrade"
      ],
      "severity": "medium",
      "userImpact": "Users of the sdk-features repository may be exposed to prototype pollution attacks through the vulnerable minimist dependency.",
      "rootCause": "Minimist <=1.2.5 is vulnerable to Prototype Pollution via the setKey() function in index.js (lines 69-95).",
      "proposedFix": "Upgrade minimist to version 1.2.6 or upgrade tsconfig-paths to version 4.0.0.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory.",
      "related": [],
      "keyQuote": "Minimist <=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69-95).",
      "number": 36,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:56.306Z"
    },
    {
      "summary": "Logback library vulnerability (CVE-2021-42550) requiring upgrade from 1.2.6 to 1.2.8 to address LDAP-based arbitrary code execution risk in configuration file handling.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "logback-classic",
        "logback-core",
        "gradle-build"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-management",
        "code-execution",
        "configuration-injection",
        "ldap"
      ],
      "severity": "medium",
      "userImpact": "Applications using the features SDK are vulnerable to arbitrary code execution if an attacker can modify logback configuration files.",
      "rootCause": "Logback versions 1.2.7 and prior allow LDAP configuration in the logging configuration, enabling arbitrary code loading and execution.",
      "proposedFix": "Upgrade logback-classic and logback-core from 1.2.6 to 1.2.8 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend as the vulnerable library was removed from the dependency inventory or marked as ignored.",
      "related": [],
      "keyQuote": "attacker with the required privileges to edit configurations files could craft a malicious configuration allowing to execute arbitrary code loaded from LDAP servers",
      "number": 35,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:38.775Z"
    },
    {
      "summary": "Temporal Server v1.13.1 has 4 transitive dependency vulnerabilities including 3 high-severity issues in Apache Thrift (CVE-2019-0205, CVE-2019-0210, CVE-2018-11798) and Prometheus client library (CVE-2022-21698), with CVSS scores up to 7.5.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "temporal-server",
        "dependency-management",
        "thrift-library",
        "prometheus-client"
      ],
      "concepts": [
        "vulnerability",
        "dependency",
        "security",
        "denial-of-service",
        "memory-exhaustion",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Users running Temporal Server with this specific version are exposed to denial-of-service and potential memory exhaustion attacks through vulnerable transitive dependencies.",
      "rootCause": "Outdated versions of Apache Thrift (0.10.0) and Prometheus client_golang (v1.11.0) included as transitive dependencies in Temporal Server v1.13.1.",
      "proposedFix": "Upgrade Apache Thrift to 0.13.0 or later and Prometheus client_golang to v1.11.1 or later.",
      "workaround": "For CVE-2022-21698, filter HTTP methods before promhttp middleware, remove method label from metrics, or use a reverse proxy/WAF to limit allowed methods.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue was automatically closed by WhiteSource because the vulnerable library was either marked as ignored or no longer part of the inventory.",
      "related": [],
      "keyQuote": "This issue was automatically closed by WhiteSource because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the WhiteSource inventory.",
      "number": 34,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:38.811Z"
    },
    {
      "summary": "Three vulnerabilities detected in temporal-sdk-1.5.0.jar transitive dependencies: jackson-databind (CVE-2020-36518, CVE-WS-2021-0616) and protobuf-java (CVE-2021-22569). The highest severity vulnerability (CVE-2020-36518) is a denial of service via deep object nesting with CVSS 7.5.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "build-system",
        "security-scanning"
      ],
      "concepts": [
        "vulnerability",
        "security",
        "denial-of-service",
        "dependency-upgrade",
        "transitive-dependency",
        "CVSS-scoring"
      ],
      "severity": "high",
      "userImpact": "Users of temporal-sdk-1.5.0 are exposed to potential DoS attacks through vulnerable jackson-databind and protobuf-java libraries.",
      "rootCause": "Vulnerable versions of transitive dependencies: jackson-databind-2.13.0 (DoS via deep object nesting and JDK serialization) and protobuf-java-3.18.1 (parser abuse via UnknownFieldSet interleaving).",
      "proposedFix": "Upgrade io.temporal:temporal-sdk to version 1.8.0 to resolve jackson-databind vulnerabilities, and to 1.6.0+ for protobuf-java CVE-2021-22569.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue automatically closed by Mend when the vulnerable library was removed from the dependency tree or marked as ignored.",
      "related": [],
      "keyQuote": "jackson-databind before 2.13.0 allows a Java StackOverflow exception and denial of service via a large depth of nested objects.",
      "number": 33,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:41.988Z"
    },
    {
      "summary": "Feature request to update workflow time when processing queries to allow handlers to get current system time instead of last workflow task time. The solution proposes exposing system time through WorkflowInfo.unsafe.now for TypeScript SDK where wall clock access is sandboxed.",
      "category": "feature",
      "subcategory": "query-handlers",
      "apis": [
        "Workflow.await"
      ],
      "components": [
        "query-handler",
        "workflow-info",
        "typescript-sdk"
      ],
      "concepts": [
        "time",
        "queries",
        "sandboxing",
        "system-time",
        "workflow-time"
      ],
      "severity": "medium",
      "userImpact": "Allows developers to get real system time in query handlers instead of being limited to workflow time, important for TypeScript where wall clock access is sandboxed.",
      "rootCause": "Query handlers use workflow time which may be stale if no recent workflow tasks have been processed, but sandboxing in TypeScript prevents direct access to system time.",
      "proposedFix": "Expose system time in WorkflowInfo.unsafe.now to allow queries to access current system time when needed.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed in favor of linked TypeScript-specific issue, deemed not needed for non-sandboxed runtimes.",
      "related": [],
      "keyQuote": "Update workflow time before processing queries (and possibly immediately reset back to workflow time)",
      "number": 31,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:24.755Z"
    },
    {
      "summary": "Request to add support for SignalExternalWorkflowWithStart as a WorkflowTaskCommand, avoiding the need to use activities and the Temporal Client. Currently requires going through an activity layer, which is inefficient compared to native signal commands.",
      "category": "feature",
      "subcategory": "workflow-signaling",
      "apis": [
        "SignalExternalWorkflow",
        "SignalExternalWorkflowWithStart",
        "StartChildWorkflow"
      ],
      "components": [
        "workflow-task-command",
        "signal-handler",
        "workflow-engine"
      ],
      "concepts": [
        "external-workflow-signaling",
        "workflow-commands",
        "start-with-signal",
        "client-abstraction",
        "command-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users must currently use activities and the Temporal Client to signal workflows with start, instead of using native workflow commands like regular SignalExternalWorkflow.",
      "rootCause": "SignalExternalWorkflowWithStart command does not exist at the server/API level, unlike SignalExternalWorkflow and StartChildWorkflow commands.",
      "proposedFix": "Create SignalExternalWorkflowWithStart as a new WorkflowTaskCommand, requiring implementation in server and API repositories.",
      "workaround": "Use an activity to invoke the Temporal Client for SignalExternalWorkflowWithStart operations.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        537
      ],
      "keyQuote": "It would be great if that can also be handled via a WorkflowTaskCommand as well.",
      "number": 30,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:23.205Z"
    },
    {
      "summary": "Add `first_execution_run_id` field to workflow info APIs across all Temporal SDKs. This field is already present in Java and TypeScript but missing from Go, Python, Ruby, and PHP SDKs.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo",
        "GetWorkflowInfo"
      ],
      "components": [
        "workflow-info-api",
        "sdk-integration",
        "workflow-execution"
      ],
      "concepts": [
        "workflow-metadata",
        "execution-tracking",
        "api-consistency",
        "multi-sdk-parity",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Users across Go, Python, Ruby, and PHP SDKs cannot access first execution run ID, limiting their ability to track workflow execution history consistently.",
      "rootCause": null,
      "proposedFix": "Add `first_execution_run_id` field to WorkflowInfo API in Go, Python, Ruby, and PHP SDKs following the existing implementation in Java and TypeScript.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2017,
        1025,
        505,
        311,
        642
      ],
      "keyQuote": "Add \"first execution run ID\" to workflow info",
      "number": 29,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:21.114Z"
    },
    {
      "summary": "Compile and package gRPC client for the operator service across all SDKs (TypeScript, Java, Go, Python, PHP, .NET, Ruby). The operator service was added to the Temporal API but needs to be exposed in each SDK for users to access it.",
      "category": "feature",
      "subcategory": "operator-service",
      "apis": [
        "OperatorService",
        "Client.WorkflowService()"
      ],
      "components": [
        "operator-client",
        "grpc-client",
        "sdk-api"
      ],
      "concepts": [
        "gRPC",
        "service-client",
        "operator-api",
        "code-generation",
        "multi-sdk-support"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access the operator service from SDKs until the gRPC client is compiled, packaged, and exposed in each SDK.",
      "rootCause": "OperatorService was added to the Temporal API but not yet exposed as a client method in all SDKs.",
      "proposedFix": "Expose OperatorService client in each SDK similar to how WorkflowService is exposed (e.g., Client.OperatorService()).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "OperatorService gRPC client was compiled and packaged for all SDKs (TS, Java, Go, Python, PHP, .NET, Ruby), with exposure implemented in SDKs like Go.",
      "related": [
        896,
        93,
        229
      ],
      "keyQuote": "We still need to expose this in Go same as we do for `Client.WorkflowService()`",
      "number": 28,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:08.230Z"
    },
    {
      "summary": "Each SDK's gRPC retry logic implementation differs across the codebase. This feature request calls for unifying the retry behavior across Core, TypeScript, Java, Go, and PHP SDKs to ensure consistent and maintainable retry semantics.",
      "category": "feature",
      "subcategory": "grpc-retry",
      "apis": [],
      "components": [
        "grpc-client",
        "retry-interceptor",
        "service-client"
      ],
      "concepts": [
        "retry-logic",
        "grpc",
        "cross-sdk-consistency",
        "error-handling",
        "network-resilience"
      ],
      "severity": "medium",
      "userImpact": "Inconsistent gRPC retry behavior across SDKs creates confusion and potential reliability issues for users building polyglot Temporal applications.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Each SDK's gRPC retry logic is a bit different and should be unified.",
      "number": 27,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:06.075Z"
    },
    {
      "summary": "Request to expose a workflow_started metric in SDKs to track worker-side workflow executions. Currently wf_completed and wf_continue_as_new metrics exist, but there is no corresponding metric for workflow starts.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [
        "StartWorkflowExecution"
      ],
      "components": [
        "worker",
        "metrics",
        "sdk"
      ],
      "concepts": [
        "metrics",
        "observability",
        "workflow-lifecycle",
        "monitoring",
        "execution-tracking"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily track the number of workflows actually started on workers, limiting observability of workflow execution patterns.",
      "rootCause": null,
      "proposedFix": "Add workflow_started metric to SDK to track worker-side workflow execution starts, complementing existing wf_completed and wf_continue_as_new metrics.",
      "workaround": "Use temporal_request{operation=\"StartWorkflowExecution\"} as an approximation, though this only tracks client attempts rather than actual worker-side execution.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "wf_completed, wf_continue_as_new exists, but there is no corresponding wf_started metric.",
      "number": 25,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:43:09.688Z"
    },
    {
      "summary": "Git checkout in the TypeScript SDK's CI workflow fails for forked repositories. The issue is in the workflow configuration that doesn't properly handle checking out code in fork contexts.",
      "category": "bug",
      "subcategory": "ci-workflow",
      "apis": [],
      "components": [
        "github-actions",
        "typescript-workflow",
        "checkout-action"
      ],
      "concepts": [
        "ci-cd",
        "forked-repositories",
        "workflow-configuration",
        "git-checkout"
      ],
      "severity": "medium",
      "userImpact": "Contributors using forked repositories cannot run TypeScript SDK tests through CI workflows.",
      "rootCause": "The git checkout action in typescript.yml doesn't properly handle fork contexts where the source repository differs from the fork.",
      "proposedFix": "Apply the fix from actions/checkout#455 to properly configure checkout for forked repositories.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Already fixed in pull request #21 with proper fork handling configuration.",
      "related": [
        21
      ],
      "keyQuote": "This is already fixed in pull request #21 -- I think probably wherever you saw this just wasn't using latest HEAD of the TS repo.",
      "number": 23,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:54.906Z"
    },
    {
      "summary": "Establish standardized client behavior specifications for WorkflowHandle and stub methods across SDKs, particularly regarding run_id usage for handles created with start(), signal_with_start(), and getHandle() methods to ensure safety and consistency.",
      "category": "feature",
      "subcategory": "workflow-handles",
      "apis": [
        "WorkflowHandle",
        "getHandle",
        "start",
        "signal_with_start",
        "signal",
        "query",
        "describe"
      ],
      "components": [
        "workflow-client",
        "workflow-handle",
        "stub-methods"
      ],
      "concepts": [
        "run_id",
        "first_execution_run_id",
        "execution-chain",
        "handle-safety",
        "cross-sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users need consistent and safe behavior when using WorkflowHandle methods across different SDKs to avoid operating on unrelated workflow runs.",
      "rootCause": "Inconsistent implementation of run_id handling across SDKs and lack of server-side safety guarantees for certain handle operations.",
      "proposedFix": "Standardize handle behavior: use run_id only when explicitly created with one, use first_execution_run_id for safety by default on started handles, and require server/API changes for signal/query/describe safety.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        468
      ],
      "keyQuote": "Handles created with `start` should follow runs by default and use `first_execution_run_id` for safety (don't operate on runs that aren't part of the same execution chain).",
      "number": 22,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:52.589Z"
    },
    {
      "summary": "Worker shutdown should send ResetStickyTaskQueue request to server to reset the sticky task queue and allow workflow tasks to be routed to the normal task queue. Should support both graceful and forceful shutdown (SIGKILL, SIGTERM).",
      "category": "feature",
      "subcategory": "worker-shutdown",
      "apis": [
        "ResetStickyTaskQueue"
      ],
      "components": [
        "worker",
        "task-queue",
        "shutdown-handler"
      ],
      "concepts": [
        "sticky-task-queue",
        "shutdown",
        "task-routing",
        "queue-management"
      ],
      "severity": "medium",
      "userImpact": "Without this feature, sticky task queues remain active after worker shutdown, preventing proper task distribution and potentially causing workflow execution delays.",
      "rootCause": null,
      "proposedFix": "Implement ResetStickyTaskQueue API call during worker shutdown lifecycle",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        464
      ],
      "keyQuote": "When a worker shuts down, it should send a ResetStickyTaskQueue request to server so it can reset it and allow server to put the next workflow task on the \"normal\" task queue.",
      "number": 19,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:52.772Z"
    },
    {
      "summary": "SDKs need a standardized API for describing workflows that wraps gRPC responses in language-idiomatic types, exposing both high-level helpers (like status shortcuts) and access to the underlying DescribeWorkflowExecutionResponse.",
      "category": "feature",
      "subcategory": "sdk-api",
      "apis": [
        "DescribeWorkflowExecution"
      ],
      "components": [
        "sdk-api",
        "grpc-wrapper",
        "response-types"
      ],
      "concepts": [
        "api-design",
        "language-idioms",
        "grpc-wrapping",
        "response-abstraction",
        "sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users across all SDKs need a consistent, language-appropriate way to describe workflows with convenient access to common fields like status.",
      "rootCause": null,
      "proposedFix": "Create a wrapper type in each SDK that exposes a DescribeWorkflowExecutionResponse and provides higher-level helper methods (e.g., status shortcut).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDKs should make describing a workflow easy... the response is a language-idiomatic wrapper that exposes a shortcut for status",
      "number": 17,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:38.541Z"
    },
    {
      "summary": "Cross-SDK feature request to expose workflow history length and size information via the Workflow Info API, along with a 'continue as new suggested' indicator. This helps workflows make informed decisions about when to continue as new based on history metrics.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "sdk-api",
        "history-tracking"
      ],
      "concepts": [
        "history-size",
        "history-length",
        "continue-as-new",
        "workflow-metadata",
        "server-capability"
      ],
      "severity": "medium",
      "userImpact": "Workflows can now access historical metrics to make informed decisions about continuing as new, improving long-running workflow management across all SDKs.",
      "rootCause": null,
      "proposedFix": "Expose history length, history size, and 'continue as new suggested' flag in WorkflowInfo API across all SDKs (Go, TypeScript, Java, Python, PHP, .NET).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented across SDKs with additional consideration for server capability detection and query response delays.",
      "related": [
        851,
        357,
        1300,
        73,
        222,
        122,
        2726,
        3055,
        628,
        564,
        695,
        1853,
        361
      ],
      "keyQuote": "These values may be delayed if accessed in a query. SDKs need to document that these values may be delayed if accessed in a query.",
      "number": 16,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:40.317Z"
    },
    {
      "summary": "Feature request to make long-poll timeout configurable across SDKs. Currently defaults to 70 seconds, but should allow users with special network setups to adjust this value for their needs.",
      "category": "feature",
      "subcategory": "long-poll-timeout",
      "apis": [],
      "components": [
        "client",
        "network",
        "long-poll"
      ],
      "concepts": [
        "timeout",
        "long-poll",
        "network-configuration",
        "client-server-communication",
        "advanced-settings"
      ],
      "severity": "low",
      "userImpact": "Users with unique network setups cannot optimize long-poll timeouts for their environment, limiting SDK flexibility.",
      "rootCause": null,
      "proposedFix": "Make long-poll timeout value configurable in SDK client configuration, allowing users to override the default 70-second timeout.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        988
      ],
      "keyQuote": "Allow the value to be configurable",
      "number": 13,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:35.711Z"
    },
    {
      "summary": "Feature request to add a metric for tracking TLS certificate expiration across SDKs. Users need visibility into certificate expiration to prevent unexpected worker failures when certificates expire without notice.",
      "category": "feature",
      "subcategory": "observability-tls",
      "apis": [],
      "components": [
        "worker",
        "tls-handshake",
        "metrics"
      ],
      "concepts": [
        "certificate-expiration",
        "observability",
        "connection-security",
        "worker-health",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Workers can silently fail when certificates expire, leaving users without visibility into the root cause until explicitly checking certificate status.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        11
      ],
      "keyQuote": "The user's workers stopped processing tasks and they did not know it was because certs have expired.",
      "number": 12,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:24.370Z"
    },
    {
      "summary": "Feature request to enable SDKs to dynamically inject new TLS certificates into connection instances after initialization. Different SDKs have varying support levels, from built-in callbacks (Go, Java) to requiring client replacement (TypeScript, Rust Core).",
      "category": "feature",
      "subcategory": "tls-certificates",
      "apis": [],
      "components": [
        "client",
        "connection",
        "tls",
        "credentials"
      ],
      "concepts": [
        "certificate-rotation",
        "tls-configuration",
        "dynamic-injection",
        "connection-management",
        "certificate-handling"
      ],
      "severity": "medium",
      "userImpact": "Users need a consistent way to refresh or rotate TLS certificates in long-running applications without reconnecting or replacing the entire client instance.",
      "rootCause": null,
      "proposedFix": "Implement per-SDK mechanisms: Go via GetClientCertificate callback, TypeScript/Rust Core via client replacement, Java via existing support, Python and .NET via issue tickets, PHP via TODO.",
      "workaround": "Client replacement (already supported in TypeScript and Rust Core)",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1412,
        513,
        235
      ],
      "keyQuote": "SDKs users should have a way to inject new certificates to a connection instance",
      "number": 11,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:23.967Z"
    },
    {
      "summary": "Clarify and standardize how all SDKs handle manually returned cancellation errors in workflows and activities when no cancellation is in progress. The behavior is currently inconsistent and needs confirmation that SDKs don't send RespondActivityTaskCanceledRequest inappropriately.",
      "category": "feature",
      "subcategory": "cancellation-handling",
      "apis": [],
      "components": [
        "activity-executor",
        "workflow-executor",
        "cancellation-handler"
      ],
      "concepts": [
        "cancellation",
        "error-handling",
        "async-completion",
        "cross-sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Developers may experience inconsistent or unexpected behavior when manually returning cancellation errors in activities across different SDK implementations.",
      "rootCause": null,
      "proposedFix": "Ensure all SDKs: (1) do not send RespondActivityTaskCanceledRequest when no cancellation is requested from the server, (2) confirm async complete activity can still receive cancellation errors",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        686
      ],
      "keyQuote": "Make sure all SDKs do not try to send RespondActivityTaskCanceledRequest to the server regardless of error type when there's not a cancellation requested",
      "number": 10,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:22.022Z"
    },
    {
      "summary": "Client certificate expiration errors show generic 'Context deadline exceeded' message instead of clearly indicating the certificate has expired. Request for improved error messaging and associated error codes to aid debugging.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "client",
        "connection",
        "tls-handshake",
        "error-reporting"
      ],
      "concepts": [
        "certificate-expiration",
        "error-messaging",
        "tls-failure",
        "connection-failure",
        "debugging",
        "error-codes",
        "metrics"
      ],
      "severity": "medium",
      "userImpact": "Users encounter cryptic error messages when client certificates expire, making it difficult to diagnose and resolve certificate-related connectivity issues.",
      "rootCause": "gRPC retries connection failures with generic timeout messages rather than reporting the underlying TLS certificate validation failure from the server.",
      "proposedFix": "Improve error messages to explicitly state 'Expired Certificate' or equivalent, add error codes, bump poll-failure SDK logs to WARN level, and potentially add dedicated metrics for TLS/certificate failures.",
      "workaround": "Enable verbose logging via EnableVerboseLogging to see debug-level poll errors, or check server-side TLS handshake logs for certificate validation details.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Have a message which clearly states `Expired Certificate or something equivalent`. Also it will be beneficial if we can have error code associated with this message",
      "number": 9,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:08.852Z"
    },
    {
      "summary": "SDKs should implement more aggressive backoff strategies when encountering ResourceExhaustedError instead of using uniform retryable error handling.",
      "category": "feature",
      "subcategory": "retry-backoff",
      "apis": [],
      "components": [
        "sdk-client",
        "retry-logic",
        "error-handling"
      ],
      "concepts": [
        "backoff",
        "retry",
        "resource-exhaustion",
        "error-handling",
        "rate-limiting"
      ],
      "severity": "medium",
      "userImpact": "Users experiencing resource exhaustion errors face suboptimal backoff behavior, potentially causing prolonged service disruption.",
      "rootCause": null,
      "proposedFix": "Implement differentiated backoff strategies where ResourceExhaustedError triggers more aggressive backoff than other retryable errors.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDKs should backoff aggressively on `ResourceExhaustedError`",
      "number": 8,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:08.349Z"
    },
    {
      "summary": "Cross-SDK feature to detect server capabilities using getSystemInfo request instead of health checks. Enables SDKs to determine feature support and optionally require specific capabilities for connection establishment.",
      "category": "feature",
      "subcategory": "server-capabilities",
      "apis": [
        "getSystemInfo"
      ],
      "components": [
        "connection",
        "server-discovery",
        "capability-detection",
        "health-check"
      ],
      "concepts": [
        "server-capabilities",
        "feature-detection",
        "connection-establishment",
        "sdk-compatibility",
        "health-check"
      ],
      "severity": "medium",
      "userImpact": "Users can rely on consistent capability detection across SDKs and optionally enforce minimum server feature requirements.",
      "rootCause": null,
      "proposedFix": "Replace health check calls with getSystemInfo request across all SDKs and add optional capability requirement validation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across Go, TypeScript, Java SDKs and sdk-core; PHP SDK implementation pending.",
      "related": [
        701,
        682,
        290,
        1312,
        223
      ],
      "keyQuote": "Should this call replace the health check call that Go and Java use when they establish a connection?",
      "number": 7,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:42:06.146Z"
    },
    {
      "summary": "SDKs need to stop retrying on 'Internal' server errors and instead treat them as non-retryable, while continuing to retry 'Unavailable' errors. SDKs should use the capabilities reported in the getSystemInfo API to distinguish between server versions that properly differentiate these error codes.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "getSystemInfo"
      ],
      "components": [
        "retry-logic",
        "error-handling",
        "server-communication"
      ],
      "concepts": [
        "retry",
        "error-codes",
        "server-compatibility",
        "Internal-error",
        "Unavailable-error",
        "capabilities"
      ],
      "severity": "high",
      "userImpact": "Without this fix, SDKs retry on Internal errors that shouldn't be retried, leading to unnecessary delays and potential cascading failures when the server encounters non-recoverable errors.",
      "rootCause": "Server previously returned only 'Internal' errors, so SDKs always retried them. Now server differentiates between 'Internal' (non-retryable) and 'Unavailable' (retryable), requiring SDK changes.",
      "proposedFix": "SDKs should use the capabilities reported in the getSystemInfo API call to determine if the server properly supports the Internal/Unavailable differentiation, and conditionally stop retrying Internal errors.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented across all SDKs: Go SDK, Core SDK, TypeScript SDK client, Java SDK (issue #1315), and PHP SDK (issue #221). Verified complete in all implementations.",
      "related": [
        1315,
        221,
        27
      ],
      "keyQuote": "SDKs need to stop retry on Internal. In order to distinguish between the server versions SDKs should use the capabilities reported in the getSystemInfo API call.",
      "number": 6,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:41:51.501Z"
    },
    {
      "summary": "Request to rename the features/ directory to spec/ since it now contains both specifications and bugs, making the original name less accurate.",
      "category": "feature",
      "subcategory": "project-structure",
      "apis": [],
      "components": [
        "repository-structure",
        "documentation"
      ],
      "concepts": [
        "naming-convention",
        "directory-organization",
        "project-layout",
        "semantic-clarity"
      ],
      "severity": "low",
      "userImpact": "Makes the repository structure more intuitive and accurately reflects the contents.",
      "rootCause": null,
      "proposedFix": "Rename the features/ directory to spec/",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Since there are bugs/ under features/ that name doesn't make as much sense.",
      "number": 4,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:41:51.428Z"
    },
    {
      "summary": "Request to add comprehensive feature tests for SDK-side validation of server commands and client-side options. Proposes creating a spec directory with markdown behavior specifications that each SDK must implement tests for.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "RetryOptions"
      ],
      "components": [
        "test-framework",
        "options-validation",
        "spec-compliance"
      ],
      "concepts": [
        "validation",
        "testing",
        "specification",
        "sdk-compliance",
        "options-constraints"
      ],
      "severity": "medium",
      "userImpact": "Ensures consistent validation behavior across all SDKs and helps developers understand expected validation rules for SDK options.",
      "rootCause": null,
      "proposedFix": "Create a spec directory with markdown files documenting specific validation behaviors. Establish conventions for where behavior tests are located in each SDK to enable quick spec compliance verification.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We'd discussed not treating this as a 'feature' but instead have a separate `spec` directory containing markdown files that document specific behaviors.",
      "number": 3,
      "repo": "temporalio-features",
      "generatedAt": "2026-01-11T04:41:53.181Z"
    }
  ]
}