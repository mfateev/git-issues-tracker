{
  "generatedAt": "2026-01-22T20:29:17.525Z",
  "totalCards": 941,
  "cards": [
    {
      "summary": "Spring Boot 4 metrics configuration fails because the MetricsScopeAutoConfiguration waits for CompositeMeterRegistryAutoConfiguration, but the class package location changed in Spring Boot 4, causing metrics to be emitted to a no-op scope instead of the actual Micrometer MeterRegistry.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "temporal-spring-boot-autoconfigure",
        "MetricsScopeAutoConfiguration",
        "Micrometer integration"
      ],
      "concepts": [
        "metrics",
        "Spring Boot 4",
        "package location",
        "auto-configuration",
        "dependency ordering"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to Spring Boot 4 lose metrics observability, with metrics being silently emitted to a no-op scope instead of being properly collected by Micrometer.",
      "rootCause": "CompositeMeterRegistryAutoConfiguration package moved from one location to another in Spring Boot 4, breaking the class reference in the @AutoConfigureAfter annotation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "the package for this class changed to org.springframework.boot.micrometer.metrics.autoconfigure.CompositeMeterRegistryAutoConfiguration in Spring Boot 4",
      "number": 2758,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:18:16.220Z"
    },
    {
      "summary": "Request to support using Temporal failures in Nexus APIs, enabling better error handling and integration between Nexus operations and Temporal's failure model.",
      "category": "feature",
      "subcategory": "nexus-integration",
      "apis": [],
      "components": [
        "nexus",
        "failure-handling",
        "api-integration"
      ],
      "concepts": [
        "error-handling",
        "nexus",
        "temporal-failures",
        "api-design",
        "interoperability"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to use Temporal's failure types natively in Nexus APIs, improving consistency and error handling across distributed systems.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        682
      ],
      "keyQuote": "Support using Temporal failures in Nexus APIs.",
      "number": 2755,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:18:17.092Z"
    },
    {
      "summary": "Java SDK reads incorrect configuration file path on macOS, using Linux path (~/.config/temporalio/temporal.toml) instead of the documented macOS path ($HOME/Library/Application Support/temporal/temporal.toml). This prevents users from loading profiles created with the CLI.",
      "category": "bug",
      "subcategory": "environment-configuration",
      "apis": [],
      "components": [
        "configuration-loader",
        "environment-config",
        "profile-manager"
      ],
      "concepts": [
        "file-path",
        "platform-specific",
        "configuration-resolution",
        "macos",
        "environment-setup",
        "profile-loading"
      ],
      "severity": "high",
      "userImpact": "macOS users cannot load Temporal configuration profiles created by the CLI, forcing them to manually copy files to non-standard locations as a workaround.",
      "rootCause": "The Java SDK's environment configuration loader uses the Linux file path on macOS instead of checking the platform-specific macOS path first.",
      "proposedFix": null,
      "workaround": "Copy the profile file from $HOME/Library/Application Support/temporal/temporal.toml to ~/.config/temporalio/temporal.toml",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Per the documentation, the SDKs should read the toml config file on a mac from $HOME/Library/Application Support/temporal/temporal.toml. However this path is not being read (the Linux path is being read instead)",
      "number": 2754,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:18:04.007Z"
    },
    {
      "summary": "User reports that activities don't retry after worker crashes during execution if the StartToCloseTimeout is exceeded, and requests a way to check CancellationScope cancellation status after scope exit.",
      "category": "question",
      "subcategory": "activity-timeout-recovery",
      "apis": [
        "CancellationScope",
        "Async.procedure"
      ],
      "components": [
        "activity-executor",
        "worker-recovery",
        "cancellation-handling"
      ],
      "concepts": [
        "timeout",
        "retry",
        "worker-crash",
        "cancellation",
        "activity-lifecycle",
        "cleanup-logic"
      ],
      "severity": "medium",
      "userImpact": "Users building DSL systems with activity cancellation cleanup logic cannot reliably handle worker crashes and lack visibility into cancellation scope status for conditional state updates.",
      "rootCause": "Activities are non-durable with no guarantees for cleanup logic execution on failure or worker crash; after cancellation request, activities are not retried by design.",
      "proposedFix": null,
      "workaround": "Use saga design pattern with compensation activities for cleanup; check CancellationScope.isCancelRequested() after scope completion; memorize activity results in variables for post-execution status checks.",
      "resolution": "invalid",
      "resolutionDetails": "Resolved as working-as-designed. Activity cancellation prevents retries by design. Users should use saga pattern for cleanup guarantees and isCancelRequested() to check scope status.",
      "related": [],
      "keyQuote": "Activities are non-durable and there are no guarantees that any cleanup logic will execute in case of failure or worker crash.",
      "number": 2753,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:18:06.185Z"
    },
    {
      "summary": "OpenTracingWorkflowClientCallsInterceptor is missing support for the updateWithStart operation, preventing trace propagation for this workflow update pattern. The trace header remains empty for the workflow execution started event when using updateWithStart.",
      "category": "feature",
      "subcategory": "opentracing-interceptor",
      "apis": [
        "updateWithStart",
        "StartWorkflow"
      ],
      "components": [
        "opentracing-interceptor",
        "workflow-client-calls",
        "trace-propagation"
      ],
      "concepts": [
        "distributed-tracing",
        "trace-propagation",
        "opentracing",
        "workflow-updates",
        "interceptor"
      ],
      "severity": "medium",
      "userImpact": "Users cannot trace updateWithStart operations, making it difficult to observe and debug this workflow pattern in distributed tracing systems.",
      "rootCause": "OpenTracingWorkflowClientCallsInterceptor does not implement handling for the updateWithStart operation, leaving trace headers empty for the workflow execution started event.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Traces are not propagated for the operation updateWithStart; header field is empty for the first event EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
      "number": 2752,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:18:06.357Z"
    },
    {
      "summary": "Tests in WorkflowFailedMetricsTests are failing intermittently when run in conjunction with other tests because the TestStatsReporter.flush() method in the @Before setup is not properly clearing metrics from previous test executions, causing assertion failures for expected metrics.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestStatsReporter",
        "metrics-reporting",
        "workflow-tests"
      ],
      "concepts": [
        "metrics-isolation",
        "test-setup",
        "state-cleanup",
        "metric-assertion",
        "test-ordering"
      ],
      "severity": "high",
      "userImpact": "Developers cannot reliably run the test suite on a clean build due to intermittent test failures.",
      "rootCause": "TestStatsReporter.flush() is not properly clearing or isolating metrics between test executions, causing metrics from previous tests to persist and interfere with assertions in subsequent tests.",
      "proposedFix": null,
      "workaround": null,
      "related": [],
      "resolution": null,
      "resolutionDetails": null,
      "keyQuote": "No metric 'temporal_workflow_failed [namespace=UnitTest|task_queue=WorkflowTest-runtimeExceptionWorkflowFailedMetric...",
      "number": 2750,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:47.989Z"
    },
    {
      "summary": "The @WorkflowImpl annotation's workers attribute does not support Spring property placeholders like ${my.property}, while taskQueues does. This inconsistency breaks placeholder-based configuration sharing across multiple services with different worker names.",
      "category": "bug",
      "subcategory": "spring-integration",
      "apis": [],
      "components": [
        "WorkersTemplate",
        "WorkflowImpl",
        "spring-boot-starter"
      ],
      "concepts": [
        "property-placeholder",
        "spring-configuration",
        "worker-registration",
        "configuration-consistency",
        "multi-service-deployment"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use Spring property placeholders for worker names in @WorkflowImpl, forcing them to hardcode values or use taskQueues workaround instead, breaking configuration consistency.",
      "rootCause": "The configureWorkflowImplementationsByWorkerName() and related methods in WorkersTemplate.java do not apply placeholder resolution to the workers attribute, unlike the taskQueues implementation.",
      "proposedFix": "Add placeholder resolution in configureWorkflowImplementationsByWorkerName(), configureActivityBeansByWorkerName(), and configureNexusServiceBeansByWorkerName() methods in WorkersTemplate.java to match taskQueues behavior.",
      "workaround": "Use taskQueues with a property placeholder instead of workers attribute, though this is inconsistent with the intended workers API.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Currently, only taskQueues supports Spring property placeholders (e.g., ${my.property}), while workers does not.",
      "number": 2747,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:51.284Z"
    },
    {
      "summary": "Add support for Jackson 3, the next major version of the JSON serialization library used by the Java SDK. This requires creating a new Jackson 3 JSON data converter while maintaining backward compatibility with Jackson 2, given that Jackson 3 requires Java 17 minimum.",
      "category": "feature",
      "subcategory": "json-serialization",
      "apis": [],
      "components": [
        "json-data-converter",
        "serialization",
        "jackson-dependency"
      ],
      "concepts": [
        "version-upgrade",
        "compatibility",
        "json-serialization",
        "dependency-management",
        "java-version"
      ],
      "severity": "medium",
      "userImpact": "Users can leverage Jackson 3 with the Temporal Java SDK, enabling compatibility with Spring Boot 4 and other frameworks standardizing on Jackson 3.",
      "rootCause": null,
      "proposedFix": "Create a new Jackson 3 JSON data converter and update all SDK code that calls Jackson APIs to support both Jackson 2 and Jackson 3.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add support for Jackson 3 to the Java SDK. This would mainly involve creating a new Jackson 3 JSON data converter, and any other place the SDK calls into Jackson.",
      "number": 2746,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:49.224Z"
    },
    {
      "summary": "WorkerOptions.isUsingVirtualThreadsOnWorkflowWorker() is incorrectly returning the value of usingVirtualThreadsOnActivityWorker instead of its own value, indicating a copy-paste bug in the getter method.",
      "category": "bug",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "worker-options",
        "virtual-threads"
      ],
      "concepts": [
        "virtual-threads",
        "configuration",
        "method-implementation",
        "getter",
        "bug"
      ],
      "severity": "medium",
      "userImpact": "Users checking whether virtual threads are enabled for workflow workers will get incorrect information, potentially causing unexpected behavior in multi-threaded workflow execution.",
      "rootCause": "The isUsingVirtualThreadsOnWorkflowWorker() method at line 870-872 returns the usingVirtualThreadsOnActivityWorker field instead of the correct usingVirtualThreadsOnWorkflowWorker field.",
      "proposedFix": "Change the return statement in isUsingVirtualThreadsOnWorkflowWorker() to return usingVirtualThreadsOnWorkflowWorker instead of usingVirtualThreadsOnActivityWorker.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "returning usingVirtualThreadsOnActivityWorker currently",
      "number": 2745,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:35.765Z"
    },
    {
      "summary": "Allow executing activities outside of workflow context. This requires client support for new server APIs to start, manage, and retrieve activity results, plus worker support for running activities independently.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "client",
        "activity-management"
      ],
      "concepts": [
        "activities",
        "non-workflow-execution",
        "server-api",
        "activity-lifecycle",
        "distributed-execution"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to execute activities without wrapping them in workflows, enabling more flexible activity composition and standalone activity execution patterns.",
      "rootCause": null,
      "proposedFix": "Implement support for new server APIs (referenced in temporalio/api#640) for starting and managing activities, and update workers to execute activities outside workflow context.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        640
      ],
      "keyQuote": "Allow executing activities without a workflow. The clients must support the new (upcoming) server APIs for starting, managing and getting results of activities.",
      "number": 2741,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:33.181Z"
    },
    {
      "summary": "Request for Temporal SDK support for Spring Boot 4, which was released in November 2025. Spring Boot 4's modularization may require SDK changes, and Jackson 3 support will also be needed since Jackson 2 is deprecated in Spring Boot 4.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-integration",
        "payload-converter",
        "jackson-converter"
      ],
      "concepts": [
        "spring-boot",
        "framework-compatibility",
        "jackson",
        "modularization",
        "json-serialization",
        "version-upgrade"
      ],
      "severity": "medium",
      "userImpact": "Users running Spring Boot 4 applications cannot use the Temporal SDK without a custom integration layer, limiting adoption among Spring Boot 4 users.",
      "rootCause": "Spring Boot 4's modularization introduces breaking changes that require SDK updates, and deprecated Jackson 2 support necessitates Jackson 3 compatibility.",
      "proposedFix": "Investigate Spring Boot 4 compatibility requirements and implement necessary changes. Consider creating a separate Jackson3JsonPayloadConverter for Jackson 3 support.",
      "workaround": "Users can create a custom Spring Boot integration layer based on the core Temporal SDK to support Spring Boot 4.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2746
      ],
      "keyQuote": "Spring Boot 4 has already come out, so it would be great if Temporal SDK adds support for it as well.",
      "number": 2738,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:35.359Z"
    },
    {
      "summary": "User's custom FailureConverter returns a RuntimeException that causes workflows to hang in an infinite loop during failure deserialization. The issue occurs when the converter returns a custom RuntimeException instead of TemporalFailure, despite this being supported after SDK 1.28.",
      "category": "bug",
      "subcategory": "failure-converter",
      "apis": [
        "FailureConverter",
        "ApplicationFailure"
      ],
      "components": [
        "failure-converter",
        "workflow-execution",
        "error-handling"
      ],
      "concepts": [
        "exception-handling",
        "failure-serialization",
        "cross-language-compatibility",
        "workflow-lifecycle",
        "error-propagation"
      ],
      "severity": "high",
      "userImpact": "Applications using custom FailureConverters that return RuntimeExceptions experience stuck workflows that never complete, blocking workflow execution entirely.",
      "rootCause": "The SDK does not properly handle RuntimeExceptions returned from FailureConverter.failureToException() - it causes workflow task failures in a loop instead of properly unwrapping and propagating the exception.",
      "proposedFix": "Add support for arbitrary RuntimeExceptions returned from failureToException by properly unwrapping and propagating them to the workflow code, similar to how GO-SDK handles the same case with error unwrapping.",
      "workaround": "Configure setFailWorkflowExceptionTypes() to mark the custom exception as a failure exception type so the SDK treats it as a workflow failure rather than a task failure.",
      "resolution": "wontfix",
      "resolutionDetails": "SDK maintainer clarified this use case is not recommended or supported per documentation. FailureConverters are intended for encryption only, not custom serialization. Users should use standard Temporal ApplicationFailures instead.",
      "related": [],
      "keyQuote": "I will say this use of failure converter is not recommend or really supported. Per the SDK docs... The intended use case of failure converters is to help with encryption of potentially sensitive data inside exceptions.",
      "number": 2737,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:21.079Z"
    },
    {
      "summary": "Non-root namespaces cannot use the in-memory test server in Spring Boot autoconfiguration due to a bean name/type mismatch. The code looks for a TestWorkflowEnvironmentAdapter with an incorrect bean name, causing non-root namespaces to connect to the dev server instead.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "test-server",
        "non-root-namespaces",
        "bean-post-processor"
      ],
      "concepts": [
        "namespace-isolation",
        "dependency-injection",
        "test-configuration",
        "bean-registration",
        "spring-autoconfiguration"
      ],
      "severity": "medium",
      "userImpact": "Users configuring multiple namespaces with Spring Boot cannot use the in-memory test server for non-root namespaces, forcing them to use the dev server instead.",
      "rootCause": "NonRootBeanPostProcessor searches for 'temporalTestWorkflowEnvironment' as TestWorkflowEnvironmentAdapter type, but TestServerAutoConfiguration registers 'temporalTestWorkflowEnvironmentAdapter' as TestWorkflowEnvironmentAdapter and 'temporalTestWorkflowEnvironment' as TestWorkflowEnvironment, causing a name/type mismatch.",
      "proposedFix": "Fix the bean name lookup in NonRootBeanPostProcessor to use 'temporalTestWorkflowEnvironmentAdapter' instead of 'temporalTestWorkflowEnvironment' when searching for TestWorkflowEnvironmentAdapter.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bean name/type mismatch was corrected in NonRootBeanPostProcessor to properly reference the TestWorkflowEnvironmentAdapter bean.",
      "related": [],
      "keyQuote": "The code is looking for a TestWorkflowEnvironmentAdapter with the wrong bean name.",
      "number": 2735,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:16.267Z"
    },
    {
      "summary": "activity_schedule_to_start_latency metric incorrectly reports activity_type dimension, including unexpected 'none' values when activities fail and are retried. The metric should either consistently report activity_type for all activities or not report it at all.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "retry-handler"
      ],
      "concepts": [
        "metrics-reporting",
        "activity-scheduling",
        "latency-tracking",
        "dimension-tags",
        "retry-behavior"
      ],
      "severity": "medium",
      "userImpact": "Users receive confusing metrics with unexpected 'none' activity_type values and inconsistent metric reporting, making it difficult to monitor activity scheduling latency accurately.",
      "rootCause": "Activity failures during retry may be generating schedule_to_start_latency metrics without an associated activity_type, resulting in 'none' being used as a default dimension value.",
      "proposedFix": "Either ensure activity_schedule_to_start_latency always reports activity_type dimension for all activities, or remove activity_type dimension entirely and use task_queue as the lowest granularity.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There's no scenario where an activity schedule to start would not have an associated activity type (from a user perspective, not sure about the internals).",
      "number": 2733,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:17.203Z"
    },
    {
      "summary": "Add GrpcMessageTooLarge as a failure_reason for workflow task failed metric in the Java SDK to better track and diagnose gRPC message size limit violations.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-handler",
        "grpc-client"
      ],
      "concepts": [
        "failure-tracking",
        "gRPC-limits",
        "observability",
        "message-size",
        "diagnostics"
      ],
      "severity": "medium",
      "userImpact": "Users can better monitor and troubleshoot workflow task failures caused by exceeding gRPC message size limits.",
      "rootCause": null,
      "proposedFix": "Add GrpcMessageTooLarge as a recognized failure_reason value in the workflow task failed metric.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing the feature to track GrpcMessageTooLarge failures in metrics.",
      "related": [
        695
      ],
      "keyQuote": null,
      "number": 2732,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:59.331Z"
    },
    {
      "summary": "User reported an internal panic error (\"Panic! This is a bug!\") when starting a workflow in Java SDK v1.23.0. The issue was closed as stale when the user did not respond to a request to reproduce on the latest version.",
      "category": "question",
      "subcategory": "workflow-execution",
      "apis": [
        "startWorkflow",
        "WorkflowClient"
      ],
      "components": [
        "WorkflowStubImpl",
        "WorkflowClient",
        "WorkflowInvocationHandler"
      ],
      "concepts": [
        "workflow-start",
        "error-handling",
        "version-compatibility",
        "exception-wrapping",
        "gRPC-error"
      ],
      "severity": "medium",
      "userImpact": "Users starting workflows encounter an internal panic error that prevents workflow execution.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Closed due to no response when asked to reproduce on latest version (v1.32.0). Issue involved very old SDK version (v1.23.0).",
      "related": [],
      "keyQuote": "Java SDK v1.23.0 is very old, can you produce this bug on the latest release v1.32.0?",
      "number": 2730,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:03.555Z"
    },
    {
      "summary": "ScheduleRange constructor has a duplicate validation check for the step parameter instead of checking the end parameter. The code checks step twice when it should validate that end is within valid bounds.",
      "category": "bug",
      "subcategory": "schedule-validation",
      "apis": [
        "ScheduleRange"
      ],
      "components": [
        "schedule",
        "validation",
        "preconditions"
      ],
      "concepts": [
        "input-validation",
        "typo",
        "parameter-checking",
        "precondition",
        "bounds-checking"
      ],
      "severity": "low",
      "userImpact": "Users creating ScheduleRange objects with invalid end values may not receive appropriate validation errors due to the missing check.",
      "rootCause": "Typo in validation logic: step parameter is checked twice instead of checking both step and end parameters.",
      "proposedFix": "Replace the second step >= 0 check with end >= 0 check in the Preconditions.checkState() call.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Why do we need to check step twice?",
      "number": 2728,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:17:01.612Z"
    },
    {
      "summary": "Allow users to override the Worker Deployment Version when invoking a Child Workflow, similar to how it works when creating a Workflow from a client. This is needed for pre-deployment testing scenarios.",
      "category": "feature",
      "subcategory": "child-workflows",
      "apis": [
        "ChildWorkflowOptions",
        "StartChildWorkflowExecution"
      ],
      "components": [
        "child-workflow-execution",
        "workflow-versioning",
        "deployment-options"
      ],
      "concepts": [
        "versioning",
        "deployment",
        "child-workflows",
        "testing",
        "override",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test pre-deployment scenarios with child workflows without the ability to override the target deployment version, limiting their testing capabilities.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users want to override the target version on a workflow, especially when doing pre-deployment testing.",
      "number": 2726,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:44.734Z"
    },
    {
      "summary": "Request to add a Spring Boot configuration option allowing applications to start even when Temporal server is unavailable. Currently the application fails to start if it cannot connect to Temporal, but for some applications Temporal is not a hard dependency.",
      "category": "feature",
      "subcategory": "spring-boot-starter",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "worker-initialization",
        "connection-management"
      ],
      "concepts": [
        "startup-behavior",
        "optional-dependency",
        "connection-failure",
        "graceful-degradation",
        "application-availability"
      ],
      "severity": "medium",
      "userImpact": "Applications that use Temporal as an optional component cannot start when the Temporal server is unavailable, preventing them from operating in degraded mode.",
      "rootCause": "Spring Boot starter currently treats Temporal connectivity as a mandatory initialization requirement during application startup.",
      "proposedFix": "Add a configuration option to allow Spring application startup to proceed even when Temporal is unavailable, possibly with conditional bean scanning based on Temporal availability.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal is _Not_ a hard dependency for some applications to remain available, this is preventing my application from starting if temporal is unavailable.",
      "number": 2724,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:46.808Z"
    },
    {
      "summary": "Implement worker heartbeating in Java SDK through a new background nexus worker, based on the design from Rust SDK core.",
      "category": "feature",
      "subcategory": "worker-heartbeating",
      "apis": [],
      "components": [
        "worker",
        "nexus",
        "background-worker"
      ],
      "concepts": [
        "heartbeating",
        "worker-health",
        "background-processing",
        "nexus-integration"
      ],
      "severity": "medium",
      "userImpact": "Enables Java SDK to maintain worker health through periodic heartbeats, improving reliability and observability of long-running workflows.",
      "rootCause": null,
      "proposedFix": "Design and implement a Java version of the Rust SDK core worker heartbeating feature (PRs #953 and #1038), using a background nexus worker for heartbeat transmission.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Implement worker heartbeating, which is sent via a new background nexus worker.",
      "number": 2716,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:47.809Z"
    },
    {
      "summary": "The file path in the envconfig ClientConfig.java needs to be changed to use 'temporalio' as the directory instead of the current incorrect path.",
      "category": "bug",
      "subcategory": "configuration",
      "apis": [],
      "components": [
        "envconfig",
        "ClientConfig"
      ],
      "concepts": [
        "file-path",
        "configuration",
        "directory-structure"
      ],
      "severity": "low",
      "userImpact": "Users may encounter incorrect file path resolution when using the SDK Java envconfig module.",
      "rootCause": "Improper directory path specification in the envconfig ClientConfig class.",
      "proposedFix": "Change the directory path to 'temporalio' in the referenced file.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The file path was corrected to use the 'temporalio' directory.",
      "related": [],
      "keyQuote": "needs to be changed to have the dir be `temporalio`",
      "number": 2714,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:31.079Z"
    },
    {
      "summary": "RPCRetryOptions class duplicates error messages for multiple properties, making it hard to identify which property is misconfigured. Request to update error messages to be unique for each property.",
      "category": "other",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "RpcRetryOptions",
        "serviceclient"
      ],
      "concepts": [
        "error-messaging",
        "configuration-validation",
        "user-experience",
        "debugging",
        "properties"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily identify which RPC retry property is misconfigured when errors occur due to duplicate error messages.",
      "rootCause": "Duplicated error message strings in RPCRetryOptions for different validation scenarios",
      "proposedFix": "Update the error messages in RPCRetryOptions to be unique for each property",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Error messages were updated to be unique for each property in RPCRetryOptions",
      "related": [],
      "keyQuote": "This duplication makes it difficult to determine which property is misconfigured when the error occurs",
      "number": 2707,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:32.897Z"
    },
    {
      "summary": "Java SDK defaults task failure cause to WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED instead of WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE like Go SDK does. This should be changed to match Go SDK behavior for consistency, especially for user exceptions.",
      "category": "feature",
      "subcategory": "workflow-task-failure",
      "apis": [
        "RespondWorkflowTaskFailedRequest"
      ],
      "components": [
        "workflow-task-executor",
        "error-handling",
        "task-failure-processor"
      ],
      "concepts": [
        "task-failure",
        "error-cause",
        "worker-exception",
        "sdk-consistency",
        "failure-classification"
      ],
      "severity": "medium",
      "userImpact": "Users see incorrect or unspecified failure causes in workflow task failures instead of clear identification of unhandled worker exceptions.",
      "rootCause": "Java SDK defaults RespondWorkflowTaskFailedRequest.cause to WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED instead of WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE",
      "proposedFix": "Change default cause to WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE for user exceptions, matching Go SDK behavior",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Default task failure cause changed to match Go SDK behavior for consistency",
      "related": [
        1041
      ],
      "keyQuote": "we default `RespondWorkflowTaskFailedRequest.cause` to `WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED`. This is unlike Go SDKs that defaults task failures to `WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE`",
      "number": 2705,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:33.200Z"
    },
    {
      "summary": "Implement a plugin system for the Java SDK to enable users to self-serve creating integrations with Temporal Workflows, following the pattern already established in the Python SDK.",
      "category": "feature",
      "subcategory": "plugin-system",
      "apis": [],
      "components": [
        "plugin-system",
        "sdk-core",
        "integration-framework"
      ],
      "concepts": [
        "plugin-architecture",
        "extensibility",
        "self-service-integration",
        "user-customization",
        "cross-sdk-feature-parity"
      ],
      "severity": "medium",
      "userImpact": "Users can create custom integrations with Temporal Workflows without modifying core SDK code, enabling broader ecosystem adoption.",
      "rootCause": null,
      "proposedFix": "Implement plugins following the Python SDK's plugin system design pattern.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Plugin system was implemented in the Java SDK following the Python SDK pattern",
      "related": [],
      "keyQuote": "Implement Plugins so that users can self-serve creating integrations with Temporal Workflows. This is done in Python and we can copy.",
      "number": 2703,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:16.660Z"
    },
    {
      "summary": "Side effect markers in the UI lack identifiable information, making it difficult to distinguish between multiple side effects in quick succession. The request is to add static summary support for side effects and mutable side effects, similar to how activities and local activities display summaries.",
      "category": "feature",
      "subcategory": "ui-side-effects",
      "apis": [],
      "components": [
        "side-effect-marker",
        "ui-display",
        "workflow-execution"
      ],
      "concepts": [
        "side-effects",
        "mutable-side-effects",
        "ui-identifiability",
        "marker-display",
        "workflow-visibility"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily distinguish between multiple side effects in the UI without clicking into individual items, reducing workflow debugging efficiency.",
      "rootCause": null,
      "proposedFix": "Implement static summary support for side effect and mutable side effect markers to display identifiable information in the UI.",
      "workaround": "Click into specific side effect items to identify them.",
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to add static summary support for side effects and mutable side effects.",
      "related": [
        2076
      ],
      "keyQuote": "Support static summary for these items, then UI can be changed to display their summaries, similar to activities and local activities.",
      "number": 2702,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:19.138Z"
    },
    {
      "summary": "Port metrics improvement from sdk-core to Java SDK where sticky task queue client metrics should use the normal task queue name instead of a separate identifier for consistency and clarity.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "task-queue",
        "sticky-task-queue"
      ],
      "concepts": [
        "metrics",
        "task-queue-naming",
        "client-metrics",
        "sticky-queue",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Users monitoring sticky task queue metrics will see clearer, more consistent metric names aligned with core SDK behavior.",
      "rootCause": null,
      "proposedFix": "Apply the same metrics naming improvement from sdk-core PR #1039 to the Java SDK implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Enhancement implemented by porting the sticky task queue metrics naming improvement from sdk-core to Java SDK.",
      "related": [],
      "keyQuote": "Port https://github.com/temporalio/sdk-core/pull/1039",
      "number": 2689,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:19.457Z"
    },
    {
      "summary": "User needs guidance on registering a custom ContextPropagator across multiple Temporal namespaces in a Spring Boot application. Currently works for a single namespace but unclear how to apply it to multiple namespaces configured via application.yaml.",
      "category": "question",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkflowClientOptions",
        "ContextPropagator"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "workflow-client",
        "context-propagator"
      ],
      "concepts": [
        "multi-namespace",
        "mdc-propagation",
        "context-propagation",
        "spring-boot-configuration",
        "customization"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily propagate context (like tenant_id) across multiple namespaces in Spring Boot, limiting multi-tenant Temporal deployments.",
      "rootCause": null,
      "proposedFix": "Configure a different customizer per namespace to set the ContextPropagator, leveraging the Temporal Spring Boot autoconfiguration customization mechanism.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Community response provided solution: use per-namespace customizers to configure ContextPropagator for each namespace separately.",
      "related": [],
      "keyQuote": "You can configure a different customizer per namespace. So in your customizer you can set a ContextPropagator",
      "number": 2687,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:04.366Z"
    },
    {
      "summary": "Spring Boot application fails to start when Temporal server is unreachable or under heavy load, throwing DEADLINE_EXCEEDED error during worker initialization. User expects graceful degradation with health check reporting instead of blocking startup.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkflowService",
        "SystemInfo"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "worker-factory",
        "system-info-interceptor",
        "grpc-client"
      ],
      "concepts": [
        "startup-blocking",
        "deadline-exceeded",
        "connection-failure",
        "health-check",
        "graceful-degradation",
        "timeout",
        "server-overload"
      ],
      "severity": "high",
      "userImpact": "Spring Boot applications cannot start if Temporal server is unavailable or overloaded, preventing deployments during peak load scenarios and preventing health checks from reporting connection issues.",
      "rootCause": "WorkerFactory.start() synchronously calls SystemInfoInterceptor which makes a blocking gRPC call to getSystemInfo() during application startup, with no timeout configuration flexibility or fallback mechanism.",
      "proposedFix": "Make worker startup non-blocking or add configuration property to enable graceful startup with connection issues reported via health checks instead of failing application startup.",
      "workaround": "Use manual start instead of auto-configuration and configure WorkflowServiceStubsOptions.Builder.setSystemInfoTimeout() to handle timeouts.",
      "resolution": "wontfix",
      "resolutionDetails": "Core issue is server overload, not SDK behavior. Workaround provided via manual configuration of SystemInfoTimeout.",
      "related": [
        2466
      ],
      "keyQuote": "The root problem is your Temporal server is overloaded and needs to be scaled up, taking over 10s for a simple RPC is too long",
      "number": 2680,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:02.571Z"
    },
    {
      "summary": "User reported that WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE does not throw WorkflowExecutionAlreadyStarted when executing a workflow with a duplicate ID, but the issue was clarified as expected behavior: the SDK attaches to existing workflows instead of throwing exceptions when using execute().",
      "category": "docs",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowClient.newWorkflowStub",
        "WorkflowClient.execute",
        "WorkflowClient.start",
        "WorkflowOptions",
        "WorkflowIdReusePolicy"
      ],
      "components": [
        "workflow-client",
        "workflow-invocation-handler",
        "workflow-execution"
      ],
      "concepts": [
        "workflow-reuse-policy",
        "duplicate-detection",
        "workflow-attachment",
        "exception-handling",
        "api-behavior"
      ],
      "severity": "low",
      "userImpact": "Users may be confused about exception behavior when reusing workflow IDs, as the SDK attaches to existing executions rather than throwing exceptions as the javadoc suggests.",
      "rootCause": "Javadoc and exception handling behavior were out of sync; the SDK design intentionally attaches to existing workflows on reuse rather than throwing exceptions, but this was not clearly documented.",
      "proposedFix": null,
      "workaround": "Use WorkflowClient.start() instead of execute() if you want WorkflowExecutionAlreadyStarted to be thrown on duplicate workflow IDs.",
      "resolution": "invalid",
      "resolutionDetails": "Maintainer clarified this is expected behavior by design; the SDK attaches to existing workflow executions instead of throwing exceptions when using execute(). Users should use start() if exceptions are desired.",
      "related": [],
      "keyQuote": "This behavior is by design. When the workflow is started by calling the stub's workflow method, or by calling WorkflowClient::execute, it waits for the result of the workflow... it will attach to the existing workflow execution",
      "number": 2679,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:16:04.839Z"
    },
    {
      "summary": "Temporal Java SDK is using an older version of gRPC (grpc-netty-shaded 1.58.x) that contains known vulnerabilities. While the vulnerability (CVE-2025-55163) doesn't directly impact the SDK's client-only usage, users want guidance on upgrading to the latest gRPC version (1.75.0+) and understanding compatibility.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "grpc-netty-shaded",
        "dependency-management",
        "testing-framework",
        "build-system"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-upgrade",
        "version-compatibility",
        "gRPC",
        "dependency-conflict",
        "transitive-dependencies",
        "vulnerability-scanning"
      ],
      "severity": "medium",
      "userImpact": "Users face security scanning failures and vulnerability reports due to outdated gRPC dependencies, even though the specific vulnerability doesn't affect the Java SDK's client-only usage.",
      "rootCause": "Temporal Java SDK pins an older version of gRPC (1.58.x) through grpc-netty-shaded, and when users upgrade to newer gRPC versions, they encounter classpath conflicts in the testing framework (temporal-testing) which has internal dependencies on older gRPC classes.",
      "proposedFix": "Update gRPC dependency management to the latest version (1.75.0+) and ensure temporal-testing module is compatible with newer gRPC APIs, particularly AbstractServerImplBuilder and related internal classes.",
      "workaround": "Users can use dependencyManagement with scope=import to override the gRPC version: add grpc-bom v1.76.0+ in dependencyManagement with scope=import to ensure consistent gRPC versions across transitive dependencies.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The Java SDK is only a client... and the Java SDK is fully compatible with the latest gRPC.",
      "number": 2676,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:47.704Z"
    },
    {
      "summary": "TestWorkflowExtension throws an IllegalStateException when using external service mode and tests fail, because getDiagnostics is called on the external service which doesn't support it.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowExtension",
        "TestWorkflowEnvironmentInternal",
        "external-service"
      ],
      "concepts": [
        "test-environment",
        "external-service",
        "diagnostics",
        "error-handling",
        "test-failure"
      ],
      "severity": "high",
      "userImpact": "Tests using external service fail with an unrelated IllegalStateException instead of showing the actual test failure.",
      "rootCause": "TestWorkflowEnvironmentInternal.getDiagnostics() is called unconditionally but throws an exception when running with external service, which doesn't support diagnostics.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "java.lang.IllegalStateException: getDiagnostics is not supported with the external service",
      "number": 2674,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:46.793Z"
    },
    {
      "summary": "Request for native OpenTelemetry interceptors in the Java SDK to replace the deprecated OpenTracing-based integration. The current approach using OpenTelemetry shims with OpenTracing has limitations with baggage propagation and is not recommended by OpenTelemetry documentation.",
      "category": "feature",
      "subcategory": "tracing-observability",
      "apis": [],
      "components": [
        "tracing-interceptors",
        "opentelemetry-integration",
        "observability"
      ],
      "concepts": [
        "opentelemetry",
        "baggage-propagation",
        "w3c-tracecontext",
        "span-processor",
        "instrumentation",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users need a native OpenTelemetry integration path instead of relying on deprecated OpenTracing shims and compatibility layers.",
      "rootCause": "OpenTracing is in maintenance mode and the OpenTelemetry shim approach has documented limitations with baggage propagation in mixed environments.",
      "proposedFix": "Create a new temporal-opentelemetry module providing native OpenTelemetry integration similar to the existing temporal-opentracing module, with full W3C TraceContext compatibility.",
      "workaround": "Continue using temporal-opentracing with OpenTelemetry compatibility layer, or create custom temporal interceptors for direct OpenTelemetry tracing.",
      "resolution": "wontfix",
      "resolutionDetails": "Core Temporal team indicated this needs to be designed across SDKs and should be done by core members, not external contributors. Users encouraged to share implementations on Temporal code exchange.",
      "related": [],
      "keyQuote": "The exact standard still needs to be designed across our various SDKs so this is something that would need to be done by a core Temporal member.",
      "number": 2671,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:46.624Z"
    },
    {
      "summary": "TestWorkflowEnvironment#sleep hangs indefinitely during test execution due to a deadlock between the main thread and workflow threads when calling unlockTimeSkippingWithSleep on the test server.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment"
      ],
      "components": [
        "test-service",
        "workflow-thread-scheduler",
        "grpc-stub"
      ],
      "concepts": [
        "deadlock",
        "time-skipping",
        "test-environment",
        "thread-synchronization",
        "blocking-call"
      ],
      "severity": "high",
      "userImpact": "Tests using TestWorkflowEnvironment#sleep hang indefinitely, preventing test execution and blocking developers from running their test suites.",
      "rootCause": "A deadlock occurs between the main thread blocked in ClientCalls.blockingUnaryCall for unlockTimeSkippingWithSleep and workflow threads waiting in WorkflowThreadScheduler.yieldLocked, causing the grpc executor thread to block waiting on a CompletableFuture that never completes.",
      "proposedFix": null,
      "workaround": null,
      "related": [
        2642
      ],
      "keyQuote": "Under certain execution path io.temporal.testing.TestWorkflowEnvironment#sleep hangs indefinitely.",
      "resolution": null,
      "resolutionDetails": null,
      "number": 2670,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:27.609Z"
    },
    {
      "summary": "Test server should automatically set metadata `type` on search attribute payloads, matching the behavior of the production Temporal server.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "search-attributes",
        "metadata"
      ],
      "concepts": [
        "metadata",
        "search-attributes",
        "type-information",
        "server-behavior",
        "test-parity"
      ],
      "severity": "medium",
      "userImpact": "Test server behavior diverges from production server, potentially causing tests to miss metadata-related issues.",
      "rootCause": "Test server does not automatically set the `type` metadata field on search attribute payloads like the production server does.",
      "proposedFix": "Implement automatic `type` metadata setting in test server to match production server behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test server was updated to set metadata `type` for search attribute payloads, achieving parity with production server behavior.",
      "related": [],
      "keyQuote": "Temporal server sets `type` metadata on search attribute payloads even if user doesn't set it, test server should do the same.",
      "number": 2666,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:24.876Z"
    },
    {
      "summary": "User requests support for kotlinx.serialization in the Java SDK's PayloadConverter interface. The issue is that kotlinx.serialization requires compile-time type information (reified generics) that the current interface cannot provide, making it impossible to create a custom adapter while avoiding silent serialization errors.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [
        "PayloadConverter",
        "DataConverter"
      ],
      "components": [
        "payload-converter",
        "data-converter",
        "serialization"
      ],
      "concepts": [
        "serialization",
        "type-information",
        "reified-generics",
        "runtime-type-erasure",
        "kotlinx-serialization",
        "kotlin-interop"
      ],
      "severity": "medium",
      "userImpact": "Kotlin developers cannot reliably use kotlinx.serialization with Temporal workflows/activities, leading to either serialization failures or silent incorrect serialization that fails only during deserialization with unrecoverable errors.",
      "rootCause": "The PayloadConverter interface uses runtime type erasure which is incompatible with kotlinx.serialization's requirement for compile-time type information via reified generics. The Java SDK cannot access the type information needed at serialization time.",
      "proposedFix": "Enhance the PayloadConverter interface to provide compile-time type information, potentially through a redesigned API that works with Kotlin's serialization model, or create a Kotlin SDK that natively supports reified generics.",
      "workaround": "Developers can manually convert serializable objects to plain blob strings and deserialize them manually on the receiving side, though this is not ideal.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers declined to extend the Java SDK for Kotlin-specific features, recommending a dedicated Kotlin SDK if such support is needed. Closed as the Java library cannot use Kotlin-specific features like reified generics.",
      "related": [],
      "keyQuote": "The same object will result in different payloads as kotlin relies on the type information available to encode/decode.",
      "number": 2665,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:31.401Z"
    },
    {
      "summary": "The test server should populate `suggest_continue_as_new` and `history_size_bytes` fields in WorkflowTaskStartedEventAttributes to better match production server behavior and enable more comprehensive testing.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [
        "WorkflowTaskStartedEventAttributes"
      ],
      "components": [
        "test-server",
        "workflow-task-handler",
        "event-attributes"
      ],
      "concepts": [
        "continue-as-new",
        "history-size",
        "task-started-event",
        "server-defaults",
        "testing"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows cannot verify behavior that depends on continue-as-new suggestions or history size constraints, limiting test coverage.",
      "rootCause": null,
      "proposedFix": "Populate `WorkflowTaskStartedEventAttributes.suggest_continue_as_new` with Temporal server defaults and `history_size_bytes` with calculated values in test server.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Populate `WorkflowTaskStartedEventAttributes.suggest_continue_as_new` and `WorkflowTaskStartedEventAttributes.history_size_bytes` on the test server.",
      "number": 2661,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:10.526Z"
    },
    {
      "summary": "The temporal-testing library does not propagate headers for signals through interceptors, unlike the production Temporal server environment. When a WorkflowClientInterceptor sets headers on outgoing signals, these headers are null in the corresponding WorkflowInboundCallsInterceptor.handleSignal method during testing.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowClientInterceptor",
        "WorkflowClientCallsInterceptor",
        "WorkflowInboundCallsInterceptor",
        "signal"
      ],
      "components": [
        "temporal-testing",
        "interceptors",
        "signal-handling",
        "header-propagation"
      ],
      "concepts": [
        "headers",
        "interceptors",
        "signals",
        "test-environment",
        "client-server-compatibility",
        "metadata-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test signal header propagation with temporal-testing, creating a gap between test and production behavior that requires running a real server to verify interceptor logic.",
      "rootCause": "The temporal-testing library does not copy headers from outgoing signal requests to the inbound signal handler, unlike the production server.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the bug was resolved in a subsequent release.",
      "related": [],
      "keyQuote": "The temporal-testing library should be as close as possible to a real environment, and the header should be propagated.",
      "number": 2659,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:12.951Z"
    },
    {
      "summary": "Request to expose Temporal Nexus operation info to operation authors, allowing them to access context about the operations they are implementing.",
      "category": "feature",
      "subcategory": "nexus-operations",
      "apis": [],
      "components": [
        "nexus-operations",
        "operation-handler"
      ],
      "concepts": [
        "nexus",
        "operation-context",
        "operation-info",
        "handler-context"
      ],
      "severity": "medium",
      "userImpact": "Nexus operation authors cannot currently access operation metadata and context information needed for implementing operations.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation was completed to expose Nexus operation info to operation authors.",
      "related": [
        674
      ],
      "keyQuote": "Expose Temporal Nexus operation info to Temporal Nexus operation authors",
      "number": 2657,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:15:12.461Z"
    },
    {
      "summary": "Request for a Java annotation in Spring Boot to specify which namespace beans (interceptors/customizers) belong to in multi-namespace setups, providing a more idiomatic alternative to bean name prefixing.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-sdk",
        "interceptors",
        "customizers",
        "namespace-configuration"
      ],
      "concepts": [
        "multi-namespace",
        "dependency-injection",
        "annotations",
        "bean-scoping",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users currently must use bean name prefixes to assign interceptors/customizers to specific namespaces, which is less idiomatic than using a Java annotation.",
      "rootCause": null,
      "proposedFix": "Add a Java annotation or interface to specify which namespace a bean belongs to, providing a more idiomatic Spring Boot approach.",
      "workaround": "Users can continue to specify namespace assignment by prefixing bean names with the appropriate namespace.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2638
      ],
      "keyQuote": "A Java annotation or interface may be more idiomatic in Springboot",
      "number": 2656,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:55.336Z"
    },
    {
      "summary": "The testing server's continue-as-new implementation doesn't propagate memo and search attributes from the ContinueAsNewWorkflowExecutionCommandAttributes, unlike the production Temporal server which correctly carries these forward to the new workflow execution.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "test-server",
        "workflow-service",
        "continue-as-new-handler"
      ],
      "concepts": [
        "continue-as-new",
        "memo",
        "search-attributes",
        "state-propagation",
        "test-parity"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows that rely on continue-as-new with memo or search attributes will encounter unexpected behavior differences between testing and production environments.",
      "rootCause": "The TestWorkflowService.continueAsNewWorkflowExecution() method constructs the start request without extracting memo and search attributes from the ContinueAsNewWorkflowExecutionCommandAttributes.",
      "proposedFix": "Extract memo and search attributes from ContinueAsNewWorkflowExecutionCommandAttributes and include them in the start request construction.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "the memo and search attributes in the command are dropped",
      "number": 2655,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:53.855Z"
    },
    {
      "summary": "Intermittent UNKNOWN gRPC error occurs when calling describe on workflows in TestWorkflowEnvironment, caused by a NullPointerException when processing pending child execution info during workflow description.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [
        "DescribeWorkflowExecution"
      ],
      "components": [
        "test-server",
        "workflow-state",
        "child-workflow-management"
      ],
      "concepts": [
        "race-condition",
        "null-pointer",
        "child-workflows",
        "test-environment",
        "concurrency"
      ],
      "severity": "high",
      "userImpact": "Tests using TestWorkflowEnvironment experience intermittent failures when describing workflows with child workflows, making test suites unreliable.",
      "rootCause": "Race condition in TestWorkflowMutableStateImpl.constructPendingChildExecutionInfo where data.execution can be null when processing child workflow information during describeWorkflowExecution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified as a null pointer exception in child execution processing; likely fixed by adding null checks or synchronization.",
      "related": [],
      "keyQuote": "Cannot invoke \"io.temporal.api.common.v1.WorkflowExecution.getWorkflowId()\" because \"data.execution\" is null",
      "number": 2652,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:57.894Z"
    },
    {
      "summary": "Request to add an overload for WorkflowStub.cancel() that targets the exact workflow execution used to create the stub, rather than the latest workflow in the execution chain.",
      "category": "feature",
      "subcategory": "workflow-control",
      "apis": [
        "WorkflowStub.cancel"
      ],
      "components": [
        "workflow-stub",
        "cancellation",
        "execution-targeting"
      ],
      "concepts": [
        "workflow-execution",
        "execution-chain",
        "continue-as-new",
        "exact-targeting",
        "api-overload"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably cancel a specific workflow execution instance, forcing them to use the latest workflow ID instead of the exact execution they created the stub with.",
      "rootCause": null,
      "proposedFix": "Add an overload for WorkflowStub.cancel() that targets the exact workflow execution instead of the latest workflow in the execution chain, with appropriate warnings about flakiness with continue-as-new.",
      "workaround": "Potentially set first_execution_run_id (needs verification for cancel operations).",
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented as an API overload for precise execution targeting.",
      "related": [],
      "keyQuote": "Add overload for `WorkflowStub.cancel` to target exact workflow execution instead of the latest workflow ID/execution chain",
      "number": 2651,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:37.562Z"
    },
    {
      "summary": "Add tests to verify that custom slot supplier implementations properly populate all required slot info fields. Related to feature consistency validation across the Java SDK.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "slot-supplier",
        "test-suite",
        "worker"
      ],
      "concepts": [
        "testing",
        "slot-management",
        "custom-implementation",
        "validation",
        "fields"
      ],
      "severity": "low",
      "userImpact": "Ensures custom slot supplier implementations are properly validated, preventing runtime issues from incomplete slot info.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        672
      ],
      "keyQuote": "Ensure tests exist to confirm custom slot supplier slot info has proper fields",
      "number": 2650,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:34.803Z"
    },
    {
      "summary": "User reported an error where activities appeared unregistered when using RetryOptions with maxAttempts(1), but investigation revealed the actual issue was multiple workers on the same task queue with different activities registered, not a bug with RetryOptions.",
      "category": "question",
      "subcategory": "activity-registration",
      "apis": [
        "Workflow.newActivityStub",
        "ActivityOptions",
        "RetryOptions"
      ],
      "components": [
        "worker",
        "activity-stub",
        "retry-policy",
        "task-queue"
      ],
      "concepts": [
        "activity-registration",
        "retry-configuration",
        "task-queue",
        "worker-configuration",
        "activity-discovery",
        "multi-worker",
        "error-handling"
      ],
      "severity": "low",
      "userImpact": "User mistakenly believed RetryOptions caused activity registration failures when the real issue was improper worker configuration with multiple workers sharing a task queue.",
      "rootCause": "Multiple workers listening on the same task queue with different activities registered. The InventoryWorker and PaymentWorker both listened on ORDER_TASK_QUEUE but only had their own activities registered.",
      "proposedFix": "Use different task queues for workers with different activities, or ensure all workers on the same task queue register the same activities.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Marked as invalid after investigation revealed this was a user configuration issue, not a bug with RetryOptions or the SDK.",
      "related": [],
      "keyQuote": "In Temporal workers listening on the same task queue need to have the same activities registered, or they need to use different task queues.",
      "number": 2647,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:40.485Z"
    },
    {
      "summary": "The `workflow_task_queue_poll_succeed` metric is not being emitted when poller autoscaling is enabled in the Java SDK. This metric should be reported regardless of autoscaling configuration.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "poller",
        "autoscaling",
        "metrics"
      ],
      "concepts": [
        "metrics",
        "observability",
        "autoscaling",
        "polling",
        "task-queue"
      ],
      "severity": "medium",
      "userImpact": "Users monitoring workflow task queue polling behavior cannot properly observe poll success rates when autoscaling is enabled, affecting observability and debugging.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "`workflow_task_queue_poll_succeed` is not emitted when poller autoscaling is on",
      "number": 2644,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:20.055Z"
    },
    {
      "summary": "Request to reclassify benign application errors in OpenTelemetry metrics to prevent them from appearing as error signals. This feature request is based on a similar Python SDK issue.",
      "category": "feature",
      "subcategory": "observability",
      "apis": [],
      "components": [
        "opentelemetry",
        "metrics",
        "error-handling"
      ],
      "concepts": [
        "observability",
        "error-classification",
        "signal-noise",
        "application-errors",
        "telemetry"
      ],
      "severity": "medium",
      "userImpact": "Users experience noise in OpenTelemetry error signals from benign application errors that don't represent actual system failures.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to reclassify benign application errors in OpenTelemetry metrics.",
      "related": [
        1041
      ],
      "keyQuote": "Reclassify Benign Application errors in OpenTelemetry",
      "number": 2643,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:22.375Z"
    },
    {
      "summary": "TestWorkflowEnvironment.sleep() incorrectly uses real time instead of virtual time when executed after a test that uses child workflows, causing tests to hang unexpectedly. Virtual time works correctly when the test runs in isolation.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment",
        "Workflow.newChildWorkflowStub",
        "Workflow.getWorkflowExecution",
        "setStartDelay"
      ],
      "components": [
        "test-environment",
        "virtual-time",
        "child-workflow",
        "test-isolation"
      ],
      "concepts": [
        "virtual-time",
        "test-execution",
        "child-workflow",
        "time-advancement",
        "test-isolation",
        "state-persistence"
      ],
      "severity": "high",
      "userImpact": "Tests using TestWorkflowEnvironment.sleep() hang with real-time delays instead of completing instantly, breaking test suite execution order dependency.",
      "rootCause": "Child workflow execution appears to switch TestWorkflowEnvironment from virtual time mode to real time mode, affecting subsequent tests in the same suite.",
      "proposedFix": null,
      "workaround": "Execute tests in isolation or reorder tests so child workflow tests run after sleep tests.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Looks like something in the child workflow test \"switches\" the TestWorkflowEnvironment from virtual time to real time.",
      "number": 2642,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:20.517Z"
    },
    {
      "summary": "Spring Boot starter non-standard bean resolution for TemporalOptionsCustomizer prevents multiple customizers per namespace and violates Spring conventions. Request to support ordered composition of customizers and namespace filtering.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "TemporalOptionsCustomizer",
        "AutoConfigurationUtils"
      ],
      "concepts": [
        "spring-conventions",
        "bean-precedence",
        "ordering",
        "namespace-configuration",
        "customizer-composition",
        "enterprise-integration"
      ],
      "severity": "high",
      "userImpact": "Enterprise users cannot extend Spring Boot starter behavior predictably or use multiple customizers per namespace, forcing workarounds like BeanPostProcessor.",
      "rootCause": "AutoConfigurationUtils.chooseTemporalCustomizerBean uses bean name resolution and findFirst semantics instead of Spring's standard List<T> composition and bean precedence/ordering conventions.",
      "proposedFix": "Add namespace filter method to TemporalOptionsCustomizer interface and accept List<TemporalOptionsCustomizer<T>> applying them in order instead of selecting single bean.",
      "workaround": "Implement custom BeanPostProcessor to register bean definitions for each namespace and handle customizer composition manually.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2117,
        2656
      ],
      "keyQuote": "Because the starter forces 1 customizer per-namespace, it would take away the freedom from our users to customize either of these options builders.",
      "number": 2638,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:03.927Z"
    },
    {
      "summary": "User encounters TypeAlreadyRegisteredException when registering multiple Activity implementations that inherit from a common interface with non-@ActivityMethod methods. The error occurs because the SDK treats the inherited method name as a duplicate activity type.",
      "category": "question",
      "subcategory": "activity-registration",
      "apis": [
        "registerActivitiesImplementations"
      ],
      "components": [
        "activity-handler",
        "worker",
        "activity-registration"
      ],
      "concepts": [
        "activity-interface",
        "method-inheritance",
        "type-registration",
        "duplicate-detection"
      ],
      "severity": "low",
      "userImpact": "Users cannot register multiple Activity implementations that share inherited non-annotated methods without encountering registration errors.",
      "rootCause": "The activity registration logic treats all inherited methods as activity types, causing name conflicts when multiple implementations inherit the same non-@ActivityMethod from a parent interface.",
      "proposedFix": "Use namePrefix in @ActivityInterface to make each activity type name unique and avoid conflicts from inherited methods.",
      "workaround": "Apply namePrefix parameter in @ActivityInterface annotations on each Activity interface to ensure unique activity type names.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers clarified this is expected behavior - duplicate activity methods cannot be registered. Users should use namePrefix as a solution.",
      "related": [],
      "keyQuote": "This is expected behaviour, duplicate activity methods cannot be registered. You can consider using namePrefix in ActivityInterface so each method has a unique activity type",
      "number": 2637,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:06.839Z"
    },
    {
      "summary": "Request to clarify the behavior and error messaging when a nexus operation cancellation fails, to improve developer understanding of failure modes.",
      "category": "other",
      "subcategory": "nexus-operation-cancellation",
      "apis": [],
      "components": [
        "nexus",
        "operation-handler",
        "cancellation"
      ],
      "concepts": [
        "cancellation",
        "error-handling",
        "nexus-operations",
        "failure-modes",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers will have clearer understanding of nexus operation cancellation failure scenarios and better error messages.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was marked as closed enhancement, indicating the clarification was addressed.",
      "related": [],
      "keyQuote": "Clarify nexus operation cancellation failure",
      "number": 2629,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:14:03.538Z"
    },
    {
      "summary": "Request to add plugin support to the Java SDK, as outlined in the cross-repository features issue #652. This would enable extensibility through a plugin architecture.",
      "category": "feature",
      "subcategory": "plugin-system",
      "apis": [],
      "components": [
        "plugin-framework",
        "sdk-core",
        "extension-system"
      ],
      "concepts": [
        "extensibility",
        "plugin-architecture",
        "modularity",
        "customization",
        "framework-integration"
      ],
      "severity": "medium",
      "userImpact": "Users would be able to extend SDK functionality through plugins without modifying core code.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        652
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/652",
      "number": 2626,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:46.658Z"
    },
    {
      "summary": "OpenTracingClientInterceptor does not propagate traces for the updateWithStart operation, resulting in empty header fields for the first workflow execution started event.",
      "category": "feature",
      "subcategory": "distributed-tracing",
      "apis": [
        "UpdateWithStart"
      ],
      "components": [
        "OpenTracingClientInterceptor",
        "workflow-execution"
      ],
      "concepts": [
        "tracing",
        "trace-propagation",
        "distributed-tracing",
        "interceptor",
        "updateWithStart",
        "workflow-events"
      ],
      "severity": "medium",
      "userImpact": "Users cannot trace updateWithStart operations, limiting observability and debugging capabilities for workflows using this API.",
      "rootCause": "OpenTracingClientInterceptor lacks implementation for the updateWithStart operation, leaving trace context unpropagated.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Traces are not propagated for the operation updateWithStart",
      "number": 2620,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:46.105Z"
    },
    {
      "summary": "Nexus handler incorrectly passes a completion callback even when no completion URL is provided, causing unnecessary or incorrect behavior.",
      "category": "bug",
      "subcategory": "nexus-handler",
      "apis": [],
      "components": [
        "nexus-handler",
        "callback-management"
      ],
      "concepts": [
        "completion-callback",
        "completion-url",
        "conditional-logic",
        "handler-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users implementing Nexus handlers may encounter unexpected callback behavior when no completion URL is configured.",
      "rootCause": "The handler implementation always passes a completion callback regardless of whether a completion URL exists.",
      "proposedFix": "Only pass a completion callback when a completion URL is actually provided.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was addressed by implementing conditional callback passing based on completion URL availability.",
      "related": [],
      "keyQuote": "In a Nexus handler only pass a completion callback if a completion URL is provided",
      "number": 2614,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:48.997Z"
    },
    {
      "summary": "Align the Nexus handler failure conversion logic in the Java SDK with the implementations in other Temporal SDKs to ensure consistent error handling behavior across all language implementations.",
      "category": "feature",
      "subcategory": "nexus-handler",
      "apis": [],
      "components": [
        "nexus",
        "handler",
        "error-handling"
      ],
      "concepts": [
        "failure-conversion",
        "error-consistency",
        "cross-sdk-alignment",
        "handler-execution"
      ],
      "severity": "medium",
      "userImpact": "Users experience inconsistent error handling behavior when using Nexus handlers across different SDK implementations.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Align Nexus handler failure conversion with other SDKs",
      "number": 2612,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:29.877Z"
    },
    {
      "summary": "The Spring Boot Autoconfigure README contains an invalid link in the Metrics section that redirects to an incorrect page. The team plans to move this documentation to the main docs.temporal.io site.",
      "category": "docs",
      "subcategory": "spring-boot-autoconfigure",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "readme"
      ],
      "concepts": [
        "documentation",
        "link-management",
        "external-reference",
        "redirect"
      ],
      "severity": "low",
      "userImpact": "Users following the Metrics documentation link in the Spring Boot Autoconfigure README encounter a broken/incorrect redirect.",
      "rootCause": "Documentation link points to a resource that no longer exists or has been moved.",
      "proposedFix": "Remove documentation from README and add it to the main docs.temporal.io site.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation will be removed from README and migrated to docs.temporal.io",
      "related": [],
      "keyQuote": "We are going to be removing the documentation in the readme and adding it to our main docs https://docs.temporal.io/",
      "number": 2611,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:33.412Z"
    },
    {
      "summary": "Spring Boot Temporal starter version 1.30.1 fails to start the test server when multiple namespaces are configured, resulting in connection refused errors on port 7233. The same configuration works in version 1.29.0.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkflowClient"
      ],
      "components": [
        "spring-boot-starter",
        "test-server",
        "namespace-configuration",
        "grpc-connection"
      ],
      "concepts": [
        "namespace",
        "configuration",
        "spring-boot",
        "test-server",
        "connection",
        "migration",
        "regression"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to Spring Boot starter 1.30.1 with namespace configuration cannot run tests, blocking migration from 1.29.0.",
      "rootCause": "The test server is not being started when namespaces are configured in Spring Boot starter 1.30.1, suggesting a regression in namespace configuration handling.",
      "proposedFix": null,
      "workaround": "Remove namespace configuration and use only the default namespace configuration to allow tests to run.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Looks like the gRPC server is not started when you define namespaces, but it is a bit hard to figure out why.",
      "number": 2610,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:33.024Z"
    },
    {
      "summary": "NonRootBeanPostProcessor eagerly initializes meter-registry before customizers are applied, causing custom tags and other customizations to be missing from metrics. This was a Spring Boot integration issue that prevented MeterRegistryCustomizer beans from being properly applied.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "meter-registry",
        "NonRootBeanPostProcessor",
        "spring-boot-autoconfigure"
      ],
      "concepts": [
        "bean-post-processor",
        "eager-initialization",
        "spring-beans",
        "customization",
        "metrics-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users using Spring Boot with custom meter-registry customizers would find their custom tags and configurations not applied to metrics.",
      "rootCause": "NonRootBeanPostProcessor requests meter-registry from application context during bean-post-processor creation stage, which occurs before customizers are registered.",
      "proposedFix": "Ensure meter-registry initialization is deferred until after all customizers are available to the application context.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was fixed in version 1.30.0",
      "related": [],
      "keyQuote": "customizers are not applied as NonRootBeanPostProcessor requests meter-registry from application context at bean-post-processor creation stage",
      "number": 2608,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:13.476Z"
    },
    {
      "summary": "Race condition in TestWorkflowMutableStateImpl where a TIMER_FIRED event removes a timer in the same workflow task, causing a subsequent CancelTimer command to fail with an invalid_argument exception. This prevents the workflow from completing and making progress.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "workflow-mutable-state",
        "timer-management",
        "history-builder"
      ],
      "concepts": [
        "race-condition",
        "timer-lifecycle",
        "workflow-task",
        "command-processing",
        "state-synchronization"
      ],
      "severity": "high",
      "userImpact": "Users writing tests with the Java test server experience workflow execution failures and may not be able to complete tests reliably when timer cancellations race with timer fired events.",
      "rootCause": "When a workflow task receives both a TIMER_FIRED event and a CancelTimer command for the same timer, the timer is removed by the TIMER_FIRED handler before the CancelTimer handler executes, causing processCancelTimer to throw an exception when it checks for a null timer without considering this race condition.",
      "proposedFix": "Check if the timer was removed by a TIMER_FIRED event in the same workflow task before throwing an exception in processCancelTimer, allowing graceful handling of this race condition.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I think on cancel command, we should only throw if we check first that if timer is null if it was actually removed in same workflow task.",
      "number": 2606,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:16.588Z"
    },
    {
      "summary": "ApplicationFailure.Builder requires the Category field to be explicitly set, but this requirement is unexpected and creates friction for users creating application failures.",
      "category": "bug",
      "subcategory": "exception-handling",
      "apis": [
        "ApplicationFailure"
      ],
      "components": [
        "ApplicationFailure",
        "Builder",
        "exception-construction"
      ],
      "concepts": [
        "builder-pattern",
        "required-field",
        "API-design",
        "usability",
        "exception-creation"
      ],
      "severity": "low",
      "userImpact": "Users must always specify a Category when building ApplicationFailure objects, which adds unnecessary complexity to exception creation.",
      "rootCause": "ApplicationFailure.Builder enforces Category as a required field despite it potentially having sensible defaults.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The Category field requirement was likely made optional or given a default value in the Builder.",
      "related": [],
      "keyQuote": "ApplicationFailure.Builder requires Category be set",
      "number": 2601,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:13:10.977Z"
    },
    {
      "summary": "Request to allow overriding activity options (timeout, retry, etc.) on a per-call basis rather than being locked to the stub configuration. Currently requires creating a new stub for each different option set.",
      "category": "feature",
      "subcategory": "activity-options",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-stub",
        "options-configuration",
        "activity-executor"
      ],
      "concepts": [
        "option-override",
        "per-call-configuration",
        "activity-timeout",
        "activity-retry",
        "stub-reuse"
      ],
      "severity": "medium",
      "userImpact": "Users are forced to create multiple stubs to call the same activity with different options, reducing code reusability and adding complexity.",
      "rootCause": null,
      "proposedFix": "Add an API to support calling an activity method with an option override, allowing options to be specified at call time rather than stub creation time.",
      "workaround": "Create a new stub for each unique set of options needed.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I would like to call an activity method with specific options that are different from the options I used to create the stub.",
      "number": 2598,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:59.794Z"
    },
    {
      "summary": "User requests support for Kotlin 2.0 and newer versions of gRPC (1.62+), Netty (4.1.102+), and related dependencies. Currently, the SDK supports older versions of these libraries.",
      "category": "feature",
      "subcategory": "dependency-versions",
      "apis": [],
      "components": [
        "dependency-management",
        "build-configuration"
      ],
      "concepts": [
        "kotlin",
        "grpc",
        "netty",
        "dependency-upgrade",
        "version-compatibility",
        "coroutines"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use newer versions of Kotlin and gRPC libraries in their projects, limiting access to latest features and security updates.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "This issue was a duplicate of #2594, identified by the issue author after comment discussion.",
      "related": [
        2594
      ],
      "keyQuote": "Would it be possible to prioritize support for newer versions in upcoming releases?",
      "number": 2595,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:57.094Z"
    },
    {
      "summary": "User requests support for Kotlin 2.0 and newer versions of gRPC, Netty, and related JVM dependencies in the Temporal Java SDK. The maintainer clarified that the Java SDK already supports the latest gRPC versions and noted that while no official Kotlin SDK exists, many users successfully use the Java SDK from Kotlin.",
      "category": "feature",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "dependency-management",
        "build-configuration",
        "java-sdk",
        "grpc-integration"
      ],
      "concepts": [
        "kotlin-support",
        "dependency-versions",
        "grpc-upgrade",
        "netty-upgrade",
        "jvm-compatibility",
        "build-dependencies"
      ],
      "severity": "low",
      "userImpact": "Kotlin users wanting to use newer versions of gRPC and related dependencies with the Temporal Java SDK need to verify compatibility and may face version conflicts.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Issue resolved as not applicable - Temporal Java SDK already supports latest gRPC versions (1.72.0+), and no official Kotlin SDK is planned, though users can use the Java SDK from Kotlin.",
      "related": [],
      "keyQuote": "Temporal Java SDK supports the lates grpc (We run CI with `1.72.0` but will update to `1.73.0` soon)",
      "number": 2594,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:58.890Z"
    },
    {
      "summary": "An issue created accidentally with no meaningful content or description.",
      "category": "other",
      "subcategory": "housekeeping",
      "apis": [],
      "components": [],
      "concepts": [
        "cleanup",
        "repository-maintenance"
      ],
      "severity": "low",
      "userImpact": "No user impact; this is an administrative issue created in error.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed as it contained no actual content or problem statement.",
      "related": [],
      "keyQuote": "Created accidentally",
      "number": 2593,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:42.098Z"
    },
    {
      "summary": "Python Nexus tests are failing when run against the Java test server, with gRPC errors indicating missing methods in generated message classes. The issue reproduces with time-skipping enabled and eventually times out.",
      "category": "bug",
      "subcategory": "testing",
      "apis": [
        "StartWorkflowExecution",
        "RespondWorkflowTaskCompleted"
      ],
      "components": [
        "nexus-tests",
        "java-test-server",
        "grpc-api",
        "protobuf-generated-classes"
      ],
      "concepts": [
        "interoperability",
        "test-server",
        "gRPC",
        "protobuf",
        "nexus",
        "message-generation"
      ],
      "severity": "high",
      "userImpact": "Python SDK tests cannot run against the Java test server, blocking Nexus testing and cross-SDK compatibility validation.",
      "rootCause": "Generated message class StartWorkflowExecutionRequest is missing the getNamespace() method when used with the Java test server, unlike behavior with the real server.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Generated message class \"io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest\" missing method \"getNamespace\".",
      "number": 2592,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:44.408Z"
    },
    {
      "summary": "Fix null handling in operation token parsing to treat null values as zero instead of causing an error.",
      "category": "bug",
      "subcategory": "operation-token",
      "apis": [],
      "components": [
        "parser",
        "operation-token"
      ],
      "concepts": [
        "null-handling",
        "parsing",
        "token",
        "operation",
        "data-conversion"
      ],
      "severity": "medium",
      "userImpact": "Users encounter errors when operation tokens contain null values that should be interpreted as zero.",
      "rootCause": "Operation token parser does not handle null values correctly, likely throwing an exception or failing to default to zero.",
      "proposedFix": "Modify the operation token parser to treat null values as zero during parsing.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by updating the parser to handle null as zero.",
      "related": [],
      "keyQuote": "When parsing operation token, treat `null` as zero",
      "number": 2590,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:40.872Z"
    },
    {
      "summary": "The OPERATION_TOKEN header is currently using the workflow ID as its value, but it should use the operation token instead. This is a correctness fix for proper header value assignment.",
      "category": "bug",
      "subcategory": "headers",
      "apis": [],
      "components": [
        "http-client",
        "headers",
        "operation-token"
      ],
      "concepts": [
        "operation-token",
        "header-value",
        "workflow-id",
        "http-headers",
        "client-request"
      ],
      "severity": "medium",
      "userImpact": "External systems receiving the OPERATION_TOKEN header will get incorrect identification values, potentially breaking integrations that rely on proper operation token tracking.",
      "rootCause": "The OPERATION_TOKEN header implementation incorrectly uses workflow ID instead of the actual operation token value.",
      "proposedFix": "Replace workflow ID with operation token in the OPERATION_TOKEN header value.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The implementation was corrected to use the operation token for the OPERATION_TOKEN header value instead of workflow ID.",
      "related": [],
      "keyQuote": "Use operation token for the OPERATION_TOKEN header value, currently we use the workflow ID which is not correct.",
      "number": 2588,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:27.065Z"
    },
    {
      "summary": "Headers set via client interceptor are not propagated to workflow signal handlers when using the time-skipping test server. The headers appear blank in the inbound workflow interceptor, breaking header-based functionality in signal processing.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [
        "signal_workflow",
        "handle_signal"
      ],
      "components": [
        "test-server",
        "interceptors",
        "signal-handling"
      ],
      "concepts": [
        "headers",
        "interceptors",
        "signal-propagation",
        "test-server",
        "time-skipping",
        "payload-routing"
      ],
      "severity": "high",
      "userImpact": "Users cannot rely on headers in workflow signals when testing with the time-skipping server, breaking interceptor-based header validation and data passing patterns.",
      "rootCause": "Time-skipping test server implementation does not properly propagate client-set headers through to workflow signal handlers",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Headers set in client interceptor appear in inbound workflow interceptor... Headers are blank",
      "number": 2586,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:27.044Z"
    },
    {
      "summary": "HandlerException constructor allows null cause, but the serialization code crashes when attempting to handle this case. The PayloadAndFailureDataConverter doesn't properly handle null causes in Nexus HandlerExceptions.",
      "category": "bug",
      "subcategory": "nexus-error-handling",
      "apis": [
        "HandlerException"
      ],
      "components": [
        "nexus",
        "error-handling",
        "payload-converter",
        "failure-data-converter"
      ],
      "concepts": [
        "null-handling",
        "exception-serialization",
        "error-type",
        "nexus-operations",
        "type-safety"
      ],
      "severity": "high",
      "userImpact": "Users cannot throw HandlerException with null cause in Nexus operations without triggering a crash.",
      "rootCause": "PayloadAndFailureDataConverter line 136-145 does not handle the case where HandlerException has a null cause.",
      "proposedFix": null,
      "workaround": null,
      "related": [],
      "keyQuote": "HandlerException has a constructor inviting operation authors to throw a HandlerException with no cause, such as throw new HandlerException(HandlerException.ErrorType.NOT_FOUND, (Throwable) null); But this crashes",
      "resolution": null,
      "resolutionDetails": null,
      "number": 2582,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:28.624Z"
    },
    {
      "summary": "Request to add a summary field to LocalActivityOptions in the Java SDK. This feature aligns with the parent issue in the features repository and has already been implemented.",
      "category": "feature",
      "subcategory": "local-activity-options",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity",
        "activity-options",
        "api"
      ],
      "concepts": [
        "metadata",
        "activity-configuration",
        "summary-field",
        "options-builder"
      ],
      "severity": "low",
      "userImpact": "Users can now include summary information when configuring local activities, improving activity documentation and introspection.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The summary field was already added to LocalActivityOptions class in the codebase at temporal-sdk/src/main/java/io/temporal/activity/LocalActivityOptions.java",
      "related": [
        637
      ],
      "keyQuote": "This is already done https://github.com/temporalio/sdk-java/blob/4afe41b6ca638775e4e6ecaa3a5171b32670f9d4/temporal-sdk/src/main/java/io/temporal/activity/LocalActivityOptions.java#L171",
      "number": 2580,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:10.900Z"
    },
    {
      "summary": "Non-root namespace Spring dependencies fail during application startup because the BeanPostProcessor that creates these beans runs after bean initialization. This contradicts the documentation which claims this configuration is supported.",
      "category": "bug",
      "subcategory": "spring-starter",
      "apis": [
        "WorkflowClient"
      ],
      "components": [
        "spring-starter",
        "bean-post-processor",
        "dependency-injection"
      ],
      "concepts": [
        "namespace-configuration",
        "bean-initialization",
        "lifecycle-ordering",
        "spring-framework",
        "startup-failure"
      ],
      "severity": "high",
      "userImpact": "Users cannot inject non-root namespace Temporal beans at application startup, forcing them to use ObjectProvider workarounds to defer bean finalization.",
      "rootCause": "BeanPostProcessor that creates non-root namespace beans executes after bean initialization phase, causing autowiring to fail during startup.",
      "proposedFix": null,
      "workaround": "Use ObjectProvider to decouple component autowiring from Temporal bean creation, deferring bean finalization to @PostConstruct or runtime.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The documentation calls out that this is supported, yet the BeanPostProcessor that creates these beans run after bean initialization, so application startup will fail.",
      "number": 2579,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:12.467Z"
    },
    {
      "summary": "JavaDoc for `startUpdate` incorrectly states it's always asynchronous, but when called with `waitForStage` set to `WorkflowUpdateStage.COMPLETED`, the method actually blocks until the update completes. The documentation needs to clarify this behavior.",
      "category": "docs",
      "subcategory": "javadoc",
      "apis": [
        "startUpdate",
        "UpdateOptions",
        "WorkflowUpdateStage"
      ],
      "components": [
        "client",
        "workflow-stub",
        "update-options"
      ],
      "concepts": [
        "asynchronous-behavior",
        "blocking-calls",
        "documentation-accuracy",
        "wait-stages",
        "api-contracts"
      ],
      "severity": "low",
      "userImpact": "Developers may misunderstand the behavior of `startUpdate` based on incorrect JavaDoc, leading to unexpected blocking calls in their code.",
      "rootCause": "JavaDoc description for `startUpdate` does not account for the `waitForStage` parameter's effect on method behavior.",
      "proposedFix": "Remove the word 'asynchronously' from the JavaDoc or clarify that the function's blocking behavior depends on the `waitForStage` parameter.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The JavaDoc for `startUpdate` says the following: Start a zero argument update workflow request asynchronously. However, the following code will block until the update is completed",
      "number": 2578,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:12:09.932Z"
    },
    {
      "summary": "User cannot test activities that use ManualActivityCompletionClient with TestActivityEnvironment. The feature request asks for either direct support for manual completion in the test environment or a way to mock the ManualActivityCompletionClient.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "Activity.getExecutionContext",
        "ManualActivityCompletionClient",
        "useLocalManualCompletion"
      ],
      "components": [
        "test-activity-environment",
        "manual-completion-client",
        "activity-execution-context"
      ],
      "concepts": [
        "testing",
        "manual-completion",
        "mocking",
        "unit-testing",
        "activity-isolation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot effectively unit test activities that use manual completion, limiting test coverage for this workflow pattern.",
      "rootCause": "TestActivityEnvironment does not provide built-in support for ManualActivityCompletionClient, and useLocalManualCompletion creates new client instances that cannot be mocked.",
      "proposedFix": "Either add native support for manual completion in TestActivityEnvironment, provide a way to return a mock ManualActivityCompletionClient through a client supplier, or document recommended patterns for testing with manual completion.",
      "workaround": "Use TestWorkflowEnvironment for end-to-end testing, or mock ManualActivityCompletionClient and inject it through the same channel as the activity worker.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Testing an Activity in isolation is feasible with the TestActivityEnvironment. However is a challenge when using ManualActivityCompletionClient",
      "number": 2573,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:55.677Z"
    },
    {
      "summary": "User reported that upgrading gRPC from 1.58.1 to 1.60.0 causes NoClassDefFoundError for AbstractManagedChannelImplBuilder, preventing use of Java SDK with modern gRPC versions in applications using other gRPC functionality.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "ChannelManager",
        "WorkflowServiceStubs",
        "serviceclient"
      ],
      "concepts": [
        "grpc-compatibility",
        "dependency-version",
        "classpath-conflict",
        "library-versioning",
        "gradle-maven"
      ],
      "severity": "medium",
      "userImpact": "Applications using the Java SDK alongside other gRPC libraries with newer versions cannot initialize the Temporal client due to missing internal gRPC classes.",
      "rootCause": "AbstractManagedChannelImplBuilder was removed from gRPC internal APIs between versions, but the Java SDK was built against older gRPC version and may have dependencies that conflict with newer versions.",
      "proposedFix": "Upgrade gRPC dependency to current version (1.73.0 or later) and ensure compatibility with internal API changes.",
      "workaround": "Downgrade other gRPC dependencies to 1.58.1 to match the Java SDK's gRPC version, though this is not recommended as 1.58.1 is from 2023.",
      "resolution": "invalid",
      "resolutionDetails": "Issue was determined to be user-side dependency version conflict rather than SDK bug; SDK is tested and confirmed compatible with gRPC 1.72.0+. Root cause was likely mixed gRPC versions in user's classpath.",
      "related": [],
      "keyQuote": "The Java SDK builds against an older version of grpc since we are a library but you are encouraged to use a more recent version in your application.",
      "number": 2565,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:54.915Z"
    },
    {
      "summary": "Spring Boot auto-discovery for workers incorrectly registers workflows and activities from packages not specified in the configuration. When multiple namespaces are configured with different package lists, all packages are registered in all namespaces instead of respecting the specified package boundaries.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "worker-auto-discovery",
        "namespace-configuration"
      ],
      "concepts": [
        "package-filtering",
        "namespace-isolation",
        "configuration-scoping",
        "bean-registration",
        "auto-discovery",
        "multi-namespace"
      ],
      "severity": "high",
      "userImpact": "Users cannot properly isolate workflows and activities across packages or namespaces, causing unintended workers to be registered with incorrect task queues and namespaces.",
      "rootCause": "The auto-discovery mechanism does not properly filter beans by the configured package list when registering workers, particularly in multi-namespace scenarios where package specifications should be namespace-scoped.",
      "proposedFix": null,
      "workaround": "Use @ActivityImpl annotations with task queue specifications to manually control which worker an auto-discovered activity registers for.",
      "resolution": "wontfix",
      "resolutionDetails": "Marked as expected behavior by maintainer; clarified that Spring beans lack package concept and that @ActivityImpl provides the mechanism for worker control.",
      "related": [],
      "keyQuote": "All activities beans registered in the spring context are registered according to their task queue/worker. Have you looked at the options under `@ActivityImpl`",
      "number": 2564,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:57.091Z"
    },
    {
      "summary": "Request to implement external client configuration for Java SDK, aligning with cross-SDK standardization efforts documented in the features repository and proposals.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [
        "WorkflowClient",
        "ActivityClient"
      ],
      "components": [
        "client-config",
        "external-client",
        "configuration-builder"
      ],
      "concepts": [
        "configuration",
        "external-client",
        "standardization",
        "client-setup",
        "environment-config",
        "sdk-alignment"
      ],
      "severity": "medium",
      "userImpact": "Users need a standardized way to configure external clients consistently across Temporal SDK implementations.",
      "rootCause": null,
      "proposedFix": "Implement external client configuration following the cross-SDK specification in the features repository and proposals document.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        441
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/441 and https://github.com/temporalio/proposals/blob/master/all-sdk/external-client-configuration.md",
      "number": 2562,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:34.704Z"
    },
    {
      "summary": "Add `WorkflowTaskFailedCause` to `RespondQueryTaskCompletedRequest` to provide the same failure cause information available for workflow task failures.",
      "category": "feature",
      "subcategory": "query-tasks",
      "apis": [
        "RespondQueryTaskCompletedRequest"
      ],
      "components": [
        "query-task-handler",
        "workflow-task-failure"
      ],
      "concepts": [
        "failure-cause",
        "query-tasks",
        "workflow-tasks",
        "error-reporting"
      ],
      "severity": "medium",
      "userImpact": "Users can now understand why query task completion failed with detailed cause information.",
      "rootCause": null,
      "proposedFix": "Add `WorkflowTaskFailedCause` field to `RespondQueryTaskCompletedRequest` following the same pattern as workflow task failures",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented by adding `WorkflowTaskFailedCause` to the request object",
      "related": [],
      "keyQuote": "Should work the same as for workflow task failures",
      "number": 2559,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:36.046Z"
    },
    {
      "summary": "User requests adding getWorkflowId() and getFirstExecutionRunId() methods to the ScheduleActionExecution interface to avoid casting when fetching active running workflows through schedule describe calls. The maintainer declined, arguing that ScheduleActionExecution is a variant type that may support non-workflow actions in the future, and casting is the appropriate pattern.",
      "category": "feature",
      "subcategory": "schedules-api",
      "apis": [
        "ScheduleClient",
        "ScheduleDescription",
        "ScheduleActionExecution",
        "ScheduleActionExecutionStartWorkflow"
      ],
      "components": [
        "schedules",
        "client-api",
        "schedule-description"
      ],
      "concepts": [
        "variant-types",
        "type-casting",
        "api-design",
        "extensibility",
        "workflow-metadata"
      ],
      "severity": "low",
      "userImpact": "Users must cast ScheduleActionExecution to ScheduleActionExecutionStartWorkflow to access workflow ID and run ID, reducing API clarity and creating maintenance burden.",
      "rootCause": "ScheduleActionExecution is designed as a variant type interface to support future action types beyond workflows (nexus operations, activities), but currently only has one implementation.",
      "proposedFix": "Add abstract methods like getActionType() and getId() to ScheduleActionExecution, or provide a getActionMetadata() method that returns action details via Java generics.",
      "workaround": "Cast ScheduleActionExecution to ScheduleActionExecutionStartWorkflow to access workflow ID and run ID.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer decided casting is the appropriate pattern for Java's variant type representation, as ScheduleActionExecution will support multiple action types in the future.",
      "related": [],
      "keyQuote": "ScheduleActionExecution is a variant type to contain multiple different types of Schedule*Execution. Currently we only have one, but that will not always be the case.",
      "number": 2557,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:40.687Z"
    },
    {
      "summary": "Add poller autoscaling options for Spring integration to support dynamic adjustment of worker pollers based on demand.",
      "category": "feature",
      "subcategory": "spring-integration",
      "apis": [],
      "components": [
        "spring-integration",
        "worker",
        "poller"
      ],
      "concepts": [
        "autoscaling",
        "resource-optimization",
        "worker-configuration",
        "dynamic-adjustment",
        "spring-framework"
      ],
      "severity": "low",
      "userImpact": "Spring framework users will be able to configure automatic poller scaling to optimize resource utilization based on workload demands.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add poller autoscaling options for Spring",
      "number": 2552,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:17.757Z"
    },
    {
      "summary": "Deployment options for versioning are currently only applied to workflow poll requests, but should be set on all types of poll requests in the Java SDK.",
      "category": "bug",
      "subcategory": "versioning",
      "apis": [],
      "components": [
        "polling",
        "deployment-options",
        "versioning"
      ],
      "concepts": [
        "deployment",
        "versioning",
        "polling",
        "configuration",
        "request-handling"
      ],
      "severity": "medium",
      "userImpact": "Users relying on deployment options for versioning will have incomplete configuration applied to non-workflow polls, potentially causing versioning issues.",
      "rootCause": "Deployment options are only set on workflow poll requests, missing application to other poll request types.",
      "proposedFix": "Apply deployment options to all poll request types, not just workflow polls.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Deployment options were extended to be set on all poll requests.",
      "related": [],
      "keyQuote": "we only set the deployment options (new versioning) info on workflow polls, but it ought to apply to all kinds of poll requests",
      "number": 2550,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:19.792Z"
    },
    {
      "summary": "Request to add a counter metric for unaccessed failed promises in the Java SDK to help developers detect when they forget to wait on promises or handle promise failures.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "DeterministicRunnerImpl",
        "promise-handling",
        "metrics"
      ],
      "concepts": [
        "metrics",
        "promises",
        "error-handling",
        "observability",
        "debugging"
      ],
      "severity": "low",
      "userImpact": "Developers would have better visibility into unhandled promise failures, helping them identify and fix oversights in their workflow code.",
      "rootCause": null,
      "proposedFix": "Add a counter metric for unaccessed failed promises similar to what exists in the codebase at DeterministicRunnerImpl.java lines 336-347",
      "workaround": "Developers can explicitly handle failed promises using promise.exceptionally(e->null) or promise.handle((ex, failure) -> null)",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Would be useful to have a counter metric for this. Would allow detection so can fix in code if was oversight not to wait on promise",
      "number": 2538,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:21.691Z"
    },
    {
      "summary": "Feature request to support custom client identity on schedule trigger to differentiate between automatic schedule-triggered workflows and manual triggers, enabling identification of who or what service initiated a manual workflow run.",
      "category": "feature",
      "subcategory": "schedules",
      "apis": [
        "ScheduleHandle.trigger()",
        "ScheduleClientCallsInterceptor.CreateScheduleInput",
        "ScheduleClientOptions.Builder"
      ],
      "components": [
        "schedules",
        "client",
        "schedule-client"
      ],
      "concepts": [
        "client-identity",
        "trigger-source",
        "schedule-trigger",
        "manual-trigger",
        "workflow-differentiation",
        "metadata"
      ],
      "severity": "low",
      "userImpact": "Users cannot identify who or what service manually triggered a workflow via schedule, limiting audit trails and workflow differentiation capabilities.",
      "rootCause": null,
      "proposedFix": "Add a metadata field like trigger_source or client_identity to distinguish between automatic schedule triggers and manual triggers initiated by specific clients.",
      "workaround": "Compare nextActionTime with actual workflow start time and manually set a trigger_type search attribute.",
      "resolution": "fixed",
      "resolutionDetails": "The ScheduleClientOptions.Builder already supports setting identity for the schedule client, which is passed for every client call including Trigger operations.",
      "related": [],
      "keyQuote": "To can set the identity for the schedule client in the ScheduleClientOptions.Builder. This identity will be passed for every client call made including Trigger",
      "number": 2537,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:02.054Z"
    },
    {
      "summary": "Request to add a configuration option in Spring Boot autoconfiguration to fail worker startup when duplicate activity type definitions are detected, rather than silently logging and continuing.",
      "category": "feature",
      "subcategory": "spring-boot-autoconfiguration",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "worker-discovery",
        "activity-registration"
      ],
      "concepts": [
        "duplicate-detection",
        "worker-startup",
        "configuration-option",
        "autodiscovery",
        "error-handling"
      ],
      "severity": "low",
      "userImpact": "Users deploying Spring Boot applications with multiple activity implementations defining the same activity type would benefit from explicit failure feedback rather than silent failures.",
      "rootCause": "The WorkersTemplate currently silently skips duplicate activity registrations instead of providing an option to fail fast on detection.",
      "proposedFix": "Add a configuration option (e.g., ignoreDuplicateDefinitions) to control whether TypeAlreadyRegisteredException should halt worker startup or continue silently.",
      "workaround": "Check the namespaceProperties.isIgnoreDuplicateDefinitions configuration option mentioned in the comment.",
      "resolution": "fixed",
      "resolutionDetails": "Configuration option was identified or implemented to handle duplicate definitions during worker autodiscovery.",
      "related": [],
      "keyQuote": "Feature request is to add config option to not continue at this point but throw exception that stops worker start",
      "number": 2534,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:03.254Z"
    },
    {
      "summary": "NonRootNamespaceAutoConfiguration#nonRootBeanPostProcessor causes early initialization of MeterRegistry before Spring's MeterRegistryPostProcessor is ready, causing MeterRegistryCustomizer to be ignored and metrics filtering to fail.",
      "category": "bug",
      "subcategory": "metrics-configuration",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "metrics-scope",
        "meter-registry"
      ],
      "concepts": [
        "bean-initialization-order",
        "metrics-filtering",
        "spring-boot-customization",
        "dependency-injection",
        "lifecycle-timing"
      ],
      "severity": "high",
      "userImpact": "Users cannot customize MeterRegistry behavior through MeterRegistryCustomizer when using NonRootNamespaceAutoConfiguration, breaking metrics filtering and customization.",
      "rootCause": "NonRootNamespaceAutoConfiguration#nonRootBeanPostProcessor triggers early MeterRegistry initialization through MetricsScopeAutoConfiguration#scope before Spring's MeterRegistryPostProcessor has a chance to apply customizers.",
      "proposedFix": null,
      "workaround": "A workaround is provided in the reproducer project at https://github.com/rpost/temporal-bug/commit/d16476e4ec796bb338efcade55d6469e9870842e",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "causes early initialization of MeterRegistry even before org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryPostProcessor is ready",
      "number": 2533,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:11:05.732Z"
    },
    {
      "summary": "Request to expose StartWorkflowExecutionResponse fields through the ExecuteWorkflow API to provide more detailed information about workflow execution initiation. This tracks a feature gap identified in the features repository.",
      "category": "feature",
      "subcategory": "workflow-api",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflowExecutionResponse"
      ],
      "components": [
        "workflow-client",
        "api-layer"
      ],
      "concepts": [
        "api-exposure",
        "workflow-execution",
        "response-fields",
        "client-interface"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access the full response details from workflow execution initiation, limiting their ability to work with complete execution metadata.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The StartWorkflowExecutionResponse fields were exposed through the ExecuteWorkflow API as requested.",
      "related": [
        619
      ],
      "keyQuote": "see https://github.com/temporalio/features/issues/619",
      "number": 2523,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:44.037Z"
    },
    {
      "summary": "User requests ability to access workflow instance state directly in test environments for assertions without needing to add query methods to production code. Currently workflow objects are inaccessible after registration.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "Workflow",
        "TestWorkflowClient"
      ],
      "components": [
        "test-framework",
        "workflow-registry",
        "workflow-instantiation"
      ],
      "concepts": [
        "testing",
        "workflow-state",
        "assertions",
        "test-utilities",
        "object-access"
      ],
      "severity": "medium",
      "userImpact": "Users must add query methods to production code for testing or use workarounds instead of being able to directly inspect workflow state in tests.",
      "rootCause": null,
      "proposedFix": "Add getWorkflowObject(workflowId, workflowRunId) method to TestWorkflowClient that returns the actual workflow instance with current state.",
      "workaround": "Add QueryMethod in workflow code for testing purposes, though this is cumbersome when managing multiple test queries.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I would like to access the workflow object at any point in time for test env, and it should provide me an object of workflow with latest state",
      "number": 2521,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:49.042Z"
    },
    {
      "summary": "gRPC version used by the Java SDK is outdated and causes NoClassDefFoundError at runtime due to removed internal classes. The SDK needs to update to a newer gRPC version to maintain compatibility with modern applications.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "ChannelManager",
        "WorkflowServiceStubs",
        "gRPC-integration"
      ],
      "concepts": [
        "dependency-versioning",
        "breaking-changes",
        "transitive-dependencies",
        "class-loading",
        "version-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users integrating the Java SDK with modern gRPC versions or applications face startup failures due to missing internal gRPC classes.",
      "rootCause": "The SDK depends on an outdated version of gRPC (specifically internal class AbstractManagedChannelImplBuilder was removed in newer versions), causing ClassNotFoundException when loaded alongside newer gRPC dependencies.",
      "proposedFix": "Update gRPC version to latest (v1.72.0 or newer) and ensure all transitive dependencies are aligned.",
      "workaround": "Users can manually override gRPC dependencies in their build configuration to use newer versions, though this shifts the burden to SDK users.",
      "resolution": "fixed",
      "resolutionDetails": "The team acknowledged the issue and committed to testing the SDK with the latest gRPC version (v1.72.0) in CI while maintaining compatibility policy.",
      "related": [],
      "keyQuote": "I firmly believe that open-source communities should strive to keep their third-party dependencies up to date.",
      "number": 2508,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:47.547Z"
    },
    {
      "summary": "Spring Boot 3.3.11 upgrade caused Temporal Java SDK to fail during bean initialization due to gRPC deadline exceeded timeout when fetching system info from Temporal cluster. The issue appeared after upgrading from Spring Boot 3.3.4 to address CVE-2025-22235.",
      "category": "bug",
      "subcategory": "spring-boot-compatibility",
      "apis": [
        "WorkflowServiceBlockingStub.getSystemInfo"
      ],
      "components": [
        "service-client",
        "channel-manager",
        "spring-boot-integration"
      ],
      "concepts": [
        "timeout",
        "gRPC",
        "deadline",
        "bean-initialization",
        "system-info",
        "connection",
        "spring-boot"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to Spring Boot 3.3.11 for security patches cannot initialize Temporal workers and their Spring applications fail to start.",
      "rootCause": "GetSystemInfo timeout was too short (default ~3.4 seconds) for the gRPC call to complete, causing DEADLINE_EXCEEDED error during WorkflowServiceBlockingStub initialization.",
      "proposedFix": "Set GetSystemInfo timeout to 5 or 10 seconds using WorkflowServiceStubsOptions.newBuilder().setSystemInfoTimeout(Duration.ofSeconds(10))",
      "workaround": "Configure WorkflowServiceStubsOptions with an increased SystemInfoTimeout value before creating the service client.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by increasing the GetSystemInfo timeout duration in WorkflowServiceStubsOptions, as documented in SDK release notes v1.25.2.",
      "related": [],
      "keyQuote": "On your WorkflowServiceStubsOptions, can you please set the GetSystemInfo timeout to 5 or 10 seconds",
      "number": 2504,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:31.805Z"
    },
    {
      "summary": "Remove license headers from all Java SDK files following the server's decision to eliminate this requirement, and remove any tooling that generates or enforces them.",
      "category": "feature",
      "subcategory": "build-system",
      "apis": [],
      "components": [
        "build-tooling",
        "file-headers",
        "license-management"
      ],
      "concepts": [
        "license-headers",
        "code-generation",
        "build-automation",
        "compliance",
        "maintenance",
        "cleanup"
      ],
      "severity": "low",
      "userImpact": "Users will have cleaner source files without unnecessary license headers, reducing file clutter and maintenance overhead.",
      "rootCause": null,
      "proposedFix": "Remove license headers from all files in the SDK and remove any tooling (build plugins, scripts) that generates them or requires them, following the pattern established by the server repository.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "License headers were removed from files and the tooling that enforced them was updated.",
      "related": [],
      "keyQuote": "Following server in https://github.com/temporalio/temporal/pull/7689, license headers are no longer required on files.",
      "number": 2502,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:29.205Z"
    },
    {
      "summary": "Proposal to support pluggable workflow caches in the Java SDK to allow customizable eviction strategies beyond the current synchronous LRU algorithm. This addresses scenarios where high-volume workloads with abandoned workflows could benefit from alternatives like TTL-based or asynchronous eviction mechanisms.",
      "category": "feature",
      "subcategory": "workflow-cache",
      "apis": [],
      "components": [
        "workflow-cache",
        "thread-pool",
        "eviction-policy"
      ],
      "concepts": [
        "caching-strategy",
        "LRU-eviction",
        "memory-management",
        "abandoned-workflows",
        "performance-optimization",
        "pluggable-architecture"
      ],
      "severity": "medium",
      "userImpact": "Users with high-volume workloads can implement custom cache eviction strategies optimized for their specific workload patterns instead of being limited to the default LRU algorithm.",
      "rootCause": "Current integrated LRU cache may not be optimal for all workloads, particularly when workflows are abandoned by remote workers without invalidation signals, creating unnecessary eviction overhead.",
      "proposedFix": "Add a pluggable cache mechanism that defaults to the current LRU design while allowing SDK users to supply custom implementations, potentially including TTL-based or asynchronous eviction strategies.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        573
      ],
      "keyQuote": "The proposal is to add a mechanism allowing a pluggable cache that defaults to the current LRU design, allowing SDK end-users to supply their own implementations when desired.",
      "number": 2499,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:28.254Z"
    },
    {
      "summary": "User requests making Jackson serialization optional and separate from the core Java SDK to avoid transitive dependencies and version conflicts, especially when using alternative serialization libraries. The feature request proposes moving Jackson to a separate module using Java Service Provider Interface for runtime discovery.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [
        "DataConverter"
      ],
      "components": [
        "data-converter",
        "serialization",
        "dependency-management"
      ],
      "concepts": [
        "optional-dependency",
        "pluggability",
        "transitive-dependencies",
        "version-conflict",
        "service-provider-interface",
        "Jackson",
        "kotlinx-serialization"
      ],
      "severity": "low",
      "userImpact": "Users with alternative serialization needs are forced to include unused Jackson dependencies, causing version conflicts and unintended behavior in frameworks like Spring Boot.",
      "rootCause": "Jackson is a hard runtime dependency for SDK internal use (non-user-facing serialization), not just user-facing DataConverter pluggability, and DefaultDataConverter loads JacksonJsonPayloadConverter statically.",
      "proposedFix": "Create a separate temporal-sdk-jackson artifact with Jackson-based converters, using Java Service Provider Interface for runtime discovery similar to SLF4J implementation discovery.",
      "workaround": "Excluding Jackson from classpath via Gradle is not feasible due to static loading in DefaultDataConverter and package-private PayloadAndFailureDataConverter.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers determined that Jackson is required for SDK internal use (not just user-facing), making removal a significant effort. Removing the dependency would be a breaking change, acceptable only in a major version bump. For now, maintainers prefer to keep Jackson as a core dependency.",
      "related": [],
      "keyQuote": "The Java SDK requires jackson (and protobuf) for basic functionality, it is not an optional dependency that could be removed from the SDK.",
      "number": 2498,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:16.183Z"
    },
    {
      "summary": "Test server is not displaying user metadata (summary/details) for workflow start in the EVENT_TYPE_WORKFLOW_EXECUTION_STARTED history event. The issue also needs verification that child workflows properly propagate this metadata.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "test-server",
        "history-event",
        "workflow-execution",
        "metadata-propagation"
      ],
      "concepts": [
        "user-metadata",
        "workflow-start",
        "history-events",
        "test-framework",
        "child-workflows"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows on the test server cannot verify that workflow start metadata is properly recorded in execution history, hindering testing and debugging.",
      "rootCause": "User metadata is not being captured or displayed in the workflow execution started event on the test server.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was fixed, likely as part of or related to issue #2441 mentioned in the bug report.",
      "related": [
        2441,
        851
      ],
      "keyQuote": "Workflow start with summary/details on test server should show this in user metadata of EVENT_TYPE_WORKFLOW_EXECUTION_STARTED event but it is not.",
      "number": 2494,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:15.886Z"
    },
    {
      "summary": "NPE in ScheduleDescription.getMemo() due to incorrect null check. Line 116 checks `memo == null` instead of `memoPayload == null`, causing a NullPointerException when memoPayload is null.",
      "category": "bug",
      "subcategory": "schedule-client",
      "apis": [
        "ScheduleDescription"
      ],
      "components": [
        "schedule-client",
        "data-conversion"
      ],
      "concepts": [
        "null-check",
        "npe",
        "memo",
        "payload",
        "defensive-programming"
      ],
      "severity": "high",
      "userImpact": "Users encounter NullPointerException when retrieving memo from ScheduleDescription objects with null payload.",
      "rootCause": "Incorrect variable name in null check condition - checking `memo` instead of `memoPayload`",
      "proposedFix": "Change line 116 from `if (memo == null)` to `if (memoPayload == null)`",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bug fix applied to correct the null check condition in ScheduleDescription.getMemo()",
      "related": [],
      "keyQuote": "Looks like line 116 should be `if (memoPayload == null) {`.",
      "number": 2493,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:13.953Z"
    },
    {
      "summary": "Request to add SDK support for activity reset functionality in Java SDK, aligned with the cross-SDK features initiative.",
      "category": "feature",
      "subcategory": "activity-management",
      "apis": [],
      "components": [
        "activity-executor",
        "worker"
      ],
      "concepts": [
        "activity-reset",
        "state-management",
        "workflow-execution",
        "activity-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users need standardized activity reset capabilities across all Temporal SDKs for better workflow state management.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Activity reset support has been implemented in the Java SDK",
      "related": [
        620
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/620",
      "number": 2488,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:59.001Z"
    },
    {
      "summary": "Request to warn users when the server-provided task start time differs significantly from when the SDK begins processing the task. This enhancement was declined as too niche.",
      "category": "feature",
      "subcategory": "task-processing",
      "apis": [],
      "components": [
        "worker",
        "task-processor",
        "logging"
      ],
      "concepts": [
        "task-timing",
        "server-client-sync",
        "monitoring",
        "diagnostics"
      ],
      "severity": "low",
      "userImpact": "Users would receive warnings about timing discrepancies that could indicate system issues, but this was deemed too specific for most use cases.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Feature request was declined by maintainers as too niche to implement.",
      "related": [
        616
      ],
      "keyQuote": "We're not gonna do this. Too niche.",
      "number": 2484,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:10:01.039Z"
    },
    {
      "summary": "ActivityOptions merge fails with UnsupportedOperationException when using immutable lists for context propagators. The issue occurs when merging ActivityOptions from WorkflowImplementationOptions with ActivityOptions from activity stubs that both use immutable lists created with List.of().",
      "category": "bug",
      "subcategory": "activity-options",
      "apis": [
        "ActivityOptions",
        "WorkflowImplementationOptions",
        "Workflow.newActivityStub"
      ],
      "components": [
        "activity-options",
        "context-propagation",
        "workflow-implementation"
      ],
      "concepts": [
        "immutable-collections",
        "list-merging",
        "context-propagators",
        "activity-configuration",
        "options-builder"
      ],
      "severity": "medium",
      "userImpact": "Users cannot merge ActivityOptions with immutable context propagators lists without encountering a runtime exception when scheduling activities.",
      "rootCause": "The merge operation attempts to modify an immutable list directly instead of creating a new combined list, causing UnsupportedOperationException when List.of() creates unmodifiable lists.",
      "proposedFix": "Create a new list that combines both context propagators instead of modifying one of them, or copy the list when setContextPropagators is called.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Create a new list that combines both instead of modifying one of them.",
      "number": 2482,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:59.593Z"
    },
    {
      "summary": "User requests to display the retry policy configuration on the activity info object, similar to feature request in the features repository. This would allow developers to inspect what retry policy is applied to an activity at runtime.",
      "category": "feature",
      "subcategory": "activity-info",
      "apis": [
        "ActivityInfo"
      ],
      "components": [
        "activity-executor",
        "activity-info",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "policy",
        "configuration",
        "activity-metadata",
        "observability",
        "runtime-inspection"
      ],
      "severity": "low",
      "userImpact": "Developers can inspect the retry policy configuration applied to activities at runtime for debugging and observability.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Retry policy information was added to activity info, allowing developers to inspect it at runtime.",
      "related": [
        615
      ],
      "keyQuote": "Show retry policy on activity info",
      "number": 2481,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:47.396Z"
    },
    {
      "summary": "Memo fields are not populated in listOpenWorkflowExecutions results when using temporal-testing, despite being set in the workflow. The same code correctly returns memos when using an external Temporal server.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "listOpenWorkflowExecutions",
        "getWorkflowServiceStubs"
      ],
      "components": [
        "temporal-testing",
        "workflow-execution-info",
        "memo"
      ],
      "concepts": [
        "test-server",
        "in-memory-server",
        "workflow-metadata",
        "query-results",
        "data-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users testing with temporal-testing cannot rely on memo data in listOpenWorkflowExecutions queries, limiting test coverage and requiring workarounds.",
      "rootCause": "The temporal-testing implementation does not properly persist or return memo data when listing open workflow executions.",
      "proposedFix": null,
      "workaround": "Use setUseExternalService(true) with a running temporal server start-dev instance for testing memos.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "memo is empty despite being filled in workflow. The same piece of code run with setUseExternalService(true) and temporal server start-dev outputs memo-s as expected.",
      "number": 2480,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:46.958Z"
    },
    {
      "summary": "Implement application failure logging and metrics behavior according to ApplicationErrorCategory specification. This involves applying standardized error categorization to logging and metrics collection for application failures in the Java SDK.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "error-handling",
        "logging",
        "metrics"
      ],
      "concepts": [
        "error-categorization",
        "application-failures",
        "logging-behavior",
        "metrics-collection",
        "error-classification",
        "standardization"
      ],
      "severity": "medium",
      "userImpact": "Users will have consistent and standardized application failure logging and metrics across the Java SDK based on error categories.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing the ApplicationErrorCategory-based logging and metrics behavior as specified in the features issue.",
      "related": [
        614
      ],
      "keyQuote": "Apply application failure logging and metrics behaviour according to `ApplicationErrorCategory`",
      "number": 2475,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:44.892Z"
    },
    {
      "summary": "NonRootBeanPostProcessor eagerly instantiates MeterRegistry before MeterRegistryPostProcessor can register, causing meter customizers and binders to fail. Spring's dependency injection order in Temporal 1.28.0+ creates a circular initialization issue where metrics exposure disappears and bean post-processors are applied out of order.",
      "category": "bug",
      "subcategory": "spring-metrics-initialization",
      "apis": [],
      "components": [
        "NonRootBeanPostProcessor",
        "MetricsScopeAutoConfiguration",
        "MeterRegistry",
        "Spring auto-configuration"
      ],
      "concepts": [
        "bean-post-processor",
        "dependency-injection-order",
        "lazy-initialization",
        "micrometer-integration",
        "spring-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Upgrading to Temporal 1.28.0+ breaks metrics collection in Spring applications as MeterRegistry is instantiated prematurely, preventing meter binders and Micrometer customizers from being applied.",
      "rootCause": "NonRootBeanPostProcessor's non-static factory method causes early instantiation of the configuration class, forcing MeterRegistry creation before MeterRegistryPostProcessor is registered with the bean factory. This violates Spring's expectation that BeanPostProcessors be registered early in the context lifecycle.",
      "proposedFix": "Make dependencies lazy by either converting NonRootBeanPostProcessor factory method to static or making the Scope dependency lazy-loaded to defer MeterRegistry instantiation until after MeterRegistryPostProcessor is registered.",
      "workaround": "Exclude NonRootNamespaceAutoConfiguration via spring.autoconfigure.exclude and manually define NonRootBeanPostProcessor using a static factory method instead of instance method.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        22926
      ],
      "keyQuote": "Bean 'prometheusMeterRegistry' is not eligible for getting processed by all BeanPostProcessors...Is this bean getting eagerly injected/applied to a currently created BeanPostProcessor?",
      "number": 2474,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:32.668Z"
    },
    {
      "summary": "When a workflow is canceled while executing activities and timers within cancellation scopes, the order in which pending operations are canceled is non-deterministic, causing NonDeterministicException during replay. The SDK iterates over a HashSet without deterministic ordering.",
      "category": "bug",
      "subcategory": "workflow-cancellation",
      "apis": [
        "Workflow.newCancellationScope",
        "Async.procedure",
        "Workflow.sleep",
        "Workflow.newActivityStub"
      ],
      "components": [
        "cancellation-scope",
        "async-executor",
        "workflow-replay",
        "history-generation"
      ],
      "concepts": [
        "determinism",
        "cancellation",
        "non-deterministic-order",
        "workflow-replay",
        "history-ordering",
        "concurrency"
      ],
      "severity": "high",
      "userImpact": "Workflows using cancellation scopes with concurrent operations fail unpredictably during replay due to non-deterministic cancellation ordering.",
      "rootCause": "SDK iterates over a HashSet without deterministic ordering when canceling multiple pending operations.",
      "proposedFix": null,
      "workaround": "Move async procedures inside the cancellation scope to ensure consistent cancellation order of nested operations.",
      "resolution": "fixed",
      "resolutionDetails": "Fix involves replacing HashSet iteration with deterministic ordering; deferred to a future release due to backwards compatibility concerns.",
      "related": [],
      "keyQuote": "the SDK iterating over a HashSet which is not deterministic. Due to some backwards compatibility concerns this fix won't be enabled until 2 minor releases.",
      "number": 2473,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:27.759Z"
    },
    {
      "summary": "Create a high-level client for control plane operations concerning worker deployments in the Java SDK, as a follow-up to issue #2458 on worker versioning.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "worker",
        "control-plane",
        "deployment-management"
      ],
      "concepts": [
        "versioning",
        "worker-deployment",
        "high-level-client",
        "control-plane-operations"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to manage worker deployments through a high-level client API for versioning and deployment control.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2458
      ],
      "keyQuote": "Create the high-level client for control plane operations concerning worker deployments",
      "number": 2469,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:27.105Z"
    },
    {
      "summary": "Spring Boot starter behavior changed in v1.22.0+ to fail startup if Temporal server is unavailable, breaking existing deployments that relied on graceful degradation. Users request a configuration option to restore the older behavior where worker startup succeeds even when the server is unreachable.",
      "category": "bug",
      "subcategory": "spring-boot-starter",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "worker",
        "client-connection"
      ],
      "concepts": [
        "startup-behavior",
        "server-availability",
        "graceful-degradation",
        "container-orchestration",
        "readiness-probe",
        "liveness-probe"
      ],
      "severity": "high",
      "userImpact": "Applications fail to start if Temporal server is temporarily unavailable, breaking deployment pipelines and microservice patterns that distinguish between application liveness and readiness.",
      "rootCause": "Version 1.22.0+ changed Spring Boot starter to fail initialization if server connection cannot be established, removing graceful degradation behavior from older versions.",
      "proposedFix": "Add configuration option to make worker startup non-blocking and allow the application to start successfully even when Temporal server is unavailable, with separate readiness/liveness probe support.",
      "workaround": "Increase `WorkflowServiceStubsOptions.Builder.setSystemInfoTimeout` and start the worker manually after application startup completes.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers determined that workers require active server connection to function and recommended fixing deployment orchestration instead, but acknowledged the microservice pattern concern.",
      "related": [],
      "keyQuote": "a microservice best practice is to make a difference between my application crashing and my application needing something not possible now",
      "number": 2466,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:14.035Z"
    },
    {
      "summary": "Heartbeating activities should be interrupted when activities are paused to prevent unnecessary heartbeat messages during pause periods.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-manager",
        "worker-pause"
      ],
      "concepts": [
        "heartbeat",
        "pause",
        "activity-lifecycle",
        "concurrency",
        "resource-management"
      ],
      "severity": "medium",
      "userImpact": "Users experience unnecessary heartbeat overhead when activities are paused, wasting resources and potentially causing confusion.",
      "rootCause": "Heartbeat mechanism does not respect activity pause state, continuing to send heartbeats even when activities are suspended.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Heartbeat interruption during pause was implemented to prevent unnecessary heartbeat messages.",
      "related": [
        602
      ],
      "keyQuote": "Heartbeating activities should be interrupted when the activities are paused.",
      "number": 2465,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:14.445Z"
    },
    {
      "summary": "Users need a way to programmatically detect when the workflow deadlock detector has triggered so they can implement defensive logic to stop processing and prevent zombie threads or infinite loops.",
      "category": "feature",
      "subcategory": "deadlock-detection",
      "apis": [
        "DestroyWorkflowThreadError"
      ],
      "components": [
        "deadlock-detector",
        "workflow-executor",
        "thread-management"
      ],
      "concepts": [
        "deadlock-detection",
        "thread-interruption",
        "defensive-programming",
        "error-handling",
        "cancellation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot defensively handle deadlock detector triggers in their workflow code, leading to potential zombie threads and infinite loops.",
      "rootCause": "SDK throws DestroyWorkflowThreadError when workflow APIs are used after deadlock detection, but there's no way to proactively check or handle this state.",
      "proposedFix": "Add a method similar to Thread.currentThread().isInterrupted() to detect deadlock state, or an interruption point like CancellationScope.current().throwCanceled() that can be placed in loops.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users would like the ability to programmatically detect when the deadlock detector has triggered so they can instruct their code to stop processing.",
      "number": 2461,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:13.996Z"
    },
    {
      "summary": "Test server incorrectly overwrites last heartbeat details on activity failure even when heartbeat details are not set, causing issues for Core-based SDKs that expect this behavior to be conditional.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "activity-heartbeat",
        "failure-handling"
      ],
      "concepts": [
        "heartbeat",
        "activity-failure",
        "test-server",
        "state-management",
        "sdk-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Test server behavior is inconsistent with SDK expectations, potentially causing test failures or incorrect heartbeat state in Core-based SDKs.",
      "rootCause": "As of PR #2354, test server unconditionally overwrites last heartbeat details regardless of whether they were actually set on the fail request.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        2354,
        293
      ],
      "keyQuote": "Test server should not overwrite last heartbeat details on activity failure unless it is actually set",
      "number": 2459,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:57.616Z"
    },
    {
      "summary": "Add annotations to Java workflows to support the new versioning APIs introduced in the Temporal SDK. This aligns Java with the Go SDK implementation and enables developers to use the new worker versioning features.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "workflow-annotations",
        "versioning-api",
        "worker"
      ],
      "concepts": [
        "versioning",
        "api-design",
        "workflow-definition",
        "backwards-compatibility",
        "sdk-alignment"
      ],
      "severity": "medium",
      "userImpact": "Java developers will be able to leverage the new worker versioning APIs to manage workflow updates and deprecations more effectively.",
      "rootCause": null,
      "proposedFix": "Add annotations to workflows following the design documented in the shared Google document and align with Go SDK equivalents.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented with new worker versioning annotations for Java workflows",
      "related": [
        548
      ],
      "keyQuote": "We need to add annotations to workflows to support the new versioning APIs. Refer to temporalio/features#548 for the Go equivalents.",
      "number": 2458,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:09:00.722Z"
    },
    {
      "summary": "Workflow StartDelay is not being respected when using TestWorkflowEnvironment, regardless of time skipping settings. When time skipping is disabled, no actual delay occurs before workflow starts, and when enabled, no timer is created.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-options",
        "time-skipping"
      ],
      "concepts": [
        "start-delay",
        "timer",
        "test-execution",
        "time-handling",
        "workflow-initialization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test workflows with start delays using the test environment, making it difficult to validate timing-dependent workflow behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Duplicate of issue #1692",
      "related": [
        1692
      ],
      "keyQuote": "there is already an issue to track this",
      "number": 2451,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:59.000Z"
    },
    {
      "summary": "GenericWorkflowClient creates a non-daemon thread (asyncThrottlerExecutor) that prevents JVM shutdown. The thread is never terminated, blocking natural process exit unless System.exit() is called.",
      "category": "bug",
      "subcategory": "client-lifecycle",
      "apis": [
        "GenericWorkflowClient"
      ],
      "components": [
        "GenericWorkflowClient",
        "asyncThrottlerExecutor",
        "thread-management"
      ],
      "concepts": [
        "thread-termination",
        "jvm-shutdown",
        "daemon-threads",
        "resource-cleanup",
        "process-exit"
      ],
      "severity": "high",
      "userImpact": "Applications using GenericWorkflowClient cannot exit gracefully and require System.exit() to terminate the JVM.",
      "rootCause": "The asyncThrottlerExecutor thread in GenericWorkflowClient is created as a non-daemon thread with no shutdown mechanism.",
      "proposedFix": null,
      "workaround": "Call System.exit(0) manually to force JVM termination.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by making the asyncThrottlerExecutor thread a daemon thread or implementing proper shutdown.",
      "related": [],
      "keyQuote": "Once the asyncThrottlerExecutor in that class has started a thread, there is no mechanism to terminate it, and the JVM will not exit",
      "number": 2450,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:43.433Z"
    },
    {
      "summary": "Spring Boot integration feature request to auto-configure ScheduleClient instances per namespace, similar to how WorkflowClient is injected, eliminating the need for manual namespace configuration.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "ScheduleClient",
        "WorkflowClient",
        "ScheduleClientOptions"
      ],
      "components": [
        "spring-boot-starter",
        "schedule-client",
        "client-options"
      ],
      "concepts": [
        "dependency-injection",
        "namespace-configuration",
        "client-factory",
        "spring-resource"
      ],
      "severity": "low",
      "userImpact": "Spring Boot users must manually create and inject separate ScheduleClient instances for each namespace instead of using autowired beans like with WorkflowClient.",
      "rootCause": null,
      "proposedFix": "Add Spring Boot auto-configuration to create ScheduleClient beans pre-configured with namespace from application properties, allowing direct injection like WorkflowClient.",
      "workaround": "Manually create ScheduleClient instances using newInstance() with ScheduleClientOptions and explicitly set namespace from WorkflowClient options.",
      "resolution": "fixed",
      "resolutionDetails": "Spring Boot starter was updated to support automatic ScheduleClient bean creation with namespace pre-configuration.",
      "related": [],
      "keyQuote": "Ask is to configure this based on configured namespace so can just do similar to WorkflowClient",
      "number": 2449,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:46.128Z"
    },
    {
      "summary": "SpringBoot configuration documentation states that HTTPS is automatically enabled when an API key is specified, but testing shows that HTTPS is not enabled unless explicitly set with enable-https: true.",
      "category": "docs",
      "subcategory": "springboot-configuration",
      "apis": [],
      "components": [
        "springboot-configuration",
        "https-configuration",
        "api-key-handling"
      ],
      "concepts": [
        "https",
        "api-key",
        "configuration",
        "documentation",
        "auto-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users following documentation expecting automatic HTTPS enablement with API keys must manually set enable-https: true, causing confusion and potential misconfiguration.",
      "rootCause": "Documentation claims automatic HTTPS enablement that does not actually occur in the implementation",
      "proposedFix": null,
      "workaround": "Explicitly set enable-https: true in SpringBoot configuration even when API key is defined",
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, likely indicating documentation was corrected or implementation was fixed to match documented behavior",
      "related": [],
      "keyQuote": "docs mention that \"If an API key is specified, https will automatically be enabled.\" after testing it seems that its not automatically set",
      "number": 2443,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:46.270Z"
    },
    {
      "summary": "Request to add a summary field to Nexus operations in the Java SDK, aligning with feature specifications defined in the cross-repository features issue.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [
        "Nexus"
      ],
      "components": [
        "nexus",
        "operation",
        "java-sdk"
      ],
      "concepts": [
        "summary",
        "metadata",
        "operation-definition",
        "feature-parity",
        "api-enhancement"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to add descriptive summaries to Nexus operations, improving metadata and discoverability across the platform.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of Nexus operation enhancements to match feature specifications.",
      "related": [
        610
      ],
      "keyQuote": "Add summary to Nexus operation",
      "number": 2442,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:28.056Z"
    },
    {
      "summary": "Spring Boot initialization should fail when duplicate activity names are registered on a worker, matching the behavior of normal workers. Currently, it only logs a warning instead of throwing an error.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot",
        "worker",
        "activity-registration"
      ],
      "concepts": [
        "activity-registration",
        "duplicate-detection",
        "error-handling",
        "initialization",
        "spring-boot-integration"
      ],
      "severity": "high",
      "userImpact": "Users can accidentally register duplicate activities in Spring Boot without detection, leading to unpredictable behavior and potential runtime errors.",
      "rootCause": "Spring Boot auto-discovery logs a warning instead of failing initialization when duplicate activity names are detected, unlike normal workers which throw an error.",
      "proposedFix": "Make Spring Boot worker initialization fail with an error message matching normal worker behavior when duplicate activity names are detected.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This bit us as well and can lead to dangerous behavior.",
      "number": 2434,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:30.324Z"
    },
    {
      "summary": "Add getStaticSummary() and getStaticDetails() methods to WorkflowExecutionDescription to expose static workflow metadata from the describe operation, separate from the base WorkflowExecutionMetadata class used by listExecutions.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [
        "describe",
        "WorkflowExecutionDescription",
        "WorkflowExecutionMetadata",
        "listExecutions"
      ],
      "components": [
        "workflow-execution",
        "metadata",
        "visibility"
      ],
      "concepts": [
        "user-metadata",
        "workflow-description",
        "static-information",
        "API-exposure"
      ],
      "severity": "low",
      "userImpact": "Users can access static workflow summary and details through the describe API, enabling richer workflow execution information retrieval.",
      "rootCause": null,
      "proposedFix": "Add getStaticSummary() and getStaticDetails() methods to WorkflowExecutionDescription class",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Methods were added to WorkflowExecutionDescription to expose static summary and details as requested",
      "related": [],
      "keyQuote": "we should have `getStaticSummary()` and `getStaticDetails()` on the result of `describe` which is `WorkflowExecutionDescription`",
      "number": 2432,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:31.661Z"
    },
    {
      "summary": "Request to expose the root workflow execution in the Java SDK, allowing users to access context about the parent workflow execution when running in a child workflow context.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-context",
        "child-workflow"
      ],
      "concepts": [
        "workflow-execution",
        "parent-workflow",
        "workflow-context",
        "execution-metadata"
      ],
      "severity": "medium",
      "userImpact": "Users working with child workflows cannot currently access information about the root workflow execution, limiting visibility into the overall execution hierarchy.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to expose root workflow execution metadata in child workflow context",
      "related": [
        605
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/605",
      "number": 2430,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:15.121Z"
    },
    {
      "summary": "Built-in query responses should be updated to use RawValue format once related work is completed. This is a follow-up to issue #2425 to ensure consistency with the features specification.",
      "category": "feature",
      "subcategory": "query-responses",
      "apis": [
        "Query"
      ],
      "components": [
        "query-handler",
        "response-serialization"
      ],
      "concepts": [
        "raw-value",
        "query-response",
        "serialization",
        "built-in-queries",
        "type-handling"
      ],
      "severity": "medium",
      "userImpact": "Users will have more consistent and predictable query response handling with proper RawValue encoding.",
      "rootCause": null,
      "proposedFix": "Update built-in query responses to return raw values as specified in features/issues/604",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Built-in queries were updated to use RawValue format following completion of the related work in issue #2425",
      "related": [
        2425,
        604
      ],
      "keyQuote": "When #2425 is done, make sure built-in queries return a raw value",
      "number": 2426,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:14.030Z"
    },
    {
      "summary": "Request to add a RawValue payload wrapper that tells converters not to apply conversion, allowing users to pass non-converted values directly without SDK transformation.",
      "category": "feature",
      "subcategory": "payload-conversion",
      "apis": [],
      "components": [
        "payload-converter",
        "serialization",
        "workflow-execution"
      ],
      "concepts": [
        "conversion",
        "serialization",
        "payload-wrapper",
        "type-safety",
        "direct-values"
      ],
      "severity": "medium",
      "userImpact": "Users need a way to pass raw, non-converted values through the SDK without automatic conversion being applied.",
      "rootCause": null,
      "proposedFix": "Implement a simple payload wrapper type that signals converters to skip conversion for wrapped values",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "RawValue wrapper was implemented to support non-converted payload values",
      "related": [
        603
      ],
      "keyQuote": "need a simple payload wrapper that tells converters not to apply conversion",
      "number": 2425,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:16.695Z"
    },
    {
      "summary": "Remove support for the old workflow run operation token format and treat all unparseable tokens as handler errors. Also remove any remaining support for operation IDs.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-runner",
        "operation-token-handler",
        "token-parser"
      ],
      "concepts": [
        "token-format",
        "backwards-compatibility",
        "error-handling",
        "operation-id",
        "workflow-state"
      ],
      "severity": "medium",
      "userImpact": "Users will need to migrate away from old operation token formats, as the SDK will no longer support them.",
      "rootCause": "Legacy support for old workflow run operation token format and operation IDs needs to be removed for code simplification.",
      "proposedFix": "Remove old workflow run operation token format support and treat all unparseable tokens as handler errors; remove operation ID support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The old workflow run operation token format and operation ID support have been removed from the Java SDK.",
      "related": [],
      "keyQuote": "Remove old workflow run operation token format support, treat all un-parsable tokens as a handler error",
      "number": 2423,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:59.203Z"
    },
    {
      "summary": "The temporal-serviceclient library uses GeneratedMessageV3 which is deprecated and removed in protobuf-java 4.x, causing NoSuchMethodError at runtime when used with protobuf 4.x despite documentation claiming compatibility.",
      "category": "bug",
      "subcategory": "dependency-compatibility",
      "apis": [
        "Payload.parseFrom"
      ],
      "components": [
        "temporal-serviceclient",
        "protobuf-java",
        "payload-codec"
      ],
      "concepts": [
        "compatibility",
        "dependency-version",
        "protobuf-migration",
        "generated-code",
        "api-version",
        "runtime-error"
      ],
      "severity": "high",
      "userImpact": "Users cannot use temporal-serviceclient with protobuf-java 4.x due to runtime NoSuchMethodError exceptions, forcing them to stay on protobuf 3.x versions.",
      "rootCause": "Generated protobuf classes extend the deprecated GeneratedMessageV3 class which was removed in protobuf-java 4.x, causing missing methods like makeExtensionsImmutable().",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The head of master is compatible with protobuf v4; v1.28.0 release and snapshot builds will include the fix.",
      "related": [],
      "keyQuote": "The head of master is compatible with protobuf v4, `v1.27.1` is not. The next release `v1.28.0` will be compatible",
      "number": 2420,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:02.835Z"
    },
    {
      "summary": "The workflow_task_execution_failed metric is missing the failure_reason tag in some cases. This inconsistency makes it difficult to diagnose task failures through metrics.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "workflow-task-executor",
        "error-handling"
      ],
      "concepts": [
        "observability",
        "metrics-tagging",
        "failure-tracking",
        "error-reporting"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably use the workflow_task_execution_failed metric for monitoring and debugging because the failure_reason tag is inconsistently present.",
      "rootCause": "There appears to be a code path where task failures are reported without properly setting the failure_reason tag, likely in an exception catch clause.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "workflow_task_execution_failed metric sometimes doesn't have `failure_reason` tag",
      "number": 2418,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:08:02.188Z"
    },
    {
      "summary": "Add support for exposing workflow cancellation cause/reason to workflows receiving cancels, and allow users to provide this information when issuing cancels from clients or commands.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [
        "WorkflowExecutionCancelRequestedEventAttributes"
      ],
      "components": [
        "workflow-runtime",
        "cancel-handler",
        "client-api"
      ],
      "concepts": [
        "cancellation",
        "cause",
        "reason",
        "workflow-lifecycle",
        "event-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot see the reason why a workflow was cancelled, making debugging and auditing workflow cancellations difficult.",
      "rootCause": "The cause field exists in WorkflowExecutionCancelRequestedEventAttributes but is not exposed through the Java SDK API.",
      "proposedFix": "Expose the cause field when workflows receive cancels and as an input parameter when users issue cancels from clients or commands.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The cause field from WorkflowExecutionCancelRequestedEventAttributes has been exposed to running workflows and is now available when issuing cancellations.",
      "related": [],
      "keyQuote": "WorkflowExecutionCancelRequestedEventAttributes has a cause field that should be exposed when workflows receive cancels",
      "number": 2414,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:44.210Z"
    },
    {
      "summary": "Adding a new parameter of generic type List to a workflow input causes the data converter to fail with a ClassCastException during replay, while non-generic parameters work correctly. This is a bug in Java's inconsistent handling of generic vs non-generic parameter types.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "WorkflowMethod"
      ],
      "components": [
        "data-converter",
        "workflow-implementation-factory",
        "parameter-handling"
      ],
      "concepts": [
        "generic-types",
        "backwards-compatibility",
        "workflow-replay",
        "type-casting",
        "payload-conversion"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely add new generic type parameters to workflow methods without breaking replay of existing workflow executions.",
      "rootCause": "Java's data converter does not properly handle ParameterizedType (generic types) when deserializing workflow parameters, attempting to cast it to Class instead of handling it as a generic type.",
      "proposedFix": "Fix the data converter to consistently handle both generic and non-generic parameter types during deserialization.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The bug was acknowledged and fixed to handle generic types consistently with non-generic types in the data converter.",
      "related": [],
      "keyQuote": "we do allow extra non-generic parameters, we just don't allow generic parameters due to a bug. we should fix it to be consistent",
      "number": 2413,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:46.296Z"
    },
    {
      "summary": "Marker commands are being sent to the server with empty names, causing BadRecordMarkerAttributes errors on workflow completion. The issue appears to occur when a marker command is constructed during replay, then sent after replay transitions to false.",
      "category": "bug",
      "subcategory": "marker-commands",
      "apis": [
        "RecordMarkerCommand"
      ],
      "components": [
        "marker-handler",
        "command-builder",
        "replay-logic"
      ],
      "concepts": [
        "replay-mode",
        "state-transition",
        "marker-name-validation",
        "command-construction"
      ],
      "severity": "high",
      "userImpact": "Users encounter workflow completion failures with BadRecordMarkerAttributes errors when marker commands have empty names.",
      "rootCause": "Marker command constructed during replay may be sent after replay flag becomes false, resulting in empty marker names being transmitted.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1838,
        1558
      ],
      "keyQuote": "the only way it seemed like this might happen is if the marker command was constructed while replaying was true, and then it later became false and sent off the command",
      "number": 2412,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:48.059Z"
    },
    {
      "summary": "Feature request to add ARM64 (Mac and Linux) distribution support for temporal-test-server, which is currently only available for AMD64. This is needed to access the start_time_skipping test environment for validating wait_condition behavior on ARM64-based Macs.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "temporal-test-server",
        "build-distribution",
        "testing-tools"
      ],
      "concepts": [
        "ARM64-support",
        "platform-compatibility",
        "test-environment",
        "time-skipping",
        "cross-platform-builds"
      ],
      "severity": "medium",
      "userImpact": "ARM64 Mac users cannot access time-skipping test environment functionality, limiting their ability to validate wait_condition behavior.",
      "rootCause": "temporal-test-server releases only include AMD64 binaries, not ARM64 builds",
      "proposedFix": "Add ARM64 Linux and Mac distribution builds to temporal-test-server releases",
      "workaround": "Run Linux containers with amd64 platform emulation, though this causes compatibility issues with ARM64-dependent packages",
      "resolution": "fixed",
      "resolutionDetails": "Team confirmed this is a priority and indicated work is underway to change the test server build to support ARM64",
      "related": [],
      "keyQuote": "Yes this is something we would like to support, hopefully in the very near future. Currently working on changing the test server build to support this.",
      "number": 2404,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:30.585Z"
    },
    {
      "summary": "Add support for musl-based test server binary in Java SDK releases. The test server should be distributed as an asset with a clear naming convention for use with temporal.download.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "binary-distribution",
        "temporal.download"
      ],
      "concepts": [
        "musl-libc",
        "test-infrastructure",
        "build-compatibility",
        "binary-distribution",
        "platform-support",
        "ci-testing"
      ],
      "severity": "medium",
      "userImpact": "Users can run tests with musl-based test server binary, enabling testing in musl-based environments.",
      "rootCause": null,
      "proposedFix": "Distribute a musl-based test server binary as a named asset alongside Java SDK releases for use with temporal.download.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "musl-based test server binary was added to Java SDK release assets with appropriate naming for temporal.download compatibility.",
      "related": [
        594
      ],
      "keyQuote": "support a musl-based test server binary in the assets with an obvious name that can be used by `temporal.download`",
      "number": 2402,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:31.342Z"
    },
    {
      "summary": "Request to add support for attaching priority to workflows and activities in the Java SDK. This feature aligns with the broader Temporal feature set described in a cross-repository feature request.",
      "category": "feature",
      "subcategory": "workflow-priority",
      "apis": [],
      "components": [
        "workflow-definition",
        "activity-definition",
        "annotation-processor"
      ],
      "concepts": [
        "priority",
        "scheduling",
        "workflow-metadata",
        "annotation",
        "task-routing",
        "execution-order"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to specify priority levels for workflows and activities, enabling better control over execution scheduling and task routing.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented priority annotation support for workflows and activities",
      "related": [
        593
      ],
      "keyQuote": "Add support for attaching priority to workflows/activities",
      "number": 2399,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:27.759Z"
    },
    {
      "summary": "Request to provide native OpenTelemetry-based tracing support instead of relying on the OpenTracing shim. Currently the Java SDK uses OpenTracing with an OpenTelemetry adapter, but a direct OpenTelemetry integration module would be more straightforward.",
      "category": "feature",
      "subcategory": "tracing-observability",
      "apis": [],
      "components": [
        "tracing",
        "observability",
        "opentelemetry"
      ],
      "concepts": [
        "distributed-tracing",
        "instrumentation",
        "observability",
        "opentelemetry",
        "shim",
        "adapter",
        "direct-integration"
      ],
      "severity": "medium",
      "userImpact": "Users would have cleaner, more direct OpenTelemetry integration without relying on the OpenTracing shim layer.",
      "rootCause": null,
      "proposedFix": "Create a dedicated module providing native OpenTelemetry-based tracing support",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Could we simply have a module using opentelemetry directly?",
      "number": 2394,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:15.720Z"
    },
    {
      "summary": "Add `patched()` and `deprecatePatch()` APIs to the Java SDK for managing workflow versioning and patching, following Core's implementation pattern. May also deprecate the existing `GetVersion` API.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "Workflow.patched",
        "Workflow.deprecatePatch",
        "GetVersion"
      ],
      "components": [
        "workflow-runtime",
        "versioning-system",
        "api-surface"
      ],
      "concepts": [
        "workflow-patching",
        "versioning",
        "backward-compatibility",
        "memoization",
        "deprecation",
        "sdk-parity"
      ],
      "severity": "medium",
      "userImpact": "Users will have new APIs for managing workflow code changes and deprecation strategies, enabling safer workflow evolution.",
      "rootCause": null,
      "proposedFix": "Implement `patched()` and `deprecatePatch()` APIs following Core's implementation, with optional memoization support.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        591
      ],
      "keyQuote": "Add the `boolean Workflow.patched(String patchId, boolean memoized)` and `Workflow.deprecatePatch(String patchId, boolean memoized)` APIs.",
      "number": 2393,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:14.656Z"
    },
    {
      "summary": "Test environment sleep hangs when executing workflows with async child workflows started via startChild(). The same test passes when using start() instead of execute(), indicating a time-skipping test server issue with child workflow handling.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "startChild",
        "execute"
      ],
      "components": [
        "time-skipping-test-server",
        "workflow-executor",
        "child-workflow-handler"
      ],
      "concepts": [
        "test-environment",
        "time-skipping",
        "child-workflows",
        "async-execution",
        "test-hanging",
        "workflow-state"
      ],
      "severity": "high",
      "userImpact": "Developers cannot reliably test workflows with child workflows using the time-skipping test environment, blocking testing of common workflow patterns.",
      "rootCause": "Time skipping test server has an issue handling sleep calls when workflows contain child workflows started with startChild()",
      "proposedFix": null,
      "workaround": "Use start() instead of execute() to work around the hanging issue",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "After starting the workflow with `execute` calling sleep on the time skipping TestWorkflowEnvironment seems to hang despite the child workflow having finished.",
      "number": 2392,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:07:13.993Z"
    },
    {
      "summary": "Cancelling an activity in the same workflow task where it completes causes the time-skipping test server to return an ACTIVITY_UNKNOWN error and get stuck, while the official server handles this gracefully.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "workflow-activation",
        "activity-cancellation"
      ],
      "concepts": [
        "activity-cancellation",
        "workflow-task-execution",
        "error-handling",
        "time-skipping",
        "signal-handler"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test workflows that cancel activities using the time-skipping test server, as it gets stuck with ACTIVITY_UNKNOWN errors.",
      "rootCause": "The test server may fail to send a subsequent workflow task after denying the workflow task completion due to attempting to cancel an unknown activity.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "the workflow get stuck, and the following error message is being displayed: Network error while completing workflow activation error=status: FailedPrecondition, message: \"ACTIVITY_UNKNOWN for scheduledEventId=41\"",
      "number": 2391,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:57.811Z"
    },
    {
      "summary": "User requests testing support for Schedules in Java SDK without requiring a server instance, similar to TestWorkflowEnvironment.createLocal() available in TypeScript SDK.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "testing",
        "schedules"
      ],
      "concepts": [
        "testing",
        "local-environment",
        "schedules",
        "development",
        "test-isolation"
      ],
      "severity": "medium",
      "userImpact": "Developers must run a full server instance to test Schedules, increasing development friction and test complexity.",
      "rootCause": null,
      "proposedFix": "Implement TestScheduleEnvironment or createLocal method for local Schedule testing without server dependency",
      "workaround": "Run temporal CLI with `temporal server start-dev` as a subprocess",
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of #1804 which requests local testing environment support across SDKs",
      "related": [
        1804
      ],
      "keyQuote": "It may not be reasonable to put an entire reimplementation of schedules in each SDK",
      "number": 2388,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:58.146Z"
    },
    {
      "summary": "Request to implement special behavior for Temporal built-in prefixes in the Java SDK, as described in the features repository issue #576.",
      "category": "feature",
      "subcategory": "naming-conventions",
      "apis": [],
      "components": [
        "sdk-core",
        "configuration"
      ],
      "concepts": [
        "naming-conventions",
        "built-in-prefixes",
        "feature-alignment"
      ],
      "severity": "low",
      "userImpact": "Users will have standardized behavior for Temporal built-in prefixes across all SDKs.",
      "rootCause": null,
      "proposedFix": "Implement special handling for Temporal built-in prefixes as specified in temporalio/features#576",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed after implementation of built-in prefix handling behavior",
      "related": [
        576
      ],
      "keyQuote": "Special behavior for Temporal built-in prefixes",
      "number": 2368,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:53.034Z"
    },
    {
      "summary": "Removing a Workflow.getVersion call while keeping a following Workflow.sideEffect causes a NullDataException (NDE) during workflow replay. The issue occurs because the state machine expects a SideEffect marker but receives a Version marker instead after getVersion removal.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.getVersion",
        "Workflow.sideEffect",
        "Workflow.newActivityStub"
      ],
      "components": [
        "state-machine",
        "side-effect-executor",
        "version-management",
        "workflow-replay"
      ],
      "concepts": [
        "workflow-replay",
        "state-machine",
        "marker-mismatch",
        "version-removal",
        "sideEffect",
        "history-reconciliation"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely remove Workflow.getVersion calls from workflows with subsequent sideEffect operations without encountering runtime errors during replay.",
      "rootCause": "The SideEffectStateMachine expects markers in the workflow history to match the current workflow code execution order. When getVersion is removed but sideEffect remains, the state machine encounters a Version marker where it expects a SideEffect marker, causing an IllegalStateException.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating a fix was implemented to properly handle getVersion removal when followed by sideEffect operations.",
      "related": [],
      "keyQuote": "Expected SideEffect, received: marker_name: \"Version\" - workflow_task_completed_event_id: 3",
      "number": 2367,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:39.606Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not properly set search attributes when using ContinueAsNewOptions. Setting typed search attributes via ContinueAsNewOptions.setTypedSearchAttributes() or the deprecated setSearchAttributes() method does not carry over to the continued workflow execution.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ContinueAsNewOptions",
        "SearchAttributes"
      ],
      "components": [
        "test-workflow-environment",
        "continue-as-new",
        "search-attributes"
      ],
      "concepts": [
        "workflow-continuation",
        "search-attributes",
        "test-environment",
        "workflow-options",
        "state-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test workflow continuations with search attributes in test environments, limiting their ability to validate search attribute behavior in continued workflows.",
      "rootCause": "TestWorkflowEnvironment does not properly propagate search attributes from ContinueAsNewOptions to the continued workflow execution",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2178
      ],
      "keyQuote": "When using TestWorkflowEnvironment setting search attributes in ContinueAsNewOptions does not set them with the continued exec",
      "number": 2364,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:40.040Z"
    },
    {
      "summary": "Users should be able to access a Temporal client from within activity code via the ActivityExecutionContext. This would provide a way to interact with the Temporal API directly from activities, similar to workflow context capabilities.",
      "category": "feature",
      "subcategory": "activity-context",
      "apis": [
        "ActivityExecutionContext",
        "WorkflowClient"
      ],
      "components": [
        "activity-executor",
        "context",
        "client-api"
      ],
      "concepts": [
        "client-access",
        "activity-context",
        "api-availability",
        "temporal-operations",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Activities currently cannot directly access a Temporal client, limiting their ability to perform temporal operations without external configuration.",
      "rootCause": null,
      "proposedFix": "Add a `getWorkflowClient() WorkflowClient` instance method to ActivityExecutionContext",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide client access from activity context",
      "related": [
        203
      ],
      "keyQuote": "Allow users to access Temporal client from within an activity. This is likely a `getWorkflowClient() WorkflowClient` instance method on `ActivityExecutionContext`.",
      "number": 2362,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:36.416Z"
    },
    {
      "summary": "Request to provide access to workflow and activity instances from their respective contexts through methods like ActivityExecutionContext.getInstance() and Workflow.getInstance(), enabling better context inspection and debugging capabilities.",
      "category": "feature",
      "subcategory": "context-api",
      "apis": [
        "ActivityExecutionContext",
        "Workflow"
      ],
      "components": [
        "activity-context",
        "workflow-context",
        "execution-context"
      ],
      "concepts": [
        "instance-access",
        "context-inspection",
        "workflow-metadata",
        "activity-metadata",
        "debugging",
        "api-enhancement"
      ],
      "severity": "low",
      "userImpact": "Users would be able to access workflow and activity instances directly from their execution contexts for inspection and debugging purposes.",
      "rootCause": null,
      "proposedFix": "Add getInstance() instance method to ActivityExecutionContext and getInstance() static method to Workflow class",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide the requested context access methods",
      "related": [
        572
      ],
      "keyQuote": "Provide access to the Temporal created/owned workflow and activity instance from their respective contexts",
      "number": 2361,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:20.913Z"
    },
    {
      "summary": "The `UnableToAcquireLockException` error message lacks clarity and context that would help users understand the issue. A PR improves the exception message to provide better guidance based on community feedback and clarification from maintainers.",
      "category": "docs",
      "subcategory": "exception-messaging",
      "apis": [],
      "components": [
        "exception-handling",
        "documentation"
      ],
      "concepts": [
        "error-messaging",
        "lock-acquisition",
        "user-guidance",
        "clarity"
      ],
      "severity": "low",
      "userImpact": "Users encountering `UnableToAcquireLockException` receive unclear error messages that don't help them understand the root cause or resolution.",
      "rootCause": null,
      "proposedFix": "Improve the `UnableToAcquireLockException` error message to include context and guidance, as addressed in PR #2360",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2360
      ],
      "keyQuote": "I suspect Kapa could have given better direction if this exception message contained the info that Tiho corrected with.",
      "number": 2359,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:24.306Z"
    },
    {
      "summary": "Add support for Nexus Error rehydration in the Java SDK, matching the functionality implemented in the Go SDK (PR #1751).",
      "category": "feature",
      "subcategory": "nexus-error-handling",
      "apis": [],
      "components": [
        "nexus",
        "error-handling",
        "serialization"
      ],
      "concepts": [
        "error-rehydration",
        "nexus-integration",
        "cross-sdk-parity",
        "error-recovery"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly rehydrate and handle Nexus errors in the Java SDK, limiting error handling capabilities compared to other SDKs.",
      "rootCause": null,
      "proposedFix": "Implement Nexus Error rehydration following the pattern established in the Go SDK PR #1751.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support Nexus Error rehydration in alignment with Go SDK implementation.",
      "related": [],
      "keyQuote": "Add support for Nexus Error rehydration.",
      "number": 2358,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:22.567Z"
    },
    {
      "summary": "WorkflowLock.tryLock creates unnecessary timers even when the lock is immediately available, potentially impacting performance and Temporal Cloud costs. The issue requests short-circuiting execution to avoid calling Workflow.await if the lock is already acquired.",
      "category": "other",
      "subcategory": "workflow-synchronization",
      "apis": [
        "WorkflowLock.tryLock",
        "Workflow.await"
      ],
      "components": [
        "workflow-lock",
        "timer-management",
        "history"
      ],
      "concepts": [
        "timer-optimization",
        "performance",
        "locking",
        "condition-evaluation",
        "cloud-costs"
      ],
      "severity": "medium",
      "userImpact": "Users may experience unnecessary performance overhead and increased costs on Temporal Cloud due to redundant timer creation in WorkflowLock.tryLock calls.",
      "rootCause": "WorkflowLock.tryLock unconditionally calls Workflow.await even when the lock is immediately available, creating timers that get saved to workflow history unnecessarily.",
      "proposedFix": "Short-circuit execution by checking if the lock is available before calling Workflow.await; only create timers when actually waiting for the lock.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #2312, which tracks the broader change to Workflow.await to not create timers when conditions are immediately satisfied.",
      "related": [
        2312
      ],
      "keyQuote": "a new timer is created and saved to WF history (which can potentially affect performance and probably costs in temporal cloud)",
      "number": 2350,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:07.367Z"
    },
    {
      "summary": "Local activity queue stops processing tasks when thread allocation fails due to OutOfMemoryError, causing a silent deadlock in the local activity worker while the rest of the system continues running. The queue callback only catches InterruptedException, allowing the OutOfMemoryError to propagate and terminate the queue processing thread.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "LocalActivitySlotSupplierQueue",
        "LocalActivityWorker",
        "PollTaskExecutor",
        "ThreadPoolExecutor"
      ],
      "concepts": [
        "thread-allocation",
        "out-of-memory",
        "deadlock",
        "exception-handling",
        "task-queue",
        "resource-exhaustion"
      ],
      "severity": "high",
      "userImpact": "Users experience silent deadlocks in local activity processing when the JVM runs out of memory for thread stack allocation, with no error messages and no graceful degradation.",
      "rootCause": "The #processQueue method in LocalActivitySlotSupplierQueue only catches InterruptedException when applying the afterReservedCallback, allowing OutOfMemoryError from ThreadPoolExecutor#execute to propagate uncaught and terminate the queue processing thread, halting all local activity task processing.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The local activity task queue stops processing any tasks that go into it, and the overall local activity worker machinery deadlocks.",
      "number": 2349,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:08.635Z"
    },
    {
      "summary": "ManualActivityCompletionClient performs unlimited retries on non-retryable errors like gRPC message size exceeding limits. When completing an async activity with a payload larger than 4MB, the client retries instead of failing fast.",
      "category": "bug",
      "subcategory": "manual-activity-completion",
      "apis": [
        "ManualActivityCompletionClient"
      ],
      "components": [
        "manual-activity-completion",
        "retry-logic",
        "error-handling"
      ],
      "concepts": [
        "retry",
        "non-retryable-error",
        "payload-size",
        "grpc",
        "async-activity",
        "error-classification"
      ],
      "severity": "high",
      "userImpact": "Users attempting to complete async activities with large payloads experience unnecessary retries instead of immediate failure, delaying error visibility and wasting resources.",
      "rootCause": "ManualActivityCompletionClient lacks proper error classification to distinguish retryable from non-retryable errors, specifically for gRPC message size constraint violations.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of temporalio/temporal#6806, indicating the issue should be tracked in the main Temporal repository.",
      "related": [
        6806
      ],
      "keyQuote": "ManualActivityCompletionClient shouldn't retry the non-retryable errors: GRPC: received message larger than max (5243998 vs. 4194304)",
      "number": 2346,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:06:10.180Z"
    },
    {
      "summary": "Proposal to rename WorkflowStub.update to WorkflowStub.executeUpdate in the Java SDK to align with naming conventions used across all Temporal SDKs, where 'execute' methods return results.",
      "category": "other",
      "subcategory": "api-design",
      "apis": [
        "WorkflowStub.update",
        "WorkflowStub.executeUpdate"
      ],
      "components": [
        "workflow-stub",
        "untyped-stub",
        "java-sdk"
      ],
      "concepts": [
        "naming-consistency",
        "sdk-alignment",
        "api-design",
        "execute-pattern",
        "semantic-clarity"
      ],
      "severity": "low",
      "userImpact": "Improves consistency within Java SDK and across all Temporal SDKs, making API naming more intuitive and reducing confusion.",
      "rootCause": null,
      "proposedFix": "Rename WorkflowStub.update method to WorkflowStub.executeUpdate to follow the established naming pattern where 'executeXXX' returns results and 'startXXX' returns handles.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Team decided it is too late to make this breaking change to the Java SDK API.",
      "related": [],
      "keyQuote": "We think it's too late.",
      "number": 2340,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:53.187Z"
    },
    {
      "summary": "A test called `taskTimeoutWillRescheduleTheTaskOnTheGlobalList` is flaky on the test server and doesn't pass consistently. The issue indicates a timing or race condition in the task timeout and rescheduling logic.",
      "category": "bug",
      "subcategory": "task-timeout",
      "apis": [],
      "components": [
        "test-server",
        "task-timeout",
        "task-scheduler"
      ],
      "concepts": [
        "timeout",
        "task-rescheduling",
        "flakiness",
        "race-condition",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Unreliable test results on the Temporal test server can mask real issues and reduce confidence in SDK functionality.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "taskTimeoutWillRescheduleTheTaskOnTheGlobalList doesn't always pass on the test server",
      "number": 2333,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:54.708Z"
    },
    {
      "summary": "GitHub Actions is enforcing Node16 EOL, requiring actions to use Node20. This breaks compatibility with GLIBC 2.27-based runners used to support older Linux distributions, potentially causing CI build failures in release workflows.",
      "category": "bug",
      "subcategory": "ci-build",
      "apis": [],
      "components": [
        "ci-pipeline",
        "github-actions",
        "test-server",
        "build-runner"
      ],
      "concepts": [
        "glibc-compatibility",
        "node-runtime",
        "linux-distro-support",
        "ci-infrastructure",
        "action-deprecation"
      ],
      "severity": "high",
      "userImpact": "CI build failures will prevent releases and updates to the Java SDK on systems running older Linux distributions.",
      "rootCause": "GitHub Actions enforced Node16 EOL, forcing actions to run on Node20. Node20 requires GLIBC 2.29+, incompatible with older GLIBC 2.27-based runners previously used.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the incompatibility was addressed or mitigated through infrastructure updates.",
      "related": [],
      "keyQuote": "the latest release of GHA's Runner agent ignores the fact that an action is requesting node16, and instead just calls node20 anyway",
      "number": 2331,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:55.367Z"
    },
    {
      "summary": "User requested a way to mock Workflow.currentTimeMillis() in test environments. The issue was resolved by pointing out the existing setInitialTime() method in TestEnvironmentOptions.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.currentTimeMillis",
        "TestWorkflowEnvironment",
        "TestEnvironmentOptions"
      ],
      "components": [
        "test-framework",
        "workflow-runtime",
        "time-management"
      ],
      "concepts": [
        "mocking",
        "time-control",
        "test-environment",
        "thread-safety",
        "static-methods"
      ],
      "severity": "low",
      "userImpact": "Users can now easily control time in test workflows using setInitialTime() instead of attempting complex Mockito mocking workarounds.",
      "rootCause": "User was unaware of the existing setInitialTime() method in TestEnvironmentOptions for controlling workflow time in tests.",
      "proposedFix": "Use TestEnvironmentOptions.newBuilder().setInitialTime(WORKFLOW_START_TIME) when creating TestWorkflowEnvironment",
      "workaround": "Create a wrapper around Workflow.currentTimeMillis() with conditional test mode logic",
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by the maintainer pointing out the existing setInitialTime() method which provides the exact functionality requested.",
      "related": [],
      "keyQuote": "To control the initial in the test environment use `setInitialTime`.",
      "number": 2329,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:39.387Z"
    },
    {
      "summary": "Add an interceptor for WorkflowClient.listExecutions API. The request also includes exposing the constructor of WorkflowExecutionMetadata for better flexibility.",
      "category": "feature",
      "subcategory": "client-interceptors",
      "apis": [
        "WorkflowClient.listExecutions",
        "WorkflowExecutionMetadata"
      ],
      "components": [
        "workflow-client",
        "interceptor-framework",
        "execution-metadata"
      ],
      "concepts": [
        "interceptor",
        "client-extension",
        "list-operations",
        "metadata",
        "api-extension"
      ],
      "severity": "low",
      "userImpact": "Users can now intercept and customize behavior of WorkflowClient.listExecutions operations for logging, monitoring, or other cross-cutting concerns.",
      "rootCause": null,
      "proposedFix": "Add interceptor support for listExecutions and expose WorkflowExecutionMetadata constructor",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide interceptor support for listExecutions and expose the WorkflowExecutionMetadata constructor",
      "related": [
        2326
      ],
      "keyQuote": "Add an interceptor for WorkflowClient.listExecutions. We should also expose the constructor of WorkflowExecutionMetadata",
      "number": 2328,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:39.754Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not allow signalWithStart when a workflow already exists, unlike standalone Temporal servers. This causes test failures when attempting to use signalWithStart on pre-existing workflows.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "signalWithStart",
        "WorkflowStub"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "testing",
        "workflow-client"
      ],
      "concepts": [
        "signal",
        "workflow-start",
        "test-compatibility",
        "server-parity",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Test developers cannot use signalWithStart with existing workflows in TestWorkflowEnvironment, forcing workarounds and limiting test scenarios compared to production server behavior.",
      "rootCause": "TestWorkflowEnvironment's signalWithStart implementation differs from standalone server's handling of existing workflows",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "TestWorkflowEnvironment should work the same as standalone server in this matter.",
      "number": 2321,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:41.612Z"
    },
    {
      "summary": "Add runtime validation to ensure update validator methods have matching parameter signatures with the update methods they validate. This prevents runtime errors from mismatched method signatures.",
      "category": "feature",
      "subcategory": "update-validation",
      "apis": [
        "UpdateHandler"
      ],
      "components": [
        "update-validator",
        "signature-validation",
        "runtime-checks"
      ],
      "concepts": [
        "method-signature",
        "parameter-matching",
        "validation",
        "runtime-check",
        "type-safety",
        "reflection"
      ],
      "severity": "medium",
      "userImpact": "Users could deploy incorrect validator implementations without catching signature mismatches until runtime.",
      "rootCause": null,
      "proposedFix": "Implement runtime validation that compares the parameter portion of the validator method signature against the update method signature it validates.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Runtime check was implemented to validate parameter signatures match between update validators and their corresponding update methods.",
      "related": [
        689
      ],
      "keyQuote": "We need to make sure at runtime the parameter portion of the signature of the validator matches the parameter portion of the signature of the update method it is validating.",
      "number": 2317,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:27.267Z"
    },
    {
      "summary": "Users may inadvertently leave MDC (Mapped Diagnostic Context) set after activity or nexus task execution, causing context to leak between unrelated tasks when thread pools are reused. The request is to automatically clear MDC context after each task completes.",
      "category": "feature",
      "subcategory": "logging-and-diagnostics",
      "apis": [],
      "components": [
        "task-executor",
        "activity-executor",
        "nexus-task-executor",
        "mdc-context"
      ],
      "concepts": [
        "context-leak",
        "thread-pool",
        "logging",
        "diagnostics",
        "resource-cleanup",
        "isolation"
      ],
      "severity": "medium",
      "userImpact": "Users experience context leakage between unrelated tasks when MDC is not properly cleared, potentially causing incorrect log context and confusing diagnostic information.",
      "rootCause": "Thread pool reuse without automatic MDC cleanup after task execution allows context set by one task to persist and affect subsequent unrelated tasks.",
      "proposedFix": "Automatically clear MDC context after each task (activity or nexus task) completes execution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "MDC context is now automatically cleared after each task execution to prevent leakage between unrelated tasks.",
      "related": [],
      "keyQuote": "Since the SDK may use thread pools to execute tasks this risks leaking context between unrelated tasks.",
      "number": 2314,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:24.284Z"
    },
    {
      "summary": "Workflow.await(duration, condition) should automatically cancel the timer when the condition is resolved early, rather than requiring users to manually manage cancellation scopes.",
      "category": "feature",
      "subcategory": "workflow-await",
      "apis": [
        "Workflow.await"
      ],
      "components": [
        "workflow-execution",
        "timer-management",
        "cancellation-scope"
      ],
      "concepts": [
        "timer-cancellation",
        "condition-resolution",
        "determinism",
        "workflow-control"
      ],
      "severity": "medium",
      "userImpact": "Users must currently manually implement cancellation scopes around await calls to cancel timers when conditions resolve, adding unnecessary boilerplate code.",
      "rootCause": null,
      "proposedFix": "Automatically cancel timers in Workflow.await() when the condition is satisfied, with SDK flag versioning to maintain determinism.",
      "workaround": "Users can manually wrap await calls in a cancellation scope to cancel the timer when the condition resolves.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflow.await(duration, condition) should automatically cancel the timer when the condition is resolved",
      "number": 2312,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:25.928Z"
    },
    {
      "summary": "Feature request to add WorkflowIdConflictPolicy support to ChildWorkflowOptions in the Java SDK. This option was added to WorkflowOptions but is not available for child workflows, though it requires Temporal Server support first.",
      "category": "feature",
      "subcategory": "child-workflow-options",
      "apis": [
        "ChildWorkflowOptions",
        "WorkflowOptions",
        "setWorkflowIdConflictPolicy"
      ],
      "components": [
        "child-workflow",
        "workflow-options",
        "api"
      ],
      "concepts": [
        "workflow-id-conflict",
        "child-workflow",
        "policy",
        "options-api"
      ],
      "severity": "low",
      "userImpact": "Users cannot set WorkflowIdConflictPolicy on child workflows, limiting workflow ID conflict handling capabilities.",
      "rootCause": "WorkflowIdConflictPolicy is not supported by Temporal Server for child workflows, blocking SDK-level exposure.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2055,
        558
      ],
      "keyQuote": "WorkflowIdConflictPolicy is not supported on Child workflows by the Temporal Server. The option would need to be supported by the Temporal Server before it could be exposed on the SDK.",
      "number": 2308,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:11.365Z"
    },
    {
      "summary": "Removing a Workflow.GetVersion call can cause NullDeferenceException when multiple parallel workflow threads are running, because GetVersion blocks the current thread and its removal changes execution order during replay.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.GetVersion",
        "Workflow.sleep",
        "Async.procedure"
      ],
      "components": [
        "workflow-execution",
        "replay-engine",
        "threading"
      ],
      "concepts": [
        "replay",
        "versioning",
        "multithreading",
        "execution-order",
        "determinism",
        "blocking"
      ],
      "severity": "high",
      "userImpact": "Developers cannot safely refactor workflows by removing GetVersion calls without risking NullDeferenceExceptions in production replays with concurrent threads.",
      "rootCause": "Workflow.GetVersion blocks the current thread; when removed, the execution order of parallel threads changes during replay, causing non-deterministic behavior.",
      "proposedFix": null,
      "workaround": "Do not remove Workflow.GetVersion calls from existing workflows.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This happens because Workflow.getVersion causes the current thread to block so when it is removed the order of execution can change.",
      "number": 2307,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:09.674Z"
    },
    {
      "summary": "Test environment hangs indefinitely when an unregistered activity is called, with scheduleToStartTimeout being ignored. Discussion clarifies that timeout applies to scheduling, not to activity type registration, leading to documentation clarification as the resolution.",
      "category": "docs",
      "subcategory": "test-framework",
      "apis": [
        "ScheduleToStartTimeout"
      ],
      "components": [
        "test-environment",
        "activity-execution",
        "task-queue"
      ],
      "concepts": [
        "timeout",
        "activity-registration",
        "task-scheduling",
        "worker-polling",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers using the test environment can experience indefinite hangs when activities aren't registered, and may misunderstand how ScheduleToStartTimeout applies to task scheduling vs activity type availability.",
      "rootCause": "User misunderstanding of the Temporal protocol: ScheduleToStartTimeout applies to the time between scheduling and a worker picking up the task, not to whether an activity type is registered. When an activity type isn't registered, workers still start the task (from the server's perspective) and then fail it.",
      "proposedFix": "Improve documentation to clarify that ScheduleToStartTimeout applies to task scheduling, not activity type registration, and explain how workers poll by task queue rather than activity type.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Behavior confirmed as working as designed. User determined this is a documentation issue rather than a product bug, closing in favor of community discussion.",
      "related": [],
      "keyQuote": "Workers poll for work by task queue, not by activity type. If a worker is listening on a task queue it can get any tasks assigned to that task queue.",
      "number": 2305,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:05:09.988Z"
    },
    {
      "summary": "Workflow implementations with non-default constructors that can be autowired by Spring fail in version 1.26.0 with an error about missing default constructor or @WorkflowInit annotation.",
      "category": "bug",
      "subcategory": "spring-integration",
      "apis": [],
      "components": [
        "workflow-implementation",
        "constructor-handling",
        "spring-integration"
      ],
      "concepts": [
        "dependency-injection",
        "constructor-injection",
        "spring-autowire",
        "initialization",
        "framework-integration"
      ],
      "severity": "high",
      "userImpact": "Spring developers cannot use constructor injection with Temporal workflows, forcing them to use alternative dependency injection patterns or upgrade their Spring Boot setup.",
      "rootCause": "The SDK appears to be requiring either a default constructor or a @WorkflowInit annotation, not recognizing Spring's autowired non-default constructors as valid initialization paths.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved in a later version after the 1.26.0 release.",
      "related": [],
      "keyQuote": "No default constructor or constructor annotated with @WorkflowInit found",
      "number": 2299,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:53.608Z"
    },
    {
      "summary": "The Spring Boot integration for Temporal Java SDK does not support the @WorkflowInit annotation on workflow constructors. Users can use this feature with direct SDK usage, but it's blocked by Spring's bean initialization mechanism.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkflowInit"
      ],
      "components": [
        "spring-boot-integration",
        "workflow-instantiation",
        "bean-creation"
      ],
      "concepts": [
        "initialization",
        "constructor-injection",
        "spring-beans",
        "workflow-lifecycle",
        "dependency-injection"
      ],
      "severity": "medium",
      "userImpact": "Spring Boot users cannot initialize workflows with arguments using the @WorkflowInit annotation, limiting their ability to use the standard workflow initialization pattern.",
      "rootCause": "Spring Boot creates workflow instances as beans using the default constructor, which bypasses the @WorkflowInit mechanism that requires explicit constructor parameters.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing @WorkflowInit support in the Spring Boot integration.",
      "related": [],
      "keyQuote": "Users of the Java SDK directly are able to specify `@WorkflowInit` on constructors of their workflow class constructors that take workflow args as a parameter. Currently this is not possible in our spring boot integration",
      "number": 2290,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:51.765Z"
    },
    {
      "summary": "Request to add API key authentication support in Spring Boot Autoconfigure for Temporal Cloud connections. Currently only mTLS is supported, requiring users to write custom code for API key authentication.",
      "category": "feature",
      "subcategory": "spring-boot-autoconfigure",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "service-stubs",
        "authentication"
      ],
      "concepts": [
        "api-key",
        "authentication",
        "mTLS",
        "temporal-cloud",
        "configuration",
        "autoconfigure"
      ],
      "severity": "medium",
      "userImpact": "Users connecting to Temporal Cloud with API keys are forced to write custom code instead of using built-in configuration options.",
      "rootCause": null,
      "proposedFix": "Add another configuration option for API key and automatically configure the service stubs to use API key authentication.",
      "workaround": "Write a custom Spring Boot configuration/customizer to handle API key authentication.",
      "resolution": "fixed",
      "resolutionDetails": "API key authentication configuration option was implemented in Spring Boot Autoconfigure.",
      "related": [],
      "keyQuote": "Add another configuration option for API key and automatically configure the service stubs to use API key authentication.",
      "number": 2289,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:50.260Z"
    },
    {
      "summary": "Temporal metrics are not exposed through Spring Boot Actuator when the `workersAutoDiscovery` property is not configured. The issue only appears for applications using only the workflow client without starting workers, but metrics require this property to be present even as a dummy value.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "metrics",
        "actuator"
      ],
      "concepts": [
        "metrics-exposure",
        "spring-configuration",
        "client-only-applications",
        "auto-discovery"
      ],
      "severity": "medium",
      "userImpact": "Users running Temporal client-only applications in Spring Boot cannot access Temporal metrics through the Actuator endpoint without adding a dummy `workersAutoDiscovery` configuration.",
      "rootCause": "Metrics initialization logic appears to be tied to the `workersAutoDiscovery` property, even for applications that only use the workflow client without starting workers.",
      "proposedFix": null,
      "workaround": "Add a dummy `workersAutoDiscovery` property with a placeholder package value (e.g., `packages: dummy`) to enable metrics exposure.",
      "resolution": "invalid",
      "resolutionDetails": "The issue reporter could not provide a self-contained reproduction case, and the maintainer was unable to replicate the issue using the client bean, so it was closed due to lack of replication evidence.",
      "related": [],
      "keyQuote": "I found one thing. After putting the `workersAutoDiscovery` as dummy, the api application is showing metric (still worker is not started because package is dummy)",
      "number": 2287,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:37.786Z"
    },
    {
      "summary": "WorkflowClient.updateWithStart does not pass workflow arguments when starting a new workflow. The update operation arguments are incorrectly being passed as workflow arguments instead of the actual workflow arguments provided to the method.",
      "category": "bug",
      "subcategory": "workflow-update",
      "apis": [
        "WorkflowClient.updateWithStart",
        "UpdateWithStartWorkflowOperation"
      ],
      "components": [
        "workflow-client",
        "update-with-start",
        "workflow-arguments"
      ],
      "concepts": [
        "workflow-initialization",
        "update-operations",
        "argument-passing",
        "workflow-start"
      ],
      "severity": "high",
      "userImpact": "Users cannot properly initialize workflows with arguments when using updateWithStart, causing workflows to receive incorrect or missing initialization data.",
      "rootCause": "Line 299 in UpdateWithStartWorkflowOperation.java passes update operation arguments as workflow arguments instead of the intended workflow arguments.",
      "proposedFix": "Fix line 299 to correctly pass the workflow arguments instead of the update arguments when starting the workflow.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The root cause was identified in UpdateWithStartWorkflowOperation.java:299 where update args were incorrectly being passed as workflow args.",
      "related": [],
      "keyQuote": "WorkflowClient.updateWithStart does not pass workflow arguments... Think the issue is this line were we pass the update args as workflow args.",
      "number": 2285,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:35.013Z"
    },
    {
      "summary": "UpdateWithStartWorkflowOperation created from a String update name cannot be used with WorkflowClient.updateWithStart(). The API should accept any valid UpdateWithStartWorkflowOperation regardless of how it was constructed.",
      "category": "bug",
      "subcategory": "workflow-updates",
      "apis": [
        "WorkflowClient.updateWithStart",
        "UpdateWithStartWorkflowOperation"
      ],
      "components": [
        "workflow-client",
        "update-with-start",
        "workflow-operation"
      ],
      "concepts": [
        "workflow-update",
        "type-safety",
        "operation-creation",
        "string-parameters",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use untyped (String-based) UpdateWithStartWorkflowOperation with the updateWithStart API, forcing them to use only typed operations.",
      "rootCause": "UpdateWithStartWorkflowOperation created from String update name has incompatible type or structure that WorkflowClient.updateWithStart does not accept.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating a fix was applied to accept UpdateWithStartWorkflowOperation created from String update names.",
      "related": [],
      "keyQuote": "WorkflowClient.updateWithStart can not take a valid UpdateWithStartWorkflowOperation if it was created with a String update name",
      "number": 2284,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:33.526Z"
    },
    {
      "summary": "Request to auto-skip time when waiting on update results in time-skipping testing environments, similar to the existing auto-skip behavior for workflow results.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "time-skipping",
        "update-handling"
      ],
      "concepts": [
        "time-skipping",
        "testing",
        "update-result",
        "workflow-execution",
        "test-environment"
      ],
      "severity": "low",
      "userImpact": "Testing becomes more cumbersome without automatic time-skipping when waiting on update results, requiring manual time advancement in test scenarios.",
      "rootCause": null,
      "proposedFix": "Implement automatic time-skipping for update result waits, matching the existing behavior for workflow result waits.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        551
      ],
      "keyQuote": "We auto-skip time when waiting on workflow result, we need to do the same when waiting on update result.",
      "number": 2283,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:14.643Z"
    },
    {
      "summary": "NullPointerException is thrown when passing empty search attributes in workflow options. The issue occurs when SearchAttributesUtil.encodeTyped() returns null for empty search attributes, and this null value is then passed to StartWorkflowExecutionRequest.setSearchAttributes(), which doesn't accept null.",
      "category": "bug",
      "subcategory": "workflow-options",
      "apis": [
        "WorkflowOptions",
        "StartWorkflowExecutionRequest",
        "SearchAttributesUtil"
      ],
      "components": [
        "workflow-client",
        "search-attributes",
        "request-builder"
      ],
      "concepts": [
        "null-handling",
        "empty-collections",
        "parameter-validation",
        "search-attributes"
      ],
      "severity": "medium",
      "userImpact": "Users cannot create workflow options with empty search attributes without encountering a null pointer exception.",
      "rootCause": "StartWorkflowExecutionRequest.setSearchAttributes() does not accept null values, but SearchAttributesUtil.encodeTyped() returns null for empty search attributes.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The Java SDK maintainers acknowledged the bug report and filed a fix for it. A subsequent request was made to backport the fix to the 1.22.x branch.",
      "related": [],
      "keyQuote": "It throws null pointer exception",
      "number": 2276,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:17.105Z"
    },
    {
      "summary": "Add a failure_reason metric tag to the nexus_task_execution_failed metric in the Java SDK, following the pattern established in the Go SDK.",
      "category": "feature",
      "subcategory": "nexus-metrics",
      "apis": [],
      "components": [
        "nexus",
        "metrics",
        "task-execution"
      ],
      "concepts": [
        "metrics",
        "observability",
        "failure-tracking",
        "nexus-integration",
        "monitoring"
      ],
      "severity": "low",
      "userImpact": "Users will have better observability into Nexus task execution failures through detailed metric tags.",
      "rootCause": null,
      "proposedFix": "Add failure_reason metric tag to nexus_task_execution_failed metric, matching Go SDK implementation in PR #1671",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed to add failure_reason metric tag following Go SDK pattern",
      "related": [],
      "keyQuote": "Add Nexus failure_reason metric tag to nexus_task_execution_failed",
      "number": 2273,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:17.579Z"
    },
    {
      "summary": "Add an optional 'summary' field to activities as part of the user metadata MVP. This enhancement involves marking the feature as experimental and populating the user metadata on the activity command.",
      "category": "feature",
      "subcategory": "user-metadata",
      "apis": [
        "Activity"
      ],
      "components": [
        "activity-command",
        "metadata",
        "user-metadata"
      ],
      "concepts": [
        "metadata",
        "activity-properties",
        "experimental-feature",
        "user-context",
        "activity-info"
      ],
      "severity": "low",
      "userImpact": "Users can now attach optional summary metadata to activities for better documentation and tracking.",
      "rootCause": null,
      "proposedFix": "Add optional 'summary' field to activities, mark as experimental, and ensure it's populated in user metadata when activity commands are executed.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Enhancement implemented as part of user metadata MVP in Java SDK.",
      "related": [],
      "keyQuote": "Add, mark experimental, and populate user metadata on command with it.",
      "number": 2268,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:02.720Z"
    },
    {
      "summary": "Add a high-level `describe()` method to workflow stubs that returns a `WorkflowExecutionDescription` with execution details and access to the raw describe response. The method should be interceptable and follow the design patterns from TypeScript, Python, and .NET SDKs.",
      "category": "feature",
      "subcategory": "workflow-client-api",
      "apis": [
        "describe",
        "WorkflowExecutionDescription",
        "WorkflowExecutionMetadata"
      ],
      "components": [
        "workflow-stub",
        "client-api",
        "interceptors"
      ],
      "concepts": [
        "workflow-execution",
        "metadata",
        "high-level-api",
        "interception",
        "client-interface"
      ],
      "severity": "medium",
      "userImpact": "Users gain the ability to retrieve detailed workflow execution information through a high-level describe API with interceptor support.",
      "rootCause": null,
      "proposedFix": "Implement a `describe()` method on workflow stub that returns `WorkflowExecutionDescription` extending `WorkflowExecutionMetadata` with raw response access, following existing SDK implementations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented and merged to provide high-level workflow describe capability",
      "related": [
        1667
      ],
      "keyQuote": "Add high-level workflow describe call. Probably `describe` on the workflow stub",
      "number": 2265,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:03.994Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not respect workflow start delays, causing workflows to start immediately instead of at the scheduled time when using TestWorkflowEnvironment.sleep().",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-execution",
        "test-utilities"
      ],
      "concepts": [
        "start-delay",
        "workflow-scheduling",
        "time-control",
        "testing",
        "test-environment"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test workflows with start delays in unit tests, making it difficult to verify delay-dependent behavior.",
      "rootCause": "TestWorkflowEnvironment does not implement start delay handling for workflows.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #1692",
      "related": [
        1692
      ],
      "keyQuote": "The workflow starts immediately.",
      "number": 2263,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:04:00.563Z"
    },
    {
      "summary": "User asked about compatibility support for Spring Boot versions 3.2.x and 3.3.x. The maintainer clarified that the Spring Boot integration already supports 3.x versions and directed the user to community forums for support questions.",
      "category": "question",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-integration"
      ],
      "concepts": [
        "spring-boot",
        "version-compatibility",
        "framework-integration",
        "user-support",
        "community-support"
      ],
      "severity": "low",
      "userImpact": "Users were uncertain about Spring Boot 3.x version compatibility with the Temporal SDK.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Clarified that Spring Boot 3.x is already supported; issue was a support question rather than a bug or feature request.",
      "related": [],
      "keyQuote": "The Springboot integration supports 3.x, see our springboot sample.",
      "number": 2256,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:44.973Z"
    },
    {
      "summary": "RetryOption.setMaximumAttempts(0) is not working correctly for local activities. When set to 0 (which should mean unlimited retries), local activities fail after 0 retry attempts instead of retrying indefinitely, inconsistent with both documentation and regular activity behavior.",
      "category": "bug",
      "subcategory": "local-activity-retry",
      "apis": [
        "LocalActivityOptions",
        "RetryOptions",
        "ExecuteLocalActivity"
      ],
      "components": [
        "local-activity-executor",
        "retry-handler",
        "activity-options"
      ],
      "concepts": [
        "retry-policy",
        "local-activity",
        "unlimited-retries",
        "timeout",
        "attempt-limit",
        "activity-execution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure unlimited retries for local activities using the standard RetryOption.setMaximumAttempts(0) pattern, causing unexpected failures.",
      "rootCause": "Local activity retry logic incorrectly interprets setMaximumAttempts(0) as zero allowed attempts instead of unlimited attempts.",
      "proposedFix": null,
      "workaround": "Use a positive integer for setMaximumAttempts instead of 0, though this does not provide true unlimited retries.",
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #1727",
      "related": [
        1727
      ],
      "keyQuote": "Local activities will not retry with default RetryOptions or explicitly setting RetryOptions.setMaxiumAttempts(0). Instead, they will error out after 0 retry attempts.",
      "number": 2254,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:48.147Z"
    },
    {
      "summary": "Implement Nexus operation cancellation type similar to ChildWorkflowCancellationType to support different cancellation behaviors. This requires server-side support for recording the NexusOperationCancelDelivered history event.",
      "category": "feature",
      "subcategory": "nexus-cancellation",
      "apis": [
        "NexusOperationCancellationType"
      ],
      "components": [
        "nexus",
        "operation-cancellation",
        "history-event"
      ],
      "concepts": [
        "cancellation",
        "child-workflow-pattern",
        "operation-lifecycle",
        "server-event-recording",
        "cancel-requested"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure different cancellation behaviors for Nexus operations, limiting control over how operation cancellations are handled.",
      "rootCause": "Server does not yet support recording the NexusOperationCancelDelivered history event needed for cancel-requested behavior.",
      "proposedFix": "Implement NexusOperationCancellationType enum similar to ChildWorkflowCancellationType and support recording NexusOperationCancelDelivered history event on the server.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented with support for Nexus operation cancellation type and corresponding server-side history event recording.",
      "related": [
        6585
      ],
      "keyQuote": "Similar to ChildWorkflowCancellationType. Waiting for \"cancel requested\" requires the server to record the NexusOperationCancelDelivered history event.",
      "number": 2247,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:48.401Z"
    },
    {
      "summary": "When using time-skipping in test environment, if an activity's startToCloseTimeout is exceeded during the test, worker.runUntil() hangs instead of closing properly because it fails to handle the abandoned activity completion.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "runUntil",
        "proxyActivities"
      ],
      "components": [
        "worker",
        "activity-executor",
        "test-server"
      ],
      "concepts": [
        "timeout",
        "time-skipping",
        "activity-abandonment",
        "test-environment",
        "worker-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Tests using time-skipping get stuck indefinitely when activities timeout, blocking test execution and developer workflows.",
      "rootCause": "Worker fails to properly handle activity completion when the activity has already timed out in the test server, resulting in an inability to close the worker gracefully.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "worker.runUntil usually hangs, ostensibly because it fails to wait for the abandoned activity",
      "number": 2246,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:32.090Z"
    },
    {
      "summary": "Add support for Nexus bi-directional links in the Java SDK to enable communication patterns similar to those implemented in the Go SDK.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [],
      "components": [
        "nexus",
        "link-handling",
        "inter-service-communication"
      ],
      "concepts": [
        "bi-directional-links",
        "nexus-integration",
        "service-orchestration",
        "async-communication"
      ],
      "severity": "medium",
      "userImpact": "Users can now establish and use bi-directional Nexus links in Java SDK applications for improved service-to-service communication patterns.",
      "rootCause": null,
      "proposedFix": "Implement Nexus bi-directional link support following the pattern established in the Go SDK implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented via commit eff3ca20fcf8579f6fe38d8345d588425c0034b6",
      "related": [],
      "keyQuote": "Support Nexus bi-directional links.",
      "number": 2245,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:33.348Z"
    },
    {
      "summary": "Request to include update handler and ID information in logging context for the Java SDK to improve observability and debugging of update operations.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logging",
        "update-handler",
        "context"
      ],
      "concepts": [
        "observability",
        "debugging",
        "update-operations",
        "logging-context",
        "handler-identification",
        "tracing"
      ],
      "severity": "low",
      "userImpact": "Users would have better visibility into update handler execution and identification in logs, making debugging and monitoring easier.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by adding update handler and ID information to the logging context",
      "related": [
        466
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/466 for more details",
      "number": 2237,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:34.212Z"
    },
    {
      "summary": "The Java SDK should call the ShutdownWorker API when a worker is being shut down, aligning with cross-SDK feature requirements. Test server support is also needed for this functionality.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "ShutdownWorker"
      ],
      "components": [
        "worker",
        "shutdown",
        "lifecycle-management"
      ],
      "concepts": [
        "worker-shutdown",
        "api-compatibility",
        "graceful-shutdown",
        "test-server",
        "cross-sdk-feature"
      ],
      "severity": "medium",
      "userImpact": "Users need proper worker shutdown behavior that aligns with other SDKs and includes test server support for comprehensive testing.",
      "rootCause": null,
      "proposedFix": "Implement ShutdownWorker API call during worker shutdown process and add corresponding test server support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "ShutdownWorker API was implemented and integrated into the worker shutdown flow with test server support added.",
      "related": [
        542
      ],
      "keyQuote": "We will also need to add test server support here IMO",
      "number": 2236,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:20.697Z"
    },
    {
      "summary": "Add Nexus support to TestWorkflowExtension to enable testing of workflows that use Nexus operations.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowExtension"
      ],
      "components": [
        "test-framework",
        "nexus",
        "workflow-testing"
      ],
      "concepts": [
        "nexus",
        "testing",
        "extension",
        "workflow-operations",
        "test-infrastructure"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently test Nexus-based workflows using TestWorkflowExtension, limiting test coverage for Nexus functionality.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Nexus support was added to TestWorkflowExtension",
      "related": [],
      "keyQuote": "Add Nexus Support to TestWorkflowExtension",
      "number": 2235,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:18.238Z"
    },
    {
      "summary": "The example code in the @WorkflowInterface javadoc annotation documentation does not behave as described in the accompanying text, creating inconsistency and confusion for developers reading the documentation.",
      "category": "docs",
      "subcategory": "javadoc-annotation",
      "apis": [
        "WorkflowInterface"
      ],
      "components": [
        "javadoc",
        "workflow-interface",
        "documentation"
      ],
      "concepts": [
        "documentation-accuracy",
        "code-examples",
        "API-documentation",
        "developer-experience",
        "annotation-usage"
      ],
      "severity": "low",
      "userImpact": "Developers reading the @WorkflowInterface documentation may misunderstand how to properly implement workflow interfaces based on misleading examples.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The example code given in the documentation for the `@WorkflowInterface` annotation would not behave as described in the accompanying text.",
      "number": 2232,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:17.739Z"
    },
    {
      "summary": "Request to add TestNexusEnvironment for testing Nexus operations without requiring a full workflow, similar to the existing TestActivityEnvironment.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "testing",
        "nexus",
        "test-environment"
      ],
      "concepts": [
        "testing",
        "nexus-operations",
        "unit-testing",
        "test-framework",
        "isolation"
      ],
      "severity": "low",
      "userImpact": "Users must currently write workaround workflows to test Nexus operations, which adds complexity to testing.",
      "rootCause": null,
      "proposedFix": "Add TestNexusEnvironment as a direct analog to TestActivityEnvironment.",
      "workaround": "Write a short workflow to invoke the operation.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add TestNexusEnvironment similar to TestActivityEnvironment",
      "number": 2229,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:06.967Z"
    },
    {
      "summary": "Add namespace capabilities to the Test Server's describe workflow response, aligning with the temporal server implementation as referenced in PR #6256.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "describe-response",
        "namespace"
      ],
      "concepts": [
        "namespace-capabilities",
        "server-response",
        "test-compatibility",
        "api-parity"
      ],
      "severity": "low",
      "userImpact": "Test Server responses will be more complete and realistic, better matching production server behavior for namespace capability queries.",
      "rootCause": null,
      "proposedFix": "Implement namespace capabilities in the describe response, following the changes in temporalio/temporal PR #6256",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to fill in namespace capabilities in test server describe response",
      "related": [
        6256
      ],
      "keyQuote": "See https://github.com/temporalio/temporal/pull/6256",
      "number": 2227,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:05.359Z"
    },
    {
      "summary": "Add support for Nexus worker interceptor to WorkerInterceptor, enabling hook points similar to those available for ActivityInboundCallsInterceptor.",
      "category": "feature",
      "subcategory": "nexus-interceptor",
      "apis": [
        "WorkerInterceptor"
      ],
      "components": [
        "worker",
        "nexus",
        "interceptor"
      ],
      "concepts": [
        "interceptor",
        "extension-point",
        "nexus-operations",
        "middleware",
        "request-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers can extend Nexus worker behavior with custom interceptors for cross-cutting concerns like logging, metrics, and request modification.",
      "rootCause": null,
      "proposedFix": "Implement Nexus worker interceptor similar to the existing ActivityInboundCallsInterceptor pattern in WorkerInterceptor.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Nexus worker interceptor support was implemented in the WorkerInterceptor interface.",
      "related": [],
      "keyQuote": "Add support for Nexus worker interceptor to `WorkerInterceptor` similar to `ActivityInboundCallsInterceptor`",
      "number": 2220,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:03:05.998Z"
    },
    {
      "summary": "Add support for user metadata on workflow start and commands in the Test Server, implementing the API changes from temporalio/api.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "workflow-start",
        "commands"
      ],
      "concepts": [
        "user-metadata",
        "workflow-start",
        "commands",
        "test-framework",
        "api-support"
      ],
      "severity": "medium",
      "userImpact": "Users can now include and test user metadata when starting workflows and executing commands in the Test Server.",
      "rootCause": null,
      "proposedFix": "Implement support for user metadata as defined in the temporalio/api commit de9e0055a5067ee3e3a6105a207b7c78e8ea8668",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support user metadata on workflow start and commands",
      "related": [],
      "keyQuote": "Add support for user metadata on workflow start and commands",
      "number": 2219,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:50.272Z"
    },
    {
      "summary": "Request to add support for workflow metadata query in the Java SDK, aligning with feature specifications and Go SDK implementation.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [],
      "components": [
        "workflow-executor",
        "metadata-service"
      ],
      "concepts": [
        "metadata-query",
        "workflow-introspection",
        "cross-sdk-parity"
      ],
      "severity": "medium",
      "userImpact": "Users cannot query workflow metadata in Java SDK, limiting visibility into workflow state and creating inconsistency with other SDKs.",
      "rootCause": null,
      "proposedFix": "Implement workflow metadata query support as described in feature spec and Go SDK implementation",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #335, which tracks the same feature request",
      "related": [
        335,
        486,
        1565
      ],
      "keyQuote": "Duplicate of https://github.com/temporalio/sdk-java/issues/335",
      "number": 2217,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:53.640Z"
    },
    {
      "summary": "Add support for user metadata on workflows and events, including fixed summary/details on workflow start events and summary on timer start events to serve as timer identifiers.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-engine",
        "event-system",
        "workflow-execution"
      ],
      "concepts": [
        "metadata",
        "workflow-start",
        "timer",
        "event-tracking",
        "signal",
        "child-workflow"
      ],
      "severity": "medium",
      "userImpact": "Users can now attach and retrieve custom metadata on workflows and events for better tracking, identification, and organization of workflow instances.",
      "rootCause": null,
      "proposedFix": "Implement metadata support on workflow start events (including signals, child workflows, and scheduled workflows) and timer start events",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented as an MVP with metadata support on workflow start and timer start events",
      "related": [
        486
      ],
      "keyQuote": "Add support for user meta data on events with fixed summary and details on workflow start and summary on timer start",
      "number": 2216,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:52.888Z"
    },
    {
      "summary": "Test Server does not correctly treat internal errors from Nexus operations as retryable. When a Nexus operation throws an internal error (RuntimeException), the test server marks it as non-retryable when it should be retryable.",
      "category": "bug",
      "subcategory": "nexus-operations",
      "apis": [
        "Workflow.newNexusServiceStub",
        "NexusOperationOptions",
        "NexusServiceOptions"
      ],
      "components": [
        "test-server",
        "nexus-operations",
        "error-handling",
        "retry-logic"
      ],
      "concepts": [
        "retryable-errors",
        "internal-errors",
        "nexus-operations",
        "error-classification",
        "test-framework",
        "timeout"
      ],
      "severity": "high",
      "userImpact": "Users testing Nexus operations with the test server cannot properly test retry behavior for internal errors, leading to incorrect test coverage and potential production issues.",
      "rootCause": "Test server's error handling logic incorrectly classifies internal errors from Nexus operations as non-retryable instead of retryable.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test server error handling for Nexus operations was updated to properly treat internal errors as retryable.",
      "related": [],
      "keyQuote": "Test server treats internal errors from nexus operations as non-retryable",
      "number": 2215,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:37.745Z"
    },
    {
      "summary": "The BatchRequest API for Signal w/ Start is difficult to use due to inflexible ordering constraints and lacks support for other operations like Update. This feature request proposes deprecating BatchRequest in favor of a more intuitive, consistent API similar to updateWithStart.",
      "category": "feature",
      "subcategory": "signal-with-start",
      "apis": [
        "BatchRequest",
        "updateWithStart",
        "SignalWithStartWorkflow"
      ],
      "components": [
        "workflow-client",
        "signal-api",
        "batch-request"
      ],
      "concepts": [
        "api-design",
        "deprecation",
        "workflow-operations",
        "signal-handling",
        "consistency"
      ],
      "severity": "medium",
      "userImpact": "Developers struggle with confusing BatchRequest constraints and may be misled about supported operations, hindering adoption of signal-with-start workflows.",
      "rootCause": "BatchRequest has rigid ordering requirements and limited operation support, creating an unintuitive and inconsistent API surface.",
      "proposedFix": "Deprecate BatchRequest and replace it with a new API that is easier to use and more consistent with updateWithStart, supporting additional operations like Update.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        915
      ],
      "keyQuote": "BatchRequest is hard to use, i.e. it has some affordances that would be illegal.",
      "number": 2213,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:39.349Z"
    },
    {
      "summary": "Add a synchronous getResult() convenience method to UpdateHandle to make the common synchronous use case more usable. Currently requires calling getResultAsync().get() which is verbose for what should be a simple operation.",
      "category": "feature",
      "subcategory": "update-handle-api",
      "apis": [
        "UpdateHandle",
        "getResultAsync"
      ],
      "components": [
        "update-handle",
        "workflow-stub",
        "sync-api"
      ],
      "concepts": [
        "convenience-method",
        "sync-async-consistency",
        "api-usability",
        "result-retrieval"
      ],
      "severity": "low",
      "userImpact": "Developers using synchronous updates must write verbose boilerplate code to get results, reducing code readability and developer experience.",
      "rootCause": null,
      "proposedFix": "Add a getResult() convenience method to UpdateHandle that aliases getResultAsync().get(), following the precedent set by WorkflowStub which has both getResult() and getResultAsync() methods.",
      "workaround": "Use handle.getResultAsync().get() for synchronous result retrieval.",
      "resolution": "fixed",
      "resolutionDetails": "Convenience method getResult() was added to UpdateHandle for synchronous use cases.",
      "related": [],
      "keyQuote": "To get the result of the update, you have to do `handle.getResultAsync().get()` Given that updates are mostly used for synchronous use cases, could we make this more convenient?",
      "number": 2212,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:36.420Z"
    },
    {
      "summary": "Implement Nexus handler support for well-known Temporal error translation in the Java SDK, replicating functionality from the Go SDK PR #1626.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [],
      "components": [
        "nexus-handler",
        "error-translation"
      ],
      "concepts": [
        "nexus",
        "error-handling",
        "handler",
        "sdk-parity",
        "temporal-errors"
      ],
      "severity": "medium",
      "userImpact": "Users can properly translate and handle well-known Temporal errors in Nexus handlers without manual conversion logic.",
      "rootCause": null,
      "proposedFix": "Replicate the error translation behavior implemented in Go SDK PR #1626",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented following Go SDK pattern for Nexus error translation",
      "related": [
        1626
      ],
      "keyQuote": "Replicate the behavior implemented in this Go SDK PR: https://github.com/temporalio/sdk-go/pull/1626",
      "number": 2209,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:50.997Z"
    },
    {
      "summary": "User requests adding `getMetricsScope` method to `WorkflowOutboundCallsInterceptor` to enable custom tags on metrics emitted within workflows.",
      "category": "feature",
      "subcategory": "metrics-and-monitoring",
      "apis": [
        "WorkflowOutboundCallsInterceptor"
      ],
      "components": [
        "workflow-interceptor",
        "metrics",
        "monitoring"
      ],
      "concepts": [
        "metrics",
        "custom-tags",
        "instrumentation",
        "observability",
        "workflow-execution"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently add custom tags to metrics emitted in workflows without accessing the metrics scope through the interceptor.",
      "rootCause": null,
      "proposedFix": "Add `getMetricsScope` method to `WorkflowOutboundCallsInterceptor` interface",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented and merged into the codebase",
      "related": [],
      "keyQuote": "Add `getMetricsScope` to `WorkflowOutboundCallsInterceptor`",
      "number": 2208,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:21.518Z"
    },
    {
      "summary": "Activity inputs are held in strong references by WorkflowOutboundCallsInterceptor$ActivityInput even after activities complete, preventing garbage collection and causing memory leaks in workflows with multiple async activities.",
      "category": "bug",
      "subcategory": "activity-memory-management",
      "apis": [
        "Async.procedure",
        "ActivityOptions",
        "Workflow.newActivityStub"
      ],
      "components": [
        "WorkflowOutboundCallsInterceptor",
        "ActivityStateMachine",
        "CancellationScope"
      ],
      "concepts": [
        "memory-leak",
        "garbage-collection",
        "async-activities",
        "reference-holding",
        "heap-pressure"
      ],
      "severity": "high",
      "userImpact": "Workflows with multiple async activities exhaust worker memory over time due to activity inputs not being released for garbage collection.",
      "rootCause": "The internal ActivityStateMachine holds a reference to activity inputs, and the cancellation callback in CancellationScope holds the state machine, preventing garbage collection even after activity completion.",
      "proposedFix": "Make the cancellation callback hold a weak reference to the state machine, or remove the cancellation callback once the ActivityStateMachine reaches a terminal state.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fix included in a future minor SDK release by addressing the reference holding in cancellation callbacks or state machine lifecycle.",
      "related": [],
      "keyQuote": "the activity input is being held because the internal ActivityStateMachine holds it and the state machine is being held by the cancellation callback",
      "number": 2203,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:02:23.389Z"
    },
    {
      "summary": "Workflow.newUntypedActivityStub does not inherit default options from WorkflowImplementationOptions.Builder customizer, unlike Workflow.newActivityStub. The untyped variant requires explicit options to be passed and ignores the configured defaults.",
      "category": "bug",
      "subcategory": "activity-options",
      "apis": [
        "Workflow.newActivityStub",
        "Workflow.newUntypedActivityStub",
        "TemporalOptionsCustomizer"
      ],
      "components": [
        "workflow-implementation",
        "activity-stub",
        "options-customizer"
      ],
      "concepts": [
        "default-options",
        "type-safety",
        "configuration-inheritance",
        "builder-pattern",
        "spring-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use Spring-configured default activity options with untyped activity stubs, requiring them to either pass explicit options or use internal APIs as a workaround.",
      "rootCause": "The newUntypedActivityStub method does not call setDefaultActivityOptions during initialization, while newActivityStub does via the referenced line in WorkflowInternal.java",
      "proposedFix": null,
      "workaround": "Call WorkflowInternal.getRootWorkflowContext().getDefaultActivityOptions() directly (requires package-hacking access to internal API)",
      "resolution": "wontfix",
      "resolutionDetails": "Design decision: setDefaultActivityOptions is intentionally documented as only applying to newActivityStub, since activity interface is required to construct final default activity options. Untyped stubs do not have this constraint.",
      "related": [],
      "keyQuote": "Yes this is intentional `setDefaultActivityOptions` specifies it only applies to `newActivityStub` in general the activity interface is required to construct the final default activities options",
      "number": 2200,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:40.324Z"
    },
    {
      "summary": "LocalActivitySlotSupplierQueue thread persists after WorkerFactory.shutdown() is called, preventing JVM termination when workers are not started. The thread is created in the constructor but shutdown is only called if the worker was started.",
      "category": "bug",
      "subcategory": "local-activity-worker",
      "apis": [
        "WorkerFactory",
        "LocalActivityWorker",
        "WorkerFactory.shutdown"
      ],
      "components": [
        "local-activity-worker",
        "slot-supplier-queue",
        "worker-factory"
      ],
      "concepts": [
        "thread-lifecycle",
        "jvm-termination",
        "resource-cleanup",
        "worker-initialization",
        "shutdown-sequence"
      ],
      "severity": "high",
      "userImpact": "Applications cannot cleanly exit when WorkerFactory is shut down without starting workers, blocking the JVM from terminating.",
      "rootCause": "LocalActivitySlotSupplierQueue thread is created in LocalActivityWorker constructor but shutdown() is only called in LocalActivityWorker.shutdown() if the worker was started, leaving the thread running.",
      "proposedFix": "Move slotQueue.shutdown() call to execute independently of worker start, or initialize the slot queue in start() method rather than constructor.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "LocalActivitySlotSupplierQueue should only create a thread if the worker is started, and awaitTermination should verify shutdown completion rather than calling slotQueue.shutdown().",
      "related": [],
      "keyQuote": "LocalActivitySlotSupplierQueue remains working and blocks jvm from exiting",
      "number": 2194,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:36.556Z"
    },
    {
      "summary": "Workflow and activity execution logs are missing the Attempt number in MDC (Mapped Diagnostic Context). The request is to add a new LoggerTag ATTEMPT and populate it in MDC alongside existing fields like WorkflowId and ActivityId.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logging",
        "mdc",
        "workflow-execution",
        "activity-execution"
      ],
      "concepts": [
        "attempt-tracking",
        "diagnostic-context",
        "structured-logging",
        "observability",
        "mdc-fields"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily track retry attempts in logs without manually parsing execution metadata, making debugging multi-attempt workflows and activities more difficult.",
      "rootCause": null,
      "proposedFix": "Add a new LoggerTag ATTEMPT and introduce its value on MDC like the existing LoggerTags (WorkflowId, ActivityId, etc.)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The enhancement was implemented by adding ATTEMPT to the LoggerTag enum and populating it in MDC during workflow and activity execution.",
      "related": [],
      "keyQuote": "Add a new LoggerTag ATTEMPT and introduce its value on MDC like the others.",
      "number": 2192,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:37.293Z"
    },
    {
      "summary": "The Java SDK incorrectly uses the minimum catch-up window (10 seconds) instead of the default (1 year) when no catch-up window is specified in a SchedulePolicy. This was a bug in versions before 1.24.0 that has been fixed.",
      "category": "bug",
      "subcategory": "schedules",
      "apis": [
        "SchedulePolicy",
        "Schedule",
        "createSchedule"
      ],
      "components": [
        "schedules",
        "proto-conversion",
        "ProtobufTimeUtils"
      ],
      "concepts": [
        "catch-up-window",
        "default-values",
        "proto-serialization",
        "schedule-policy",
        "temporal-duration"
      ],
      "severity": "medium",
      "userImpact": "Users who don't explicitly set a catch-up window get unexpected behavior where schedules catch up every 10 seconds instead of the documented 1-year default.",
      "rootCause": "ProtobufTimeUtils was converting null/unset catch-up window to duration 0, which the server then interpreted as lower than the 10-second minimum and used the minimum instead of the documented default.",
      "proposedFix": "Fixed in Java SDK 1.24.0 by commit 9a856f30 to properly handle null/unset catch-up window values.",
      "workaround": "Update existing schedules with a no-op update that removes the 0 value from the policy, or upgrade to Java SDK 1.24.0+",
      "resolution": "fixed",
      "resolutionDetails": "Bug was fixed in Java SDK version 1.24.0 through commit 9a856f30 which properly handles unset catch-up window values instead of converting them to 0.",
      "related": [],
      "keyQuote": "If you don't set a catch up window on your SchedulePolicy when creating the schedule it will use the default value of 1 year.",
      "number": 2189,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:24.279Z"
    },
    {
      "summary": "Documentation issue: workflow start delay documentation incorrectly states that signals can interrupt the delay. This needs to be corrected to clarify that signals do not interrupt workflow start delays.",
      "category": "docs",
      "subcategory": "workflow-delay",
      "apis": [],
      "components": [
        "documentation",
        "workflow-lifecycle"
      ],
      "concepts": [
        "signal",
        "delay",
        "workflow-start",
        "interruption",
        "timing"
      ],
      "severity": "low",
      "userImpact": "Users may misunderstand signal behavior during workflow start delays, leading to incorrect workflow implementations.",
      "rootCause": "Documentation inaccuracy regarding signal semantics",
      "proposedFix": "Update workflow start delay documentation to clarify that signals do not interrupt the initial delay",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was corrected to accurately reflect that signals do not interrupt workflow start delays",
      "related": [],
      "keyQuote": "signal does not interrupt delay",
      "number": 2184,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:23.481Z"
    },
    {
      "summary": "Request for a type-safe async update API in the Java SDK that works similarly to WorkflowClient.start, returning an update handle instead of using stub/proxy-based approach.",
      "category": "feature",
      "subcategory": "update-api",
      "apis": [
        "WorkflowClient.start",
        "update"
      ],
      "components": [
        "workflow-client",
        "update-handler",
        "async-api"
      ],
      "concepts": [
        "type-safety",
        "async-operations",
        "api-design",
        "handle-pattern",
        "client-interface"
      ],
      "severity": "low",
      "userImpact": "Developers can use a more ergonomic and type-safe API for async workflow updates.",
      "rootCause": null,
      "proposedFix": "Add an update API similar to WorkflowClient.start that returns an update handle",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed, suggesting the feature was implemented or resolved",
      "related": [],
      "keyQuote": "Add an API similar to WorkflowClient.start for update methods that return an update handle",
      "number": 2181,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:20.676Z"
    },
    {
      "summary": "Workflow.newExternalWorkflowStub() rejects interfaces that don't have @WorkflowInterface annotation, even though WorkflowClient.newWorkflowStub() accepts such interfaces. This inconsistency prevents using base interfaces containing only signal/query/update methods for external workflow communication.",
      "category": "bug",
      "subcategory": "external-workflows",
      "apis": [
        "Workflow.newExternalWorkflowStub",
        "WorkflowClient.newWorkflowStub"
      ],
      "components": [
        "ExternalWorkflowInvocationHandler",
        "POJOWorkflowInterfaceMetadata",
        "WorkflowInternal"
      ],
      "concepts": [
        "workflow-interface",
        "signal-methods",
        "external-workflows",
        "interface-inheritance",
        "type-validation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use base interfaces containing only signal/query/update methods for external workflow communication, forcing less elegant API design patterns.",
      "rootCause": "ExternalWorkflowInvocationHandler enforces @WorkflowInterface annotation requirement, while WorkflowClient does not, creating an API inconsistency.",
      "proposedFix": "Allow Workflow.newExternalWorkflowStub() to accept any interface without @WorkflowInterface annotation, validating method annotations at invocation time instead, matching WorkflowClient behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by allowing external workflow stubs to accept interfaces without @WorkflowInterface annotation, with validation occurring at method invocation time.",
      "related": [],
      "keyQuote": "The same should work when signaling workflow from an external workflow as it does with WorkflowClient.newWorkflowStub()",
      "number": 2180,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:07.734Z"
    },
    {
      "summary": "Feature request to add configuration-based exclusions for interceptors to prevent certain workflows and activities from being intercepted based on their type or task queue. The maintainer suggested this is better handled programmatically through conditional logic within interceptors rather than as a configuration option.",
      "category": "feature",
      "subcategory": "interceptors",
      "apis": [],
      "components": [
        "interceptor",
        "workflow",
        "activity"
      ],
      "concepts": [
        "interceptor-configuration",
        "workflow-filtering",
        "activity-filtering",
        "task-queue",
        "exclusion-logic",
        "interceptor-wrapper"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily configure interceptors to skip certain workflows or activities, requiring workarounds or custom wrapper implementations.",
      "rootCause": null,
      "proposedFix": "Implement configuration-based approach for interceptor exclusions based on workflow/activity type or task queue.",
      "workaround": "Write an interceptor wrapper that performs exclusion checks before applying the inner interceptor using conditional logic.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer declined the feature, arguing that programmatic exclusion through conditionals is more flexible than configuration-based approach since configuration needs are infinite.",
      "related": [],
      "keyQuote": "I think we should encourage programmatic exclusion when using programmatic interceptors. If someone wants to write an interceptor wrapper that does does exclusion check before applying inner interceptor, they can.",
      "number": 2179,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:09.697Z"
    },
    {
      "summary": "Search attributes should be automatically carried over when using continue-as-new in Java SDK if none are explicitly specified, matching the behavior of other Temporal SDKs.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "workflow-executor",
        "search-attributes",
        "state-management"
      ],
      "concepts": [
        "continue-as-new",
        "search-attributes",
        "state-preservation",
        "cross-sdk-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users lose search attributes when using continue-as-new, creating inconsistent behavior compared to other SDKs and potential data loss.",
      "rootCause": "Continue-as-new implementation does not preserve search attributes by default in Java SDK.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation updated to carry over search attributes on continue-as-new when none are explicitly specified.",
      "related": [],
      "keyQuote": "This will match the behavior in other SDKs. Currently it looks like nothing is carried over.",
      "number": 2178,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:01:07.439Z"
    },
    {
      "summary": "The Java SDK's JAR manifest is incomplete and lacks package version information. This prevents developers from retrieving the SDK version at runtime using reflection (e.g., `WorkflowClient.class.getPackage().getImplementationVersion()`), which is needed for tools like Quarkus Extensions and DevOps dashboards.",
      "category": "other",
      "subcategory": "build-configuration",
      "apis": [],
      "components": [
        "manifest",
        "jar",
        "gradle-build"
      ],
      "concepts": [
        "version-detection",
        "metadata",
        "reflection",
        "osgi-compatibility",
        "build-artifact"
      ],
      "severity": "low",
      "userImpact": "Users cannot programmatically detect the SDK version at runtime, limiting integration with third-party tools and DevOps platforms.",
      "rootCause": "The Gradle build configuration does not populate manifest attributes like Implementation-Version and Implementation-Title in the JAR manifest.",
      "proposedFix": "Add manifest attributes to the Gradle jar task configuration, including Implementation-Title, Implementation-Version, and other standard OSGi manifest entries.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was addressed by adding proper manifest configuration to the Gradle build.",
      "related": [],
      "keyQuote": "For our Quarkus Extension we would like to display the version of Temporal in use on the DevOps card but right now we display ? because we can't detect the version.",
      "number": 2177,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:55.230Z"
    },
    {
      "summary": "Request for a workflow initialization method that executes before any signals or updates are received, allowing handlers to use pre-initialized values.",
      "category": "feature",
      "subcategory": "workflow-initialization",
      "apis": [],
      "components": [
        "workflow",
        "signal-handler",
        "update-handler"
      ],
      "concepts": [
        "initialization",
        "signal-handling",
        "update-handling",
        "handler-lifecycle",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Users need a reliable way to initialize workflow state before signal and update handlers execute.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #865 which addresses the same workflow initialization requirement.",
      "related": [
        865
      ],
      "keyQuote": "We should have a method that's guaranteed to initialize before signals and updates come in so handlers can use initialized values.",
      "number": 2166,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:55.078Z"
    },
    {
      "summary": "Nexus functional tests using an external test server are currently disabled because Nexus is only fully supported in OSS 1.25.0+. These tests should be re-enabled once version 1.25.0 is officially released.",
      "category": "feature",
      "subcategory": "nexus-testing",
      "apis": [],
      "components": [
        "nexus",
        "test-server",
        "functional-tests"
      ],
      "concepts": [
        "nexus-support",
        "version-compatibility",
        "external-server",
        "test-automation",
        "oss-release"
      ],
      "severity": "medium",
      "userImpact": "Nexus functional tests remain disabled, preventing comprehensive testing of Nexus integration until OSS 1.25.0 is released.",
      "rootCause": "Nexus is only fully supported in OSS 1.25.0+, requiring version prerequisite for external server tests",
      "proposedFix": "Re-enable Nexus test server docker functional tests once OSS 1.25.0 is officially released",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tests were re-enabled after OSS 1.25.0 release became available",
      "related": [],
      "keyQuote": "Nexus is only fully supported in OSS 1.25.0+ so the functional tests using an external server are disabled for now.",
      "number": 2165,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:52.337Z"
    },
    {
      "summary": "Child workflow cancellation can trigger the SDK event loop without a WFT (Workflow Task) Started event, causing non-deterministic behavior. This issue requires versioning the fix to maintain determinism.",
      "category": "bug",
      "subcategory": "child-workflow-cancellation",
      "apis": [],
      "components": [
        "event-loop",
        "state-machines",
        "workflow-task-processing"
      ],
      "concepts": [
        "cancellation",
        "event-loop",
        "non-determinism",
        "workflow-task",
        "child-workflow",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Child workflow cancellations may cause unpredictable event loop triggering, potentially leading to workflow execution issues and non-deterministic behavior.",
      "rootCause": "Child workflow cancellation triggers the event loop before a WFT Started event is received, breaking the expected event ordering.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2155
      ],
      "keyQuote": "Child workflow cancellation can trigger SDK event loop without a WFT Started",
      "number": 2160,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:41.420Z"
    },
    {
      "summary": "GitHub's Runner Agent now has dependencies incompatible with Ubuntu 18.04, forcing an urgent migration away from buildjet-2vcpu-ubuntu-1804 runners used for Test Server builds. This blocks Java SDK releases until resolved.",
      "category": "bug",
      "subcategory": "ci-infrastructure",
      "apis": [],
      "components": [
        "ci-workflows",
        "test-server-build",
        "github-actions"
      ],
      "concepts": [
        "build-infrastructure",
        "runner-compatibility",
        "glibc-compatibility",
        "ubuntu-version",
        "ci-pipeline",
        "dependency-management",
        "release-blocking"
      ],
      "severity": "critical",
      "userImpact": "Java SDK releases cannot be made until CI workflows are updated to use compatible runners, directly blocking users from accessing new SDK releases.",
      "rootCause": "GitHub's latest Runner Agent version introduced dependencies incompatible with Ubuntu 18.04, which the buildjet runners were still using for glibc compatibility with older Linux distributions.",
      "proposedFix": "Update CI workflows to use a more recent runner that is compatible with the latest GitHub Runner Agent version.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "CI workflows were updated to use newer runners that are compatible with the latest GitHub Runner Agent dependencies.",
      "related": [],
      "keyQuote": "It is therefore urgent that we update our CI workflows to use a more recent runner, as we might be incapable of making a new Java SDK release until this is fixed.",
      "number": 2157,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:40.706Z"
    },
    {
      "summary": "LocalActivity state machine enters an invalid state when executed within a detached cancellation scope after a child workflow cancellation. The state transition REQUEST_PREPAREDNON_REPLAY_WORKFLOW_TASK_STARTED fails, causing WorkflowTask execution to fail.",
      "category": "bug",
      "subcategory": "local-activity-state-machine",
      "apis": [
        "Workflow.newLocalActivityStub",
        "Workflow.newChildWorkflowStub",
        "Workflow.newDetachedCancellationScope",
        "CancellationScope.isCancelRequested"
      ],
      "components": [
        "local-activity-executor",
        "state-machine",
        "cancellation-scope",
        "child-workflow-handler",
        "workflow-task-processor"
      ],
      "concepts": [
        "state-transition",
        "cancellation",
        "local-activity",
        "child-workflow",
        "detached-scope",
        "invalid-state"
      ],
      "severity": "high",
      "userImpact": "Users cannot execute local activities in detached cancellation scopes after child workflow cancellations, causing workflow execution failures.",
      "rootCause": "LocalActivity state machine does not properly handle state transitions when executed within a detached cancellation scope following child workflow cancellation events.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "State machine logic was corrected to handle the REQUEST_PREPAREDNON_REPLAY_WORKFLOW_TASK_STARTED transition in detached cancellation scope contexts.",
      "related": [],
      "keyQuote": "LocalActivity: invalid REQUEST_PREPARED->NON_REPLAY_WORKFLOW_TASK_STARTED, transition history is [CREATED->CHECK_EXECUTION_STATE, EXECUTING->SCHEDULE]",
      "number": 2155,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:39.011Z"
    },
    {
      "summary": "Add support for updating schedule search attributes in the Java SDK, following the feature specification and Go SDK implementation.",
      "category": "feature",
      "subcategory": "schedule-search-attributes",
      "apis": [
        "UpdateSchedule"
      ],
      "components": [
        "scheduler",
        "search-attributes",
        "client"
      ],
      "concepts": [
        "search-attributes",
        "schedule-management",
        "workflow-scheduling",
        "metadata",
        "filtering"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to update search attributes on schedules for better querying and management of scheduled workflows.",
      "rootCause": null,
      "proposedFix": "Implement schedule search attribute update following the specification in temporalio/features#512 and the Go SDK implementation from temporalio/sdk-go#1561",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support updating schedule search attributes in line with cross-SDK specification",
      "related": [
        512,
        1561
      ],
      "keyQuote": "Support schedule search attribute update",
      "number": 2152,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:24.401Z"
    },
    {
      "summary": "The generated temporal-serviceclient JAR includes duplicate Google Protocol Buffer classes that are already available as dependencies (protobuf-java and proto-google-common-protos), causing classpath duplication warnings.",
      "category": "bug",
      "subcategory": "build-dependencies",
      "apis": [],
      "components": [
        "temporal-serviceclient",
        "maven-build",
        "proto-generation"
      ],
      "concepts": [
        "duplicate-classes",
        "classpath-pollution",
        "dependency-management",
        "proto-compilation",
        "shading"
      ],
      "severity": "medium",
      "userImpact": "Users encounter duplicate class warnings during builds and risk classpath conflicts when proto-google-common-protos or protobuf-java versions differ from those bundled in temporal-serviceclient.",
      "rootCause": "The proto code generation process includes Google's protobuf and common-protos classes in the final JAR instead of excluding them as provided dependencies.",
      "proposedFix": "Exclude or shade generated Google proto classes in the temporal-serviceclient build configuration to prevent inclusion in the final artifact.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Removed generated Google proto classes from temporal-serviceclient to prevent duplication with independently managed dependencies.",
      "related": [],
      "keyQuote": "Found duplicate and different classes in [com.google.protobuf:protobuf-java:3.21.7, io.temporal:temporal-serviceclient:1.24.0]",
      "number": 2150,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:28.124Z"
    },
    {
      "summary": "Local activity backpressure logic needs revisiting for slot suppliers without defined upper limits. Currently defaults to 100 slots for unlimited suppliers, but a more optimal default may be possible.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "slot-supplier",
        "local-activity-executor",
        "backpressure"
      ],
      "concepts": [
        "backpressure",
        "slot-management",
        "concurrency-control",
        "resource-limits",
        "semaphore"
      ],
      "severity": "medium",
      "userImpact": "Users with slot suppliers that have no upper limit may experience suboptimal backpressure handling or unexpected WFT failures due to arbitrary default slot limits.",
      "rootCause": "When slot suppliers have no defined upper limit, there is no principled way to choose a reasonable default backpressure semaphore size, currently hardcoded to 100.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "for suppliers with no defined upper-limit on slots, there is no way to pick a reasonable number, so we default to 100",
      "number": 2149,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:27.703Z"
    },
    {
      "summary": "Add missing toString() implementations for OperatorServiceStubsOptions and CloudServiceStubsOptions, and fix WorkflowServiceStubsOptions.toString() to include inherited fields.",
      "category": "feature",
      "subcategory": "service-stubs",
      "apis": [
        "WorkflowServiceStubsOptions",
        "OperatorServiceStubsOptions",
        "CloudServiceStubsOptions"
      ],
      "components": [
        "service-stubs",
        "options",
        "serialization"
      ],
      "concepts": [
        "toString",
        "debugging",
        "configuration",
        "representation",
        "inheritance"
      ],
      "severity": "low",
      "userImpact": "Users lack proper string representations for service stub options objects, making debugging and logging less informative.",
      "rootCause": null,
      "proposedFix": "Implement toString() methods for OperatorServiceStubsOptions and CloudServiceStubsOptions, and update WorkflowServiceStubsOptions.toString() to include inherited fields.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2146
      ],
      "keyQuote": "WorkflowServiceStubsOptions.toString only includes direct fields not inherited ones",
      "number": 2148,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:12.243Z"
    },
    {
      "summary": "Test server's update/poll-update endpoints should implement proper long-poll timeout behavior instead of potentially throwing timeout exceptions. The timeout should either match the get-history call's 20-second hardcoded value or be set to 10 seconds before the user-set deadline.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "update-polling",
        "long-poll-handler"
      ],
      "concepts": [
        "long-polling",
        "timeout",
        "deadline",
        "poll-update",
        "test-framework"
      ],
      "severity": "medium",
      "userImpact": "Test server may throw timeout exceptions during update/poll-update operations, causing flaky or failing tests for users relying on proper long-poll behavior.",
      "rootCause": "Test server does not properly implement long-poll timeout semantics for update/poll-update endpoints, potentially causing premature timeout exceptions.",
      "proposedFix": "Update the test server to handle update/poll-update long-poll timeouts similar to get-history (either use hardcoded 20s or set to 10s before user-set deadline).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing proper long-poll timeout behavior in the test server for update/poll-update endpoints.",
      "related": [
        1903
      ],
      "keyQuote": "Start/poll update long poll timeout should return empty response. This could be updated to just match the get-history call which is hardcoded to 20s",
      "number": 2142,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:13.027Z"
    },
    {
      "summary": "Add support for query filters when listing schedules in the Java SDK, matching the existing functionality available for listing workflows.",
      "category": "feature",
      "subcategory": "schedule-management",
      "apis": [
        "ListSchedules"
      ],
      "components": [
        "schedule-client",
        "query-filter",
        "list-operations"
      ],
      "concepts": [
        "query-filtering",
        "schedule-listing",
        "api-parity",
        "workflow-operations"
      ],
      "severity": "low",
      "userImpact": "Users cannot filter schedules during listing operations, reducing usability and requiring client-side filtering.",
      "rootCause": null,
      "proposedFix": "Implement query parameter support for ListSchedules to match ListWorkflows functionality",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Query support was added to the ListSchedules operation in the Java SDK",
      "related": [],
      "keyQuote": "Need to support the query option when listing schedules same as we do when listing workflows.",
      "number": 2139,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:13.661Z"
    },
    {
      "summary": "The Java SDK's `getSystemInfo` call (used in `ChannelManager#getServerCapabilities`) intentionally overrides the RPC timeout configuration, forcing users to rely on the deprecated `healthCheckAttemptTimeout` option. A request to add a separate `getSystemInfoTimeout` configuration option to allow independent deadline control.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [
        "getSystemInfo",
        "getServerCapabilities"
      ],
      "components": [
        "ChannelManager",
        "SystemInfoInterceptor",
        "ServiceStubsOptions"
      ],
      "concepts": [
        "timeout",
        "deadline",
        "configuration",
        "connection",
        "initialization",
        "gRPC"
      ],
      "severity": "high",
      "userImpact": "Users cannot configure the deadline for server capability checks independently and are forced to use deprecated APIs as a workaround, causing connection failures when DNS resolution is slow.",
      "rootCause": "The `getServerCapabilities` RPC call in `SystemInfoInterceptor` intentionally overrides the global RPC timeout with a hardcoded deadline, preventing configuration through the standard `rpcTimeout` option.",
      "proposedFix": "Add a new `getSystemInfoTimeout` configuration option to `ServiceStubsOptions` to allow independent control of the server capability check deadline.",
      "workaround": "Use the deprecated `setHealthCheckAttemptTimeout` method in `ServiceStubsOptions`.",
      "resolution": "fixed",
      "resolutionDetails": "A new configuration option was introduced to allow independent control of the system info timeout.",
      "related": [],
      "keyQuote": "We have encountered a problem connecting to Temporal after upgrading Java SDK from version 1.23.2 to 1.24.0. When we increased the timeout problem was solved.",
      "number": 2132,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:58.200Z"
    },
    {
      "summary": "NoClassDefFoundError occurs when creating WorkflowServiceStubs Bean with Spring 3.3.1 due to protobuf version conflict. The issue arises from protobuf 4.26.1 used by DGS framework being incompatible with grpc-java.",
      "category": "bug",
      "subcategory": "dependency-conflict",
      "apis": [
        "WorkflowServiceStubs"
      ],
      "components": [
        "spring-integration",
        "grpc-client",
        "protobuf-dependency"
      ],
      "concepts": [
        "classloader",
        "dependency-management",
        "spring-beans",
        "protobuf-compatibility",
        "grpc"
      ],
      "severity": "high",
      "userImpact": "Users cannot initialize Temporal SDK with Spring 3.3.1 when using frameworks like DGS that depend on protobuf 4.26.1, causing application startup failure.",
      "rootCause": "Protobuf 4.26.1 is incompatible with grpc-java, resulting in missing GeneratedMessageV3 class at runtime despite being on classpath.",
      "proposedFix": null,
      "workaround": "Use shaded Temporal SDK to avoid protobuf version conflicts.",
      "resolution": "invalid",
      "resolutionDetails": "User found workaround using shaded Temporal SDK; issue closed by reporter as it's a known grpc-java compatibility issue with protobuf 4.26.",
      "related": [],
      "keyQuote": "Yes protobuf `4.26` is know to be problematic with `grpc-java`",
      "number": 2128,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:58.559Z"
    },
    {
      "summary": "Test server occasionally fails to include signal events in the first workflow task for SDK Python when signals are sent before the worker starts, particularly on macOS Intel runners. The signal event is sometimes missing from the first WFT activation, causing the workflow to process start_workflow before signal_workflow.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "start_workflow",
        "signal_workflow"
      ],
      "components": [
        "test-server",
        "activation",
        "signal-handling",
        "workflow-task"
      ],
      "concepts": [
        "signal-ordering",
        "race-condition",
        "event-sequencing",
        "time-skipping",
        "activation-ordering",
        "event-loss"
      ],
      "severity": "medium",
      "userImpact": "Test reliability is compromised as signals sent before worker startup are occasionally not included in the first workflow task, causing test flakiness on certain platforms.",
      "rootCause": "Test server does not reliably include signal events in the first WFT when signals are sent before worker startup, with the issue more common on macOS Intel builds; cancel requests appear to work around the issue.",
      "proposedFix": null,
      "workaround": "Sending a cancel request before starting the worker appears to ensure all signals are included in the first WFT.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        556
      ],
      "keyQuote": "Occasionally (on `macos-intel` builds) Python processes a `start_workflow` activation job first... the first WFT has no signal in it",
      "number": 2127,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T20:00:00.446Z"
    },
    {
      "summary": "Add extension point to control MDC (Mapped Diagnostic Context) key naming conventions in the Java SDK worker. Currently MDC keys are statically defined, but users need flexibility to implement custom naming conventions that align with Python SDK and other services.",
      "category": "feature",
      "subcategory": "logging-mdc",
      "apis": [],
      "components": [
        "worker",
        "logging",
        "mdc"
      ],
      "concepts": [
        "logging",
        "mdc",
        "naming-convention",
        "extension-point",
        "observability",
        "integration"
      ],
      "severity": "medium",
      "userImpact": "Users managing multiple language stacks cannot align logging naming conventions across services without implementing custom workarounds.",
      "rootCause": null,
      "proposedFix": "Provide an extension point or configuration mechanism to allow custom MDC key naming strategies in the worker.",
      "workaround": "Implement custom logging code as a workaround (as mentioned by the author).",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we have multiple stacks: Java + Python and trying to unite our services logs/metrics/traces with single naming conventions",
      "number": 2124,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:44.356Z"
    },
    {
      "summary": "Java SDK lacks a method to register workflows with static names during registration. Users need this to share workflow definitions across different language platforms (Go, Python) via protobuf enums, which annotations alone cannot support.",
      "category": "feature",
      "subcategory": "workflow-registration",
      "apis": [
        "WorkflowImplementationOptions",
        "registerWorkflowImplementationTypes"
      ],
      "components": [
        "worker",
        "workflow-registration",
        "implementation-options"
      ],
      "concepts": [
        "static-naming",
        "cross-platform-compatibility",
        "workflow-definition-sharing",
        "protocol-buffers",
        "multi-language-support"
      ],
      "severity": "medium",
      "userImpact": "Users sharing workflows across Java and non-Java services cannot use static names for workflow registration, limiting cross-platform workflow execution.",
      "rootCause": null,
      "proposedFix": "Add a setDefaultWorkflowImplementationTypeName() method to WorkflowImplementationOptions to allow static name registration during worker.registerWorkflowImplementationTypes() call.",
      "workaround": "Use annotation-based names or accept the default short name of the workflow interface, though this doesn't work for cross-language scenarios.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We need a way to set a default workflow implementation type name during registration... to define workflows that can be triggered across different apps with a shared static name.",
      "number": 2122,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:42.775Z"
    },
    {
      "summary": "When workers-auto-discovery is enabled in Spring Boot autoconfigure, the @Profile annotation on @WorkflowImpl classes is ignored, causing workflows to be discovered even when their profile condition doesn't match. The ClassPathScanningCandidateComponentProvider scanner lacks Environment configuration needed to evaluate @Conditional annotations.",
      "category": "bug",
      "subcategory": "spring-boot-autoconfigure",
      "apis": [],
      "components": [
        "workers-auto-discovery",
        "spring-boot-autoconfigure",
        "ClassPathScanningCandidateComponentProvider",
        "workflow-discovery"
      ],
      "concepts": [
        "profile-matching",
        "conditional-beans",
        "auto-discovery",
        "spring-configuration",
        "worker-registration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot conditionally disable workflows based on Spring profiles when using auto-discovery, forcing them to use workarounds like manual registration or package separation.",
      "rootCause": "ClassPathScanningCandidateComponentProvider is instantiated without passing the Environment, preventing evaluation of @Conditional annotations like @Profile",
      "proposedFix": "Pass Environment to the scanner to enable @Conditional annotation evaluation, or add Spring-aware configuration beans to conditionally manage workers",
      "workaround": "Disable auto-discovery and manually register conditional workers to the worker factory, or place workflows in separate packages",
      "resolution": "wontfix",
      "resolutionDetails": "Workflow classes are not intended to be Spring beans, so @Profile support is considered outside the intended use case. Users should use explicit configuration or package separation.",
      "related": [],
      "keyQuote": "Profile effects what beans are included, technically workflow classes are not beans by intention, but I think it would be reasonable here to respect Profile",
      "number": 2121,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:45.125Z"
    },
    {
      "summary": "Local activity execution metrics (temporal_activity_succeed_endtoend_latency and temporal_local_activity_execution_failed) are not being reported in production, despite being implemented identically to normal activity metrics. End-to-end latency metrics are missing while execution metrics are reported, and execution failures appear not to be captured.",
      "category": "bug",
      "subcategory": "metrics-reporting",
      "apis": [],
      "components": [
        "local-activity-executor",
        "metrics-reporter",
        "worker"
      ],
      "concepts": [
        "metrics",
        "local-activity",
        "latency",
        "failure-reporting",
        "end-to-end",
        "production-monitoring"
      ],
      "severity": "high",
      "userImpact": "Users cannot monitor local activity performance and failures in production, limiting visibility into workflow execution health.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We also pretty sure there are many cases of LA execution failure but not reported based on our workflow history.",
      "number": 2119,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:26.265Z"
    },
    {
      "summary": "Java SDK uses different OpenTelemetry span tag names (workflowId, runId) compared to other SDKs (temporalWorkflowID, temporalRunID). Request to allow customization of OTel span tags so users can make them consistent across SDKs.",
      "category": "feature",
      "subcategory": "observability-otel",
      "apis": [],
      "components": [
        "opentelemetry-interceptor",
        "span-tags",
        "instrumentation"
      ],
      "concepts": [
        "observability",
        "telemetry",
        "standardization",
        "customization",
        "compatibility",
        "otel-spans"
      ],
      "severity": "low",
      "userImpact": "Users cannot standardize OpenTelemetry span tag naming across multi-SDK deployments without Java SDK customization support.",
      "rootCause": "Java SDK currently uses different span tag naming conventions than other SDKs for compatibility reasons, and lacks OpenTelemetry interceptor customization.",
      "proposedFix": "Create a first-class OpenTelemetry interceptor (replacing current OpenTracing) that allows customization of span tag names, similar to .NET SDK.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Go and Python and .NET and others use `temporalWorkflowID`, `temporalRunID`, `temporalActivityID`, etc but Java uses `workflowId` and `runId`",
      "number": 2117,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:30.166Z"
    },
    {
      "summary": "Request for a workflow-friendly concurrency control mechanism (mutex/semaphore) that is reentrant and deterministic for use within Temporal workflow coroutines, including signal and update handlers.",
      "category": "feature",
      "subcategory": "workflow-concurrency",
      "apis": [],
      "components": [
        "workflow-coroutine",
        "signal-handler",
        "update-handler"
      ],
      "concepts": [
        "concurrency-control",
        "mutex",
        "semaphore",
        "reentrancy",
        "determinism",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "Users need a safe way to coordinate concurrent operations within workflows without non-deterministic behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Workflow-friendly concurrency control was implemented to meet the requirements.",
      "related": [],
      "keyQuote": "We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.",
      "number": 2116,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:27.202Z"
    },
    {
      "summary": "Minimal testing issue with no description provided. The issue appears to be a placeholder or incomplete submission with only the word 'testing' in the body.",
      "category": "other",
      "subcategory": "test-framework",
      "apis": [],
      "components": [],
      "concepts": [
        "testing",
        "quality-assurance"
      ],
      "severity": "low",
      "userImpact": "Unclear due to minimal issue description; unable to determine actual user impact.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed likely due to being incomplete or a test submission with insufficient information.",
      "related": [],
      "keyQuote": "testing",
      "number": 2114,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:12.477Z"
    },
    {
      "summary": "Placeholder issue with minimal content marked as testing.",
      "category": "other",
      "subcategory": "test-infrastructure",
      "apis": [],
      "components": [],
      "concepts": [
        "testing",
        "placeholder"
      ],
      "severity": "low",
      "userImpact": "No user impact; this appears to be a test or placeholder issue.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Closed as invalid - appears to be a placeholder or test issue with no meaningful content.",
      "related": [],
      "keyQuote": null,
      "number": 2113,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:13.553Z"
    },
    {
      "summary": "Placeholder testing issue with minimal content. No actual problem statement or test framework question is provided.",
      "category": "other",
      "subcategory": "test-framework",
      "apis": [],
      "components": [],
      "concepts": [
        "testing",
        "validation"
      ],
      "severity": "low",
      "userImpact": "Unable to determine impact from this minimal issue description.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue closed as invalid - appears to be a test or placeholder issue with no substantive content",
      "related": [],
      "keyQuote": "testing",
      "number": 2112,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:14.985Z"
    },
    {
      "summary": "Minimal issue with only the word 'testing' as the title and body. Unclear what the actual testing-related problem or request is.",
      "category": "other",
      "subcategory": "unclear",
      "apis": [],
      "components": [],
      "concepts": [
        "testing"
      ],
      "severity": "low",
      "userImpact": "Cannot determine impact due to insufficient information provided in the issue.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was too vague to process and was closed as invalid.",
      "related": [],
      "keyQuote": "testing",
      "number": 2111,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:02.316Z"
    },
    {
      "summary": "WorkflowHistoryLoader fails to load event history downloaded from Temporal UI with the 'Decode History' option enabled. The UI produces a JSON format that is incompatible with the SDK's protobuf parser, causing InvalidProtocolBufferException when attempting to load the history for testing and replay purposes.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "WorkflowHistoryLoader.readHistory"
      ],
      "components": [
        "WorkflowHistoryLoader",
        "WorkflowExecutionHistory",
        "DataConverter"
      ],
      "concepts": [
        "history-replay",
        "testing",
        "data-format-compatibility",
        "deserialization",
        "UI-SDK-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot load decoded event histories downloaded from Temporal UI for local testing with WorkflowReplayer, limiting their ability to test workflow changes against actual execution histories.",
      "rootCause": "The UI 'Decode History' feature produces JSON in a format incompatible with the SDK's protobuf parser expectations, specifically for BYTES type fields.",
      "proposedFix": "Add SDK utilities to decode encrypted payloads in history to make replay easier (planned as per comment reference to temporalio/features#468).",
      "workaround": "Download history from CLI or SDK instead of UI, as documented in the testing suite guide.",
      "resolution": "wontfix",
      "resolutionDetails": "The UI 'Decode History' feature is designed for human consumption, not SDK consumption, and is intentionally not compatible with SDKs. The recommended approach is to download history from CLI or SDK.",
      "related": [
        468
      ],
      "keyQuote": "The UI 'Decode History' is designed for human consumption not SDK consumption and is not intended to be compatible with SDKs",
      "number": 2109,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:01.851Z"
    },
    {
      "summary": "LocalActivityMeteringHelper throws ConcurrentModificationException when executing workflow tasks with local activities due to illegal modifications to its underlying data structure during newWFTStarting calls.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "LocalActivityMeteringHelper",
        "ReplayWorkflowRunTaskHandler",
        "WorkflowWorker"
      ],
      "concepts": [
        "concurrent-modification",
        "local-activities",
        "workflow-task-execution",
        "data-structure-iteration",
        "thread-safety"
      ],
      "severity": "high",
      "userImpact": "Users executing workflows with local activities experience runtime crashes due to ConcurrentModificationException, preventing workflow execution.",
      "rootCause": "LocalActivityMeteringHelper modifies a HashMap while iterating over it during newWFTStarting, violating HashMap's concurrent modification contract.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The concurrent modification issue in LocalActivityMeteringHelper was resolved, likely by using a copy of the collection or synchronized iteration.",
      "related": [],
      "keyQuote": "LocalActivityMeteringHelper may attempt to make illegal modifications to its underlying data structure when calling newWFTStarting causing a ConcurrentModificationException",
      "number": 2107,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:59:02.037Z"
    },
    {
      "summary": "Investigate whether Java proto library allows non-UTF8 strings in proto messages, following a similar validation gap discovered in Go. Determine compatibility and plan mitigation if needed.",
      "category": "question",
      "subcategory": "proto-serialization",
      "apis": [],
      "components": [
        "proto-serialization",
        "failure-message"
      ],
      "concepts": [
        "utf8-validation",
        "proto-compatibility",
        "data-serialization",
        "cross-language-compatibility"
      ],
      "severity": "low",
      "userImpact": "Users who have previously set invalid UTF-8 in proto Failure messages may experience compatibility issues between SDKs.",
      "rootCause": "Proto library implementations differ in UTF-8 validation enforcement between gogoproto and common proto across languages.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Confirmed that the Java proto library does not allow non-UTF8 proto strings, resolving the investigation.",
      "related": [],
      "keyQuote": "Confirmed the java proto library does not allow non-utf8 proto string",
      "number": 2106,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:49.104Z"
    },
    {
      "summary": "Java SDK is not reporting workflow_failures metrics when exceptions are thrown by the SDK itself (such as NonDeterministicException), causing a discrepancy between SDK metrics and Temporal Cloud metrics.",
      "category": "bug",
      "subcategory": "workflow-metrics",
      "apis": [],
      "components": [
        "ReplayWorkflowExecutor",
        "ReplayWorkflowRunTaskHandler",
        "WorkflowImplementationOptions"
      ],
      "concepts": [
        "metrics",
        "workflow-failure",
        "exception-handling",
        "instrumentation",
        "nondeterminism"
      ],
      "severity": "medium",
      "userImpact": "Users cannot accurately monitor workflow failures through SDK metrics when failures are caused by SDK-thrown exceptions, leading to inconsistent metric data between local SDK and Temporal Cloud.",
      "rootCause": "The Java SDK only reports workflow_failures from ReplayWorkflowExecutor.java:97, which is not reachable when WorkflowExecutionException is thrown from ReplayWorkflowRunTaskHandler.java:256-260.",
      "proposedFix": null,
      "workaround": "None identified in discussion.",
      "resolution": "fixed",
      "resolutionDetails": "SDK was updated to report workflow_failures metrics correctly when exceptions are thrown by the SDK itself, not just when thrown in user workflow code.",
      "related": [
        1590
      ],
      "keyQuote": "Java SDK is not reporting workflow_failures from the code path via the FailWorkflowExceptionTypes",
      "number": 2103,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:48.641Z"
    },
    {
      "summary": "Retry policies configured on scheduled workflows via RetryOptions are not being applied when the workflow fails. The retry configuration is ignored during the mapping from Java SDK objects to protobuf service client objects, causing scheduled workflow retries to either fail to work or use an incorrect default retry policy.",
      "category": "bug",
      "subcategory": "scheduled-workflows",
      "apis": [
        "ScheduleActionStartWorkflow",
        "WorkflowOptions",
        "RetryOptions",
        "ScheduleClient",
        "createSchedule"
      ],
      "components": [
        "schedule-client",
        "proto-serialization",
        "retry-policy",
        "workflow-options"
      ],
      "concepts": [
        "retry",
        "scheduled-workflows",
        "backoff-coefficient",
        "workflow-execution",
        "retry-policy-serialization"
      ],
      "severity": "high",
      "userImpact": "Users cannot configure custom retry policies for scheduled workflows, breaking a critical reliability pattern and causing unexpected workflow behavior.",
      "rootCause": "RetryOptions object is ignored during mapping of ScheduleAction from temporal-sdk-java to temporal-serviceclient protobuf objects. The RetryPolicy field in NewWorkflowExecutionInfo remains null despite RetryOptions being provided.",
      "proposedFix": "Fix the proto serialization in ScheduleProtoUtil.actionToProto() to properly map RetryOptions to the protobuf RetryPolicy field.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved in PR #2082 included in Java SDK v1.24.0",
      "related": [
        2082
      ],
      "keyQuote": "RetryOptions object which we pass to the Temporal client is being ignored. During that mapping ScheduleAction.action_.retryPolicy_ stays null",
      "number": 2100,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:47.363Z"
    },
    {
      "summary": "TestActivityEnvironment throws NullPointerException when testing asynchronous activities with doNotCompleteOnReturn(). The test framework expects activities to complete, fail, or be cancelled, but async activities that don't complete on return leave result fields null.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "doNotCompleteOnReturn"
      ],
      "components": [
        "TestActivityEnvironment",
        "TestActivityEnvironmentInternal",
        "ActivityTaskHandler"
      ],
      "concepts": [
        "asynchronous-completion",
        "activity-testing",
        "null-pointer-exception",
        "test-environment",
        "activity-result"
      ],
      "severity": "high",
      "userImpact": "Users cannot test asynchronous activities with doNotCompleteOnReturn() using the provided test framework, blocking testing of important async patterns.",
      "rootCause": "TestActivityEnvironmentInternal.completeActivity() method assumes ActivityTaskHandler.Result will have either cancelled, failed, or completed fields set, but async activities without completion leave all fields null, causing NullPointerException at response.getTaskFailed().",
      "proposedFix": "Handle the case where all result fields are null by checking for null before accessing getTaskFailed(), or skip completion handling for async activities that don't complete on return.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was fixed with a small patch that handles null result fields in async activity completion.",
      "related": [
        460
      ],
      "keyQuote": "NullPointerException at response.getTaskFailed() is null - TestActivityEnvironmentInternal expects either cancelled, failed or completed activity",
      "number": 2097,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:35.075Z"
    },
    {
      "summary": "The Java SDK executes StartUpdate and waits for the update to reach the required stage outside of the intercepted call, differing from other SDKs where this wait happens inside the interceptor. This prevents interceptors from running logic after the StartUpdate call completes.",
      "category": "bug",
      "subcategory": "update-request-handling",
      "apis": [
        "StartUpdate"
      ],
      "components": [
        "update-executor",
        "interceptor",
        "call-handler"
      ],
      "concepts": [
        "interceptor",
        "blocking",
        "synchronization",
        "update-staging",
        "cross-sdk-alignment"
      ],
      "severity": "high",
      "userImpact": "Users cannot execute custom logic in interceptors after StartUpdate calls, limiting interceptor functionality and breaking consistency with other SDK implementations.",
      "rootCause": "Java SDK blocks on update stage requirement outside the intercepted call scope, whereas other SDKs perform this wait inside the interceptor.",
      "proposedFix": "Move the blocking wait for update stage requirement inside the intercepted call to align Java SDK behavior with other SDKs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation was updated to move the StartUpdate blocking logic inside the intercepted call, aligning Java SDK with other SDKs.",
      "related": [],
      "keyQuote": "This makes it impossible to run logic in the interceptor after the start update call has completed. We need to align the Java SDK with other SDKs here.",
      "number": 2094,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:32.846Z"
    },
    {
      "summary": "Request to expose UpdateID in update handlers to allow users to use it as a unique primary key for handlers in the Java SDK.",
      "category": "feature",
      "subcategory": "update-handler",
      "apis": [
        "UpdateID"
      ],
      "components": [
        "update-handler",
        "workflow-execution"
      ],
      "concepts": [
        "unique-identifier",
        "primary-key",
        "handler-tracking",
        "update-context"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to use UpdateID as a unique primary key to track and manage update handlers.",
      "rootCause": null,
      "proposedFix": "Expose UpdateID field in update handler context/parameters",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "UpdateID was exposed in the update handler to provide users with a unique identifier for handlers",
      "related": [],
      "keyQuote": "This will allow users to use it when they want a unique primary key for handlers.",
      "number": 2093,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:34.152Z"
    },
    {
      "summary": "The activity_succeed_endtoend_latency metric is not reported when completing activities using ActivityCompletionClient.complete() for manual async completion. This metric should be captured when in-process async activities are completed manually.",
      "category": "bug",
      "subcategory": "activity-metrics",
      "apis": [
        "ActivityCompletionClient"
      ],
      "components": [
        "ManualActivityCompletionClientImpl",
        "metrics",
        "activity-executor"
      ],
      "concepts": [
        "latency-metrics",
        "async-activity",
        "manual-completion",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users relying on async activity completion cannot observe end-to-end latency metrics for their activities, limiting visibility into performance.",
      "rootCause": "The ActivityCompletionClient.complete() method bypasses Temporal's normal completion mechanisms where the metric is recorded, similar to how other SDKs handle async completion.",
      "proposedFix": "Add activity_succeed_endtoend_latency metric reporting to the ManualActivityCompletionClientImpl.complete() method when completing in-process async activities.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Metric is not reported, you can find a reproduction here https://github.com/antmendoza/my-temporal-pocs/tree/main/java/pocs/src/main/java/io/antmendoza/samples/_6442",
      "number": 2092,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:21.262Z"
    },
    {
      "summary": "Users need methods to wait for all handlers to finish when continuing as new or exiting a workflow. This requires explicit user specification since the SDK cannot automatically determine the desired behavior.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "workflow-executor",
        "handler-manager"
      ],
      "concepts": [
        "handler-lifecycle",
        "workflow-exit",
        "async-completion",
        "resource-cleanup"
      ],
      "severity": "medium",
      "userImpact": "Users lack a convenient way to await or ignore remaining handlers during workflow state transitions, requiring manual error-prone handling.",
      "rootCause": null,
      "proposedFix": "Provide methods that allow users to explicitly specify whether to await all handlers or ignore them when continuing as new or exiting.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "SDK provides explicit methods for users to wait for or ignore handlers during workflow transitions.",
      "related": [],
      "keyQuote": "Users want to easily await (or ignore) all their remaining handlers when they continue as new or exit the workflow.",
      "number": 2091,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:21.456Z"
    },
    {
      "summary": "Add warnings or errors when update handlers don't complete before workflow exits due to cancellation or workflow end. The proposal includes methods like `all_handlers_finished()` to allow workflows to wait for handler completion, with configurable policies to warn or abandon unfinished handlers.",
      "category": "feature",
      "subcategory": "update-handlers",
      "apis": [
        "all_handlers_finished"
      ],
      "components": [
        "update-handler",
        "workflow-exit",
        "signal-handler"
      ],
      "concepts": [
        "handler-lifecycle",
        "workflow-completion",
        "cancellation",
        "policy-configuration",
        "warning-system"
      ],
      "severity": "medium",
      "userImpact": "Users can now detect and handle situations where update or signal handlers don't complete before workflow exits, preventing silent failures and data loss.",
      "rootCause": null,
      "proposedFix": "Implement `workflow.all_handlers_finished()` method, emit `UnfinishedUpdateHandlersWarning` and `UnfinishedSignalHandlersWarning` on worker side, provide `HandlerUnfinishedPolicy` with WARN_AND_ABANDON default and ABANDON options, include TMPRL1102 rule identifier in warning messages.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as cross-SDK feature with Python PR merged first, then rolled out to other SDKs including Java with configurable handler completion policies and warnings.",
      "related": [],
      "keyQuote": "Users can wait on a method named similarly to `workflow.all_handlers_finished()` and warnings are controlled by a policy whose default value is `HandlerUnfinishedPolicy.WARN_AND_ABANDON`",
      "number": 2090,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:20.650Z"
    },
    {
      "summary": "gRPC version 1.54.0 causes JVM crashes on Alpine Linux. This is a compatibility issue that was resolved by updating the Java SDK's gRPC dependency in v1.28.0.",
      "category": "bug",
      "subcategory": "dependency-compatibility",
      "apis": [],
      "components": [
        "grpc-dependency",
        "jvm-runtime"
      ],
      "concepts": [
        "jvm-crash",
        "alpine-linux",
        "dependency-upgrade",
        "version-compatibility",
        "runtime-stability"
      ],
      "severity": "high",
      "userImpact": "Users running the Java SDK on Alpine Linux experience JVM crashes due to gRPC version incompatibility.",
      "rootCause": "gRPC version 1.54.0 has a compatibility issue with Alpine Linux JVM runtime.",
      "proposedFix": "Upgrade to a compatible gRPC version (resolved in SDK v1.28.0).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Java SDK v1.28.0 updated the gRPC dependency to a version compatible with Alpine Linux.",
      "related": [
        10096
      ],
      "keyQuote": "Java SDK `v1.28.0` updated `grpc`",
      "number": 2086,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:07.490Z"
    },
    {
      "summary": "Feature request to add worker-level identity configuration in WorkerOptions. Currently, only client-level identity is available, but users need per-worker identity specification for multi-worker deployments operating on different queues.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerFactory",
        "WorkerOptions",
        "SingleWorkerOptions"
      ],
      "components": [
        "worker",
        "worker-factory",
        "worker-options"
      ],
      "concepts": [
        "identity",
        "queue-routing",
        "multi-worker",
        "configuration",
        "infrastructure-integration"
      ],
      "severity": "medium",
      "userImpact": "Users running multiple workers for different queues cannot specify per-worker identity, forcing them to create separate clients and factories as a workaround.",
      "rootCause": "Worker identity configuration is only available at the client level, not at the individual worker level in WorkerOptions.",
      "proposedFix": "Add an identity option to WorkerOptions that takes priority over the client-level identity when SingleWorkerOptions are configured.",
      "workaround": "Create a separate WorkflowClient and WorkerFactory for each queue that requires a different identity.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I propose the introduction of an option to assign an identity within WorkerOptions, and for this identity to be treated as a priority when SingleWorkerOptions are being configured.",
      "number": 2078,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:07.111Z"
    },
    {
      "summary": "Feature request to automatically register search attributes from WorkflowStub in test environments, eliminating the need for explicit pre-registration in test code.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowStub"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "TestWorkflowRule",
        "TestWorkflowExtension",
        "test-client"
      ],
      "concepts": [
        "search-attributes",
        "auto-registration",
        "test-setup",
        "configuration",
        "workflow-testing"
      ],
      "severity": "low",
      "userImpact": "Test developers must manually register each search attribute before using it in tests, adding boilerplate code.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Feature request to auto-register search attributes from WorkflowStub created by test envWorkflowClient",
      "number": 2077,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:58:08.459Z"
    },
    {
      "summary": "Querying a running workflow causes previously logged messages to be replayed and logged again. During workflow query operations, the replaying flag is incorrectly set to false, causing exception logs to be duplicated when the workflow is replayed to handle the query.",
      "category": "bug",
      "subcategory": "workflow-query",
      "apis": [
        "WorkflowClient",
        "newWorkflowStub"
      ],
      "components": [
        "WorkflowStateMachines",
        "WorkflowExecutionHandler",
        "query-processing"
      ],
      "concepts": [
        "workflow-replay",
        "logging",
        "query-handling",
        "state-machine",
        "workflow-execution",
        "exception-handling"
      ],
      "severity": "medium",
      "userImpact": "Users see duplicate log entries when querying running workflows, causing log spam and difficulty in debugging.",
      "rootCause": "The replaying flag is being incorrectly set to false during query processing in WorkflowStateMachines, causing logs from workflow replay to be emitted again.",
      "proposedFix": "Ensure the replaying flag is properly maintained as true during workflow replay operations initiated by queries, as attempted in commit a41c64e.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by commit a41c64ece3876f584ebde70903668b817c5455d8 for inclusion in the next SDK release.",
      "related": [],
      "keyQuote": "Querying a workflow generates additional logs... replaying is being set to false... the issue is present in all of them [1.23.1, 1.23.2, master]",
      "number": 2076,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:55.594Z"
    },
    {
      "summary": "Worker shutdown immediately terminates activity heartbeats, preventing activities from completing during the graceful shutdown period. Users request the ability to maintain heartbeating during shutdown so activities can finish work within the awaitTermination timeout.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "WorkerFactory.shutdown",
        "WorkerFactory.awaitTermination",
        "ActivityWorkerShutdownException",
        "ActivityExecutionContext.useLocalManualCompletion",
        "ManualActivityCompletionClient"
      ],
      "components": [
        "worker",
        "activity-executor",
        "heartbeat-manager",
        "shutdown-handler"
      ],
      "concepts": [
        "graceful-shutdown",
        "heartbeat",
        "activity-completion",
        "worker-termination",
        "timeout",
        "lifecycle-management"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably complete long-running activities during worker shutdown, even when providing a timeout period via awaitTermination.",
      "rootCause": "WorkerFactory.shutdown immediately stops sending heartbeats and raises ActivityWorkerShutdownException, not respecting the awaitTermination timeout window.",
      "proposedFix": "Allow heartbeats to continue during the shutdown grace period specified by awaitTermination, only reporting ActivityWorkerShutdownException after the timeout expires.",
      "workaround": "Use ActivityExecutionContext.useLocalManualCompletion() and ManualActivityCompletionClient for manual heartbeating during shutdown.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I want the ability to keep heartbeating while the worker is shutting down so my activities can actually finish my activities work",
      "number": 2075,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:53.721Z"
    },
    {
      "summary": "Update request needs to be sent back in accept/reject responses to the server. This aligns with the Go SDK implementation (PR #1480) to ensure proper round-trip of update request data.",
      "category": "feature",
      "subcategory": "update-handling",
      "apis": [
        "WorkflowUpdate"
      ],
      "components": [
        "update-handler",
        "server-communication",
        "request-response"
      ],
      "concepts": [
        "update-request",
        "accept-reject",
        "request-response",
        "server-sync",
        "round-trip"
      ],
      "severity": "medium",
      "userImpact": "Updates processed by the Java SDK must properly return original request data to the server, ensuring consistency with other SDKs and correct server-side tracking.",
      "rootCause": null,
      "proposedFix": "Modify accept/reject response handlers to include the original update request, matching the implementation pattern from sdk-go PR #1480.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed to send original update request back in accept/reject responses, aligning with Go SDK pattern.",
      "related": [],
      "keyQuote": "See https://github.com/temporalio/sdk-go/pull/1480, need to send original request back to server when accepting/rejecting update.",
      "number": 2073,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:51.086Z"
    },
    {
      "summary": "KotlinObjectMapperFactory crashes with MethodNotFoundError when upgrading jackson kotlin library due to reliance on deprecated KotlinModule constructor. The fix requires using the builder pattern as a fallback or exclusively to ensure forward compatibility.",
      "category": "bug",
      "subcategory": "kotlin-serialization",
      "apis": [],
      "components": [
        "KotlinObjectMapperFactory",
        "JacksonJsonPayloadConverter",
        "DataConverter"
      ],
      "concepts": [
        "forward-compatibility",
        "deprecated-methods",
        "jackson-integration",
        "kotlin-module",
        "serialization",
        "version-upgrade"
      ],
      "severity": "high",
      "userImpact": "Kotlin users cannot upgrade their jackson kotlin library without breaking temporal integration.",
      "rootCause": "KotlinObjectMapperFactory uses a deprecated KotlinModule constructor that was removed in newer jackson-kotlin versions.",
      "proposedFix": "Use KotlinModule.Builder().build() pattern with fallback to deprecated constructor, or use builder exclusively.",
      "workaround": "Register KotlinModule manually using mapper.registerModule(KotlinModule.Builder().build()) and create custom DataConverter.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1387
      ],
      "keyQuote": "Instead of using a deprecated method, it would have been best to try using the builder first, then fall back to the deprecated KotlinModule constructor.",
      "number": 2071,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:39.247Z"
    },
    {
      "summary": "Request to wrap gRPC CANCELED and DEADLINE_EXCEEDED errors in a custom SDK Timeout exception for Update operations, so users only need to catch one predictable exception instead of handling multiple gRPC error types.",
      "category": "feature",
      "subcategory": "update-timeout-handling",
      "apis": [
        "Update"
      ],
      "components": [
        "update-handler",
        "grpc-client",
        "exception-wrapping"
      ],
      "concepts": [
        "timeout",
        "exception-handling",
        "grpc-errors",
        "deadline",
        "cancelation",
        "error-wrapping"
      ],
      "severity": "medium",
      "userImpact": "Users must currently catch multiple gRPC exceptions for timeout scenarios in Update operations instead of a single predictable SDK exception.",
      "rootCause": "Update operations expose raw gRPC CANCELED and DEADLINE_EXCEEDED errors instead of wrapping them in SDK-level timeout exceptions.",
      "proposedFix": "Wrap gRPC CANCELED and DEADLINE_EXCEEDED errors in a custom SDK Timeout exception for Update operations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of broader timeout exception handling improvements referenced in temporalio/features#483.",
      "related": [
        483
      ],
      "keyQuote": "So that users only have to catch one predictable exception",
      "number": 2069,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:37.081Z"
    },
    {
      "summary": "Remove the ability to call continue-as-new in update handlers for the Java SDK. A previous decision to allow this was reverted across SDKs, but Java still has this functionality implemented and should be updated to disallow it.",
      "category": "other",
      "subcategory": "update-handlers",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "update-handler",
        "workflow-execution"
      ],
      "concepts": [
        "continue-as-new",
        "update-handlers",
        "workflow-lifecycle",
        "API-consistency",
        "SDK-alignment"
      ],
      "severity": "medium",
      "userImpact": "Users may accidentally use an unsupported feature that contradicts the behavior of other SDKs, leading to inconsistent workflow behavior.",
      "rootCause": "Java SDK was the only implementation to support continue-as-new in update handlers after a cross-SDK decision to revert this feature.",
      "proposedFix": "Fail with an error if users try to call continue-as-new within an update handler.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation aligned Java SDK with the reverted cross-SDK decision by disallowing continue-as-new in update handlers.",
      "related": [
        379
      ],
      "keyQuote": "Previously at https://github.com/temporalio/features/issues/379 it was decided to allow continue-as-new in update handlers. This decision has been reverted but Java was the only one that implemented it.",
      "number": 2068,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:40.176Z"
    },
    {
      "summary": "null Duration values in options classes like SchedulePolicy are sent as zero duration instead of being treated as unset, causing the server to apply minimum defaults instead of expected defaults (e.g., 10 second MinCatchupWindow instead of 1 year DefaultCatchupWindow).",
      "category": "bug",
      "subcategory": "protobuf-serialization",
      "apis": [
        "SchedulePolicy",
        "Schedule"
      ],
      "components": [
        "ProtobufTimeUtils",
        "schedule-creation",
        "protobuf-conversion"
      ],
      "concepts": [
        "duration-handling",
        "null-semantics",
        "protobuf-defaults",
        "schedule-configuration"
      ],
      "severity": "high",
      "userImpact": "Users cannot create schedules with unset durations and receive incorrect server-side defaults, breaking schedule configuration behavior.",
      "rootCause": "ProtobufTimeUtils converts null Duration to zero duration instead of preserving null to indicate unset value in protobuf messages, as required by the server's schedule handling logic.",
      "proposedFix": "Add conversion functions for Duration that preserve null values to distinguish between unset and zero duration in protobuf serialization.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, likely resolved by adding proper null-preserving duration conversion functions.",
      "related": [
        1950
      ],
      "keyQuote": "null values are sent as zero duration... server side treats it as 0 and uses MinCatchupWindow (=10 sec) instead of expected DefaultCatchupWindow (=1yr)",
      "number": 2065,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:26.033Z"
    },
    {
      "summary": "Request to add native image descriptors for GraalVM support in temporal-spring-boot-starter-alpha. Users are experiencing build failures when creating Spring Boot native images due to missing or conflicting native-image configuration files.",
      "category": "feature",
      "subcategory": "graalvm-native-image",
      "apis": [],
      "components": [
        "temporal-spring-boot-starter-alpha",
        "temporal-serviceclient",
        "grpc-netty-shaded"
      ],
      "concepts": [
        "native-image",
        "graalvm",
        "class-initialization",
        "spring-boot",
        "build-configuration"
      ],
      "severity": "high",
      "userImpact": "Users cannot build Spring Boot native images with Temporal SDK due to class initialization conflicts and missing GraalVM configuration descriptors.",
      "rootCause": "Erroneous native-image configurations in grpc-netty-shaded causing classes like Slf4JLoggerFactory to initialize at build time instead of runtime, and missing native-image descriptors in temporal-spring-boot-starter-alpha.",
      "proposedFix": "Add native image descriptors to temporal-spring-boot-starter-alpha similar to those already present in temporal-test-server at temporal-test-server/src/main/resources/META-INF/native-image/io.temporal/temporal-test-server",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        10601
      ],
      "keyQuote": "It would be nice to have native image descriptors as part of the temporal-spring-boot-starter-alpha... Currently I am experiencing different build issues when trying to build a spring boot app native image.",
      "number": 2064,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:24.258Z"
    },
    {
      "summary": "Feature request to extend TestWorkflowExtension to allow specifying a custom task queue name for the worker, enabling more flexible integration testing scenarios.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowExtension"
      ],
      "components": [
        "test-workflow-extension",
        "worker",
        "task-queue"
      ],
      "concepts": [
        "testing",
        "integration-testing",
        "task-queue-configuration",
        "worker-setup",
        "test-builder"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently specify custom task queue names when using TestWorkflowExtension, limiting integration test flexibility.",
      "rootCause": null,
      "proposedFix": "Add a setter method to TestWorkflowExtension builder (e.g., setWorkerTaskQueue(TASK_QUEUE)) to allow custom task queue name specification.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "it would be nice to have possibility to specify custom name for a worker queue when using TestWorkflowExtension",
      "number": 2063,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:21.362Z"
    },
    {
      "summary": "Request to call describe namespace on worker startup to validate namespace configuration and detect issues early. This aligns with the features repository initiative to improve worker initialization.",
      "category": "feature",
      "subcategory": "worker-initialization",
      "apis": [
        "Worker"
      ],
      "components": [
        "worker",
        "namespace-client",
        "initialization"
      ],
      "concepts": [
        "namespace-validation",
        "startup-checks",
        "configuration-detection",
        "error-handling",
        "initialization"
      ],
      "severity": "medium",
      "userImpact": "Workers could detect namespace configuration issues earlier at startup, improving debugging and preventing runtime failures.",
      "rootCause": null,
      "proposedFix": "Call describe namespace API during worker initialization to validate configuration",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to call describe namespace on worker start to improve startup validation",
      "related": [
        477
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/477",
      "number": 2060,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:07.594Z"
    },
    {
      "summary": "Implement a separate Cloud Operations API client for the Java SDK using cloud protos, mirroring implementations in other SDKs. The client should be marked as experimental.",
      "category": "feature",
      "subcategory": "cloud-client",
      "apis": [],
      "components": [
        "cloud-client",
        "proto-bindings",
        "api-client"
      ],
      "concepts": [
        "cloud-operations",
        "api-client",
        "experimental",
        "proto-definitions",
        "cloud-integration"
      ],
      "severity": "medium",
      "userImpact": "Users need a dedicated cloud operations API client to interact with Temporal Cloud services from Java applications.",
      "rootCause": null,
      "proposedFix": "Create a separate cloud client library using cloud protos, following the pattern established in the Go SDK (PR #1426).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Cloud operations API client was implemented as a separate component with experimental API marker.",
      "related": [
        440
      ],
      "keyQuote": "We need a separate cloud client using the cloud protos (they are separate today). The client should be marked experimental.",
      "number": 2059,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:10.041Z"
    },
    {
      "summary": "Add automatic Temporal-Namespace header to all namespace-specific gRPC requests in the Java SDK via an interceptor, eliminating the need for manual namespace configuration.",
      "category": "feature",
      "subcategory": "grpc-interceptor",
      "apis": [],
      "components": [
        "grpc-client",
        "interceptor",
        "namespace-handler"
      ],
      "concepts": [
        "namespace",
        "grpc-header",
        "interceptor",
        "request-metadata",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Simplifies namespace configuration by automatically setting the header on all namespace-specific requests, reducing boilerplate code.",
      "rootCause": null,
      "proposedFix": "Implement an interceptor that automatically sets the Temporal-Namespace header, potentially using reflection to call getNamespace() on requests.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented via gRPC interceptor to automatically set namespace headers on all namespace-specific requests.",
      "related": [
        475
      ],
      "keyQuote": "It needs to be an interceptor surely, but unsure how the implementation will do this generically.",
      "number": 2058,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:57:06.465Z"
    },
    {
      "summary": "Java SDK replay tests fail with non-deterministic error when child workflows use dynamically generated IDs derived from parent workflow ID. The replayer cannot match the child workflow ID generated at runtime with the ID stored in the event history.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.getInfo",
        "StartChildWorkflow"
      ],
      "components": [
        "replay-engine",
        "workflow-execution",
        "child-workflow",
        "history-matching"
      ],
      "concepts": [
        "determinism",
        "workflow-id-generation",
        "event-history",
        "replay-testing",
        "child-workflows",
        "workflow-context"
      ],
      "severity": "high",
      "userImpact": "Users cannot perform replay tests on workflows that dynamically generate child workflow IDs based on parent workflow context, blocking testing workflows with audit/tracing patterns.",
      "rootCause": "The replayer requires workflow ID to be specified upfront to match event history, but this requirement was undocumented. When workflow ID is derived from runtime context (parent workflow ID), the replayer cannot resolve it before matching events.",
      "proposedFix": "Workflow ID is now included in WorkflowExecutionStartedEventAttributes, allowing the SDK to automatically extract it from history if available, eliminating the need for manual specification.",
      "workaround": "Specify the workflow ID explicitly when using the replayer, or avoid using parent workflow ID as part of child workflow ID generation logic.",
      "resolution": "fixed",
      "resolutionDetails": "Workflow ID was added to WorkflowExecutionStartedEventAttributes in the Temporal API, enabling automatic extraction by the SDK.",
      "related": [],
      "keyQuote": "You need to specificy a workflow ID when using the replayer since it is not always in history",
      "number": 2057,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:55.382Z"
    },
    {
      "summary": "Allow update handlers to be completed asynchronously rather than blocking threads, similar to how activities support manual completion. This would enable workflows to handle multiple concurrent updates without excessive thread consumption.",
      "category": "feature",
      "subcategory": "async-updates",
      "apis": [
        "UpdateHandler"
      ],
      "components": [
        "update-handler",
        "workflow-executor",
        "async-completion"
      ],
      "concepts": [
        "async-completion",
        "thread-efficiency",
        "concurrent-updates",
        "manual-completion",
        "workflow-threading"
      ],
      "severity": "medium",
      "userImpact": "Users can implement long-running update handlers without consuming threads for each concurrent update, improving performance and scalability.",
      "rootCause": "Update handlers are currently run synchronously in their own threads, causing thread pool exhaustion when handling multiple concurrent updates.",
      "proposedFix": "Implement a native API similar to ActivityExecutionContext.isUseLocalManualCompletion() that allows update handlers to return a Promise that can be completed asynchronously in another thread.",
      "workaround": "Users can currently implement async updates with existing SDK API but must wait in the thread for results, which doesn't solve the thread consumption problem.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Support the ability to transform an update call into a Promise that can be completed later in another thread like the main workflow method",
      "number": 2056,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:51.349Z"
    },
    {
      "summary": "Add support for next-retry-delay in local activity application failures, allowing local activities to return retry delay information similar to regular activities.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "local-activity-executor",
        "retry-handler",
        "activity-failure"
      ],
      "concepts": [
        "retry",
        "delay",
        "local-activity",
        "failure-handling",
        "application-failure"
      ],
      "severity": "medium",
      "userImpact": "Users can now specify retry delays for local activity failures, providing consistent retry behavior across local and remote activities.",
      "rootCause": null,
      "proposedFix": "Implement next-retry-delay support in local activity execution path to match remote activity behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by pull request #2081 which implemented the requested feature.",
      "related": [
        419
      ],
      "keyQuote": "it was decided we need to support next retry delay in application failures from local activity too",
      "number": 2054,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:51.653Z"
    },
    {
      "summary": "Request to add timeout configuration at the activity method level via annotation (e.g., @ActivityTimeouts or extension to @MethodRetry) instead of requiring configuration at the activity stub level, which forces interface fragmentation for per-method settings.",
      "category": "feature",
      "subcategory": "activity-configuration",
      "apis": [
        "ActivityInterface",
        "ActivityMethod",
        "MethodRetry"
      ],
      "components": [
        "activity-interface",
        "activity-stub",
        "annotations"
      ],
      "concepts": [
        "timeout",
        "retry",
        "configuration",
        "annotation",
        "start-to-close",
        "schedule-to-close"
      ],
      "severity": "medium",
      "userImpact": "Users must either split activity interfaces into smaller pieces or use string-based activity names to configure per-method timeouts, losing type safety and code maintainability.",
      "rootCause": null,
      "proposedFix": "Add timeout parameters to @MethodRetry annotation or create a new @ActivityTimeouts annotation to specify start-to-close and schedule-to-close timeouts at the method level with precedence over stub-level config.",
      "workaround": "Use WorkflowImplementationOptions with string-based activity names, though this loses type safety and stub-level config still takes precedence.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "you specify retry and timeout options on the activity stub, which is based on the interface, so in order to have specific config for each activity you have to go out of your way and break up the interface",
      "number": 2051,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:38.020Z"
    },
    {
      "summary": "Feature request to support async activities in Java SDK by allowing activity methods to return CompletableFuture/CompletablePromise without blocking. The discussion explores whether activities should be able to handle Java's native async APIs and determinism constraints.",
      "category": "feature",
      "subcategory": "activity-async",
      "apis": [
        "ActivityMethod",
        "ManualActivityCompletionClient",
        "ActivityExecutionContext"
      ],
      "components": [
        "activity-executor",
        "activity-framework",
        "async-activities"
      ],
      "concepts": [
        "async-execution",
        "completable-future",
        "non-blocking",
        "determinism",
        "concurrent-primitives",
        "manual-completion"
      ],
      "severity": "medium",
      "userImpact": "Users implementing activities with Java async APIs must currently block on Future completion or use manual activity completion, reducing efficiency and usability.",
      "rootCause": "Java SDK cannot support Java's native concurrent primitives like CompletableFuture in workflows due to determinism requirements, limiting async activity patterns.",
      "proposedFix": "Provide AsyncActivityMethod annotation for activities returning CompletablePromise, with automatic handling similar to ManualActivityCompletionClient, reducing boilerplate.",
      "workaround": "Use ManualActivityCompletionClient for manual async activity completion, or use doNotCompleteOnReturn() with virtual threads.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed as not planned because the existing ManualActivityCompletionClient API already provides the needed functionality for async activity patterns.",
      "related": [],
      "keyQuote": "this case is already covered by the ManualActivityCompletionClient",
      "number": 2049,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:39.003Z"
    },
    {
      "summary": "ScheduleClient lacks an API to add interceptors (ScheduleClientCallsInterceptor or ScheduleClientInterceptor) for request interception and customization, following the pattern established by WorkflowClient.",
      "category": "feature",
      "subcategory": "schedule-client-interceptors",
      "apis": [
        "ScheduleClient",
        "ScheduleClientOptions",
        "ScheduleClientCallsInterceptor"
      ],
      "components": [
        "schedule-client",
        "client-options",
        "interceptor-framework"
      ],
      "concepts": [
        "interceptors",
        "request-interception",
        "client-customization",
        "api-consistency",
        "extension-point"
      ],
      "severity": "medium",
      "userImpact": "Users cannot add custom interceptors to ScheduleClient for request interception, limiting ability to customize behavior and add cross-cutting concerns like logging or monitoring.",
      "rootCause": null,
      "proposedFix": "Add API to ScheduleClientOptions to register ScheduleClientCallsInterceptor instances, following WorkflowClient's interceptor pattern.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "ScheduleClientOptions was updated to support adding interceptors through an API consistent with WorkflowClient.",
      "related": [],
      "keyQuote": "There should be an API on ScheduleClientOptions to add ScheduleClientCallsInterceptor instances to the ScheduleClient.",
      "number": 2048,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:34.285Z"
    },
    {
      "summary": "Add toString, equals, and hashCode methods to WorkflowServiceStubsOptions and related *Options classes for better logging and debugging support.",
      "category": "feature",
      "subcategory": "options-classes",
      "apis": [],
      "components": [
        "WorkflowServiceStubsOptions",
        "OperatorServiceStubsOptions",
        "Builder"
      ],
      "concepts": [
        "logging",
        "debugging",
        "options-configuration",
        "serialization",
        "builder-pattern"
      ],
      "severity": "low",
      "userImpact": "Users can now log and debug service stub options more effectively with proper string representations and object comparison.",
      "rootCause": null,
      "proposedFix": "Implement toString, equals, and hashCode methods in WorkflowServiceStubsOptions, OperatorServiceStubsOptions, and their Builder sub-classes following the pattern used in other *Options classes in the Java SDK.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "toString, equals, and hashCode methods were implemented for the options classes to enable better logging and debugging.",
      "related": [],
      "keyQuote": "We should also include `equals` and `hashcode` like all other `*Options` in the Java SDK.",
      "number": 2047,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:22.939Z"
    },
    {
      "summary": "Promise.allOf() ignores failures in promises that have already failed before being passed to allOf(), causing workflows to complete successfully when they should fail. The issue is in AllOfPromise#addPromise which only handles non-completed promises.",
      "category": "bug",
      "subcategory": "promise-handling",
      "apis": [
        "Promise.allOf",
        "Async.procedure"
      ],
      "components": [
        "AllOfPromise",
        "promise-coordination",
        "workflow-execution"
      ],
      "concepts": [
        "promise-composition",
        "error-handling",
        "async-coordination",
        "state-management",
        "failure-propagation"
      ],
      "severity": "high",
      "userImpact": "Workflows fail silently when combining already-failed promises with allOf(), leading to incorrect workflow completion and potential data consistency issues.",
      "rootCause": "AllOfPromise#addPromise only registers callbacks for non-completed promises, ignoring the completion state (success or failure) of already-completed promises.",
      "proposedFix": "Check if each promise has completed exceptionally in AllOfPromise#addPromise and propagate the failure immediately.",
      "workaround": "Implement a wrapper function that checks all promises for prior failures before calling Promise.allOf().",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If one Promise in promises is already failed before calling allOf, the failure is ignored.",
      "number": 2046,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:20.737Z"
    },
    {
      "summary": "Users need better awareness that startUpdate is synchronous with the worker and requires explicit opt-in. This is a documentation and API usability enhancement to make the behavior more discoverable and intentional.",
      "category": "feature",
      "subcategory": "workflow-updates",
      "apis": [
        "startUpdate",
        "startWorkflow"
      ],
      "components": [
        "workflow-stub",
        "client-api",
        "documentation"
      ],
      "concepts": [
        "synchronous-behavior",
        "worker-acceptance",
        "api-clarity",
        "opt-in-behavior",
        "user-awareness"
      ],
      "severity": "medium",
      "userImpact": "Developers may unknowingly rely on synchronous behavior of startUpdate without understanding its worker synchronization requirements.",
      "rootCause": null,
      "proposedFix": "Make startUpdate behavior explicit through documentation and API design, ensuring developers understand and opt into the synchronous-with-worker behavior similar to startWorkflow.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed through documentation updates and API improvements to clarify startUpdate synchronous behavior with worker acceptance.",
      "related": [
        469
      ],
      "keyQuote": "Developers should be informed about and opt in to behavior that startWorkflow waits for acceptance",
      "number": 2045,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:21.733Z"
    },
    {
      "summary": "Add validation to fail workflow tasks when illegal state-mutating calls (like activities) are made within Workflow.await(), which is expected to be idempotent. This will help catch bugs in workflow implementations that violate the idempotency requirement.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "Workflow.await",
        "ExecuteActivity"
      ],
      "components": [
        "workflow-executor",
        "await-handler",
        "activity-executor"
      ],
      "concepts": [
        "idempotency",
        "state-mutation",
        "workflow-task-failure",
        "illegal-calls",
        "bug-detection"
      ],
      "severity": "medium",
      "userImpact": "Users will get explicit workflow task failures when they accidentally make illegal state-mutating calls in Workflow.await(), making bugs easier to detect and fix.",
      "rootCause": "Workflow.await() does not validate that no state-mutating operations are performed within its predicate, allowing buggy code to slip through.",
      "proposedFix": "Detect any calls to mutate workflow state (like starting activities) within Workflow.await() and fail the workflow task with an appropriate error.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation added validation to detect illegal calls within Workflow.await() and fail the workflow task accordingly.",
      "related": [],
      "keyQuote": "Workflow.await is expected to be idempotent, so it is not allowed to make any calls to mutate workflow state like start an activity.",
      "number": 2044,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:07.147Z"
    },
    {
      "summary": "Activity options merging logic is incorrect across six different option sources. The current implementation fails to properly merge options in the documented precedence order, causing unexpected behavior when multiple option sources are specified.",
      "category": "bug",
      "subcategory": "activity-options",
      "apis": [
        "newActivityStub",
        "setDefaultActivityOptions",
        "applyActivityOptions"
      ],
      "components": [
        "WorkflowInternal",
        "ActivityInvocationHandler",
        "WorkflowImplementationOptions"
      ],
      "concepts": [
        "option-merging",
        "precedence",
        "configuration",
        "activity-execution",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users get unexpected activity behavior when combining multiple option sources due to incorrect merging logic that doesn't follow documented precedence rules.",
      "rootCause": "The merging logic is split between WorkflowInternal and ActivityInvocationHandler, and doesn't properly handle all six option sources in the correct precedence order. Default and per-activity-type options are being merged when they should replace each other based on specificity.",
      "proposedFix": "Consolidate the merging logic to properly process all six sources in documented order: WorkflowImplementationOptions defaults, WorkflowImplementationOptions map, Workflow.setDefaultActivityOptions, Workflow.applyActivityOptions map, newActivityStub options argument, and activityMethodOptions map.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The precedence outlined above is the only one that makes sense to me... defaults should not be used if a more specific option for an activity type is specified.",
      "number": 2042,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:08.864Z"
    },
    {
      "summary": "StickyWorkflowDrainShutdownTest.testShutdown is flaky in CI due to a suspected race condition in worker shutdown when no activities are registered.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "worker",
        "shutdown",
        "activity-registry"
      ],
      "concepts": [
        "race-condition",
        "shutdown",
        "worker-drain",
        "test-flakiness",
        "sticky-workflow"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests create unreliable CI/CD pipelines and reduce confidence in code quality checks.",
      "rootCause": "Race condition in worker shutdown when no activities are registered",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        2021
      ],
      "keyQuote": "Looking at it I think there is a race condition in worker shutdown if no activities are registered.",
      "number": 2038,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:56:03.130Z"
    },
    {
      "summary": "Request to expose a defaultConnection() method that switches between localhost and cloud-based connections based on environment variables, enabling samples to easily run against either local or cloud deployments.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [
        "defaultConnection"
      ],
      "components": [
        "client",
        "connection",
        "configuration"
      ],
      "concepts": [
        "connection-pooling",
        "environment-configuration",
        "localhost-vs-cloud",
        "sample-execution",
        "deployment-flexibility"
      ],
      "severity": "low",
      "userImpact": "Developers using sample code can easily switch between running workflows locally or on Temporal Cloud without modifying code.",
      "rootCause": null,
      "proposedFix": "Expose a defaultConnection() method that reads an environment variable to select between localhost and cloud connection configurations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Method was implemented to allow easy switching between localhost and cloud connections via environment variables.",
      "related": [
        454
      ],
      "keyQuote": "Expose a defaultConnection() method or similar that switches between localhost (default) and cloud based on some environment variable",
      "number": 2035,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:52.911Z"
    },
    {
      "summary": "Request to populate activity execution context in TestActivityEnvironment for unit tests without requiring a workflow setup. Currently, developers must create a temporary workflow using TestWorkflowEnvironment to access context information like workflow type.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "Activity.getExecutionContext",
        "TestActivityEnvironment",
        "TestWorkflowEnvironment"
      ],
      "components": [
        "activity-testing",
        "test-environment",
        "execution-context"
      ],
      "concepts": [
        "unit-testing",
        "test-setup",
        "activity-context",
        "test-isolation",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Developers must create tedious temporary workflows to test activities that access execution context, increasing test complexity and setup time.",
      "rootCause": null,
      "proposedFix": "Add an option to TestActivityEnvironment to populate execution context via TestEnvironmentOptions, such as `TestActivityEnvironment.newInstance(TestEnvironmentOptions.newBuilder().setActivityExecutionContext(...).build())`",
      "workaround": "Setting up a test environment workflow with a sample workflow to access execution context",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Ideally, I should be able to setup execution context for tests without any interactions with workflows.",
      "number": 2034,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:51.504Z"
    },
    {
      "summary": "Support for WorkflowIdConflictPolicy in the Java SDK to align with feature support across Temporal SDKs, as defined in the cross-repository features issue #437.",
      "category": "feature",
      "subcategory": "workflow-configuration",
      "apis": [
        "StartWorkflowOptions",
        "WorkflowOptions"
      ],
      "components": [
        "workflow-client",
        "workflow-options",
        "client-api"
      ],
      "concepts": [
        "workflow-id",
        "conflict-policy",
        "workflow-creation",
        "idempotency",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Java SDK users cannot configure how workflow ID conflicts are handled when starting workflows, limiting control over workflow creation behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support WorkflowIdConflictPolicy configuration in the Java SDK",
      "related": [
        437
      ],
      "keyQuote": "Support for WorkflowIdConflictPolicy",
      "number": 2033,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:51.183Z"
    },
    {
      "summary": "Add SpringBoot integration configuration options to enable developers to configure slot suppliers in their Spring Boot applications, extending the slot supplier functionality introduced in PR #2014.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "slot-supplier",
        "configuration"
      ],
      "concepts": [
        "spring-boot-integration",
        "dependency-injection",
        "configuration-management",
        "resource-pooling"
      ],
      "severity": "low",
      "userImpact": "Spring Boot developers will be able to configure slot suppliers through standard Spring Boot configuration options rather than manual setup.",
      "rootCause": null,
      "proposedFix": "Add SpringBoot config options to configure slot suppliers",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2014
      ],
      "keyQuote": "Add sprintboot config options to configure slot suppliers as introduced in https://github.com/temporalio/sdk-java/pull/2014",
      "number": 2031,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:34.317Z"
    },
    {
      "summary": "Add a new `PauseableSlotSupplier` implementation that wraps other slot suppliers and provides a pause() function for worker tuning as part of the autotuning proposal.",
      "category": "feature",
      "subcategory": "worker-tuning",
      "apis": [
        "SlotSupplier"
      ],
      "components": [
        "worker",
        "slot-supplier",
        "autotuning"
      ],
      "concepts": [
        "worker-tuning",
        "slot-management",
        "pause-mechanism",
        "resource-throttling",
        "worker-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to pause activity execution through a slot supplier wrapper, enabling dynamic worker capacity management.",
      "rootCause": null,
      "proposedFix": "Implement `PauseableSlotSupplier` wrapping another `SlotSupplier` with pause() functionality per the autotuning proposal specification.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add an implementation of `SlotSupplier` that wraps another implementation adding a `pause()` function.",
      "number": 2030,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:38.489Z"
    },
    {
      "summary": "Feature request to add a configurable graceful shutdown wait time property for the Spring Boot worker factory, preventing application closure before inflight tasks complete.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkerFactory"
      ],
      "components": [
        "spring-boot",
        "worker-factory",
        "lifecycle-management",
        "shutdown-handler"
      ],
      "concepts": [
        "graceful-shutdown",
        "inflight-tasks",
        "shutdown-timeout",
        "spring-boot-integration",
        "resource-cleanup",
        "lifecycle-hooks"
      ],
      "severity": "medium",
      "userImpact": "Users' Spring Boot applications may close before completing in-flight worker tasks, potentially losing work or causing data inconsistency.",
      "rootCause": "Worker factory shutdown triggered by Spring Boot close event lacks a configurable wait period for task completion.",
      "proposedFix": "Add a configurable property to control how long the worker factory waits during shutdown before continuing.",
      "workaround": "Users can manually add a hook to the context close event and manually shutdown the factory with explicit wait.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This can cause the application to close before all inflight tasks are finished.",
      "number": 2026,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:36.754Z"
    },
    {
      "summary": "ReplayWorkflowTaskHandler.failureToWFTResult does not use SerializationContext when serializing exceptions for direct queries, potentially causing serialization issues with custom exception handling.",
      "category": "bug",
      "subcategory": "query-handling",
      "apis": [],
      "components": [
        "ReplayWorkflowTaskHandler",
        "serialization",
        "direct-query"
      ],
      "concepts": [
        "serialization",
        "exception-handling",
        "context",
        "query-processing"
      ],
      "severity": "medium",
      "userImpact": "Users with custom exception serialization configurations may experience incorrect exception serialization in direct query responses.",
      "rootCause": "The failureToWFTResult method is missing SerializationContext when serializing exceptions for direct queries, inconsistent with other serialization operations.",
      "proposedFix": "Add SerializationContext parameter to the exception serialization call in ReplayWorkflowTaskHandler.failureToWFTResult.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the missing SerializationContext was added to the failureToWFTResult method.",
      "related": [],
      "keyQuote": "ReplayWorkflowTaskHandler.failureToWFTResult does not use a SeralizationContext when serializing an exception for a direct query",
      "number": 2020,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:24.079Z"
    },
    {
      "summary": "Kotlin ActivityStubExt.execute extension functions incorrectly wrap arguments in a list instead of passing them as varargs to the underlying ActivityStub.execute method, causing arguments to be double-wrapped in the ActivityTaskScheduled event.",
      "category": "bug",
      "subcategory": "kotlin-extensions",
      "apis": [
        "ActivityStub.execute",
        "Workflow.newUntypedActivityStub"
      ],
      "components": [
        "kotlin-extensions",
        "activity-stub",
        "varargs-handling"
      ],
      "concepts": [
        "varargs",
        "spread-operator",
        "argument-passing",
        "kotlin-interop",
        "serialization"
      ],
      "severity": "medium",
      "userImpact": "Users of Kotlin extension functions receive incorrectly wrapped arguments in activity execution, breaking expected behavior and payload structure.",
      "rootCause": "Missing spread operator (*) when calling ActivityStub.execute with varargs in ActivityStubExt.kt",
      "proposedFix": "Use the spread operator (*) when passing varargs to ActivityStub.execute in ActivityStubExt.kt line 36",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by adding spread operator in PR #2395",
      "related": [
        2395
      ],
      "keyQuote": "the call to `ActivityStub.execute` with varargs in ActivityStubExt.kt needs to use the spread operator (`*`)",
      "number": 2018,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:21.219Z"
    },
    {
      "summary": "Request to use macOS M1/ARM runners for all Java SDK CI pipelines instead of Intel-based runners. This is related to broader Temporal effort to support ARM architecture across SDKs.",
      "category": "feature",
      "subcategory": "ci-infrastructure",
      "apis": [],
      "components": [
        "ci",
        "build-system",
        "testing"
      ],
      "concepts": [
        "arm-architecture",
        "performance",
        "ci-optimization",
        "macos-support",
        "infrastructure"
      ],
      "severity": "medium",
      "userImpact": "Enables faster CI builds and better testing on ARM architecture, improving development velocity for maintainers and ensuring compatibility with M1/M2 Macs.",
      "rootCause": null,
      "proposedFix": "Migrate Java SDK CI runners to use macOS M1/ARM runners across all CI workflows.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        396
      ],
      "keyQuote": "Use macOS M1/ARM runners for all SDK CI",
      "number": 2017,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:21.863Z"
    },
    {
      "summary": "The isReplaying() method incorrectly returns false during workflow replay when a query is executed after a workflow task that doesn't generate commands. This occurs because the replay state is prematurely set to false based on a flawed check in the WorkflowStateMachines class.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "isReplaying"
      ],
      "components": [
        "workflow-state-machines",
        "replay-engine",
        "query-handler"
      ],
      "concepts": [
        "replay",
        "query",
        "workflow-task",
        "state-management",
        "event-processing"
      ],
      "severity": "high",
      "userImpact": "Users get incorrect isReplaying() values when querying workflows during replay, potentially breaking query logic that depends on accurate replay state.",
      "rootCause": "The replay flag is incorrectly set to false when processing a query after a workflow task that didn't generate a command, due to insufficient conditions in the replay state check at WorkflowStateMachines.java:427.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The flawed replay state check was corrected to properly handle queries after workflow tasks without command generation.",
      "related": [],
      "keyQuote": "This check is flawed since if we receive a query after a workflow task that didn't generate a command will cause the Java SDK to incorrectly assume the workflow is no longer replaying.",
      "number": 2016,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:06.063Z"
    },
    {
      "summary": "Request to upgrade the Protobuf plugin to v26.0 with breaking changes. Upgrade is blocked by compatibility issues between Proto 4 and grpc-java, requiring investigation of gRPC recommendations before proceeding.",
      "category": "other",
      "subcategory": "build-dependencies",
      "apis": [],
      "components": [
        "protobuf-plugin",
        "grpc-java",
        "build-system"
      ],
      "concepts": [
        "dependency-upgrade",
        "breaking-changes",
        "compatibility",
        "plugin-version",
        "proto-compiler"
      ],
      "severity": "medium",
      "userImpact": "Users cannot benefit from Protobuf v26.0 improvements and security fixes until the SDK upgrades its plugin and resolves gRPC compatibility issues.",
      "rootCause": "Proto 4 has compatibility issues with grpc-java that need to be resolved before upgrading; gRPC team is working on recommendations.",
      "proposedFix": "Follow gRPC recommendations for Proto 4 compatibility: make SDK compatible with both Proto 3.x and 4.x, replace GeneratedMessage/GeneratedMessageV3 with Message, and use protoc 25.x for generated code.",
      "workaround": "Use Proto 3.x until Proto 4 compatibility is resolved in grpc-java.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by following gRPC's compatibility recommendations and completing the Protobuf upgrade.",
      "related": [
        1752,
        11015
      ],
      "keyQuote": "Proto 4 has some issues with grpc-java. We're waiting for grpc/grpc-java#11015 to resolve and plan to follow their recommendations.",
      "number": 2006,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:08.993Z"
    },
    {
      "summary": "Feature request to prevent the SDK from returning an update handle if the update hasn't reached the desired state. This ensures clients don't receive incomplete or invalid update results.",
      "category": "feature",
      "subcategory": "update-handle",
      "apis": [
        "update"
      ],
      "components": [
        "update-handler",
        "client-api",
        "state-management"
      ],
      "concepts": [
        "state-validation",
        "handle-lifecycle",
        "desired-state",
        "update-completion"
      ],
      "severity": "medium",
      "userImpact": "Users may receive invalid update handles in certain conditions, leading to incorrect state management in their workflows.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed and the SDK now properly validates update state before returning handles.",
      "related": [
        432
      ],
      "keyQuote": "SDK should not return an update handle if the update has not reached the desired state",
      "number": 2002,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:55:09.393Z"
    },
    {
      "summary": "GrpcRetryer fails to retry requests when the initial serviceCapabilities.get() call fails, instead failing immediately without applying retry policies. This breaks reliability for scenarios where the Temporal server is temporarily unavailable or unhealthy.",
      "category": "bug",
      "subcategory": "grpc-retry-policy",
      "apis": [
        "WorkflowServiceStubs",
        "WorkflowClient"
      ],
      "components": [
        "GrpcRetryer",
        "WorkflowServiceStubs",
        "RpcRetryOptions",
        "gRPC connection"
      ],
      "concepts": [
        "retry-policy",
        "connection-health",
        "fault-tolerance",
        "service-availability",
        "gRPC error-handling"
      ],
      "severity": "high",
      "userImpact": "CLI applications and clients connecting to temporarily unavailable Temporal servers fail immediately instead of retrying, breaking reliability expectations for intermittent network issues.",
      "rootCause": "The serviceCapabilities.get() call failure during initial connection is not wrapped in the retry logic, causing the entire request to fail before retries can be applied.",
      "proposedFix": null,
      "workaround": "Use eager connection with appropriate timeout configuration to differentiate between connection failures and RPC failures.",
      "resolution": "fixed",
      "resolutionDetails": "The serviceCapabilities call is now retried as part of the standard retry mechanism.",
      "related": [],
      "keyQuote": "If serviceCapabilities.get() fails (not initialized yet + network issue or whatever) actual request under retry is not getting retried according to retry policies",
      "number": 1999,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:54.816Z"
    },
    {
      "summary": "Request to add a dedicated `setApiKey` method as syntactic sugar for setting API credentials in the Java SDK, potentially as a foundation for future `setCloudApiKey` functionality that could default the target.",
      "category": "feature",
      "subcategory": "authentication",
      "apis": [
        "WorkflowServiceStubsOptions"
      ],
      "components": [
        "client",
        "grpc-metadata",
        "authentication"
      ],
      "concepts": [
        "api-key",
        "authentication",
        "credentials",
        "grpc-metadata",
        "client-options"
      ],
      "severity": "low",
      "userImpact": "Developers would have a more intuitive and explicit way to configure API key authentication instead of using lower-level metadata providers.",
      "rootCause": null,
      "proposedFix": "Add a `setApiKey` method to WorkflowServiceStubsOptions as convenience syntax for AuthorizationGrpcMetadataProvider configuration.",
      "workaround": "Use `AuthorizationGrpcMetadataProvider` with `addGrpcMetadataProvider` to attach API key as Bearer token in metadata.",
      "resolution": "fixed",
      "resolutionDetails": "Likely implemented through the AuthorizationGrpcMetadataProvider approach, though specific resolution details not provided in comments.",
      "related": [
        426
      ],
      "keyQuote": "I was hoping to have a literal `setApiKey` even if it's sugar, but can be convinced otherwise if we don't think it's needed here.",
      "number": 1997,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:52.128Z"
    },
    {
      "summary": "Feature request to add a \"server-name\" property to Spring Boot connection options, allowing users to override the server authority via ManagedChannelBuilder for scenarios like PrivateLink connectivity. Currently possible through TemporalOptionsCustomizer but adding a dedicated option would improve convenience.",
      "category": "feature",
      "subcategory": "connection-options",
      "apis": [],
      "components": [
        "spring-boot",
        "connection-options",
        "managed-channel",
        "tls"
      ],
      "concepts": [
        "server-name",
        "tls",
        "privatelink",
        "authority-override",
        "connection-configuration"
      ],
      "severity": "low",
      "userImpact": "Users can more conveniently configure server-name for private network connectivity scenarios without needing to use TemporalOptionsCustomizer.",
      "rootCause": null,
      "proposedFix": "Add \"server-name\" property to connection options that uses ManagedChannelBuilder#overrideAuthority to set the server name directly.",
      "workaround": "Use TemporalOptionsCustomizer to configure this manually.",
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and merged into the Spring Boot SDK.",
      "related": [],
      "keyQuote": "This can be useful for users going through PrivateLink or similar. This would use ManagedChannelBuilder#overrideAuthority to set the server name directly rather than getting it from target.",
      "number": 1996,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:50.508Z"
    },
    {
      "summary": "Feature request to include RunID in HasWorkflowSerializationContext to help PayloadCodec implementations disambiguate execution runs that have been ContinuedAsNew or Reset. After investigation, the request was closed as the SDK cannot reliably provide the correct RunID in all scenarios.",
      "category": "feature",
      "subcategory": "serialization-context",
      "apis": [
        "HasWorkflowSerializationContext",
        "PayloadCodec"
      ],
      "components": [
        "serialization-context",
        "payload-codec",
        "workflow-context"
      ],
      "concepts": [
        "run-identification",
        "payload-caching",
        "continued-as-new",
        "workflow-lifecycle",
        "serialization-metadata"
      ],
      "severity": "medium",
      "userImpact": "Users implementing custom PayloadCodecs with caching strategies cannot reliably disambiguate which workflow run a payload belongs to when executions use ContinuedAsNew or Reset.",
      "rootCause": "The SDK does not always have visibility into the new workflow execution's RunID in scenarios involving reset, continue-as-new, or child workflows, since RunIDs are generated server-side.",
      "proposedFix": "Extend HasWorkflowSerializationContext implementations to include RunID where available (all cases except ClientInterceptor), allowing it to be null when unavailable.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed by author as not a tenable solution. The fundamental issue is that the SDK cannot consistently provide the correct RunID in all execution scenarios (reset, continue-as-new, child workflows), making it unsuitable for serialization context which requires consistent information.",
      "related": [
        3709
      ],
      "keyQuote": "SerializationContext is meant to provide information needed to serialize a payload, if that information cannot be consistently provided then it can't be used to serialize the payload",
      "number": 1994,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:36.529Z"
    },
    {
      "summary": "Guava dependency vulnerability (CVE-2023-2976) with CVSS 7.1 severity in FileBackedOutputStream allows unauthorized file access on Unix systems through Java's default temporary directory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "grpc-client",
        "build-system"
      ],
      "concepts": [
        "security-vulnerability",
        "temporary-files",
        "privilege-escalation",
        "dependency-upgrade"
      ],
      "severity": "high",
      "userImpact": "Users running the SDK on Unix systems are exposed to local privilege escalation attacks through temporary file access vulnerabilities in transitive Guava dependencies.",
      "rootCause": "Guava 31.1-jre uses Java's default temporary directory for FileBackedOutputStream without proper access controls, allowing other local users to access created files.",
      "proposedFix": "Upgrade grpc-api to 1.57.0 or later, which includes Guava 32.0.1-android with the security fix (or 32.0.0 minimum).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by upgrading grpc-api dependency to version 1.57.0, which includes the patched Guava 32.0.1-android.",
      "related": [],
      "keyQuote": "Use of Java's default temporary directory for file creation in FileBackedOutputStream in Google Guava versions 1.0 to 31.1 on Unix systems and Android Ice Cream Sandwich allows other users and apps on the machine with access to the default Java temporary directory to be able to access the files created by the class.",
      "number": 1990,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:34.682Z"
    },
    {
      "summary": "Request for built-in API to override ActivityOptions in test workflows. Currently, production code uses high retry counts on activities, but tests need low retry counts (maxAttempts=1) and custom queue names without hardcoding production configurations.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ActivityOptions",
        "WorkflowImplementationOptions",
        "TestWorkflowEnvironment",
        "Workflow.newActivityStub"
      ],
      "components": [
        "testing",
        "activity-executor",
        "workflow-implementation",
        "options-builder"
      ],
      "concepts": [
        "test-override",
        "retry-policy",
        "activity-configuration",
        "task-queue",
        "mock-stubbing",
        "test-setup"
      ],
      "severity": "medium",
      "userImpact": "Users must use workarounds like global state or code flags to override activity options in tests, making test setup more complex and error-prone.",
      "rootCause": null,
      "proposedFix": "Add methods like `overrideAllActivityOptions()` and `overrideActivityOptions(Map<Class, ActivityOptions>)` to WorkflowImplementationOptions or TestWorkflowEnvironment to allow declarative override of activity options during test execution.",
      "workaround": "Use GlobalWorkflowOptions to store override values at test setup time, and check for overrides in workflow implementation code before creating activity stubs.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        499,
        626
      ],
      "keyQuote": "In production code I have high retry count on activities, but in testing I want to override that to have maxAttempts=1 so that workflow gets it's failure right away.",
      "number": 1988,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:38.140Z"
    },
    {
      "summary": "Request to allow configurable workflow exception types at the worker level, potentially allowing workers to handle exception serialization and behavior differently based on configuration.",
      "category": "feature",
      "subcategory": "exception-handling",
      "apis": [],
      "components": [
        "worker",
        "exception-handling"
      ],
      "concepts": [
        "exception-types",
        "worker-configuration",
        "workflow-exceptions",
        "error-handling",
        "configurability"
      ],
      "severity": "medium",
      "userImpact": "Users would be able to customize how workflow exceptions are handled and serialized at the worker configuration level.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        322
      ],
      "keyQuote": "Configurable workflow exception types at the worker level",
      "number": 1987,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:19.758Z"
    },
    {
      "summary": "gRPC dependency versions have breaking changes in v1.59.0+ that move InProcessServerBuilder to a separate artifact. The Java SDK needs to upgrade to support Quarkus and other frameworks using recent gRPC versions.",
      "category": "other",
      "subcategory": "dependencies",
      "apis": [],
      "components": [
        "grpc-core",
        "grpc-inprocess",
        "dependencies"
      ],
      "concepts": [
        "dependency-management",
        "version-compatibility",
        "breaking-changes",
        "grpc-migration",
        "class-relocation"
      ],
      "severity": "high",
      "userImpact": "Users using Quarkus or other frameworks with recent gRPC versions face ClassNotFound errors unless they manually add grpc-inprocess and grpc-services dependencies.",
      "rootCause": "gRPC v1.59.0 moved InProcessServerBuilder from grpc-core to grpc-inprocess artifact, breaking binary compatibility for downstream projects not recompiled with the new version.",
      "proposedFix": "Upgrade gRPC dependencies to version > 1.59.0 and add grpc-inprocess as a dependency in the SDK.",
      "workaround": "Manually add io.grpc:grpc-inprocess and io.grpc:grpc-services dependencies, or pin to older gRPC version < 1.59.0.",
      "resolution": "fixed",
      "resolutionDetails": "Users confirmed the workaround works by explicitly including grpc-inprocess and grpc-services dependencies.",
      "related": [],
      "keyQuote": "Class io.grpc.internal.AbstractServerImplBuilder is deleted, and no longer in the class hierarchy of the server builders",
      "number": 1985,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:19.321Z"
    },
    {
      "summary": "Spring Boot Starter lacks ability to customize workflow options by workflow type. Unlike the Java SDK which supports type-specific options via `registerWorkflowImplementationTypes()`, the Spring Boot Starter only allows global customization, preventing workflows like scheduled ones from having different failure handling (e.g., failing on NonDeterministicException) than others.",
      "category": "feature",
      "subcategory": "spring-boot-starter",
      "apis": [
        "registerWorkflowImplementationTypes",
        "WorkflowImplementationOptions.Builder"
      ],
      "components": [
        "spring-boot-starter",
        "workflow-registration",
        "workflow-options"
      ],
      "concepts": [
        "customization",
        "workflow-types",
        "implementation-options",
        "non-deterministic-exception",
        "configuration",
        "type-specific-behavior"
      ],
      "severity": "medium",
      "userImpact": "Users cannot apply different workflow options to different workflow types in Spring Boot applications, forcing them to either use identical configurations across all workflows or avoid using the Spring Boot Starter.",
      "rootCause": "The Spring Boot Starter's `TemporalOptionsCustomizer` and `WorkflowImplementationOptions.Builder` do not support workflow-type-specific customization, a feature available in the core Java SDK.",
      "proposedFix": "Add capability to customize workflow implementation options by workflow type when using the Spring Boot Starter, similar to the Java SDK's `registerWorkflowImplementationTypes(WorkflowImplementationOptions options, Class<?>... workflowImplementationClasses)` method.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add the capability to customize workflow options by workflow type when using the spring boot starter, as we might not want to apply these options to all workflow types.",
      "number": 1984,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:22.027Z"
    },
    {
      "summary": "Expose the ability for activities to specify the next retry delay on failure via the ApplicationFailureInfo field, making this feature available across all SDKs. This field was recently added to the API proto definition but needs SDK-level exposure.",
      "category": "feature",
      "subcategory": "activity-retry",
      "apis": [
        "ApplicationFailureInfo"
      ],
      "components": [
        "activity-executor",
        "failure-handling",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "failure-handling",
        "activity-execution",
        "delay",
        "backoff",
        "API-exposure"
      ],
      "severity": "medium",
      "userImpact": "Activities can now provide custom retry delay strategies on failure, giving developers more fine-grained control over retry behavior.",
      "rootCause": null,
      "proposedFix": "Expose the nextRetryDelay field from ApplicationFailureInfo proto in the Java SDK API surface",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to expose the ApplicationFailureInfo nextRetryDelay field in the SDK",
      "related": [],
      "keyQuote": "We recently added the ability for an activity to specify the next retry delay on failure via a field on `ApplicationFailureInfo`.",
      "number": 1983,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:05.532Z"
    },
    {
      "summary": "DynamicWorkflow implementation needs to apply serialization context similar to issue #1895 to properly handle data conversion. A fix is proposed that wraps the dataConverter with WorkflowSerializationContext.",
      "category": "bug",
      "subcategory": "dynamic-workflow",
      "apis": [
        "DynamicWorkflow"
      ],
      "components": [
        "dynamic-workflow",
        "serialization",
        "POJOWorkflowImplementationFactory",
        "data-converter"
      ],
      "concepts": [
        "serialization",
        "dynamic-workflow",
        "data-conversion",
        "workflow-context",
        "implementation-factory"
      ],
      "severity": "medium",
      "userImpact": "Customers using DynamicWorkflow may experience serialization issues when data conversion doesn't properly apply workflow context.",
      "rootCause": "DynamicWorkflow implementation in POJOWorkflowImplementationFactory is not applying WorkflowSerializationContext to the dataConverter, similar to the issue reported in #1895.",
      "proposedFix": "Wrap dataConverter with WorkflowSerializationContext in the DynamicSyncWorkflowDefinition constructor call, passing namespace and workflow ID from execution context.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by applying the proposed fix to add WorkflowSerializationContext to DynamicWorkflow serialization handling.",
      "related": [
        1895
      ],
      "keyQuote": "replacing... for return new DynamicSyncWorkflowDefinition(dynamicWorkflowImplementationFactory, workerInterceptors, dataConverter.withContext(new WorkflowSerializationContext(namespace, execution.getWorkflowId()));",
      "number": 1982,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:05.587Z"
    },
    {
      "summary": "Shaded JAR library lacks source code attachment, preventing IDE access to JavaDoc and source code during development. Users must resort to online documentation as a workaround.",
      "category": "other",
      "subcategory": "build-artifacts",
      "apis": [],
      "components": [
        "build-system",
        "maven-plugin",
        "shaded-jar"
      ],
      "concepts": [
        "source-availability",
        "ide-integration",
        "javadoc",
        "developer-experience",
        "artifact-packaging"
      ],
      "severity": "medium",
      "userImpact": "Developers lose local IDE source code and JavaDoc access when using the shaded JAR, requiring them to browse online documentation instead of leveraging IDE features.",
      "rootCause": null,
      "proposedFix": "Publish the shaded JAR with source code attached (source JAR alongside main JAR)",
      "workaround": "Use browser/online Java documentation",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "No source code available to read in IDE for java docs",
      "number": 1981,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:54:06.854Z"
    },
    {
      "summary": "MDC (Mapped Diagnostic Context) is not propagating to Temporal worker threads when using the Spring Boot SDK. User configured MdcContextPropagator on the workflow client but logs from Temporal activities lack the MDC context.",
      "category": "bug",
      "subcategory": "context-propagation",
      "apis": [
        "WorkflowClient",
        "WorkflowClientOptions",
        "MdcContextPropagator"
      ],
      "components": [
        "spring-boot-starter",
        "worker",
        "context-propagator"
      ],
      "concepts": [
        "MDC",
        "logging",
        "context-propagation",
        "thread-locals",
        "spring-boot-integration",
        "worker-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot track requests through logs across workflow and activity boundaries, making debugging and monitoring distributed workflows difficult.",
      "rootCause": "Context propagator was only configured on the workflow client but not on the worker client, preventing MDC context from propagating to activity threads.",
      "proposedFix": "Configure the MdcContextPropagator on both the workflow client and the worker client. Reference TemporalOptionsConfig.java from the Spring Boot sample for the correct setup pattern.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "User was missing context propagator configuration on the worker client. Solution confirmed in comments with reference to sample code configuration.",
      "related": [],
      "keyQuote": "You need to also be setting the the context propagator on the client the worker uses.",
      "number": 1980,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:52.759Z"
    },
    {
      "summary": "Request to disable eager activities when task queue rate limits are configured, to prevent potential performance issues with rate-limited task queues.",
      "category": "feature",
      "subcategory": "activities",
      "apis": [],
      "components": [
        "activity-executor",
        "task-queue",
        "worker"
      ],
      "concepts": [
        "eager-activities",
        "rate-limiting",
        "performance",
        "task-queue",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users with rate-limited task queues may experience unexpected behavior or performance degradation when eager activities are enabled.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing the feature to disable eager activities when task queue rate limits are set.",
      "related": [
        405
      ],
      "keyQuote": "Disable eager activities if task queue rate limits is set",
      "number": 1978,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:48.227Z"
    },
    {
      "summary": "WorkflowUpdateException is incorrectly wrapped in ExecutionException during sync update calls when the update request exceeds the server's long poll deadline and the SDK switches to long polling. This unexpected wrapping is confusing to users who didn't await any future.",
      "category": "bug",
      "subcategory": "workflow-update",
      "apis": [
        "WorkflowUpdateException",
        "ExecutionException"
      ],
      "components": [
        "workflow-client",
        "update-handler",
        "long-polling"
      ],
      "concepts": [
        "exception-handling",
        "long-polling",
        "timeout",
        "sync-calls",
        "update-requests"
      ],
      "severity": "medium",
      "userImpact": "Users receive unexpected ExecutionException wrapping when workflow updates timeout and trigger long polling, making error handling inconsistent.",
      "rootCause": "When an update request exceeds the server's long poll deadline during a sync call, the SDK switches to long polling and incorrectly wraps WorkflowUpdateException in ExecutionException.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the incorrect exception wrapping was addressed.",
      "related": [],
      "keyQuote": "WorkflowUpdateException may be wrapped in a ExecutionException on a sync update call if the update request could not finish in the servers long poll deadline",
      "number": 1973,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:51.199Z"
    },
    {
      "summary": "Configuration parameter for starting workers is incorrectly named 'startWorkers' instead of using the correct configuration key naming convention.",
      "category": "bug",
      "subcategory": "configuration",
      "apis": [],
      "components": [
        "worker",
        "configuration"
      ],
      "concepts": [
        "config",
        "naming",
        "startup",
        "initialization"
      ],
      "severity": "low",
      "userImpact": "Users cannot properly configure worker startup due to incorrect configuration parameter naming.",
      "rootCause": "Configuration parameter was named 'startWorkers' instead of the correct convention.",
      "proposedFix": "Rename the configuration parameter to use the correct naming convention.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Configuration parameter name was corrected.",
      "related": [],
      "keyQuote": "Fix start-workers config. Currently its \"startWorkers\"",
      "number": 1971,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:38.303Z"
    },
    {
      "summary": "When signaling a closed workflow throws WorkflowNotFoundException, the Java SDK should include the WorkflowStatus to distinguish between workflows that don't exist versus workflows that are closed/completed. Currently developers must make a separate DescribeWorkflowExecution API call to determine the actual state.",
      "category": "feature",
      "subcategory": "workflow-signaling",
      "apis": [
        "SignalWorkflow",
        "DescribeWorkflowExecution"
      ],
      "components": [
        "client",
        "exception-handling",
        "workflow-execution"
      ],
      "concepts": [
        "workflow-status",
        "error-handling",
        "signal-workflow",
        "workflow-lifecycle",
        "api-enhancement"
      ],
      "severity": "medium",
      "userImpact": "Developers must make additional API calls to distinguish between non-existent and closed workflows when handling signal failures, increasing latency and code complexity.",
      "rootCause": "The server does not return WorkflowExecutionStatus in the error response when signaling a workflow that is not running.",
      "proposedFix": "Enhance the Temporal server to include WorkflowExecutionStatus in the error details returned when signaling a non-running workflow, and update the Java SDK to expose this information in WorkflowNotFoundException.",
      "workaround": "Call DescribeWorkflowExecution API separately to determine the workflow status after receiving WorkflowNotFoundException.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        5303
      ],
      "keyQuote": "As an application, we sometimes need to handle the two cases differently(error handling).",
      "number": 1969,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:37.629Z"
    },
    {
      "summary": "Workflow stub creation fails when the stub interface only defines an update method without a workflow method. This prevents using update-only workflows through the workflow client stub.",
      "category": "bug",
      "subcategory": "workflow-stub",
      "apis": [
        "newWorkflowStub"
      ],
      "components": [
        "workflow-stub",
        "workflow-client",
        "interface-binding"
      ],
      "concepts": [
        "workflow-interface",
        "update-method",
        "stub-creation",
        "interface-inheritance",
        "method-resolution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot create workflow stubs that only contain update methods, limiting workflow communication patterns.",
      "rootCause": "The stub creation logic likely requires a @WorkflowMethod to be present in the interface hierarchy, but doesn't properly handle cases where the stub interface only inherits update methods.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the stub creation logic to handle interfaces with only update methods.",
      "related": [],
      "keyQuote": "Cannot use a stub that only defines an update method",
      "number": 1966,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:38.093Z"
    },
    {
      "summary": "Activity heartbeats are retrying with the first heartbeat data instead of the last recorded heartbeat, causing retried activities to restart processing with outdated progress information rather than resuming from the last checkpoint.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [
        "Activity.getExecutionContext",
        "ActivityExecutionContext.getHeartbeatDetails",
        "ActivityExecutionContext.heartbeat"
      ],
      "components": [
        "activity-executor",
        "heartbeat-storage",
        "activity-retry"
      ],
      "concepts": [
        "checkpoint",
        "retry",
        "activity-resumption",
        "heartbeat-throttling",
        "state-recovery"
      ],
      "severity": "high",
      "userImpact": "Users performing long-running activities with checkpointing lose progress on retry because the activity resumes from the first heartbeat instead of the most recent one.",
      "rootCause": "The Java SDK is not properly propagating the last heartbeat details to the Cluster during retries; it appears to be using earlier heartbeat data instead of the most recent one.",
      "proposedFix": "The Java SDK should set the latest heartbeat details on the ActivityTask when retrying, as indicated in the Temporal API specification for workflowservice request_response.proto.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was identified as a Java SDK bug where heartbeat details were not being properly propagated during retries. The SDK needed to ensure the last heartbeat data was sent to the Cluster.",
      "related": [],
      "keyQuote": "If I throw an exception in the 4th iteration, then I would expect a retry that calls me with the remaining 1 elements however, I am called with remaining 4",
      "number": 1965,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:25.170Z"
    },
    {
      "summary": "Add automatic tracing span creation when schedules are created in the Java SDK's tracing interceptor. Users should be able to opt-out of this behavior via tracing interceptor options.",
      "category": "feature",
      "subcategory": "tracing-spans",
      "apis": [
        "Schedule"
      ],
      "components": [
        "tracing-interceptor",
        "schedule-client",
        "workflow-header"
      ],
      "concepts": [
        "tracing",
        "spans",
        "observability",
        "instrumentation",
        "interceptor",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Users relying on tracing will get automatic span creation for schedules, improving observability of scheduled workflow executions.",
      "rootCause": null,
      "proposedFix": "Implement automatic span creation in tracing interceptor when schedules are created, with workflow header propagation for workflow-starting actions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        394
      ],
      "keyQuote": "When the tracing interceptor is in use, by default creating a schedule should create a span for the schedule and set it on the workflow header",
      "number": 1963,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:20.736Z"
    },
    {
      "summary": "OpenTracing spans are not properly propagated when activities are chained using .thenCompose, resulting in orphaned spans disconnected from the parent workflow span.",
      "category": "bug",
      "subcategory": "tracing-context-propagation",
      "apis": [
        "executeAsync",
        "thenCompose"
      ],
      "components": [
        "tracing-interceptor",
        "promise-chain",
        "span-context"
      ],
      "concepts": [
        "context-propagation",
        "distributed-tracing",
        "promise-composition",
        "opentracing",
        "span-correlation"
      ],
      "severity": "medium",
      "userImpact": "Users with OpenTracing enabled cannot properly trace activity execution chains, making distributed tracing unreliable for workflows using .thenCompose.",
      "rootCause": "Tracing context is not properly propagated through promise chains when using .thenCompose for activity composition.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved, likely through a fix to context propagation in promise chains, as evidenced by author engagement and offer to submit PR.",
      "related": [],
      "keyQuote": "Some spans end up severed from the parent. This seems to be isolated to spans that are generated with a promise chain using .thenCompose.",
      "number": 1962,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:22.552Z"
    },
    {
      "summary": "json-path-2.8.0.jar contains a stack overflow vulnerability (CVE-2023-51074) via the Criteria.parse() method with CVSS score 5.3. The issue affects the temporal-spring-boot-starter-alpha module and was resolved by upgrading to json-path-2.9.0.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "temporal-spring-boot-starter-alpha",
        "dependency-management",
        "gradle-build"
      ],
      "concepts": [
        "security-vulnerability",
        "stack-overflow",
        "dependency-upgrade",
        "cvss-score",
        "json-parsing"
      ],
      "severity": "medium",
      "userImpact": "Applications using the Spring Boot starter with json-path-2.8.0 are vulnerable to denial-of-service attacks through stack overflow.",
      "rootCause": "Stack overflow vulnerability in json-path v2.8.0's Criteria.parse() method",
      "proposedFix": "Upgrade json-path from 2.8.0 to 2.9.0",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved in master branch by upgrading json-path dependency to version 2.9.0",
      "related": [],
      "keyQuote": "json-path v2.8.0 was discovered to contain a stack overflow via the Criteria.parse() method.",
      "number": 1960,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:06.898Z"
    },
    {
      "summary": "Retry policy is not propagated when using continue-as-new in Java SDK, and there's no way to explicitly set retry options in ContinueAsNewOptions. Other SDKs (Go, Python, TypeScript) propagate these attributes by default.",
      "category": "bug",
      "subcategory": "continue-as-new",
      "apis": [
        "ContinueAsNew",
        "ContinueAsNewOptions",
        "RetryPolicy"
      ],
      "components": [
        "workflow-execution",
        "continue-as-new",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "continue-as-new",
        "policy-propagation",
        "workflow-execution",
        "options",
        "cross-sdk-alignment"
      ],
      "severity": "medium",
      "userImpact": "Workflows that rely on retry policies lose this configuration when continued as new, requiring manual workarounds and inconsistent behavior across SDKs.",
      "rootCause": "ContinueAsNewOptions does not include or propagate RetryPolicy from the parent workflow execution.",
      "proposedFix": "Add RetryPolicy propagation or include retry options parameter in ContinueAsNewOptions, aligning Java SDK with Go and Python/TypeScript SDK behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by PR #1961 which implemented retry policy propagation for continue-as-new.",
      "related": [
        695,
        372,
        1961
      ],
      "keyQuote": "Retry Options and other attributes are propagated by default in Go SDK and Python/TS SDK. This should help Java SDK to align the behaviour on continue-as-new.",
      "number": 1959,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:08.858Z"
    },
    {
      "summary": "Request to implement worker autotuning for pollers in the Java SDK, aligning with a broader feature initiative tracked in the features repository.",
      "category": "feature",
      "subcategory": "worker-tuning",
      "apis": [],
      "components": [
        "worker",
        "poller"
      ],
      "concepts": [
        "autotuning",
        "performance-optimization",
        "resource-management",
        "scalability"
      ],
      "severity": "medium",
      "userImpact": "Users will benefit from automatic optimization of worker poller configuration, improving performance without manual tuning.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of the worker autotuning feature initiative",
      "related": [
        334
      ],
      "keyQuote": "Worker autotuning - Pollers",
      "number": 1956,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:53:04.013Z"
    },
    {
      "summary": "Request for dynamic configuration of worker behavior at runtime. The issue was closed due to uncertainty about implementation approach and architectural changes (particularly Nexus introduction as a potential transport for config changes).",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "worker",
        "configuration"
      ],
      "concepts": [
        "dynamic-configuration",
        "runtime-configuration",
        "worker-behavior",
        "transport",
        "nexus"
      ],
      "severity": "low",
      "userImpact": "Users cannot dynamically adjust worker configuration at runtime, potentially requiring restarts to apply configuration changes.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed due to unclear requirements and significant architectural changes (Nexus development) that could provide a better transport mechanism for config changes.",
      "related": [
        388
      ],
      "keyQuote": "Unclear what/how we want to do this, and a lot has changed since this was opened (e.g. we are building Nexus now, which could be a transport for config changes).",
      "number": 1955,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:53.359Z"
    },
    {
      "summary": "Request to add schedule testing support to the temporal-test-server for Java SDK. The test server's time-skipping architecture doesn't support concurrent, independent workflow runs needed for proper schedule testing.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "temporal-test-server",
        "schedule-executor",
        "workflow-engine"
      ],
      "concepts": [
        "schedule",
        "time-skipping",
        "concurrent-workflows",
        "test-isolation",
        "multi-workflow"
      ],
      "severity": "low",
      "userImpact": "Users cannot test schedules using the lightweight test server and must use a real server instead.",
      "rootCause": "The test server uses server-wide time skipping rather than per-workflow time control, preventing concurrent independent workflow runs required for schedule testing.",
      "proposedFix": null,
      "workaround": "Run schedule tests using a real or local server instead of the test server.",
      "resolution": "wontfix",
      "resolutionDetails": "Team decided the architectural changes required to support schedules in the test server would be too complex relative to the benefit, and users can use a real server instead.",
      "related": [],
      "keyQuote": "The test server isn't really built well to be a multi-workflow server...time skipping is server-wide not per workflow.",
      "number": 1954,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:51.611Z"
    },
    {
      "summary": "TestWorkflowExtension needs support for WorkflowImplementationOptions to allow configurable behavior like failWorkflowExceptionTypes during testing, currently only using defaults.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "registerWorkflowImplementationTypes"
      ],
      "components": [
        "TestWorkflowExtension",
        "worker",
        "testing"
      ],
      "concepts": [
        "testing",
        "configuration",
        "exception-handling",
        "workflow-registration",
        "retry-behavior"
      ],
      "severity": "low",
      "userImpact": "Test authors cannot configure failWorkflowExceptionTypes and other WorkflowImplementationOptions when using TestWorkflowExtension, limiting test flexibility.",
      "rootCause": null,
      "proposedFix": "Add a WorkflowImplementationOptions property to TestWorkflowExtension and its builder, used in beforeEach when calling worker.registerWorkflowImplementationTypes, with default value of WorkflowImplementationOptions.newBuilder().build().",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Already implemented and will be included in the next Java SDK release (commit bb43d37).",
      "related": [],
      "keyQuote": "Add a WorkflowImplementationOptions property to TestWorkflowExtension and its builder to be used in beforeEach when calling worker.registerWorkflowImplementationTypes.",
      "number": 1953,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:50.768Z"
    },
    {
      "summary": "Two high-severity vulnerabilities (CVE-2023-6481, CVE-2023-6378) in logback-core and logback-classic dependencies used by ktlint-0.47.1, which is a build dependency in the Java SDK's temporal-kotlin module. Both are serialization vulnerabilities enabling denial-of-service attacks.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "build-dependencies",
        "kotlin-module",
        "build-gradle"
      ],
      "concepts": [
        "dependency-vulnerability",
        "serialization",
        "denial-of-service",
        "logback",
        "transitive-dependency",
        "security-patch"
      ],
      "severity": "high",
      "userImpact": "Users building the Java SDK are exposed to high-severity DoS vulnerabilities through transitive dependencies that could be exploited by attackers sending poisoned data.",
      "rootCause": "ktlint-0.47.1 depends on logback-classic-1.3.0 which depends on logback-core-1.3.0, both containing serialization vulnerabilities in their receiver components.",
      "proposedFix": "Upgrade logback-core to version 1.2.13, 1.3.14, or 1.4.14 and logback-classic to version 1.3.12 or 1.4.12. Alternatively, consider removing or updating the ktlint build dependency.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A serialization vulnerability in logback receiver component allows an attacker to mount a Denial-Of-Service attack by sending poisoned data.",
      "number": 1952,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:38.227Z"
    },
    {
      "summary": "Spring Boot 2.7.12 dependency includes logback-core 1.2.12 with a serialization vulnerability (CVE-2023-6481) that allows attackers to mount Denial-of-Service attacks. Upgrade to logback-core 1.2.13 or later to remediate.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "logback",
        "dependency-management"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "DoS",
        "serialization",
        "transitive-dependency",
        "remediation"
      ],
      "severity": "high",
      "userImpact": "Applications using spring-boot-dependencies-2.7.12 are exposed to a network-based denial-of-service attack through poisoned data sent to the logback receiver component.",
      "rootCause": "Serialization vulnerability in logback receiver component (ch.qos.logback:logback-core:1.2.12) allows remote attackers to cause availability impact without authentication.",
      "proposedFix": "Upgrade logback-core to version 1.2.13, 1.3.14, or 1.4.14",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A serialization vulnerability in logback receiver component part of logback version 1.4.13, 1.3.13 and 1.2.12 allows an attacker to mount a Denial-Of-Service attack",
      "number": 1951,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:33.656Z"
    },
    {
      "summary": "Add logic to fail tasks when workers encounter unknown history events that they must handle (when HistoryEvent.worker_may_ignore is false). Currently workers may silently ignore or mishandle critical events.",
      "category": "feature",
      "subcategory": "event-handling",
      "apis": [],
      "components": [
        "worker",
        "history-event-processor",
        "task-executor"
      ],
      "concepts": [
        "event-handling",
        "error-recovery",
        "worker-compatibility",
        "unknown-events",
        "graceful-failure"
      ],
      "severity": "medium",
      "userImpact": "Prevents silent failures and data corruption when workers encounter unknown but required events, improving reliability and debuggability.",
      "rootCause": null,
      "proposedFix": "Fail the task when an event is seen that the worker must handle but is not familiar with",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Fail the task when an event is seen that the worker must handle but is not familiar with",
      "number": 1945,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:34.340Z"
    },
    {
      "summary": "When an update request calls continue-as-new on a workflow, the SDK should fail or complete the update with a specific response to indicate the workflow continued as new rather than the update succeeding.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "update"
      ],
      "components": [
        "update-handler",
        "workflow-execution",
        "continue-as-new"
      ],
      "concepts": [
        "update-semantics",
        "workflow-continuation",
        "request-completion",
        "error-handling",
        "state-transition"
      ],
      "severity": "medium",
      "userImpact": "Users cannot distinguish whether an update request succeeded or if the workflow continued as new, making it unclear if the update operation was actually processed.",
      "rootCause": "The SDK has no mechanism to fail or complete an update request with a specific response when continue-as-new is called, leaving the update in an ambiguous state.",
      "proposedFix": "Fail the update request with a specific response indicating the workflow continued as new, or have the server handle unblocking pending updates when a workflow completes.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed in favor of temporalio/temporal#5174, indicating the fix should be implemented at the server level rather than in the SDK.",
      "related": [
        5174
      ],
      "keyQuote": "the update can't succeeded because I can't force the update handles type to be the type of the success message",
      "number": 1944,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:19.608Z"
    },
    {
      "summary": "Java SDK cannot be used as a named Java module due to split packages across multiple JAR files (temporal.sdk and temporal.serviceclient both contain io.temporal.internal packages), preventing proper module-info.java or Automatic-Module-Name support.",
      "category": "feature",
      "subcategory": "module-system",
      "apis": [],
      "components": [
        "gradle-build",
        "packaging",
        "dependencies",
        "manifest"
      ],
      "concepts": [
        "java-modules",
        "split-packages",
        "module-info",
        "automatic-module-name",
        "jar-packaging",
        "gradle-configuration"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use the Java SDK as a named module in modular Java applications due to package conflicts across JAR files.",
      "rootCause": "Classes from io.temporal.internal and io.temporal.internal.common packages are distributed across multiple JAR files (temporal.sdk and temporal.serviceclient), creating split packages which violate Java module system constraints.",
      "proposedFix": "Rename io.temporal.internal.common to io.temporal.internal.utils in temporal-sdk module, move WorkflowThreadMarker and BackoffThrottler classes to the new utils package to eliminate split packages, then add module-info.java or Automatic-Module-Name manifest entries.",
      "workaround": "Use shadow JAR plugin to repack packages and avoid module conflicts; continue using unnamed module classpath.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The first step should be to stop sharing/splitting packages in different modules/jars. This is an easy fix, takes no more than 10 minutes for an experienced coder.",
      "number": 1940,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:21.544Z"
    },
    {
      "summary": "The `toProtoDuration` method throws an `ArithmeticException` when converting a Java `Duration` to protobuf `Duration` if the Duration value is too large. The method uses `toMillis()` which can overflow for very large durations; the fix should convert seconds directly and truncate nanoseconds to millisecond precision.",
      "category": "bug",
      "subcategory": "duration-conversion",
      "apis": [],
      "components": [
        "duration-conversion",
        "protobuf-serialization",
        "type-conversion"
      ],
      "concepts": [
        "overflow",
        "arithmetic-exception",
        "duration",
        "millisecond-precision",
        "type-conversion",
        "edge-cases"
      ],
      "severity": "medium",
      "userImpact": "Users with very large Duration values will experience runtime crashes when the SDK attempts to convert them to protobuf Duration.",
      "rootCause": "The `toMillis()` method can overflow for Duration values that are too large, causing an ArithmeticException during the conversion to protobuf Duration.",
      "proposedFix": "Convert seconds directly from the Duration and truncate nanoseconds to millisecond precision instead of using `toMillis()` which can overflow.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "if the Java Duration represents a very large value converting to milliseconds may result in an overflow",
      "number": 1938,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:17.734Z"
    },
    {
      "summary": "Request for a promise-based alternative to the blocking await() function in workflows, allowing developers to coordinate mixed event classes like activities and signals without blocking. The proposed API would return a Promise that resolves based on a predicate evaluation or timeout.",
      "category": "feature",
      "subcategory": "async-coordination",
      "apis": [
        "Workflow.await"
      ],
      "components": [
        "workflow-execution",
        "promise-coordination",
        "async-apis"
      ],
      "concepts": [
        "promise",
        "await",
        "timeout",
        "predicate",
        "coordination",
        "non-blocking",
        "event-handling"
      ],
      "severity": "medium",
      "userImpact": "Developers gain more flexible options for coordinating mixed event classes in workflows without resorting to blocking operations.",
      "rootCause": null,
      "proposedFix": "Add a static Promise<Boolean> await(Duration timeout, Supplier<Boolean> unblockCondition) method to an Async class, evaluating the predicate on each state transition and resolving with true/false based on predicate result or timeout.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Promise until(java.time.Duration timeout, java.util.function.Supplier<java.lang.Boolean> predicate) - function would take a timeout and predicate, and return a promise.",
      "number": 1937,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:03.098Z"
    },
    {
      "summary": "User encountered a DataConverterException for 'binary/null' encoding in Java SDK. The issue was resolved by clarifying that NullPayloadConverter is already part of the default data converter and must be explicitly registered if not using default settings.",
      "category": "question",
      "subcategory": "data-converter",
      "apis": [],
      "components": [
        "data-converter",
        "payload-converter",
        "NullPayloadConverter"
      ],
      "concepts": [
        "serialization",
        "encoding",
        "null-handling",
        "data-conversion",
        "default-converter"
      ],
      "severity": "low",
      "userImpact": "Users not using the default data converter may encounter exceptions when handling binary null payloads unless they explicitly register NullPayloadConverter.",
      "rootCause": "User was not using the default data converter which includes NullPayloadConverter, or failed to register it manually when using a custom converter.",
      "proposedFix": "Ensure NullPayloadConverter is registered in the data converter configuration, either by using the default data converter or explicitly adding it to a custom configuration.",
      "workaround": "Register NullPayloadConverter explicitly when configuring a custom DataConverter.",
      "resolution": "fixed",
      "resolutionDetails": "Clarified that NullPayloadConverter is already implemented in Java SDK's default data converter. Users need to ensure it's registered if using custom configurations.",
      "related": [],
      "keyQuote": "The NullPayloadConverter is part of the default data converter for Java does register itself for binary/null",
      "number": 1933,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:02.454Z"
    },
    {
      "summary": "SDK-Java 1.22.3 broke the ability to query workflow executions after calling testEnv.sleep(). Queries fail with WorkflowQueryException after testEnv.sleep() in tests, though this functionality worked in v1.22.2.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "query",
        "newUntypedWorkflowStub",
        "WorkflowOptions"
      ],
      "components": [
        "test-environment",
        "workflow-stub",
        "query-handler"
      ],
      "concepts": [
        "test-execution",
        "time-simulation",
        "query-state",
        "test-server-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot query workflow state in tests after advancing test time with testEnv.sleep(), breaking common test patterns that were working in previous versions.",
      "rootCause": "Regression introduced in v1.22.3 related to changes in PR #1916; actual root cause was old temporal-test-server version being resolved instead of 1.22.3.",
      "proposedFix": null,
      "workaround": "Ensure temporal-test-server dependency is explicitly set to version 1.22.3 or later.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by confirming temporal-test-server version was up to date; the SDK change in 1.22.3 was not the actual cause, but an outdated test-server dependency.",
      "related": [
        1916
      ],
      "keyQuote": "It used to be possible to issue a testEnv.sleep(Duration) in a test and subsequently query the execution in v1.22.2 but this seems to have been broken in v1.22.3",
      "number": 1931,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:52:05.777Z"
    },
    {
      "summary": "Request to tag workflow_task_execution_failed metrics with error type information for better observability. This follows feature request #231 in the features repository.",
      "category": "feature",
      "subcategory": "metrics-tagging",
      "apis": [],
      "components": [
        "metrics",
        "workflow-execution",
        "error-handling"
      ],
      "concepts": [
        "observability",
        "metrics",
        "error-classification",
        "monitoring",
        "tagging"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily filter and analyze workflow task execution failures by error type in their monitoring systems.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Likely addressed as part of feature implementation #231 or related metrics enhancement",
      "related": [
        231
      ],
      "keyQuote": "Tag workflow_task_execution_failed with error type",
      "number": 1929,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:45.696Z"
    },
    {
      "summary": "Workflow signal handlers with non-deterministic logic that would fail on replay should throw NonDeterministicException instead of IllegalStateException. Currently, signals received after workflow completion result in an error that doesn't properly indicate a determinism violation.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "signal-handler",
        "workflow-executor",
        "determinism-checker"
      ],
      "concepts": [
        "non-determinism",
        "replay",
        "signal-handling",
        "workflow-completion",
        "deterministic-execution"
      ],
      "severity": "high",
      "userImpact": "Users receive misleading error messages (IllegalStateException) instead of proper NonDeterministicException when signal handlers have non-deterministic behavior, making it harder to debug workflow logic errors.",
      "rootCause": "Signal handler non-determinism check doesn't distinguish between actual post-completion signals and replay-induced determinism violations, throwing generic IllegalStateException instead.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If a workflow receives multiple signals and one signal has non deterministic logic in the signal handler that originally did not continue as new but on replay does should throw a `NonDeterministicException`",
      "number": 1928,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:47.139Z"
    },
    {
      "summary": "Grpc-java v1.59.0 introduced an ABI breaking change requiring the SDK to update its grpc and protoc dependencies to v1.36.0 or later to maintain compatibility with compiled code.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "grpc-core",
        "protoc-compiler",
        "grpc-generator"
      ],
      "concepts": [
        "dependency-upgrade",
        "ABI-compatibility",
        "breaking-change",
        "transitive-dependencies",
        "version-mismatch"
      ],
      "severity": "medium",
      "userImpact": "Users may experience ABI incompatibility issues if they have mismatched versions of gRPC transitive dependencies.",
      "rootCause": "Grpc-java v1.59.0 introduced planned ABI breakage for @ExperimentalApi classes; issue was ultimately caused by users not updating all transitive dependencies uniformly.",
      "proposedFix": "Upgrade grpc generator to at least v1.36.0 and potentially update the protoc compiler as the current one uses deprecated methods.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "No work needed - root cause was determined to be user error (not updating all transitive dependencies uniformly), not an SDK issue.",
      "related": [],
      "keyQuote": "No work needed. Root cause was the user was not also updating all the transitive dependencies as well",
      "number": 1927,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:49.690Z"
    },
    {
      "summary": "Workflow executions became frozen in Running state after a NullPointerException in FailureConverter.failureToException during stack trace processing. The issue caused WorkflowTask state machine failures that prevented progress, requiring worker restarts to recover.",
      "category": "bug",
      "subcategory": "workflow-task-processing",
      "apis": [],
      "components": [
        "workflow-worker",
        "state-machine",
        "failure-converter",
        "replay-handler"
      ],
      "concepts": [
        "state-machine-transition",
        "stack-trace-processing",
        "null-pointer-exception",
        "workflow-task-failure",
        "execution-freeze"
      ],
      "severity": "high",
      "userImpact": "Workflow executions can become completely frozen and require worker restart to resume, causing production outages.",
      "rootCause": "NullPointerException in FailureConverter.failureToException at stackTrace[15] when processing stack traces with null elements, causing state machine transition failures.",
      "proposedFix": "Fix stack trace handling in FailureConverter to properly handle null stack trace elements during failure conversion.",
      "workaround": "Restart all workers to recover stuck executions.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #1795, available in v1.22.0 SDK release.",
      "related": [
        1795
      ],
      "keyQuote": "java.lang.NullPointerException: stackTrace[15] at java.base/java.lang.Throwable.setStackTrace(Throwable.java:879)",
      "number": 1921,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:34.061Z"
    },
    {
      "summary": "Request to support configurable bind address for test server, allowing binding to specific addresses like 127.0.0.1 instead of defaulting to all addresses.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "server-configuration",
        "network-binding"
      ],
      "concepts": [
        "bind-address",
        "localhost",
        "network-configuration",
        "test-infrastructure",
        "server-setup"
      ],
      "severity": "low",
      "userImpact": "Users cannot restrict test server to specific network interfaces, limiting flexibility in test environments and network configurations.",
      "rootCause": null,
      "proposedFix": "Add a configuration option to set the bind address for the test server instead of always binding to all addresses.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Need to be able to set bind address (e.g. for 127.0.0.1) instead of assuming all addresses",
      "number": 1920,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:31.028Z"
    },
    {
      "summary": "Java SDK doesn't verify it replays up to the StartedEventId sent in workflow task polls, which can cause incomplete workflow history replay if fetching from GetWorkflowExecutionHistory after receiving partial history with no cached execution on stale history nodes.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "GetWorkflowExecutionHistory"
      ],
      "components": [
        "workflow-task-processor",
        "history-replay",
        "task-poller"
      ],
      "concepts": [
        "replay",
        "history",
        "StartedEventId",
        "partial-history",
        "stale-history"
      ],
      "severity": "high",
      "userImpact": "Users may encounter incomplete workflow history replay in edge cases with older servers, leading to potential workflow state inconsistencies.",
      "rootCause": "Java SDK does not validate that replayed history matches the StartedEventId boundary from the workflow task poll request.",
      "proposedFix": null,
      "workaround": "Upgrade to server version 1.21 or greater where the server won't send partial history on normal task queues.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing verification of replay up to StartedEventId in the Java SDK workflow task processing.",
      "related": [],
      "keyQuote": "Java SDK does not verify it replays up to `StartedEventId` sent on the poll request when processing a workflow task.",
      "number": 1915,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:34.902Z"
    },
    {
      "summary": "Users need a way to cancel long-running client calls such as GetWorkflowResult or GetUpdateResult, with optional timeout support. This should follow common Java practices for cancellation.",
      "category": "feature",
      "subcategory": "client-cancellation",
      "apis": [
        "GetWorkflowResult",
        "GetUpdateResult"
      ],
      "components": [
        "client",
        "blocking-calls",
        "cancellation-handling"
      ],
      "concepts": [
        "cancellation",
        "timeout",
        "long-running-calls",
        "client-operations",
        "async-patterns"
      ],
      "severity": "medium",
      "userImpact": "Users cannot cancel or timeout long-running client calls, blocking threads indefinitely and limiting application responsiveness.",
      "rootCause": null,
      "proposedFix": "Implement cancellation mechanism for client calls with optional timeout support, following Java best practices (e.g., Future cancellation, CompletableFuture, or similar patterns).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1212
      ],
      "keyQuote": "Provide some way for users to cancel a long client call such as getting workflow result or getting update result.",
      "number": 1914,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:20.423Z"
    },
    {
      "summary": "Remove the WorkflowClientCallsInterceptor.pollWorkflowUpdate method as it is unnecessarily interceptable, inconsistent with how workflow result retrieval works in the Java SDK.",
      "category": "feature",
      "subcategory": "interceptor-design",
      "apis": [
        "pollWorkflowUpdate",
        "getWorkflowResult"
      ],
      "components": [
        "interceptor",
        "workflow-client",
        "async-operations"
      ],
      "concepts": [
        "consistency",
        "api-design",
        "interceptability",
        "workflow-updates",
        "result-retrieval"
      ],
      "severity": "low",
      "userImpact": "Simplifies the interceptor API by removing unnecessary interceptability that contradicts existing SDK patterns.",
      "rootCause": "The pollWorkflowUpdate method is interceptable unlike the async workflow result retrieval, creating an inconsistency in the SDK design.",
      "proposedFix": "Remove the WorkflowClientCallsInterceptor.pollWorkflowUpdate method entirely.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Getting the workflow result in an async manner is intercept-able in Java so this is inconsistent with the rest of the Java SDK",
      "number": 1913,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:16.458Z"
    },
    {
      "summary": "The proto-google-common-protos dependency used by StatusUtils is missing from the shaded SDK, causing NoClassDefFoundErrors or IncompatibleClassChangeErrors when converting status objects to/from exceptions.",
      "category": "bug",
      "subcategory": "shading-dependencies",
      "apis": [
        "StatusUtils"
      ],
      "components": [
        "shaded-sdk",
        "status-conversion",
        "exception-handling"
      ],
      "concepts": [
        "dependency-shading",
        "classpath-issues",
        "protobuf",
        "class-resolution",
        "runtime-errors"
      ],
      "severity": "high",
      "userImpact": "Users of the shaded SDK encounter runtime errors when the SDK attempts to convert gRPC status objects to exceptions.",
      "rootCause": "com.google.api.grpc:proto-google-common-protos is not included in the SDK shading configuration despite being a dependency of StatusUtils.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The missing dependency was added to the shading configuration to ensure proto-google-common-protos is included in the shaded SDK JAR.",
      "related": [],
      "keyQuote": "com.google.api.grpc:proto-google-common-protos that is used by StatusUtils is not included in the shaded SDK. This causes NoClassDefFoundErrors or IncompatibleClassChangeError",
      "number": 1911,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:18.018Z"
    },
    {
      "summary": "Test Server hangs or incorrectly reports workflow completion after update requests. The issue occurs inconsistently - hanging when using CDN-downloaded server, and falsely reporting completion when running locally.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "test-server",
        "update-handler",
        "workflow-state"
      ],
      "concepts": [
        "workflow-updates",
        "server-state",
        "test-infrastructure",
        "async-operations",
        "state-synchronization"
      ],
      "severity": "high",
      "userImpact": "SDK developers cannot reliably test workflow update functionality, blocking update feature development and testing across multiple SDKs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        179
      ],
      "keyQuote": "the server was either hanging (when downloaded from the CDN) or reporting the workflow was complete when it wasn't",
      "number": 1903,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:02.812Z"
    },
    {
      "summary": "Read-only check failures in update validators should cause a workflow task failure rather than failing the entire update. This issue was resolved by PR #1918.",
      "category": "bug",
      "subcategory": "update-validator",
      "apis": [],
      "components": [
        "update-validator",
        "workflow-task",
        "read-only-check"
      ],
      "concepts": [
        "validation",
        "error-handling",
        "workflow-task-failure",
        "update-semantics",
        "read-only"
      ],
      "severity": "medium",
      "userImpact": "Users experience incorrect error handling when read-only checks fail in update validators, causing updates to fail instead of the workflow task.",
      "rootCause": "Read-only check failures were not being properly converted to workflow task failures in the update validator context.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #1918 which corrected the read-only check failure handling in update validators.",
      "related": [
        1918
      ],
      "keyQuote": "Failed read-Only check should cause a WFT failure in an update validator, not fail the update",
      "number": 1901,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:05.362Z"
    },
    {
      "summary": "Audit and verify that SerializationContext is applied consistently across all data conversion sites in the Java SDK, particularly in areas like memo fields during StartWorkflow calls where it may be missing.",
      "category": "bug",
      "subcategory": "serialization-context",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "data-converter",
        "serialization",
        "workflow-start"
      ],
      "concepts": [
        "serialization",
        "data-conversion",
        "context-consistency",
        "audit",
        "memo"
      ],
      "severity": "medium",
      "userImpact": "Users may experience inconsistent serialization behavior across different SDK operations, potentially leading to unexpected data transformation results.",
      "rootCause": "SerializationContext is not being applied uniformly across all data conversion sites in the SDK, with specific gaps identified in memo handling during StartWorkflow.",
      "proposedFix": "Audit all data conversion sites in the SDK and add comprehensive tests to verify SerializationContext is consistently applied everywhere.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the audit was completed and inconsistencies were addressed.",
      "related": [],
      "keyQuote": "SerializationContext should be applied consistently in the Java SDK",
      "number": 1895,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:51:01.365Z"
    },
    {
      "summary": "The Terminate call in the Java SDK is not setting the identity field, which should be included for proper request identification and tracking.",
      "category": "bug",
      "subcategory": "workflow-termination",
      "apis": [
        "Terminate"
      ],
      "components": [
        "workflow-service",
        "client",
        "request-builder"
      ],
      "concepts": [
        "identity",
        "workflow-termination",
        "request-metadata",
        "cross-language-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users terminating workflows may lack proper identity tracking, affecting audit trails and request logging across SDK calls.",
      "rootCause": "Identity field is not being set when constructing the Terminate request in the Java SDK implementation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Identity field was added to the Terminate call implementation to match behavior in other SDKs, as referenced in the linked features issue.",
      "related": [
        193
      ],
      "keyQuote": "Identity not set on `Terminate` call in the Java SDK",
      "number": 1893,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:46.721Z"
    },
    {
      "summary": "The spring-boot-starter dependency in the Java SDK contains 9 known vulnerabilities from transitive dependencies (snakeyaml, logback, spring-boot), with the most critical being CVE-2022-1471 (CVSS 9.8) allowing remote code execution via unsafe YAML deserialization.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "dependency-management",
        "build-configuration"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "dependency-upgrade",
        "transitive-dependency",
        "deserialization",
        "remote-code-execution",
        "yaml-parsing"
      ],
      "severity": "critical",
      "userImpact": "Applications using the Temporal Java SDK with spring-boot-starter are exposed to remote code execution attacks and denial-of-service through vulnerable transitive dependencies.",
      "rootCause": "Outdated transitive dependencies in spring-boot-starter (snakeyaml-1.30, logback-classic-1.2.12, spring-boot-2.7.12) contain unpatched security vulnerabilities with high CVSS scores.",
      "proposedFix": "Upgrade spring-boot-starter to version 3.2.0 or later, which includes patched versions of snakeyaml (2.0+), logback-classic (1.2.13+), and spring-boot (2.7.18+) to remediate all 9 CVEs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution.",
      "number": 1890,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:49.779Z"
    },
    {
      "summary": "Dependency vulnerability in snakeyaml-1.30.jar used by spring-boot-starter with 7 security issues including a critical remote code execution vulnerability (CVE-2022-1471, CVSS 9.8).",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "dependency-management",
        "snakeyaml"
      ],
      "concepts": [
        "security-vulnerability",
        "remote-code-execution",
        "deserialization",
        "yaml-parsing",
        "dependency-upgrade",
        "transitive-dependency"
      ],
      "severity": "critical",
      "userImpact": "Applications using the Spring Boot starter are exposed to critical security vulnerabilities that could allow remote code execution through untrusted YAML deserialization.",
      "rootCause": "snakeyaml version 1.30 has unrestricted type instantiation during YAML deserialization, allowing arbitrary object instantiation by attackers.",
      "proposedFix": "Upgrade snakeyaml to version 2.0 or higher, and spring-boot-starter to version 3.0.0 or higher. Use SafeConstructor when parsing untrusted YAML content.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Issue was automatically closed as a duplicate of #1890 by Mend.",
      "related": [
        1890
      ],
      "keyQuote": "SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution.",
      "number": 1889,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:47.262Z"
    },
    {
      "summary": "Kotlin Standard Library 1.5.32 has a transitive dependency vulnerability (CVE-2022-24329) with CVSS score 5.3 affecting Multiplatform Gradle Projects. The issue allows dependency lock functionality to be bypassed in Kotlin projects. Automatic remediation is available by upgrading to version 1.6.0.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "build-system",
        "gradle",
        "kotlin-stdlib",
        "dependency-management"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-locking",
        "transitive-dependency",
        "gradle-build",
        "kotlin-multiplatform",
        "integrity-impact"
      ],
      "severity": "medium",
      "userImpact": "Projects using kotlin-klib-commonizer-embeddable-1.5.32 are exposed to a security vulnerability that allows dependency lock circumvention in Multiplatform Gradle builds.",
      "rootCause": "Kotlin Standard Library before 1.6.0 does not properly implement dependency locking for Multiplatform Gradle Projects, allowing integrity bypass with network attack vector.",
      "proposedFix": "Upgrade kotlin-klib-commonizer-embeddable to version 1.6.0 or upgrade org.jetbrains.kotlin:kotlin-stdlib to 1.6.0-M1 or later.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.",
      "number": 1888,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:34.235Z"
    },
    {
      "summary": "The Java SDK increments the temporal_workflow_task_execution_failed metric on server-side task completion rejection (e.g., UNHANDLED_COMMAND), but this metric should only reflect worker-side failures. Unlike the Go SDK which logs these cases separately, Java needs to either stop incrementing in server-side rejection scenarios or introduce a label to differentiate worker-side failures from server-side rejections.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "metrics",
        "workflow-task-execution"
      ],
      "concepts": [
        "metric-accuracy",
        "task-completion",
        "error-classification",
        "observability",
        "metric-semantics"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably use the workflow_task_execution_failed metric to distinguish worker-side failures from server-side rejections, making monitoring and debugging more difficult.",
      "rootCause": "Java SDK increments workflow_task_execution_failed metric in both worker-side task failure and server-side task completion rejection cases, whereas the metric semantics only intend to track worker-side failures.",
      "proposedFix": "Either stop incrementing the metric on server-side task completion rejection, or introduce a label to differentiate between worker-side task failures and server-side task rejections.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we _also_ increment this on server-side task completion rejection (e.g. `UNHANDLED_COMMAND`). We should have some way to differentiate worker-side task failure and server-side task rejection.",
      "number": 1885,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:32.851Z"
    },
    {
      "summary": "Build fails on Ubuntu Linux for aarch64 ARM architecture because the protoc executable being pulled is for macOS instead of Linux. The gradle build configuration needs to check both OS and architecture to select the correct protoc binary.",
      "category": "bug",
      "subcategory": "build-system",
      "apis": [],
      "components": [
        "build.gradle",
        "protoc-compiler",
        "protobuf-dependencies"
      ],
      "concepts": [
        "cross-platform-build",
        "architecture-detection",
        "dependency-resolution",
        "compilation",
        "gradle-configuration"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot build the Java SDK from source on Ubuntu Linux running on aarch64 ARM hardware.",
      "rootCause": "The build.gradle in temporal-serviceclient only checks os.arch but ignores the OS type (Linux vs macOS), causing incorrect protoc binary selection for Linux aarch64 systems.",
      "proposedFix": "Update gradle.build to check both OS and architecture, pulling protoc-3.10.1-linux-aarch_64.exe for Linux aarch64 systems instead of the macOS binary.",
      "workaround": "Building from source on OSX",
      "resolution": "fixed",
      "resolutionDetails": "Build configuration was updated to properly handle Linux aarch64 architecture detection.",
      "related": [],
      "keyQuote": "The gradle.build file needs to also consider the OS and pull in the correct protoc executable.",
      "number": 1883,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:31.928Z"
    },
    {
      "summary": "Speculative workflow tasks can cause workflow task (WFT) failures in the Java SDK. When a speculative update is rejected and followed by a signal, the WFT may fail unexpectedly.",
      "category": "bug",
      "subcategory": "workflow-task-processing",
      "apis": [],
      "components": [
        "workflow-task-handler",
        "speculative-execution",
        "signal-processing"
      ],
      "concepts": [
        "speculative-execution",
        "workflow-task-failure",
        "signal-handling",
        "task-rejection",
        "error-recovery"
      ],
      "severity": "high",
      "userImpact": "Users experience workflow task failures when using speculative updates with signals, causing workflow execution interruptions.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Speculative workflow task can cause WFT failure",
      "number": 1880,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:19.084Z"
    },
    {
      "summary": "WorkflowLocal instances created via withInitial() were being shared across different Workflows instead of creating unique instances per Workflow. This regression from v1.19.1 caused child workflows to access the same WorkflowLocal instance as their parent, breaking isolation.",
      "category": "bug",
      "subcategory": "workflow-local-storage",
      "apis": [
        "WorkflowLocal"
      ],
      "components": [
        "workflow-local",
        "child-workflow",
        "workflow-context"
      ],
      "concepts": [
        "thread-local-storage",
        "workflow-isolation",
        "instance-creation",
        "state-sharing",
        "lifecycle"
      ],
      "severity": "high",
      "userImpact": "Users experience unexpected state sharing between workflows when using WorkflowLocal, breaking workflow isolation guarantees and causing silent data corruption.",
      "rootCause": "WorkflowLocal.withInitial() was not properly isolating the supplier function calls per workflow context, causing all workflows to share the same initial instance.",
      "proposedFix": "Add a new caching behavior API for WorkflowLocal (referenced in PR #1878) that ensures each workflow gets its own unique instance, with the old API deprecated.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #1878 which added a new caching API for WorkflowLocal and deprecated the non-caching withInitial() version to maintain backwards compatibility.",
      "related": [
        1878
      ],
      "keyQuote": "I get the same instance of MyClass returned in every Workflow.",
      "number": 1876,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:18.704Z"
    },
    {
      "summary": "TestWorkflowEnvironment returns null for typed search attributes that work correctly in production environments, indicating a test framework implementation gap.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.getTypedSearchAttributes",
        "SearchAttributeKey.forOffsetDateTime"
      ],
      "components": [
        "test-workflow-environment",
        "search-attributes",
        "workflow-context"
      ],
      "concepts": [
        "search-attributes",
        "typed-queries",
        "test-environment",
        "mocking",
        "workflow-state"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot properly test workflows that use typed search attributes, as test environments do not correctly simulate production behavior.",
      "rootCause": "TestWorkflowEnvironment does not properly initialize or populate typed search attributes for test workflows.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating it was resolved in a subsequent version or through a fix.",
      "related": [],
      "keyQuote": "When running a workflow that does getTypedSearchAttributes in test using TestWorkflowEnvironment the value of getTypedSearchAttributes is null. When run outside of test env this works fine",
      "number": 1875,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:15.816Z"
    },
    {
      "summary": "Enable TCP Keep Alive by default in the Java SDK to improve connection stability and detect network failures more reliably.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [],
      "components": [
        "gRPC-client",
        "connection-pool",
        "network-transport"
      ],
      "concepts": [
        "TCP keep-alive",
        "connection-stability",
        "network-reliability",
        "heartbeat",
        "failure-detection"
      ],
      "severity": "medium",
      "userImpact": "Users benefit from more reliable connection handling and faster detection of network failures without manual configuration.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "TCP Keep Alive was enabled by default in the Java SDK to improve connection stability.",
      "related": [
        123
      ],
      "keyQuote": "Enable TCP Keep alive by default",
      "number": 1872,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:00.359Z"
    },
    {
      "summary": "When a workflow task times out with `UnableToAcquireLockException`, the worker slot is not released, causing resource leaks and preventing future tasks from executing on that slot.",
      "category": "bug",
      "subcategory": "worker-slots",
      "apis": [],
      "components": [
        "worker",
        "slot-manager",
        "task-execution",
        "lock-management"
      ],
      "concepts": [
        "timeout",
        "resource-leak",
        "slot-release",
        "exception-handling",
        "concurrency",
        "lock-acquisition"
      ],
      "severity": "high",
      "userImpact": "Workflow tasks timeout with lock exceptions, causing permanent slot loss that degrades worker capacity and throughput.",
      "rootCause": "Exception handler for `UnableToAcquireLockException` during workflow task timeout does not properly release the acquired slot.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Slot release logic was corrected to ensure slots are freed even when `UnableToAcquireLockException` occurs during task timeout handling.",
      "related": [],
      "keyQuote": "If a workflow task times out with `UnableToAcquireLockException` the slot is not released",
      "number": 1870,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:04.612Z"
    },
    {
      "summary": "User asked how to run workflows using the temporal-spring-boot-starter-alpha. The question was redirected to documentation and community channels as it's not an SDK bug.",
      "category": "question",
      "subcategory": "spring-boot-integration",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "spring-boot-starter",
        "workflow-execution"
      ],
      "concepts": [
        "workflow-execution",
        "spring-boot-integration",
        "getting-started",
        "documentation"
      ],
      "severity": "low",
      "userImpact": "User needs guidance on how to properly execute workflows when using the Spring Boot starter.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Closed as not an SDK issue; user directed to documentation and community forums for general questions.",
      "related": [],
      "keyQuote": "Closing since this is not an SDK issue, feel free to ask general questions on our forum or community slack",
      "number": 1867,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:50:02.159Z"
    },
    {
      "summary": "Request to expose the workflow retry policy set by the client through the WorkflowInfo API, allowing workflow code to inspect retry settings configured at invocation time.",
      "category": "feature",
      "subcategory": "workflow-retry-policy",
      "apis": [
        "WorkflowInfo",
        "Workflow.getInfo"
      ],
      "components": [
        "workflow-info",
        "retry-policy",
        "client-api"
      ],
      "concepts": [
        "retry-policy",
        "workflow-configuration",
        "client-side-settings",
        "workflow-inspection",
        "metadata-access"
      ],
      "severity": "low",
      "userImpact": "Developers who set workflow retry policies on the client side can now inspect these settings from within workflow code for conditional logic or validation.",
      "rootCause": null,
      "proposedFix": "Add retry policy field to WorkflowInfo to expose client-configured retry settings to workflow code.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented via PR #1961, adding retry policy exposure through WorkflowInfo.",
      "related": [
        1961
      ],
      "keyQuote": "if client does set it for some reason it would be good to be able to check it in workflow code via Workflow.getInfo()",
      "number": 1866,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:48.425Z"
    },
    {
      "summary": "Creating a schedule with TriggerImmediately and no policy set throws a null pointer exception instead of working as expected.",
      "category": "bug",
      "subcategory": "schedules",
      "apis": [
        "CreateSchedule",
        "TriggerImmediately"
      ],
      "components": [
        "schedule-service",
        "schedule-validation",
        "api-server"
      ],
      "concepts": [
        "null-safety",
        "schedule-creation",
        "policy-handling",
        "trigger-logic",
        "validation"
      ],
      "severity": "high",
      "userImpact": "Users cannot create schedules with immediate triggers and no policy, preventing use of a valid configuration.",
      "rootCause": "Null pointer exception when policy is not set but TriggerImmediately is used, indicating missing null-safety validation in schedule creation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved, likely through adding null-safety checks or default policy handling for TriggerImmediately schedules.",
      "related": [],
      "keyQuote": "Creating a schedule with `TriggerImmediately` and no policy set throws a null pointer exception",
      "number": 1864,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:46.353Z"
    },
    {
      "summary": "Feature request to add a start delay option to workflow start options in the Java SDK, allowing workflows to be scheduled to start at a future time.",
      "category": "feature",
      "subcategory": "workflow-options",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-client",
        "start-options",
        "workflow-execution"
      ],
      "concepts": [
        "delay",
        "scheduling",
        "workflow-start",
        "temporal-options",
        "future-execution"
      ],
      "severity": "low",
      "userImpact": "Users can schedule workflows to start at a delayed time without external scheduling logic.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented as part of SDK enhancement to support delayed workflow start times.",
      "related": [
        338
      ],
      "keyQuote": "Add start delay to start workflow options",
      "number": 1863,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:49.290Z"
    },
    {
      "summary": "Request to implement support for the Build ID reachability API in the Java SDK, as documented in the Temporal workers documentation.",
      "category": "feature",
      "subcategory": "build-id-reachability",
      "apis": [
        "BuildIDReachability"
      ],
      "components": [
        "worker",
        "build-id-management"
      ],
      "concepts": [
        "build-id",
        "reachability",
        "compatibility",
        "versioning",
        "worker-deployment"
      ],
      "severity": "medium",
      "userImpact": "Java SDK users cannot query which workflow/activity types are reachable from a given build ID, limiting deployment compatibility checking.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Build ID reachability API was implemented and integrated into the Java SDK.",
      "related": [],
      "keyQuote": "Build ID reachability API should be supported in the Java SDK",
      "number": 1862,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:32.608Z"
    },
    {
      "summary": "Worker can get stuck polling only the sticky task queue when empty responses or errors occur. The sticky queue backlog should be reset on empty/error responses (like Go SDK does), but Java SDK only resets on non-empty responses, causing workers to remain stuck polling the sticky queue if all pollers are exhausted.",
      "category": "bug",
      "subcategory": "task-polling",
      "apis": [],
      "components": [
        "worker",
        "task-pollers",
        "sticky-queue"
      ],
      "concepts": [
        "task-polling",
        "sticky-queue",
        "backlog-management",
        "polling-strategy",
        "deadlock",
        "queue-rotation"
      ],
      "severity": "high",
      "userImpact": "Workers can become completely stuck polling only the sticky task queue, unable to process new tasks until the issue is manually resolved.",
      "rootCause": "The sticky queue backlog reset logic only triggers on non-empty responses, unlike the Go SDK which resets on empty responses or errors. This causes workers to remain stuck polling an empty sticky queue when all task pollers are allocated to it.",
      "proposedFix": "Reset the sticky queue backlog on empty responses or errors, matching the Go SDK implementation referenced in the issue.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was fixed by implementing the same backlog reset logic as the Go SDK, resetting on empty/error responses.",
      "related": [],
      "keyQuote": "The worker only resets the backlog if it receives a non empty response. This can cause the worker to get stuck only polling the stick task queue",
      "number": 1858,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:32.913Z"
    },
    {
      "summary": "Feature request to expose worker versioning configuration options through Spring Boot autoconfiguration, allowing developers to manage worker versions via properties/YAML files instead of programmatic configuration.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-autoconfiguration",
        "worker",
        "versioning"
      ],
      "concepts": [
        "worker-versioning",
        "configuration",
        "spring-boot-properties",
        "autoconfig",
        "declarative-config"
      ],
      "severity": "low",
      "userImpact": "Spring Boot users currently cannot configure worker versioning through standard property files and must resort to programmatic configuration.",
      "rootCause": null,
      "proposedFix": "Add worker versioning configuration options to Spring Boot autoconfiguration to support properties/YAML-based setup.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker versioning was exposed via Spring Boot autoconfig, allowing configuration through properties/YAML files.",
      "related": [],
      "keyQuote": "allow worker versioning configs to be added to autoconfig (properties/yaml)",
      "number": 1856,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:34.995Z"
    },
    {
      "summary": "Request to implement typed search attributes for the Java SDK. This feature was already implemented in PR #1782 and this issue appears to be tracking or documenting that implementation.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [
        "SearchAttributes"
      ],
      "components": [
        "search-attributes",
        "type-system",
        "workflow-client"
      ],
      "concepts": [
        "type-safety",
        "search-attributes",
        "workflow-queries",
        "indexing",
        "schema"
      ],
      "severity": "medium",
      "userImpact": "Users can now use type-safe search attributes instead of untyped string-based attributes, improving code safety and IDE support.",
      "rootCause": null,
      "proposedFix": "Implementation completed via PR #1782",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Typed search attributes were already implemented in Java SDK via PR #1782, as noted in the comment by Quinn-With-Two-Ns.",
      "related": [
        1782
      ],
      "keyQuote": "Typed search attributes is already implemented in Java https://github.com/temporalio/sdk-java/pull/1782",
      "number": 1855,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:20.302Z"
    },
    {
      "summary": "WorkerOptions.equals() throws NullPointerException when buildid is not explicitly set because the equals method lacks null checks for the buildid field.",
      "category": "bug",
      "subcategory": "worker-options",
      "apis": [],
      "components": [
        "WorkerOptions",
        "equals-method",
        "builder-pattern"
      ],
      "concepts": [
        "null-safety",
        "equals-contract",
        "object-comparison",
        "builder"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably compare WorkerOptions objects when using default values, causing test assertions and equality checks to fail unexpectedly.",
      "rootCause": "The equals method compares the buildid field without checking for null, violating Java's equals contract that requires handling null values gracefully.",
      "proposedFix": "Add null checks in the equals method for the buildid field before performing the comparison.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed by adding proper null checks to the equals method implementation in WorkerOptions.",
      "related": [],
      "keyQuote": "WorkerOptions equals is failing with NullPointer if buildid is not explicitly set.",
      "number": 1854,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:19.302Z"
    },
    {
      "summary": "Discussion about whether the Java SDK implements exponential backoff for server polling requests. The author questions whether polling uses fixed intervals rather than exponential backoff, which could impact server load during high-traffic scenarios. A commenter clarifies that exponential backoff is already implemented via GrpcSyncRetryer and BackoffThrottler.",
      "category": "question",
      "subcategory": "server-communication",
      "apis": [],
      "components": [
        "GrpcSyncRetryer",
        "BackoffThrottler",
        "GrpcDeadlineInterceptor"
      ],
      "concepts": [
        "exponential-backoff",
        "retry-logic",
        "polling",
        "server-load",
        "rate-limiting"
      ],
      "severity": "low",
      "userImpact": "Clarifies that exponential backoff is already implemented for server requests, preventing potential misunderstandings about client behavior under server load.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "The issue was based on a misunderstanding of the code. The Java SDK already implements exponential backoff through GrpcSyncRetryer and BackoffThrottler as confirmed by the maintainer.",
      "related": [
        1258,
        947
      ],
      "keyQuote": "The Java SDK does do exponential backoff if you look at GrpcSyncRetier and the BackoffThrottler you will see it is exponential.",
      "number": 1850,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:18.010Z"
    },
    {
      "summary": "Request to expose an async API for starting workflows that integrates with Kotlin coroutines and dispatchers, allowing non-blocking workflow invocation from suspend functions.",
      "category": "feature",
      "subcategory": "kotlin-coroutines",
      "apis": [
        "WorkflowClient.newWorkflowStub",
        "WorkflowOptions"
      ],
      "components": [
        "workflow-client",
        "kotlin-integration"
      ],
      "concepts": [
        "async-api",
        "coroutines",
        "dispatchers",
        "non-blocking",
        "kotlin-integration"
      ],
      "severity": "medium",
      "userImpact": "Kotlin developers cannot currently start workflows from coroutines without blocking, limiting async adoption in Kotlin projects.",
      "rootCause": null,
      "proposedFix": "Expose async-friendly workflow start API that integrates with Kotlin coroutine dispatchers and suspend functions.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed in favor of issue #1845, which addresses the same async workflow start capability.",
      "related": [
        1845
      ],
      "keyQuote": "To be able to start workflows from a Kotlin coroutine(using a dispatcher with a thread pool)",
      "number": 1849,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:03.447Z"
    },
    {
      "summary": "Typed search attributes in Java SDK have incomplete integration with Schedule Workflows. The ScheduleOptions still uses the deprecated search attribute approach, and there are inconsistencies in how the SDK handles deprecated vs. typed search attributes when creating schedules, as well as panic conditions when describing schedules with incomplete metadata.",
      "category": "bug",
      "subcategory": "search-attributes",
      "apis": [
        "ScheduleOptions",
        "Schedule",
        "SearchAttribute"
      ],
      "components": [
        "schedule-workflow",
        "search-attributes",
        "schedule-options",
        "typed-search-attributes"
      ],
      "concepts": [
        "type-safety",
        "api-consistency",
        "deprecation",
        "metadata",
        "backward-compatibility",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users experience inconsistent behavior and potential runtime panics when using typed search attributes with Schedule Workflows, and deprecated approach inconsistently interacts with the new typed API.",
      "rootCause": "The typed search attributes PR was completed before Schedule Workflows feature was merged, resulting in incomplete integration. ScheduleOptions was missed, and the schedule workflow action doesn't properly handle the transition from deprecated to typed search attributes.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by updating ScheduleOptions to use typed search attributes and fixing the schedule workflow action to properly handle both deprecated and typed approaches with appropriate validation and error messaging.",
      "related": [],
      "keyQuote": "Java SDK will panic if the search attributes does not type information in their metadata. Java always writes this, but other SDKs like Go did not",
      "number": 1847,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:02.905Z"
    },
    {
      "summary": "Enhancement request to support alternative concurrency models in the Java SDK: Kotlin coroutines (suspend functions) for workflows/activities, and virtual threads for Java 21+. Community is interested in first-class coroutine support to improve context propagation and ease of use in Kotlin.",
      "category": "feature",
      "subcategory": "concurrency-models",
      "apis": [],
      "components": [
        "workflow-execution",
        "activity-execution",
        "concurrency-framework"
      ],
      "concepts": [
        "coroutines",
        "virtual-threads",
        "concurrency",
        "kotlin-integration",
        "context-propagation",
        "async-primitives"
      ],
      "severity": "medium",
      "userImpact": "Kotlin developers struggle with context propagation and cancellation when using the SDK, making Kotlin support unnecessarily complex and hindering adoption.",
      "rootCause": null,
      "proposedFix": "Abstract workflow concurrency implementation, add Kotlin coroutine support as suspend functions, create Java 21+ virtual-threads project for virtual thread-based concurrency.",
      "workaround": "Currently must manually bridge workflow/activity context thread locals into coroutine context for proper context propagation in Kotlin.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The problem with using Temporal Java SDK in Kotlin is we have to bridge the workflow/activity context thread locals into a coroutine context for proper context propagation and cancellation",
      "number": 1845,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:49:05.776Z"
    },
    {
      "summary": "The okhttp library (4.10.0) has a transitive dependency on okio-jvm-3.0.0 which contains CVE-2023-3635, a vulnerability in GzipSource that can cause denial of service when handling malformed gzip buffers. The issue requires upgrading okio-jvm to 3.4.0 or okhttp to 4.11.0.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "okhttp",
        "okio",
        "remote-data-encoder"
      ],
      "concepts": [
        "vulnerability",
        "denial-of-service",
        "gzip",
        "malformed-input",
        "transitive-dependency",
        "security"
      ],
      "severity": "high",
      "userImpact": "Applications using the Java SDK could experience denial of service if they process crafted malformed GZIP archives through okhttp.",
      "rootCause": "GzipSource does not handle exceptions that might be raised when parsing a malformed gzip buffer, leading to potential DoS.",
      "proposedFix": "Upgrade okio-jvm to version 3.4.0 or okhttp to version 4.11.0 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Dependency upgraded to address the vulnerability; confirmed fixed in master branch.",
      "related": [],
      "keyQuote": "GzipSource does not handle an exception that might be raised when parsing a malformed gzip buffer. This may lead to denial of service",
      "number": 1842,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:49.252Z"
    },
    {
      "summary": "Spring Boot 3 native image compilation fails due to missing `-parameters` compiler argument in Temporal Spring Boot autoconfigure classes. Constructor binding requires this flag for native image support.",
      "category": "feature",
      "subcategory": "spring-boot-native-image",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "configuration-properties",
        "native-image"
      ],
      "concepts": [
        "native-image",
        "spring-boot-3",
        "compiler-arguments",
        "constructor-binding",
        "reflection"
      ],
      "severity": "high",
      "userImpact": "Users cannot build Spring Boot 3 native images with Temporal SDK until the -parameters compiler flag is added.",
      "rootCause": "WorkerProperties and related configuration classes lack the -parameters compiler argument needed for Spring Boot's constructor binding reflection in native images.",
      "proposedFix": "Add `tasks.withType<JavaCompile> { options.compilerArgs = options.compilerArgs + \"-parameters\" }` to temporal-spring-boot-autoconfigure-alpha/build.gradle",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by PR #1877 which likely added the -parameters compiler argument to the build configuration.",
      "related": [
        1877
      ],
      "keyQuote": "Constructor binding in a native image requires compilation with -parameters but the following classes were compiled without it",
      "number": 1840,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:47.275Z"
    },
    {
      "summary": "Request to add a Spring Boot HealthIndicator to the temporal-spring-boot-autoconfigure-alpha library to expose Temporal SDK connection and worker health status through the /health actuator endpoint.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure-alpha",
        "health-indicator",
        "actuator-integration"
      ],
      "concepts": [
        "health-monitoring",
        "spring-boot-actuator",
        "connection-state",
        "worker-health",
        "observability",
        "application-state"
      ],
      "severity": "medium",
      "userImpact": "Users can monitor Temporal SDK health status through Spring Boot Actuator, enabling external monitoring tools to detect failures and trigger restarts.",
      "rootCause": null,
      "proposedFix": "Create a HealthIndicator and AutoConfiguration in temporal-spring-boot-autoconfigure-alpha library, using Spring's RabbitHealthIndicator and RabbitHealthContributorAutoConfiguration as reference implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "HealthIndicator allows external monitoring tools to check whether the application has entered a failed state and needs a restart.",
      "number": 1839,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:45.086Z"
    },
    {
      "summary": "Add logic to update task-level SDK name and version metadata when these values change on the workflow, keeping them in sync with the client-name and client-version gRPC headers.",
      "category": "feature",
      "subcategory": "metadata",
      "apis": [],
      "components": [
        "task-metadata",
        "workflow-worker",
        "gRPC-headers"
      ],
      "concepts": [
        "metadata-synchronization",
        "version-tracking",
        "task-lifecycle",
        "client-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users will have accurate and up-to-date SDK version information at the task level when SDK versions change during workflow execution.",
      "rootCause": null,
      "proposedFix": "Set task-level sdk-name and sdk-version to current values matching client-name and client-version gRPC headers when either value changes on the workflow",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to update task-level metadata when SDK name or version changes",
      "related": [
        321
      ],
      "keyQuote": "if either SDK name or SDK version changed on the workflow from what was last seen on some task, set it to the current values",
      "number": 1838,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:33.161Z"
    },
    {
      "summary": "Users must manually call `applicationContext.start()` to begin workers, which is non-idiomatic Spring Boot and causes confusion. The request is to use Spring Boot's `ApplicationReadyEvent` to automatically start workers, eliminating boilerplate code in tests and main methods.",
      "category": "other",
      "subcategory": "spring-integration",
      "apis": [
        "WorkerFactory"
      ],
      "components": [
        "spring-boot-starter",
        "worker-factory",
        "application-lifecycle"
      ],
      "concepts": [
        "spring-boot-integration",
        "lifecycle-management",
        "idiomatic-framework-usage",
        "test-boilerplate",
        "application-startup",
        "event-driven"
      ],
      "severity": "medium",
      "userImpact": "Users must add non-idiomatic boilerplate code to start workers manually, causing confusion and inconsistency with standard Spring Boot patterns.",
      "rootCause": "The current implementation requires explicit `start()` calls deferred until an application event, rather than leveraging Spring Boot's standard lifecycle events.",
      "proposedFix": "Use Spring Boot's `ApplicationReadyEvent` to automatically start workers after the application is ready, eliminating the need for manual `start()` calls and test boilerplate.",
      "workaround": "Users can add `@Autowired ConfigurableApplicationContext applicationContext` and call `applicationContext.start()` in `@BeforeEach` setup methods.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented using Spring Boot's standard lifecycle events instead of requiring manual `start()` calls, making the integration idiomatic and eliminating test boilerplate.",
      "related": [
        1614,
        1648,
        1839
      ],
      "keyQuote": "Using `ApplicationReadyEvent` removes the need for every test to contain the boilerplate of manual `start()` invocation.",
      "number": 1837,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:31.399Z"
    },
    {
      "summary": "User requests support for using Temporal annotations (@ActivityInterface, @WorkflowInterface, @WorkflowMethod) as meta annotations in custom annotations, enabling declarative composition of annotation metadata similar to Spring Framework patterns.",
      "category": "feature",
      "subcategory": "annotation-processing",
      "apis": [
        "ActivityInterface",
        "WorkflowInterface",
        "WorkflowMethod"
      ],
      "components": [
        "annotation-processor",
        "activity-interface",
        "workflow-interface"
      ],
      "concepts": [
        "meta-annotation",
        "annotation-composition",
        "spring-integration",
        "reflection",
        "declarative-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot create custom annotations that wrap Temporal annotations, limiting flexibility in Spring Boot integration and requiring workarounds like Byte Buddy runtime modification.",
      "rootCause": "The SDK does not recursively scan for annotations using AnnotationUtils.findAnnotation() pattern; it only reads annotations directly present on the class.",
      "proposedFix": "Modify the SDK to read annotations using Spring's AnnotationUtils.findAnnotation() or equivalent recursive annotation scanning mechanism to support meta annotations.",
      "workaround": "Use Byte Buddy to modify activity interfaces at runtime and add Temporal annotations where custom annotations are present.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add support for using Temporal annotations (like @WorkflowInterface, @ActivityInterface, @WorkflowMethod) as meta annotations.",
      "number": 1832,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:32.419Z"
    },
    {
      "summary": "WorkflowReplayer throws a cryptic exception when LocalActivityOptions are misconfigured, instead of providing a clear error message like it does for regular ActivityOptions. The underlying IllegalArgumentException from validateAndBuildWithDefaults is being swallowed by exception handling in CancellationScopeImpl.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "WorkflowReplayer",
        "LocalActivityOptions",
        "TestWorkflowEnvironment"
      ],
      "components": [
        "workflow-replayer",
        "local-activity-options",
        "cancellation-scope"
      ],
      "concepts": [
        "error-handling",
        "exception-propagation",
        "test-framework",
        "activity-configuration",
        "debugging"
      ],
      "severity": "medium",
      "userImpact": "Users debugging misconfigured LocalActivityOptions receive an unclear error message about query failures instead of a helpful message, making troubleshooting difficult.",
      "rootCause": "The IllegalArgumentException thrown by validateAndBuildWithDefaults in LocalActivityOptions is being swallowed by exception handling in CancellationScopeImpl.finally block, resulting in a generic RuntimeException about query failure.",
      "proposedFix": "Ensure that IllegalArgumentException from LocalActivityOptions validation is properly propagated to the user, similar to how it's handled for regular ActivityOptions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Both StartToCloseTimeout and ScheduleToCloseTimeout aren't specified for ImportInitialization activity. Please set at least one of the above through the ActivityStub or WorkflowImplementationOptions.",
      "number": 1830,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:15.557Z"
    },
    {
      "summary": "Environment variables containing certificate and private key strings cannot be properly loaded by ServiceStubOptionsTemplate because they use escaped newline sequences (\"\\n\") instead of actual linebreaks. The template needs to handle conversion of escaped newlines to actual newlines when loading credentials from environment variables.",
      "category": "bug",
      "subcategory": "mtls-configuration",
      "apis": [],
      "components": [
        "ServiceStubOptionsTemplate",
        "ServiceStubsAutoConfiguration",
        "spring-boot-autoconfigure"
      ],
      "concepts": [
        "certificate-loading",
        "environment-variables",
        "mTLS",
        "string-escaping",
        "configuration",
        "credential-management"
      ],
      "severity": "medium",
      "userImpact": "Users storing Temporal Cloud certificates in environment variables cannot load them due to escaped newline characters, forcing them to either use YAML/properties files or implement custom workarounds.",
      "rootCause": "ServiceStubOptionsTemplate does not convert escaped newline sequences (\\\\n) to actual newlines (\\n) when loading certificate strings from environment variables, while YAML/properties files automatically perform this conversion.",
      "proposedFix": "Add logic to convert \"\\\\n\" to \"\\n\" in the cert string within ServiceStubOptionsTemplate class before certificate validation.",
      "workaround": "Replace ServiceStubsAutoConfiguration with a customized/extended class that performs the \\\\n to \\n conversion in mtlsProperties' cert and key before loading.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "the ServiceStubOptionsTemaplte fails to load cert/key saying it is not valid cert... It works perfectly with application.yaml/propeties because it converts \"\\n\" to linebreak",
      "number": 1825,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:18.142Z"
    },
    {
      "summary": "User requested to remove `final` modifiers from ProtobufPayloadConverter and ProtobufJsonPayloadConverter to allow direct extension and code reuse rather than extending AbstractProtobufPayloadConverter. The maintainer suggested using delegation/composition instead of inheritance.",
      "category": "feature",
      "subcategory": "payload-conversion",
      "apis": [],
      "components": [
        "ProtobufPayloadConverter",
        "ProtobufJsonPayloadConverter",
        "AbstractProtobufPayloadConverter",
        "payload-converter"
      ],
      "concepts": [
        "inheritance",
        "extensibility",
        "payload-serialization",
        "protobuf",
        "converter-pattern",
        "code-reuse"
      ],
      "severity": "low",
      "userImpact": "Users wanting to create custom protobuf payload converters are forced to duplicate code from base implementations instead of extending them directly.",
      "rootCause": "ProtobufPayloadConverter and ProtobufJsonPayloadConverter are marked as final, preventing direct extension.",
      "proposedFix": null,
      "workaround": "Users can create a new payload converter and delegate to the desired default converter instead of using inheritance.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer recommended using delegation pattern (composition) instead of inheritance, and user agreed this approach is acceptable.",
      "related": [],
      "keyQuote": "I think it may be best if you just make a new payload converter and delegate to the one you want instead of using inheritance.",
      "number": 1824,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:13.247Z"
    },
    {
      "summary": "Feature request to add a configuration flag to disable Temporal bean instantiation in Spring Boot auto-configuration when Temporal is not used in certain service environments. Currently requires setting connection to 'local' to prevent errors.",
      "category": "feature",
      "subcategory": "spring-boot-auto-configure",
      "apis": [],
      "components": [
        "spring-boot-auto-configure-alpha",
        "ServiceStubsAutoConfiguration",
        "RootNamespaceAutoConfiguration",
        "client-bean"
      ],
      "concepts": [
        "auto-configuration",
        "conditional-bean-creation",
        "spring-boot",
        "dependency-management",
        "environment-specific-config"
      ],
      "severity": "low",
      "userImpact": "Users deploying to environments without Temporal need a clean way to disable Temporal beans instead of using workarounds like intentional connection failures.",
      "rootCause": "Spring auto-configuration always attempts to instantiate Temporal beans if the dependency is present, even when not needed in certain environments.",
      "proposedFix": "Add an 'enabled' feature flag to conditionally create temporal spring beans, making the auto-configuration opt-in.",
      "workaround": "Set connection type to 'local' to intentionally fail and prevent service crash.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed as Spring provides built-in mechanisms to disable specific auto-configurations, making a separate flag unnecessary.",
      "related": [],
      "keyQuote": "Spring provides built in way to disable auto configuration",
      "number": 1823,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:59.951Z"
    },
    {
      "summary": "ScheduleClient and ScheduleHandle throw exceptions that are not subclasses of TemporalException, violating the SDK's exception hierarchy contract where all SDK exceptions should extend TemporalException.",
      "category": "bug",
      "subcategory": "exception-handling",
      "apis": [
        "ScheduleClient",
        "ScheduleHandle"
      ],
      "components": [
        "schedule-client",
        "schedule-handle",
        "exception-handling"
      ],
      "concepts": [
        "exception-hierarchy",
        "API-contract",
        "error-consistency",
        "type-safety"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably catch and handle all SDK exceptions uniformly, breaking the expected exception hierarchy contract.",
      "rootCause": "ScheduleClient and ScheduleHandle implementations throw exceptions that do not inherit from TemporalException",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "All exceptions thrown from the SDK should be subclasses of TemporalException",
      "number": 1820,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:56.199Z"
    },
    {
      "summary": "The RootScheduleClientInvoker.createSchedule method swallows exceptions that don't match ScheduleAlreadyRunningException, instead of rethrowing them. The catch clause needs to be more specific to only handle the intended exception type.",
      "category": "bug",
      "subcategory": "schedule-client",
      "apis": [
        "createSchedule"
      ],
      "components": [
        "RootScheduleClientInvoker",
        "schedule-client",
        "error-handling"
      ],
      "concepts": [
        "exception-handling",
        "error-swallowing",
        "catch-clause",
        "schedule-operations"
      ],
      "severity": "high",
      "userImpact": "Users cannot see real errors that occur during schedule creation, making debugging and error recovery difficult.",
      "rootCause": "The catch clause in RootScheduleClientInvoker.createSchedule is too broad and catches all exceptions instead of only the intended ScheduleAlreadyRunningException.",
      "proposedFix": "Change the catch clause to only catch ScheduleAlreadyRunningException and rethrow other exceptions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Catch clause was made specific to ScheduleAlreadyRunningException and other exceptions are now rethrown.",
      "related": [
        1776
      ],
      "keyQuote": "the RootScheduleClientInvoker.createSchedule code will swallow all exceptions that don't satisfy the ScheduleAlreadyRunningException conditions",
      "number": 1817,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:48:00.372Z"
    },
    {
      "summary": "When setting target to 'local' in Spring Boot configuration, ServiceStubOptionsTemplate is not registered, preventing metricsScope and other options from being applied to local service stubs.",
      "category": "bug",
      "subcategory": "spring-boot-autoconfigure",
      "apis": [
        "WorkflowServiceStubs.newLocalServiceStubs"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "ServiceStubsTemplate",
        "ServiceStubOptionsTemplate"
      ],
      "concepts": [
        "local-development",
        "spring-boot-integration",
        "configuration",
        "metrics",
        "service-stubs"
      ],
      "severity": "medium",
      "userImpact": "Users developing locally with Spring Boot cannot configure metrics and other service stub options when using the 'local' target setting.",
      "rootCause": "ServiceStubsTemplate creates local service stubs directly without applying ServiceStubOptionsTemplate, bypassing option registration logic.",
      "proposedFix": "Either modify local stub creation to apply ServiceStubOptionsTemplate or properly document that local configurations do not support options like metricsScope.",
      "workaround": null,
      "resolution": "unknown",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We should either change this to also use ServiceStubOptionsTemplate or document that when using local things like metricsScope would not be registered.",
      "number": 1815,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:45.723Z"
    },
    {
      "summary": "Request to add Spring Boot autowiring support for ScheduleClient in the temporal-spring-boot-starter-alpha to simplify migration from legacy cron workflows to Schedules.",
      "category": "feature",
      "subcategory": "spring-integration",
      "apis": [
        "ScheduleClient"
      ],
      "components": [
        "spring-boot-starter",
        "schedule-client",
        "dependency-injection"
      ],
      "concepts": [
        "spring-boot",
        "autowiring",
        "schedules",
        "migration",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users migrating from cron workflows to Schedules can use Spring Boot autowiring to simplify integration and reduce boilerplate code.",
      "rootCause": null,
      "proposedFix": "Add ScheduleClient autowiring capability to temporal-spring-boot-starter-alpha",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "ScheduleClient autowiring support was implemented in the spring-boot-starter",
      "related": [],
      "keyQuote": "Autowire ScheduleClient using the spring-boot-starter",
      "number": 1812,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:43.403Z"
    },
    {
      "summary": "SpringBoot autoconfig should annotate the default WorkflowClient bean with @Primary to allow autowiring without requiring @Qualifier when custom WorkflowClient beans are defined for different namespaces.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkflowClient",
        "WorkflowServiceStubs",
        "WorkflowClientOptions"
      ],
      "components": [
        "spring-boot-autoconfig",
        "bean-registration",
        "dependency-injection"
      ],
      "concepts": [
        "spring-beans",
        "primary-bean",
        "autowiring",
        "qualifier",
        "multiple-clients",
        "namespace-isolation"
      ],
      "severity": "low",
      "userImpact": "Users creating additional WorkflowClient beans for different namespaces must use @Qualifier annotations everywhere, reducing code convenience.",
      "rootCause": "The default WorkflowClient bean is not annotated with @Primary, making qualifier resolution ambiguous when multiple WorkflowClient beans exist.",
      "proposedFix": "Annotate the default WorkflowClient bean with @Primary annotation in the SpringBoot autoconfig to make it the default autowiring target.",
      "workaround": "Use property name matching: @Autowired WorkflowClient temporalWorkflowClient; (property name matches bean name)",
      "resolution": "fixed",
      "resolutionDetails": "The @Primary annotation was added to the default WorkflowClient bean in SpringBoot autoconfig.",
      "related": [
        1799
      ],
      "keyQuote": "annotate the default WorkflowClient bean with @Primary in order to allow autowiring the default one without having to use Qualifier",
      "number": 1811,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:43.302Z"
    },
    {
      "summary": "The DataConverter interface is missing default implementations for `failureToException` and `exceptionToFailure` methods, breaking API compatibility when these methods are added to the interface.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "DataConverter"
      ],
      "components": [
        "data-converter",
        "serialization"
      ],
      "concepts": [
        "api-compatibility",
        "interface-design",
        "backward-compatibility",
        "exception-handling",
        "type-conversion"
      ],
      "severity": "high",
      "userImpact": "Users implementing the DataConverter interface experience API breaks when new methods are added without default implementations.",
      "rootCause": "DataConverter interface methods added without default implementations, violating API stability contract.",
      "proposedFix": "Add default implementations for `failureToException` and `exceptionToFailure` methods in the DataConverter interface.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Default implementations were added to maintain API compatibility (see PR #1645).",
      "related": [
        1645
      ],
      "keyQuote": "A default implementation for `failureToException` and `exceptionToFailure` exist since adding these without one breaks the API of `DataConverter`",
      "number": 1808,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:28.112Z"
    },
    {
      "summary": "Request to add local Temporal CLI server support for testing in Java SDK, similar to TypeScript's TestWorkflowEnvironment.createLocal(). This would enable testing of features not available in the test environment, such as listWorkflowExecution.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-environment",
        "server",
        "cli"
      ],
      "concepts": [
        "local-testing",
        "test-server",
        "workflow-execution",
        "feature-parity",
        "sdk-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Java developers cannot easily test advanced features like listWorkflowExecution locally without setting up a full Temporal server.",
      "rootCause": null,
      "proposedFix": "Implement a TestWorkflowEnvironment.createLocal() method or similar API to start a Temporal CLI server for testing purposes.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Other SDKs allows starting a full Temporal server locally for testing purpose. Eg typescript: `TestWorkflowEnvironment.createLocal()`",
      "number": 1804,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:31.301Z"
    },
    {
      "summary": "Guava dependency 31.1-jre contains a security vulnerability (CVE-2023-2976) with CVSS score 7.1 that allows unauthorized file access via the default Java temporary directory. The fix involves upgrading to version 32.0.1 or later.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "build-configuration",
        "gradle"
      ],
      "concepts": [
        "security-vulnerability",
        "file-access",
        "temporary-files",
        "dependency-upgrade",
        "guava-library"
      ],
      "severity": "high",
      "userImpact": "Users may be exposed to unauthorized file access if they use the Temporal Java SDK with the vulnerable Guava version.",
      "rootCause": "FileBackedOutputStream in Google Guava versions 1.0-31.1 uses Java's default temporary directory which is world-readable on Unix systems, allowing other users/apps to access created files.",
      "proposedFix": "Upgrade Guava from 31.1-jre to 32.0.1-android (32.0.0 breaks Windows functionality).",
      "workaround": "Users can manually upgrade their own Guava dependency to a newer version independently of the SDK update.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by upgrading Guava dependency to a patched version that fixes the insecure temporary file handling.",
      "related": [],
      "keyQuote": "Generally we don't update dependencies if the issue doesn't affect the SDK to avoid forcing users to upgrade...given the small diff between 31.1 and 32.0.1 it is probably fine to upgrade to silence vulnerability tools.",
      "number": 1803,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:31.630Z"
    },
    {
      "summary": "ConcurrentModificationException occurs when calling Workflow.upsertSearchAttributes in tests with concurrent workflows due to non-thread-safe HashMap in TestVisibilityStoreImpl. The fix requires changing to ConcurrentHashMap to handle child workflow concurrency.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "upsertTypedSearchAttributes"
      ],
      "components": [
        "test-visibility-store",
        "test-workflow-mutable-state",
        "test-server"
      ],
      "concepts": [
        "concurrency",
        "thread-safety",
        "search-attributes",
        "child-workflows",
        "test-server"
      ],
      "severity": "high",
      "userImpact": "Tests using concurrent workflows fail when calling upsertSearchAttributes due to ConcurrentModificationException in the test server implementation.",
      "rootCause": "TestVisibilityStoreImpl uses a non-thread-safe HashMap at line 58 which can be accessed concurrently by child workflows, causing ConcurrentModificationException in the compute operation.",
      "proposedFix": "Replace the non-thread-safe HashMap with ConcurrentHashMap in TestVisibilityStoreImpl to handle concurrent access from child workflows.",
      "workaround": "Comment out the code calling upsertSearchAttributes in tests.",
      "resolution": "fixed",
      "resolutionDetails": "Changed HashMap to ConcurrentHashMap in TestVisibilityStoreImpl to safely handle concurrent child workflow execution.",
      "related": [
        1067
      ],
      "keyQuote": "the map at TestVisibilityStoreImpl.java#L58 should be concurrent map because technically child workflows can run concurrently too",
      "number": 1802,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:16.705Z"
    },
    {
      "summary": "Request to add Spring Boot integration support for creating multiple Temporal clients and workers with different configurations, including support for different namespaces in the same application.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-integration",
        "client-factory",
        "worker-factory"
      ],
      "concepts": [
        "namespace-isolation",
        "multi-tenant",
        "configuration-management",
        "client-options",
        "spring-boot"
      ],
      "severity": "medium",
      "userImpact": "Spring Boot developers cannot currently create multiple Temporal clients or workers with different namespaces or options within the same application.",
      "rootCause": null,
      "proposedFix": "Extend Spring Boot integration to support configuration of multiple client and worker instances with different namespace and option settings.",
      "workaround": "Create separate Spring Boot applications per namespace, but this doesn't support cross-namespace calls or different client options for different workers in the same namespace.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add support in springboot integration to create clients and workers with different options including different namespaces",
      "number": 1799,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:14.273Z"
    },
    {
      "number": 1797,
      "repository": "temporalio-sdk-java",
      "summary": "Request to expose the started time of an activity task in the activity info. This would allow activities to access timing information about when their execution began.",
      "category": "feature",
      "subcategory": "activity-info",
      "apis": [
        "ActivityInfo"
      ],
      "components": [
        "activity-executor",
        "activity-info"
      ],
      "concepts": [
        "timing",
        "metadata",
        "activity-lifecycle",
        "started-time",
        "execution-context"
      ],
      "severity": "low",
      "userImpact": "Users need to access activity task start timing information to track execution metrics and timing behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Expose activity task started time in activity info.",
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:16.632Z"
    },
    {
      "summary": "Feature request for a generic workflow failure handler via interceptor to detect when a workflow is about to fail and invoke an activity (e.g., send email, post to Kafka, alert). The request asks for a utility method to determine if an exception will fail the workflow based on WorkflowImplementationOptions.failWorkflowExceptionTypes.",
      "category": "feature",
      "subcategory": "interceptor-workflow-failure",
      "apis": [
        "WorkflowInboundCallsInterceptor",
        "WorkflowImplementationOptions"
      ],
      "components": [
        "interceptor",
        "workflow-execution",
        "exception-handling"
      ],
      "concepts": [
        "failure-detection",
        "error-handling",
        "determinism",
        "workflow-lifecycle",
        "exception-types"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably implement generic failure handlers in workflows without duplicating logic or risking non-deterministic behavior.",
      "rootCause": "Calling an activity conditional on exception matching failWorkflowExceptionTypes would be non-deterministic if failWorkflowExceptionTypes changes during workflow replay.",
      "proposedFix": "Implement WorkflowInboundCallsInterceptor.execute with try/catch and a static utility method to check if an exception will fail the workflow.",
      "workaround": "Users can write their own interceptor or base worker class and inject failWorkflowExceptionTypes, but must carefully manage changes to it during workflow execution.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed as not planned due to determinism concerns. A utility encouraging this pattern would risk non-deterministic behavior if failWorkflowExceptionTypes changes during workflow replay.",
      "related": [],
      "keyQuote": "Since calling an activity conditional on an exception matching failWorkflowExceptionTypes is not deterministic I don't think we would want to add any feature that encourages this in the SDK.",
      "number": 1793,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:02.566Z"
    },
    {
      "summary": "Add support for build ID versioning APIs (UpdateWorkerBuildIdCompatibility, GetWorkerBuildIdCompatibility, GetWorkerTaskReachability) to the test server to match the new worker versioning feature added to the SDK.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [
        "UpdateWorkerBuildIdCompatibility",
        "GetWorkerBuildIdCompatibility",
        "GetWorkerTaskReachability"
      ],
      "components": [
        "test-server",
        "workflow-service",
        "worker-versioning"
      ],
      "concepts": [
        "build-id-versioning",
        "worker-compatibility",
        "api-implementation",
        "test-infrastructure"
      ],
      "severity": "low",
      "userImpact": "Test server lacks build ID versioning support, limiting ability to test worker versioning scenarios locally.",
      "rootCause": null,
      "proposedFix": "Implement the three workflow service RPCs for build ID compatibility and worker task reachability on the test server.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "The build ID versioning APIs were discontinued and are no longer being maintained, so implementation was deemed unnecessary.",
      "related": [],
      "keyQuote": "Closing since we are no longer keeping these APIs",
      "number": 1788,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:47:02.308Z"
    },
    {
      "summary": "User requests a clearer exception message for WorkflowExecutionAlreadyStarted, which currently only contains workflow details but lacks explicit explanation that the workflow has already started. The request is to provide a more descriptive message that clarifies the condition while maintaining existing workflow detail information.",
      "category": "other",
      "subcategory": "exception-messages",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "client",
        "exception-handling",
        "workflow-execution"
      ],
      "concepts": [
        "exception-message",
        "error-clarity",
        "workflow-lifecycle",
        "duplicate-execution",
        "user-experience"
      ],
      "severity": "low",
      "userImpact": "Users receive unclear exception messages when attempting to start a workflow that already exists, making it harder to diagnose and handle the error appropriately.",
      "rootCause": null,
      "proposedFix": "Include a clear message in the WorkflowExecutionAlreadyStarted exception explaining that a workflow with the given workflowId has already been started, in addition to the existing workflow details.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "The maintainer determined that changing the exception message would be a backwards incompatible change, and users should deduce the meaning from the exception type itself rather than the message content.",
      "related": [],
      "keyQuote": "the intention is users deduce the message from the exception type and changing the message would be a backwards incompatible change",
      "number": 1785,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:59.650Z"
    },
    {
      "summary": "User unable to run Temporal tests in Docker containers on M1/M2 Macs because the test server only provides amd64 binaries for Linux. Requests linux_arm64 builds to enable ARM64 container testing.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowEnvironment.start_time_skipping",
        "WorkflowEnvironment.start_local"
      ],
      "components": [
        "test-server",
        "docker",
        "arm64-support"
      ],
      "concepts": [
        "cross-platform",
        "container-testing",
        "architecture-compatibility",
        "binary-distribution",
        "test-infrastructure"
      ],
      "severity": "medium",
      "userImpact": "Developers using M1/M2 Macs cannot run Temporal tests in ARM64 Docker containers, limiting their ability to test in production-like environments.",
      "rootCause": "Test server distribution only provides amd64 binaries for Linux, causing incompatibility when running in ARM64 containers.",
      "proposedFix": "Provide linux_arm64 builds of the test server to enable native execution in ARM64 containers.",
      "workaround": "Use WorkflowEnvironment.start_local() instead of start_time_skipping(), or skip tests in Docker.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #1407. User found workaround using start_local() and noted the original problem was addressed elsewhere.",
      "related": [
        1407
      ],
      "keyQuote": "amd64 test server is not going to run within arm64... I am unable to run temporal tests in docker on M1/M2 Macs",
      "number": 1783,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:47.864Z"
    },
    {
      "summary": "Enhancement request to validate protocol message types during workflow replay for more accurate determinism coverage. Currently only ProtocolMessageCommand and Event are checked, but the generated protocol message should also be validated.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "replay-engine",
        "protocol-handler",
        "determinism-checker"
      ],
      "concepts": [
        "replay",
        "determinism",
        "protocol-messages",
        "validation",
        "coverage",
        "event-sourcing"
      ],
      "severity": "medium",
      "userImpact": "Users working with workflow replay and protocol messages will have improved determinism validation coverage.",
      "rootCause": null,
      "proposedFix": "Add validation of the protocol message generated during replay in addition to existing ProtocolMessageCommand and Event checks.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "For the most accurate coverage the protocol message generated should also be checked.",
      "number": 1781,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:47.173Z"
    },
    {
      "summary": "Activity timeouts are only detectable when heartbeats reach the Temporal server, but heartbeat throttling delays detection. The request proposes having the heartbeat method throw a timeout exception when start-to-close or schedule-to-close timeouts are violated, enabling local timeout detection.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "heartbeat"
      ],
      "components": [
        "activity-context",
        "activity-executor",
        "heartbeat-mechanism"
      ],
      "concepts": [
        "timeout-detection",
        "heartbeat-throttling",
        "activity-completion",
        "local-detection",
        "schedule-to-close",
        "start-to-close"
      ],
      "severity": "medium",
      "userImpact": "Activities continue executing unnecessarily when timeouts are reached but not detected locally, wasting resources and delaying failure handling.",
      "rootCause": "Heartbeat throttling prevents or delays heartbeats from reaching the server, preventing timeout detection in activity code until the server rejects the result.",
      "proposedFix": "Have the heartbeat method throw a subclass of ActivityCompletionException when start-to-close or schedule-to-close timeouts are violated, similar to how the Go SDK sets context deadlines.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Activity timeouts are only detectable by activity code when a heartbeat attempt reaches the Temporal server. Heartbeat throttling can significantly delay timeout detection because it prevents or delays some heartbeats from reaching the server.",
      "number": 1770,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:46.586Z"
    },
    {
      "summary": "Add support for speculative workflow tasks for Update in the Test Server when no command events were sent, no commands are in the response, or only rejected updates are present.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "Update"
      ],
      "components": [
        "test-server",
        "workflow-task-handler",
        "update-handler"
      ],
      "concepts": [
        "speculative-execution",
        "workflow-tasks",
        "updates",
        "command-events",
        "test-framework"
      ],
      "severity": "medium",
      "userImpact": "Enables more comprehensive testing of Update functionality under specific conditions in the Test Server.",
      "rootCause": null,
      "proposedFix": "Implement speculative workflow task support when: (1) no command events were sent, (2) response has no commands, or (3) response contains only rejected updates",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support speculative workflow tasks for Update under the specified conditions",
      "related": [],
      "keyQuote": "Add support for speculative workflow tasks for Update under the appropriate conditions: No command events were sent in the WFT",
      "number": 1769,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:33.275Z"
    },
    {
      "summary": "Spring Boot AutoConfigure version 2.7.9 contains CVE-2023-20883, a high-severity (7.5 CVSS) denial-of-service vulnerability affecting Spring MVC with reverse proxy caches. The issue requires upgrading to version 2.7.12 or later.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "spring-mvc",
        "build-dependencies"
      ],
      "concepts": [
        "denial-of-service",
        "security-vulnerability",
        "cvss-score",
        "reverse-proxy",
        "caching",
        "dependency-upgrade",
        "spring-framework"
      ],
      "severity": "high",
      "userImpact": "Users running Spring Boot applications with Spring MVC behind reverse proxy caches are vulnerable to denial-of-service attacks.",
      "rootCause": "Spring Boot versions 2.7.0-2.7.11 have potential for DoS attacks when Spring MVC is used with reverse proxy caching.",
      "proposedFix": "Upgrade spring-boot-autoconfigure to version 2.7.12 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically remediated through dependency upgrade.",
      "related": [],
      "keyQuote": "Can you pls fix this by upgrading spring boot as it is flagged by Snyk as a High risk issue?",
      "number": 1768,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:31.388Z"
    },
    {
      "summary": "The Java test server should log when task failures occur due to invalid commands (e.g., invalid search attributes) in TestWorkflowMutableStateImpl, rather than silently failing. Currently CommandVerifier.verifyCommand validates commands but doesn't log failures.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowMutableStateImpl",
        "CommandVerifier",
        "test-service"
      ],
      "concepts": [
        "logging",
        "command-validation",
        "task-failure",
        "error-reporting",
        "test-debugging"
      ],
      "severity": "low",
      "userImpact": "Test developers cannot see why their test server workflows are silently failing due to invalid commands, making debugging difficult.",
      "rootCause": "CommandVerifier validates commands and causes task failures, but no logging is performed to inform users of the validation error.",
      "proposedFix": "Add logging in TestWorkflowMutableStateImpl where CommandVerifier.verifyCommand is called to log when task failures occur from command validation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We should log (where it's called from `TestWorkflowMutableStateImpl`). This only applies to search attributes today, because that's the only thing we check command validity on.",
      "number": 1767,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:32.564Z"
    },
    {
      "summary": "User wants to register the same workflow interface multiple times with different names in the Java SDK, similar to Go SDK's pattern. They're using a shared base class for trace creation and error handling across multiple test workflows but can't register it multiple times.",
      "category": "feature",
      "subcategory": "worker-registration",
      "apis": [
        "Worker"
      ],
      "components": [
        "worker",
        "workflow-registration",
        "interface-binding"
      ],
      "concepts": [
        "workflow-type",
        "registration",
        "interface-abstraction",
        "testing-framework",
        "polymorphism",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users cannot reuse workflow interface implementations across multiple workflow types without creating separate workers or interfaces.",
      "rootCause": "Java SDK requires a unique interface per workflow type and doesn't support registering the same interface with different workflow names.",
      "proposedFix": "Add support for registering workflows by function/factory with configurable names via workflow options, similar to the Go SDK API.",
      "workaround": "Use dynamic workflows to switch implementations, or create separate workers for each workflow type.",
      "resolution": "wontfix",
      "resolutionDetails": "Design limitation: a workflow interface represents a unique workflow type. Each distinct workflow should have its own interface. Dynamic workflows offer an alternative solution.",
      "related": [],
      "keyQuote": "A workflow interface represents a workflow type, a worker can only have one implementation for each workflow type.",
      "number": 1763,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:17.110Z"
    },
    {
      "summary": "WorkflowLocal.set(null) causes subsequent get() calls to throw NullPointerException because the Optional wrapper cannot distinguish between unset state and null values. Additionally, withInitial callbacks are re-invoked on each get() rather than being cached.",
      "category": "bug",
      "subcategory": "workflow-local-state",
      "apis": [
        "WorkflowLocal"
      ],
      "components": [
        "DeterministicRunnerImpl",
        "RunnerLocalInternal",
        "WorkflowLocal"
      ],
      "concepts": [
        "null-handling",
        "state-management",
        "optional-semantics",
        "initialization",
        "local-variables",
        "determinism"
      ],
      "severity": "medium",
      "userImpact": "Users cannot set WorkflowLocal values to null, which breaks expected null-handling semantics and forces workarounds.",
      "rootCause": "Optional<T> return type in DeterministicRunnerImpl.getRunnerLocal() cannot differentiate between unset state and null values, and Optional.of(null) throws NullPointerException.",
      "proposedFix": "Replace Optional<T> return type with a custom state wrapper that can represent three states: unset, set-to-null, and set-to-value.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Optional<T> return type just doesn't work here, since this method needs to differentiate between two states: set has not been called, or set has been called, inclusive of set being called with null",
      "number": 1761,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:15.446Z"
    },
    {
      "summary": "Request to support Spring property placeholders in @WorkflowImpl and @ActivityImpl task queue names to enable dynamic queue configuration across different environments while maintaining worker auto-discovery.",
      "category": "feature",
      "subcategory": "configuration",
      "apis": [],
      "components": [
        "worker",
        "annotation-processor",
        "auto-configuration"
      ],
      "concepts": [
        "property-placeholder",
        "environment-specific-config",
        "worker-auto-discovery",
        "task-queue",
        "spring-integration",
        "dynamic-configuration"
      ],
      "severity": "low",
      "userImpact": "Users cannot use worker auto-discovery with dynamic task queue names across multiple environments without reverting to manual configuration.",
      "rootCause": null,
      "proposedFix": "Allow Spring property placeholders (e.g., ${task-queue.suffix:}) in the taskQueues property of @WorkflowImpl and @ActivityImpl annotations.",
      "workaround": "Disable auto-configuration and manually configure task queue names in Spring configuration with property placeholder values.",
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support property placeholders in annotation task queue names.",
      "related": [],
      "keyQuote": "Allow spring property placeholders to be used for the taskQueues property value",
      "number": 1759,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:46:12.814Z"
    },
    {
      "summary": "Feature request to make activity prefix and name generation pluggable rather than requiring repeated @ActivityInterface annotations. User references a TODO in the codebase and offers to contribute.",
      "category": "feature",
      "subcategory": "activity-naming",
      "apis": [
        "ActivityInterface"
      ],
      "components": [
        "activity-metadata",
        "annotation-processing",
        "POJOActivityMethodMetadata"
      ],
      "concepts": [
        "naming-convention",
        "code-reusability",
        "plugin-architecture",
        "annotation-driven-configuration",
        "extensibility",
        "boilerplate-reduction"
      ],
      "severity": "low",
      "userImpact": "Users must manually repeat namePrefix patterns across multiple @ActivityInterface annotations instead of centralizing the logic.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed in favor of issue #396 which already covers this feature request.",
      "related": [
        396
      ],
      "keyQuote": "I am repeating the same logic in my @ActivityInterface(namePrefix = \"...\") annotations. I would like to have this expressed in code, rather than a manually-applied pattern.",
      "number": 1751,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:55.870Z"
    },
    {
      "summary": "Request to pass the activity implementation object to ActivityInboundCallInterceptor's init method to enable reflection-based analysis of activity annotations. This would allow interceptors to apply behavior based on activity metadata without maintaining separate references.",
      "category": "feature",
      "subcategory": "activity-interceptor",
      "apis": [
        "ActivityInboundCallInterceptor"
      ],
      "components": [
        "activity-interceptor",
        "activity-executor",
        "reflection"
      ],
      "concepts": [
        "interceptor",
        "reflection",
        "annotations",
        "activity-metadata",
        "monitoring",
        "encapsulation"
      ],
      "severity": "medium",
      "userImpact": "Users can now implement sophisticated interceptor logic based on activity annotations without maintaining workarounds to access the activity implementation object.",
      "rootCause": null,
      "proposedFix": "Change the init(context) method signature to init(context, activity) to pass the activity implementation object to the interceptor.",
      "workaround": "Users currently maintain references to activity implementations using other patterns outside the interceptor framework.",
      "resolution": "fixed",
      "resolutionDetails": "The ActivityInboundCallInterceptor init method was updated to accept the activity implementation object as a parameter.",
      "related": [],
      "keyQuote": "To allow reflection to work properly a reference to the real object should be passed to the interceptor, not the proxy.",
      "number": 1750,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:54.615Z"
    },
    {
      "summary": "Feature request to run update validators in a limited workflow context where they have access to workflow info but cannot execute APIs that produce commands.",
      "category": "feature",
      "subcategory": "update-validator",
      "apis": [],
      "components": [
        "update-validator",
        "workflow-context",
        "command-execution"
      ],
      "concepts": [
        "workflow-context",
        "validator-execution",
        "api-restrictions",
        "command-production",
        "workflow-info"
      ],
      "severity": "medium",
      "userImpact": "Users need to validate updates with workflow context access while preventing unintended command production.",
      "rootCause": null,
      "proposedFix": "Run update validators with limited workflow context that provides access to workflow info but restricts APIs that produce commands",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Update validators now execute in a restricted workflow context with access to workflow information but limited API capabilities",
      "related": [],
      "keyQuote": "When running an update validator it should be run in a workflow context (ie have access to workflow info) but be limited in the actions it can take",
      "number": 1748,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:57.137Z"
    },
    {
      "summary": "Add support for SDK and capability metadata fields in the test server to align with API pull requests #259 and #263. Requires determining how TestServer should return sensible values coherent with the current SDK version.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "capability-metadata",
        "sdk-metadata"
      ],
      "concepts": [
        "metadata",
        "test-server",
        "capabilities",
        "schema",
        "version-coherence"
      ],
      "severity": "medium",
      "userImpact": "Users need test server to properly report SDK and capability metadata for testing purposes.",
      "rootCause": null,
      "proposedFix": "Implement support for API changes in PR #259 and #263, ensuring TestServer returns values coherent with current SDK version",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating implementation of SDK and capability metadata support was completed",
      "related": [
        259,
        263
      ],
      "keyQuote": "Should it return values that are coherent with the current version of sdk-java?",
      "number": 1746,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:36.390Z"
    },
    {
      "summary": "Feature request to add support for sending synchronous update requests to external workflows from the Java SDK client.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "client",
        "workflow-update",
        "external-workflow-communication"
      ],
      "concepts": [
        "synchronous-update",
        "external-workflow",
        "request-response",
        "workflow-communication"
      ],
      "severity": "medium",
      "userImpact": "Users cannot send synchronous update requests to external workflows from Java clients, limiting workflow coordination capabilities.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add support for sending synchronous update request to external workflows from the java client",
      "number": 1745,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:39.381Z"
    },
    {
      "summary": "Add ProtocolMessageCommand support to Java SDK when sending protocol messages during WorkflowTaskComplete. This enables proper non-determinism validation for workflow updates, which was previously difficult without this command.",
      "category": "feature",
      "subcategory": "protocol-messages",
      "apis": [
        "WorkflowTaskComplete"
      ],
      "components": [
        "workflow-task-handler",
        "protocol-message-processor",
        "command-builder"
      ],
      "concepts": [
        "protocol-messages",
        "non-determinism-validation",
        "workflow-updates",
        "determinism"
      ],
      "severity": "medium",
      "userImpact": "Users can now properly validate non-determinism in workflow updates through ProtocolMessageCommand support in the Java SDK.",
      "rootCause": "ProtocolMessageCommand was not being written when protocol messages were sent, making non-determinism validation for updates difficult to implement.",
      "proposedFix": "Write ProtocolMessageCommand along with protocol messages when WorkflowTaskComplete is sent.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of commit ee2f5d0974bb9fabae71f97f7b2bb4c67c098608",
      "related": [],
      "keyQuote": "When the SDK sends a protocol message on `WorkflowTaskComplete` also write a `ProtocolMessageCommand`",
      "number": 1744,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:39.449Z"
    },
    {
      "summary": "Feature request to add support for asynchronous update polling in the Java SDK, aligning with similar functionality implemented in the Go SDK.",
      "category": "feature",
      "subcategory": "async-updates",
      "apis": [
        "Update"
      ],
      "components": [
        "update-handler",
        "polling-mechanism",
        "async-executor"
      ],
      "concepts": [
        "asynchronous-operations",
        "polling",
        "updates",
        "non-blocking",
        "workflow-updates"
      ],
      "severity": "medium",
      "userImpact": "Users can now poll for workflow updates asynchronously without blocking worker threads.",
      "rootCause": null,
      "proposedFix": "Implement async update polling mechanism similar to the Go SDK implementation (referenced PR #1088).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to bring Java SDK to parity with Go SDK async update polling capabilities.",
      "related": [
        1088
      ],
      "keyQuote": "Adds support for async updates",
      "number": 1743,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:22.692Z"
    },
    {
      "summary": "Add support for workflow update protocol and messages to the Test Server, enabling testing of workflow update functionality.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "update-protocol",
        "workflow-update"
      ],
      "concepts": [
        "workflow-update",
        "protocol-implementation",
        "testing-infrastructure",
        "message-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently test workflow update functionality with the Test Server, limiting their ability to validate update implementations.",
      "rootCause": null,
      "proposedFix": "Implement protocol/messages and the update protocol to the test server",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Workflow update protocol support was implemented in the Test Server",
      "related": [],
      "keyQuote": "Implement protocol/messages and the update protocol to the test server",
      "number": 1742,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:24.251Z"
    },
    {
      "summary": "Add support for workflow updates to the Java SDK, allowing users to issue update requests to workflows, have them process the update while accessing and mutating internal state, and return responses to callers. This functionality will be available from external workflows and external code.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "workflow-engine",
        "update-handler",
        "external-api",
        "state-mutation"
      ],
      "concepts": [
        "workflow-state",
        "update-request",
        "response-handling",
        "external-access",
        "mutation"
      ],
      "severity": "high",
      "userImpact": "Users can now dynamically update running workflows and mutate their internal state without restarting them.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Core objectives completed through subtasks #1745, #1742, #1743, #1744, #1748, #1769. Work consolidated under features#296.",
      "related": [
        1745,
        1742,
        1743,
        1744,
        1748,
        1769,
        1781,
        1708,
        266,
        296
      ],
      "keyQuote": "This feature will allow users to issue update requests to a workflow, have that workflow process the update (accessing and mutating internal workflow state as necessary) and return a response to the caller.",
      "number": 1741,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:22.775Z"
    },
    {
      "summary": "Spring Expression Language (SpEL) vulnerability in transitive dependency spring-expression-5.3.25.jar affecting the temporal-spring-boot-starter-alpha module. Two CVEs (CVE-2023-20861 and CVE-2023-20863) with CVSS 6.5 severity allow denial-of-service attacks through specially crafted SpEL expressions.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "dependency-management",
        "spring-expression"
      ],
      "concepts": [
        "vulnerability",
        "denial-of-service",
        "spring-expression-language",
        "dependency-security",
        "transitive-dependency"
      ],
      "severity": "medium",
      "userImpact": "Applications using the temporal-spring-boot-starter are vulnerable to DoS attacks through malicious SpEL expressions if exposed to untrusted input.",
      "rootCause": "Transitive dependency on spring-expression-5.3.25.jar which contains unpatched SpEL expression parsing vulnerabilities allowing DoS conditions.",
      "proposedFix": "Upgrade spring-expression to version 5.2.23.RELEASE, 5.3.26, or 6.0.7 (or later) to resolve CVE-2023-20861, and to 5.2.24.RELEASE, 5.3.27, or 6.0.8 (or later) to resolve CVE-2023-20863.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Autoclosed by Mend as the vulnerable library was either marked as ignored or is no longer part of the Mend inventory on the specific branch.",
      "related": [],
      "keyQuote": "In Spring Framework versions...it is possible for a user to provide a specially crafted SpEL expression that may cause a denial-of-service (DoS) condition.",
      "number": 1738,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:08.811Z"
    },
    {
      "summary": "After calling getVersion() in a workflow, business logic exceptions thrown immediately after are being suppressed instead of propagating to the Temporal UI. The workflow task appears to be consuming the exception.",
      "category": "bug",
      "subcategory": "workflow-versioning",
      "apis": [
        "getVersion"
      ],
      "components": [
        "workflow-engine",
        "exception-handling",
        "task-processor"
      ],
      "concepts": [
        "exception-suppression",
        "workflow-versioning",
        "error-propagation",
        "task-execution",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Business logic exceptions are hidden from users when thrown immediately after version checks, making debugging impossible and masking errors in production workflows.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed due to insufficient information. A test was created showing the behavior works correctly in simple cases, and the reporter did not provide additional reproduction details.",
      "related": [],
      "keyQuote": "The exception should not be eaten up. Instead the business logic exception should come in the Temporal UI",
      "number": 1736,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:09.502Z"
    },
    {
      "summary": "Request to add activity attempt number to MDC context in the Java SDK's activity worker handler to differentiate between retry attempts in logs.",
      "category": "feature",
      "subcategory": "activity-logging",
      "apis": [
        "ActivityWorker"
      ],
      "components": [
        "activity-worker",
        "mdc-logging",
        "local-activity-worker"
      ],
      "concepts": [
        "logging",
        "mdc-context",
        "activity-retry",
        "attempt-tracking",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Users can now distinguish between different activity attempt logs using MDC context, improving debugging of retried activities.",
      "rootCause": null,
      "proposedFix": "Add MDC.put(LoggerTag.ACTIVITY_ATTEMPT, pollResponse.getAttempt()) and corresponding MDC.remove() calls to ActivityWorker#handle and LocalActivityWorker#handle methods.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in commit f2e113a49ba5d3d5b7a178bcaf14e6fb1e0df878",
      "related": [],
      "keyQuote": "Having the attempt added to the MDC context of the activity worker handler would allow me to differentiate between two activity attempts",
      "number": 1731,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:45:06.958Z"
    },
    {
      "summary": "User attempted to return an AWS S3Object from an activity, but Jackson serialization failed because S3Object contains non-serializable stream objects. The issue was closed as wontfix with guidance that users must implement custom serialization for complex objects.",
      "category": "question",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "serialization",
        "payload-converter",
        "activity-execution"
      ],
      "concepts": [
        "serialization",
        "jackson",
        "s3-integration",
        "payload-conversion",
        "stream-handling",
        "custom-converters"
      ],
      "severity": "low",
      "userImpact": "Users attempting to return complex external objects like S3Object from activities must implement custom serialization logic instead of relying on default JSON serialization.",
      "rootCause": "S3Object contains non-serializable internal stream objects (AbstractQueuedSynchronizer$ConditionObject) that Jackson cannot handle by default.",
      "proposedFix": "Either fully fetch and convert S3 object to an in-memory serializable representation, or pass S3 object by reference/ID instead of as a return value.",
      "workaround": "Configure custom PayloadConverter or Jackson serialization settings to handle S3Object serialization; alternatively, fetch S3 content into memory before returning.",
      "resolution": "wontfix",
      "resolutionDetails": "Temporal does not handle serialization of arbitrary objects; users are responsible for configuring their own serialization logic via PayloadConverter abstractions.",
      "related": [],
      "keyQuote": "Generally, an object containing any kind of input stream shouldn't be used as an activity return value. The S3 object should be either fully fetched and converted into a full in-memory representation or passed by reference / id.",
      "number": 1729,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:52.514Z"
    },
    {
      "summary": "Local activities do not retry when MaximumAttempts is set to 0, while regular activities retry forever with the same setting. This creates inconsistent behavior between local and normal activities.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "local-activity-executor",
        "retry-policy",
        "activity-options"
      ],
      "concepts": [
        "retry",
        "maximum-attempts",
        "local-activities",
        "consistency",
        "retry-forever"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure local activities to retry indefinitely using the same MaximumAttempts=0 pattern that works for regular activities, creating a confusing API inconsistency.",
      "rootCause": "Local activity retry logic does not handle MaximumAttempts=0 the same way as the standard activity retry mechanism.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "setting setMaximumAttempts=0 (or not setting any value, default = 0) for local activities should make the activity retry forever. I expect the same behavior as \"normal\" activities",
      "number": 1727,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:50.194Z"
    },
    {
      "summary": "Transitive dependency json-smart-2.4.8 contains CVE-2023-1370, a stack exhaustion vulnerability (CVSS 7.5) triggered by deeply nested JSON arrays/objects. The vulnerability affects temporal-testing through the json-path dependency chain.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "json-path",
        "json-smart",
        "testing-framework"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "stack-overflow",
        "dependency-management",
        "transitive-dependency",
        "cvss-scoring"
      ],
      "severity": "high",
      "userImpact": "Applications using temporal-testing are vulnerable to denial-of-service attacks via malformed JSON with excessive nesting, causing stack exhaustion and crashes.",
      "rootCause": "json-smart library lacks recursive depth limits when parsing nested JSON arrays and objects, allowing stack exhaustion attacks.",
      "proposedFix": "Upgrade net.minidev:json-smart from 2.4.8 to 2.4.9 or later version that includes the fix.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory, indicating the dependency was removed or updated.",
      "related": [],
      "keyQuote": "nesting too many of them can cause a stack exhaustion (stack overflow) and crash the software",
      "number": 1725,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:53.622Z"
    },
    {
      "summary": "When a workflow receives a signal in the final workflow task that starts a local activity, the workflow hangs with an INVALID_ARGUMENT error due to improper command sequencing. The CompleteWorkflowExecution command is issued before RecordMarker commands from the signal's local activity, violating the requirement that CompleteWorkflowExecution must be the last command.",
      "category": "bug",
      "subcategory": "signal-handling",
      "apis": [],
      "components": [
        "workflow-execution",
        "signal-handler",
        "local-activity",
        "command-sequencing"
      ],
      "concepts": [
        "workflow-completion",
        "signal-processing",
        "command-ordering",
        "local-activity",
        "workflow-task",
        "async-execution"
      ],
      "severity": "high",
      "userImpact": "Workflows that receive signals in the final task containing local activities will hang and fail with a command sequence error, preventing workflow completion.",
      "rootCause": "CompleteWorkflowExecution command is issued immediately upon workflow method completion before all pending signal-related commands (like RecordMarker from local activities) are issued, violating command ordering constraints.",
      "proposedFix": "Three options proposed: (1) defer CompleteWorkflowExecution to end of workflow task, (2) defer until all workflow threads complete, or (3) discard commands after CompleteWorkflowExecution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If workflow receives a signal with the last workflow task and this signal starts a local activity... it leads to INVALID_ARGUMENT: invalid command sequence: [CompleteWorkflowExecution, RecordMarker]",
      "number": 1722,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:37.825Z"
    },
    {
      "summary": "Transitive dependency vulnerability in json-smart-2.4.8 (CVE-2023-1370) affects temporal-testing due to stack exhaustion risk from uncontrolled JSON nesting. The vulnerability was automatically resolved when the vulnerable library was removed from the dependency tree.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "json-path",
        "json-smart",
        "temporal-testing"
      ],
      "concepts": [
        "vulnerability",
        "denial-of-service",
        "stack-overflow",
        "dependency-management",
        "json-parsing",
        "security"
      ],
      "severity": "high",
      "userImpact": "Users of temporal-testing could experience application crashes if the service processes malformed JSON with deeply nested structures.",
      "rootCause": "json-smart-2.4.8 lacks limits on JSON nesting depth, causing recursive parsing to exhaust stack memory when processing nested arrays or objects.",
      "proposedFix": "Upgrade net.minidev:json-smart to version 2.4.9 or later which addresses the stack exhaustion vulnerability.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was removed from the dependency inventory in the specific branch.",
      "related": [],
      "keyQuote": "Stack exhaustion in JSON Smart leads to Denial of Service when parsing malformed JSON",
      "number": 1717,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:34.762Z"
    },
    {
      "summary": "Dependency vulnerability in json-smart-2.4.7.jar (transitive dependency via json-path-2.7.0) causes potential denial of service through stack exhaustion when parsing deeply nested JSON structures. Fixed by upgrading json-smart to 2.4.9 or json-path to 2.8.0.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "json-path",
        "json-smart"
      ],
      "concepts": [
        "stack-exhaustion",
        "denial-of-service",
        "vulnerability",
        "dependency-upgrade",
        "nested-json-parsing"
      ],
      "severity": "high",
      "userImpact": "Applications using the Java SDK are vulnerable to denial of service attacks through malformed deeply-nested JSON inputs that cause stack overflow.",
      "rootCause": "json-smart library lacks limits on JSON array/object nesting depth, causing stack exhaustion when parsing recursively nested structures.",
      "proposedFix": "Upgrade json-smart to 2.4.9 or json-path to 2.8.0 (direct dependency fix)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend after the vulnerable library was removed from the inventory or marked as ignored in the specific branch.",
      "related": [],
      "keyQuote": "When reaching a '[' or '{' character in the JSON input, nesting too many of them can cause a stack exhaustion (stack overflow) and crash the software.",
      "number": 1716,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:38.287Z"
    },
    {
      "summary": "WorkerOptions configuration allows invalid executor counts that prevent proper queue polling. The maxConcurrentWorkflowTaskExecutionSize setting can be set lower than the minimum required executors (2: one for sticky queue, one for main queue), causing worker initialization failures.",
      "category": "bug",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "task-queue-polling",
        "executor-management"
      ],
      "concepts": [
        "executor-pool",
        "queue-polling",
        "sticky-queue",
        "configuration-validation",
        "worker-initialization"
      ],
      "severity": "high",
      "userImpact": "Users can create non-functional worker configurations that silently fail or behave unexpectedly, leading to workers unable to process tasks properly.",
      "rootCause": "WorkerOptions lacks validation to enforce that maxConcurrentWorkflowTaskExecutionSize >= 2, which is the minimum needed to maintain separate executor threads for sticky and main queue polling.",
      "proposedFix": "Add validation in WorkerOptions to enforce minimum executor count constraints and reject configurations that would prevent dual-queue polling.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Every worker needs at least 2 executors: one to be reserved and allow polling on the main task queue and another to be reserved and allow polling on a sticky task queue.",
      "number": 1715,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:18.620Z"
    },
    {
      "summary": "Test server fails with ExceptionInInitializerError during startup when reflection code for ActivityTaskHandlers is out of sync with actual method signatures, causing the test server to crash when attempting to start workflow execution.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "activity-task-handler",
        "test-visibility-store",
        "reflection-utils"
      ],
      "concepts": [
        "initialization",
        "reflection",
        "method-signature-mismatch",
        "test-framework",
        "grpc",
        "thread-pool"
      ],
      "severity": "high",
      "userImpact": "Users cannot start the test server, making it impossible to run local tests during development.",
      "rootCause": "Reflection code that publishes method signatures in ActivityTaskHandlerImpl is out of sync with the actual POJOActivityImplementation.execute method signature.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Method signatures were updated to align between reflection code and actual implementation.",
      "related": [],
      "keyQuote": "Reflection code that publishes the methods signatures is out of sync with actual method signatures. Class 'io.temporal.internal.activity.ActivityTaskExecutors.POJOActivityImplementation' is expected to have method 'execute'",
      "number": 1712,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:21.997Z"
    },
    {
      "summary": "Child workflows started from already-cancelled workflow contexts lack unit test coverage. The code path at SyncWorkflowContext.java:586 needs tests to verify proper behavior when initiating child workflows during cancellation.",
      "category": "feature",
      "subcategory": "test-coverage",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "SyncWorkflowContext",
        "child-workflow",
        "workflow-cancellation"
      ],
      "concepts": [
        "cancellation",
        "child-workflow",
        "test-coverage",
        "error-handling",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Lack of test coverage for cancelled workflow context could leave edge cases in child workflow initialization untested and potentially buggy.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Unit tests were added to cover the scenario of starting child workflows from cancelled workflow contexts.",
      "related": [],
      "keyQuote": "A situation where we attempt to start a child workflow from a workflow scope that is already cancelled is not covered with unit tests.",
      "number": 1711,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:19.569Z"
    },
    {
      "summary": "Epic for tracking test code coverage gaps in critical sections of the Java SDK. The epic was closed as the team decided against using GitHub issues as epics.",
      "category": "other",
      "subcategory": "test-coverage",
      "apis": [],
      "components": [
        "test-framework",
        "code-coverage"
      ],
      "concepts": [
        "testing",
        "code-coverage",
        "quality-assurance",
        "epic-tracking"
      ],
      "severity": "low",
      "userImpact": "Users benefit from improved test coverage ensuring critical Java SDK functionality is thoroughly validated.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because the team no longer wants to use GitHub issues as epics for organizing work.",
      "related": [
        1709,
        1711
      ],
      "keyQuote": "Closing since we no longer want to use GH issues as epics",
      "number": 1710,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:06.930Z"
    },
    {
      "summary": "The external workflow cancellation API (ExternalWorkflowStub#cancel and SyncWorkflowContext#cancelWorkflow) lacks unit test coverage. This request is to add comprehensive tests for the user-facing external workflow cancellation functionality.",
      "category": "feature",
      "subcategory": "testing",
      "apis": [
        "ExternalWorkflowStub#cancel",
        "SyncWorkflowContext#cancelWorkflow"
      ],
      "components": [
        "external-workflow-stub",
        "sync-workflow-context",
        "workflow-cancellation",
        "test-framework"
      ],
      "concepts": [
        "testing",
        "test-coverage",
        "cancellation",
        "external-workflow",
        "unit-testing",
        "api-coverage"
      ],
      "severity": "medium",
      "userImpact": "Users cannot verify that external workflow cancellation works correctly due to missing unit tests, potentially leaving bugs undetected.",
      "rootCause": null,
      "proposedFix": "Add unit tests for ExternalWorkflowStub#cancel and SyncWorkflowContext#cancelWorkflow methods.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test coverage was added for external workflow cancellation functionality.",
      "related": [],
      "keyQuote": "User-facing \"external\" workflow cancelation API and implementation that are not covered by any unit test.",
      "number": 1709,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:06.143Z"
    },
    {
      "summary": "Feature request to implement synchronous workflow updates in the Java SDK, based on the corresponding feature added to the Temporal server (PR #3822). This enables workflows to be updated synchronously during execution.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "UpdateWorkflow"
      ],
      "components": [
        "workflow-engine",
        "update-handler",
        "client"
      ],
      "concepts": [
        "workflow-update",
        "synchronous-execution",
        "workflow-lifecycle",
        "versioning",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users can now synchronously update workflows in Java SDK, matching the capability available in the server and other SDKs.",
      "rootCause": null,
      "proposedFix": "Implement the synchronous workflow update feature as specified in Temporal server PR #3822.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented and closed as duplicate/superseded by issue #1745, scheduled for release in v1.20.",
      "related": [
        1745
      ],
      "keyQuote": "Closing as implemented here https://github.com/temporalio/sdk-java/issues/1745 will be release in v1.20",
      "number": 1708,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:44:05.055Z"
    },
    {
      "summary": "ServiceWorkflowHistoryIterator should eagerly request the next page of workflow history instead of waiting until the current page is fully processed, improving performance for long workflow replays by reducing blocking time.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "ServiceWorkflowHistoryIterator"
      ],
      "components": [
        "workflow-history-iterator",
        "pagination",
        "replay-engine"
      ],
      "concepts": [
        "pagination",
        "eager-loading",
        "performance-optimization",
        "blocking",
        "workflow-replay",
        "history-fetching"
      ],
      "severity": "medium",
      "userImpact": "Users experiencing issues with replays of long workflow histories can see improved performance through reduced blocking time.",
      "rootCause": "ServiceWorkflowHistoryIterator only requests the next page when the worker is blocked after finishing the previous page, causing unnecessary waiting.",
      "proposedFix": "Eagerly request the next page immediately instead of on-demand, following the pattern already implemented in EagerPaginator.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1242
      ],
      "keyQuote": "Currently `ServiceWorkflowHistoryIterator` requests the next page only when the worker is already blocked and finished processing the previous page.",
      "number": 1707,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:52.705Z"
    },
    {
      "summary": "WorkerFactoryOptions.getDefaultInstance() doesn't return an instance with actual default values populated. Users expected the method to return an object with all default configuration values set, but instead it returns an instance requiring manual merging of properties from different sources.",
      "category": "question",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerFactoryOptions"
      ],
      "components": [
        "worker-factory",
        "configuration"
      ],
      "concepts": [
        "default-values",
        "configuration-merging",
        "api-expectations",
        "builder-pattern"
      ],
      "severity": "low",
      "userImpact": "Users calling getDefaultInstance() may be confused about how to access default configuration values, requiring them to use alternative approaches like newBuilder().validateAndBuildWithDefaults().",
      "rootCause": "The design intentionally doesn't populate unoverridden fields to support merging properties from different sources, which differs from user expectations of what getDefaultInstance() should return.",
      "proposedFix": null,
      "workaround": "Use WorkerFactoryOptions.newBuilder().validateAndBuildWithDefaults() to get default values.",
      "resolution": "wontfix",
      "resolutionDetails": "Marked as wontfix because the current behavior is intentional - getDefaultInstance() returns a minimal instance to support property merging from multiple sources, not a fully populated defaults object.",
      "related": [],
      "keyQuote": "If you want to read the default values for whatever purposes, you may use WorkerFactoryOptions.newBuilder().validateAndBuildWithDefaults()",
      "number": 1703,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:50.774Z"
    },
    {
      "summary": "Spring Boot starter 2.7.9 contains 7 vulnerabilities in SnakeYAML 1.30, including a critical RCE vulnerability (CVE-2022-1471) with CVSS score 9.8. The issue was automatically closed after the vulnerable dependency was removed or ignored.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "dependency-management",
        "snakeyaml"
      ],
      "concepts": [
        "security-vulnerability",
        "remote-code-execution",
        "dependency-upgrade",
        "transitive-dependency",
        "deserialization"
      ],
      "severity": "critical",
      "userImpact": "Users of the Spring Boot starter are exposed to critical RCE and DoS vulnerabilities through the outdated SnakeYAML transitive dependency.",
      "rootCause": "SnakeYAML 1.30 lacks proper type restrictions during YAML deserialization and nested depth limitations, allowing remote code execution and denial of service attacks.",
      "proposedFix": "Upgrade spring-boot-starter to version 3.0.0 or later, which includes SnakeYAML 2.0+. For the critical CVE-2022-1471, upgrade snakeyaml to 2.0 or beyond.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The vulnerable library was either marked as ignored or removed from the Mend inventory in the specific branch, allowing the issue to be automatically closed.",
      "related": [],
      "keyQuote": "SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution.",
      "number": 1700,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:52.788Z"
    },
    {
      "summary": "WorkflowImplementationOptions.FailWorkflowExceptionTypes is ignored when the service rejects workflow task completion, causing workflows to get stuck in retry loops instead of failing as expected. Setting an invalid retry policy (e.g., maximumInterval < initialInterval) demonstrates the issue where service failures don't trigger workflow failure.",
      "category": "bug",
      "subcategory": "workflow-task-failure",
      "apis": [
        "WorkflowImplementationOptions",
        "FailWorkflowExceptionTypes"
      ],
      "components": [
        "workflow-implementation",
        "workflow-task-processor",
        "retry-policy"
      ],
      "concepts": [
        "workflow-failure",
        "task-rejection",
        "exception-handling",
        "retry-loop",
        "service-failure",
        "workflow-execution-state"
      ],
      "severity": "high",
      "userImpact": "Workflows can become stuck in infinite retry loops when encountering invalid retry policies or service rejections, making them unrecoverable without manual intervention.",
      "rootCause": "The SDK does not emit FailWorkflowExecution command when the service rejects workflow task completion, even when FailWorkflowExceptionTypes includes the exception type.",
      "proposedFix": "SDK should fail the workflow execution by emitting FailWorkflowExecution command when service rejects workflow task completion and exception matches FailWorkflowExceptionTypes.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDK can fail the execution by emitting FailWorkflowExecution command.",
      "number": 1698,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:38.856Z"
    },
    {
      "summary": "Users need access to serialization context (workflow ID, activity ID, task queue names) in PayloadConverter and PayloadCodec implementations. This enables use cases like task-queue-specific data conversion and incorporating workflow context into encryption codecs.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [
        "PayloadConverter",
        "PayloadCodec"
      ],
      "components": [
        "payload-conversion",
        "codec",
        "serialization-context"
      ],
      "concepts": [
        "context-awareness",
        "payload-encoding",
        "encryption",
        "workflow-isolation",
        "codec-customization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently implement task-queue-specific or workflow-aware serialization logic, limiting encryption and data conversion customization options.",
      "rootCause": null,
      "proposedFix": "Make serialization context (workflow ID, activity ID, task queue names) available to PayloadConverter and PayloadCodec implementations",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Serialization context was made available to PayloadCodecs and PayloadConverters, allowing access to workflow ID, activity ID, and task queue information",
      "related": [],
      "keyQuote": "Some users need to have an access to some basic info like workflow id and activity id and task queue names in their PayloadConverter or PayloadCodec",
      "number": 1694,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:37.076Z"
    },
    {
      "summary": "Test server lacks support for listWorkflowExecutions API endpoint, forcing users to use separate listOpenWorkflowExecutions and listClosedWorkflowExecutions endpoints instead. This is a gap since all SDKs now provide high-level APIs for listing workflows that rely on the unified endpoint.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "listWorkflowExecutions",
        "ListOpenWorkflowExecutionsRequest",
        "ListClosedWorkflowExecutionsRequest"
      ],
      "components": [
        "test-server",
        "workflow-client",
        "workflow-service-stub"
      ],
      "concepts": [
        "workflow-querying",
        "test-environment",
        "api-parity",
        "search-attributes",
        "workflow-listing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot list workflow executions with search attribute queries in test environment, requiring workarounds with separate open/closed endpoints and limiting testing capabilities.",
      "rootCause": "Test server implementation only supports separate list open/closed endpoints and has no search attribute query support.",
      "proposedFix": "Implement listWorkflowExecutions endpoint in test server with search attribute querying capabilities.",
      "workaround": "Use ListOpenWorkflowExecutionsRequest or ListClosedWorkflowExecutionsRequest endpoints separately via workflowServiceStubs.blockingStub().",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Test server only implements list open / closed, need support for this since all SDKs now have a high level API to list workflows that relies on this endpoint.",
      "number": 1693,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:36.068Z"
    },
    {
      "summary": "Implement the workflow_start_delay feature in the test server to support delayed workflow start times for testing purposes, following the API specification defined in temporalio/api PR #264.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "workflow-execution"
      ],
      "concepts": [
        "workflow-delay",
        "test-support",
        "api-implementation",
        "timing-control",
        "test-framework"
      ],
      "severity": "medium",
      "userImpact": "Enables developers to test workflows with delayed start times, improving test coverage for time-dependent workflow scenarios.",
      "rootCause": null,
      "proposedFix": "Implement workflow_start_delay feature in Java test server as specified in temporalio/api PR #264",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented following the API specification",
      "related": [
        264
      ],
      "keyQuote": "See API PR here: https://github.com/temporalio/api/pull/264",
      "number": 1692,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:21.333Z"
    },
    {
      "summary": "Request to add an API to count workflows in the Java SDK. This is a reference to a parent issue that specifies the requirements for implementing workflow count functionality.",
      "category": "feature",
      "subcategory": "workflow-management",
      "apis": [
        "ListWorkflows"
      ],
      "components": [
        "workflow-service",
        "client",
        "query-api"
      ],
      "concepts": [
        "workflow-enumeration",
        "count",
        "list-operation",
        "query",
        "workflow-metadata"
      ],
      "severity": "medium",
      "userImpact": "Users need a programmatic way to count workflows in their Temporal deployment without manual iteration or external tools.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of the workflow listing and query capabilities in the Java SDK.",
      "related": [],
      "keyQuote": "See parent issue for reference.",
      "number": 1685,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:23.156Z"
    },
    {
      "summary": "Closing a metric subscope created with .tagged() or .subscope() unexpectedly closes the parent worker's metrics scope, disabling all metrics reporting. This is caused by subscopes closing their underlying reporter through the Uber Tally library dependency.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [
        "getMetricsScope"
      ],
      "components": [
        "metrics",
        "scope",
        "ReplayAwareScope"
      ],
      "concepts": [
        "metrics reporting",
        "scope lifecycle",
        "resource management",
        "try-with-resources",
        "AutoCloseable"
      ],
      "severity": "high",
      "userImpact": "Users closing metric subscopes cause silent failure of all metrics reporting for the entire worker.",
      "rootCause": "ReplayAwareScope wraps an Uber Tally Scope which closes its reporter on close(), affecting the parent scope. This is by design in Tally's subscope implementation.",
      "proposedFix": null,
      "workaround": "Avoid calling close() on metric subscopes, or do not wrap subscopes in try-with-resources blocks.",
      "resolution": "wontfix",
      "resolutionDetails": "Scope behavior is controlled by Uber Tally (transitive dependency). The Temporal Java SDK does not control Tally's abstractions. This will be addressed if/when Temporal creates its own Scope abstraction.",
      "related": [],
      "keyQuote": "Scope abstraction, contracts and implementation is not Temporal Java SDK abstraction, it's uber-tally, our transitive dependency.",
      "number": 1684,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:22.469Z"
    },
    {
      "summary": "Test Server does not respect the WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING WorkflowIdReusePolicy. When this policy is set, the Test Server should terminate any running workflow with the same ID and create a new one, but currently it does not.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowIdReusePolicy"
      ],
      "components": [
        "test-server",
        "workflow-id-reuse",
        "policy-enforcement"
      ],
      "concepts": [
        "workflow-termination",
        "workflow-reuse-policy",
        "test-compliance",
        "workflow-lifecycle",
        "policy-enforcement"
      ],
      "severity": "medium",
      "userImpact": "Test Server users cannot properly test workflows with the TERMINATE_IF_RUNNING reuse policy, limiting test coverage for this important workflow lifecycle scenario.",
      "rootCause": null,
      "proposedFix": "Test Server should implement support for WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING by terminating existing workflows and creating new ones when this policy is configured.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Test Server should terminate the running workflow and create a new one with this WorkflowIdReusePolicy.",
      "number": 1682,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:04.735Z"
    },
    {
      "summary": "Exceptions thrown from workflow executor/control code are currently subject to failWorkflowExceptionTypes logic, which can cause internal SDK errors (like outdated cached instance detection) to fail workflow executions instead of just failing workflow tasks. The request is to exclude control code exceptions from user-configured exception type filters, with an exception for NonDeterministicException.",
      "category": "other",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowImplementationOptions"
      ],
      "components": [
        "workflow-executor",
        "control-code",
        "exception-handling",
        "task-processing"
      ],
      "concepts": [
        "exception-filtering",
        "workflow-task-failure",
        "execution-failure",
        "determinism",
        "retry-logic",
        "control-flow"
      ],
      "severity": "high",
      "userImpact": "Users setting broad failWorkflowExceptionTypes filters may inadvertently fail entire workflow executions when internal SDK errors occur, instead of just failing the workflow task.",
      "rootCause": "failWorkflowExceptionTypes is applied to all exceptions including those from workflow executor control code, not just user workflow code exceptions.",
      "proposedFix": "Don't apply failWorkflowExceptionTypes to exceptions from control code; introduce explicit FailWorkflowTaskException for SDK internals to distinguish between task-level and execution-level failures, with NonDeterministicException as an exception to always fail executions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "users expect `failWorkflowExceptionTypes` to be applied only to the workflow exceptions, but it's also applied to the workflow executor exception",
      "number": 1681,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:09.461Z"
    },
    {
      "summary": "Improve graceful worker shutdown to wait for all reserved local dispatch slots (from eager activities and eager workflow tasks) to be released before completing shutdown.",
      "category": "feature",
      "subcategory": "worker-shutdown",
      "apis": [],
      "components": [
        "worker",
        "eager-activity-dispatch",
        "eager-workflow-task-dispatch",
        "executor"
      ],
      "concepts": [
        "graceful-shutdown",
        "resource-cleanup",
        "task-dispatch",
        "reservation-management",
        "worker-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users need reliable shutdown of workers that properly releases all reserved task slots to prevent resource leaks.",
      "rootCause": null,
      "proposedFix": "Wait for all eager dispatch reservations to be released during graceful worker shutdown.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by #1679",
      "related": [
        1679
      ],
      "keyQuote": "Graceful Worker shutdown should wait for all such reservations to be released by the holders.",
      "number": 1680,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:43:05.818Z"
    },
    {
      "summary": "Child workflow fails with SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND error even though the signal was successfully handled by the parent workflow, suggesting a race condition in signal delivery timing.",
      "category": "bug",
      "subcategory": "signal-handling",
      "apis": [
        "SignalExternalWorkflowExecution"
      ],
      "components": [
        "signal-dispatcher",
        "child-workflow",
        "workflow-completion"
      ],
      "concepts": [
        "signal-delivery",
        "race-condition",
        "parent-child-workflow",
        "workflow-completion",
        "signal-failure"
      ],
      "severity": "high",
      "userImpact": "Users experience unexpected workflow failures when signaling parent workflows during child workflow shutdown, causing signal-based coordination patterns to fail intermittently.",
      "rootCause": "Parent workflow may complete before the last child signal is actually sent, causing the signal delivery to fail with NOT_FOUND after the parent has already received and processed an earlier signal.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "stale",
      "resolutionDetails": "Closed due to lack of activity and inability to reproduce the issue without a minimal reproduction case.",
      "related": [],
      "keyQuote": "Can it be that the parent WF manage to complete but somehow the child still didn't handle the signal, although the signal got to the parent?",
      "number": 1676,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:51.640Z"
    },
    {
      "summary": "LongLocalActivityFailsWhileHeartbeatingMeteringTest flakes intermittently during code coverage runs, producing unexpected metering counts [0, 3, 3, 2] instead of expected [0, 2, 3, 1].",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "local-activity",
        "heartbeat",
        "metering",
        "test-framework"
      ],
      "concepts": [
        "flakiness",
        "metering",
        "heartbeat",
        "race-condition",
        "test-reliability",
        "code-coverage"
      ],
      "severity": "medium",
      "userImpact": "Test flakiness in CI/CD code coverage runs indicates potential issues with local activity metering and heartbeat handling that could affect reliability in production.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved as the test was fixed to handle timing-dependent metering counts properly.",
      "related": [],
      "keyQuote": "expected:<[0, 2, 3, 1]> but was:<[0, 3, 3, 2]>",
      "number": 1672,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:49.608Z"
    },
    {
      "summary": "Epic to introduce new failure types to the Failures structure to better express various failure scenarios in the Java SDK.",
      "category": "feature",
      "subcategory": "failure-handling",
      "apis": [],
      "components": [
        "failure-handling",
        "error-types"
      ],
      "concepts": [
        "failure-types",
        "error-handling",
        "exception-types",
        "failure-classification"
      ],
      "severity": "medium",
      "userImpact": "Users cannot adequately express all failure scenarios their workflows encounter, limiting error handling precision.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Epic was closed as GitHub issues are no longer used for tracking epics.",
      "related": [
        1374
      ],
      "keyQuote": "Closing since we no longer use GH issues to track epics",
      "number": 1671,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:52.928Z"
    },
    {
      "summary": "User requests that the @WorkflowMethod annotation be discoverable through inheritance from parent classes/interfaces to enable code reuse in workflow patterns without redundant re-declaration.",
      "category": "feature",
      "subcategory": "workflow-definition",
      "apis": [
        "WorkflowMethod",
        "WorkflowInterface",
        "SignalMethod"
      ],
      "components": [
        "workflow-interface",
        "annotation-processor",
        "workflow-definition"
      ],
      "concepts": [
        "inheritance",
        "code-reuse",
        "annotation-discovery",
        "interface-hierarchy",
        "design-pattern",
        "composition"
      ],
      "severity": "low",
      "userImpact": "Developers must redundantly redeclare and re-annotate workflow methods in child classes, leading to boilerplate code and potential maintenance issues.",
      "rootCause": "Temporal's design intentionally couples @WorkflowMethod with @WorkflowInterface to prevent orphaned workflow method annotations and maintain a single workflow method per interface.",
      "proposedFix": "Allow @WorkflowMethod annotation inheritance while treating multi-inheritance of workflow methods as a runtime violation or unspecified behavior.",
      "workaround": "Create custom documenting annotations like @WorkflowMethodCandidate or redeclare the method in child classes with the annotation.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers decided against the feature to enforce the design principle that @WorkflowMethod and @WorkflowInterface must work together, and @WorkflowMethod outside a @WorkflowInterface is conceptually invalid.",
      "related": [],
      "keyQuote": "You parent class is not implementing a @WorkflowInterface, it shouldn't have WorkflowMethods. It's not workflow methods. It's just methods.",
      "number": 1669,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:36.263Z"
    },
    {
      "summary": "Subsequent MutableSideEffect calls with the same ID within a single workflow task can cause non-deterministic replay errors. When multiple calls produce different results, only some markers are recorded in history, causing markers to be misaligned to wrong calls on replay.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "MutableSideEffect"
      ],
      "components": [
        "workflow-execution",
        "history-replay",
        "side-effect-handler"
      ],
      "concepts": [
        "determinism",
        "replay",
        "marker-alignment",
        "history-consistency",
        "mutable-side-effect"
      ],
      "severity": "high",
      "userImpact": "Workflows using multiple MutableSideEffect calls with the same ID will fail non-deterministically during replay, causing workflow execution failures.",
      "rootCause": "When consecutive MutableSideEffect calls with the same ID produce different results, not all results create markers in history. During replay, markers created by later calls are applied to earlier calls, causing misalignment.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1014
      ],
      "keyQuote": "On replay the marker created by the third mutable side effect call will be applied to a second call instead causing a non-deterministic replay.",
      "number": 1668,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:36.022Z"
    },
    {
      "summary": "WorkflowStub.getExecution() returns null after workflows are started via signalWithStart() in SDK 1.18.1, breaking unit tests that relied on this behavior in previous versions.",
      "category": "bug",
      "subcategory": "workflow-stub",
      "apis": [
        "WorkflowStub.signalWithStart",
        "WorkflowStub.getExecution"
      ],
      "components": [
        "workflow-stub",
        "signal-handling",
        "test-framework"
      ],
      "concepts": [
        "workflow-execution",
        "signal-with-start",
        "null-reference",
        "regression",
        "unit-testing"
      ],
      "severity": "high",
      "userImpact": "Unit tests fail unexpectedly after upgrading to 1.18.1 because getExecution() returns null for workflows started via signalWithStart().",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in patch release v1.18.2",
      "related": [],
      "keyQuote": "WorkflowStub.getExecution() returns null after the workflow is started via signalWithStart",
      "number": 1667,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:37.332Z"
    },
    {
      "summary": "User requests a high-level Schedule API example for Java SDK with Spring Boot integration. The feature is being tracked and was eventually delivered with a sample in the samples repository.",
      "category": "feature",
      "subcategory": "schedule-api",
      "apis": [
        "CreateSchedule",
        "WorkflowService"
      ],
      "components": [
        "schedule-api",
        "spring-boot-integration"
      ],
      "concepts": [
        "scheduling",
        "cron-jobs",
        "workflow-scheduling",
        "api-design",
        "examples"
      ],
      "severity": "low",
      "userImpact": "Users need guidance on implementing Temporal schedules with Spring Boot, which affects adoption and ease of use of the scheduling feature.",
      "rootCause": null,
      "proposedFix": "Provide high-level Schedule API for Java SDK and Spring Boot examples/documentation.",
      "workaround": "Use raw gRPC API with WorkflowService/CreateSchedule, or use legacy cron workflows pattern.",
      "resolution": "fixed",
      "resolutionDetails": "A schedule sample was provided in the samples repository at samples-java/core/src/main/java/io/temporal/samples/hello/HelloSchedules.java",
      "related": [
        1333
      ],
      "keyQuote": "A schedule sample is available in our samples repo... Springboot does not effect schedules so a spring boot specific example wouldn't provide much value",
      "number": 1666,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:22.616Z"
    },
    {
      "summary": "Implement signal request deduplication by utilizing the SignalWorkflowExecutionRequest#request_id field in the Java SDK. This allows the SDK to deduplicate signal retry attempts that experience gRPC errors but still arrive at the Server.",
      "category": "feature",
      "subcategory": "signal-deduplication",
      "apis": [
        "SignalWorkflowExecution",
        "SignalWorkflowExecutionRequest"
      ],
      "components": [
        "signal-client",
        "grpc-retry-handler",
        "request-deduplication"
      ],
      "concepts": [
        "retry",
        "deduplication",
        "request-id",
        "grpc-error",
        "idempotency",
        "signal-handling",
        "fault-tolerance"
      ],
      "severity": "medium",
      "userImpact": "Users benefit from improved reliability of signal operations with automatic deduplication of retried signal requests, preventing duplicate signal processing.",
      "rootCause": null,
      "proposedFix": "Generate a unique UUID for each user-facing signal API and utilize SignalWorkflowExecutionRequest#request_id for deduplication.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Signal request deduplication using request_id was implemented in the Java SDK.",
      "related": [],
      "keyQuote": "Generate a unique UUID for each user-facing signal API and utilize `SignalWorkflowExecutionRequest#request_id`",
      "number": 1655,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:21.279Z"
    },
    {
      "summary": "Workers fail to auto-start in Spring Boot starter version 1.18.1 when using the start-workers flag, causing workflows to time out with no error logs. The issue was resolved by requiring explicit ConfigurableApplicationContext.start() call in applications.",
      "category": "bug",
      "subcategory": "spring-boot-starter",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "worker-auto-discovery",
        "application-context"
      ],
      "concepts": [
        "worker-startup",
        "spring-auto-configuration",
        "application-lifecycle",
        "context-initialization"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to 1.18.1 experience workflow execution failures without clear error messages, requiring application restart and configuration changes.",
      "rootCause": "ConfigurableApplicationContext.start() must be explicitly called for workers to auto-start in version 1.18.x, a breaking change from the previous behavior.",
      "proposedFix": "Call ConfigurableApplicationContext.start() in the application to properly initialize worker auto-discovery and startup.",
      "workaround": "Manually invoke start() on the application context or implement a ContextStartedEvent listener as documented in Spring documentation.",
      "resolution": "invalid",
      "resolutionDetails": "Marked as invalid because the issue was a missing required step in the Spring Boot starter documentation - not a bug in the code but rather a behavior change that required users to adapt their initialization logic.",
      "related": [],
      "keyQuote": "Since version 1.18.x ConfigurableApplicationContext.start() needs to be called for workers to auto-start.",
      "number": 1648,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:20.185Z"
    },
    {
      "summary": "Request to allow WorkflowImplementationOptions to be configured via Spring Boot configuration instead of only programmatically. This feature would improve Spring Boot integration by enabling declarative workflow option setup.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkflowImplementationOptions"
      ],
      "components": [
        "spring-boot-integration",
        "workflow-configuration",
        "options-handling"
      ],
      "concepts": [
        "configuration",
        "spring-boot",
        "declarative-setup",
        "workflow-options",
        "integration"
      ],
      "severity": "low",
      "userImpact": "Spring Boot users are currently unable to configure WorkflowImplementationOptions declaratively and must set them programmatically.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Folded into issue #1984 which provides a more comprehensive solution for Spring Boot configuration.",
      "related": [
        1984
      ],
      "keyQuote": "Currently its not possible to set WorkflowImplementationOptions via config in Spring Boot integration",
      "number": 1647,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:05.081Z"
    },
    {
      "summary": "WorkflowClient should request eager workflow task dispatch from the Server when starting workflows or signaling workflows on local workers listening to the correct task queue, to improve performance and latency.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowClient",
        "start",
        "signalWithStart"
      ],
      "components": [
        "workflow-client",
        "task-dispatch",
        "worker"
      ],
      "concepts": [
        "eager-dispatch",
        "task-queue",
        "workflow-start",
        "performance",
        "local-worker",
        "latency-optimization"
      ],
      "severity": "medium",
      "userImpact": "Reduces latency for workflow execution by enabling the server to dispatch workflow tasks immediately to local workers instead of waiting for polling.",
      "rootCause": null,
      "proposedFix": "Implement eager workflow task dispatch mechanism in WorkflowClient for start and signalWithStart operations when aware of local worker on correct task queue.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented with eager workflow task dispatch support in WorkflowClient",
      "related": [
        242
      ],
      "keyQuote": "WorkflowClient should request eager workflow task dispatch on #start and #signalWithStart calls from the Server if it's aware of the local worker listening on the correct task queue.",
      "number": 1646,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:02.445Z"
    },
    {
      "summary": "ContextPropagator lacks access to workflow/activity instances and awareness of context type, preventing proper ThreadLocal/WorkflowLocal usage and lifecycle management. A redesign is needed to reimplement it as Interceptors with proper integration into the SDK's context propagation model.",
      "category": "feature",
      "subcategory": "context-propagation",
      "apis": [],
      "components": [
        "ContextPropagator",
        "Interceptor",
        "ThreadLocal",
        "WorkflowLocal"
      ],
      "concepts": [
        "context-propagation",
        "lifecycle-management",
        "thread-local-storage",
        "workflow-context",
        "activity-context",
        "interceptors"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly implement custom context propagators that need to access entity instances or decide between ThreadLocal and WorkflowLocal storage strategies.",
      "rootCause": "Current ContextPropagator design lacks reference to propagation target (workflow/activity instance) and lacks awareness of context type, preventing informed lifecycle and storage decisions.",
      "proposedFix": "Reimplement ContextPropagator as Interceptors with proper access to entity references and context type information, including lifecycle methods for ThreadLocal cleanup.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        525
      ],
      "keyQuote": "ContextPropagator should be reimplemented as Interceptors from scratch and its design should be reimplemented taking into account the points mentioned above.",
      "number": 1644,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:42:07.660Z"
    },
    {
      "summary": "Test Server currently returns all history in a single response without pagination. This prevents SDK developers from testing pagination-dependent behavior. The request is to add configurable pagination to the Test Server for improved test coverage.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "history",
        "pagination"
      ],
      "concepts": [
        "pagination",
        "testing",
        "SDK internals",
        "server behavior",
        "test coverage"
      ],
      "severity": "medium",
      "userImpact": "SDK developers cannot adequately test pagination-dependent code paths without using a real Temporal server.",
      "rootCause": null,
      "proposedFix": "Make pagination configurable in Test Server, allowing aggressive pagination modes for enhanced test coverage",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1639,
        1638
      ],
      "keyQuote": "Pagination of the Test Server doesn't have to match the behavior of the real server, but it should be present and configurable",
      "number": 1642,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:50.014Z"
    },
    {
      "summary": "Workers with java-sdk 1.18.0+ fail with 'required property congestionInitialInterval not set' when processing workflows requiring pagination to fetch history, causing stuck workflows unable to complete replay.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "RpcRetryOptions",
        "ServiceWorkflowHistoryIterator",
        "ReplayWorkflowRunTaskHandler"
      ],
      "concepts": [
        "workflow-replay",
        "pagination",
        "history-fetching",
        "retry-configuration",
        "worker-processing"
      ],
      "severity": "critical",
      "userImpact": "Workers become stuck and unable to finish workflow replay when processing workflows with large histories, preventing workflow task execution.",
      "rootCause": "RpcRetryOptions validation requiring congestionInitialInterval property that is not being set during GrpcRetryer initialization.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was introduced in v1.18.1 and resolved by fixing the RpcRetryOptions configuration to properly initialize congestionInitialInterval.",
      "related": [],
      "keyQuote": "required property congestionInitialInterval not set",
      "number": 1639,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:49.429Z"
    },
    {
      "summary": "Users need the ability to register interceptor beans in the Spring Boot context so that these interceptors can be automatically applied to Workers and Client configuration.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "Worker",
        "Client"
      ],
      "components": [
        "spring-boot",
        "interceptor",
        "bean-registration",
        "worker-config",
        "client-config"
      ],
      "concepts": [
        "dependency-injection",
        "spring-context",
        "interceptor-chain",
        "bean-lifecycle",
        "configuration",
        "extension-point",
        "integration"
      ],
      "severity": "medium",
      "userImpact": "Spring Boot users cannot easily register custom interceptors through the Spring context, limiting their ability to integrate cross-cutting concerns like logging, monitoring, and tracing.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users should be able to register interceptor beans in the Spring Boot context and these interceptors should be used for Workers and Client configuration.",
      "number": 1634,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:51.324Z"
    },
    {
      "summary": "TestWorkflowExtension lacks the ability to pass WorkflowImplementationOptions to setWorkflowTypes, unlike TestWorkflowRule which supports this. Users must use workarounds like calling registerWorkflowImplementationTypes directly instead of using the convenient setWorkflowTypes method.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "setWorkflowTypes",
        "registerWorkflowImplementationTypes",
        "WorkflowImplementationOptions"
      ],
      "components": [
        "TestWorkflowExtension",
        "TestWorkflowRule",
        "Worker"
      ],
      "concepts": [
        "testing",
        "workflow-registration",
        "api-consistency",
        "developer-experience",
        "activity-options"
      ],
      "severity": "low",
      "userImpact": "Users working with TestWorkflowExtension cannot conveniently set WorkflowImplementationOptions and must resort to more verbose workarounds in their test setup.",
      "rootCause": "TestWorkflowExtension.setWorkflowTypes() has a simpler signature than TestWorkflowRule.setWorkflowTypes(), missing the WorkflowImplementationOptions parameter.",
      "proposedFix": "Add an overloaded setWorkflowTypes method to TestWorkflowExtension.Builder that accepts WorkflowImplementationOptions as the first parameter, similar to TestWorkflowRule.",
      "workaround": "Use TestWorkflowExtension.newBuilder().setDoNotStart(true) combined with @BeforeEach setupWorkflowOptions to manually call worker.registerWorkflowImplementationTypes() with the desired options.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the feature was implemented to allow WorkflowImplementationOptions to be passed in TestWorkflowExtension.setWorkflowTypes.",
      "related": [],
      "keyQuote": "Allow WorkflowImplementationOptions to also be passed in setWorkflowTypes in TestWorkflowExtention.",
      "number": 1626,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:37.170Z"
    },
    {
      "summary": "Request to add an `addMemo()` method to ContinueAsNewOptions.Builder that allows appending memo values to the next workflow execution without requiring access to the current execution's entire memo map. Currently users must extract all existing memo values before setting new ones when continuing a workflow.",
      "category": "feature",
      "subcategory": "workflow-continuation",
      "apis": [
        "ContinueAsNewOptions"
      ],
      "components": [
        "workflow-engine",
        "continuation",
        "memo-management"
      ],
      "concepts": [
        "state-preservation",
        "workflow-continuation",
        "memo-metadata",
        "api-ergonomics",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily add memo values when continuing workflows as new without duplicating all existing memo data, complicating abstraction layers that manage standard memo values.",
      "rootCause": null,
      "proposedFix": "Add `addMemo(key, value)` method to ContinueAsNewOptions.Builder that allows setting additional memo values while preserving existing ones from the current execution.",
      "workaround": "Either add memo values to workflow arguments (leaky abstraction) or maintain a list of all known memo keys to manually reconstruct the entire memo map.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "ContinueAsNewOptions allows setting the entire memo map...in order to *add* new memo values to the next run while preserving existing values, we need to extract all the values",
      "number": 1621,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:34.673Z"
    },
    {
      "summary": "Temporal Spring Boot Integration is incompatible with Spring Boot 3.0 due to removal of spring.factories for auto-configuration. Support needs to be added with necessary changes while considering backwards compatibility with earlier versions.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-integration",
        "auto-configuration",
        "spring-factories"
      ],
      "concepts": [
        "spring-boot-compatibility",
        "auto-configuration",
        "migration",
        "backwards-compatibility",
        "framework-upgrade"
      ],
      "severity": "high",
      "userImpact": "Users cannot use Temporal Spring Boot Integration with Spring Boot 3.0, blocking adoption of the latest Spring Boot version.",
      "rootCause": "spring.factories auto-configuration mechanism was deprecated in Spring Boot 2.7 and removed in Spring Boot 3.0.",
      "proposedFix": "Update integration to support Spring Boot 3.0 auto-configuration while maintaining backwards compatibility with earlier versions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal Spring Boot Integration is not compatible with Spring Boot 3.0. One specific issue is that `spring.factories` is no longer supported for enabling autoconfiguration, it was deprecated in 2.7 and removed in 3.0",
      "number": 1619,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:32.380Z"
    },
    {
      "summary": "Test server with child workflow and signal is timing out when attempting unlock-with-sleep. When a parent workflow starts a child workflow and both wait on signals, time-skipping test failures occur during unlock operations.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "start_child_workflow",
        "wait_condition",
        "signal"
      ],
      "components": [
        "test-server",
        "time-skipping",
        "child-workflows"
      ],
      "concepts": [
        "timeout",
        "time-skipping",
        "signal-handling",
        "child-workflows",
        "workflow-activation",
        "test-environment"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test workflows with child workflows and signals using the test server's time-skipping feature, causing test failures in development.",
      "rootCause": "Time-skipping unlock operations appear to cause timeouts when parent and child workflows both have pending timers and signal handlers, likely related to activation/completion sequencing in the test server.",
      "proposedFix": null,
      "workaround": "Tests pass if child workflow is not started (as noted in the code comment).",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "test passes if child workflow is not started.",
      "number": 1618,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:20.908Z"
    },
    {
      "summary": "TemporalFailure exceptions thrown from signal methods should fail the workflow execution instead of failing only the workflow task, which can cause infinite retry loops. Currently, failures in signal handlers are not treated the same as failures in workflow methods.",
      "category": "bug",
      "subcategory": "signal-handling",
      "apis": [],
      "components": [
        "signal-handler",
        "workflow-task-processor",
        "failure-handling"
      ],
      "concepts": [
        "exception-handling",
        "signal-processing",
        "workflow-failure",
        "infinite-loop",
        "task-retry"
      ],
      "severity": "high",
      "userImpact": "Workflows can enter infinite loops when exceptions are thrown from signal methods, preventing proper error handling and workflow termination.",
      "rootCause": "Signal method failures are treated as task failures rather than workflow execution failures, causing the task to be retried indefinitely instead of failing the workflow.",
      "proposedFix": "Modify signal handler exception processing to fail the workflow execution when TemporalFailure is thrown, matching the behavior of workflow method failures.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Signal method exception handling was updated to properly propagate TemporalFailure to workflow execution failure rather than task failure.",
      "related": [],
      "keyQuote": "ActivityFailure or ApplicationFailure that are thrown from a signal method should fail Workflow Execution the same way it works with Workflow Method code.",
      "number": 1615,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:18.505Z"
    },
    {
      "summary": "Seven vulnerabilities were identified in snakeyaml-1.30.jar (transitive dependency via spring-boot-dependencies-2.7.8), with the highest severity being 9.8. The most critical vulnerability (CVE-2022-1471) allows remote code execution through unsafe YAML deserialization.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "spring-boot-starter-alpha",
        "build-dependencies",
        "snakeyaml"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "rce",
        "yaml-deserialization",
        "transitive-dependency",
        "dos-attack"
      ],
      "severity": "critical",
      "userImpact": "Applications using the Spring Boot starter are exposed to remote code execution and denial of service attacks through unsafe YAML deserialization.",
      "rootCause": "SnakeYaml's Constructor class does not restrict types during deserialization, allowing instantiation of arbitrary classes from untrusted YAML content.",
      "proposedFix": "Upgrade snakeyaml to version 2.0 for CVE-2022-1471 or version 1.31 for CVE-2022-25857, and use SafeConstructor when parsing untrusted YAML.",
      "workaround": "Use SnakeYaml's SafeConstructor class instead of Constructor when parsing untrusted YAML content.",
      "resolution": "stale",
      "resolutionDetails": "Issue was automatically closed by Mend as the vulnerable library was either marked as ignored or is no longer part of the Mend inventory.",
      "related": [],
      "keyQuote": "SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution.",
      "number": 1613,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:19.995Z"
    },
    {
      "summary": "error_prone_core dependency transitively includes protobuf-java-3.19.2 with 3 high-severity vulnerabilities (CVE-2022-3510, CVE-2022-3509, CVE-2022-3171) that can cause denial of service through parsing attacks. The issue was resolved by noting this is a compile-time only dependency not included in runtime.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "build-system",
        "dependency-management",
        "error-prone"
      ],
      "concepts": [
        "vulnerability",
        "protobuf",
        "dependency-injection",
        "denial-of-service",
        "security",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Potential exposure to high-severity protocol buffer parsing vulnerabilities could enable denial of service attacks if the vulnerable library were included in runtime dependencies.",
      "rootCause": "error_prone_core-2.18.0 transitively depends on protobuf-java-3.19.2 which contains unpatched CVE vulnerabilities in message parsing.",
      "proposedFix": "Upgrade protobuf-java to version 3.21.7, 3.20.3, 3.19.6, or 3.16.3 (or later) to resolve all three vulnerabilities.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Determined to be a compile-time only vulnerability since error_prone is not included in Temporal Runtime dependencies, therefore not a security concern for end users.",
      "related": [],
      "keyQuote": "Compile-time vulnerability, error-prone is not a part of Temporal Runtime dependencies",
      "number": 1611,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:05.031Z"
    },
    {
      "summary": "WorkflowStub queries incorrectly target only the first workflow run after the stub is used to start a workflow, instead of following the ContinueAsNew chain and targeting the latest run as expected.",
      "category": "bug",
      "subcategory": "workflow-stub-query",
      "apis": [
        "WorkflowStub"
      ],
      "components": [
        "workflow-stub",
        "query-engine",
        "run-tracking"
      ],
      "concepts": [
        "query-targeting",
        "continue-as-new",
        "workflow-runs",
        "stub-state"
      ],
      "severity": "high",
      "userImpact": "Users unable to query the correct workflow run after using a stub to start a workflow, breaking expected query behavior.",
      "rootCause": "After start call, the WorkflowStub internally tracks the specific runId and targets that run for queries instead of maintaining the default behavior of targeting the latest run.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "if this stub is used to start a workflow, after this start call the query targets the specific run that was started by this stub",
      "number": 1601,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:05.319Z"
    },
    {
      "summary": "Spring Boot autoconfiguration prematurely starts WorkerFactory when a Spring Cloud OpenFeign client bean is autowired into an ActivityImpl component, preventing auto-registration of additional workers.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [
        "WorkerFactory"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "worker-factory",
        "activity-implementation"
      ],
      "concepts": [
        "bean-initialization",
        "lifecycle-management",
        "spring-context-refresh",
        "worker-registration",
        "autowiring"
      ],
      "severity": "high",
      "userImpact": "Users cannot auto-register multiple workers when using Spring Cloud OpenFeign clients with ActivityImpl beans due to premature WorkerFactory startup.",
      "rootCause": "ContextRefreshedEvent triggered during Spring bean autowiring causes WorkerFactory to transition to Started state before all workers can be registered, violating the Initial state requirement.",
      "proposedFix": null,
      "workaround": "Use @Lazy annotation on the autowired FeignClient bean to defer its initialization.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "spring will trigger ContextRefreshedEvent and then, WorkerFactory.State.Started which resulting in no other new workers can be auto registered",
      "number": 1597,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:41:02.623Z"
    },
    {
      "summary": "When @Autowired beans are injected into a bean with @ActivityImpl @Component, the workerFactory.start() is called prematurely, preventing other workers from being auto-registered.",
      "category": "bug",
      "subcategory": "spring-boot-autoconfigure",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "worker-factory",
        "activity-implementation"
      ],
      "concepts": [
        "dependency-injection",
        "bean-autowiring",
        "worker-initialization",
        "auto-registration",
        "startup-ordering"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly register multiple workers when using Spring Boot autowiring with @ActivityImpl components.",
      "rootCause": "RootNamespaceAutoConfiguration prematurely starts workers during bean autowiring, interfering with the auto-registration process.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #1597",
      "related": [
        1597
      ],
      "keyQuote": "when @Autowired other bean into bean with @ActivityImpl @Component, this.workerFactory.start(); gonna start workers so that could not auto register other workers",
      "number": 1596,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:47.813Z"
    },
    {
      "summary": "The workflow_completed metric counter incorrectly counts successful completions of workflow methods (including replays) instead of actual workflow executions. The same issue affects workflow_continue_as_new and workflow_failed counters.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "worker",
        "metrics",
        "workflow-execution"
      ],
      "concepts": [
        "metrics",
        "workflow-completion",
        "replay",
        "task-reporting",
        "server-confirmation"
      ],
      "severity": "medium",
      "userImpact": "Users receive inaccurate workflow completion metrics, making it difficult to monitor actual workflow executions in production.",
      "rootCause": "Metrics are logged when workflow methods complete successfully rather than when the server confirms acceptance of the workflow completion task.",
      "proposedFix": "Worker should log completion metrics only after reporting the workflow task completion to the server and receiving confirmation that the completion was not rejected.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "workflow_completed counter counts successful completion of workflow methods, including replays for example",
      "number": 1590,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:45.822Z"
    },
    {
      "summary": "Three high-severity vulnerabilities (CVE-2022-3510, CVE-2022-3509, CVE-2022-3171) identified in protobuf-java 3.19.2, a transitive dependency of error_prone_core. All three CVEs have CVSS scores of 7.5 and affect denial of service resilience through parsing issues with Protocol Buffer messages.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "build-system",
        "dependency-management",
        "remote-data-encoder"
      ],
      "concepts": [
        "security-vulnerability",
        "protobuf",
        "denial-of-service",
        "transitive-dependency",
        "cvss-score"
      ],
      "severity": "high",
      "userImpact": "Applications using the Java SDK could be vulnerable to denial of service attacks through malformed Protocol Buffer messages.",
      "rootCause": "Parsing issues in protobuf-java 3.19.2 allow conversion of messages between mutable and immutable forms, causing prolonged garbage collection pauses.",
      "proposedFix": "Upgrade protobuf-java to version 3.21.7, 3.20.3, 3.19.6, or 3.16.3.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend; the vulnerable library was either marked as ignored or removed from the Mend inventory in the tracked branch.",
      "related": [],
      "keyQuote": "A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7 can lead to a denial of service attack.",
      "number": 1588,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:50.838Z"
    },
    {
      "summary": "The javadoc for ActivityExecutionContext.getHeartbeatDetails is inaccurateit states the method extracts details from the last failed attempt, but it actually returns updated details on each heartbeat call. Additionally, a new getLastHeartbeatDetails method should be added to match other SDKs and provide access to heartbeat details without automatic updates.",
      "category": "docs",
      "subcategory": "activity-heartbeat",
      "apis": [
        "ActivityExecutionContext.getHeartbeatDetails"
      ],
      "components": [
        "activity-executor",
        "documentation"
      ],
      "concepts": [
        "heartbeat",
        "activity-execution",
        "api-consistency",
        "state-management"
      ],
      "severity": "low",
      "userImpact": "Developers are confused about heartbeat behavior due to inaccurate documentation, and lack a method to retrieve stable heartbeat details across SDK implementations.",
      "rootCause": "Javadoc was not updated when getHeartbeatDetails behavior changed to update on each call rather than returning only last failed attempt details.",
      "proposedFix": "Update javadoc for getHeartbeatDetails to accurately describe current behavior; add new getLastHeartbeatDetails method for cross-SDK consistency.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation corrected and new API method added to match other SDKs.",
      "related": [],
      "keyQuote": "The javadoc for `ActivityExecutionContext.getHeartbeatDetails` says...this is actually updated for each heartbeat call within the activity.",
      "number": 1587,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:33.576Z"
    },
    {
      "summary": "Request to add a worker option allowing the custom data converter to be used for __stack_trace queries instead of always using the default converter.",
      "category": "feature",
      "subcategory": "data-converter",
      "apis": [],
      "components": [
        "worker",
        "data-converter",
        "stack-trace-query"
      ],
      "concepts": [
        "custom-encoding",
        "data-serialization",
        "query-handling",
        "converter-configuration",
        "stack-trace"
      ],
      "severity": "low",
      "userImpact": "Users cannot use their custom data converter for stack trace queries, limiting consistency in serialization behavior across different query types.",
      "rootCause": null,
      "proposedFix": "Add a new worker option to enable custom data converter usage for __stack_trace queries, defaulting to false to maintain backward compatibility.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Make a new worker option that lets the custom data converter be used for `__stack_trace` queries like it is for the rest of the queries if `true`",
      "number": 1586,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:34.677Z"
    },
    {
      "summary": "The gRPC interceptor automatically retries ResourceExhausted errors, but should not retry the specific case where a message exceeds the 4MB size limit. Currently, message-too-large errors are retried unnecessarily and should either be prevented before transmission or handled specially to fail the workflow task immediately.",
      "category": "bug",
      "subcategory": "grpc-communication",
      "apis": [],
      "components": [
        "grpc-interceptor",
        "retry-logic",
        "message-handling"
      ],
      "concepts": [
        "retry",
        "error-handling",
        "message-size",
        "grpc",
        "resource-exhaustion",
        "workflow-task"
      ],
      "severity": "medium",
      "userImpact": "Users experience unnecessary retries and delayed workflow task failures when their activity payloads exceed the 4MB message size limit.",
      "rootCause": "The gRPC interceptor treats all ResourceExhausted errors uniformly as retryable, but message-size-too-large errors should fail immediately rather than retry.",
      "proposedFix": "Either pre-calculate message size to prevent exceeding the limit before transmission, or detect and skip retrying this specific ResourceExhausted error variant by checking the error message.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented special handling to detect gRPC message-size-too-large errors and prevent them from being retried by the interceptor.",
      "related": [
        624
      ],
      "keyQuote": "grpc: received message larger than max (10248653 vs. 4194304) ... We need to stop retrying this one in particular but still retry others.",
      "number": 1585,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:32.811Z"
    },
    {
      "summary": "Request to add query capability to ExternalWorkflowStub, currently only supporting signals. This requires new command and server-side implementation support.",
      "category": "feature",
      "subcategory": "external-workflow-interaction",
      "apis": [
        "ExternalWorkflowStub"
      ],
      "components": [
        "external-workflow-stub",
        "state-machines",
        "command-system"
      ],
      "concepts": [
        "query",
        "external-workflow",
        "command-support",
        "server-implementation",
        "workflow-interaction"
      ],
      "severity": "medium",
      "userImpact": "Users cannot query external workflows and must use activities as a workaround, limiting cross-workflow communication patterns.",
      "rootCause": "Query command and underlying workflow history implementation not available in server state machines for external workflows.",
      "proposedFix": null,
      "workaround": "Use an activity to query an external workflow.",
      "resolution": "wontfix",
      "resolutionDetails": "Marked as wontfix because the feature requires new command and server-side implementation that is outside SDK scope.",
      "related": [],
      "keyQuote": "This is not an SDK issue. ExternalWorkflowStub has an underlying implementation in state machines and produces commands. There is no command and no underlying workflow history baked implementation for query currently.",
      "number": 1584,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:17.675Z"
    },
    {
      "summary": "Timers create non-deterministic execution history when duration is <=0 or >0, causing workflow replay issues. Users need validation checks to prevent this non-deterministic behavior.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "timer",
        "workflow-replay",
        "history"
      ],
      "concepts": [
        "determinism",
        "timer-duration",
        "replay",
        "validation",
        "non-deterministic-errors"
      ],
      "severity": "medium",
      "userImpact": "Users experience non-deterministic errors during internal workflow replay when timer durations are improperly set.",
      "rootCause": "Timer implementation creates different execution history based on duration value boundaries (<=0 vs >0)",
      "proposedFix": "Add validation checks to reduce non-deterministic errors caused by timer duration values",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "timers create a different execution history if timer / sleep duration is <=0 or > 0",
      "number": 1579,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:15.412Z"
    },
    {
      "summary": "Time skipping in TestWorkflowEnvironment fails to advance time for workflows started via signalWithStart when called from an activity. The timer in the second workflow (W2) doesn't complete immediately despite time skipping being enabled.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment",
        "signalWithStart",
        "Worker",
        "workflow.execute",
        "workflow.getHandle"
      ],
      "components": [
        "test-server",
        "time-skipping",
        "workflow-client",
        "signal-with-start"
      ],
      "concepts": [
        "time-skipping",
        "timer",
        "test-environment",
        "workflow-execution",
        "signal-handling",
        "activity-invocation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test workflows that use signalWithStart to start child workflows with timers in time-skipping test environments.",
      "rootCause": "The worker is shut down before the second workflow gets a chance to complete, preventing proper time advancement for workflows started via signalWithStart from activities.",
      "proposedFix": "Ensure the worker remains active long enough for all started workflows to complete, or improve time-skipping coordination for dynamically started workflows.",
      "workaround": "Reconfigure the WorkflowClient used in activities to use the time-skipping workflow client via interceptors, though this may not fully resolve the issue.",
      "resolution": "fixed",
      "resolutionDetails": "Identified that worker shutdown timing was the root cause; user confirmed reproduction case.",
      "related": [],
      "keyQuote": "Looks like the worker in this example is shut down before the second workflow gets a chance to complete.",
      "number": 1565,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:20.573Z"
    },
    {
      "summary": "Spring Boot Starter 2.7.6 contains 7 vulnerabilities in the transitive SnakeYAML 1.30 dependency, including a critical remote code execution flaw (CVE-2022-1471 with CVSS 9.8). Most vulnerabilities have fixes available in Spring Boot 3.0.0, but one (CVE-2022-1471) has no direct fix path.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "snakeyaml",
        "dependency-management"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "remote-code-execution",
        "deserialization",
        "dependency-upgrade",
        "transitive-dependency"
      ],
      "severity": "critical",
      "userImpact": "Users relying on spring-boot-starter 2.7.6 are exposed to critical remote code execution vulnerabilities that can be exploited over the network.",
      "rootCause": "SnakeYAML 1.30 Constructor class does not restrict types during deserialization, allowing arbitrary code execution. Additionally, missing nested depth limitation for collections enables denial of service attacks.",
      "proposedFix": "Upgrade Spring Boot Starter to 3.0.0 or later, which upgrades SnakeYAML to a patched version. For CVE-2022-1471, use SnakeYAML's SafeConstructor when parsing untrusted content.",
      "workaround": "Use SnakeYAML's SafeConstructor instead of the standard Constructor when parsing untrusted YAML content.",
      "resolution": "invalid",
      "resolutionDetails": "Automatically closed by Mend because the vulnerable library was no longer part of the Mend inventory or was marked as ignored in the branch.",
      "related": [],
      "keyQuote": "SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution.",
      "number": 1564,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:04.803Z"
    },
    {
      "summary": "Local Activity Execution continues making retry attempts even after the parent Workflow Task fails, potentially causing orphaned activities to retry indefinitely if no scheduleToClose timeout is set or it's very long.",
      "category": "bug",
      "subcategory": "local-activity-execution",
      "apis": [],
      "components": [
        "local-activity-executor",
        "workflow-task-lifecycle",
        "retry-mechanism"
      ],
      "concepts": [
        "lifecycle-awareness",
        "failure-propagation",
        "orphaned-activity",
        "retry-exhaustion",
        "task-coordination"
      ],
      "severity": "high",
      "userImpact": "Users may experience unexpected prolonged retry behavior and resource waste when local activities continue executing after their parent workflow task fails.",
      "rootCause": "Local Activity Execution does not monitor the lifecycle state of the Workflow Task that initiated it, so it cannot detect when that task has failed and should stop retrying.",
      "proposedFix": "Local Activity Execution should be enhanced to track and respect the Workflow Task lifecycle, stopping retry attempts when the parent task fails.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1303
      ],
      "keyQuote": "Local Activity will continue execution. If there is no `scheduleToClose` timeout set or `scheduleToClose` is long, such an orphan local activity can retry for a long time.",
      "number": 1563,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:01.238Z"
    },
    {
      "summary": "User requests that OriginalExecutionRunID be included in the Workflow info returned by the SDK. Currently, this field is not accessible through searchable attributes or the workflow info API.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-runtime",
        "metadata-service"
      ],
      "concepts": [
        "execution-history",
        "workflow-metadata",
        "run-identity",
        "state-tracking"
      ],
      "severity": "low",
      "userImpact": "Users cannot access OriginalExecutionRunID information needed for workflow lifecycle tracking and analysis.",
      "rootCause": null,
      "proposedFix": "Expose OriginalExecutionRunID as a field in the WorkflowInfo class returned by the SDK.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "OriginalExecutionRunID was added to WorkflowInfo in a subsequent SDK release.",
      "related": [],
      "keyQuote": "Please return OriginalExecutionRunID in Workflow info",
      "number": 1562,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:40:03.879Z"
    },
    {
      "summary": "Unregistered local activities should fail the workflow task instead of failing at activity execution time. This ensures that missing local activity registrations are caught early during workflow execution rather than at the activity execution stage.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "worker",
        "local-activity-executor",
        "workflow-task-processor"
      ],
      "concepts": [
        "registration",
        "local-activities",
        "error-handling",
        "workflow-task",
        "validation"
      ],
      "severity": "medium",
      "userImpact": "Users will receive clearer error feedback when they forget to register a local activity, helping them catch configuration mistakes during workflow execution.",
      "rootCause": "Local activities are not validated for registration at workflow task execution time, only at activity execution time.",
      "proposedFix": "Fail the workflow task when attempting to execute an unregistered local activity instead of deferring the error to activity execution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Workflow task now fails if a local activity is not registered with the worker, providing early validation.",
      "related": [],
      "keyQuote": "We should fail workflow task if workflow code requests the execution of a local activity that is not registered with the worker.",
      "number": 1561,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:49.255Z"
    },
    {
      "summary": "Kotlin Standard Library version 1.4.32 contains CVE-2022-24329, a medium severity (CVSS 5.3) vulnerability related to dependency locking in Multiplatform Gradle Projects. The vulnerability is in a transitive dependency and can be fixed by upgrading to Kotlin 1.6.0 or later.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "kotlin-stdlib",
        "gradle",
        "build-system"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-management",
        "transitive-dependency",
        "cvss-scoring",
        "gradle-multiplatform"
      ],
      "severity": "medium",
      "userImpact": "Projects using the Java SDK may expose compiled code to a medium severity integrity vulnerability in the Kotlin Standard Library dependency.",
      "rootCause": "Kotlin Standard Library version 1.4.32 lacks proper dependency locking mechanisms for Multiplatform Gradle Projects (CVE-2022-24329).",
      "proposedFix": "Upgrade kotlin-stdlib-jdk8 from 1.4.32 to 1.6.0 or later to resolve the vulnerability.",
      "workaround": "Use modern Kotlin versions in runtime environments to mitigate compile-time vulnerabilities.",
      "resolution": "fixed",
      "resolutionDetails": "Addressed by upgrading the Kotlin Standard Library dependency to a version >= 1.6.0, which includes the fix for CVE-2022-24329.",
      "related": [],
      "keyQuote": "Compile-time vulnerability, users should use modern Kotlin versions in their runtimes.",
      "number": 1559,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:47.044Z"
    },
    {
      "summary": "ReplayAwareLogger incorrectly identifies workflow as replaying when handling ActivityFailure with CanceledFailure cause, causing incorrect logging behavior and breaking mutableSideEffect calls in detached CancellationScopes.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "ExecuteActivity",
        "mutableSideEffect"
      ],
      "components": [
        "ReplayAwareLogger",
        "WorkflowStateMachines",
        "MutableSideEffectStateMachine",
        "WorkflowUnsafe"
      ],
      "concepts": [
        "replay-mode",
        "activity-cancellation",
        "state-machine",
        "event-loop",
        "workflow-execution",
        "side-effects"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably use mutableSideEffect or logging in detached CancellationScopes when activities are canceled, and workflow replay state becomes incorrect.",
      "rootCause": "In WorkflowStateMachines.scheduleActivityTask, when an activity throws CanceledFailure, the event loop runs prematurely while the workflow is still in replaying state, rather than waiting for WorkflowTaskScheduled/WorkflowTaskStarted events to complete event history processing.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When that if statement evaluates to true (meaning the activity has thrown a CanceledFailure), and the event loop is allowed to run, it causes the Workflow to make progress while it is still in the replaying state",
      "number": 1558,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:49.300Z"
    },
    {
      "summary": "Request to return NamespaceNotFoundFailure error details when DescribeNamespace is called for an unknown namespace, and support other missing error details from the Temporal API.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "DescribeNamespace"
      ],
      "components": [
        "namespace-client",
        "error-details",
        "grpc-status"
      ],
      "concepts": [
        "error-handling",
        "namespace-validation",
        "gRPC-status-details",
        "error-codes",
        "API-compliance"
      ],
      "severity": "low",
      "userImpact": "Users cannot reliably detect when a namespace doesn't exist, as no error is raised in DescribeNamespace calls.",
      "rootCause": "Test Server intentionally supports all namespaces for user convenience, deviating from regular server behavior.",
      "proposedFix": "Return not-found error with NamespaceNotFoundFailure in gRPC status details; implement other missing error details from temporal/api/errordetails/v1/message.proto.",
      "workaround": "Skip test server validation for unregistered namespace tests.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed as intentional deviation - Test Server supports all namespaces by design for user convenience.",
      "related": [],
      "keyQuote": "Right now Test Server supports all namespaces as registered for user convenience. It's a design choice.",
      "number": 1557,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:31.852Z"
    },
    {
      "summary": "Add public FailureConverter API to allow customizing error-to-failure conversion with support for encrypting failure attributes like message and stack trace. This API was already implemented in the other 3 major SDKs.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "FailureConverter",
        "DefaultFailureConverter",
        "error-conversion"
      ],
      "concepts": [
        "error-handling",
        "failure-conversion",
        "encryption",
        "customization",
        "cross-sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently customize how errors are converted to failures or encrypt sensitive failure attributes, limiting security and flexibility in error handling.",
      "rootCause": null,
      "proposedFix": "Implement public FailureConverter API with DefaultFailureConverter supporting encryption of common failure attributes (message, stack_trace).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "FailureConverter API was implemented to match the other major SDKs, allowing customization of error-to-failure conversion and encryption of failure attributes.",
      "related": [],
      "keyQuote": "Add public `FailureConverter` API to allow customizing error <-> failure conversion and `DefaultFailureConverter` implementation that supports encrypting common failure attributes",
      "number": 1553,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:29.474Z"
    },
    {
      "summary": "Add a high-level API to WorkflowClient for listing workflows and fetching their execution histories. This feature is needed for the SDK's safe rollout capability and should provide user-friendly access to workflow listings with optional concurrency support for history fetching.",
      "category": "feature",
      "subcategory": "workflow-client-api",
      "apis": [
        "WorkflowClient",
        "WorkflowExecution",
        "DescribeWorkflowExecutionResponse",
        "History"
      ],
      "components": [
        "WorkflowClient",
        "WorkflowExecution",
        "history-fetching"
      ],
      "concepts": [
        "listing-workflows",
        "workflow-execution",
        "history-replay",
        "pagination",
        "concurrency",
        "mass-replayer"
      ],
      "severity": "medium",
      "userImpact": "Users gain a safe, user-friendly API to list and fetch workflow histories without direct protobuf manipulation.",
      "rootCause": null,
      "proposedFix": "Add WorkflowClient.list(String query) returning Stream<WorkflowExecution>, WorkflowClient.describe() for individual workflows, and WorkflowClient.fetchHistoryEvents() for history fetching with concurrency support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "High-level API was implemented in Java SDK following the design suggested in the issue comments, providing WorkflowExecution and WorkflowExecutionDescription wrappers.",
      "related": [],
      "keyQuote": "Add `WorkflowClient.list(String query)` that returns `Stream<WorkflowExecution>`. I don't expect people to care about options to this function at this time (can add overloads later).",
      "number": 1552,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:34.067Z"
    },
    {
      "summary": "User encounters error when implementing generic workflow interfaces with inheritance. The SDK throws a \"multiple signal method found\" error when creating workflow stubs for implementations that inherit from a generic TranslationWorkflow interface with type parameters.",
      "category": "bug",
      "subcategory": "workflow-definition",
      "apis": [
        "WorkflowMethod"
      ],
      "components": [
        "workflow-stub",
        "workflow-interface",
        "type-system"
      ],
      "concepts": [
        "generics",
        "inheritance",
        "interface-override",
        "workflow-method-resolution"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use generic interfaces to define shared workflow logic across multiple concrete workflow implementations.",
      "rootCause": "The Java SDK does not support generics in workflow interface definitions. The reflection-based method resolution finds both the generic method and the overridden concrete method, resulting in duplicate signal method detection.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #1106. The core limitation is that generics are not supported by the SDK.",
      "related": [
        1106
      ],
      "keyQuote": "Generics are not supported. What is the R type?",
      "number": 1551,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:17.809Z"
    },
    {
      "summary": "Spring Boot auto-configuration doesn't support dynamic or interpolated task queues. Users need the ability to set task queues programmatically or through property resolution in the WorkersTemplate, similar to how activities can be registered to multiple queues in samples.",
      "category": "feature",
      "subcategory": "spring-boot-configuration",
      "apis": [
        "WorkersTemplate",
        "ActivityImpl"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "WorkersTemplate",
        "annotation-processing"
      ],
      "concepts": [
        "dynamic-configuration",
        "property-interpolation",
        "task-queues",
        "auto-discovery",
        "programmatic-setup"
      ],
      "severity": "medium",
      "userImpact": "Users adopting Spring Boot auto-configuration cannot dynamically assign activities to multiple task queues or use property-based configuration, forcing them to choose between auto-discovery convenience and configuration flexibility.",
      "rootCause": "WorkersTemplate lacks a resolver function mechanism for task queues and doesn't support property value interpolation in annotations, limiting it to static hardcoded string lists.",
      "proposedFix": "Introduce a resolver function mechanism in WorkersTemplate similar to JUnit's @ParameterizedTest @MethodSource pattern, and add property value interpolation support to task queue annotations.",
      "workaround": "Users can use explicit configuration instead of auto-discovery by package, or bypass Spring Boot entirely and configure WorkerFactory programmatically.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by issue #1623, which likely implemented support for dynamic task queue configuration in the Spring Boot auto-configuration module.",
      "related": [
        1623
      ],
      "keyQuote": "The WorkersTemplate doesn't have a way to delegate taskQueues to a resolver function. Ideally, it would work similar to how JUnit's @ParameterizedTest + @MethodSource works.",
      "number": 1550,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:17.830Z"
    },
    {
      "summary": "Workflow MetricScope should prevent metric reporting after instance destruction is requested, avoiding double-reporting in finally blocks during workflow eviction due to DestroyWorkflowThreadError.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [
        "getMetricsScope"
      ],
      "components": [
        "workflow-runtime",
        "metrics-scope",
        "thread-destruction"
      ],
      "concepts": [
        "metrics-reporting",
        "workflow-lifecycle",
        "finally-blocks",
        "destruction",
        "double-reporting"
      ],
      "severity": "medium",
      "userImpact": "Users experience duplicate metric reports when using MetricScope in finally blocks, complicating metrics analysis and monitoring.",
      "rootCause": "DestroyWorkflowThreadError triggers finally blocks after instance destruction is requested, causing metrics to be reported to an invalidated scope.",
      "proposedFix": "Make workflow's MetricScope aware of pending destruction and silently ignore metric reporting attempts after destruction is requested.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal SDK should make workflow's MetricsScope aware of the fact that the instance destruction is requested and not allow any new metric's reporting",
      "number": 1549,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:14.557Z"
    },
    {
      "summary": "User requests a way to configure TLS server settings for Java SDK connections, similar to the Go SDK's ConnectionOptions. They need to connect through a TLS server to obtain certificates before connecting to the Temporal cluster.",
      "category": "question",
      "subcategory": "tls-configuration",
      "apis": [
        "ServiceStubsOptions",
        "ManagedChannelBuilder"
      ],
      "components": [
        "client",
        "grpc-channel",
        "tls-config"
      ],
      "concepts": [
        "tls",
        "certificate",
        "connection-options",
        "grpc-configuration",
        "server-name"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily configure TLS server names for Java SDK connections without manually intercepting gRPC channel creation.",
      "rootCause": "Java SDK lacks direct TLS server name configuration option equivalent to Go SDK's ConnectionOptions.TLS.ServerName.",
      "proposedFix": "Provide a TLS configuration option in Java SDK connection settings, similar to Go SDK's approach.",
      "workaround": "Use ServiceStubsOptions#setChannelInitializer to intercept gRPC's ManagedChannelBuilder and call overrideAuthority to set custom TLS server name.",
      "resolution": "invalid",
      "resolutionDetails": "Issue was resolved by providing a workaround. The user was redirected to use the channel initializer pattern and advised to use Temporal community channels for questions.",
      "related": [],
      "keyQuote": "Use `ServiceStubsOptions#setChannelInitializer` to intercept the creation of gRPC's `ManagedChannelBuilder`... you can set a custom tls server name in `ManagedChannelBuilder#overrideAuthority`.",
      "number": 1541,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:00.483Z"
    },
    {
      "summary": "Time skipping in child workflows doesn't work when a parent workflow uses continue-as-new. The test service fails to skip time for Workflow.sleep calls in child workflows after the parent continues as new.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.sleep",
        "continueAsNew"
      ],
      "components": [
        "test-service",
        "child-workflow",
        "time-skipping"
      ],
      "concepts": [
        "time-skipping",
        "child-workflow",
        "continue-as-new",
        "workflow-execution",
        "test-framework",
        "timing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably test workflows with child workflows that use continue-as-new, as time skipping breaks in the child workflow execution.",
      "rootCause": "Time skipping mechanism doesn't properly handle the state transition when a parent workflow executes continue-as-new before child workflow time skipping occurs.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1539,
        1618
      ],
      "keyQuote": "When a parent calls continue-as-new time skipping in a child is not happening.",
      "number": 1540,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:39:00.608Z"
    },
    {
      "summary": "The test server's continue-as-new implementation is not atomic, causing signals sent to a workflow executing continue-as-new to be rejected with NOT_FOUND errors instead of being reliably delivered.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "test-server",
        "signal-handler",
        "workflow-state"
      ],
      "concepts": [
        "atomicity",
        "signal-delivery",
        "race-condition",
        "continue-as-new",
        "workflow-lifecycle",
        "state-transition"
      ],
      "severity": "high",
      "userImpact": "Tests using continue-as-new with signal sending may experience flaky failures due to signals being incorrectly rejected.",
      "rootCause": "The test server's continue-as-new implementation does not atomically handle the workflow state transition, creating a race condition where signals sent during the transition are not found.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1537
      ],
      "keyQuote": "Signal sender can receive NOT_FOUND if it is sent while target workflow is executing continue-as-new.",
      "number": 1538,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:57.376Z"
    },
    {
      "summary": "Activity stub throws IllegalArgumentException when toString() is called, as the method invocation handler doesn't recognize Object methods that aren't defined in the activity interface. The same issue affects workflow stubs.",
      "category": "bug",
      "subcategory": "activity-stubs",
      "apis": [],
      "components": [
        "activity-stub",
        "activity-invocation-handler",
        "metadata-processing",
        "proxy-generation"
      ],
      "concepts": [
        "object-methods",
        "proxy-behavior",
        "method-resolution",
        "interface-metadata",
        "stub-configuration"
      ],
      "severity": "high",
      "userImpact": "Users cannot call toString() on activity or workflow stubs, and implicit toString() calls (e.g., in logging or string concatenation) cause the application to crash.",
      "rootCause": "The ActivityInvocationHandlerBase only recognizes methods defined in the activity interface, rejecting inherited Object methods like toString() that should be handled by the proxy.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The invocation handler was modified to properly handle Object methods like toString(), equals(), and hashCode() that are inherited by all Java objects.",
      "related": [],
      "keyQuote": "Call toString on any activity stub.",
      "number": 1536,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:44.508Z"
    },
    {
      "summary": "TestWorkflowRule timeout diagnostics need improvement to include DescribeWorkflowExecution results, stack traces for open workflows, and better formatting to help troubleshoot stuck tests.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "DescribeWorkflowExecution"
      ],
      "components": [
        "TestWorkflowRule",
        "test-framework",
        "diagnostics"
      ],
      "concepts": [
        "timeout",
        "debugging",
        "diagnostics",
        "test-failure",
        "workflow-execution",
        "activity-retry"
      ],
      "severity": "medium",
      "userImpact": "Users debugging stuck JUnit tests receive incomplete diagnostic information, making it harder to identify the root cause of test timeouts.",
      "rootCause": null,
      "proposedFix": "Enhance TestWorkflowRule to include DescribeWorkflowExecution results for each workflow, stack trace queries for open workflows, and improved output formatting.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This is useful, but misses a lot of useful information that could be used to troubleshoot a stuck test problem.",
      "number": 1535,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:41.438Z"
    },
    {
      "summary": "Local activities that throw Java Errors fail with RETRY_STATE_INTERNAL_SERVER_ERROR instead of immediately failing the WorkflowTask. Errors should signal worker problems and cause workflow task failure rather than activity execution failure.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "local-activity-executor",
        "workflow-task-handler",
        "error-handling"
      ],
      "concepts": [
        "error-handling",
        "local-activities",
        "workflow-task",
        "worker-failure",
        "retry-logic"
      ],
      "severity": "high",
      "userImpact": "Errors in local activities are incorrectly handled as activity failures instead of worker failures, leading to incorrect workflow behavior and retry logic.",
      "rootCause": "Local activity execution does not distinguish between activity errors and JVM errors, treating Error exceptions the same as Activity exceptions.",
      "proposedFix": "Local activity executor should catch Java Errors and immediately fail the WorkflowTask instead of failing the activity execution with RETRY_STATE_INTERNAL_SERVER_ERROR.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Error handling in local activities was corrected to fail the WorkflowTask when Java Errors occur.",
      "related": [],
      "keyQuote": "If Local Activity throws an Error, it should immediately fail Workflow Task. Java Error signals a problem with the Worker and shouldn't lead to a failure of a Local Activity execution or a Workflow.",
      "number": 1533,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:39.874Z"
    },
    {
      "summary": "The javadoc.jar artifact for temporal-serviceclient does not include documentation for classes in the io.temporal.api package, even though the compiled jar contains these classes. Users need complete javadoc coverage across all packages.",
      "category": "other",
      "subcategory": "javadoc-distribution",
      "apis": [],
      "components": [
        "temporal-serviceclient",
        "javadoc-generation",
        "artifact-distribution"
      ],
      "concepts": [
        "documentation",
        "javadoc",
        "artifact-completeness",
        "api-package",
        "distribution",
        "consistency"
      ],
      "severity": "low",
      "userImpact": "Developers cannot access javadoc documentation for io.temporal.api classes, reducing discoverability and usability of the SDK.",
      "rootCause": "The javadoc generation or aggregation process excludes the io.temporal.api package from the distributed javadoc.jar.",
      "proposedFix": "Include io.temporal.api package documentation in the distributed javadoc.jar artifact to match the compiled jar contents.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by including io.temporal.api documentation in javadoc.jar distribution.",
      "related": [],
      "keyQuote": "The artifact temporal-serviceclient.jar contains classes in the package io.temporal.api, however the javadoc.jar artifact does not contain documentation",
      "number": 1532,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:24.132Z"
    },
    {
      "summary": "Feature request to support declaring ActivityStub instances using Spring annotations instead of requiring manual Workflow.newActivityStub() calls. This would integrate with Temporal-Springboot-alpha to enable declarative activity stub configuration with retry options.",
      "category": "feature",
      "subcategory": "spring-integration",
      "apis": [
        "newActivityStub"
      ],
      "components": [
        "spring-boot-starter",
        "activity-stub",
        "dependency-injection"
      ],
      "concepts": [
        "annotation",
        "dependency-injection",
        "activity-configuration",
        "retry-options",
        "spring-integration",
        "declarative-programming"
      ],
      "severity": "low",
      "userImpact": "Developers using Temporal-Springboot-alpha must manually create activity stubs in workflows instead of using simpler Spring annotations, reducing code clarity and reusability.",
      "rootCause": null,
      "proposedFix": "@ActivityStub annotation that accepts taskQueue and retryOptions parameters for declarative activity stub configuration in Spring-managed workflows",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Can we declare ActivityStub using an annotation? Something like @ActivityStub(taskQueue = SOME_QUEUE, retryOptions = @RetryActivityOptions(...))",
      "number": 1531,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:26.446Z"
    },
    {
      "summary": "User asks how to gracefully shut down a Temporal worker in Java SDK without data loss or corruption, and whether steps/tasks can be re-executed.",
      "category": "question",
      "subcategory": "worker-lifecycle",
      "apis": [
        "WorkerFactory#shutdown"
      ],
      "components": [
        "worker",
        "worker-factory"
      ],
      "concepts": [
        "graceful-shutdown",
        "data-loss",
        "worker-lifecycle",
        "resource-cleanup"
      ],
      "severity": "low",
      "userImpact": "Users need to understand proper worker shutdown procedures to prevent data loss in production environments.",
      "rootCause": null,
      "proposedFix": "Use WorkerFactory#shutdown() method for graceful worker shutdown",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by providing documentation link and pointing user to WorkerFactory#shutdown() method",
      "related": [],
      "keyQuote": "JavaSDK has `WorkerFactory#shutdown` method that allows to gracefully shutdown workers.",
      "number": 1522,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:26.661Z"
    },
    {
      "summary": "Request to add a num_pollers gauge metric to track the number of concurrent active activity and workflow pollers, as implemented in the Core SDK. This metric is needed to monitor poller activity separately for different poller types.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "poller",
        "worker"
      ],
      "concepts": [
        "monitoring",
        "gauge",
        "concurrency",
        "activity-pollers",
        "workflow-pollers",
        "observability"
      ],
      "severity": "low",
      "userImpact": "Users can monitor the number of active pollers to better understand worker utilization and performance characteristics.",
      "rootCause": null,
      "proposedFix": "Implement num_pollers gauge metric that distinguishes between activity pollers and workflow pollers, following the Core SDK implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Metric was implemented to expose concurrent active poller counts, with separate tracking for activity and workflow pollers as documented in the SDK metrics reference.",
      "related": [],
      "keyQuote": "Need to be able to tell how many activity pollers and how many workflow pollers.",
      "number": 1519,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:06.018Z"
    },
    {
      "summary": "Multiple tests in a test class fail when run together due to shared static activity stubs between workflow instances, though each test passes individually. The mocking setup fails for subsequent tests because activity stubs cannot be shared across workflow instances.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.newActivityStub",
        "TestWorkflowEnvironment",
        "WorkflowClient"
      ],
      "components": [
        "test-framework",
        "activity-stub",
        "workflow-instance",
        "mocking"
      ],
      "concepts": [
        "test-isolation",
        "shared-state",
        "activity-mocking",
        "stub-lifecycle",
        "test-ordering",
        "mockito-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot run multiple tests with mocked activities in the same test class because shared static stubs cause mocking to fail after the first test.",
      "rootCause": "Activity stubs are created as static fields and shared between multiple workflow instances, which violates the SDK requirement that stubs must be created per-workflow-instance.",
      "proposedFix": "Remove the `static` modifier from the activity stub field or move stub creation inside the workflow method instead of initializing it at class load time.",
      "workaround": "Create activity stubs inside the workflow method (non-static) rather than as static class fields.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by identifying that activity stubs cannot be shared between workflow instances. The solution is to create stubs per-workflow-instance rather than statically.",
      "related": [
        746
      ],
      "keyQuote": "stubs can't be shared between workflow instances. They need to be created during workflow instance initialization in a workflow code.",
      "number": 1518,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:11.074Z"
    },
    {
      "summary": "Spring Boot dependency spring-boot-dependencies-2.7.5.pom contains 7 vulnerabilities in the transitive snakeyaml-1.30 dependency, with the highest severity at 9.8 (CVE-2022-1471 remote code execution). Issue was automatically closed when the vulnerable library was removed from the Mend inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "dependency-management",
        "snakeyaml",
        "yaml-parsing"
      ],
      "concepts": [
        "vulnerability",
        "security",
        "deserialization",
        "remote-code-execution",
        "transitive-dependency",
        "supply-chain",
        "yaml-parsing"
      ],
      "severity": "critical",
      "userImpact": "Users of the spring-boot-starter could be vulnerable to remote code execution if untrusted YAML content is deserialized, requiring immediate dependency upgrades.",
      "rootCause": "SnakeYaml Constructor class does not restrict types during deserialization, allowing arbitrary object instantiation from malicious YAML input.",
      "proposedFix": "Upgrade snakeyaml to version 1.31 or later, or use SnakeYaml's SafeConstructor when parsing untrusted content.",
      "workaround": "Use SafeConstructor instead of Constructor for parsing untrusted YAML content.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was removed from the inventory, indicating the spring-boot-dependencies version was updated to exclude snakeyaml-1.30.",
      "related": [],
      "keyQuote": "Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content.",
      "number": 1516,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:38:10.043Z"
    },
    {
      "summary": "Request to add scheduleToStart timeout configuration to LocalActivityOptions in the Java SDK. Local Activity Workers can become saturated like regular Activity Workers, and the SDK should provide a way to set and limit the scheduleToStart duration for local activities.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activities",
        "activity-worker",
        "options"
      ],
      "concepts": [
        "timeout",
        "scheduling",
        "saturation",
        "backpressure",
        "worker-capacity"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently set timeout limits on local activity scheduling, leaving local activity workers vulnerable to saturation without explicit time-based constraints.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to add scheduleToStart timeout support to LocalActivityOptions",
      "related": [],
      "keyQuote": "Local Activities Workers can be saturated in the same way as a regular Activity Workers. Temporal SDK should provide a way to set and limit `scheduleToStart` for Local Activities.",
      "number": 1512,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:50.425Z"
    },
    {
      "summary": "Request to add cron jitter support to avoid all scheduled workflows starting simultaneously. User currently implements workaround at application level, citing similar functionality in Cadence SDK.",
      "category": "feature",
      "subcategory": "cron-scheduling",
      "apis": [],
      "components": [
        "cron-scheduler",
        "workflow-execution"
      ],
      "concepts": [
        "scheduling",
        "jitter",
        "concurrency-control",
        "load-distribution"
      ],
      "severity": "low",
      "userImpact": "Users must implement cron jitter workarounds at application level to prevent thundering herd scenarios with scheduled workflows.",
      "rootCause": null,
      "proposedFix": "Implement jitter parameter in cron scheduling similar to Cadence SDK implementation",
      "workaround": "Handle jittering at application level",
      "resolution": "wontfix",
      "resolutionDetails": "Existing cron functionality will not evolve; team is developing a new flexible scheduling API to replace it",
      "related": [],
      "keyQuote": "Existing cron functionality will not evolve, the internal implementation and the whole experience are quite finicky. We are working on a brand new fully revisited flexible scheduling API",
      "number": 1511,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:49.177Z"
    },
    {
      "summary": "Local activity worker polling is being incorrectly suspended, causing workflow tasks with local activities to get stuck in heartbeat loops. Additionally, during graceful shutdown, activities dispatched by the server may fail to execute because the worker's long-poll thread can be interrupted after the server registers the attempt but before the task is received.",
      "category": "bug",
      "subcategory": "worker-shutdown",
      "apis": [],
      "components": [
        "worker",
        "local-activity-poller",
        "long-poll-thread",
        "graceful-shutdown"
      ],
      "concepts": [
        "polling",
        "graceful-shutdown",
        "heartbeat-loop",
        "task-dispatch",
        "thread-interruption",
        "distributed-activities"
      ],
      "severity": "high",
      "userImpact": "Users experience workflow tasks with local activities getting stuck without making progress and activities failing to execute during worker shutdown.",
      "rootCause": "worker.suspendPolling stops local activity worker from polling, and worker long-poll thread can be interrupted after server registers an activity attempt but before the worker receives the task.",
      "proposedFix": "Local activity poller should never stop polling since it's an implementation detail. Server should handle the scenario by sending CANCELLED and potentially registering an activity failure when dispatch occurs during shutdown.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the graceful shutdown problems were addressed",
      "related": [],
      "keyQuote": "Local activity poller should never stop polling. Local activity poller is an implementation detail and the only source it polls from is an internal worker queue.",
      "number": 1510,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:53.746Z"
    },
    {
      "summary": "Epic tracking improvements and bugs related to custom Data Converter, Payload Converter, and Payload Codec implementations in the Java SDK.",
      "category": "feature",
      "subcategory": "data-conversion",
      "apis": [],
      "components": [
        "data-converter",
        "payload-converter",
        "payload-codec"
      ],
      "concepts": [
        "serialization",
        "custom-converters",
        "payload-encoding",
        "codec",
        "extensibility"
      ],
      "severity": "medium",
      "userImpact": "Users implementing custom data converters and payload codecs need improvements and bug fixes to properly handle workflow data serialization.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because the repository decided to discontinue using GitHub issues as epics.",
      "related": [
        1373,
        1345,
        1301,
        1586,
        1694
      ],
      "keyQuote": "Closing since we no longer want to use GH issues as epics",
      "number": 1509,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:27.100Z"
    },
    {
      "summary": "IllegalStateException occurs when a signal is received at the exact moment a workflow calls ContinuedAsNew, causing the signal to be processed after the workflow closes, leading to repeated workflow task failures during replay.",
      "category": "bug",
      "subcategory": "signal-handling",
      "apis": [
        "ContinuedAsNew"
      ],
      "components": [
        "signal-handler",
        "workflow-task",
        "cancellation-scope"
      ],
      "concepts": [
        "signal-timing",
        "workflow-closure",
        "task-replay",
        "continueasnew",
        "race-condition"
      ],
      "severity": "high",
      "userImpact": "Workflows fail with IllegalStateException when signals coincide with ContinuedAsNew calls, requiring workflow restart and causing repeated task failures.",
      "rootCause": "Signal arrives at the same time workflow calls ContinuedAsNew; the signal is extended as UnhandledCommand, but on the next workflow task execution, processing the signal against the closed workflow scope causes an IllegalStateException.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Testing on the latest SDK version confirmed the issue no longer occurs, indicating the bug was fixed in a subsequent release.",
      "related": [],
      "keyQuote": "Seems that when a signal comes in at same time as workflow calls continueasnew, worker raises UnhandledCommand to extend the workflow task",
      "number": 1505,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:31.998Z"
    },
    {
      "summary": "Worker configured without any registered activity implementations should not request eager activity dispatch, as there is no activity worker to handle them. This prevents unnecessary overhead and aligns with Core SDK behavior.",
      "category": "bug",
      "subcategory": "activity-worker",
      "apis": [],
      "components": [
        "activity-worker",
        "worker-configuration"
      ],
      "concepts": [
        "eager-dispatch",
        "activity-registration",
        "worker-initialization",
        "resource-optimization"
      ],
      "severity": "medium",
      "userImpact": "Workers without activities configured were unnecessarily requesting eager activity dispatch, causing inefficient resource usage.",
      "rootCause": "Activity worker was requesting eager activity dispatch regardless of whether any activities were registered.",
      "proposedFix": "Check if activity worker has registered activities before requesting eager activity dispatch, matching Core SDK implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Already implemented correctly in ActivityWorker.java at the time of issue creation, validated through code review.",
      "related": [],
      "keyQuote": "Such workers should never request eager activity dispatch, as there is no activity worker to handle them.",
      "number": 1504,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:29.510Z"
    },
    {
      "summary": "Request to implement multi-history replay support for the Java SDK, matching existing functionality in TypeScript and Python SDKs. This allows testing workflows against multiple historical execution paths.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "test-framework",
        "workflow-executor",
        "replay-engine"
      ],
      "concepts": [
        "replay",
        "multi-history",
        "testing",
        "workflow-execution",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "Java SDK users cannot test workflows against multiple historical paths like TS/Python users can, limiting test coverage capabilities.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Multi-history replay support was implemented in the Java SDK to achieve feature parity with TypeScript and Python SDKs.",
      "related": [],
      "keyQuote": "Multi-history replay support a-la what's already been done in TS/Python",
      "number": 1494,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:10.416Z"
    },
    {
      "summary": "Spring Boot Starter dependency contains 7 vulnerabilities in SnakeYAML 1.30, including critical remote code execution via deserialization (CVE-2022-1471) and denial of service issues. All vulnerabilities are fixable by upgrading to Spring Boot 3.0.0.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "snakeyaml",
        "dependency-management"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "deserialization",
        "remote-code-execution",
        "denial-of-service",
        "dependency-upgrade"
      ],
      "severity": "critical",
      "userImpact": "Applications using the Spring Boot Starter are exposed to remote code execution and denial of service attacks through unsafe YAML deserialization.",
      "rootCause": "SnakeYAML 1.30 Constructor class does not restrict types during deserialization, allowing arbitrary object instantiation from untrusted YAML content.",
      "proposedFix": "Upgrade Spring Boot Starter to version 3.0.0 or use SnakeYAML's SafeConstructor when parsing untrusted content.",
      "workaround": "Use SnakeYAML SafeConstructor instead of default Constructor for parsing untrusted YAML.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was removed from inventory or marked as ignored.",
      "related": [],
      "keyQuote": "SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution.",
      "number": 1493,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:13.728Z"
    },
    {
      "summary": "Scala method references passed to Async.function() are not properly detected as async workflow method calls, causing them to be submitted as regular functions instead, which leads to excessive thread creation and RejectedExecutionException. The issue is in MethodReferenceDisassembler which only checks for REF_invokeInterface, but Scala uses REF_invokeStatic.",
      "category": "bug",
      "subcategory": "async-workflow-execution",
      "apis": [
        "Async.function",
        "Workflow.newChildWorkflowStub"
      ],
      "components": [
        "MethodReferenceDisassembler",
        "async-execution",
        "method-reference-detection",
        "scala-interop"
      ],
      "concepts": [
        "method-references",
        "scala-compatibility",
        "thread-pool-exhaustion",
        "lambda-introspection",
        "workflow-invocation",
        "interop"
      ],
      "severity": "high",
      "userImpact": "Scala developers using Async.function with workflow method references experience thread pool exhaustion and RejectedExecutionException, forcing them to use Java workarounds.",
      "rootCause": "The isAsyncJava method in MethodReferenceDisassembler only accepts MethodHandleInfo.REF_invokeInterface, but Scala method references use REF_invokeStatic, causing them to be classified as regular functions instead of async workflow calls.",
      "proposedFix": "Modify the method implementation kind check in MethodReferenceDisassembler.isAsync() to also accept REF_invokeStatic, or create a MethodReferenceDisassemblyService implementation for Scala similar to the existing KotlinMethodReferenceDisassemblyService.",
      "workaround": "Create a Java wrapper method that calls Async.function with a Java method reference, then invoke that wrapper from Scala.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1007
      ],
      "keyQuote": "With a Scala method reference, the implementation method kind is equal to MethodHandleInfo.REF_invokeStatic. I'm hoping that allowing both types of method implementation kinds may be all that's required here.",
      "number": 1489,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:37:14.466Z"
    },
    {
      "summary": "Spring Boot autoconfigure module lacks configuration options for WorkerFactory and Worker settings via properties/YAML, forcing users to manually autowire and create workers to configure them.",
      "category": "feature",
      "subcategory": "spring-boot-autoconfigure",
      "apis": [
        "WorkerFactory",
        "WorkerOptions"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "worker-factory",
        "worker-configuration"
      ],
      "concepts": [
        "configuration-as-code",
        "spring-properties",
        "worker-tuning",
        "autoconfiguration",
        "customization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot tune worker behavior through configuration files and must write custom code to override default worker settings.",
      "rootCause": "The Spring Boot autoconfigure module creates and configures workers internally without exposing these settings to external configuration.",
      "proposedFix": "Add support for defining WorkerFactory and WorkerOptions through Spring properties/YAML configuration files.",
      "workaround": "Autowire WorkerFactory and manually create and configure workers with custom WorkerOptions before factory.start().",
      "resolution": "fixed",
      "resolutionDetails": "Configuration options were added to allow WorkerFactory and Worker customization via Spring properties.",
      "related": [],
      "keyQuote": "Defining worker options via properties/yaml config allows to mitigate the above constraint.",
      "number": 1488,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:54.576Z"
    },
    {
      "summary": "Transitive dependency protobuf-java-3.19.2 contains three high-severity vulnerabilities (CVE-2022-3510, CVE-2022-3509, CVE-2022-3171) with CVSS scores of 7.5, affecting denial of service resilience through parsing issues.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "build-system",
        "dependency-management",
        "protobuf-serialization"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "dependency-upgrade",
        "transitive-dependency",
        "protobuf",
        "cvss-scoring"
      ],
      "severity": "high",
      "userImpact": "Applications using the SDK are exposed to denial of service attacks through specially crafted protobuf messages that trigger extended garbage collection pauses.",
      "rootCause": "Protobuf-java versions prior to 3.21.7, 3.20.3, 3.19.6, and 3.16.3 have parsing vulnerabilities that convert messages back-and-forth between mutable and immutable forms, causing long GC pauses.",
      "proposedFix": "Upgrade com.google.protobuf:protobuf-java to version 3.21.7, 3.20.3, 3.19.6, or 3.16.3 depending on the SDK's target version line.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory, indicating resolution through dependency upgrade or exclusion.",
      "related": [],
      "keyQuote": "A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack.",
      "number": 1483,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:53.677Z"
    },
    {
      "summary": "Spring Boot Starter 2.7.4 has 5 dependency vulnerabilities in snakeyaml 1.30, including a critical DoS vulnerability (CVE-2022-25857, CVSS 7.5). The issue was automatically closed after the vulnerable dependency was either marked as ignored or removed from inventory.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "dependency-management",
        "snakeyaml"
      ],
      "concepts": [
        "denial-of-service",
        "yaml-parsing",
        "stack-overflow",
        "nested-depth-limitation",
        "vulnerability",
        "dependency-security"
      ],
      "severity": "high",
      "userImpact": "Applications using Spring Boot Starter 2.7.4 are exposed to DoS attacks through malicious YAML parsing.",
      "rootCause": "snakeyaml 1.30 lacks nested depth limitations for collections, allowing attackers to cause stack overflow through crafted YAML input.",
      "proposedFix": "Upgrade snakeyaml from 1.30 to 1.31 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The vulnerable library was either marked as ignored or removed from the dependency inventory.",
      "related": [],
      "keyQuote": "The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.",
      "number": 1482,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:51.357Z"
    },
    {
      "summary": "Spring Boot Starter dependency fails with Maven validation error due to missing version on transitive spring-boot-starter dependency. The autoconfigure module works fine, but the starter module doesn't properly export its dependencies in the Maven POM.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "maven-pom",
        "dependency-management"
      ],
      "concepts": [
        "dependency-resolution",
        "transitive-dependencies",
        "maven-pom",
        "bom-import",
        "spring-boot"
      ],
      "severity": "high",
      "userImpact": "Users cannot use the temporal-spring-boot-starter-alpha dependency in Maven projects without manual workarounds.",
      "rootCause": "The Gradle-to-Maven exporter plugin is not properly handling the BOM import from spring-boot-dependencies, causing the version information to be lost in the generated POM.",
      "proposedFix": "Add the spring-boot-dependencies BOM explicitly to the temporal-spring-boot-starter-alpha POM with type=pom and scope=import.",
      "workaround": "Users can explicitly add the spring-boot-dependencies BOM import to their project POM, or use the autoconfigure-alpha dependency directly instead of starter-alpha.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was likely resolved by explicitly adding the BOM import to the starter module POM during a subsequent release.",
      "related": [],
      "keyQuote": "Probably some problem in Gradle->Maven exporter plugin. I will try to add the BOM explicitly to temporal-spring-boot-starter-alpha.",
      "number": 1479,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:33.823Z"
    },
    {
      "summary": "Dependency security vulnerability in protobuf-java 3.19.2 (CVE-2022-3171) with CVSS score 4.3, which is a transitive dependency of error_prone_core. The vulnerability can lead to denial of service through parsing issues with binary data.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "build-system",
        "protobuf"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "denial-of-service",
        "dependency",
        "protobuf",
        "parsing"
      ],
      "severity": "medium",
      "userImpact": "Users may experience service unavailability due to potential DoS attacks targeting the vulnerable protobuf-java library in the SDK's dependencies.",
      "rootCause": "Parsing issue with binary data in protobuf-java versions prior to 3.16.3/3.19.6/3.20.3/3.21.7 causes conversion between mutable and immutable forms leading to long garbage collection pauses.",
      "proposedFix": "Upgrade protobuf-java to version 3.16.3, 3.19.6, 3.20.3, or 3.21.7 depending on the current major version.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Automatically closed by Mend as the vulnerable library was either marked as ignored or is no longer part of the Mend inventory.",
      "related": [],
      "keyQuote": "Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses.",
      "number": 1476,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:31.819Z"
    },
    {
      "summary": "CVE-2022-3171 vulnerability in protobuf-java 3.21.6 with CVSS score 4.3 was reported as a transitive dependency. The parsing issue with binary data in protobuf-java can lead to denial of service through repeated garbage collection pauses.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "protobuf",
        "serialization"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "denial-of-service",
        "garbage-collection",
        "dependency-version",
        "CVE"
      ],
      "severity": "medium",
      "userImpact": "Users could experience denial of service attacks if an attacker sends specially crafted binary data with non-repeated embedded messages to SDK applications.",
      "rootCause": "Protobuf-java versions prior to 3.21.7 have a parsing issue with binary data that causes objects to be converted between mutable and immutable forms, resulting in long garbage collection pauses.",
      "proposedFix": "Upgrade protobuf-java to version 3.21.7 or later (also available in 3.20.3, 3.19.6, or 3.16.3).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend as the vulnerable library was marked as ignored or is no longer part of the Mend inventory, indicating the dependency was upgraded.",
      "related": [],
      "keyQuote": "Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms",
      "number": 1475,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:33.034Z"
    },
    {
      "summary": "CVE-2022-42003 vulnerability detected in jackson-databind 2.13.4 dependency used in temporal-spring-boot-starter-alpha. The vulnerability allows resource exhaustion through deep wrapper array nesting when UNWRAP_SINGLE_VALUE_ARRAYS feature is enabled, with CVSS score of 7.5.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "jackson-databind",
        "spring-boot-starter",
        "dependency-management"
      ],
      "concepts": [
        "security-vulnerability",
        "resource-exhaustion",
        "deserialization",
        "dependency-upgrade"
      ],
      "severity": "high",
      "userImpact": "Applications using the Spring Boot starter are vulnerable to denial-of-service attacks through crafted JSON payloads exploiting the jackson-databind vulnerability.",
      "rootCause": "Lack of check in primitive value deserializers to avoid deep wrapper array nesting when UNWRAP_SINGLE_VALUE_ARRAYS feature is enabled in jackson-databind 2.13.4.",
      "proposedFix": "Upgrade jackson-databind to version 2.14.0-rc1 or later to fix the resource exhaustion vulnerability.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was marked as ignored or removed from the Mend inventory.",
      "related": [],
      "keyQuote": "resource exhaustion can occur because of a lack of a check in primitive value deserializers to avoid deep wrapper array nesting",
      "number": 1469,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:15.334Z"
    },
    {
      "summary": "Request to allow setting WorkflowOptions via WorkflowImplementationOptions to configure default workflow options per workflow type, similar to how ActivityOptions can be configured. This would enable configuration-driven setup instead of requiring injection at stub creation time.",
      "category": "feature",
      "subcategory": "workflow-configuration",
      "apis": [
        "WorkflowImplementationOptions",
        "WorkflowOptions",
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "workflow-stub",
        "configuration"
      ],
      "concepts": [
        "configuration",
        "defaults",
        "dependency-injection",
        "workflow-dispatch",
        "options-management"
      ],
      "severity": "medium",
      "userImpact": "Users must inject configuration objects into workflow stub creation code rather than being able to set defaults centrally per workflow type.",
      "rootCause": "WorkflowOptions must be defined before workflow dispatch to the worker, so the worker cannot decide them like it can with ActivityOptions.",
      "proposedFix": "Allow WorkerOptions to set default WorkflowOptions per workflow type, if technically feasible.",
      "workaround": "Inject configuration options into any code that creates a workflow stub.",
      "resolution": "wontfix",
      "resolutionDetails": "Not possible with current design as WorkflowOptions must be defined before workflow dispatch. A new component is being developed to address this broader problem.",
      "related": [],
      "keyQuote": "WorkflowOptions have to be defined at the workflow start BEFORE the workflow ever gets dispatched to the worker.",
      "number": 1464,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:13.092Z"
    },
    {
      "summary": "Spring Boot's auto-configured TestWorkflowEnvironment doesn't register custom DataConverter beans, preventing test configurations with custom data converters from being applied.",
      "category": "bug",
      "subcategory": "spring-boot-integration",
      "apis": [
        "TestWorkflowEnvironment",
        "WorkflowClientOptions",
        "DataConverter"
      ],
      "components": [
        "spring-boot-autoconfigure",
        "test-framework",
        "workflow-client"
      ],
      "concepts": [
        "dependency-injection",
        "auto-configuration",
        "test-setup",
        "data-serialization",
        "bean-registration"
      ],
      "severity": "medium",
      "userImpact": "Developers using Spring Boot with custom DataConverters cannot properly test their workflows because the TestWorkflowEnvironment ignores DataConverter beans.",
      "rootCause": "The Spring Boot auto-configuration for TestWorkflowEnvironment does not detect and register DataConverter beans during test setup.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The TestWorkflowEnvironment auto-configuration was updated to properly discover and register DataConverter beans from the Spring context.",
      "related": [],
      "keyQuote": "testWorkflowEnvironment does not take in account any test configuration beans of type DataConverter and does not register them in its WorkflowClientOptions",
      "number": 1463,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:36:11.250Z"
    },
    {
      "summary": "A state machine exception occurs during workflow termination in replay when handling EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED, causing an IllegalArgumentException in event processing. This was observed once during a load test.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "state-machine",
        "replay-handler",
        "workflow-executor",
        "event-processor"
      ],
      "concepts": [
        "workflow-termination",
        "state-machine",
        "event-replay",
        "exception-handling",
        "load-testing",
        "event-processing"
      ],
      "severity": "high",
      "userImpact": "Workflows fail during replay when terminated, causing production workload failures in load test scenarios.",
      "rootCause": "WorkflowStateMachines.handleNonStatefulEvent() throws IllegalArgumentException when encountering EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED event during replay, suggesting incomplete event handling logic for termination scenarios.",
      "proposedFix": null,
      "workaround": null,
      "related": [],
      "keyQuote": "Failure handling event 19 of type 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED' during replay. Unexpected event: EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED",
      "resolution": null,
      "resolutionDetails": null,
      "number": 1457,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:54.126Z"
    },
    {
      "summary": "The Java SDK allocates excessive physical threads for blocking gRPC long poll requests in pollers, causing inefficient context switching. The proposal is to use just two async threads (one for workflow tasks, one for activity tasks) to handle all corresponding poll requests efficiently.",
      "category": "other",
      "subcategory": "poller-threading",
      "apis": [],
      "components": [
        "workflow-task-poller",
        "activity-task-poller",
        "grpc-client"
      ],
      "concepts": [
        "threading",
        "async-io",
        "long-polling",
        "context-switching",
        "resource-efficiency"
      ],
      "severity": "medium",
      "userImpact": "Reduces unnecessary thread overhead and improves application resource utilization by eliminating inefficient blocking thread patterns.",
      "rootCause": "Pollers allocate one physical thread per poll request, leading to excessive semi-active threads with high context switching overhead for blocking I/O operations.",
      "proposedFix": "Implement two dedicated async threads: one for workflow task polling and one for activity task polling to handle all corresponding long poll requests asynchronously.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented async polling mechanism with dedicated thread pools for workflow and activity task pollers.",
      "related": [],
      "keyQuote": "We should have two threads for Pollers. One for Workflow Task Pollers, one for Activity Task Pollers. They should handle all corresponding long poll requests in an async manner.",
      "number": 1456,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:56.677Z"
    },
    {
      "summary": "Spring Boot framework integration currently rejects DynamicWorkflow implementations due to Spring integration validation. Request to add support for workflows that implement DynamicWorkflow interface alongside Spring Boot annotations.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [
        "DynamicWorkflow"
      ],
      "components": [
        "spring-boot-integration",
        "workflow-validation",
        "annotation-processor"
      ],
      "concepts": [
        "dynamic-workflows",
        "spring-framework",
        "interface-validation",
        "workflow-registration",
        "spring-boot-auto-configuration"
      ],
      "severity": "medium",
      "userImpact": "Spring Boot users cannot use DynamicWorkflow for runtime workflow flexibility due to validation that requires specific @WorkflowInterface annotations.",
      "rootCause": "Spring Boot integration's interface validation logic does not recognize DynamicWorkflow as a valid workflow interface type.",
      "proposedFix": "Update Spring Boot annotation processor to accept DynamicWorkflow interface as valid alongside @WorkflowInterface-annotated interfaces.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Support for DynamicWorkflow was added to Spring Boot integration validation.",
      "related": [],
      "keyQuote": "currently raises: Class doesn't implement any non empty public interface annotated with @WorkflowInterface",
      "number": 1449,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:56.280Z"
    },
    {
      "summary": "Request to support Java 19+ Virtual Threads (Project Loom) in the Java SDK to eliminate OS thread blocking during I/O operations and reduce implementation complexity. Virtual Threads have now become a full-fledged feature and should be adopted for significant performance benefits.",
      "category": "feature",
      "subcategory": "threading-model",
      "apis": [],
      "components": [
        "worker",
        "thread-pool",
        "activity-executor",
        "io-handling"
      ],
      "concepts": [
        "virtual-threads",
        "concurrency",
        "io-blocking",
        "performance",
        "loom",
        "thread-pool-management"
      ],
      "severity": "high",
      "userImpact": "Adopting Virtual Threads would allow the SDK to handle concurrent I/O operations more efficiently without blocking OS threads, improving scalability and reducing resource overhead for applications.",
      "rootCause": "The current SDK implementation requires complex eviction logic to manage OS threads blocked during I/O operations, creating performance penalties and implementation overhead.",
      "proposedFix": "Integrate Virtual Threads support in the Java SDK threading model to allow blocking I/O without consuming OS threads.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Virtual Threads support has been implemented or planned for adoption in the Java SDK following its full release as a standard feature in Java 21+.",
      "related": [],
      "keyQuote": "This enables applications to block a thread while waiting for some I/O to complete, without actually blocking any underlying OS thread.",
      "number": 1448,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:39.556Z"
    },
    {
      "summary": "Tracing spans for local and remote activities have identical prefixes, making it difficult to distinguish between them in span data. The request is to add differentiation to span names to clarify whether an activity is local or remote.",
      "category": "other",
      "subcategory": "tracing",
      "apis": [],
      "components": [
        "tracing",
        "activity-executor",
        "local-activity"
      ],
      "concepts": [
        "observability",
        "span-naming",
        "activity-type",
        "distributed-tracing",
        "debugging"
      ],
      "severity": "low",
      "userImpact": "Developers cannot easily distinguish between local and remote activity spans when analyzing distributed traces, making debugging and performance monitoring more difficult.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "tracing spans created for normal and local activities have the same exact prefix like \"startactivity\" and \"runactivity\"",
      "number": 1440,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:39.723Z"
    },
    {
      "summary": "Workflow.getVersion() causes NonDeterministicError when used with multithreading and timers because it yields the thread, changing execution order and misaligning with recorded history. The issue affects workflow replay tests when getVersion() is added to existing code.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.getVersion",
        "Workflow.sleep",
        "ExecuteActivity",
        "Async.procedure"
      ],
      "components": [
        "workflow-context",
        "state-machine",
        "replay-engine",
        "thread-scheduler"
      ],
      "concepts": [
        "determinism",
        "thread-ordering",
        "history-replay",
        "versioning",
        "multithreading",
        "event-sequencing",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely add Workflow.getVersion() to existing workflows without breaking replay tests, making it difficult to version workflow logic.",
      "rootCause": "Workflow.getVersion() yields the current thread in SyncWorkflowContext.java:678, causing thread execution order to change and event IDs to mismatch the recorded history during replay.",
      "proposedFix": "Make getVersion() not yield during replay when the version from history is default (indicating the original execution didn't have this call). Alternatively, add SDK metadata to workflow task started/completed to enable version-aware behavior decisions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It needs a very careful and probably very ugly fix to keep it backwards compatible. Only replay shouldn't yield and ONLY if the actual version from history is default",
      "number": 1430,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:39.162Z"
    },
    {
      "summary": "The test server fails to raise an error when attempting to start a child workflow that has already been started. Users expect a WorkflowExecutionAlreadyStartedFailure or similar error on the second start attempt, but instead nothing is returned.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "test-server",
        "child-workflow",
        "error-handling"
      ],
      "concepts": [
        "workflow-execution",
        "duplicate-detection",
        "error-handling",
        "state-validation"
      ],
      "severity": "medium",
      "userImpact": "Users writing tests with the test server cannot reliably validate child workflow deduplication behavior, potentially missing bugs in production code.",
      "rootCause": "Test server does not validate or error on duplicate child workflow start attempts",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1220
      ],
      "keyQuote": "Should be able to start a child workflow, then when I try to start it again, it should error",
      "number": 1429,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:20.575Z"
    },
    {
      "summary": "Activity with a 1-second heartbeat timeout that performs a heartbeat and then sleeps for 3 seconds fails to trigger a heartbeat timeout in the workflow. The test server is not properly detecting the timeout condition after the heartbeat is sent.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-handler",
        "test-server",
        "timeout-detection"
      ],
      "concepts": [
        "heartbeat",
        "timeout",
        "activity-lifecycle",
        "workflow-server-communication",
        "test-framework"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test activity heartbeat timeout scenarios, making it difficult to validate timeout handling logic in workflows.",
      "rootCause": "Test server's heartbeat timeout detection mechanism is not functioning correctly after a heartbeat is received and the activity continues sleeping.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The heartbeat timeout detection in the test server was corrected to properly trigger timeouts even after heartbeats have been recorded.",
      "related": [],
      "keyQuote": "An activity with a heartbeat timeout of 1s that does a heartbeat then sleeps for 3s should give the workflow a heartbeat timeout",
      "number": 1427,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:22.514Z"
    },
    {
      "summary": "Test server incorrectly sets workflow execution timeout and schedule-to-close timeout to 10 years when not explicitly configured by the user, causing API responses to be inaccurate compared to production behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowExecutionStartedEventAttributes",
        "PollActivityTaskQueueResponse",
        "ActivityInfo.getScheduleToCloseTimeout"
      ],
      "components": [
        "test-server",
        "activity-executor",
        "workflow-execution"
      ],
      "concepts": [
        "timeout",
        "test-environment",
        "production-parity",
        "configuration",
        "default-values",
        "API-accuracy"
      ],
      "severity": "high",
      "userImpact": "Workflows tested with the test server may pass but fail in production due to incorrect timeout defaults, leading to production incidents.",
      "rootCause": "Test server defaults workflow and activity timeouts to 10 years internally instead of leaving them unset when not user-configured.",
      "proposedFix": "Make test server API responses accurate by either not setting these timeouts or validating required timeout configuration before activity execution.",
      "workaround": "Users must manually validate and set timeout configurations in their own code to match production requirements.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This issue just took down all of our production workflows cause we made an incorrect assumption that all of our Workflow Tests would've caught this issue.",
      "number": 1426,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:21.417Z"
    },
    {
      "summary": "The test server is not populating the task_queue field in DescribeWorkflowExecutionResponse.workflow_execution_info, even though it correctly populates the same field in execution_config.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [
        "DescribeWorkflowExecution"
      ],
      "components": [
        "test-server",
        "describe-workflow-execution"
      ],
      "concepts": [
        "task-queue",
        "workflow-execution-info",
        "response-population",
        "test-infrastructure"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows with the test server cannot verify task queue information through the standard workflow execution response, complicating test validation.",
      "rootCause": "The test server implementation does not populate the workflow_execution_info.task_queue field when building DescribeWorkflowExecutionResponse.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The test server was updated to populate the task_queue field in workflow_execution_info.",
      "related": [],
      "keyQuote": "Populate DescribeWorkflowExecutionResponse.workflow_execution_info.task_queue",
      "number": 1425,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:02.364Z"
    },
    {
      "summary": "The test server incorrectly requires a task queue to be specified on continue-as-new operations, while the actual Temporal server does not. This inconsistency causes test server behavior to diverge from production behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "test-server",
        "workflow-execution"
      ],
      "concepts": [
        "continue-as-new",
        "task-queue",
        "test-compatibility",
        "server-behavior-parity"
      ],
      "severity": "medium",
      "userImpact": "Developers using the test server encounter unexpected validation errors that don't occur with the actual server, making tests behave differently than production.",
      "rootCause": "Test server validation logic differs from actual server - it enforces task queue requirement on continue-as-new when the actual server allows this operation without specifying one",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test server was updated to match actual server behavior and not require task queue on continue-as-new",
      "related": [],
      "keyQuote": "Actual server does not require task queue on continue as new",
      "number": 1424,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:03.676Z"
    },
    {
      "summary": "MicrometerClientStatsReporter does not report histogram metrics like .max, .avg, .median submetrics, only the base temporal_request_latency metric is published. The issue stems from reportHistogramValueSamples and reportHistogramDurationSamples methods being implemented as no-ops.",
      "category": "bug",
      "subcategory": "metrics-reporting",
      "apis": [
        "WorkflowServiceStubsOptions",
        "RootScopeBuilder",
        "MicrometerClientStatsReporter"
      ],
      "components": [
        "MicrometerClientStatsReporter",
        "metrics-bridge",
        "tally-micrometer"
      ],
      "concepts": [
        "histogram",
        "metrics",
        "distribution",
        "aggregation",
        "micrometer",
        "reporting"
      ],
      "severity": "medium",
      "userImpact": "Users configuring metrics with MicrometerClientStatsReporter cannot access histogram submetrics needed for performance monitoring and observability.",
      "rootCause": "reportHistogramValueSamples and reportHistogramDurationSamples methods are implemented as no-ops instead of properly handling histogram distribution.",
      "proposedFix": null,
      "workaround": "Use Datadog backend for distribution aggregation instead of client-side aggregation.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue was closed as distribution aggregation is handled by Datadog backend rather than on the client side with micrometer+datadog setup.",
      "related": [],
      "keyQuote": "distribution aggregation is done on the datadog backend and not on the client as it used to",
      "number": 1422,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:35:01.935Z"
    },
    {
      "summary": "Inconsistency in metric labels between temporal_activity_schedule_to_start_latency_seconds_bucket and temporal_workflow_task_schedule_to_start_latency_seconds_bucket. Activity latency metric includes both activity_type and workflow_type tags, while workflow task latency metric has workflow_type as 'none'. Documentation also needs alignment.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "worker",
        "activity-executor"
      ],
      "concepts": [
        "metrics-alignment",
        "labels",
        "monitoring",
        "latency",
        "task-queue"
      ],
      "severity": "medium",
      "userImpact": "Users receive inconsistent metric labels between activity and workflow task latency metrics, making it difficult to correlate and analyze metrics across different worker types.",
      "rootCause": "The activity schedule-to-start latency metric populates both activity_type and workflow_type tags, while the workflow task schedule-to-start latency metric only has workflow_type as 'none', creating asymmetry in metric labels.",
      "proposedFix": "Either both metrics should populate their respective type tags (activity_type for activity latency, workflow_type for workflow task latency), or neither should include the irrelevant type tag. Documentation should be updated to reflect the final decision.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Determined that workflow_type label is not relevant for pollers (task-queue level) and should be removed from documentation. The Go SDK behavior was identified as keeping the label for backwards compatibility.",
      "related": [
        2526
      ],
      "keyQuote": "Spoke with the team the conclusion was `workflow_type` label is only supported on the Go SDK and should be removed from the documentation since it is not relevant to pollers.",
      "number": 1417,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:44.853Z"
    },
    {
      "summary": "Users calling getResultAsync multiple times on the same stub or different stubs for the same workflow execution cause redundant long polls. SDK should deduplicate these calls to open only one long poll under the hood as an optimization.",
      "category": "feature",
      "subcategory": "workflow-client",
      "apis": [
        "getResultAsync",
        "WorkflowClient",
        "WorkflowStub"
      ],
      "components": [
        "workflow-client",
        "long-polling",
        "result-retrieval"
      ],
      "concepts": [
        "deduplication",
        "optimization",
        "connection-pooling",
        "caching",
        "long-polling"
      ],
      "severity": "medium",
      "userImpact": "Users must manually manage multiple getResultAsync calls to avoid unnecessary overhead, reducing SDK usability and performance.",
      "rootCause": "WorkflowClient and WorkflowStub do not deduplicate concurrent getResultAsync calls for the same workflow execution.",
      "proposedFix": "Implement call deduplication logic within WorkflowClient or WorkflowStub to reuse a single long poll for identical requests.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1212
      ],
      "keyQuote": "SDK should deduplicate such calls and open only one long poll under the hood as an optimization, so users don't have to think about it in their code.",
      "number": 1413,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:41.549Z"
    },
    {
      "summary": "MetricsScope configuration on TestEnvironmentOptions doesn't work as documented - metrics must be set directly on TestEnvironmentOptions rather than through WorkflowServiceStubsOptions, causing confusion and unexpected behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestEnvironmentOptions",
        "WorkflowServiceStubsOptions",
        "TestWorkflowEnvironment"
      ],
      "components": [
        "test-environment",
        "metrics-reporting",
        "configuration"
      ],
      "concepts": [
        "metrics-scope",
        "micrometer-integration",
        "test-setup",
        "configuration-hierarchy",
        "stats-reporting"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly configure metrics reporting in tests using the documented approach, requiring them to discover an undocumented workaround.",
      "rootCause": "MetricsScope set via WorkflowServiceStubsOptions is not properly propagated to or recognized by the TestEnvironmentOptions, while direct configuration on TestEnvironmentOptions works.",
      "proposedFix": null,
      "workaround": "Set MetricsScope directly on TestEnvironmentOptions instead of through WorkflowServiceStubsOptions.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the configuration behavior or documentation to clarify the correct approach.",
      "related": [],
      "keyQuote": "Worker & Client are not reported to your MeterRegistry, unless MeterRegistry is registered using setMetricsScope on TestEnvironmentOptions",
      "number": 1412,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:41.265Z"
    },
    {
      "summary": "Five security vulnerabilities detected in snakeyaml 1.30 dependency (transitive via Spring Boot), with highest severity CVSS 7.5. Issues relate to Denial of Service via nested depth limitations and stack overflow in YAML parsing.",
      "category": "bug",
      "subcategory": "security",
      "apis": [],
      "components": [
        "spring-boot-autoconfigure",
        "dependency-management",
        "snakeyaml"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "denial-of-service",
        "dependency",
        "yaml-parsing",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Applications using the Spring Boot starter may be vulnerable to DoS attacks through untrusted YAML parsing.",
      "rootCause": "Snakeyaml 1.30 lacks nested depth limitation for collections and has stack overflow issues in YAML parsing.",
      "proposedFix": "Upgrade snakeyaml to version 1.31 or later which fixes all identified CVEs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was auto-closed by Mend when vulnerable library was marked as ignored or removed from inventory.",
      "related": [],
      "keyQuote": "org.yaml:snakeyaml:1.30 - vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections",
      "number": 1411,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:24.090Z"
    },
    {
      "summary": "addWorkflowImplementationFactory without WorkflowImplementationOptions incorrectly sets Throwable as a fail-workflow exception type, causing non-TemporalFailure exceptions to fail workflow tasks. This behavior is undocumented and differs from other registration methods.",
      "category": "bug",
      "subcategory": "workflow-registration",
      "apis": [
        "registerWorkflowImplementationTypes",
        "addWorkflowImplementationFactory",
        "WorkflowImplementationOptions",
        "setFailWorkflowExceptionTypes"
      ],
      "components": [
        "worker",
        "workflow-registration",
        "exception-handling"
      ],
      "concepts": [
        "exception-handling",
        "workflow-execution",
        "backwards-compatibility",
        "default-behavior",
        "API-consistency"
      ],
      "severity": "high",
      "userImpact": "Users are unexpectedly having workflows fail when using the no-options factory method, with inconsistent behavior compared to other registration methods.",
      "rootCause": "The addWorkflowImplementationFactory(Class, Func) method implementation sets Throwable in setFailWorkflowExceptionTypes, deviating from the default behavior of other registration methods.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "if used, Throwable is set into WorkflowImplementationOptions#setFailWorkflowExceptionTypes by the underlying implementation. this difference is completely unexpected by users and undocumented",
      "number": 1408,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:19.142Z"
    },
    {
      "summary": "Test Server binary fails to run on ARM64 (Apple Silicon M1) with qemu-x86_64 architecture error. Users need native ARM64 build support instead of x86_64 emulation.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "build-system",
        "platform-support"
      ],
      "concepts": [
        "ARM64",
        "Apple Silicon",
        "cross-platform",
        "architecture compatibility",
        "binary distribution"
      ],
      "severity": "high",
      "userImpact": "Users on Apple Silicon Macs cannot run the Test Server without significant workarounds or performance degradation.",
      "rootCause": "Test Server binary is only distributed for x86_64 architecture, causing qemu emulation errors on ARM64 platforms.",
      "proposedFix": "Build and distribute native ARM64 Test Server binary alongside x86_64 version.",
      "workaround": "Monkey-patch SDK to force x86_64 architecture resolution or run in Docker with performance degradation.",
      "resolution": "fixed",
      "resolutionDetails": "Native ARM64 build was included in the next release after this issue was filed.",
      "related": [],
      "keyQuote": "Test server running... Exception: qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory",
      "number": 1407,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:22.534Z"
    },
    {
      "summary": "Test server should emit warning logs when tasks are scheduled on task queues with no listening workers. This helps users quickly identify the common mistake of forgetting to register workers on all required queues, which currently manifests only as test timeouts.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "task-queue",
        "worker-registration"
      ],
      "concepts": [
        "task-queue",
        "worker-listening",
        "diagnostics",
        "logging",
        "test-debugging",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Users receive confusing test timeouts when workers aren't registered on all required task queues, making it difficult to diagnose the actual problem.",
      "rootCause": "Test server lacks visibility into task queue listener registration; tasks scheduled on unlistened queues fail silently without diagnostic output.",
      "proposedFix": "Add warning log messages to the test server when tasks are scheduled on task queues that have no registered workers listening on them.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A typical user mistake in unit tests which may be a little tricky for users to realize is forgetting to register workers on all the queues that participate in a unit test.",
      "number": 1403,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:01.038Z"
    },
    {
      "summary": "Request to split PayloadCodec into separate Encoder and Decoder interfaces with independent configuration, allowing microservices to encode payloads with one scheme (e.g., gzip) while decoding multiple schemes (e.g., gzip or encrypt) from other services.",
      "category": "feature",
      "subcategory": "payload-codec",
      "apis": [
        "PayloadCodec"
      ],
      "components": [
        "payload-codec",
        "data-converter",
        "encoding"
      ],
      "concepts": [
        "encoding",
        "payload-transformation",
        "multi-encoding-support",
        "configuration",
        "microservices-interop",
        "compression",
        "encryption"
      ],
      "severity": "medium",
      "userImpact": "Users running microservices with different payload encoding schemes cannot easily configure the SDK to encode with one scheme while decoding multiple schemes without workarounds.",
      "rootCause": "PayloadCodec interface combines encoding and decoding into a single unified interface, preventing independent configuration of multiple encoders and decoders.",
      "proposedFix": "Split PayloadCodec into separate PayloadEncoder and PayloadDecoder interfaces with independent lists, allowing flexible configuration of encoding and decoding strategies through configuration like `temporal.payload-encoding=binary/encrypt,binary/gzip`.",
      "workaround": "Use a custom CodecDataConverter or external library to implement complex conditional logic outside of the Temporal Java SDK.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers declined to make breaking changes to PayloadCodec interface, suggesting complex logic can be implemented in custom PayloadCodec or CodecDataConverter instead.",
      "related": [],
      "keyQuote": "We have no plan to make breaking changes to the `PayloadCodec` interface. In general if you want complex conditional logic that can be done in the `PayloadCodec` or a custom `CodecDataConverter`",
      "number": 1402,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:00.678Z"
    },
    {
      "summary": "Spring Boot starter transitive dependency on snakeyaml-1.30 contains 5 security vulnerabilities related to YAML parsing denial of service attacks. The highest severity vulnerability (CVE-2022-25857, CVSS 7.5) involves missing nested depth limitation for collections.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "spring-boot-starter",
        "snakeyaml",
        "dependency-management"
      ],
      "concepts": [
        "denial-of-service",
        "yaml-parsing",
        "nested-depth-limitation",
        "stack-overflow",
        "untrusted-input",
        "dependency-vulnerability"
      ],
      "severity": "critical",
      "userImpact": "Applications using the Spring Boot starter are vulnerable to DoS attacks through malicious YAML input, potentially causing service unavailability.",
      "rootCause": "snakeyaml-1.30 lacks proper depth limitations when parsing YAML collections, allowing attackers to craft inputs that cause stack overflow and denial of service.",
      "proposedFix": "Upgrade org.yaml:snakeyaml from 1.30 to 1.31 to address all 5 vulnerabilities.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The vulnerable snakeyaml dependency was either marked as ignored or removed from the Mend inventory in the affected branches, automatically closing the issue.",
      "related": [],
      "keyQuote": "The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.",
      "number": 1400,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:34:04.671Z"
    },
    {
      "summary": "The Test Server incorrectly accepts workflows where WorkflowExecutionCompleted is not the last command, while the real Temporal server would reject this. The Test Server should validate command ordering to match production server behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "workflow-task-validation",
        "command-ordering"
      ],
      "concepts": [
        "workflow-completion",
        "command-validation",
        "server-behavior-alignment",
        "task-rejection"
      ],
      "severity": "high",
      "userImpact": "Developers using the Test Server may not catch workflow implementation errors that would fail in production, leading to unreliable testing.",
      "rootCause": "Test Server does not validate that WorkflowExecutionCompleted is the final command in a workflow task, unlike the real Temporal server.",
      "proposedFix": "Add validation in Test Server to reject workflow tasks where WorkflowExecutionCompleted is not the last command, with error message aligned with real server.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test Server now validates command ordering and rejects tasks with WorkflowExecutionCompleted as non-final command, matching real server behavior.",
      "related": [],
      "keyQuote": "If a workflow (or an SDK) is written in the way that the workflow is completed before some other operations (like an asynchronous local activity), the Test Server should reject such a workflow task with a text message aligned with a real Temporal server.",
      "number": 1398,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:33:38.285Z"
    },
    {
      "summary": "Server sends unbounded error messages that exceed HTTP/2 default header limits. The Java SDK needs to increase maxInboundMetadataSize from 8KB to 4MB to accommodate these larger error messages.",
      "category": "bug",
      "subcategory": "gRPC-configuration",
      "apis": [],
      "components": [
        "gRPC-client",
        "metadata-handling",
        "connection-config"
      ],
      "concepts": [
        "HTTP/2",
        "header-limits",
        "error-handling",
        "gRPC-metadata",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users encounter connection failures when the server sends large error messages that exceed the default HTTP/2 metadata size limit.",
      "rootCause": "Server sends unbounded error messages that don't fit into the standard HTTP/2 headers limit (8KB default)",
      "proposedFix": "Set maxInboundMetadataSize to 4MB instead of the default 8KB",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "maxInboundMetadataSize was increased to 4MB to accommodate unbounded server error messages",
      "related": [
        3284,
        122
      ],
      "keyQuote": "Server sometimes sends unbounded error messages that don't fit into a standard HTTP/2 headers limit",
      "number": 1396,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:33:36.166Z"
    },
    {
      "summary": "WorkflowHistoryIterator throws DEADLINE_EXCEEDED during history retrieval, causing workflow execution failure instead of task retry. Investigation determined the root cause lies elsewhere (issue #1408) and the SDK behavior is actually correct when failWorkflowExceptionTypes is properly configured.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "WorkflowHistoryIterator",
        "ReplayWorkflowRunTaskHandler",
        "ReplayWorkflowTaskHandler",
        "WorkflowWorker"
      ],
      "concepts": [
        "deadline-exceeded",
        "error-handling",
        "workflow-task-retry",
        "history-retrieval",
        "gRPC-errors"
      ],
      "severity": "high",
      "userImpact": "Workflows fail permanently when gRPC deadline is exceeded during history retrieval, instead of allowing workers to retry and recover.",
      "rootCause": "Issue #1408 - the actual root cause lies in a different part of the codebase; the SDK behavior is correct when failWorkflowExceptionTypes is properly configured",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Investigation determined the error handling is working as designed; the actual root cause is in issue #1408 with related fix in PR #1404",
      "related": [
        1242,
        1408,
        1404
      ],
      "keyQuote": "There is no code path that may lead to workflow execution failure on this Error if failWorkflowExceptionTypes is not set.",
      "number": 1395,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:33:41.679Z"
    },
    {
      "summary": "Spring Boot starter should allow users to define custom *Customizer beans to intercept and modify all *Options class instances for advanced configuration beyond externalized properties.",
      "category": "feature",
      "subcategory": "spring-boot-starter",
      "apis": [
        "WorkerFactoryOptions",
        "WorkerOptions"
      ],
      "components": [
        "spring-boot-starter",
        "options-configuration",
        "worker-creation"
      ],
      "concepts": [
        "customization",
        "interceptors",
        "externalized-configuration",
        "dependency-injection",
        "flexibility",
        "spring-boot"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily customize complex Option objects through Spring Boot configuration without full property exposure.",
      "rootCause": "Spring Boot starter abstracts worker creation internally, preventing users from applying custom logic to Options instances.",
      "proposedFix": "Implement *Customizer pattern (following Spring Boot conventions) to allow users to define beans that intercept and modify all *Options classes.",
      "workaround": "Expose all properties through Spring externalized config, though this is not trivial for complex object values.",
      "resolution": "fixed",
      "resolutionDetails": "Spring Boot starter was updated to support user-defined *Customizers for Options classes, enabling flexible customization.",
      "related": [],
      "keyQuote": "Spring boot supports externalized configuration, but for full flexibility, JavaSDK Spring Boot should allow users to intercept the creation of all *Options instances",
      "number": 1394,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:32:34.045Z"
    },
    {
      "summary": "Kotlin Standard Library 1.5.31 has a medium severity vulnerability (CVE-2022-24329) related to dependency locking in Multiplatform Gradle Projects. The vulnerability is compile-time only and users should upgrade to modern Kotlin versions in their runtimes.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "gradle-build",
        "kotlin-stdlib",
        "multiplatform-projects"
      ],
      "concepts": [
        "dependency-management",
        "vulnerability",
        "compile-time-security",
        "gradle",
        "kotlin-version"
      ],
      "severity": "low",
      "userImpact": "Users may have compile-time dependency locking vulnerabilities in Multiplatform Gradle Projects when using Kotlin 1.5.31.",
      "rootCause": "Kotlin before 1.6.0 lacked proper dependency locking mechanism for Multiplatform Gradle Projects.",
      "proposedFix": "Upgrade kotlin-stdlib from 1.5.31 to 1.6.0-M1 or later.",
      "workaround": "Use modern Kotlin versions in runtime environments.",
      "resolution": "fixed",
      "resolutionDetails": "Upgrade available to Kotlin 1.6.0-M1 which includes the fix for CVE-2022-24329. Issue closed as the vulnerability is compile-time only.",
      "related": [],
      "keyQuote": "Compile-time vulnerability, users should use modern Kotlin versions in their runtimes.",
      "number": 1393,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:32:34.377Z"
    },
    {
      "summary": "User finds Jackson configuration cumbersome when trying to use custom modules like jackson-module-kotlin with the Temporal SDK. Requires either duplicating extensive default configuration or using reflection workarounds. Requests easier customization mechanisms.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "DataConverter",
        "JacksonJsonPayloadConverter",
        "ObjectMapper"
      ],
      "concepts": [
        "serialization",
        "Jackson",
        "Kotlin",
        "data-classes",
        "customization",
        "configuration",
        "boilerplate"
      ],
      "severity": "medium",
      "userImpact": "Kotlin users and others needing custom Jackson configuration must either replicate large amounts of default configuration code or resort to reflection hacks.",
      "rootCause": "The SDK's Jackson ObjectMapper is encapsulated in JacksonJsonPayloadConverter with no public API to customize it, forcing users to either recreate the entire DataConverter or use reflection.",
      "proposedFix": "Expose mechanisms to customize Jackson configuration: (1) global ObjectMapper access, (2) List<PayloadConverter> and ObjectMapper properties, (3) UnaryOperator<ObjectMapper> customizer, (4) environment variables for automatic module registration like kotlin or module discovery.",
      "workaround": "Use reflection to access and modify the ObjectMapper field in the default JacksonJsonPayloadConverter, or manually create a custom DataConverter replicating all default configuration.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers decided not to use SPI or automatic classpath detection due to risks of unexpected configuration loading. Users are expected to customize their own Jackson settings; a temporal-kotlin module is provided as a starting point but not auto-loaded.",
      "related": [
        139,
        1388
      ],
      "keyQuote": "It would be nice if it was simpler and easier to be able to customize the Jackson-level configuration.",
      "number": 1387,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:32:36.675Z"
    },
    {
      "summary": "Full replay of workflows exposes a fake WorkflowId to user code, which can break determinism. The SDK should provide the actual WorkflowId from the history instead.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Worker.replayWorkflowExecution",
        "WorkflowInfo"
      ],
      "components": [
        "worker",
        "replay",
        "workflow-execution-history"
      ],
      "concepts": [
        "determinism",
        "workflow-replay",
        "workflow-id",
        "history-replay",
        "test-framework",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Workflow code that depends on WorkflowId values during replay may break due to receiving fake IDs instead of actual values from history.",
      "rootCause": "The replay implementation supplies a fake WorkflowId from WorkflowExecutionHistory instead of using the actual value from the workflow history.",
      "proposedFix": "Extract actual WorkflowId from the history and provide it to the Workflow via WorkflowInfo during replay.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Addressed by PR #1497 which passes the real WorkflowId during full replay.",
      "related": [
        1497
      ],
      "keyQuote": "Actual values from the history should be taken and supplied to the Workflow in WorkflowInfo during replay.",
      "number": 1378,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:31:38.281Z"
    },
    {
      "summary": "Test server needs to emit a predictable, standardized log message upon successful startup so that SDKs and users can reliably detect when the server is ready for use, replacing the current socket-polling approach.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "startup",
        "logging"
      ],
      "concepts": [
        "readiness-detection",
        "process-initialization",
        "server-lifecycle",
        "external-integration",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "SDK developers and users can reliably wait for test server readiness instead of implementing socket polling, improving integration reliability and reducing startup latency.",
      "rootCause": null,
      "proposedFix": "Emit a standardized output (stdout or stderr) with a predictable prefix as the first output when the test server is successfully started and ready to accept connections.",
      "workaround": "Continuously attempt socket connections until successful, though this is inefficient and unreliable.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Create some kind of output (stdout or stderr) that is somewhat predictable (e.g. starts with a common string or something) and would be the _first_ output of the test server process when the server is successfully started and ready for use.",
      "number": 1377,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:31:38.081Z"
    },
    {
      "summary": "External workflow signal operations throw incorrect ApplicationFailure exception instead of the proper SignalExternalWorkflowException. The SDK has an unused SignalExternalWorkflowException class and a TODO comment indicating this was never properly implemented.",
      "category": "bug",
      "subcategory": "external-workflow-signals",
      "apis": [
        "Workflow.newUntypedExternalWorkflowStub",
        "signal"
      ],
      "components": [
        "external-workflow-client",
        "signal-execution",
        "state-machine",
        "exception-handling"
      ],
      "concepts": [
        "external-workflow-signals",
        "exception-type",
        "workflow-not-found",
        "signal-failure",
        "api-correctness"
      ],
      "severity": "high",
      "userImpact": "Users cannot properly catch and handle external workflow signal failures because the wrong exception type is thrown, forcing them to catch generic ApplicationFailure.",
      "rootCause": "SignalExternalStateMachine has an unimplemented TODO comment and never creates the proper SignalExternalWorkflowException when signal execution fails.",
      "proposedFix": "Implement the TODO in SignalExternalStateMachine.java:152 to properly throw SignalExternalWorkflowException or WorkflowNotFoundException instead of ApplicationFailure.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "ApplicationFailure is an incorrect exception to be thrown here. There is already an exception for this situation: SignalExternalWorkflowException that is currently not created anywhere.",
      "number": 1374,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:31:38.192Z"
    },
    {
      "summary": "Child workflow creation API lacks support for custom data converters, preventing parent workflows from specifying different serialization/encryption settings for child workflows on different task queues or namespaces. Users need this to support multi-team setups with different encryption keys.",
      "category": "feature",
      "subcategory": "child-workflow-options",
      "apis": [
        "ChildWorkflowOptions",
        "StartChildWorkflow",
        "ActivityOptions"
      ],
      "components": [
        "child-workflow-executor",
        "data-converter",
        "payload-converter",
        "activity-options"
      ],
      "concepts": [
        "data-serialization",
        "encryption",
        "multi-tenant",
        "task-queue",
        "namespace-isolation",
        "payload-conversion"
      ],
      "severity": "high",
      "userImpact": "Multi-team deployments with different workers using separate encryption keys cannot safely invoke child workflows across team boundaries without workarounds.",
      "rootCause": "ChildWorkflowOptions and ActivityOptions do not expose a mechanism to override the data converter used for serializing payloads specific to that invocation.",
      "proposedFix": "Add a custom data converter parameter to ChildWorkflowOptions (and ActivityOptions) that allows specifying a different data converter for that specific invocation.",
      "workaround": "Users can create a PayloadConverter that applies only to the input class of the child workflow, though this approach is hacky and has limitations.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There is no way for a parent workflow to specify a different data converter for such a child workflow invocation.",
      "number": 1373,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:30:45.017Z"
    },
    {
      "summary": "During direct queries on evicted workflows, the SDK fails when the query arrives with outdated event IDs, causing the state machine to enter an invalid state. The SDK should handle these scenarios by performing a full replay instead of failing the workflow task.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "state-machines",
        "query-processing",
        "workflow-task-handler"
      ],
      "concepts": [
        "replay",
        "state-machine",
        "query",
        "event-id",
        "workflow-eviction",
        "state-consistency"
      ],
      "severity": "high",
      "userImpact": "Users experience workflow query failures and internal state machine exceptions when queries arrive during workflow task processing with outdated state information.",
      "rootCause": "The isReplaying state detection in state machines relies on previousStartedWorkflowTaskId matching server history. When queries arrive with outdated IDs during eviction, the SDK incorrectly routes through EXECUTE instead of REPLAY path, causing state machine exceptions.",
      "proposedFix": "Handle queries with full replay when the state machine check detects too advanced workflow state, and fix isReplaying detection to account for outdated previousStartedWorkflowTaskId in query scenarios.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by improving state machine handling and replay logic for queries with outdated event IDs.",
      "related": [
        1267
      ],
      "keyQuote": "JavaSDK probably should handle the query with a full replay when this happens instead of failing a workflow task.",
      "number": 1371,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:30:46.297Z"
    },
    {
      "summary": "Spring Boot Starter should provide the ability to register custom data converters through autoconfiguration. Currently, there is no direct way to configure custom DataConverter implementations in the Spring Boot environment.",
      "category": "feature",
      "subcategory": "spring-boot-autoconfiguration",
      "apis": [
        "DataConverter"
      ],
      "components": [
        "spring-boot-starter",
        "autoconfiguration",
        "data-converter"
      ],
      "concepts": [
        "serialization",
        "customization",
        "configuration",
        "spring-boot",
        "dependency-injection"
      ],
      "severity": "medium",
      "userImpact": "Spring Boot users cannot easily register custom data converters, requiring manual bean configuration workarounds.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Spring Boot Starter should provide the ability to register custom data converters",
      "number": 1370,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:30:43.471Z"
    },
    {
      "summary": "User reported that calling a synchronous workflow stub in tests doesn't propagate workflow exceptions and causes the workflow to block indefinitely. The issue was resolved by clarifying that non-TemporalFailure exceptions cause workflow task failures rather than workflow failures by design, and that ApplicationFailure should be used to properly fail workflows.",
      "category": "question",
      "subcategory": "exception-handling",
      "apis": [
        "WorkflowStub",
        "ApplicationFailure",
        "TemporalFailure"
      ],
      "components": [
        "workflow-stub",
        "test-framework",
        "exception-handling",
        "workflow-execution"
      ],
      "concepts": [
        "exception-propagation",
        "workflow-failure",
        "task-failure",
        "error-handling",
        "test-execution",
        "synchronous-stub"
      ],
      "severity": "low",
      "userImpact": "Users calling synchronous workflow stubs in tests may experience confusion when exceptions don't propagate as expected, leading to workflow blocking and debugging difficulty.",
      "rootCause": "Non-TemporalFailure exceptions cause workflow task failures rather than whole workflow failures by design, allowing users to fix issues and continue execution.",
      "proposedFix": "Use ApplicationFailure to properly fail a workflow instead of throwing generic exceptions.",
      "workaround": "Throw ApplicationFailure instead of other exception types to fail a workflow.",
      "resolution": "invalid",
      "resolutionDetails": "Closed as working as designed. The issue was actually a misunderstanding of the exception handling design. Non-TemporalFailure exceptions intentionally cause task failures, not workflow failures, allowing recovery. Users should use ApplicationFailure to fail a workflow.",
      "related": [],
      "keyQuote": "Any other exception other than subclasses of TemporalFailure lead to failure of a workflow task, not a whole workflow.",
      "number": 1369,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:29:58.176Z"
    },
    {
      "summary": "Epic to improve Local Activities support in the Java SDK by addressing bugs and implementing missing features that users expect from local activity functionality.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "local-activities",
        "activity-executor",
        "worker"
      ],
      "concepts": [
        "local-execution",
        "activity-support",
        "performance-optimization",
        "feature-parity"
      ],
      "severity": "medium",
      "userImpact": "Users lack expected features and proper enforcement in local activities, limiting their ability to use this optimization effectively.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because GitHub issues are no longer used as epics for tracking work.",
      "related": [
        1533,
        1561,
        1004,
        1261,
        1346,
        1246,
        1303,
        1512,
        1563
      ],
      "keyQuote": "Closing since we no longer want to use GH issues as epics",
      "number": 1361,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:29:56.492Z"
    },
    {
      "summary": "The Java SDK lacks CI testing for the native test server, which resulted in a broken native test server build being released to users. Integration tests are needed to ensure the native test server image builds and functions correctly.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "native-build",
        "ci-pipeline"
      ],
      "concepts": [
        "testing",
        "integration-tests",
        "native-image",
        "build-verification",
        "release-quality"
      ],
      "severity": "high",
      "userImpact": "Users can receive SDK releases with broken native test server builds, breaking their testing infrastructure.",
      "rootCause": "Missing CI integration tests for the native test server build process",
      "proposedFix": "Add integration tests for the native test server image to the CI pipeline",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1357
      ],
      "keyQuote": "We don't have CI testing for the native test server. As a result of that, we can release a version of SDK with a broken native test server build",
      "number": 1358,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:29:56.510Z"
    },
    {
      "summary": "The latest test-server binary fails with Java NoClassDefFound and reflection errors related to protobuf message classes, breaking the TypeScript SDK testing framework that depends on downloading the latest test-server build.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "protobuf-generated-code",
        "grpc"
      ],
      "concepts": [
        "dependency-version-mismatch",
        "classloader-issue",
        "reflection",
        "java-compatibility",
        "build-artifact"
      ],
      "severity": "high",
      "userImpact": "Users cannot run tests with the TypeScript SDK testing framework as the test-server fails to initialize.",
      "rootCause": "Protobuf version mismatch - generated message class missing expected reflection method (getUnverifiedLazy) causing ExceptionInInitializerError during gRPC message parsing.",
      "proposedFix": null,
      "workaround": "Downgrade to a previous working version of the test-server.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was mitigated, allowing users to use the TS testing framework again.",
      "related": [],
      "keyQuote": "Generated message class \"com.google.protobuf.DescriptorProtos$FieldOptions\" missing method \"getUnverifiedLazy\".",
      "number": 1357,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:29:04.953Z"
    },
    {
      "summary": "ActivityCompletionClient methods that use workflowId and activityId instead of taskToken are unused and lack unit test coverage. These code paths in ManualActivityCompletionClientImpl need basic unit tests to ensure they function correctly.",
      "category": "feature",
      "subcategory": "activity-completion",
      "apis": [
        "ActivityCompletionClient",
        "ManualActivityCompletionClientImpl"
      ],
      "components": [
        "activity-completion",
        "client",
        "testing"
      ],
      "concepts": [
        "unit-testing",
        "test-coverage",
        "activity-completion",
        "workflow-id",
        "activity-id",
        "task-token",
        "client-methods"
      ],
      "severity": "medium",
      "userImpact": "Untested code paths in ActivityCompletionClient may contain hidden bugs that affect users relying on workflowId/activityId completion methods.",
      "rootCause": null,
      "proposedFix": "Add basic unit tests to cover ActivityCompletionClient methods that use workflowId and activityId parameters.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "All the methods of ActivityCompletionClient that don't use task token and use String workflowId, Optional<String> runId, String activityId instead are unused and untested.",
      "number": 1354,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:29:04.860Z"
    },
    {
      "summary": "The Java SDK should support setting the reason parameter in workflow cancellation requests, matching the functionality already available for termination requests. This feature was added to the server's RequestCancelWorkflowExecutionRequest.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [
        "RequestCancelWorkflowExecutionRequest"
      ],
      "components": [
        "workflow-client",
        "cancellation-request"
      ],
      "concepts": [
        "cancellation",
        "workflow-lifecycle",
        "request-parameters",
        "API-parity",
        "server-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot provide a cancellation reason when canceling workflows, limiting the ability to document why a workflow was cancelled.",
      "rootCause": null,
      "proposedFix": "Allow the reason field to be set in cancellation requests similar to how it's implemented for termination requests.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The reason parameter was wired into the workflow cancellation request implementation.",
      "related": [],
      "keyQuote": "JavaSDK should allow this field to be set the same way it's allowed for termination requests.",
      "number": 1350,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:29:04.117Z"
    },
    {
      "summary": "When a workflow fails due to application code throwing an exception, querying the failed workflow replays the same exception and logs it at ERROR level without context indicating it's a replay. This creates noisy, confusing logs that don't indicate the exception was from a query execution.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "worker",
        "workflow-execution",
        "logging",
        "query-handler",
        "replay-engine"
      ],
      "concepts": [
        "workflow-failure",
        "exception-handling",
        "logging-levels",
        "query-execution",
        "replay-context",
        "noise-reduction"
      ],
      "severity": "medium",
      "userImpact": "Users see confusing ERROR-level logs when querying failed workflows, making it difficult to distinguish actual failures from replayed exceptions in query contexts.",
      "rootCause": "The exception logging during workflow execution doesn't differentiate between original workflow failure and replay-only execution (query), resulting in ERROR logs during query replay without context about the replay.",
      "proposedFix": "Transform the original exception to Warning level and change exceptions in query-only execution to Debug level with additional context tracking back to the query that caused the execution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by adjusting logging levels and adding context to distinguish between actual workflow failures and query replays.",
      "related": [],
      "keyQuote": "The original exception should be transformed into Warning from the Error. The exception that happens in a query-only execution should be on Debug level",
      "number": 1348,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:28:16.245Z"
    },
    {
      "summary": "When a Temporal cluster is restarted in a multi-cluster environment, the first getClusterInfo() call fails with a connection error, even though the cluster is fully operational. Subsequent calls succeed, suggesting a gRPC channel state management issue.",
      "category": "bug",
      "subcategory": "grpc-connection",
      "apis": [
        "getClusterInfo"
      ],
      "components": [
        "grpc-channel",
        "connection-pool",
        "health-check"
      ],
      "concepts": [
        "connection-refused",
        "channel-state",
        "cluster-recovery",
        "retry-logic",
        "server-restart"
      ],
      "severity": "medium",
      "userImpact": "Multi-cluster deployments experience intermittent connection failures on cluster restart, requiring retry logic to work around the issue.",
      "rootCause": "gRPC channel does not properly reconnect after server restart; connection attempts are refused on the first call despite server being ready, suggesting stale channel state or timing issue in connection reestablishment.",
      "proposedFix": null,
      "workaround": "Retry the getClusterInfo() call; the second attempt succeeds after cluster restart.",
      "resolution": "stale",
      "resolutionDetails": "Issue closed due to inactivity; no fix was implemented or confirmed.",
      "related": [],
      "keyQuote": "It does not seem to matter how long this first call is after turning the cluster back on, it still fails.",
      "number": 1347,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:28:16.236Z"
    },
    {
      "summary": "Local activities currently block the workflow executor thread while waiting for completion, causing inefficient resource utilization and requiring users to carefully tune the number of workflow executor threads. The request is to release the thread during local activity execution while properly implementing backpressure mechanisms.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "workflow-executor",
        "local-activity-worker",
        "thread-pool"
      ],
      "concepts": [
        "thread-blocking",
        "resource-efficiency",
        "backpressure",
        "local-activities",
        "thread-management",
        "load-balancing"
      ],
      "severity": "medium",
      "userImpact": "Users must carefully tune workflow executor thread counts based on local activity profiles, leading to suboptimal resource utilization and uneven load distribution.",
      "rootCause": "Workflow executor thread actively waits (busy-waits or blocks) for local activity completion instead of releasing the thread for other work.",
      "proposedFix": "Restructure workflow executor worker code so the thread is released during local activity execution and resumed when the activity completes, with proper backpressure handling.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflow executor thread shouldn't actively wait for local activities completion and release the thread.",
      "number": 1346,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:28:15.819Z"
    },
    {
      "summary": "DataConverter interface needs a method to deserialize all Payloads at once instead of requiring individual deserialization calls. The current random access approach is inefficient with PayloadCodec and Remote Data Encoder as it requires one call per parameter.",
      "category": "feature",
      "subcategory": "data-conversion",
      "apis": [
        "DataConverter"
      ],
      "components": [
        "data-converter",
        "payload-codec",
        "remote-data-encoder"
      ],
      "concepts": [
        "batch-deserialization",
        "payload-processing",
        "encoding-efficiency",
        "parameter-conversion",
        "performance"
      ],
      "severity": "medium",
      "userImpact": "Users experience degraded performance when using PayloadCodec and Remote Data Encoder for workflow/activity parameters due to inefficient per-parameter deserialization calls.",
      "rootCause": "The DataConverter interface design assumes random access deserialization, which doesn't scale efficiently with encoders that benefit from batch processing.",
      "proposedFix": "Add a new interface method to DataConverter that deserializes all Payloads at once instead of requiring individual calls per parameter.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "DataConverter interface has to evolve to support encoding all the Payloads at once.",
      "number": 1345,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:27:22.137Z"
    },
    {
      "summary": "Request to implement eager activity dispatch in the Java SDK, enabling activities to be dispatched immediately rather than waiting for the next polling cycle.",
      "category": "feature",
      "subcategory": "activity-dispatch",
      "apis": [],
      "components": [
        "activity-executor",
        "worker",
        "task-dispatcher"
      ],
      "concepts": [
        "eager-dispatch",
        "activity-scheduling",
        "performance-optimization",
        "latency-reduction"
      ],
      "severity": "medium",
      "userImpact": "Users can achieve lower latency for activity execution by enabling eager dispatch instead of relying on polling-based scheduling.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented as requested for the Java SDK",
      "related": [
        55
      ],
      "keyQuote": "Add support for an eager activity dispatch in java-sdk.",
      "number": 1339,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:27:21.544Z"
    },
    {
      "summary": "Epic to develop a static analyzer tool for detecting non-deterministic code in Java workflows. A proof-of-concept implementation was created at temporal-workflowcheck-java.",
      "category": "feature",
      "subcategory": "workflow-validation",
      "apis": [],
      "components": [
        "workflow-validator",
        "static-analyzer",
        "determinism-checker"
      ],
      "concepts": [
        "determinism",
        "static-analysis",
        "code-validation",
        "workflow-correctness",
        "tooling"
      ],
      "severity": "medium",
      "userImpact": "Helps Java SDK users identify and prevent non-deterministic code patterns in workflows that could cause replay failures.",
      "rootCause": null,
      "proposedFix": "Create a static analyzer tool to detect non-deterministic patterns in Java workflows, building on the PoC at cretz/temporal-workflowcheck-java",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Proof-of-concept implementation was created and shared by community member cretz",
      "related": [],
      "keyQuote": "I did a PoC of this at https://github.com/cretz/temporal-workflowcheck-java",
      "number": 1338,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:27:22.167Z"
    },
    {
      "summary": "Request for a high-level API for managing Temporal schedules in the Java SDK. This enhancement was tracked across SDKs in the features repository.",
      "category": "feature",
      "subcategory": "schedules",
      "apis": [
        "Schedule"
      ],
      "components": [
        "schedules",
        "api",
        "client"
      ],
      "concepts": [
        "schedules",
        "high-level-api",
        "recurring-workflows",
        "scheduling"
      ],
      "severity": "medium",
      "userImpact": "Users need a more accessible and intuitive API to create and manage recurring workflow executions.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in #1776 - a dedicated high-level schedules API was implemented for the Java SDK",
      "related": [
        73,
        1776
      ],
      "keyQuote": "High level API for schedules",
      "number": 1333,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:26:32.580Z"
    },
    {
      "summary": "SIGSEGV crash occurs when calling WorkflowServiceStubs.newServiceStub in Kubernetes pods running Alpine Linux with gRPC native transport. The issue is caused by incompatible Netty native libraries and can be resolved by upgrading to SDK v1.15.0+ which includes updated Netty with a fix.",
      "category": "bug",
      "subcategory": "grpc-native-transport",
      "apis": [
        "WorkflowServiceStubs.newServiceStubs"
      ],
      "components": [
        "grpc-java",
        "netty-native-transport",
        "service-stubs"
      ],
      "concepts": [
        "native-crash",
        "sigsegv",
        "alpine-linux",
        "grpc-transport",
        "jvm-crash",
        "kubernetes",
        "environment-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users running the Java SDK on Alpine Linux experience JVM crashes during worker initialization, making the SDK unusable in Alpine-based containers.",
      "rootCause": "Incompatible Netty native transport libraries in gRPC-Java when running on Alpine Linux (musl libc instead of glibc).",
      "proposedFix": "Upgrade to Temporal Java SDK v1.15.0 or later which includes gRPC-Java 1.48 and Netty 4.1.77 with fixes for Alpine compatibility.",
      "workaround": "Three temporary workarounds: (1) Pass `-Dio.grpc.netty.shaded.io.netty.transport.noNative=true` to disable native transport (performance impact), (2) Use LD_PRELOAD fix from gRPC issue, (3) Switch from Alpine Linux.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in SDK v1.15.0+ with updated Netty that resolves Alpine Linux compatibility issues.",
      "related": [
        8751
      ],
      "keyQuote": "this crash likely happened on Alpine. Passing `-Dio.grpc.netty.shaded.io.netty.transport.noNative=true` to JVM. I don't recommend this option long-term as it will have performance implications",
      "number": 1332,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:26:34.608Z"
    },
    {
      "summary": "Jacoco code coverage plugin causes test failures when processing synthetic methods, specifically the $jacocoInit method. The POJOWorkflowInterfaceMetadata class fails to recognize synthetic methods and expects them to have @WorkflowMethod, @SignalMethod or @QueryMethod annotations.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Worker.addWorkflowImplementationFactory"
      ],
      "components": [
        "POJOWorkflowInterfaceMetadata",
        "POJOWorkflowImplementationFactory",
        "test-infrastructure",
        "build-system"
      ],
      "concepts": [
        "code-coverage",
        "synthetic-methods",
        "annotation-processing",
        "test-execution",
        "jacoco",
        "gradle"
      ],
      "severity": "high",
      "userImpact": "Developers cannot generate code coverage reports for tests using Jacoco because the test suite fails to process synthetic methods injected by Jacoco.",
      "rootCause": "POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods() does not filter out synthetic methods created by Jacoco ($jacocoInit), causing IllegalArgumentException when expecting workflow annotations on synthetic methods.",
      "proposedFix": "Filter synthetic methods in POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods() to exclude methods like $jacocoInit that do not require workflow annotations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by updating method scanning logic to skip synthetic methods that are not actual workflow methods.",
      "related": [],
      "keyQuote": "I believe that synthetic methods (which jacoco may be creating) are not currently getting checked under getWorkflowInterfaceMethods in the POJOWorkflowInterfaceMetadata class",
      "number": 1331,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:26:33.965Z"
    },
    {
      "summary": "User requested a public API to check if the current thread is running under Workflow context, as Workflow.getInfo() throws an error when called from non-workflow threads. The capability already exists in the internal WorkflowUnsafe.isWorkflowThread() API.",
      "category": "feature",
      "subcategory": "workflow-context",
      "apis": [
        "Workflow.getInfo",
        "WorkflowUnsafe.isWorkflowThread"
      ],
      "components": [
        "workflow-context",
        "thread-management"
      ],
      "concepts": [
        "thread-safety",
        "context-detection",
        "workflow-isolation",
        "api-accessibility"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily determine if they are executing within a workflow context without risking exceptions, limiting safe conditional logic in shared code.",
      "rootCause": "Workflow.getInfo() throws an exception rather than providing a safe way to detect workflow context, forcing users to either rely on unsafe APIs or catch exceptions.",
      "proposedFix": "Expose io.temporal.workflow.unsafe.WorkflowUnsafe.isWorkflowThread() as a public API or create a new Workflow.isWorkflowThread() method.",
      "workaround": "Use the existing internal io.temporal.workflow.unsafe.WorkflowUnsafe.isWorkflowThread() API despite it being marked unsafe.",
      "resolution": "duplicate",
      "resolutionDetails": "The requested functionality already exists as WorkflowUnsafe.isWorkflowThread(); issue was closed as the API is available, though marked as internal/unsafe.",
      "related": [],
      "keyQuote": "Already exists as `io.temporal.workflow.unsafe.WorkflowUnsafe.isWorkflowThread`",
      "number": 1321,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:25:41.066Z"
    },
    {
      "summary": "TestServer incorrectly propagates the parent workflow's timeout to child workflows that don't have an explicit timeout specified, causing the child to timeout prematurely instead of running independently.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "test-server",
        "child-workflow",
        "timeout-handling"
      ],
      "concepts": [
        "timeout",
        "workflow-hierarchy",
        "timeout-propagation",
        "child-workflow",
        "test-isolation"
      ],
      "severity": "high",
      "userImpact": "Test developers cannot verify child workflows that are intended to run longer than their parent workflows, preventing proper testing of independent child workflow behavior.",
      "rootCause": "TestServer implementation propagates parent workflow timeout to child workflows when no explicit child timeout is specified",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "TestServer was updated to not propagate parent timeout to child workflows that don't have an explicit timeout",
      "related": [],
      "keyQuote": "A parent workflow with a short timeout should be able to start and abandon a child workflow without explicitly specifying a timeout and such a child can take a long time to finish on its own.",
      "number": 1319,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:25:39.605Z"
    },
    {
      "summary": "Improve javadoc documentation for ApplicationFailure to clarify interaction with retry options and failure handling. Consider adding convenience methods to create non-retryable failures directly from exceptions.",
      "category": "docs",
      "subcategory": "exception-handling",
      "apis": [
        "ApplicationFailure.newNonRetryableFailure",
        "ActivityOptions.retryOptions",
        "WorkflowImplementationOptions.setFailWorkflowExceptionTypes"
      ],
      "components": [
        "ApplicationFailure",
        "exception-handling",
        "activity-options",
        "workflow-options"
      ],
      "concepts": [
        "non-retryable-exceptions",
        "retry-policy",
        "failure-handling",
        "documentation",
        "api-usability",
        "exception-wrapping"
      ],
      "severity": "low",
      "userImpact": "Users have difficulty understanding how to properly create non-retryable failures and how they interact with retry options, requiring them to consult code or documentation beyond the javadoc.",
      "rootCause": null,
      "proposedFix": "Add comprehensive javadoc explaining the relationship between ApplicationFailure.newNonRetryableFailure(), ActivityOptions.retryOptions.setDoNotRetry, and WorkflowImplementationOptions.setFailWorkflowExceptionTypes. Add convenience methods to create non-retryable failures directly from exceptions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Javadoc was improved and convenience methods were added to ApplicationFailure for creating non-retryable failures.",
      "related": [],
      "keyQuote": "Consider adding additional methods that allow the creation of non-retryable ApplicationFailure from an exception directly without wrapping to simplify handling",
      "number": 1318,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:25:40.652Z"
    },
    {
      "summary": "Client and Workers should not retry INTERNAL errors in newer versions of Server. The retry behavior needs to be version-aware and depend on Server Capabilities to determine whether INTERNAL errors are retryable.",
      "category": "other",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "client",
        "worker",
        "error-handler",
        "retry-logic"
      ],
      "concepts": [
        "retry",
        "error-handling",
        "server-version",
        "capabilities",
        "internal-errors",
        "version-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users may experience unexpected retries of operations that should fail immediately when using newer Server versions, leading to delayed failures and confusion.",
      "rootCause": "Retry logic does not account for Server version differences in how INTERNAL errors are classified (retryable vs non-retryable).",
      "proposedFix": "Implement version-aware retry logic that queries Server Capabilities to determine the retryability of INTERNAL errors.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Retry behavior was updated to respect Server Capabilities for INTERNAL error handling across different Server versions.",
      "related": [
        6
      ],
      "keyQuote": "In newer versions of Server Internal errors are considered non-retryable. This logic has to depend on the Server version and specifically it's defined by the Server Capabilities.",
      "number": 1315,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:24:45.869Z"
    },
    {
      "summary": "The Temporal Server provides a getSystemInfo call that returns server capabilities. The Java SDK should call this method before any other client call to obtain server capabilities.",
      "category": "feature",
      "subcategory": "client-initialization",
      "apis": [
        "getSystemInfo"
      ],
      "components": [
        "client",
        "stubs",
        "server-communication"
      ],
      "concepts": [
        "server-capabilities",
        "client-setup",
        "feature-detection",
        "initialization",
        "api-versioning"
      ],
      "severity": "medium",
      "userImpact": "Users cannot discover what features are supported by their Temporal Server without explicit documentation or trial-and-error.",
      "rootCause": null,
      "proposedFix": "Call getSystemInfo from stubs or client before any other client call to obtain server capabilities",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was closed, indicating the feature was implemented",
      "related": [],
      "keyQuote": "This call needs to be performed by the stubs or client before any other client call.",
      "number": 1312,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:24:44.771Z"
    },
    {
      "summary": "TestActivityEnvironment lacks support for setting heartbeat details to test Activity methods that resume from previous heartbeats. Currently, the test framework cannot simulate retries or persist heartbeat data, making it difficult to test resumable activities.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestActivityEnvironment",
        "HeartbeatDetails"
      ],
      "components": [
        "testing",
        "activity-executor",
        "test-activity-environment"
      ],
      "concepts": [
        "heartbeat",
        "activity-retry",
        "resumable-workflow",
        "test-simulation",
        "checkpoint",
        "fault-tolerance"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot easily test long-running activities that use heartbeats to resume from checkpoints after failures.",
      "rootCause": "TestActivityEnvironment does not provide a mechanism to set or retrieve heartbeat details before activity execution, and treats all exceptions as non-retryable.",
      "proposedFix": "Add setHeartbeatDetails() method to TestActivityEnvironment that accepts activity name and heartbeat payload, with corresponding getHeartbeatDetails() called during executeActivity execution.",
      "workaround": "Use TestWorkflowEnvironment with an ad-hoc workflow that wraps the activity being tested, or refactor activities to avoid heartbeat dependency in tests.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented setHeartbeatDetails method in TestActivityEnvironment to allow simulating previous heartbeat calls during activity testing.",
      "related": [],
      "keyQuote": "It doesn't seem easy (or possible) to test Activity methods which make use of HeartbeatDetails for resuming an aborted process",
      "number": 1310,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:24:46.606Z"
    },
    {
      "summary": "Signal and query handlers should inherit client OpenTracing/OpenTelemetry spans as parent spans to form a complete distributed tracing chain, but currently lack this capability due to historical limitations in Temporal server APIs.",
      "category": "feature",
      "subcategory": "observability-tracing",
      "apis": [
        "signal",
        "query"
      ],
      "components": [
        "client",
        "signal-handler",
        "query-handler",
        "tracing"
      ],
      "concepts": [
        "distributed-tracing",
        "span-hierarchy",
        "observability",
        "opentracing",
        "opentelemetry",
        "signal-propagation",
        "context-inheritance"
      ],
      "severity": "medium",
      "userImpact": "Users cannot trace signal and query calls end-to-end from client to handler, breaking distributed tracing visibility.",
      "rootCause": "Temporal server signal and query APIs historically didn't support headers for transferring context like spanId from caller to handler.",
      "proposedFix": "Add header support to signal and query APIs to propagate span context from client calls to handlers.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in PR #1819 to support header propagation for signal and query calls.",
      "related": [
        1819
      ],
      "keyQuote": "Signal and query handlers and threads inherit the client span as a parent span and form a solid spans chain",
      "number": 1306,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:23:44.080Z"
    },
    {
      "summary": "Local activities do not respect cancellation scope cancellations and instead proceed to retry, preventing code after scope.run() from executing. This is a missing feature for local activities in the Java SDK.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "Workflow.newCancellationScope",
        "Workflow.newTimer"
      ],
      "components": [
        "local-activities",
        "cancellation-scope",
        "retry-policy"
      ],
      "concepts": [
        "cancellation",
        "local-activities",
        "retry",
        "scope",
        "heartbeat"
      ],
      "severity": "medium",
      "userImpact": "Users cannot cancel local activities with retry options using cancellation scopes, causing expected behavior to fail and blocking code execution.",
      "rootCause": "Heartbeats and cancellations are not supported for local activities in the Java SDK.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Heartbeats and cancelations are not supported for Local Activities in JavaSDK. It's a missing feature of Local Activities.",
      "number": 1303,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:23:43.477Z"
    },
    {
      "summary": "Users' data converters that perform IO operations sometimes trigger the deadlock detector. The request is to add a way to disable the deadlock detector for specific code sections and data converters, similar to the Go SDK implementation.",
      "category": "feature",
      "subcategory": "data-converter",
      "apis": [],
      "components": [
        "data-converter",
        "deadlock-detector",
        "workflow-unsafe"
      ],
      "concepts": [
        "deadlock-detection",
        "io-operations",
        "data-conversion",
        "timeout",
        "concurrency"
      ],
      "severity": "medium",
      "userImpact": "Users with IO-performing data converters experience false-positive deadlock detector triggering, causing workflow disruptions.",
      "rootCause": "Deadlock detector does not account for legitimate IO operations in data converters, treating them as potential deadlocks.",
      "proposedFix": "Add configuration option to disable deadlock detector for specific data converters and code sections under WorkflowUnsafe, following the Go SDK approach from PR #772.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to allow disabling deadlock detector for data converters performing IO operations.",
      "related": [],
      "keyQuote": "JavaSDK should have a way to disable deadline detector for a piece of code (under `WorkflowUnsafe`) and for a specific data converter.",
      "number": 1301,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:23:43.598Z"
    },
    {
      "summary": "Feature request to expose WorkflowInfo#getHistoryLength() allowing users to directly check if continue-as-new is needed by comparing history length against a threshold, rather than estimating based on event production.",
      "category": "feature",
      "subcategory": "workflow-lifecycle",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "history-management",
        "deterministic-replay"
      ],
      "concepts": [
        "history-length",
        "continue-as-new",
        "deterministic-behavior",
        "replay",
        "custom-metrics",
        "threshold-comparison"
      ],
      "severity": "medium",
      "userImpact": "Users gain a direct, reliable way to determine when to call continue-as-new without manually tracking event counts or guessing.",
      "rootCause": null,
      "proposedFix": "Expose getHistoryLength() method on WorkflowInfo that returns the exact history length value, ensuring it remains deterministic during replays.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Method was implemented and aligned with TypeScript SDK naming (historylength) to maintain consistency across SDKs.",
      "related": [],
      "keyQuote": "Users should be able to have a more direct way to check if it's time to call continue-as-new than guessing how many events their code produces",
      "number": 1300,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:22:43.071Z"
    },
    {
      "summary": "Users can set cron schedules using robfig format in WorkflowOptions but cannot use them in tests since TestWorkflowEnvironment only supports crontab style. This feature request asks for robfig predefined schedules and intervals support in the test environment.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowOptions"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "cron-scheduling",
        "test-utilities"
      ],
      "concepts": [
        "cron-scheduling",
        "robfig-format",
        "workflow-options",
        "testing",
        "schedule-intervals"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test workflows with robfig-style cron schedules, forcing them to use only crontab format in tests even when using robfig in production.",
      "rootCause": null,
      "proposedFix": "Add support for robfig predefined schedules and intervals in TestWorkflowEnvironment to match production WorkflowOptions capabilities.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #341, which addresses the same feature request.",
      "related": [
        341
      ],
      "keyQuote": "Users can set cron schedules in their WorkflowOptions using robfig schedules/intervals format, but they cannot currently use them in tests",
      "number": 1293,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:22:42.613Z"
    },
    {
      "summary": "Unit tests using Workflow.await(condition) without timeout fail intermittently with WorkflowNotFoundException when time skipping is enabled, particularly under concurrent load. The issue stems from time skipping advancing too far ahead during long polls, causing workflow task timeouts before signals can be processed.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.await"
      ],
      "components": [
        "test-server",
        "time-skipping",
        "workflow-execution",
        "signal-handling"
      ],
      "concepts": [
        "timeout",
        "time-skipping",
        "race-condition",
        "signal-delivery",
        "workflow-task",
        "concurrent-load",
        "test-framework"
      ],
      "severity": "medium",
      "userImpact": "Unit tests using time skipping with condition-only await calls fail intermittently, making tests unreliable and difficult to debug.",
      "rootCause": "Time skipping doesn't stop soon enough during long polls, advancing time too far to workflow task timeout, completing the workflow before signals can be delivered. No ordering guarantee between client code completion and server state updates.",
      "proposedFix": null,
      "workaround": "Add an explicit timeout to Workflow.await(timeout, condition) or avoid setting workflow timeout/time skipping in tests, though workaround is not fully reliable.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When you create a load, the client code doesn't stop time skipping soon enough and the time gets advanced A LOT to the workflow task timeout",
      "number": 1291,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:22:43.920Z"
    },
    {
      "summary": "Test Server experiences instability with child workflows that complete quickly, causing state machine errors where completion events arrive before initialization is recorded in history.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-service",
        "state-machine",
        "child-workflow"
      ],
      "concepts": [
        "race-condition",
        "state-transition",
        "workflow-completion",
        "concurrency",
        "event-ordering"
      ],
      "severity": "high",
      "userImpact": "Tests fail intermittently in loaded environments due to test server state machine violations when child workflows complete rapidly.",
      "rootCause": "Test Server observes child workflow completion before the start event is recorded in history, violating state machine transitions (INITIATED -> COMPLETE requires prior INITIATE event).",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Invalid Transition{from=INITIATED, action=COMPLETE}, history: [Transition{from=NONE, action=INITIATE}]",
      "number": 1288,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:21:36.873Z"
    },
    {
      "summary": "Kotlin stdlib version 1.5.20 has a medium severity vulnerability (CVE-2022-24329) related to dependency locking in multiplatform Gradle projects. The issue was automatically resolved when the vulnerable dependency was no longer part of the project inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "kotlin-stdlib",
        "gradle",
        "build-system"
      ],
      "concepts": [
        "dependency-locking",
        "vulnerability",
        "security",
        "multiplatform",
        "gradle-projects",
        "version-management"
      ],
      "severity": "medium",
      "userImpact": "Users building the Temporal Java SDK with vulnerable Kotlin stdlib versions faced potential integrity risks in dependency resolution for multiplatform Gradle projects.",
      "rootCause": "Kotlin stdlib 1.5.20 lacked proper dependency locking support for multiplatform Gradle projects, allowing potential integrity manipulation (CVSS 5.3).",
      "proposedFix": "Upgrade kotlin-stdlib to version 1.6.0-M1 or later to resolve the vulnerability.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was automatically closed by Mend because the vulnerable library was no longer part of the project's dependency inventory (likely upgraded in a subsequent commit).",
      "related": [],
      "keyQuote": "In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.",
      "number": 1287,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:21:36.777Z"
    },
    {
      "summary": "Kotlin Standard Library 1.4.32 contains a medium severity vulnerability (CVE-2022-24329) affecting dependency locking in Multiplatform Gradle Projects. The issue was automatically resolved when the vulnerable library was removed from the project's dependency inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "gradle-build",
        "kotlin-stdlib",
        "dependency-management"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-locking",
        "transitive-dependency",
        "cvss-5.3",
        "integrity-impact"
      ],
      "severity": "medium",
      "userImpact": "Users may be exposed to integrity attacks through the vulnerable Kotlin Standard Library dependency used in Multiplatform Gradle Projects.",
      "rootCause": "Kotlin Standard Library version 1.4.32 lacked proper dependency locking mechanism for Multiplatform Gradle Projects, allowing potential integrity compromise via network attack.",
      "proposedFix": "Upgrade kotlin-stdlib from 1.4.32 to 1.6.0 or later (kotlin-scripting-compiler-embeddable to 1.6.0)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was either marked as ignored or removed from the project's dependency inventory.",
      "related": [],
      "keyQuote": "In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.",
      "number": 1286,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:21:36.350Z"
    },
    {
      "summary": "Local activities scheduled asynchronously at the end of workflow execution without waiting on promises cause a NOT_FOUND exception and prevent workflow completion. The workflow should either ignore or safely execute these activities instead of failing.",
      "category": "bug",
      "subcategory": "local-activity-lifecycle",
      "apis": [
        "Async.procedure"
      ],
      "components": [
        "workflow-executor",
        "local-activity-scheduler",
        "async-handler"
      ],
      "concepts": [
        "asynchronous-execution",
        "workflow-completion",
        "activity-scheduling",
        "promise-handling",
        "lifecycle-management"
      ],
      "severity": "high",
      "userImpact": "Workflows fail with NOT_FOUND exception when developers schedule local activities asynchronously without awaiting them at workflow end.",
      "rootCause": "Workflow executor does not properly handle asynchronous activity scheduling that occurs after workflow logic completes, causing a race condition where activities attempt to execute after the workflow is marked completed.",
      "proposedFix": "Either safely ignore asynchronous activities scheduled after workflow completion or queue them for execution before completing the workflow.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by commit 8b3be3bb521f7ab62b7d384ee417d053286a95d5 which properly handles asynchronous local activities at workflow end.",
      "related": [
        1722
      ],
      "keyQuote": "An activity scheduled at the end of the workflow code asynchronously without waiting on the promise should be ignored. Such a code shouldn't block workflow completion.",
      "number": 1281,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:20:27.618Z"
    },
    {
      "summary": "Request to add trace-id and span-id to logs when using OpenTracingWorkerInterceptor in Java SDK. Currently these identifiers are not being printed, requiring users to implement custom interceptors as a workaround.",
      "category": "feature",
      "subcategory": "tracing-observability",
      "apis": [
        "OpenTracingWorkerInterceptor",
        "OpenTracingWorkflowInboundCallsInterceptor",
        "OpenTracingActivityInboundCallsInterceptor"
      ],
      "components": [
        "worker-interceptor",
        "logging",
        "tracing",
        "MDC"
      ],
      "concepts": [
        "observability",
        "distributed-tracing",
        "trace-context",
        "span-correlation",
        "logging-enrichment",
        "MDC-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily correlate logs with distributed traces without implementing custom interceptors, reducing observability in production systems.",
      "rootCause": null,
      "proposedFix": "Add trace-id and span-id to MDC-context within the OpenTracingWorkerInterceptor implementation.",
      "workaround": "Implement custom OpenTracingWorkerInterceptor, OpenTracingWorkflowInboundCallsInterceptor, and OpenTracingActivityInboundCallsInterceptor.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Add trace-id and span-id to MDC-context.",
      "number": 1273,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:20:26.894Z"
    },
    {
      "summary": "Feature request to add toString() methods to ActivityInfo and WorkflowInfo classes for improved logging and debugging. Currently developers must manually construct log messages with individual field accessors instead of simply logging the info object directly.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [
        "ActivityInfo",
        "WorkflowInfo"
      ],
      "components": [
        "activity-executor",
        "workflow-executor",
        "interceptor"
      ],
      "concepts": [
        "logging",
        "debugging",
        "string-representation",
        "activity-context",
        "workflow-context"
      ],
      "severity": "low",
      "userImpact": "Developers must write verbose logging code when inspecting ActivityInfo and WorkflowInfo objects, reducing code readability and maintainability.",
      "rootCause": null,
      "proposedFix": "Add toString() method implementations to ActivityInfo and WorkflowInfo classes that return a formatted string representation of all fields.",
      "workaround": "Manually construct log messages using individual getter methods for each field.",
      "resolution": "fixed",
      "resolutionDetails": "toString() methods were added to both ActivityInfo and WorkflowInfo classes.",
      "related": [],
      "keyQuote": "It is often necessary (especially in interceptors) to log all info about workflow or activity.",
      "number": 1272,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:20:27.052Z"
    },
    {
      "summary": "Add unit test covering scenario of Server outage during Worker sending workflow task execution result. This addresses the bug fixed in PR #1265 where workers fail to handle Temporal Server being down when reporting results.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "worker",
        "test-server",
        "result-reporting"
      ],
      "concepts": [
        "server-outage",
        "fault-tolerance",
        "test-coverage",
        "error-handling",
        "result-reporting"
      ],
      "severity": "medium",
      "userImpact": "Users need reliable unit tests to verify worker behavior during server outages to prevent similar bugs and ensure stability.",
      "rootCause": "No test coverage exists for the scenario where Temporal Server is down when workers attempt to report workflow task execution results.",
      "proposedFix": "Add support in Test Server to simulate outages during result reporting and implement corresponding unit test for this scenario.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1265
      ],
      "keyQuote": "Temporal SDK should add support for such tests to Test Server. Also, a unit test for this bug and fix should be implemented.",
      "number": 1266,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:19:44.604Z"
    },
    {
      "summary": "Workflows become stuck waiting for local activity results when a workflow task heartbeat occurs during the execution of a sequence of local activities. The last scheduled local activity before the heartbeat is not properly tracked, causing the outstanding activity counter to reach zero while work remains pending.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "ReplayWorkflowRunTaskHandler",
        "LocalActivityStubImpl",
        "WorkflowThreadContext",
        "state-machines"
      ],
      "concepts": [
        "workflow-task-heartbeat",
        "local-activity",
        "synchronous-execution",
        "outstanding-work-tracking",
        "event-loop",
        "task-timeout"
      ],
      "severity": "high",
      "userImpact": "Users experience stuck workflows that appear to be waiting for local activities that are not actually executing, with no automatic recovery.",
      "rootCause": "A `break` statement in ReplayWorkflowRunTaskHandler prevents the last scheduled local activity from being processed by state machines before a heartbeat, causing the outstanding local activities counter to incorrectly reach zero while work remains pending, leading to premature workflow task closure instead of heartbeat.",
      "proposedFix": "Modify the break logic in ReplayWorkflowRunTaskHandler to ensure all scheduled local activities are accounted for in the outstanding activities counter before performing a heartbeat.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed through proper tracking of local activities before workflow task heartbeat to prevent premature task closure.",
      "related": [],
      "keyQuote": "Because of a `break` here... this local activity command will never be taken by the state machines and accounted for in the outstanding local activities counter.",
      "number": 1262,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:19:46.651Z"
    },
    {
      "summary": "Local activities fail to retry after reaching the LocalActivityThreshold and don't schedule server-side timers as expected. Instead of backing off with a server timer, the failure propagates directly to the workflow.",
      "category": "bug",
      "subcategory": "local-activity-retry",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "local-activity-executor",
        "retry-policy",
        "timer-scheduler"
      ],
      "concepts": [
        "retry",
        "backoff",
        "local-activity-threshold",
        "server-timer",
        "failure-handling"
      ],
      "severity": "high",
      "userImpact": "Local activities fail permanently instead of retrying with server-side timers, causing workflows to fail unexpectedly when local retries are exhausted.",
      "rootCause": "Code that scheduled the server-side timer after reaching LocalActivityThreshold was removed during early error handling reimplementation in PR #101, and the regression was not caught by existing tests.",
      "proposedFix": "Restore the timer scheduling logic that was removed in PR #101 to ensure server-side timers are scheduled when LocalActivityThreshold is reached.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Timer scheduling logic was restored to properly handle local activity retries after reaching the threshold.",
      "related": [
        101
      ],
      "keyQuote": "Local Activity should schedule a timer on the server when it reaches LocalActivityThreshold according to its backoff strategy.",
      "number": 1261,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:19:45.477Z"
    },
    {
      "summary": "User reports that when a long-lived workflow execution is rescheduled across multiple workers, each worker reports its own gauge metric with outdated values instead of a single consolidated metric. The issue raises questions about whether gauges should be workflow-aware or worker-specific.",
      "category": "question",
      "subcategory": "metrics-gauges",
      "apis": [
        "Workflow.getMetricScope()"
      ],
      "components": [
        "metrics",
        "worker",
        "gauge",
        "micrometer"
      ],
      "concepts": [
        "gauge",
        "metric-deduplication",
        "workflow-scheduling",
        "worker-affinity",
        "metric-lifecycle"
      ],
      "severity": "low",
      "userImpact": "Users may see duplicate and stale gauge metrics when workflows are rescheduled across multiple workers, potentially causing confusion about actual metric values.",
      "rootCause": "Gauges in the metrics system are host/worker-specific, not workflow-aware. When a workflow moves to a new worker, the old worker continues reporting its own gauge instance with the last recorded value.",
      "proposedFix": "SDK could add a listener interface around workflow scheduling to allow users to evict metric gauges from the registry when workflows stop running on a worker.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Marked invalid because the reported behavior is the expected and correct behavior of worker gauges. Gauges are host-specific metrics, not workflow-isolated. Users should not create unique gauges per workflow.",
      "related": [],
      "keyQuote": "This gauge is not some magic Temporal Workflow aware Gauge. It's a standard gauge in this host's metrics set.",
      "number": 1260,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:19:05.669Z"
    },
    {
      "summary": "Activity heartbeats fail silently without retry on network outages, causing activities to timeout prematurely. The issue requests implementing exponential backoff retries for failed heartbeats to make them more robust.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "ActivityContext.heartbeat()"
      ],
      "components": [
        "activity-executor",
        "heartbeat-executor",
        "retry-logic"
      ],
      "concepts": [
        "heartbeat",
        "retry",
        "network-resilience",
        "exponential-backoff",
        "timeout",
        "activity-termination"
      ],
      "severity": "high",
      "userImpact": "Activities can be terminated with heartbeat timeout during temporary network issues even when heartbeating regularly.",
      "rootCause": "Failed heartbeats are ignored without retry logic, leaving no mechanism to recover from transient network failures.",
      "proposedFix": "Use heartbeatExecutor to schedule asynchronous retries with exponential backoff throttling strategy for failed heartbeats.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If we get a network blip, such an activity will be terminated with heartbeat timeout.",
      "number": 1258,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:19:03.705Z"
    },
    {
      "summary": "Worker shutdown is delayed because scheduled throttled activity heartbeat tasks are not properly drained during graceful shutdown. The heartbeat executor times out waiting for these tasks, forcing a fallback to forceful shutdown.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "heartbeat-executor",
        "shutdown-manager"
      ],
      "concepts": [
        "shutdown",
        "graceful-shutdown",
        "heartbeat",
        "timeout",
        "task-draining",
        "executor"
      ],
      "severity": "medium",
      "userImpact": "Workers experience delayed shutdown times when activities have scheduled heartbeats, impacting deployment and scaling operations.",
      "rootCause": "Scheduled throttled activity heartbeat tasks are not being properly drained during the graceful shutdown process of the heartbeat executor.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Worker shutdown is delayed on the shutdown of activity heartbeat executor because there are scheduled heartbeat tasks.",
      "number": 1257,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:19:03.702Z"
    },
    {
      "summary": "Activity heartbeats that are throttled and cached are not properly drained or discarded when the activity completes or the worker shuts down gracefully, potentially causing issues with cleanup and resource management.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "worker",
        "heartbeat-manager"
      ],
      "concepts": [
        "heartbeat",
        "throttling",
        "caching",
        "graceful-shutdown",
        "resource-cleanup",
        "activity-completion"
      ],
      "severity": "medium",
      "userImpact": "Cached heartbeats may not be properly cleaned up, potentially leaving orphaned heartbeat operations and causing resource leaks during activity completion or worker shutdown.",
      "rootCause": "The heartbeat throttling and caching mechanism does not drain or cancel pending heartbeats when activities complete or workers shut down gracefully.",
      "proposedFix": "The last cached heartbeat should be either drained before activity completion or discarded/canceled, with the same behavior applied during graceful worker shutdown.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing proper cleanup of cached heartbeats during activity completion and worker shutdown.",
      "related": [],
      "keyQuote": "The last cached heartbeat should be either drained before the activity completion or discarded/canceled. This also should be happening during graceful worker shutdown.",
      "number": 1256,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:18:24.804Z"
    },
    {
      "summary": "Client query calls hang for 60 seconds when the worker is executing a local activity that exceeds the timeout period. The client should fail with a WorkflowServiceException based on rpcTimeout (default 10s) instead of waiting for the max workflow task timeout.",
      "category": "bug",
      "subcategory": "query-timeout",
      "apis": [
        "Query"
      ],
      "components": [
        "query-handler",
        "local-activity-executor",
        "workflow-task-executor"
      ],
      "concepts": [
        "timeout",
        "rpc-timeout",
        "local-activity",
        "query-execution",
        "deadline"
      ],
      "severity": "high",
      "userImpact": "Users experience 60-second delays on query calls during local activity execution instead of timely failures, degrading application responsiveness.",
      "rootCause": "Query execution flow does not properly respect rpcTimeout when the worker is executing local activities; appears related to workflow task execution structure.",
      "proposedFix": null,
      "workaround": null,
      "related": [
        1346
      ],
      "keyQuote": "The client call should instead fail with WorkflowServiceException according to rpcTimeout (default 10s).",
      "resolution": null,
      "resolutionDetails": null,
      "number": 1246,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:18:25.198Z"
    },
    {
      "summary": "WorkflowStub.getResultAsync performs unbalanced time locking (unlock-lock-lock sequence) in test environments with time-skipping, causing a time lock leak. This regression was introduced in Java SDK 1.12.0.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "getResultAsync"
      ],
      "components": [
        "WorkflowStub",
        "test-framework",
        "time-skipping"
      ],
      "concepts": [
        "time-locking",
        "test-environment",
        "resource-leak",
        "synchronization",
        "time-skipping"
      ],
      "severity": "high",
      "userImpact": "Users testing workflows with time-skipping and getResultAsync encounter time lock leaks that can cause test hangs or failures.",
      "rootCause": "Unbalanced unlock-lock-lock sequence in getResultAsync when used with time-skipping in test environment",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was fixed by restoring balanced time locking in getResultAsync",
      "related": [
        1210
      ],
      "keyQuote": "WorkflowStub.getResultAsync performs the sequence of unlock-lock-lock in test environment with time-skipping, leading to a leak and retaining a time lock.",
      "number": 1243,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:18:24.780Z"
    },
    {
      "summary": "WorkflowHistoryIterator needs refactoring to improve deadline handling, exception reporting, and add protection against infinite event loops from the server, similar to what exists in Core.",
      "category": "feature",
      "subcategory": "history-pagination",
      "apis": [
        "WorkflowHistoryIterator"
      ],
      "components": [
        "worker",
        "history-fetcher",
        "deadline-handler"
      ],
      "concepts": [
        "pagination",
        "timeout",
        "deadline",
        "exception-handling",
        "infinite-loop-protection"
      ],
      "severity": "medium",
      "userImpact": "Users experience improved reliability and visibility when paginating workflow history, with better timeout handling and protection against server-side event loop issues.",
      "rootCause": "Current WorkflowHistoryIterator implementation lacks robust deadline calculation, comprehensive logging, and protection against server returning events in infinite loops.",
      "proposedFix": "Implement build-in protection from server returning events in a loop (reference implementation in Core SDK), improve deadline calculations based on currentTimeMillis, enhance exception handling and logging with more information about workflow task timeout and elapsed time.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "WorkflowHistoryIterator implementation related to deadline... requires a revisit and polishing.",
      "number": 1242,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:17:45.309Z"
    },
    {
      "summary": "DynamicWorkflow implementations do not respect WorkflowImplementationOptions settings like setFailWorkflowExceptionTypes. When a NullPointerException is thrown in a dynamic workflow, it is not failed even when NPE is configured to fail the workflow, whereas regular workflow implementations handle this correctly.",
      "category": "bug",
      "subcategory": "dynamic-workflow",
      "apis": [
        "registerWorkflowImplementationTypes",
        "DynamicWorkflow",
        "WorkflowImplementationOptions"
      ],
      "components": [
        "worker",
        "workflow-implementation",
        "dynamic-workflow",
        "exception-handling"
      ],
      "concepts": [
        "exception-handling",
        "workflow-configuration",
        "dynamic-workflows",
        "option-inheritance",
        "configuration-validation"
      ],
      "severity": "high",
      "userImpact": "Users registering dynamic workflows cannot configure exception handling behavior, leading to inconsistent failure handling between dynamic and regular workflows.",
      "rootCause": "WorkflowImplementationOptions are not being applied when executing dynamic workflows, likely due to separate code path that bypasses option processing.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "throwing NullPointerException inside Dynamic workflow does not take in account WorkflowImplementationOptions and will not fail when NPE is thrown. This works fine for normal workflow impls",
      "number": 1241,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:17:46.326Z"
    },
    {
      "summary": "When a workflow is replayed with code that calls `getVersion()` with a range that doesn't include `DEFAULT_VERSION`, the replay should fail with `UnsupportedVersion`. Currently, it incorrectly tolerates unversioned code by returning `DEFAULT_VERSION` even though it's outside the specified range.",
      "category": "bug",
      "subcategory": "workflow-versioning",
      "apis": [
        "getVersion"
      ],
      "components": [
        "workflow-versioning",
        "replay-engine",
        "version-resolver"
      ],
      "concepts": [
        "versioning",
        "workflow-replay",
        "version-compatibility",
        "code-evolution",
        "backward-compatibility",
        "state-machine"
      ],
      "severity": "high",
      "userImpact": "Users can inadvertently run incompatible workflow code during replay, leading to incorrect workflow execution and potential data corruption.",
      "rootCause": "The getVersion implementation returns DEFAULT_VERSION for unversioned code even when the caller specified a version range that excludes DEFAULT_VERSION, violating the versioning contract.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "getVersion now properly validates that the requested version is within the specified range and throws UnsupportedVersion if DEFAULT_VERSION is not in the valid range.",
      "related": [],
      "keyQuote": "Workflow.getVersion(\"changeId\", 1, 2) returns DEFAULT_VERSION",
      "number": 1239,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:17:45.176Z"
    },
    {
      "summary": "Worker startup logging needs improvement to explicitly report whether pollers are started on task queues and to display registered workflow and activity types for better diagnostics and UI visibility.",
      "category": "feature",
      "subcategory": "worker-startup-logging",
      "apis": [
        "StartWorker"
      ],
      "components": [
        "worker",
        "poller",
        "logging"
      ],
      "concepts": [
        "diagnostics",
        "startup",
        "visibility",
        "task-queue",
        "registration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily diagnose worker startup issues or verify that workers are properly configured and visible in monitoring tools without detailed logging.",
      "rootCause": null,
      "proposedFix": "Add explicit logging to report poller startup status per task queue and list registered workflow and activity types during worker initialization.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker startup logging was enhanced to provide more diagnostic information about poller initialization and registered types.",
      "related": [],
      "keyQuote": "Worker should explicitly report if it does or especially DOESN'T start a poller on the workflow task queue.",
      "number": 1238,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:17:05.437Z"
    },
    {
      "summary": "Workflow.getWorkflowExecution() throws ClassCastException when called with an external workflow stub created via Workflow.newExternalWorkflowStub(). The method expects a ChildWorkflowStub but receives an ExternalWorkflowStubImpl, despite the javadoc indicating both should be supported.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "Workflow.getWorkflowExecution",
        "Workflow.newExternalWorkflowStub",
        "Workflow.getInfo"
      ],
      "components": [
        "external-workflow-stub",
        "workflow-execution",
        "type-casting"
      ],
      "concepts": [
        "external-workflow",
        "parent-workflow",
        "stub-creation",
        "type-compatibility",
        "workflow-execution-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot retrieve workflow execution information when working with external workflow stubs, limiting parent-child workflow communication capabilities.",
      "rootCause": "ExternalWorkflowStubImpl is cast to ChildWorkflowStub in Workflow.getWorkflowExecution(), but the method should accept both stub types as documented.",
      "proposedFix": "Modify Workflow.getWorkflowExecution() to accept ExternalWorkflowStubImpl in addition to ChildWorkflowStub, or adjust the type hierarchy to support both.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bug fix implemented to support both ChildWorkflowStub and ExternalWorkflowStubImpl types in getWorkflowExecution().",
      "related": [],
      "keyQuote": "per javadoc it should also work with externalworkflow stub",
      "number": 1237,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:17:06.241Z"
    },
    {
      "summary": "Users need a built-in Prometheus scrape endpoint implementation in the Java SDK to easily export metrics from the micrometer reporter without implementing their own custom endpoint.",
      "category": "feature",
      "subcategory": "metrics-export",
      "apis": [],
      "components": [
        "metrics",
        "micrometer-reporter",
        "observability"
      ],
      "concepts": [
        "prometheus",
        "monitoring",
        "metrics-export",
        "observability",
        "configuration",
        "port-binding"
      ],
      "severity": "medium",
      "userImpact": "Users must currently implement their own Prometheus scrape endpoint, adding friction to metrics collection setup.",
      "rootCause": null,
      "proposedFix": "Add a built-in Prometheus scrape endpoint implementation to the JavaSDK with configurable port and URL to avoid port conflicts.",
      "workaround": "Users can manually implement a scrape endpoint following Tanzu documentation for exposing metrics to Prometheus.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal JavaSDK should have a built-in implementation of a scrape endpoint for prometheus. This endpoint should allow port/url configuration to be passed to avoid any port conflicts.",
      "number": 1234,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:17:05.707Z"
    },
    {
      "summary": "ActivityCompletionClient is a public API that lacks documentation. This issue requests adding Javadocs to this user-facing interface to help users understand its purpose and usage.",
      "category": "docs",
      "subcategory": "activity-completion",
      "apis": [
        "ActivityCompletionClient"
      ],
      "components": [
        "activity-executor",
        "javadoc"
      ],
      "concepts": [
        "documentation",
        "public-api",
        "activity-completion",
        "user-facing-interface",
        "api-clarity"
      ],
      "severity": "low",
      "userImpact": "Users are unable to understand the purpose and usage of ActivityCompletionClient due to missing documentation.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Javadocs were added to ActivityCompletionClient as part of documentation improvements.",
      "related": [
        1354
      ],
      "keyQuote": "ActivityCompletionClient is a public user-facing interface and it is currently undocumented.",
      "number": 1233,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:16:25.036Z"
    },
    {
      "summary": "Request to support dynamic creation and shutdown of individual workers without recreating the entire WorkerFactory, to handle scenarios with dynamic task queues.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "WorkerFactory"
      ],
      "components": [
        "worker",
        "worker-factory",
        "task-queue-management"
      ],
      "concepts": [
        "dynamic-workers",
        "lifecycle-management",
        "task-queues",
        "resource-efficiency"
      ],
      "severity": "medium",
      "userImpact": "Users with dynamic task queues must currently recreate the entire WorkerFactory instead of being able to start/stop individual workers.",
      "rootCause": null,
      "proposedFix": "Allow starting and stopping of individual workers without recreating the WorkerFactory.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Not supported in any other SDK and not currently planned.",
      "related": [
        966
      ],
      "keyQuote": "To support this use case without a huge overhead we should allow starting and stopping of individual workers without the need to recreate the whole WorkersFactory",
      "number": 1230,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:16:25.450Z"
    },
    {
      "summary": "Time skipping was not being disabled in 1.11.0 even when explicitly set to false via TestEnvironmentOptions, causing tests with Kafka integration to fail immediately due to artificial time advancement.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment",
        "TestEnvironmentOptions",
        "WorkflowOptions"
      ],
      "components": [
        "test-environment",
        "time-skipping",
        "workflow-testing"
      ],
      "concepts": [
        "test-isolation",
        "time-control",
        "external-integrations",
        "async-actions",
        "test-timeout"
      ],
      "severity": "high",
      "userImpact": "Tests that depend on disabling time skipping (e.g., for external service integration) fail immediately in 1.11.0 when they worked in 1.8.1.",
      "rootCause": "Configuration flag for disabling time skipping was not being properly honored in the test environment implementation.",
      "proposedFix": null,
      "workaround": "Downgrade to 1.8.1 or wait for fix in next version.",
      "resolution": "fixed",
      "resolutionDetails": "Already fixed as noted in linked issue #1219.",
      "related": [
        1219
      ],
      "keyQuote": "When running a test environment with disabled time-skipping, time should not be magically incremented by the test environment.",
      "number": 1226,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:16:27.180Z"
    },
    {
      "summary": "Test server generates duplicate activity task tokens on retry instead of unique tokens for each attempt. This issue is a duplicate of #84.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "activity-task-handler",
        "task-token-generator"
      ],
      "concepts": [
        "task-token",
        "retry",
        "activity-execution",
        "test-server-behavior",
        "token-uniqueness"
      ],
      "severity": "medium",
      "userImpact": "Test server behaves incorrectly during activity retries, issuing the same token which can cause test failures and incorrect behavior simulation.",
      "rootCause": "Test server's token generation logic does not account for retry attempts, reusing the same token for activity tasks.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Issue is a duplicate of #84 where the same problem is tracked.",
      "related": [
        84
      ],
      "keyQuote": "Same token issued",
      "number": 1223,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:15:46.447Z"
    },
    {
      "summary": "Test Server usage message is unclear about what 'command' means, doesn't indicate optional parameters, and provides no feedback when the server starts successfully. User requests clarification in help text and startup confirmation message.",
      "category": "docs",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "cli"
      ],
      "concepts": [
        "usability",
        "documentation",
        "startup-feedback",
        "command-line-interface",
        "error-messages"
      ],
      "severity": "low",
      "userImpact": "Users are confused by unclear usage documentation and lack of startup confirmation, making it difficult to verify the Test Server is running correctly.",
      "rootCause": null,
      "proposedFix": "Clarify 'command' in usage text (referring to the executable itself), indicate optional parameters with brackets, and display a confirmation message when the server starts successfully and is ready for requests.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer decided not to change the usage message because the command path varies by platform (./temporal-test-server vs ./temporal-test-server.exe) and users may rename the executable.",
      "related": [],
      "keyQuote": "for linux it's \"./temporal-test-server\", for windows it's \"./temporal-test-server.exe\" and what if users renamed the file?",
      "number": 1222,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:15:46.891Z"
    },
    {
      "summary": "Test Server does not populate the FirstExecutionRunId field in WorkflowExecutionStartedEventAttributes when retrieving workflow history, while the normal Temporal server correctly sets it to the run ID of the started workflow.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "GetWorkflowExecutionHistory"
      ],
      "components": [
        "test-server",
        "history",
        "event-attributes"
      ],
      "concepts": [
        "workflow-execution",
        "history-events",
        "run-id",
        "test-server-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Tests that validate FirstExecutionRunId behavior fail on Test Server despite passing on production Temporal server, breaking test compatibility.",
      "rootCause": "Test Server implementation does not populate the FirstExecutionRunId field in WorkflowExecutionStartedEventAttributes during history retrieval.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the Test Server to properly populate FirstExecutionRunId in history events.",
      "related": [],
      "keyQuote": "On the \"normal\" server, it is a non-null, non-whitespace string that is the same as the run-id just of the run started. On Test Server it is empty.",
      "number": 1221,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:15:46.435Z"
    },
    {
      "summary": "The test server crashes with a RuntimeException when attempting to start a workflow with a duplicate ID. The error occurs in protobuf reflection when trying to pack error details, specifically due to a missing getStartRequestId() method on WorkflowExecutionAlreadyStartedFailure.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflowExecution"
      ],
      "components": [
        "test-service",
        "error-handling",
        "protobuf-reflection",
        "grpc"
      ],
      "concepts": [
        "duplicate-workflow-id",
        "error-details",
        "graal-vm",
        "reflection",
        "protobuf"
      ],
      "severity": "high",
      "userImpact": "Integration tests fail when starting workflows with duplicate IDs on the test server, even though the same code works correctly on local and cloud servers.",
      "rootCause": "The WorkflowExecutionAlreadyStartedFailure proto message is missing the getStartRequestId() method required by protobuf reflection. This is likely a Graal VM-specific issue where error detail protos are not properly available for reflection.",
      "proposedFix": "Make the entire errordetails.v1 package available for reflection, or ensure that WorkflowExecutionAlreadyStartedFailure and QueryFailedFailure have all required methods for protobuf reflection.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by ensuring proper protobuf message definitions and reflection support for error details.",
      "related": [],
      "keyQuote": "Generated message class \"io.temporal.api.errordetails.v1.WorkflowExecutionAlreadyStartedFailure\" missing method \"getStartRequestId\".",
      "number": 1220,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:15:07.812Z"
    },
    {
      "summary": "Calling WorkflowStub.getResult re-enables time skipping even when disabled in TestEnvironmentOptions, causing workflows to time out prematurely when interacting with asynchronous operations.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowStub.getResult",
        "TestService.UnlockTimeSkipping"
      ],
      "components": [
        "test-environment",
        "workflow-stub",
        "time-skipping"
      ],
      "concepts": [
        "time-skipping",
        "test-execution",
        "workflow-timeout",
        "async-operations",
        "test-configuration"
      ],
      "severity": "high",
      "userImpact": "Users writing tests with disabled time skipping experience unexpected workflow timeouts when calling getResult, breaking tests that rely on asynchronous signal interactions.",
      "rootCause": "WorkflowStub.getResult calls TestService.UnlockTimeSkipping API even when time skipping was explicitly disabled in TestEnvironmentOptions.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #1210",
      "related": [
        1210
      ],
      "keyQuote": "Calling WorkflowStub.getResult appears to call the temporal.api.testservice.v1.TestService/UnlockTimeSkipping API, which fast-forwards the workflow execution",
      "number": 1219,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:15:07.572Z"
    },
    {
      "summary": "Request to automatically log the stack trace of activity threads when they fail to heartbeat within the heartbeat interval or exceed the start-to-close timeout. This would help troubleshoot common activity execution failures.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat-manager",
        "logging"
      ],
      "concepts": [
        "heartbeat",
        "timeout",
        "stack-trace",
        "debugging",
        "activity-thread",
        "diagnostics"
      ],
      "severity": "medium",
      "userImpact": "Users will have better visibility into why activities are failing to complete or heartbeat, reducing debugging time.",
      "rootCause": null,
      "proposedFix": "Automatically log the stack of the activity thread if an activity didn't heartbeat within heartbeat interval or an activity failed to complete for the start to close timeout.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Automatically log the stack of the activity thread if an activity didn't heartbeat within heartbeat interval or an activity failed to complete for the start to close timeout.",
      "number": 1216,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:15:06.318Z"
    },
    {
      "summary": "The Java SDK's getResultAsync() method starts a long poll that continues running even if the returned Future is discarded by user code, causing resource leaks. The issue requests automatic cancellation of the background poll when the Future is garbage collected using weak or phantom references.",
      "category": "feature",
      "subcategory": "workflow-result-retrieval",
      "apis": [
        "WorkflowStub.getResultAsync",
        "Future.get",
        "CompletableFuture"
      ],
      "components": [
        "workflow-stub",
        "result-polling",
        "async-execution"
      ],
      "concepts": [
        "resource-leak",
        "garbage-collection",
        "background-polling",
        "future-management",
        "weak-references",
        "lifecycle-management"
      ],
      "severity": "medium",
      "userImpact": "Users unknowingly create resource leaks when using getResultAsync() without consuming the Future, forcing them to add timeouts as a workaround.",
      "rootCause": "The SDK maintains strong references to polling tasks regardless of whether the user code still references the returned CompletableFuture.",
      "proposedFix": "Implement weak or phantom reference tracking on the returned CompletableFuture to automatically cancel background long polls when the Future is garbage collected.",
      "workaround": "Pass a timeout parameter to getResultAsync() to limit poll duration, though this is unconventional and not documented as a leak prevention mechanism.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal Java SDK code should maintain a weak or phantom reference on the CompletableFuture that we return to the users and cancel the background long poll when it's discarded",
      "number": 1212,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:14:27.383Z"
    },
    {
      "summary": "MDC (Mapped Diagnostic Context) logging properties set before a promise handler are not propagating into the logs within the handler, affecting context-aware logging in workflows.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "promise-handler",
        "mdc-context",
        "logging"
      ],
      "concepts": [
        "mdc",
        "context-propagation",
        "logging",
        "promise",
        "handler",
        "diagnostic-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot track correlated log entries through promise handlers, making debugging and monitoring of workflow execution more difficult.",
      "rootCause": "MDC context is not being properly propagated into the scope of promise handlers during execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The MDC markers placed before a promise handler do not appear in the log within the handler.",
      "number": 1211,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:14:25.837Z"
    },
    {
      "summary": "GrpcRetryer is logging errors at inappropriate log levels, including final exceptions. The component should only log at Trace level for debugging, allowing calling code to handle exception logging appropriately.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "error-handling",
        "logging"
      ],
      "concepts": [
        "logging-levels",
        "exception-handling",
        "error-propagation",
        "debugging",
        "separation-of-concerns"
      ],
      "severity": "medium",
      "userImpact": "Users see verbose error logs from GrpcRetryer that obscure application-level error handling and logging strategies.",
      "rootCause": "GrpcRetryer logs exceptions at inappropriate levels without context about whether errors are actionable at that layer.",
      "proposedFix": "Reduce GrpcRetryer logging to Trace level only, allowing calling code to handle exception logging and propagation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Logging was reduced to Trace level in GrpcRetryer, delegating exception handling responsibility to calling code.",
      "related": [],
      "keyQuote": "GrpcRetryer doesn't have a context to understand which exception is a problem and which is not, only the calling code does.",
      "number": 1208,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:14:26.941Z"
    },
    {
      "summary": "Implement support for immediate local dispatch of new workflow tasks to the same worker in response to workflow task completion, matching an optimization available in Temporal Server.",
      "category": "feature",
      "subcategory": "workflow-task-dispatch",
      "apis": [],
      "components": [
        "worker",
        "workflow-task-handler",
        "task-dispatcher"
      ],
      "concepts": [
        "optimization",
        "dispatch",
        "workflow-task",
        "performance",
        "local-execution",
        "response-handling"
      ],
      "severity": "medium",
      "userImpact": "Enables better performance and efficiency by allowing workflow tasks to be dispatched locally without round-trip latency.",
      "rootCause": null,
      "proposedFix": "Support immediate local dispatch in the JavaSDK's workflow task completion response handling to match Server implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented immediate dispatch of new workflow tasks in workflow task completion response",
      "related": [],
      "keyQuote": "Temporal Server implemented a new optimization. It supported an immediate local dispatch of a new workflow task to the same Worker",
      "number": 1206,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:13:44.095Z"
    },
    {
      "summary": "Test server throws a NullPointerException when processing a workflow query request that lacks a gRPC deadline. This causes the test service to crash instead of gracefully handling the absent deadline.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "QueryWorkflow"
      ],
      "components": [
        "test-service",
        "workflow-service",
        "grpc-handler"
      ],
      "concepts": [
        "deadline",
        "null-pointer",
        "error-handling",
        "test-server",
        "query",
        "grpc"
      ],
      "severity": "high",
      "userImpact": "Test server crashes when queries lack gRPC deadlines, breaking tests and preventing users from testing workflows with optional deadlines.",
      "rootCause": "QueryWorkflow method in TestWorkflowService does not null-check the deadline field before dereferencing it at line 953.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The null pointer exception was fixed by adding proper null-checking for the deadline field in the TestWorkflowService.queryWorkflow method.",
      "related": [],
      "keyQuote": "NullPointer is thrown at io.temporal.internal.testservice.TestWorkflowService.queryWorkflow(TestWorkflowService.java:953)",
      "number": 1205,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:13:45.719Z"
    },
    {
      "summary": "GrpcRetryer's long polling retry code uses error-prone elapsed time calculations instead of absolute deadlines. The solution is to rework GrpcRetryer to accept absolute deadlines directly through internal RetryerOptions.",
      "category": "feature",
      "subcategory": "grpc-retry",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "long-polling",
        "retry-logic"
      ],
      "concepts": [
        "deadline",
        "timeout",
        "retry",
        "elapsed-time",
        "connection-management",
        "polling"
      ],
      "severity": "medium",
      "userImpact": "Developers using the Java SDK's retry mechanism benefit from cleaner, less error-prone timeout handling with absolute deadlines.",
      "rootCause": "Current implementation requires manual and error-prone calculation of elapsed and remaining time instead of using absolute deadlines.",
      "proposedFix": "Rework GrpcRetryer to support absolute deadline directly through internal RetryerOptions, eliminating the need for explicit deadline-to-timeout conversion.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by PR #1209 which implemented the rework to use absolute deadlines.",
      "related": [
        1209
      ],
      "keyQuote": "GrpcRetryer should support an absolute deadline directly, without error-prone explicit converting of the absolute deadline to the timeout duration.",
      "number": 1203,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:13:44.835Z"
    },
    {
      "summary": "RpcRetryOptions is exposed in a public API package (serviceclient) but is not intended for direct SDK user consumption. The class should be moved to an internal package to allow modification flexibility, but this won't be done as the class is exposed through WorkflowStubOptions.Builder.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [
        "WorkflowStubOptions"
      ],
      "components": [
        "serviceclient",
        "WorkflowStubOptions",
        "RpcRetryOptions"
      ],
      "concepts": [
        "public-api",
        "internal-package",
        "api-encapsulation",
        "retry-configuration",
        "client-options"
      ],
      "severity": "low",
      "userImpact": "Users may be confused by RpcRetryOptions being in a public package when it's not intended as part of the public API surface.",
      "rootCause": "RpcRetryOptions was placed in io.temporal.serviceclient public package but is not meant for direct SDK user consumption",
      "proposedFix": "Move RpcRetryOptions from io.temporal.serviceclient to an internal package",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "RpcRetryOptions is exposed on WorkflowStubOptions.Builder, making the proposed change infeasible without breaking changes",
      "related": [],
      "keyQuote": "RpcRetryOptions is exposed on WorkflowStubOptions.Builder. Won't fix.",
      "number": 1202,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:13:04.224Z"
    },
    {
      "summary": "continueAsNew doesn't automatically carry over parent workflow attributes that aren't explicitly set in ContinueAsNewOptions. The implementation incorrectly assumes the server carries over parameters, but the server actually requires them to be explicitly set.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "Workflow.continueAsNew",
        "ContinueAsNewOptions"
      ],
      "components": [
        "workflow-client",
        "continue-as-new",
        "workflow-options"
      ],
      "concepts": [
        "workflow-properties",
        "parameter-inheritance",
        "server-behavior",
        "attribute-carry-over",
        "workflow-continuation"
      ],
      "severity": "high",
      "userImpact": "Users lose workflow configuration when using continueAsNew without explicitly setting all options, leading to unexpected behavior changes in continued workflow runs.",
      "rootCause": "Implementation assumes server carries over parameters automatically, but server doesn't carry over most parameters if not specified in continueAsNew request.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1200,
        1424
      ],
      "keyQuote": "Server doesn't carry over most parameters are not carried over by the server.",
      "number": 1201,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:13:04.449Z"
    },
    {
      "summary": "Search attributes are not automatically carried forward when using `continueAsNew()`, requiring manual re-specification via `ContinueAsNewOptions.Builder#setSearchAttributes()`. This was part of a broader issue where multiple workflow options weren't being propagated to continued workflows.",
      "category": "bug",
      "subcategory": "workflow-continuation",
      "apis": [
        "continueAsNew",
        "ContinueAsNewOptions"
      ],
      "components": [
        "workflow-executor",
        "continuation-handler",
        "search-attributes"
      ],
      "concepts": [
        "workflow-continuation",
        "state-propagation",
        "search-attributes",
        "workflow-options",
        "metadata-handling"
      ],
      "severity": "medium",
      "userImpact": "Users must manually re-specify search attributes when calling continueAsNew, otherwise continued workflows lose searchability metadata from the original run.",
      "rootCause": "The continueAsNew implementation does not automatically copy search attributes and other workflow options from the original workflow execution context.",
      "proposedFix": "Automatically carry forward search attributes and other applicable workflow options during continueAsNew execution.",
      "workaround": "Use `ContinueAsNewOptions.Builder#setSearchAttributes()` to manually pass search attributes into continueAsNew.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed in favor of issue #1201 which addresses the broader problem of multiple attributes not being passed during continuation.",
      "related": [
        1201
      ],
      "keyQuote": "Use `ContinueAsNewOptions.Builder#setSearchAttributes` to pass search attributes into `continueAsNew` for now.",
      "number": 1200,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:13:05.559Z"
    },
    {
      "summary": "WorkflowStub#cancel and #terminate throw StatusRuntimeException instead of WorkflowNotFoundException when a workflow doesn't exist, inconsistent with other WorkflowStub methods like #signal.",
      "category": "bug",
      "subcategory": "workflow-management",
      "apis": [
        "WorkflowStub#cancel",
        "WorkflowStub#terminate",
        "WorkflowStub#signal"
      ],
      "components": [
        "workflow-stub",
        "grpc-client",
        "exception-handling"
      ],
      "concepts": [
        "exception-mapping",
        "workflow-lifecycle",
        "error-consistency",
        "not-found-handling"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably distinguish between workflow not found and other errors when canceling or terminating workflows, requiring manual exception handling for gRPC errors.",
      "rootCause": "The cancel and terminate methods are not translating gRPC StatusRuntimeException with NOT_FOUND code to WorkflowNotFoundException, unlike other WorkflowStub methods.",
      "proposedFix": "Wrap cancel and terminate methods to catch StatusRuntimeException with NOT_FOUND code and throw WorkflowNotFoundException instead.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Exception handling was updated to map StatusRuntimeException with NOT_FOUND code to WorkflowNotFoundException for cancel and terminate methods.",
      "related": [],
      "keyQuote": "Raw gRPC `StatusRuntimeException` with NOT_FOUND code is thrown.",
      "number": 1198,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:12:24.608Z"
    },
    {
      "summary": "getResultAsync long poll requests are prematurely terminated after 10 seconds due to default rpcTimeout, instead of allowing the expected 60-second long poll like getResult does.",
      "category": "bug",
      "subcategory": "async-result-polling",
      "apis": [
        "getResultAsync",
        "getResult"
      ],
      "components": [
        "result-poller",
        "rpc-client",
        "timeout-handler"
      ],
      "concepts": [
        "long-poll",
        "timeout",
        "async-execution",
        "rpc",
        "result-retrieval"
      ],
      "severity": "high",
      "userImpact": "Users relying on getResultAsync experience premature request termination, breaking long-poll behavior and potentially losing workflow results.",
      "rootCause": "getResultAsync applies the default 10-second rpcTimeout instead of using the extended timeout for long polling operations.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The timeout handling for getResultAsync was corrected to use appropriate long-poll duration instead of default rpcTimeout.",
      "related": [],
      "keyQuote": "getResultAsync long poll requests get terminated after 10 seconds (default rpcTimeout)",
      "number": 1197,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:12:24.021Z"
    },
    {
      "summary": "Feature request to support dynamic custom tag values for metrics. Currently custom tags are static and cannot be updated during workflow execution. User requests ability to modify custom tags via Workflow.getMetricsScope().tagged() method based on dynamic inputs.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [
        "getMetricsScope"
      ],
      "components": [
        "metrics",
        "workflow-execution",
        "tags"
      ],
      "concepts": [
        "custom-tags",
        "dynamic-values",
        "metrics-instrumentation",
        "observability",
        "workflow-context"
      ],
      "severity": "low",
      "userImpact": "Users cannot tag metrics with dynamic values derived from workflow inputs, limiting observability and metrics categorization flexibility.",
      "rootCause": null,
      "proposedFix": "Ability to modify custom tag values using Workflow.getMetricsScope().tagged() method during workflow execution.",
      "workaround": "Create custom metrics similar to those already exposed by the SDK instead of using tagged built-in metrics.",
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #1163 and won't fix for now.",
      "related": [
        1163
      ],
      "keyQuote": "Ability to modify the custom tag using Workflow.getMetricsScope().tagged() method (similarly for Activity too).",
      "number": 1195,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:12:24.466Z"
    },
    {
      "summary": "When starting a workflow with `startWithSignal`, search attributes defined on the workflow stub are not applied to the workflow. The workflow starts successfully but without the specified search attributes attached.",
      "category": "bug",
      "subcategory": "signal-with-start",
      "apis": [
        "startWithSignal",
        "newWorkflowStub",
        "newSignalWithStartRequest",
        "signalWithStart"
      ],
      "components": [
        "workflow-stub",
        "signal-with-start",
        "search-attributes"
      ],
      "concepts": [
        "search-attributes",
        "workflow-start",
        "signal",
        "workflow-options",
        "initialization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot attach search attributes to workflows started with signal, limiting their ability to index and search workflows initiated through this pattern.",
      "rootCause": "The signal-with-start implementation does not properly transfer search attributes from the workflow stub options to the workflow execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When starting a workflow with `startWithSignal`, I would expect any search attributes defined on the workflow stub to be applied to the workflow.",
      "number": 1194,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:11:44.123Z"
    },
    {
      "summary": "Test Server query for non-cached execution causes SDK state machine failure when replaying workflow tasks. The PollWorkflowTaskResponse incorrectly sets previousStartedEventId equal to startedEventId, causing the SDK to treat a replayed task as a first execution, resulting in invalid state transitions in the LocalActivity state machine.",
      "category": "bug",
      "subcategory": "test-framework, workflow-replay, state-machines",
      "apis": [
        "queryWorkflow"
      ],
      "components": [
        "test-server",
        "state-machines",
        "replay-engine",
        "local-activity",
        "workflow-task-handler"
      ],
      "concepts": [
        "state-machine",
        "event-replay",
        "test-execution",
        "workflow-task",
        "event-history",
        "cached-execution"
      ],
      "severity": "high",
      "userImpact": "Users cannot query workflows during test server execution when local activities are involved, causing test failures with cryptic state machine errors.",
      "rootCause": "Test Server forms PollWorkflowTaskResponse for legacy queries with previousStartedEventId equal to startedEventId, causing SDK to treat replayed workflow task as first execution instead of replay, leading to mismatched event-command pairing in LocalActivity state machine",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "LocalActivity: invalid REQUEST_PREPARED->MARKER_RECORDED, transition history is [CREATED->CHECK_EXECUTION_STATE, EXECUTING->SCHEDULE]",
      "number": 1190,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:11:45.375Z"
    },
    {
      "summary": "Request to expose the assertHistoryEvent utility method from internal SDKTestWorkflowRule to public TestWorkflowRule API for easier testing. The request was declined as the maintainers consider testing Temporal internal history events an anti-pattern that breaks abstraction.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowRule"
      ],
      "components": [
        "testing",
        "test-workflow-rule"
      ],
      "concepts": [
        "testing",
        "history-events",
        "abstraction",
        "test-utilities",
        "internal-implementation"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily assert on history events from the public TestWorkflowRule API and must either write their own implementation or access internal APIs.",
      "rootCause": "The maintainers consider direct history event assertions in user tests a bad practice that breaks Temporal's abstraction layers.",
      "proposedFix": "Expose assertHistoryEvent as a public method in TestWorkflowRule.",
      "workaround": "Users can access the internal SDKTestWorkflowRule or write their own assertion utilities to inspect history events directly.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers declined to expose this method as they consider testing Temporal internal abstractions an anti-pattern and believe it would promote bad testing practices.",
      "related": [],
      "keyQuote": "It's a bad practice for application test code to assert Temporal history events which is basically a Temporal internal abstraction.",
      "number": 1189,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:11:45.368Z"
    },
    {
      "summary": "LocalActivity completion incorrectly advances the workflow task timestamp to the current system time instead of respecting the TestEnvironment's initial time setting. When running tests with a custom initial timestamp, it gets overridden when a LocalActivity completes.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.currentTimeMillis()"
      ],
      "components": [
        "LocalActivity",
        "TestEnvironment",
        "workflow-task-execution"
      ],
      "concepts": [
        "timestamp",
        "test-framework",
        "time-override",
        "LocalActivity",
        "workflow-clock"
      ],
      "severity": "medium",
      "userImpact": "Developers using TestEnvironment with custom timestamps cannot reliably test time-dependent workflows when LocalActivities are involved, as the timestamp gets reset unexpectedly.",
      "rootCause": "LocalActivity completion logic directly uses the current system time instead of using an offset from the TestEnvironment's configured initial time.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by ensuring LocalActivity completion respects the TestEnvironment's time settings rather than using the current system time.",
      "related": [],
      "keyQuote": "When LocalActivity runs, Workflow.currentTimeMillis() gets updated to the current DateTime that is nothing around the time set on TestEnv.",
      "number": 1187,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:11:03.819Z"
    },
    {
      "summary": "The workflow_active_thread_count metric is incorrectly tagged with WORKFLOW_TYPE, causing double-counting since all workflows share the same ThreadPoolExecutor. This tag should be removed to ensure accurate metric aggregation.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "worker",
        "thread-pool-executor",
        "workflow-execution"
      ],
      "concepts": [
        "metric-tagging",
        "aggregation",
        "thread-pool",
        "double-counting",
        "monitoring",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users see inflated workflow_active_thread_count metrics when aggregating across multiple workflow types due to incorrect WORKFLOW_TYPE tagging.",
      "rootCause": "The metric is being emitted with a WORKFLOW_TYPE tag despite the underlying ThreadPoolExecutor being shared across all workflows, leading to duplicate counts when aggregated by host.",
      "proposedFix": "Remove the WORKFLOW_TYPE tag from the workflow_active_thread_count metric emission.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This metric should not contain the WORKFLOW_TYPE tag to avoid double-counting of workflow_active_thread_count given that every workflow shared the same ThreadPoolExecutor.",
      "number": 1179,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:11:03.231Z"
    },
    {
      "summary": "WorkflowStub.getResult and getResultAsync methods do not throw TimeoutException when the workflow doesn't complete within the specified timeout period. Instead, they throw WorkflowServiceException with DEADLINE_EXCEEDED errors, and timeout handling is inconsistent based on the timeout value.",
      "category": "bug",
      "subcategory": "workflow-result-handling",
      "apis": [
        "WorkflowStub.getResult",
        "WorkflowStub.getResultAsync"
      ],
      "components": [
        "workflow-stub",
        "grpc-client",
        "retry-logic",
        "timeout-handling"
      ],
      "concepts": [
        "timeout",
        "exception-handling",
        "deadline",
        "retry",
        "async-operations"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably catch TimeoutException when waiting for workflow results, making it difficult to implement proper timeout handling in client code.",
      "rootCause": "WorkflowStub.getResult and getResultAsync use gRPC retry logic that throws WorkflowServiceException on deadline exceeded rather than TimeoutException, and the behavior is inconsistent for timeouts >= 10 seconds.",
      "proposedFix": null,
      "workaround": "Use getResultAsync with CompletableFuture.get(timeout, TimeUnit) to catch TimeoutException, though this still produces DEADLINE_EXCEEDED logs for timeouts >= 10 seconds.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        1203
      ],
      "keyQuote": "The only way to catch TimeoutException is if you use getResultAsync and put the timeout on Future.get",
      "number": 1177,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:11:04.460Z"
    },
    {
      "summary": "User requests ability to add custom tags (e.g., region) to root worker metrics scope per workflow execution for better metric grouping in external systems like New Relic. Currently no clean way to achieve this with the distributed execution model.",
      "category": "feature",
      "subcategory": "metrics-tagging",
      "apis": [
        "WorkflowServiceStubs",
        "WorkflowClientInterceptor",
        "ContextPropagator",
        "MetricScope"
      ],
      "components": [
        "metrics",
        "worker",
        "workflow-client"
      ],
      "concepts": [
        "metrics-tagging",
        "custom-dimensions",
        "workflow-execution-context",
        "signal-routing",
        "task-queue",
        "metric-scope"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily tag core worker metrics with workflow-specific dimensions, limiting observability and metric aggregation capabilities in external monitoring systems.",
      "rootCause": "Temporal's distributed execution model makes it difficult to propagate workflow execution-specific metadata to core worker metrics without safety and reliability concerns.",
      "proposedFix": null,
      "workaround": "Create separate task queues and worker instances for each region/dimension, with each worker configured with its own MetricsScope containing the appropriate tags.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers decided this is too narrow a use-case with too much customization risk. Core worker metrics should remain unified and simple. Users can use custom workflow metrics instead.",
      "related": [],
      "keyQuote": "Too large pain, customization, and risk of unsafety for a narrow use-case. Core worker metrics should be unified and simple.",
      "number": 1163,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:10:23.992Z"
    },
    {
      "summary": "OpenTracing interceptor logs internal DestroyWorkflowThreadError as workflow failures, causing excessive error spans in DataDog. This is an SDK-internal error for thread cleanup and should not be treated as a workflow failure.",
      "category": "bug",
      "subcategory": "opentracing-interceptor",
      "apis": [],
      "components": [
        "opentracing-interceptor",
        "workflow-inbound-calls",
        "error-handling"
      ],
      "concepts": [
        "tracing",
        "error-logging",
        "thread-cleanup",
        "error-categorization",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users see false error signals in their observability systems when using OpenTracing integration, making it difficult to identify real workflow failures.",
      "rootCause": "OpenTracingWorkflowInboundCallsInterceptor catches Throwable without distinguishing between internal SDK errors (like DestroyWorkflowThreadError) and actual workflow failures, causing all errors to be logged as failures.",
      "proposedFix": "Catch Exception instead of Throwable for logFail, or implement special handling to exclude internal Error classes from failure logging.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by filtering out internal errors from error logging in the OpenTracing interceptor.",
      "related": [],
      "keyQuote": "This is an internal error that the SDK uses for thread cleanup, and does NOT indicate a failure in the workflow.",
      "number": 1162,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:10:23.460Z"
    },
    {
      "summary": "Test server's WorkflowService lacks DescribeNamespace implementation, causing Go SDK workers to fail during initialization. The issue arose from a discrepancy where Go SDK explicitly calls this method while other SDKs don't.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "DescribeNamespace",
        "WorkflowService"
      ],
      "components": [
        "test-server",
        "workflow-service",
        "worker-initialization"
      ],
      "concepts": [
        "test-compatibility",
        "namespace-management",
        "sdk-discrepancy",
        "stub-implementation",
        "initialization-flow"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot start workers with test-server using Go SDK without encountering an UNIMPLEMENTED error during worker initialization.",
      "rootCause": "Go SDK explicitly calls DescribeNamespace during worker startup, but test-server lacks a stub implementation of this method, whereas other SDKs don't make this call.",
      "proposedFix": "Implement a stub DescribeNamespace method in TestWorkflowService that returns valid namespace metadata or silently succeeds, or remove the call from Go SDK for consistency.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test server was updated to implement a stub DescribeNamespace method to support Go SDK's initialization flow and maintain compatibility across all SDKs.",
      "related": [
        196
      ],
      "keyQuote": "It looks like we should implement some stub describeNamespace in the test server just for the sake of compatibility with older versions of Go SDK.",
      "number": 1158,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:10:22.849Z"
    },
    {
      "summary": "The temporal-test-server POM file is invalid in version 1.9.1, missing version specifications for transitive dependencies (grpc-core and grpc-services), causing Maven 3.8.x to emit warnings during compilation.",
      "category": "bug",
      "subcategory": "build-system",
      "apis": [],
      "components": [
        "temporal-test-server",
        "pom.xml",
        "maven-build"
      ],
      "concepts": [
        "pom-validation",
        "transitive-dependencies",
        "maven-3.8",
        "dependency-resolution",
        "build-warnings"
      ],
      "severity": "medium",
      "userImpact": "Users cannot compile projects with temporal-testing as a dependency using Maven 3.8.x without build warnings due to invalid POM configuration.",
      "rootCause": "The temporal-test-server POM lacks explicit version specifications for grpc-core and grpc-services dependencies, violating Maven 3.8.x stricter POM validation rules.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by correcting the POM file to include explicit versions for all transitive dependencies.",
      "related": [],
      "keyQuote": "The POM for io.temporal:temporal-test-server:jar:1.9.1 is invalid, transitive dependencies (if any) will not be available",
      "number": 1153,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:09:43.170Z"
    },
    {
      "summary": "Race condition in WorkflowRunLockManager where a thread may release a lock it doesn't own if lock acquisition times out, causing multiple threads to simultaneously execute the same workflow and corrupt state machine.",
      "category": "bug",
      "subcategory": "workflow-locking",
      "apis": [],
      "components": [
        "WorkflowWorker",
        "WorkflowRunLockManager",
        "TaskHandler"
      ],
      "concepts": [
        "race-condition",
        "lock-management",
        "thread-safety",
        "concurrency",
        "workflow-state",
        "deadlock-detection"
      ],
      "severity": "high",
      "userImpact": "Users may experience workflow state corruption or undefined behavior when undetected blocking causes lock timeout scenarios, potentially leading to data loss or incorrect workflow execution.",
      "rootCause": "The finally block unconditionally releases the lock even when tryLock() fails, meaning a thread that never acquired the lock will release it while another thread still holds it, allowing concurrent access to non-thread-safe workflow state machine.",
      "proposedFix": "Check if the lock was successfully acquired before releasing it in the finally block, or use a try-with-resources pattern with proper lock ownership validation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If the exception is thrown and the lock is not taken - it means that another thread acquired the lock and still processing this runId - the finally block will actually release the lock while another thread is still working on the task",
      "number": 1146,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:09:42.950Z"
    },
    {
      "summary": "Deadlock Detector fires unexpectedly on cold JVM startup during class loading and instrumentation, blocking workflow execution on the workflow-root thread. The detector should use relaxed thresholds during initial worker startup rather than standard production thresholds.",
      "category": "bug",
      "subcategory": "deadlock-detection",
      "apis": [],
      "components": [
        "deadlock-detector",
        "workflow-thread",
        "class-loader",
        "instrumentation"
      ],
      "concepts": [
        "classloading",
        "instrumentation",
        "JVM-startup",
        "thread-blocking",
        "timeout-detection",
        "cold-start",
        "thread-yield"
      ],
      "severity": "high",
      "userImpact": "Users running Java SDK with code instrumentation tools (like JaCoCo) experience immediate workflow failures on JVM startup due to false positive deadlock detection during class loading.",
      "rootCause": "Deadlock detector uses fixed thresholds (>1 second without yielding) during class loading and instrumentation phases, which are inherently slow on cold JVM startup, causing false positives.",
      "proposedFix": "Implement relaxed Deadlock Detector thresholds during worker startup, such as multiplying the detection threshold by N for the first execution of each workflow type.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Deadlock Detector should implement a relaxed Deadlock Detector during the start of workers",
      "number": 1141,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:09:43.589Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not apply filtering options like StartTimeFilter and WorkflowTypeFilter when handling ListOpenWorkflowExecutions requests, limiting the ability to test workflow implementations with realistic query parameters.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ListOpenWorkflowExecutions",
        "StartTimeFilter",
        "WorkflowTypeFilter"
      ],
      "components": [
        "test-workflow-environment",
        "test-server",
        "workflow-execution-service"
      ],
      "concepts": [
        "filtering",
        "list-operations",
        "test-utilities",
        "query-parameters",
        "workflow-discovery"
      ],
      "severity": "low",
      "userImpact": "Developers testing workflow implementations cannot validate filtering behavior in ListOpenWorkflowExecutions queries.",
      "rootCause": "TestWorkflowEnvironment service implementation does not process filter parameters from ListOpenWorkflowExecutionsRequest.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Test Server is intended for testing Workflow implementations, full on-par support of all administrative endpoints is not really a goal.",
      "number": 1139,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:09:02.287Z"
    },
    {
      "summary": "The test server fails to properly decrement its time-skipping lock when a workflow completes while activities are still outstanding. This causes subsequent activities in new tests to sleep in real time instead of skipped time.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-server",
        "time-skipping",
        "activity-execution",
        "workflow-completion"
      ],
      "concepts": [
        "time-skipping",
        "lock-management",
        "test-isolation",
        "resource-cleanup",
        "workflow-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Tests using the test server hang or run much slower than expected when activities overlap workflow completion, making test-driven development difficult.",
      "rootCause": "Test server does not decrement the time-skipping lock when workflows complete with outstanding activities still in progress",
      "proposedFix": null,
      "workaround": "Create a separate test server instance for affected tests",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The second activity sleeps in normal time",
      "number": 1138,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:09:02.659Z"
    },
    {
      "summary": "Gson 2.8.6 dependency used in jaeger-client contains a denial of service vulnerability (CVSS 7.7) via writeReplace() method. Issue was automatically closed as the vulnerable library was only used in test scopes and has been fixed in a follow-up PR.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "jaeger-client",
        "gradle-build",
        "temporal-opentracing"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "dependency-management",
        "transitive-dependency",
        "test-scope"
      ],
      "severity": "high",
      "userImpact": "Users could be vulnerable to denial of service attacks through gson if the jaeger library dependency is not upgraded to version 2.8.9 or later.",
      "rootCause": "Gson version 2.8.6 contains a DoS vulnerability in the writeReplace() method that was fixed in version 2.8.9.",
      "proposedFix": "Upgrade com.google.code.gson:gson from 2.8.6 to 2.8.9 or later. Exclude jaeger-client from production scopes as it's only needed for testing.",
      "workaround": "Exclude jaeger library from non-test scopes in Gradle build configuration.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was auto-closed by WhiteSource. The vulnerability was in a test-only dependency. Follow-up PR #1136 fixed the Gradle configuration to explicitly exclude test scope from vulnerability scans.",
      "related": [
        1136
      ],
      "keyQuote": "This Jaeger library is only used in Gradle test scopes, which should have been explicitly excluded from the scan.",
      "number": 1135,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:09:03.615Z"
    },
    {
      "summary": "TestActivityEnvironment.close() fails on subsequent test methods due to static executor fields being closed prematurely. When a new TestActivityEnvironmentInternal instance is created for each test, it shares static executor pools that get closed, causing RejectedExecutionException on the next test.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestActivityEnvironment",
        "TestActivityEnvironmentInternal",
        "TestActivityExtension",
        "WorkflowThreadImpl"
      ],
      "concepts": [
        "static-state",
        "executor-lifecycle",
        "test-isolation",
        "resource-cleanup",
        "thread-pool"
      ],
      "severity": "high",
      "userImpact": "Tests that call TestActivityEnvironment.close() in cleanup fail on subsequent test methods, breaking test suites that need proper resource cleanup between tests.",
      "rootCause": "Static ExecutorService fields (activityWorkerExecutor, heartbeatExecutor, deterministicRunnerExecutor) are shared across all TestActivityEnvironmentInternal instances but are closed when any single instance is closed, causing subsequent instances to fail when trying to submit tasks to the terminated pool.",
      "proposedFix": "Make the executor fields non-static so each TestActivityEnvironmentInternal instance has its own lifecycle-managed executors, preventing one instance's close() from affecting others.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Converted static executor fields to instance fields so each TestActivityEnvironmentInternal manages its own executor lifecycle without affecting other instances.",
      "related": [
        1329
      ],
      "keyQuote": "Make these fields not static (creating a new thread pool per test may be sub-optimal for performance but is probably acceptable for most testing use cases)",
      "number": 1133,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:08:23.680Z"
    },
    {
      "summary": "Feature request to allow passing Payloads directly through the default DataConverter for DSLs and generic starters, enabling typed workflow/activity calls with JSON input without deserialization errors.",
      "category": "feature",
      "subcategory": "data-converter",
      "apis": [
        "DataConverter"
      ],
      "components": [
        "data-converter",
        "serialization",
        "workflow-invocation"
      ],
      "concepts": [
        "payload-passthrough",
        "json-handling",
        "deserialization",
        "generic-starter",
        "dsl"
      ],
      "severity": "medium",
      "userImpact": "Users implementing DSLs or generic starters can now pass Payloads directly to workflows/activities without custom DataConverter implementation.",
      "rootCause": "Default DataConverter always attempts to deserialize content, making it impossible to pass pre-serialized JSON as raw input to typed workflows/activities.",
      "proposedFix": "Allow application code to pass Payloads as activity or workflow arguments, with DataConverter returning them as-is without inspection.",
      "workaround": "Implement a custom DataConverter to handle raw payload passthrough.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented RawValues support to allow passing Payloads directly through without deserialization.",
      "related": [],
      "keyQuote": "Allow application code to pass Payloads as an activity or workflow argument. In this case, the default DataConverter would not look into its content and return it as it is.",
      "number": 1126,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:08:22.580Z"
    },
    {
      "summary": "PotentialDeadlockException collects stack traces at different safepoints, resulting in inconsistent thread dumps. The current thread's stack trace is captured separately from workflow thread dumps, potentially showing an inconsistent view of the system state.",
      "category": "bug",
      "subcategory": "deadlock-detection",
      "apis": [],
      "components": [
        "deadlock-detection",
        "workflow-threads",
        "stack-trace-collection"
      ],
      "concepts": [
        "safepoint",
        "thread-synchronization",
        "consistency",
        "diagnostics",
        "stack-traces"
      ],
      "severity": "medium",
      "userImpact": "Users may receive incomplete or inconsistent deadlock diagnostic information when the SDK detects a potential deadlock.",
      "rootCause": "Stack traces are collected at different times for the suspect thread and other workflow threads, potentially crossing different JVM safepoints, resulting in inconsistent state representation.",
      "proposedFix": "Collect all stack traces at a single safepoint to ensure consistency across all threads in the deadlock diagnosis.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by issue #1152",
      "related": [
        1152
      ],
      "keyQuote": "Each stacktrace may be collected at a different safepoint and they may be inconsistent.",
      "number": 1125,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:08:21.880Z"
    },
    {
      "summary": "Query methods cannot return WorkflowLocal variable values; attempting to do so throws an error about being called from a non-workflow thread.",
      "category": "bug",
      "subcategory": "workflow-queries",
      "apis": [
        "WorkflowLocal"
      ],
      "components": [
        "query-handler",
        "thread-validation",
        "workflow-context"
      ],
      "concepts": [
        "workflow-local",
        "query-execution",
        "thread-safety",
        "context-propagation"
      ],
      "severity": "high",
      "userImpact": "Users cannot access WorkflowLocal state from query methods, breaking a common pattern for exposing workflow state to external clients.",
      "rootCause": "Query methods are executed outside the workflow thread context, but WorkflowLocal access requires execution within a workflow or workflow callback thread.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The query execution context was updated to allow proper WorkflowLocal access within query methods.",
      "related": [],
      "keyQuote": "Called from non workflow or workflow callback thread",
      "number": 1120,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:07:42.171Z"
    },
    {
      "summary": "Worker suspend/resume functionality can cause workflows to get stuck when repeatedly suspending and resuming workers. The root cause is that Worker#isSuspended() returns incorrect values, causing the resume method to not be called when needed.",
      "category": "bug",
      "subcategory": "worker-polling",
      "apis": [
        "suspendPolling",
        "resumePolling"
      ],
      "components": [
        "worker",
        "polling",
        "task-matching"
      ],
      "concepts": [
        "suspension",
        "polling",
        "task-distribution",
        "worker-lifecycle",
        "synchronization",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Users experience workflow execution getting permanently stuck when using suspend/resume operations repeatedly, making the feature unreliable for production use cases.",
      "rootCause": "Worker#isSuspended() method not returning the correct value consistently, causing logical errors in code that checks this state before calling resume()",
      "proposedFix": null,
      "workaround": "Avoid repeated suspend/resume cycles; ensure Worker#isSuspended() state is properly verified before calling resume()",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in version 1.10 by correcting the Worker#isSuspended() method to return accurate state values",
      "related": [],
      "keyQuote": "The problem is in `Worker#isSuspended` not returning the right value sometimes and your code trust this value and doesn't call `#resume` if it's already suspended.",
      "number": 1114,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:07:42.981Z"
    },
    {
      "summary": "The Java SDK workflow configuration system is unbalanced - the constructor-based approach and worker registration approach don't support the same configuration levels. The worker registration approach lacks support for per-activity configuration (between default and per-method), and both approaches have limitations around method polymorphism.",
      "category": "feature",
      "subcategory": "workflow-configuration",
      "apis": [
        "Workflow.newActivityStub",
        "Worker.registerWorkflowImplementationTypes"
      ],
      "components": [
        "workflow-implementation",
        "activity-options",
        "worker-registration"
      ],
      "concepts": [
        "configuration",
        "activity-options",
        "retry-options",
        "polymorphism",
        "workflow-setup",
        "timeout-options"
      ],
      "severity": "low",
      "userImpact": "Users struggle to configure activities consistently across different workflows without duplicating code or sacrificing flexibility in configuration strategies.",
      "rootCause": null,
      "proposedFix": "Balance the two configuration strategies (constructor-based and worker registration-based) to support all three levels of ActivityOptions configuration without sacrificing functionality or polymorphism support.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "it would be awesome to balance this two configuration strategies to be able to achieve the same without sacrificing functionality",
      "number": 1113,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:07:42.968Z"
    },
    {
      "summary": "Transitive dependency protobuf-java-3.4.0 contains CVE-2021-22569, a medium severity vulnerability (CVSS 5.5) that allows malicious payloads to cause denial of service through parser manipulation. The vulnerability was automatically resolved by removing the vulnerable library from the inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "protobuf",
        "error_prone_core"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "dependency-upgrade",
        "transitive-dependency",
        "parser-attack"
      ],
      "severity": "medium",
      "userImpact": "Users could be impacted by denial of service attacks if the vulnerable protobuf-java library is used to parse untrusted data.",
      "rootCause": "protobuf-java-3.4.0 allows interleaving of UnknownFieldSet fields to be processed out of order, enabling malicious payloads to occupy the parser for extended periods through repeated object creation.",
      "proposedFix": "Upgrade protobuf-java to version 3.16.1, 3.18.2, or 3.19.2; protobuf-kotlin to 3.18.2 or 3.19.2; or google-protobuf to 3.19.2",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Automatically closed by WhiteSource as the vulnerable library was removed from inventory or marked as ignored in the branch",
      "related": [],
      "keyQuote": "A small malicious payload can occupy the parser for several minutes by creating large numbers of short-lived objects that cause frequent, repeated pauses.",
      "number": 1112,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:07:03.207Z"
    },
    {
      "summary": "Security vulnerability (CVE WS-2021-0419) in gson-2.8.6.jar transitive dependency via protobuf-java-util-3.19.4, with CVSS 7.7 (High) Denial of Service risk. Requires upgrading gson to version 2.8.9 or later.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "protobuf",
        "gson"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "transitive-dependency",
        "cvss-score",
        "dependency-upgrade"
      ],
      "severity": "high",
      "userImpact": "Applications using this SDK are vulnerable to denial of service attacks via the gson JSON library's writeReplace() method.",
      "rootCause": "gson-2.8.6 contains a DoS vulnerability in the writeReplace() method that was fixed in version 2.8.9.",
      "proposedFix": "Upgrade com.google.code.gson:gson from 2.8.6 to 2.8.9 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend after the vulnerable library was either marked as ignored or removed from the WhiteSource inventory, indicating the dependency was addressed.",
      "related": [],
      "keyQuote": "Denial of Service vulnerability was discovered in gson before 2.8.9 via the writeReplace() method.",
      "number": 1111,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:07:02.875Z"
    },
    {
      "summary": "jackson-databind 2.13.1 contains CVE-2020-36518, a denial of service vulnerability (CVSS 7.5) caused by stack overflow from deeply nested objects. The issue was automatically resolved by removing the vulnerable dependency from the inventory.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "jackson-databind",
        "dependency-management",
        "temporal-opentracing"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "stack-overflow",
        "dependency-upgrade",
        "CVE"
      ],
      "severity": "high",
      "userImpact": "Users are vulnerable to denial of service attacks through deeply nested objects in jackson-databind 2.13.1.",
      "rootCause": "jackson-databind versions up to 2.13.2 allow StackOverflow exceptions via large depth of nested objects",
      "proposedFix": "Upgrade jackson-databind to version 2.13.2.1 or later",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was removed from the inventory or marked as ignored",
      "related": [],
      "keyQuote": "jackson-databind before 2.13.0 allows a Java StackOverflow exception and denial of service via a large depth of nested objects",
      "number": 1110,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:07:02.630Z"
    },
    {
      "summary": "Workflow metadata resolution incorrectly registers overridden methods from parent interfaces as duplicate queries/methods, causing IllegalArgumentException when using interface inheritance with @QueryMethod or @WorkflowMethod overrides.",
      "category": "bug",
      "subcategory": "workflow-metadata-resolution",
      "apis": [
        "WorkflowInterface",
        "WorkflowMethod",
        "QueryMethod"
      ],
      "components": [
        "POJOWorkflowInterfaceMetadata",
        "metadata-resolution",
        "interface-processing"
      ],
      "concepts": [
        "interface-inheritance",
        "method-overriding",
        "duplicate-detection",
        "reflection",
        "annotation-processing",
        "generic-types"
      ],
      "severity": "high",
      "userImpact": "Users cannot define workflow interfaces that extend parent interfaces with overridden query or workflow methods, forcing developers to flatten their interface hierarchies.",
      "rootCause": "POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods() does not properly handle method resolution in inheritance hierarchies, treating overridden methods as duplicates instead of recognizing them as the same method signature.",
      "proposedFix": "Modify getWorkflowInterfaceMethods to use proper method resolution that accounts for inheritance, potentially using Method.equals() or signature-based deduplication that considers both declaring class and signature.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Duplicated name of QUERY: \"getResults\" declared at...should be fine when using interface inheritance with @QueryMethod override",
      "number": 1107,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:06:22.828Z"
    },
    {
      "summary": "Workflow metadata resolution doesn't respect generic type parameters specified in interface hierarchies. When a workflow interface extends a generic base interface like TemporalWorkflow<T>, the SDK fails to resolve the concrete type parameter and uses Object instead for query results.",
      "category": "bug",
      "subcategory": "metadata-resolution",
      "apis": [
        "QueryMethod",
        "WorkflowMethod",
        "WorkflowInterface"
      ],
      "components": [
        "metadata-resolver",
        "type-reflection",
        "data-converter"
      ],
      "concepts": [
        "generics",
        "type-erasure",
        "reflection",
        "inheritance",
        "type-resolution",
        "metadata"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use generic type parameters in workflow interfaces, forcing data converters to treat query results as Object instead of the intended concrete type.",
      "rootCause": "Java's generic type information is erased at runtime for dynamically created instances, but preserved in class hierarchies when a concrete class extends a generic base. The SDK's metadata resolution code doesn't leverage reflection to extract preserved generic type parameters from the inheritance chain.",
      "proposedFix": "Implement reflection-based generic type parameter resolution for straightforward 1-1 unbounded cases. Reject or log warnings for complex scenarios (diamond inheritance, bounded wildcards, multiple levels of indirection) where resolution would be ambiguous.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the feature was implemented to support generic type resolution in common cases.",
      "related": [],
      "keyQuote": "Java erases generic information for dynamically created instances. But Java do preserve information about generic typed for defined standalone classes.",
      "number": 1106,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:06:23.366Z"
    },
    {
      "summary": "Search results on javadoc.io for Temporal Java SDK documentation produce AccessDenied errors due to an `/undefined/` path segment being added to URLs when following search links, while direct navigation works correctly.",
      "category": "bug",
      "subcategory": "documentation",
      "apis": [],
      "components": [
        "javadoc-hosting",
        "documentation-site"
      ],
      "concepts": [
        "search",
        "url-routing",
        "documentation-access",
        "javadoc.io",
        "api-docs"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access API documentation through javadoc.io search functionality, forcing them to manually navigate or use alternative documentation sources.",
      "rootCause": "The `/undefined/` path segment is being incorrectly appended to URLs when following search results on javadoc.io, causing permission/access denied errors.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Already addressed in issue #1078",
      "related": [
        1078
      ],
      "keyQuote": "navigating to any page in the search results seems to produce an AccessDenied error... /undefined/ path segment added to the URL when following search results",
      "number": 1104,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:06:22.074Z"
    },
    {
      "summary": "Request to add ActivityStub#fromTyped method to provide a unified typed/untyped experience for activity stubs, similar to the existing WorkflowStub#fromTyped pattern.",
      "category": "feature",
      "subcategory": "activity-stub-api",
      "apis": [
        "ActivityStub"
      ],
      "components": [
        "activity-stub",
        "stub-factory"
      ],
      "concepts": [
        "typed-stub",
        "untyped-stub",
        "api-consistency",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Users cannot create typed activity stubs from untyped stubs, limiting the flexibility and consistency of the activity stub API compared to workflows.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "As we have `WorkflowStub#fromTyped`, we should have `ActivityStub#fromTyped`. Untyped activity stubs have significantly limited usage in comparison with WorkflowStub, but there is no reason why there shouldn't be a unified experience.",
      "number": 1098,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:05:41.145Z"
    },
    {
      "summary": "WorkerFactory instantiation fails with NoSuchMethodError due to incompatible protobuf-java-util version. The issue occurs when protobuf-java-util 4.0.0-rc-2 is loaded before grpc-services 1.44.1, causing a method compatibility issue.",
      "category": "bug",
      "subcategory": "dependency-conflict",
      "apis": [
        "WorkerFactory"
      ],
      "components": [
        "worker-factory",
        "dependency-management",
        "protobuf-integration"
      ],
      "concepts": [
        "version-conflict",
        "dependency-resolution",
        "protobuf-compatibility",
        "grpc-integration"
      ],
      "severity": "high",
      "userImpact": "Users cannot instantiate WorkerFactory when temporal-sdk is added to their project due to transitive protobuf dependency conflicts.",
      "rootCause": "protobuf-java-util dependency version constraint [3.10.0,) allows newer incompatible versions like 4.0.0-rc-2 to be resolved before grpc-services 1.44.1, causing missing method errors.",
      "proposedFix": "Pin protobuf-java-util to version 3.19.4 or earlier compatible version that is compatible with grpc-services 1.44.1.",
      "workaround": "Explicitly specify protobuf-java-util version 3.19.4 in application pom.xml to override transitive dependency resolution.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in master branch, will be included in next release. Marked as duplicate of issues #1085 and #1091.",
      "related": [
        1085,
        1091
      ],
      "keyQuote": "I found out that there is a new version of com.google.protobuf:protobuf-java-util with version 4.0.0-rc-2. This new version is loaded first, which seems to be incompatible with io.grpc:grpc-services:1.44.1.",
      "number": 1097,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:05:43.267Z"
    },
    {
      "summary": "Epic tracking Test Server usability improvements and bug fixes for the in-memory Temporal Server implementation used for testing, including new endpoint implementations and feature enhancements.",
      "category": "feature",
      "subcategory": "test-server",
      "apis": [],
      "components": [
        "test-server",
        "workflow-service",
        "operator-service"
      ],
      "concepts": [
        "testing",
        "in-memory",
        "time-skipping",
        "endpoints",
        "usability"
      ],
      "severity": "medium",
      "userImpact": "Improves testing experience for SDK users by enhancing the fast in-memory Test Server with better usability and bug fixes.",
      "rootCause": null,
      "proposedFix": "Implement missing WorkflowService and OperatorService endpoints, fix identified bugs, and resolve tracked tasks.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because the team decided to no longer use GitHub issues as epics for tracking.",
      "related": [
        1079,
        1093,
        1069,
        84,
        1139,
        1158,
        1220,
        1221,
        1223,
        262,
        1403,
        1642,
        1682,
        1746,
        1742,
        1692,
        1693,
        1291,
        1288,
        1289,
        1319,
        1398,
        1401,
        1138,
        1424,
        1425,
        1426,
        1427,
        1429,
        1618,
        1903
      ],
      "keyQuote": "Closing since we no longer want to use GH issues as epics",
      "number": 1094,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:05:42.403Z"
    },
    {
      "summary": "ResetWorkflowExecution API is not implemented in the in-memory Test Server, causing UNIMPLEMENTED gRPC errors when tests attempt to use this method without an external Temporal service.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ResetWorkflowExecution"
      ],
      "components": [
        "test-server",
        "workflow-service",
        "grpc"
      ],
      "concepts": [
        "workflow-reset",
        "test-execution",
        "in-memory-testing",
        "api-compatibility",
        "test-coverage"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot test workflow reset functionality using the in-memory test server and must resort to using external Temporal services or dockerized instances for reset-related tests.",
      "rootCause": "ResetWorkflowExecution method is not implemented in the test server's WorkflowService implementation.",
      "proposedFix": "Implement ResetWorkflowExecution support in the test server, possibly as a simplified version.",
      "workaround": "Use dockerized Temporal or set useExternalService to true for tests that need to cover workflow reset.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Method temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution is unimplemented",
      "number": 1093,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:05:01.262Z"
    },
    {
      "summary": "Maven dependency resolution for temporal-sdk 1.8.1 was pulling protobuf 4.0.0-rc-2 instead of respecting the intended version range constraint. This was fixed in a subsequent release by updating the version range restrictions.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "maven-pom",
        "protobuf-dependency",
        "build-configuration"
      ],
      "concepts": [
        "dependency-resolution",
        "version-constraints",
        "maven-range",
        "transitive-dependencies",
        "build-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users building with Maven could receive incompatible protobuf versions, potentially causing runtime errors or incompatibilities.",
      "rootCause": "The Maven POM for temporal-sdk 1.8.1 did not properly restrict the protobuf version range, allowing Maven to select version 4.0.0-rc-2 instead of the intended 3.x range.",
      "proposedFix": "Update the version range constraints in the build configuration to exclude 4.x versions of protobuf.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Version range restrictions were updated to properly constrain protobuf to the 3.x branch. Testing with 1.9.0-SNAPSHOT confirmed the fix pulls version 3.20.0-rc-1 as intended.",
      "related": [],
      "keyQuote": "Tested with 1.9.0-SNAPSHOT and the updated range pulls com.google.protobuf:protobuf-java-util:jar:3.20.0-rc-1",
      "number": 1091,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:05:01.894Z"
    },
    {
      "summary": "Protobuf version range dependency [3.10.0,) in SDK 1.8.1 allows installation of incompatible protobuf-java-util 4.0.0-rc-2, causing NoSuchMethodError at runtime when health checks are performed. Explicit downgrade to protobuf 3.19.4 resolves the issue.",
      "category": "bug",
      "subcategory": "dependency-conflict",
      "apis": [],
      "components": [
        "dependency-management",
        "grpc-client",
        "health-check",
        "protobuf-serialization"
      ],
      "concepts": [
        "version-constraint",
        "dependency-resolution",
        "binary-compatibility",
        "protobuf-version",
        "maven-dependency",
        "runtime-error"
      ],
      "severity": "high",
      "userImpact": "Users cannot use SDK 1.8.1 without explicitly pinning protobuf version, causing workflow initialization failures with NoSuchMethodError.",
      "rootCause": "Overly permissive version range [3.10.0,) in protobuf-java-util dependency allows incompatible protobuf 4.0.0-rc-2 which removed the isStringEmpty method used by generated gRPC code.",
      "proposedFix": "Tighten protobuf-java-util version constraint to exclude incompatible 4.x versions, or explicitly pin to 3.19.4.",
      "workaround": "Add explicit dependency on protobuf-java-util version 3.19.4 in pom.xml to override the range constraint.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in master branch before next release, likely by constraining protobuf version range to compatible versions.",
      "related": [],
      "keyQuote": "com.google.protobuf:protobuf-java-util:jar:4.0.0-rc-2:compile (version selected from constraint [3.10.0,))",
      "number": 1085,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:05:02.610Z"
    },
    {
      "summary": "Test fails with infinite activity retries when running against real Temporal Server, showing 78,000+ retry attempts for a single failed activity. The test hangs with IllegalThreadStateException and eventually times out, potentially indicating a server-side issue with activity retry logic.",
      "category": "bug",
      "subcategory": "activity-retry",
      "apis": [],
      "components": [
        "activity-executor",
        "activity-worker",
        "test-framework",
        "retry-logic"
      ],
      "concepts": [
        "infinite-retry",
        "activity-failure",
        "test-flakiness",
        "timeout",
        "server-interaction",
        "concurrency"
      ],
      "severity": "high",
      "userImpact": "Tests fail intermittently when running against real Temporal Server, blocking reliable test execution and potentially masking server-side retry handling issues.",
      "rootCause": "Activity retry logic appears to not be respecting backoff or max retry limits when activity execution fails, causing infinite retry attempts instead of failing the workflow.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It flakes with real Temporal Server only and may manifest a severe server issue.",
      "number": 1081,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:04:21.042Z"
    },
    {
      "summary": "Bug in WorkerOptions.Builder where maxConcurrentLocalActivityExecutionSize is incorrectly set to maxConcurrentActivityExecutionSize during build(), causing both configuration values to be identical regardless of intended values.",
      "category": "bug",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "builder",
        "configuration"
      ],
      "concepts": [
        "activity-execution",
        "local-activity",
        "concurrent-limits",
        "builder-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure different concurrency limits for regular activities and local activities, as the local activity limit is overwritten with the activity limit.",
      "rootCause": "Copy-paste error in WorkerOptions.Builder.build() method where maxConcurrentActivityExecutionSize is passed twice instead of passing maxConcurrentLocalActivityExecutionSize as the 4th argument.",
      "proposedFix": "Change the 4th argument in the WorkerOptions constructor call from maxConcurrentActivityExecutionSize to maxConcurrentLocalActivityExecutionSize.",
      "workaround": "Use validateAndBuildWithDefaults() method as a temporary workaround instead of build().",
      "resolution": "fixed",
      "resolutionDetails": "The bug was confirmed and corrected by passing the proper maxConcurrentLocalActivityExecutionSize parameter.",
      "related": [],
      "keyQuote": "maxConcurrentLocalActivityExecutionSize is configured using maxConcurrentActivityExecutionSize when building the object",
      "number": 1080,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:04:22.392Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not properly terminate child workflows when parent completes with ParentClosePolicy set to TERMINATE. Child workflows are allowed to complete instead of being terminated.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ChildWorkflowOptions",
        "setParentClosePolicy"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "child-workflow-execution",
        "parent-close-policy"
      ],
      "concepts": [
        "workflow-termination",
        "parent-child-relationship",
        "async-child-workflow",
        "lifecycle-management",
        "test-execution"
      ],
      "severity": "high",
      "userImpact": "Tests using async child workflows with TERMINATE parent close policy produce incorrect results, allowing terminated workflows to complete instead.",
      "rootCause": "TestWorkflowEnvironment does not properly handle the TERMINATE parent close policy when parent workflow completes, failing to terminate child workflows as expected.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "when the parent completes, the child workflow is not terminated, but still is allowed to complete.",
      "number": 1079,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:04:21.026Z"
    },
    {
      "summary": "TestWorkflowEnvironment incorrectly schedules the first activity retry immediately instead of respecting the initial interval from the retry policy. With a retry policy having a 10-second initial interval, the first retry executes at T0 instead of waiting 10 seconds.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "RetryOptions"
      ],
      "components": [
        "test-workflow-environment",
        "activity-executor",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "backoff-coefficient",
        "scheduling",
        "timing",
        "test-server"
      ],
      "severity": "medium",
      "userImpact": "Tests using TestWorkflowEnvironment with retry policies produce incorrect timing behavior, potentially masking real retry issues in actual workflows.",
      "rootCause": "The test environment's scheduling logic does not properly apply the initial interval before the first retry attempt, scheduling it immediately instead.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Attempts run at T0, 0, 10, 30, 70 - the first retry gets scheduled immediately.",
      "number": 1069,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:03:42.215Z"
    },
    {
      "summary": "When a workflow is killed by the Deadlock Detector, it throws IllegalStateException instead of a proper Error, which can be caught by user code and cause side effects. The SDK should throw DestroyWorkflowThreadError or similar to properly terminate the workflow thread.",
      "category": "bug",
      "subcategory": "deadlock-detection",
      "apis": [],
      "components": [
        "deadlock-detector",
        "workflow-thread",
        "event-loop"
      ],
      "concepts": [
        "deadlock",
        "thread-termination",
        "exception-handling",
        "determinism",
        "control-thread"
      ],
      "severity": "high",
      "userImpact": "Users may catch IllegalStateException in their workflow code and execute unintended side effects when deadlock detection kills the workflow.",
      "rootCause": "Deadlock Detector raises PotentialDeadlockException in control thread, but workflow thread receives IllegalStateException instead of a proper Error that prevents catchable exceptions.",
      "proposedFix": "Throw DestroyWorkflowThreadError or similar Error type instead of IllegalStateException when workflow is killed by Deadlock Detector.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "SDK was updated to throw proper Error type instead of IllegalStateException when workflow thread is destroyed by deadlock detection.",
      "related": [],
      "keyQuote": "Temporal SDK should throw DestroyWorkflowThreadError or some other kind of Error in this situation that will lead to the killing of the workflow thread.",
      "number": 1066,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:03:42.601Z"
    },
    {
      "summary": "When a workflow is started with invalid input (missing required map parameter), the SDK throws a cryptic ClassCastException instead of a clear error message. The issue was ultimately user error but highlighted poor error reporting.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "data-converter",
        "workflow-implementation",
        "error-handling"
      ],
      "concepts": [
        "input-validation",
        "type-casting",
        "error-messaging",
        "user-error-handling",
        "workflow-execution",
        "parameter-resolution"
      ],
      "severity": "medium",
      "userImpact": "Users receive confusing stack traces when providing invalid workflow inputs, making it difficult to diagnose the actual problem.",
      "rootCause": "DataConverter.arrayFromPayloads() attempts to cast a ParameterizedTypeImpl to Class without proper type checking, causing a ClassCastException when workflow input doesn't match expected types.",
      "proposedFix": "Improve error handling and validation in the data converter to provide clear error messages when input types don't match workflow parameter types.",
      "workaround": "Ensure workflow start commands provide correctly typed input matching the workflow parameter expectations.",
      "resolution": "fixed",
      "resolutionDetails": "Error handling was improved in recent SDK versions to provide more understandable error messages for invalid workflow inputs.",
      "related": [],
      "keyQuote": "The error handling here is very different from when this issue was first open so the underlying user error should be more understandable.",
      "number": 1056,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:03:42.609Z"
    },
    {
      "summary": "Request to make PollWorkflowTaskQueueResponse available through interceptors for logging and monitoring purposes. Specifically, the attempt counter in the response is needed to track workflows that fail to progress due to repeated failures.",
      "category": "feature",
      "subcategory": "interceptor-extensibility",
      "apis": [
        "PollWorkflowTaskQueueResponse",
        "WorkflowInboundInterceptor"
      ],
      "components": [
        "workflow-interceptor",
        "polling-mechanism",
        "worker"
      ],
      "concepts": [
        "interception",
        "logging",
        "monitoring",
        "workflow-task",
        "failure-tracking",
        "extensibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently access polling response metadata through interceptors, limiting their ability to implement custom logging and monitoring for workflow execution progress.",
      "rootCause": null,
      "proposedFix": "Make PollWorkflowTaskQueueResponse or its components available through a new method on WorkflowInboundInterceptor, or expose the most recent task via a getter method.",
      "workaround": "Use gRPC interceptors directly to access the response, or hardcode logging logic similar to the server implementation.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2526
      ],
      "keyQuote": "PollWorkflowTaskQueueResponse has the information about the WorkflowTask and contains some pieces of information that may be needed for reporting/logging.",
      "number": 1051,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:03:03.592Z"
    },
    {
      "summary": "Activity interfaces that inherit from generic interfaces fail with ClassCastException when called in workflows. The issue occurs because generic type parameters in inherited methods are not properly handled during activity method invocation, causing LinkedHashMap to be cast to the wrong type.",
      "category": "bug",
      "subcategory": "activity-generics",
      "apis": [
        "LocalActivityOptions",
        "newLocalActivityStub"
      ],
      "components": [
        "activity-executor",
        "POJOActivityTaskHandler",
        "reflection-handler",
        "type-resolution"
      ],
      "concepts": [
        "generic-types",
        "interface-inheritance",
        "type-erasure",
        "method-reflection",
        "serialization"
      ],
      "severity": "high",
      "userImpact": "Developers cannot use generic interfaces in activity interface hierarchies, blocking a common pattern for reusable activity definitions.",
      "rootCause": "The activity invocation handler uses reflection to invoke methods but does not properly resolve generic type parameters from inherited interface methods, causing deserialized objects to be cast to incorrect types.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A method that's inherited and uses generics in an activity interface always throws a ClassCastException when called within a workflow.",
      "number": 1050,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:03:03.539Z"
    },
    {
      "summary": "Worker logs warning messages about DEADLINE_EXCEEDED and UNAVAILABLE errors every minute when idle with SSL context configured, even though workflows execute normally. The issue was reported as non-reproducible on the latest SDK version.",
      "category": "bug",
      "subcategory": "polling-connection",
      "apis": [
        "WorkflowServiceStubs"
      ],
      "components": [
        "worker",
        "poller",
        "activity-poll-task",
        "grpc-client"
      ],
      "concepts": [
        "deadline-exceeded",
        "connection-management",
        "ssl-context",
        "idle-worker",
        "polling"
      ],
      "severity": "low",
      "userImpact": "Workers generate recurring warning messages in logs that clutter output and may indicate underlying connection issues, though workflow execution is not blocked.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Closed because the issue could not be reproduced on the latest SDK version, suggesting it was either already fixed or environment-specific.",
      "related": [
        707
      ],
      "keyQuote": "Worker still picks up workflow tasks, and you can run your workflows. Just these warnings keep popping up when worker is running but idle.",
      "number": 1046,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:03:02.933Z"
    },
    {
      "summary": "Implement a Remote Data Encoder framework for Java SDK to allow serving and consuming data encoding via HTTP, providing feature parity with Go and TypeScript SDKs. This enables users to encrypt data in their preferred SDK language, restrict encryption key access to a remote process, and support tctl payload encoding.",
      "category": "feature",
      "subcategory": "data-encoding",
      "apis": [
        "DataConverter",
        "PayloadCodec"
      ],
      "components": [
        "data-converter",
        "codec-framework",
        "http-server",
        "encryption"
      ],
      "concepts": [
        "encryption",
        "data-encoding",
        "http-remote-service",
        "key-management",
        "security",
        "cross-sdk-compatibility",
        "tctl-integration"
      ],
      "severity": "medium",
      "userImpact": "Users requiring encryption or similar use cases cannot properly view plaintext in Web UI or tctl output without Java SDK parity with Go and TypeScript SDKs.",
      "rootCause": null,
      "proposedFix": "Implement Remote Data Encoder framework following the protocol specification and reference implementations from Go SDK (PR #717, #733)",
      "workaround": "Use standard data converters approach, though not suitable for all encryption scenarios",
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide parity with other SDKs",
      "related": [],
      "keyQuote": "This is a requirement for anyone who is using encryption and wants to be able to see the plaintext in the Web UI or tctl output.",
      "number": 1044,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:02:23.905Z"
    },
    {
      "summary": "User requested ability to dynamically limit parallel activities based on runtime conditions like available heap space. The solution involves a pluggable component that can inspect poll requests and delay polling if certain conditions aren't satisfied.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "worker",
        "activity-executor",
        "poll-handler"
      ],
      "concepts": [
        "resource-management",
        "concurrency-control",
        "dynamic-limiting",
        "heap-space",
        "polling"
      ],
      "severity": "medium",
      "userImpact": "Users can now dynamically control activity parallelism based on runtime conditions like available heap space to prevent resource exhaustion.",
      "rootCause": null,
      "proposedFix": "Implement a pluggable component that intercepts poll requests and can delay polling based on user-defined conditions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Interface implemented as of PR #2014 in experimental state, with evolution based on user feedback.",
      "related": [
        2014
      ],
      "keyQuote": "Provide a pluggable component that the user can tailor for his needs. This component would be called with poll request and can decide to delay the poll",
      "number": 1042,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:02:22.626Z"
    },
    {
      "summary": "Child workflow cancellation fails with state machine error when attempting to cancel a schedule command that hasn't been sent to the server yet. The error occurs due to an invalid state transition (START_COMMAND_CREATEDCANCEL) when the workflow is in SCHEDULE state.",
      "category": "bug",
      "subcategory": "child-workflow-cancellation",
      "apis": [
        "StartChildWorkflow",
        "CancellationScope"
      ],
      "components": [
        "ChildWorkflowStateMachine",
        "StateMachine",
        "WorkflowStateMachines"
      ],
      "concepts": [
        "state-machine",
        "cancellation",
        "child-workflow",
        "state-transition",
        "command-scheduling"
      ],
      "severity": "high",
      "userImpact": "Users cannot cancel child workflows that are scheduled but not yet started on the server, resulting in runtime exceptions.",
      "rootCause": "Invalid state transition in ChildWorkflowStateMachine: attempting to execute CANCEL transition from START_COMMAND_CREATED state when the actual state is SCHEDULE, causing NullPointerException in CanceledFailure initialization.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "State machine transition logic was corrected to properly handle cancellation of child workflow schedule commands.",
      "related": [],
      "keyQuote": "ChildWorkflow: failure executing START_COMMAND_CREATED->CANCEL, transition history is [CREATED->SCHEDULE]",
      "number": 1037,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:02:23.796Z"
    },
    {
      "summary": "Request to expose describeWorkflowExecution as part of the official WorkflowStub API in Java SDK. Users regularly need this API for checking workflow status and related checks, and it should be wrapped in a friendly Java class.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "describeWorkflowExecution",
        "WorkflowStub"
      ],
      "components": [
        "workflow-client",
        "workflow-stub",
        "grpc-wrapper"
      ],
      "concepts": [
        "workflow-status",
        "workflow-inspection",
        "api-exposure",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users currently lack a convenient SDK method to check workflow execution status and details, forcing them to work directly with gRPC APIs.",
      "rootCause": null,
      "proposedFix": "Wrap describeWorkflowExecution in a friendly Java class as part of WorkflowStub API, exposing at least the status field with option to access the underlying gRPC response.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #2265",
      "related": [
        1028,
        17,
        2265
      ],
      "keyQuote": "describeWorkflowExecution is an API that is used regularly for a large range of checks by the users, Temporal SDK should expose it",
      "number": 1036,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:01:43.236Z"
    },
    {
      "summary": "Request for a new metric to track the total time elapsed from activity scheduling to the last retry attempt, enabling users to set alerts for activities that keep retrying and failing.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "retry-handler"
      ],
      "concepts": [
        "metrics",
        "retry",
        "activity-lifecycle",
        "alerting",
        "latency-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily detect and alert on activities that are stuck in retry loops without implementing custom metrics.",
      "rootCause": null,
      "proposedFix": "Add a new SDK-side metric reporting time from activity scheduling to the last activity attempt, tagged with activity type.",
      "workaround": "Users can produce their own custom metrics.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        718
      ],
      "keyQuote": "We should add a metric reporting how much time passed from an activity schedule to the last activity attempt.",
      "number": 1035,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:01:43.003Z"
    },
    {
      "summary": "Java SDK 1.8.0 introduced version ranges in Gradle platform dependencies, which Maven translates to unsupported version range syntax in dependencyManagement sections. This causes Maven 3.8.4 to fail with a resolution error for jackson-bom and other dependencies.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "maven-integration",
        "dependency-resolution",
        "gradle-platform-translation"
      ],
      "concepts": [
        "version-ranges",
        "maven-bug",
        "dependency-management",
        "gradle-platforms",
        "bom-import"
      ],
      "severity": "high",
      "userImpact": "Users cannot use Java SDK 1.8.0 with Maven 3.8.4, the default Maven version for many environments.",
      "rootCause": "Maven does not support version ranges in dependencyManagement sections. Gradle platforms with version ranges are incorrectly translated to Maven's unsupported [min,max) syntax. This is a known Maven bug (MNG-4463) unfixed in current releases.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by updating dependency declarations to use concrete versions instead of version ranges, or by waiting for Maven 4.0.0 fix",
      "related": [],
      "keyQuote": "Gradle Platforms with version range are translated effectively into the Maven dependencyManagement section that looks like... It's a long-time Maven bug of not supporting version ranges in dependencyManagement sections.",
      "number": 1033,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:01:43.534Z"
    },
    {
      "summary": "Request to add ability to disable workflow worker in Java SDK. Unlike Go SDK which allows workflow registration after worker startup, Java requires all registration before startup, so this feature would allow conditionally enabling/disabling the workflow worker and poller based on whether workflows are registered.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "worker",
        "workflow-poller",
        "worker-options"
      ],
      "concepts": [
        "worker-initialization",
        "workflow-registration",
        "conditional-startup",
        "poller-management"
      ],
      "severity": "low",
      "userImpact": "Users would have more flexibility in configuring which pollers to enable based on their worker's registered workflows and activities.",
      "rootCause": null,
      "proposedFix": "Conditionally enable/disable workflow worker and poller if no workflows were registered, similar to the Go SDK implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in Java SDK following the pattern used in Go SDK to allow conditional enabling/disabling of workflow worker based on whether workflows are registered.",
      "related": [
        636
      ],
      "keyQuote": "If Java requires all registration happen before worker is started, you can just not turn on the workflow worker/poller if no workflows were registered",
      "number": 1032,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:01:01.741Z"
    },
    {
      "summary": "Rename WorkerOptions poller-related options in Java SDK to match Go SDK naming conventions for better cross-SDK consistency. Java uses `workflowPollThreadCount` and `activityPollThreadCount` while Go uses the more generic `MaxConcurrentWorkflowTaskPollers` and `MaxConcurrentActivityTaskPollers`.",
      "category": "feature",
      "subcategory": "api-naming",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "options",
        "polling"
      ],
      "concepts": [
        "naming-consistency",
        "sdk-unification",
        "workflow-polling",
        "activity-polling",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users would need to update code using these options to the new naming convention.",
      "rootCause": null,
      "proposedFix": "Rename `workflowPollThreadCount` to `maxConcurrentWorkflowTaskPollers` and `activityPollThreadCount` to `maxConcurrentActivityTaskPollers`",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in PR #1031",
      "related": [
        1031
      ],
      "keyQuote": "GoSDK naming is more generic and should be preferred for unification between SDKs.",
      "number": 1030,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:01:01.279Z"
    },
    {
      "summary": "User encountered missing `WorkflowExecutionUtils.describeWorkflowInstance()` method after upgrading from SDK v1.1.0 to v1.8.0. The method was removed during refactoring in v1.4.0. User asked for alternatives to get workflow execution status.",
      "category": "question",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowExecutionUtils.describeWorkflowInstance",
        "DescribeWorkflowExecution"
      ],
      "components": [
        "WorkflowExecutionUtils",
        "WorkflowClientHelper",
        "WorkflowServiceStubs"
      ],
      "concepts": [
        "internal-api",
        "breaking-change",
        "workflow-status",
        "api-compatibility",
        "migration",
        "deprecated-method"
      ],
      "severity": "medium",
      "userImpact": "Users upgrading to newer SDK versions face compilation failures if they relied on the removed internal method.",
      "rootCause": "The method was removed during refactoring of WorkflowExecutionUtils in v1.4.0 because it was part of an internal class not intended for public use.",
      "proposedFix": "Use WorkflowServiceStubs directly with DescribeWorkflowExecutionRequest as shown in the comment, or wait for official SDK API exposure (issue #976).",
      "workaround": "Copy the provided implementation of describeWorkflowInstance into the project, or call the gRPC stubs directly.",
      "resolution": "invalid",
      "resolutionDetails": "Closed as invalid because the method was in an internal class not meant for public consumption. Users were directed to use gRPC stubs directly or wait for official API.",
      "related": [
        976
      ],
      "keyQuote": "io.temporal.internal.common.WorkflowExecutionUtils is an internal class and you shouldn't be using it in the first place.",
      "number": 1028,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:01:02.801Z"
    },
    {
      "summary": "Epic tracking documentation improvements needed across Javadocs, including CancelationScope.cancel, Workflow.registerListener, and ActivityOptions. The issue was closed as GitHub is no longer used for tracking epics.",
      "category": "docs",
      "subcategory": "javadocs",
      "apis": [
        "CancelationScope",
        "Workflow.registerListener",
        "DynamicSignalHandler",
        "DynamicQueryHandler",
        "ActivityOptions"
      ],
      "components": [
        "documentation",
        "javadoc",
        "workflow-interface",
        "activity-options"
      ],
      "concepts": [
        "documentation",
        "api-documentation",
        "code-comments",
        "interface-documentation",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Incomplete or inaccurate Javadocs make it harder for developers to understand and use SDK APIs correctly.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because the team no longer uses GitHub issues to track epics; epic management has moved to another system.",
      "related": [
        387,
        752,
        1318
      ],
      "keyQuote": "Closing since we no longer want to use GH issues as epics",
      "number": 1027,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:00:20.814Z"
    },
    {
      "summary": "Java SDK lacks a way to distinguish between a returned existing workflow execution versus a newly started one when WorkflowReusePolicy prevents re-execution. Go SDK has WorkflowExecutionErrorWhenAlreadyStarted flag to address this; Java needs similar functionality for both sync and async APIs.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteWorkflow",
        "StartWorkflow"
      ],
      "components": [
        "client",
        "workflow-execution",
        "api-consistency"
      ],
      "concepts": [
        "workflow-reuse-policy",
        "duplicate-detection",
        "error-handling",
        "api-consistency",
        "execution-state"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably determine if a workflow execution was newly started or if an existing execution was returned, forcing them to use exceptions for control flow or leading to inconsistent behavior between sync and async APIs.",
      "rootCause": "Java SDK's ExecuteWorkflow returns an existing execution on reuse-policy conflicts instead of providing an option to error out, and StartWorkflow throws exceptions, creating inconsistent behavior between the two APIs.",
      "proposedFix": "Add a configuration flag (similar to Go's WorkflowExecutionErrorWhenAlreadyStarted) to both sync and async execution methods allowing users to choose between erroring out or returning the existing execution when WorkflowReusePolicy prevents re-execution.",
      "workaround": "Make two separate API calls: StartWorkflow (catches exception) followed by waiting for workflow result, but this uses exceptions as control flow which is not ideal.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This makes users use exceptions as a part of their normal code flow. It is bad practice especially when we already have all the underlying APIs to make it possible without exceptions.",
      "number": 1025,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:00:22.170Z"
    },
    {
      "summary": "Java SDK should log long poll failures similar to Core and Go implementations to help with debugging and monitoring without spamming logs.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "polling",
        "logging",
        "worker"
      ],
      "concepts": [
        "long-polling",
        "failure-logging",
        "observability",
        "log-frequency",
        "debugging"
      ],
      "severity": "low",
      "userImpact": "Users lack visibility into long poll failures in Java SDK, making it harder to diagnose connection and polling issues compared to other language SDKs.",
      "rootCause": null,
      "proposedFix": "Implement logging of long poll failures with frequency throttling to match Go SDK implementation (PR #708).",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This is already implemented in Core and now in Go. Java should have the same behavior.",
      "number": 1019,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T19:00:20.077Z"
    },
    {
      "summary": "OpenTracing interceptor logs all exceptions as errors, creating artificially inflated error metrics for expected polling failures. Request to add a configurable predicate to filter which exceptions are logged as errors in traces.",
      "category": "feature",
      "subcategory": "opentracing-interceptor",
      "apis": [],
      "components": [
        "opentracing-interceptor",
        "tracing",
        "exception-handling"
      ],
      "concepts": [
        "error-tracking",
        "observability",
        "exception-filtering",
        "polling-pattern",
        "external-services",
        "metrics"
      ],
      "severity": "low",
      "userImpact": "Users with polling workflows generate misleading error metrics and spans in OpenTracing due to expected exceptions being logged as errors.",
      "rootCause": "OpenTracing interceptor treats all exceptions identically regardless of whether they represent actual errors or expected control flow.",
      "proposedFix": "Add a configurable `java.util.function.Predicate` parameter called `isErrorPredicate` to `OpenTracingOptions` that accepts an exception and determines if it should be logged as an error, with a default implementation returning `true`.",
      "workaround": "Implement a custom interceptor for the project that wraps or replaces the OpenTracing interceptor.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented via configurable Predicate in OpenTracingOptions as suggested in comments.",
      "related": [],
      "keyQuote": "I'd like to be able to exclude certain exception types from being logged as errors in the OpenTracing interceptor.",
      "number": 1012,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:59:41.170Z"
    },
    {
      "summary": "Epic for collecting Java SDK user experience improvements. This includes multiple tasks aimed at simplifying APIs, reducing workarounds, and improving overall usability for developers using the Java SDK.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [],
      "components": [
        "api-design",
        "developer-experience",
        "sdk-usability"
      ],
      "concepts": [
        "user-experience",
        "api-simplification",
        "developer-workflow",
        "workarounds",
        "usability"
      ],
      "severity": "medium",
      "userImpact": "Java SDK users struggle with unnecessarily complex APIs that require workarounds and artificial effort to implement common tasks.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because GitHub issues are no longer used as epics; the epic structure itself was deprecated in favor of other project management approaches.",
      "related": [
        1009,
        1010,
        1098
      ],
      "keyQuote": "Closing since we no longer want to use GH issues as epics",
      "number": 1011,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:59:38.969Z"
    },
    {
      "summary": "Workflow needs access to the activity ID of scheduled activities to enable external cancellation and async activity completion. Currently, activities cannot retrieve their own ID, forcing users to maintain separate correlation IDs and pass them manually.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteActivity",
        "ActivityOptions"
      ],
      "components": [
        "activity-executor",
        "workflow-execution",
        "activity-stub"
      ],
      "concepts": [
        "activity-id",
        "activity-cancellation",
        "async-completion",
        "determinism",
        "correlation"
      ],
      "severity": "high",
      "userImpact": "Users cannot directly cancel activities from external code without complex workarounds, and async activity completion is unreliable due to inability to pass activity ID reliably.",
      "rootCause": "Activity execution context does not expose the assigned activity ID to the activity code, and activity IDs are treated as internal implementation details rather than accessible identifiers.",
      "proposedFix": "Create an ActivityInvocationStub that binds activity type, parameters, and exposes the activity ID. Allow workflows to generate and pass activity IDs to stubs while ensuring uniqueness for determinism. Stub should also allow overriding ActivityOptions per invocation.",
      "workaround": "Users must create and maintain separate correlation IDs, map them to cancellation scopes or activities, and pass these IDs manually between workflow and activity.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1009
      ],
      "keyQuote": "An activity sends its own id to some external code and this code has a need to cancel the activity if something happens or finishes before the activity is done.",
      "number": 1010,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:59:41.017Z"
    },
    {
      "summary": "ActivityStub should be bound to specific activity types and support typed method references, similar to WorkflowStub, to provide consistency and better type safety across the SDK.",
      "category": "feature",
      "subcategory": "activity-stubs",
      "apis": [
        "ActivityStub",
        "ActivityInterface",
        "ActivityMethod",
        "WorkflowStub"
      ],
      "components": [
        "activity-stubs",
        "activity-interface",
        "untyped-stubs"
      ],
      "concepts": [
        "type-binding",
        "method-reference",
        "consistency",
        "type-safety",
        "api-design"
      ],
      "severity": "medium",
      "userImpact": "Users must work with untyped ActivityStub and string-based activity names instead of compile-time safe method references, making it harder to use compared to WorkflowStub.",
      "rootCause": "ActivityInterface can have multiple ActivityMethod entries unlike WorkflowInterface which has a single entry workflow method, causing inconsistency in stub design.",
      "proposedFix": "Create a variation of ActivityStub bound to specific activity types and add ActivityStub.fromTyped method similar to WorkflowStub.fromTyped that takes a method reference instead of an instance pointer.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "To keep things consistent, we should have a variation of the ActivityStub that binds an execution of the activity to a specific type the same way as WorkflowStub.",
      "number": 1009,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:59:00.023Z"
    },
    {
      "summary": "Request for first-class Scala language support in the Java SDK, including interoperability for functional types (Func/Proc), Scala collection serialization, and Scala-idiomatic APIs for workflow operations.",
      "category": "feature",
      "subcategory": "language-support",
      "apis": [
        "WorkflowClient.start",
        "WorkflowClient.execute",
        "Workflow.await"
      ],
      "components": [
        "workflow-client",
        "serialization",
        "scala-interop",
        "method-references"
      ],
      "concepts": [
        "scala-integration",
        "functional-programming",
        "type-conversion",
        "method-references",
        "collection-serialization",
        "language-bindings"
      ],
      "severity": "medium",
      "userImpact": "Scala developers must write verbose Java interop wrappers to use the SDK, reducing code ergonomics and adoption in Scala projects.",
      "rootCause": "The Java SDK APIs use Java-specific functional types (Func, Proc, Supplier) and collection types that don't map naturally to Scala idioms; method reference handling differs between Java and Scala.",
      "proposedFix": "Create a Scala module with idiomatic wrappers for WorkflowClient and Workflow operations, support Scala collections in serialization, and handle Scala method references correctly.",
      "workaround": "Write small wrapper functions to convert Scala functions/lambdas to Java functional types; use Scala-Java interop libraries like scala-java8-compat for Future conversion.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Scala developers must write verbose Java interop wrappers to use the SDK, reducing code ergonomics and adoption in Scala projects.",
      "number": 1007,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:59:00.282Z"
    },
    {
      "summary": "Request to add ActivityExecutionContext#isCancelled method to allow activities to check cancellation status without heartbeating. Currently, activities can only detect cancellation through heartbeat exceptions, which is problematic for non-heartbeating and local activities that have no way to be notified of cancellation.",
      "category": "feature",
      "subcategory": "activity-cancellation",
      "apis": [
        "ActivityExecutionContext",
        "isCancelled"
      ],
      "components": [
        "activity-executor",
        "activity-context",
        "local-activity",
        "heartbeat-mechanism"
      ],
      "concepts": [
        "cancellation",
        "activity-timeout",
        "interruption",
        "context-flag",
        "heartbeat-alternative"
      ],
      "severity": "high",
      "userImpact": "Activities currently lack a clean, non-heartbeat mechanism to detect cancellation, making it difficult to implement proper cancellation handling in local activities and non-heartbeating activities.",
      "rootCause": "The SDK's current cancellation notification design relies exclusively on heartbeat exceptions, which doesn't work for activities that don't heartbeat or for local activities that don't heartbeat at all.",
      "proposedFix": "Add ActivityExecutionContext#isCancelled method as a flag-based alternative to heartbeat exception handling, with a possible additional method returning detailed cancellation reasons.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1004
      ],
      "keyQuote": "Not all activities need to heartbeat and making them do it just to check for cancelation is ugly.",
      "number": 1005,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:58:59.837Z"
    },
    {
      "summary": "Local Activity Worker ignores startToClose and scheduleToClose timeouts, allowing activities to run longer than the specified startToClose timeout. The worker should respect startToClose by initiating new executions or abandoning timed-out activities.",
      "category": "bug",
      "subcategory": "local-activity-timeout",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity-worker",
        "activity-executor",
        "timeout-enforcement"
      ],
      "concepts": [
        "timeout",
        "startToClose",
        "scheduleToClose",
        "activity-lifecycle",
        "execution-control"
      ],
      "severity": "high",
      "userImpact": "Users cannot rely on startToClose timeouts for local activities, causing unpredictable execution times and potential workflow delays.",
      "rootCause": "Local Activity Worker does not enforce startToClose timeout; only scheduleToClose is considered during execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented proper startToClose timeout enforcement in Local Activity Worker",
      "related": [],
      "keyQuote": "Local Activity Worker should respect `startToClose` timeout and initiate a new activity execution if the activity call doesn't finish during a user-defined timeout.",
      "number": 1004,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:58:20.096Z"
    },
    {
      "summary": "Java SDK uses a single sticky queue and poller per workflow factory shared across all workers, causing rate limiting issues, backpressure problems, and resource isolation complexities. The solution is to implement one sticky queue and poller per worker to match Go and Core implementations.",
      "category": "feature",
      "subcategory": "pollers-workers",
      "apis": [],
      "components": [
        "worker",
        "sticky-queue",
        "poller",
        "workflow-factory"
      ],
      "concepts": [
        "rate-limiting",
        "backpressure",
        "resource-isolation",
        "queue-prioritization",
        "concurrency"
      ],
      "severity": "high",
      "userImpact": "Users cannot rate limit workflow task fetching or implement per-worker backpressure, limiting their ability to manage resource consumption.",
      "rootCause": "Architectural design shares a single sticky queue and poller across all workers in a factory, preventing independent rate limiting and backpressure per worker.",
      "proposedFix": "Implement one sticky queue and poller per worker instead of per workflow factory, enabling independent rate limiting and backpressure semantics similar to activity polling.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed to bring pollers and workers on par with Core and Go SDK implementations with per-worker sticky queues.",
      "related": [
        760,
        997
      ],
      "keyQuote": "A sticky queue and poller per each worker. This will also open the road to implement the same backpressure semantic we have for activities",
      "number": 998,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:58:20.624Z"
    },
    {
      "summary": "When registering workflow implementations that inherit from @WorkflowInterface annotated interfaces, the framework registers the parent interface name instead of the child interface name, causing IllegalStateException and confusing behavior.",
      "category": "bug",
      "subcategory": "workflow-interface-inheritance",
      "apis": [
        "@WorkflowInterface",
        "@WorkflowMethod",
        "@SignalMethod"
      ],
      "components": [
        "worker-registration",
        "workflow-interface-processor",
        "annotation-handler"
      ],
      "concepts": [
        "interface-inheritance",
        "workflow-type-registration",
        "annotation-processing",
        "polymorphism",
        "type-resolution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot register workflow implementations using inherited workflow interfaces as it either registers the wrong workflow type or throws an IllegalStateException.",
      "rootCause": "The framework does not properly resolve the actual interface being registered when inheritance is involved; it appears to register the parent interface name instead of the child interface name.",
      "proposedFix": "Support workflow interface inheritance properly so that registering a child workflow interface registers it with the child interface name, not the parent's.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "What definitely shouldn't happen and it happens now, when a user registers CustomerWorkflowWithSignal workflow, actually a workflow CustomerWorkflow gets registered.",
      "number": 995,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:58:20.129Z"
    },
    {
      "summary": "Add Jackson jdk8 module support to JacksonJsonPayloadConverter to enable workflows and activities to use Optional parameters like Optional<MyClass>.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "JacksonJsonPayloadConverter",
        "Jackson",
        "serialization"
      ],
      "concepts": [
        "Optional",
        "jdk8",
        "type-handling",
        "parameter-support",
        "serialization"
      ],
      "severity": "low",
      "userImpact": "Developers can now use Java Optional types in workflow and activity parameters for more idiomatic null-safety.",
      "rootCause": null,
      "proposedFix": "Register Jackson jdk8 support module in JacksonJsonPayloadConverter",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Jackson jdk8 module support was added to JacksonJsonPayloadConverter",
      "related": [],
      "keyQuote": "Adding would allow workflow / activities to use optional params, for example Optional<MyClass> etc.",
      "number": 991,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:57:39.199Z"
    },
    {
      "summary": "LocalActivity retry intervals are ignored due to incorrect Duration checking. The code checks if getNanos() > 0, but getNanos() returns 0 even when seconds are specified, causing the default retry interval to be used instead of the configured value.",
      "category": "bug",
      "subcategory": "local-activity-retry",
      "apis": [
        "LocalActivityOptions",
        "RetryOptions",
        "MethodRetry"
      ],
      "components": [
        "LocalActivityWorker",
        "retry-policy",
        "local-activity-executor"
      ],
      "concepts": [
        "retry",
        "duration",
        "interval",
        "local-activity",
        "configuration",
        "default-values"
      ],
      "severity": "high",
      "userImpact": "Users cannot configure custom retry intervals for local activities, as their settings are silently ignored and default values are used instead.",
      "rootCause": "LocalActivityWorker.handleLocalActivity() checks only getNanos() > 0 to validate the maximum interval, ignoring the seconds component of Duration. This causes valid durations like Duration.ofSeconds(30, 1) to be treated as zero.",
      "proposedFix": "Check the complete Duration value (both seconds and nanos) instead of only getNanos() when validating the maximum interval.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue confirmed by maintainer Spikhalskiy",
      "related": [],
      "keyQuote": "The problem is that getNanos() always returns 0, so default value is used. It doesn't matter if use MethodRetry annotation or specify RetryOptions via setRetryOptions method",
      "number": 989,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:57:41.058Z"
    },
    {
      "summary": "The WorkflowServiceStubsOptions#rpcLongPollTimeout is currently hardcoded to require a minimum of 70 seconds due to the server's 60-second timeout. This prevents users with strict network configurations (like reverse proxies) from using shorter polling timeouts. The request is to make this timeout configurable to support shorter values.",
      "category": "feature",
      "subcategory": "configuration",
      "apis": [
        "WorkflowServiceStubsOptions"
      ],
      "components": [
        "workflow-service-stubs",
        "client-configuration",
        "connection-options"
      ],
      "concepts": [
        "timeout",
        "long-polling",
        "configuration",
        "network-constraints",
        "server-communication",
        "client-deadline"
      ],
      "severity": "medium",
      "userImpact": "Users with strict network layer configurations (reverse proxies, middleware) cannot configure shorter long poll timeouts, forcing them to use the 70-second minimum.",
      "rootCause": "The server's 60-second timeout cap and safety margin implementation require the client to always use 70+ seconds, but this doesn't account for users with stricter network constraints.",
      "proposedFix": "Allow the SDK to accept rpcLongPollTimeout values less than 70 seconds, and let the server handle returning responses based on the request's context timeout/deadline.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        705
      ],
      "keyQuote": "Not allowing users to configure the long polls to be shorter than 70s, Temporal makes configuration tricky for some of the users who may be using middle layers with a strict configuration",
      "number": 988,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:57:41.338Z"
    },
    {
      "summary": "Request to add metrics for active executor threads in the Java SDK. Currently, the SDK lacks direct metrics to gauge the utilization of WTF, Activity, or Local Activity executor thread pools, making it difficult to determine if executor pool sizes need to be increased.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "executor",
        "thread-pool",
        "worker"
      ],
      "concepts": [
        "thread-pool-utilization",
        "executor-capacity",
        "resource-monitoring",
        "performance-metrics",
        "thread-availability",
        "capacity-planning"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily determine if their executor thread pools are fully utilized or if they need to increase pool sizes for better performance.",
      "rootCause": null,
      "proposedFix": "Report a gauge metric with the number of available threads in Executor ThreadPools.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Report a gauge metric with a number of available threads in Executor ThreadPools.",
      "number": 986,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:56:59.158Z"
    },
    {
      "summary": "Gauge metrics disappear approximately 60 seconds after being reported to Micrometer, despite being properly initialized. The issue occurs in MicrometerClientStatsReporter which creates gauges with primitive number values, violating Micrometer's requirement to maintain strong references to state objects.",
      "category": "bug",
      "subcategory": "metrics-gauges",
      "apis": [],
      "components": [
        "MicrometerClientStatsReporter",
        "MeterRegistry",
        "metrics-collection"
      ],
      "concepts": [
        "gauge-metrics",
        "garbage-collection",
        "micrometer-integration",
        "metrics-reporting",
        "reference-management",
        "memory-management"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably track gauge metrics in their Temporal applications as reported metrics disappear after approximately 60 seconds.",
      "rootCause": "MicrometerClientStatsReporter creates gauges with primitive double values instead of maintaining strong references to state objects, causing them to be garbage collected as Micrometer expects the user to hold references to the measured object.",
      "proposedFix": "Modify MicrometerClientStatsReporter to create gauges using AtomicLong or similar wrapper objects and maintain strong references to ensure they are not garbage collected, consistent with Micrometer's gauge documentation.",
      "workaround": "Create Gauge instances directly through MeterRegistry with AtomicLong and ensure the reference is held to prevent garbage collection.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was confirmed as a bug in MicrometerClientStatsReporter's integration with Micrometer, indicating it was subsequently fixed in a later version.",
      "related": [],
      "keyQuote": "It is your responsibility to hold a strong reference to the state object that you are measuring with a Gauge.",
      "number": 979,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:57:01.327Z"
    },
    {
      "summary": "Static and synthetic methods in activity interfaces are incorrectly treated as activity methods, causing registration errors when using tools like Jacoco that generate synthetic methods.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "registerActivitiesImplementations"
      ],
      "components": [
        "activity-registration",
        "POJOActivityTaskHandler",
        "activity-interface-reflection"
      ],
      "concepts": [
        "synthetic-methods",
        "static-methods",
        "method-reflection",
        "activity-discovery",
        "code-generation",
        "jacoco-coverage"
      ],
      "severity": "medium",
      "userImpact": "Users running Jacoco coverage or other tools that generate synthetic methods experience crashes when registering activity implementations.",
      "rootCause": "Activity registration logic scans all methods in activity interfaces without filtering out synthetic or static methods, treating them as activity methods.",
      "proposedFix": "Filter out static and synthetic methods during activity method discovery by checking Method.isSynthetic() and Modifier.isStatic().",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Activity registration now ignores static and synthetic methods during reflection-based method discovery.",
      "related": [],
      "keyQuote": "A construct emitted by a Java compiler must be marked as synthetic if it does not correspond to a construct declared explicitly or implicitly in source code",
      "number": 977,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:57:00.444Z"
    },
    {
      "summary": "Epic to systematize and expose additional Temporal APIs for utility functionality that doesn't fit within WorkflowClient. This includes workflow introspection, status queries, and administrative operations that users currently implement via raw gRPC or internal workarounds.",
      "category": "feature",
      "subcategory": "admin-apis",
      "apis": [
        "WorkflowClient",
        "describeWorkflowExecution"
      ],
      "components": [
        "client-api",
        "admin-utilities",
        "workflow-management"
      ],
      "concepts": [
        "workflow-status",
        "pagination",
        "search-attributes",
        "visibility",
        "administrative-operations"
      ],
      "severity": "medium",
      "userImpact": "Users must currently implement custom utility methods or use raw gRPC endpoints for common administrative tasks like checking workflow status and resetting workflows.",
      "rootCause": "Lack of structured API surface for administrative and introspection functionality outside of WorkflowClient, forcing users to create their own implementations.",
      "proposedFix": "Create a new class/interface structure to systematically expose administrative APIs with built-in pagination handling and clear documentation on Elasticsearch vs persistent store consistency.",
      "workaround": "Users implement custom utility methods wrapping raw gRPC endpoints or use tctl-equivalent operations locally.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue was closed as an epic format is no longer used for tracking GitHub issues.",
      "related": [
        1036,
        835,
        1028
      ],
      "keyQuote": "we should have a 1-1 mapping between tctl commands and out-of-box util methods in our sdk",
      "number": 976,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:56:19.816Z"
    },
    {
      "summary": "Request to add WorkflowImplementationOptions.setLocalActivityOptions to allow users to define default local activity options at the workflow level, similar to the existing setActivityOptions for regular activities.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "newLocalActivityStub",
        "newActivityStub"
      ],
      "components": [
        "workflow-implementation-options",
        "local-activity-stub",
        "activity-options"
      ],
      "concepts": [
        "configuration",
        "defaults",
        "local-activities",
        "activity-options",
        "workflow-level-settings",
        "option-override"
      ],
      "severity": "medium",
      "userImpact": "Users can now configure default local activity options at the workflow level instead of having to specify them individually in workflow code.",
      "rootCause": null,
      "proposedFix": "Add WorkflowImplementationOptions.setLocalActivityOptions method that accepts a Map<String, LocalActivityOptions> and applies these defaults to Workflow.newLocalActivityStub calls, with ability to override them with specific options.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide parity with ActivityOptions configuration capabilities.",
      "related": [],
      "keyQuote": "add WorkflowImplementationOptions.setLocalActivityOptions which would be applied to Workflow.newLocalActivityStub and can be overwritten if specific LocalActivity options are specified",
      "number": 975,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:56:17.320Z"
    },
    {
      "summary": "Worker options are immutable, requiring the entire WorkerFactory to be shut down and recreated to change worker configuration. This is expensive as it disrupts in-flight activities and evicts the workflow cache. A feature request to gracefully replace workers with new options without stopping the factory.",
      "category": "feature",
      "subcategory": "worker-lifecycle",
      "apis": [
        "WorkerFactory",
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "worker-factory",
        "workflow-cache"
      ],
      "concepts": [
        "worker-replacement",
        "graceful-shutdown",
        "configuration-update",
        "cache-management",
        "activity-disruption"
      ],
      "severity": "medium",
      "userImpact": "Users must stop the entire WorkerFactory to change worker configuration, causing disruption to in-flight activities and loss of cached workflows.",
      "rootCause": "WorkerOptions are immutable and workers are tightly coupled to the factory, making individual worker reconfiguration impossible without factory restart.",
      "proposedFix": "Add a method like `WorkerFactory.shutdownAndRecreateWorker(Worker existingWorker, WorkerOptions newOptions)` that gracefully replaces a worker without stopping the factory.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Not supported in any other SDK and not currently planned for implementation.",
      "related": [
        1230
      ],
      "keyQuote": "provide a way to gracefully replace an existing Worker with a new worker with new WorkerOptions without stopping the factory",
      "number": 966,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:56:17.930Z"
    },
    {
      "summary": "Version ranges for dependencies are lost during artifact publication to Nexus, being replaced with strict requirements. This causes dependency conflicts for Temporal users.",
      "category": "bug",
      "subcategory": "artifact-publication",
      "apis": [],
      "components": [
        "gradle-publication",
        "nexus-repository",
        "dependency-management"
      ],
      "concepts": [
        "version-ranges",
        "dependency-constraints",
        "artifact-metadata",
        "gradle-modules",
        "nexus-publication"
      ],
      "severity": "high",
      "userImpact": "Users experience dependency conflicts and struggle with the dependency matrix due to overly strict version requirements in published artifacts.",
      "rootCause": "Version ranges are not being preserved during the Gradle publication process to Nexus, likely due to Gradle module metadata (POM or .module file) generation replacing ranges with locked versions.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the publication process was updated to preserve version ranges in artifacts.",
      "related": [],
      "keyQuote": "The version ranges are lost during publication and replaced with strict requirements as may be seen here",
      "number": 964,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:55:36.029Z"
    },
    {
      "summary": "Users need a way to detect if code is executing inside a workflow thread to enable code reuse between workflow and non-workflow contexts, selecting between deterministic and non-deterministic implementations accordingly.",
      "category": "feature",
      "subcategory": "workflow-context",
      "apis": [
        "Workflow"
      ],
      "components": [
        "workflow-executor",
        "context-detection"
      ],
      "concepts": [
        "code-reuse",
        "determinism",
        "context-awareness",
        "thread-detection",
        "workflow-execution"
      ],
      "severity": "low",
      "userImpact": "Users can more easily share code between workflow and non-workflow contexts by programmatically determining execution context.",
      "rootCause": null,
      "proposedFix": "Add a method on the Workflow class returning true if executing inside a workflow thread",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Method added to Workflow class to detect workflow thread context, addressing the feature request",
      "related": [],
      "keyQuote": "Users want to reuse pieces of code in workflow and outside of the workflow context and use deterministic Workflow class methods if they are inside a workflow context and non-deterministic versions if they are outside.",
      "number": 955,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:55:36.361Z"
    },
    {
      "summary": "OpenTracing duplicates user-created spans during workflow replay. When a workflow is replayed, spans created by user code are recreated instead of being ignored, resulting in duplicate span reports. The solution should discard spans during replay when they were already reported in the original execution.",
      "category": "bug",
      "subcategory": "opentracing-replay",
      "apis": [],
      "components": [
        "tracer",
        "scope-manager",
        "span",
        "workflow-replay"
      ],
      "concepts": [
        "opentracing",
        "replay",
        "span-duplication",
        "tracing-library",
        "determinism",
        "parent-span"
      ],
      "severity": "medium",
      "userImpact": "Users see duplicate spans in trace data when workflows are replayed, making tracing output confusing and inaccurate.",
      "rootCause": "Spans created during workflow replay are not discarded; they are finalized like normal spans, causing duplicates in the trace output. Unlike TypeScript SDK which completely evicts workflows, Java SDK must run cleanup blocks including span finalization.",
      "proposedFix": "Create a thin wrapper layer on top of Tracer, ScopeManager, Scope, or Span that checks if the workflow is replaying when a span is finalized. If replaying, discard the span instead of finalizing it. Alternatively, serialize span data into history and recreate from serialized data on replay, ensuring deterministic span IDs.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        951
      ],
      "keyQuote": "The user span should be duplicated under each WorkflowRun span and contain only activities that were actually executed and not replayed in that run.",
      "number": 952,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:55:38.174Z"
    },
    {
      "summary": "User requested OpenTelemetry tracing support for Java SDK similar to Go SDK's otel interceptor. Issue was closed as invalid/wontfix with guidance that existing OpenTracing support already provides OpenTelemetry compatibility.",
      "category": "question",
      "subcategory": "tracing",
      "apis": [],
      "components": [
        "tracing",
        "opentelemetry",
        "interceptor"
      ],
      "concepts": [
        "observability",
        "distributed-tracing",
        "instrumentation",
        "opentelemetry",
        "opentracing"
      ],
      "severity": "low",
      "userImpact": "Users looking for OpenTelemetry tracing integration were confused about available options and directed to existing OpenTracing support.",
      "rootCause": null,
      "proposedFix": "Use existing temporal-opentracing module with OpenTelemetry bridge as documented.",
      "workaround": "Configure OpenTracing with OpenTelemetry as shown in temporal-opentracing documentation.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer provided documentation link showing OpenTracing already supports OpenTelemetry bridging, making separate OTEL interceptor unnecessary. Directed user to community forums for further questions.",
      "related": [
        207
      ],
      "keyQuote": "Here is a configuration for opentracing... here is how is can be used with opentelemetry",
      "number": 950,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:54:56.197Z"
    },
    {
      "summary": "DynamicActivity incorrectly uses a regular activity context instead of maintaining the local activity context when called as a local activity, affecting heartbeat behavior and other activity-specific concepts.",
      "category": "bug",
      "subcategory": "dynamic-activity",
      "apis": [
        "DynamicActivity"
      ],
      "components": [
        "activity-executor",
        "dynamic-activity",
        "context-management"
      ],
      "concepts": [
        "heartbeat",
        "local-activity",
        "activity-context",
        "context-inheritance"
      ],
      "severity": "high",
      "userImpact": "Local activities using DynamicActivity behave incorrectly with respect to heartbeating and other activity concepts, potentially causing unexpected timeouts or behavior differences.",
      "rootCause": "DynamicActivity instantiation creates a regular activity context instead of preserving or detecting the local activity context when invoked.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by ensuring DynamicActivity respects and maintains the local activity context properties when invoked as a local activity.",
      "related": [],
      "keyQuote": "DynamicActivity has a regular activity context even if called as a local activity.",
      "number": 948,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:54:54.824Z"
    },
    {
      "summary": "HeartbeatContext currently uses constant delay for network retries but should use exponential backoff via GrpcRetryer to better handle transient network issues.",
      "category": "other",
      "subcategory": "activity-heartbeat",
      "apis": [
        "HeartbeatContext"
      ],
      "components": [
        "heartbeat",
        "grpc-client",
        "retry-logic"
      ],
      "concepts": [
        "exponential-backoff",
        "network-resilience",
        "retry-strategy",
        "activity-execution",
        "error-handling"
      ],
      "severity": "medium",
      "userImpact": "Users experience unnecessary heartbeat failures during transient network issues because constant delays are less effective than exponential backoff.",
      "rootCause": "HeartbeatContext retry mechanism uses constant delay instead of exponential backoff strategy.",
      "proposedFix": "Rework HeartbeatContext to use GrpcRetryer with exponential backoff for handling network issues.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Marked as duplicate of issue #1258 which addresses the same exponential backoff requirement.",
      "related": [
        1258
      ],
      "keyQuote": "HeartbeatContext should have an exponential backoff in case of network issues",
      "number": 947,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:54:55.348Z"
    },
    {
      "summary": "Add support for headers in signals and queries, mirroring functionality already implemented in the Temporal server and other SDKs (Go, TypeScript).",
      "category": "feature",
      "subcategory": "signal-query-headers",
      "apis": [
        "Signal",
        "Query"
      ],
      "components": [
        "signal-dispatcher",
        "query-handler",
        "interceptor-framework"
      ],
      "concepts": [
        "headers",
        "metadata-propagation",
        "interceptor-extension",
        "cross-sdk-parity"
      ],
      "severity": "medium",
      "userImpact": "Users cannot pass custom headers with signals and queries, limiting context propagation and tracing capabilities.",
      "rootCause": null,
      "proposedFix": "Implement header parameter support in signal and query APIs, following the pattern established in Go and TypeScript SDKs.",
      "workaround": "Use WorkflowClientCallsInterceptorBase and custom interceptors to manually handle context propagation.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by PR #1819 which added header support to signals and queries.",
      "related": [
        438,
        631
      ],
      "keyQuote": "Headers were added to signals and queries in https://github.com/temporalio/temporal/pull/2149.",
      "number": 940,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:54:16.276Z"
    },
    {
      "summary": "Activity implementations using inheritance chains cannot be registered because the SDK fails to recognize inherited interface implementations. This prevents using proxy-based patterns like those generated by Quarkus dependency injection.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "registerActivitiesImplementations"
      ],
      "components": [
        "worker",
        "activity-registration",
        "interface-validation"
      ],
      "concepts": [
        "inheritance",
        "proxy-pattern",
        "interface-detection",
        "bean-injection",
        "class-hierarchy"
      ],
      "severity": "medium",
      "userImpact": "Users cannot register activity implementations that use inheritance or proxy patterns, blocking integration with frameworks like Quarkus that automatically generate proxies.",
      "rootCause": "The activity registration logic does not traverse the class hierarchy to find interface implementations, only checking the immediate class declaration.",
      "proposedFix": null,
      "workaround": "Explicitly implement the @ActivityInterface in the final class rather than relying on inheritance.",
      "resolution": "fixed",
      "resolutionDetails": "The SDK was updated to traverse the class hierarchy and recognize inherited interface implementations.",
      "related": [],
      "keyQuote": "It seems that that SDK expects `BlockListenerActivitiesImpl` to explicitly say `implements BlockListenerActivities`.",
      "number": 929,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:54:16.267Z"
    },
    {
      "summary": "TestActivityExtension throws RejectedExecutionException when running multiple test methods in a single test class because the thread pool executor is terminated after the first test completes.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestActivityExtension",
        "TestActivityEnvironmentInternal",
        "ThreadPoolExecutor"
      ],
      "concepts": [
        "lifecycle",
        "test-isolation",
        "thread-pool",
        "resource-cleanup",
        "junit5-extension"
      ],
      "severity": "high",
      "userImpact": "Users cannot write multiple test methods in a single test class using TestActivityExtension, causing test failures on the second test method.",
      "rootCause": "The thread pool executor is terminated after the first test method completes, preventing reuse across multiple test methods in the same class.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Trivial local mistake in the original implementation that was corrected without architectural changes.",
      "related": [
        1133
      ],
      "keyQuote": "Task rejected from java.util.concurrent.ThreadPoolExecutor@377fb945[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]",
      "number": 928,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:54:16.255Z"
    },
    {
      "summary": "SimpleSslContextBuilder only supports PKCS8 certificates while all Temporal documentation and examples use PKCS12, forcing users to convert certificates. Need to add PKCS12 support and improve javadocs with direct usage examples.",
      "category": "feature",
      "subcategory": "ssl-configuration",
      "apis": [
        "SimpleSslContextBuilder"
      ],
      "components": [
        "ssl-context-builder",
        "certificate-handling",
        "security-configuration"
      ],
      "concepts": [
        "ssl-tls",
        "certificate-formats",
        "pkcs8",
        "pkcs12",
        "documentation-consistency",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users must manually convert PKCS12 certificates to PKCS8 format to use the Java SDK, adding unnecessary complexity to deployment.",
      "rootCause": "SimpleSslContextBuilder implementation only recognizes PKCS8 format while Temporal ecosystem standardizes on PKCS12.",
      "proposedFix": "Add code to SimpleSslContextBuilder supporting PKCS12 certificates and improve javadocs with direct usage examples.",
      "workaround": "Convert PKCS12 certificates to PKCS8 format before using with SimpleSslContextBuilder.",
      "resolution": "fixed",
      "resolutionDetails": "PKCS12 support was added to SimpleSslContextBuilder to match Temporal documentation standards.",
      "related": [],
      "keyQuote": "SimpleSslContextBuilder uses and exposes working with PKCS8 only. Meanwhile, all Temporal server docs and examples are working with PKCS12 only.",
      "number": 925,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:53:36.877Z"
    },
    {
      "summary": "OpenTracing context propagation is incomplete across child workflows, async lambda invocations, continueAsNew calls, and signal methods. This checklist tracks missing instrumentation for distributed tracing in various Java SDK scenarios.",
      "category": "feature",
      "subcategory": "opentracing",
      "apis": [
        "Async",
        "continueAsNew"
      ],
      "components": [
        "opentracing",
        "child-workflows",
        "async-invocation",
        "signal-methods"
      ],
      "concepts": [
        "distributed-tracing",
        "context-propagation",
        "headers",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably trace distributed workflows and async operations, making it difficult to debug and monitor complex workflow executions.",
      "rootCause": null,
      "proposedFix": "Implement proper header wiring and OpenTracing instrumentation for child workflows, async lambda invocations, continueAsNew operations, and signal methods.",
      "workaround": "Use stub method references instead of lambda invocations for activities to maintain tracing context.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing OpenTracing context propagation across the identified scenarios.",
      "related": [
        537,
        844,
        1306
      ],
      "keyQuote": "Child workflows as reported in comments in #537, Async invocation of a function or procedure as lambda, continueAsNew needs a proper wiring of headers and OT implementation",
      "number": 922,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:53:37.003Z"
    },
    {
      "summary": "Request to upgrade gRPC dependency from 1.41.0 to 1.42.1. User encountered a strict version constraint conflict when trying to use gRPC 1.42.1 in their own code while the SDK required 1.41.0.",
      "category": "feature",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "grpc-stub",
        "dependency-management",
        "gradle-build"
      ],
      "concepts": [
        "dependency-versioning",
        "version-constraints",
        "gradle-platforms",
        "transitive-dependencies",
        "compatibility"
      ],
      "severity": "low",
      "userImpact": "Users cannot upgrade to gRPC 1.42.1 in their applications due to the SDK's strict version constraint on 1.41.0.",
      "rootCause": "Strict version constraint on gRPC 1.41.0 in SDK prevents users from upgrading to newer versions of gRPC in their own dependencies.",
      "proposedFix": null,
      "workaround": "User indicated they would try upgrading when SDK version 1.6 is released.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by upgrading to SDK 1.6 which updated gRPC dependencies.",
      "related": [],
      "keyQuote": "We're trying to upgrade our gRPC usages to 1.42.1 (for our own clients/servers), but are running into a Temporal dep constraint conflict",
      "number": 918,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:53:37.311Z"
    },
    {
      "summary": "The `Workflow#signalWithStart` method interface is overcomplicated and difficult to use. The issue requests improvements to the class structure and addition of more conventional builders and factory methods to simplify the API and improve usability.",
      "category": "feature",
      "subcategory": "signalWithStart-API",
      "apis": [
        "signalWithStart",
        "WorkflowStub",
        "WorkflowClient"
      ],
      "components": [
        "workflow-client",
        "workflow-stub",
        "signal-handling"
      ],
      "concepts": [
        "API usability",
        "builder pattern",
        "factory methods",
        "strongly-typed API",
        "workflow signals"
      ],
      "severity": "medium",
      "userImpact": "Users find the signalWithStart method difficult to use and require checking samples to understand how to properly call it.",
      "rootCause": "The current interface design lacks conventional builders and factory methods, making it unintuitive compared to similar APIs like updateWithStart.",
      "proposedFix": "Adopt a pattern similar to the recently shipped updateWithStart API for better usability and consistency. Add untyped option for WorkflowClient.signalWithStart that takes signalName, signalData, and inputData.",
      "workaround": "Users can convert typed stubs to untyped stubs using `WorkflowStub.fromTyped()` to access the untyped signalWithStart method.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed as a duplicate of issue #2213, which likely addresses the same signalWithStart usability improvements.",
      "related": [
        2213
      ],
      "keyQuote": "Workflow#signalWithStart method interface is overcomplicated and hard to use without checking with samples first.",
      "number": 915,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:52:58.040Z"
    },
    {
      "summary": "Worker factory shutdown doesn't properly destroy in-flight cached workflows, causing resource leaks and blocking clean JVM shutdown since workflow threads are not daemon processes.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [],
      "components": [
        "worker-factory",
        "workflow-cache",
        "thread-pool",
        "shutdown"
      ],
      "concepts": [
        "resource-cleanup",
        "lifecycle-management",
        "thread-safety",
        "memory-leak",
        "shutdown-semantics",
        "worker-termination"
      ],
      "severity": "high",
      "userImpact": "Users experience resource leaks when recreating worker factories and JVM shutdown is blocked by non-daemon workflow threads.",
      "rootCause": "In-flight cached workflows are not being destroyed during worker factory shutdown, leaving workflow threads alive.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker shutdown process was updated to properly clean up in-flight cached workflows and ensure daemon thread handling.",
      "related": [],
      "keyQuote": "If there are non-completed workflows in the workflow cache and thread pool, these workflows are not getting destroyed.",
      "number": 914,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:52:56.802Z"
    },
    {
      "summary": "NullPointerException occurs when using startWithSignal with OpenTracing configured. The runId is null when OpenTracing tries to build span tags, causing ImmutableMap to fail during span creation.",
      "category": "bug",
      "subcategory": "opentracing-integration",
      "apis": [
        "startWithSignal",
        "WorkflowStub"
      ],
      "components": [
        "opentracing",
        "workflow-client-interceptor",
        "span-factory"
      ],
      "concepts": [
        "distributed-tracing",
        "opentracing-integration",
        "workflow-execution",
        "null-pointer",
        "exception-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot use startWithSignal when OpenTracing is configured, preventing signal-based workflow initialization with tracing enabled.",
      "rootCause": "ActionTypeAndNameSpanBuilderProvider.getSpanTags() attempts to create an ImmutableMap with a null runId value, which ImmutableMap.of() does not allow.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the OpenTracing span builder to handle null runId values properly.",
      "related": [],
      "keyQuote": "java.lang.NullPointerException: null value in entry: runId=null at io.temporal.opentracing.internal.ActionTypeAndNameSpanBuilderProvider.getSpanTags",
      "number": 912,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:52:57.319Z"
    },
    {
      "summary": "Make heartbeat throttling interval configurable across Java SDK with explicit defaults. Currently Java has implicit maximum (30s) and default (0s), causing confusion. Need to add WorkerOptions for maxHeartbeatThrottleInterval (default 60s) and defaultHeartbeatThrottleInterval (default 30s) for consistency with other SDKs.",
      "category": "feature",
      "subcategory": "activity-heartbeat",
      "apis": [
        "WorkerOption"
      ],
      "components": [
        "worker",
        "activity-heartbeat",
        "configuration"
      ],
      "concepts": [
        "heartbeat",
        "throttling",
        "timeout",
        "configuration",
        "cancellation",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users currently experience confusing and inconsistent heartbeat throttling behavior across SDKs, with no way to configure it explicitly.",
      "rootCause": "Implicit default values (0s default, 30s max) and lack of configurable options make behavior unclear and inconsistent between SDKs.",
      "proposedFix": "Add maxHeartbeatThrottleInterval and defaultHeartbeatThrottleInterval WorkerOptions with defaults of 60s and 30s respectively, using formula: throttleInterval = min(heartbeat_timeout * 0.8 if provided else defaultHeartbeatThrottleInterval, maxHeartbeatThrottleInterval)",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to add configurable heartbeat throttling options with explicit defaults matching the proposed specification.",
      "related": [
        656
      ],
      "keyQuote": "Make the behavior explicit and configurable. Java currently has an implicit maximum (30s) and default (0). Not heartbeating means no cancellations, need a default value.",
      "number": 906,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:52:18.146Z"
    },
    {
      "summary": "Exception in one async workflow function causes non-deterministic execution when multiple procedures run in parallel. The exception stays in a Promise until checked, allowing other procedures to advance and record incompatible history, causing replay failures even after the bug is fixed.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Async.procedure",
        "Promise.get",
        "Promise.allOf",
        "Workflow.newActivityStub"
      ],
      "components": [
        "workflow-execution",
        "promise-handling",
        "history-replay",
        "activity-scheduling"
      ],
      "concepts": [
        "non-determinism",
        "eager-evaluation",
        "exception-handling",
        "history-mismatch",
        "workflow-determinism",
        "parallel-execution"
      ],
      "severity": "high",
      "userImpact": "Users cannot fix bugs in async workflow procedures without resetting history, as exceptions in parallel tasks create incompatible execution histories that fail replay validation.",
      "rootCause": "Eager evaluation of async procedures allows exceptions to be deferred while other procedures continue executing, recording incompatible activity scheduling sequences in the history that don't match the fixed code.",
      "proposedFix": "Promote all exceptions in async functions to errors to immediately fail the workflow task before incompatible history is produced, or enforce strict ordering guarantees for parallel promise execution.",
      "workaround": "Use Promise.allOf to wait on all promises simultaneously rather than sequentially, ensuring exceptions are caught before other procedures advance. Must be implemented before incorrect history is produced.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Exception stays in Promise until checked, allowing first procedure to advance and schedule incompatible activities before failure is detected.",
      "number": 902,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:52:18.355Z"
    },
    {
      "summary": "Broken workflow code that creates invalid commands causes workers to continuously hammer the server with faulty commands or task failures. The issue lacks rate limiting or backoff, allowing workers to monopolize all available task processors in a retry cycle, effectively DoS-ing the server.",
      "category": "bug",
      "subcategory": "workflow-task-execution",
      "apis": [],
      "components": [
        "worker",
        "workflow-task-executor",
        "command-validation"
      ],
      "concepts": [
        "backoff",
        "rate-limiting",
        "retry",
        "resource-exhaustion",
        "server-stability",
        "task-processor"
      ],
      "severity": "high",
      "userImpact": "Users with broken workflow code can inadvertently cause a denial-of-service on the Temporal server by exhausting worker task processors without rate limiting.",
      "rootCause": "Invalid commands generated by broken workflow code trigger continuous task failure and recreation cycles. The lack of backoff or rate limiting on the SDK side allows workers to utilize all available task processors hammering the server.",
      "proposedFix": "Implement exponential backoff for workflow tasks on the server side (temporal/temporal#2238). On the SDK side, add proactive validation of options that could cause invalid commands and rely on Workflow Task Run Timeout as a basic backoff mechanism.",
      "workaround": "Use Workflow Task Run Timeout as a basic SDK-side backoff mechanism. Implement basic sanity checks on SDK options rather than duplicating full server-side validation logic.",
      "resolution": "fixed",
      "resolutionDetails": "Addressed through server-side exponential backoff for workflow tasks and SDK-side proactive validation of options that could cause invalid commands.",
      "related": [
        898,
        900,
        2238
      ],
      "keyQuote": "all workers end up utilizing all of their allowed by maxConcurrentWorkflowTaskExecutionSize (200 by default) parallel tasks processors to just hammer the server",
      "number": 901,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:52:18.246Z"
    },
    {
      "summary": "Worker silently fails when reporting workflow task completion to the server, without logging the error. This causes issues to go unnoticed, particularly when invalid commands are sent, and also fails to invalidate the workflow thread cache as it should.",
      "category": "bug",
      "subcategory": "worker-task-handling",
      "apis": [],
      "components": [
        "worker",
        "task-handler",
        "workflow-task-processing"
      ],
      "concepts": [
        "logging",
        "error-handling",
        "task-completion",
        "server-communication",
        "exception-handling",
        "cache-invalidation"
      ],
      "severity": "high",
      "userImpact": "Users cannot see server-side errors during workflow task result reporting, making debugging difficult and leaving stale workflow thread cache entries.",
      "rootCause": "Exceptions in WorkflowWorker.TaskHandlerImpl#sendReply are not logged and occur outside the WorkflowTaskHandler scope, preventing proper exception handling and cache invalidation.",
      "proposedFix": "Logging should be added when reporting workflow task results fails, and the exception handling should be refactored to occur within the proper scope to trigger workflow thread destruction and cache invalidation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating a fix was applied to add logging for failures during workflow task result reporting.",
      "related": [],
      "keyQuote": "If a worker logs a problem during workflow task processing, the worker should log a problem during reporting the workflow task processing result to the server.",
      "number": 900,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:51:37.771Z"
    },
    {
      "summary": "RetryOptions builder allows invalid configurations where maximumInterval is less than minimumInterval, which passes client-side validation but fails on the server with a BadScheduleActivityAttributes error.",
      "category": "bug",
      "subcategory": "retry-policy",
      "apis": [
        "RetryOptions"
      ],
      "components": [
        "retry-options",
        "validation",
        "activity-scheduling"
      ],
      "concepts": [
        "validation",
        "retry-policy",
        "configuration",
        "interval",
        "error-handling",
        "server-side-validation"
      ],
      "severity": "high",
      "userImpact": "Users can create invalid RetryOptions that appear valid on the client but fail during workflow execution on the server.",
      "rootCause": "RetryOptions#validateAndBuildWithDefaults does not validate that maximumInterval >= minimumInterval before allowing the configuration to be built.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "BadScheduleActivityAttributes: MaximumInterval cannot be less than InitialInterval on retry policy.",
      "number": 898,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:51:35.389Z"
    },
    {
      "summary": "Workflow code should be able to catch and ignore CancellationFailure to finish successfully, but currently the workflow is forced to complete with a canceled event. This is a design limitation where cancellation of a scope prevents normal completion even if the exception is handled.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [],
      "components": [
        "workflow-execution",
        "cancellation-handler",
        "scope-management"
      ],
      "concepts": [
        "cancellation",
        "exception-handling",
        "scope",
        "workflow-completion",
        "error-propagation"
      ],
      "severity": "medium",
      "userImpact": "Workflows cannot gracefully handle cancellation requests by catching and suppressing CancellationFailure exceptions, limiting error handling flexibility.",
      "rootCause": "Once a scope is requested to be canceled, it is considered canceled and new commands must be scheduled in a detached scope, preventing the workflow from completing successfully even if the cancellation exception is caught and handled.",
      "proposedFix": null,
      "workaround": "Scheduled commands that should complete must be executed in a detached scope after catching CancellationFailure.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Once the scope is requested to be canceled, it's considered canceled new commands have to be scheduled in the detached scope.",
      "number": 896,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:51:36.069Z"
    },
    {
      "summary": "Implement gRPC connection resolvers with round-robin load balancing for frontend connections in Java SDK. This enhancement addresses the need to support dynamic load balancing similar to the Go SDK implementation, replacing the current workaround of forcefully re-establishing connections.",
      "category": "feature",
      "subcategory": "grpc-load-balancing",
      "apis": [],
      "components": [
        "grpc-connection",
        "client-options",
        "connection-resolver"
      ],
      "concepts": [
        "load-balancing",
        "round-robin",
        "frontend-discovery",
        "grpc-resolver",
        "connection-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users will have better connection load distribution across multiple frontends without needing hacky reconnection frequency settings.",
      "rootCause": "Java SDK lacks proper gRPC load balancing resolvers that are available in Go SDK, forcing users to rely on connection re-establishment frequency as a workaround.",
      "proposedFix": "Implement gRPC resolvers following the gRPC load balancing documentation and matching Go SDK's ClientOptions approach, supporting round-robin between known frontends.",
      "workaround": "Use WorkflowServiceStubsOptions#grpcReconnectFrequency to forcefully reestablish connections for load balancing (not recommended).",
      "resolution": "fixed",
      "resolutionDetails": "gRPC load balancing and connection resolvers were implemented to support round-robin frontend resolution.",
      "related": [
        577,
        815
      ],
      "keyQuote": "We need to support resolvers, including the one that round-robin between known frontends. This will let us remove hacks like WorkflowServiceStubsOptions#grpcReconnectFrequency",
      "number": 888,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:50:57.122Z"
    },
    {
      "summary": "The Java SDK is missing the WorkflowInfo.getCronSchedule accessor that exists in the Go SDK. This feature request asks for the same accessor to be exposed in Java for consistency across SDKs.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "java-sdk"
      ],
      "concepts": [
        "cron-schedule",
        "workflow-metadata",
        "cross-sdk-consistency"
      ],
      "severity": "low",
      "userImpact": "Java developers cannot access cron schedule information for workflows, unlike Go SDK users, limiting visibility into scheduled workflow execution details.",
      "rootCause": null,
      "proposedFix": "Add getCronSchedule accessor method to the Java WorkflowInfo class",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The accessor was added to the Java SDK's WorkflowInfo class",
      "related": [],
      "keyQuote": "Go SDK has `WorkflowInfo.CronSchedule` but Java does not",
      "number": 887,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:50:55.154Z"
    },
    {
      "summary": "The testActivityScheduleToCloseTimeout test was flaky when running with a dockerized Temporal service. The issue has been resolved and is no longer occurring.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "activity-timeout",
        "docker-service"
      ],
      "concepts": [
        "timeout",
        "flakiness",
        "docker",
        "schedule-to-close",
        "test-reliability"
      ],
      "severity": "medium",
      "userImpact": "Tests would intermittently fail when using dockerized Temporal service, making CI/CD pipelines unreliable.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue no longer occurs, as indicated by the author's comment 'not anymore'.",
      "related": [],
      "keyQuote": "not anymore",
      "number": 886,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:50:54.904Z"
    },
    {
      "summary": "Workers don't reset the sticky queue when workflow executions are evicted from the cache due to hitting thread limits. This creates unnecessary pressure on already overloaded workers and increases delays.",
      "category": "bug",
      "subcategory": "worker-sticky-queue",
      "apis": [],
      "components": [
        "worker",
        "sticky-queue",
        "cache",
        "workflow-executor"
      ],
      "concepts": [
        "load-balancing",
        "worker-saturation",
        "cache-eviction",
        "task-routing",
        "performance-degradation"
      ],
      "severity": "medium",
      "userImpact": "Users experience increased latency and unnecessary worker overload when workflow executions are evicted from the sticky queue cache.",
      "rootCause": "Sticky queue is not reset when workflows are evicted from cache due to thread limits, only on exceptions. This causes subsequent tasks to route to already overloaded workers.",
      "proposedFix": "Reset the sticky queue when a workflow execution is evicted from the cache, similar to how it's currently reset on exceptions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        236,
        2811
      ],
      "keyQuote": "This creates pressure on already overloaded workers and can lead to incremented delays.",
      "number": 883,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:50:16.684Z"
    },
    {
      "summary": "Feature request to allow registering new search attributes directly through the Java SDK instead of requiring manual registration via tctl commands on Elasticsearch.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [],
      "components": [
        "client-sdk",
        "workflow-client",
        "server-communication"
      ],
      "concepts": [
        "search-attributes",
        "elasticsearch",
        "metadata-management",
        "workflow-configuration",
        "sdk-capabilities"
      ],
      "severity": "medium",
      "userImpact": "Users currently must use tctl commands to register search attributes before using them in workflows, requiring external tooling and administrative access.",
      "rootCause": null,
      "proposedFix": "Add SDK functionality to register new search attributes programmatically through gRPC calls to the Temporal server.",
      "workaround": "Use tctl add-search-attributes command to manually register attributes on Elasticsearch before workflow creation.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Allow to register new search attributes through the SDK",
      "number": 882,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:50:16.180Z"
    },
    {
      "summary": "Thread pool exhaustion in the legacy query path causes thread leaks when worker or state machine exceptions occur, particularly with RejectedExecutionException when the thread pool reaches capacity.",
      "category": "bug",
      "subcategory": "workflow-query-execution",
      "apis": [],
      "components": [
        "workflow-worker",
        "state-machine",
        "thread-pool-executor",
        "query-handler"
      ],
      "concepts": [
        "thread-leak",
        "resource-cleanup",
        "exception-handling",
        "thread-pool-exhaustion",
        "query-execution",
        "state-machine-exception"
      ],
      "severity": "high",
      "userImpact": "Users experience thread pool exhaustion and resource leaks when query operations fail, potentially causing worker instability and cascading failures.",
      "rootCause": "The legacy query path does not properly release threads when exceptions occur during state machine processing, particularly when RejectedExecutionException is thrown due to thread pool saturation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Task rejected from java.util.concurrent.ThreadPoolExecutor@1faac87d[Running, pool size = 600, active threads = 600, queued tasks = 0, completed tasks = 14007]",
      "number": 880,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:50:16.854Z"
    },
    {
      "summary": "Temporal Java SDK currently uses hardcoded magic numbers (5 activity pollers, 2 workflow pollers) that users must manually adjust. This feature request proposes implementing automatic autoscaling of pollers based on the actual load profile of executors and pollers.",
      "category": "feature",
      "subcategory": "poller-autoscaling",
      "apis": [],
      "components": [
        "poller",
        "worker",
        "executor"
      ],
      "concepts": [
        "autoscaling",
        "load-balancing",
        "concurrency",
        "configuration",
        "performance-tuning",
        "resource-management"
      ],
      "severity": "medium",
      "userImpact": "Users must currently guess and manually configure poller counts, leading to suboptimal performance; autoscaling would eliminate this configuration burden.",
      "rootCause": null,
      "proposedFix": "Implement dynamic autoscaling mechanism that adapts poller count based on executor and poller load profiles.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented with autoscaling logic for pollers to adapt based on load.",
      "related": [],
      "keyQuote": "SDK can adapt them accordingly to the load profile of executors and pollers.",
      "number": 878,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:49:34.029Z"
    },
    {
      "summary": "Deadlock occurs during activity state machine cancelation when a cancellation scope cancels an async activity and forces a workflow end. The activity state machine triggers an event loop on a workflow thread that has already completed, causing a potential deadlock exception.",
      "category": "bug",
      "subcategory": "activity-cancelation",
      "apis": [
        "Async.procedure",
        "CancellationScope.cancel",
        "Workflow.sleep"
      ],
      "components": [
        "activity-state-machine",
        "cancelation-scope",
        "event-loop",
        "workflow-thread",
        "deterministic-runner"
      ],
      "concepts": [
        "deadlock",
        "concurrency",
        "state-machine-transition",
        "event-loop-re-entrancy",
        "thread-synchronization",
        "cancelation-semantics"
      ],
      "severity": "high",
      "userImpact": "Workflows that cancel async activities during error handling or cleanup will deadlock and fail to execute properly.",
      "rootCause": "Activity state machine takes SCHEDULE_COMMAND_CREATED  CANCELED: CANCEL transition route, triggering an event loop callback on a workflow thread that has already completed execution, causing re-entrancy deadlock in the thread synchronization logic.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Activity state machine cancelation logic was fixed to prevent triggering event loops on workflow threads that have already completed or are in a blocked state.",
      "related": [],
      "keyQuote": "Potential deadlock detected: workflow thread didn't yield control for over a second",
      "number": 871,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:49:34.975Z"
    },
    {
      "summary": "Add an init method to workflows that executes before any signal, query, or workflow method is processed, with access to workflow input parameters. This is essential for Dynamic Workflows where signals can arrive before workflow code execution, and for handling initialization that depends on workflow parameters.",
      "category": "feature",
      "subcategory": "workflow-initialization",
      "apis": [
        "WorkflowInit"
      ],
      "components": [
        "workflow-runtime",
        "dynamic-workflows",
        "signal-handler",
        "listener-registration"
      ],
      "concepts": [
        "initialization",
        "signal-handling",
        "workflow-lifecycle",
        "dynamic-workflows",
        "listener-registration",
        "state-initialization"
      ],
      "severity": "high",
      "userImpact": "Users can now initialize state and register listeners before signals arrive, eliminating the need for workarounds with deferred signal processing.",
      "rootCause": "Signals can arrive before workflow code execution (especially with signalToStart), but initialization code and listener registration currently only run during workflow method execution.",
      "proposedFix": "Add @WorkflowInit annotation that marks a method (or constructor) to execute before signal/query/workflow methods, accepting the same parameters as the primary workflow method.",
      "workaround": "Users currently save signals in fields and process them later in delayed manner within workflow code, or perform initialization in constructors (but this lacks access to workflow parameters).",
      "resolution": "fixed",
      "resolutionDetails": "Implemented @WorkflowInit annotation for workflow initialization before signal/query/workflow method processing, with constructor support.",
      "related": [
        864,
        2166,
        400
      ],
      "keyQuote": "With signalToStart, signal is getting delivered before the execution of the workflow method...this makes init() method a necessity for Dynamic Workflows, not a convenience.",
      "number": 865,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:49:36.181Z"
    },
    {
      "summary": "Documentation needs clarification that signal methods can be called before the workflow method when a workflow is reset to the first workflow task. Signal methods, query code, and workflow code should not assume ordering of execution.",
      "category": "docs",
      "subcategory": "signal-methods",
      "apis": [
        "SignalMethod"
      ],
      "components": [
        "signal-handler",
        "workflow-reset",
        "documentation"
      ],
      "concepts": [
        "workflow-reset",
        "signal-processing",
        "execution-ordering",
        "query-processing",
        "workflow-task"
      ],
      "severity": "medium",
      "userImpact": "Developers may write signal handling code that assumes signals are processed only after the workflow method is initially triggered, leading to unexpected behavior during workflow resets.",
      "rootCause": "When a workflow is reset to the first workflow task, signals from the original run are prepended before the first WFT of the new run, causing signal methods to execute before workflow method execution.",
      "proposedFix": "Add clarifications to @SignalMethod javadoc and Signal documentation explaining that signal methods, query code, and workflow code should not assume ordering. Also apply similar clarifications to query documentation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to clarify signal method execution ordering and that developers should not assume signals are processed only after initial workflow method trigger.",
      "related": [],
      "keyQuote": "signal methods to be called before the workflow method...Application developers should not assume that signals will be processed only after an initial trigger",
      "number": 864,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:48:53.500Z"
    },
    {
      "summary": "After long periods of inactivity (~40 min), WorkflowServiceStubs encounters an internal gRPC error ('INTERNAL: Panic! This is a bug!') caused by a race condition between gRPC's idle timer and Temporal's connection reset mechanism, rendering the channel unusable.",
      "category": "bug",
      "subcategory": "grpc-channel",
      "apis": [
        "WorkflowServiceStubs"
      ],
      "components": [
        "grpc-channel",
        "connection-management",
        "idle-timer"
      ],
      "concepts": [
        "race-condition",
        "connection-pooling",
        "channel-state",
        "idle-timeout",
        "load-balancing",
        "reconnection"
      ],
      "severity": "high",
      "userImpact": "Applications experience workflow execution failures after periods of inactivity, with the gRPC channel becoming permanently unusable until restarted.",
      "rootCause": "Race condition between gRPC netty channel's IdleModeTimer (30 min default) and Temporal's setGrpcReconnectFrequency() mechanism both calling enterIdle() on the channel, causing nameResolver state inconsistency.",
      "proposedFix": "Manual calling of enterIdle() should be replaced with automatic gRPC load balancing mechanisms or coordinated idle management.",
      "workaround": "A temporary workaround was implemented in the Temporal SDK pending upstream gRPC fix in grpc-java.",
      "resolution": "fixed",
      "resolutionDetails": "Workaround implemented in Temporal SDK while waiting for grpc-java fix (grpc/grpc-java#8714). Long-term solution planned as part of issue #888.",
      "related": [
        888
      ],
      "keyQuote": "After long period of inactivity (~40min) at some point of time we see an internal exception when trying to start a new workflow",
      "number": 863,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:48:53.941Z"
    },
    {
      "summary": "Tracing tags are inconsistent across Temporal SDKs. This feature request aims to standardize tracing tags to provide a consistent observability experience across all SDK implementations (Java, Go, TypeScript, and others).",
      "category": "feature",
      "subcategory": "tracing",
      "apis": [],
      "components": [
        "tracing",
        "observability",
        "sdk-core"
      ],
      "concepts": [
        "consistency",
        "standardization",
        "observability",
        "tracing",
        "tagging",
        "cross-sdk"
      ],
      "severity": "medium",
      "userImpact": "Users experience inconsistent tracing tag formats across different SDK implementations, making it difficult to build unified observability solutions.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        619,
        360
      ],
      "keyQuote": "Make tracing tags consistent across SDKs.",
      "number": 862,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:48:51.118Z"
    },
    {
      "summary": "When passing a blob larger than the server limit as an activity input, users receive a non-descriptive gRPC error about a closed stream instead of a clear server error message and clean activity failure.",
      "category": "bug",
      "subcategory": "activity-input-validation",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "grpc-client",
        "error-handling"
      ],
      "concepts": [
        "blob-size-limit",
        "input-validation",
        "error-messaging",
        "grpc-channel",
        "server-limits"
      ],
      "severity": "high",
      "userImpact": "Users passing large files (PDFs, images) as activity inputs receive cryptic gRPC errors instead of actionable error messages about size limits.",
      "rootCause": "The gRPC channel is broken when the server rejects oversized input, and the error is not properly translated to a user-friendly activity failure.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Received data on closed stream",
      "number": 860,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:48:10.309Z"
    },
    {
      "summary": "The SignalExternalWorkflowExecutionCommandAttributes.ChildWorkflowOnly flag is not exposed in the Java SDK API or signal interceptors, unlike the Go and TypeScript SDKs. This feature request seeks to expose this flag for parity across SDKs and support external workflow signaling to child workflows only.",
      "category": "feature",
      "subcategory": "signal-interceptor",
      "apis": [
        "SignalExternalWorkflowExecutionCommandAttributes"
      ],
      "components": [
        "signal-interceptor",
        "external-workflow-signaling",
        "api-exposure"
      ],
      "concepts": [
        "child-workflow-targeting",
        "signal-filtering",
        "sdk-parity",
        "interceptor-api",
        "external-signals"
      ],
      "severity": "medium",
      "userImpact": "Users cannot selectively signal only child workflows due to missing API exposure, requiring workarounds and reducing feature parity with other SDKs.",
      "rootCause": null,
      "proposedFix": "Expose SignalExternalWorkflowExecutionCommandAttributes.ChildWorkflowOnly in the Java SDK API and signal interceptor parameters, matching Go and TypeScript SDK implementations.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SignalExternalWorkflowExecutionCommandAttributes.ChildWorkflowOnly is not exposed as a part of any JavaSDK API. It's also not in the parameters of signal interceptors.",
      "number": 857,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:48:11.201Z"
    },
    {
      "summary": "WorkflowClient.execute() doesn't properly synchronize with workflowStub.getResult(), causing tests to hang. The issue occurs when calling getResult() immediately after execute() without intermediate operations like sleep() or waiting on the returned future.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowClient.execute",
        "WorkflowStub.getResult",
        "WorkflowStub.fromTyped"
      ],
      "components": [
        "workflow-client",
        "workflow-stub",
        "async-execution"
      ],
      "concepts": [
        "synchronization",
        "race-condition",
        "completable-future",
        "blocking",
        "workflow-result"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably retrieve workflow results using the standard execute() + getResult() pattern, forcing workarounds like sleep() or explicit future waiting.",
      "rootCause": "Missing synchronization between WorkflowClient.execute() and workflowStub.getResult() results in a race condition where getResult() may be called before the workflow execution is properly registered.",
      "proposedFix": null,
      "workaround": "Add Thread.sleep() between execute() and getResult(), or wait on the CompletableFuture returned by execute() before calling getResult().",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "This test hangs (times out), but uncommenting of either sleep or waiting for a completable future makes it pass",
      "number": 856,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:48:11.490Z"
    },
    {
      "summary": "Users need granular control over QueryRejectCondition settings. Currently, QueryRejectCondition can only be specified globally at the WorkflowClientOptions level, affecting all queries from that client. This request seeks the ability to configure rejection conditions per query or per workflow stub.",
      "category": "feature",
      "subcategory": "query-configuration",
      "apis": [
        "WorkflowClientOptions"
      ],
      "components": [
        "client",
        "query-handler",
        "workflow-stub"
      ],
      "concepts": [
        "query-rejection",
        "configuration",
        "granularity",
        "conditional-logic",
        "client-options"
      ],
      "severity": "medium",
      "userImpact": "Users cannot apply different rejection policies to different workflows or queries, limiting their ability to handle various workflow states appropriately.",
      "rootCause": null,
      "proposedFix": "Support specifying QueryRejectCondition at the query level or workflow stub level in addition to the global WorkflowClientOptions setting.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We should be able to specify QueryRejectCondition for each query or at least for each specific workflow stub to have a granular enough control.",
      "number": 851,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:47:29.093Z"
    },
    {
      "summary": "Document and normalize gRPC retry logic, deadlines, and parameters across all SDKs. Each SDK currently has different implementations with varying default values, timeout handling, jitter, and retry behaviors that need to be unified.",
      "category": "docs",
      "subcategory": "grpc-retry-policy",
      "apis": [],
      "components": [
        "grpc-client",
        "retry-logic",
        "deadline-handling"
      ],
      "concepts": [
        "retry",
        "deadline",
        "timeout",
        "jitter",
        "grpc",
        "standardization",
        "cross-sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Inconsistent retry behavior across SDKs makes it difficult for users to predict and configure gRPC communication reliability.",
      "rootCause": "Each SDK independently implemented gRPC retry and deadline logic without unified specification, leading to divergent parameters and behaviors.",
      "proposedFix": "Create unified specification with documented default parameter values and normalize retry behavior across all SDKs.",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed in favor of temporalio/features#27 as a cross-SDK issue requiring centralized solution.",
      "related": [
        27
      ],
      "keyQuote": "We should write a unified specification including default parameter values and normalize the retrying behavior across SDKs.",
      "number": 850,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:47:30.713Z"
    },
    {
      "summary": "Epic tracking improvements to reduce verbosity and misleading error logs in Temporal SDK, and provide users with flexibility to configure logging of errors and exceptions from their code execution.",
      "category": "feature",
      "subcategory": "logging-configuration",
      "apis": [],
      "components": [
        "logging-system",
        "error-handling",
        "configuration"
      ],
      "concepts": [
        "verbosity",
        "log-levels",
        "error-reporting",
        "user-code-execution",
        "exception-handling",
        "logging-framework"
      ],
      "severity": "medium",
      "userImpact": "Users experience excessive logging verbosity and misleading ERROR level messages for non-critical issues, making it difficult to identify actual problems.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed because GitHub issues are no longer used as epics in the project.",
      "related": [
        704,
        631,
        618
      ],
      "keyQuote": "Decrease verbosity and levels of logs produced by Temporal SDK. Provide flexibility for users to configure logging of errors and exceptions.",
      "number": 849,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:47:29.296Z"
    },
    {
      "summary": "A cron workflow test fails with an assertion error where the expected count is 4 but the actual count is 3, indicating an issue with cron scheduling or execution counting.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "workflow-engine",
        "cron-scheduling",
        "test-framework"
      ],
      "concepts": [
        "cron-schedule",
        "workflow-execution",
        "test-assertion",
        "timing"
      ],
      "severity": "medium",
      "userImpact": "Cron workflow tests fail unpredictably, making it difficult to verify cron scheduling behavior is working correctly.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "java.lang.AssertionError: expected:<4> but was:<3>",
      "number": 847,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:46:49.301Z"
    },
    {
      "summary": "OpenTracing span becomes disconnected when continueAsNew is used. The continueAsNew interception and header handling doesn't correctly propagate tracing context in the Java SDK.",
      "category": "bug",
      "subcategory": "opentracing-integration",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "opentracing",
        "interceptor",
        "workflow-execution"
      ],
      "concepts": [
        "distributed-tracing",
        "span-continuity",
        "context-propagation",
        "header-handling",
        "workflow-continuation"
      ],
      "severity": "high",
      "userImpact": "Users relying on OpenTracing for observability lose trace continuity when using continueAsNew, breaking distributed tracing visibility.",
      "rootCause": "continueAsNew interception and header implementation in Java SDK does not correctly maintain OpenTracing span context across workflow continuation boundaries.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the continueAsNew interception to properly handle OpenTracing span context propagation and headers.",
      "related": [],
      "keyQuote": "continueAsNew leads to a disconnected OpenTracing span",
      "number": 844,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:46:49.752Z"
    },
    {
      "summary": "When listing open workflow executions in test environment using TestWorkflowRule, the execution status is always WORKFLOW_EXECUTION_STATUS_UNSPECIFIED instead of the expected WORKFLOW_EXECUTION_STATUS_RUNNING.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "listOpenWorkflowExecutions",
        "WorkflowClient",
        "TestWorkflowRule"
      ],
      "components": [
        "test-environment",
        "workflow-execution-status",
        "list-executions"
      ],
      "concepts": [
        "test-framework",
        "workflow-status",
        "execution-state",
        "test-environment",
        "status-tracking"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot verify workflow execution status in unit tests, making it impossible to properly test workflow lifecycle management.",
      "rootCause": "TestWorkflowRule's listOpenWorkflowExecutions is not properly setting the execution status field in the response.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The test environment implementation was fixed to properly set WORKFLOW_EXECUTION_STATUS_RUNNING status in ListOpenWorkflowExecutionsResponse.",
      "related": [],
      "keyQuote": "See that status is always WORKFLOW_EXECUTION_STATUS_UNSPECIFIED. Should be WorkflowExecutionStatus.WORKFLOW_EXECUTION_STATUS_RUNNING",
      "number": 842,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:46:50.253Z"
    },
    {
      "summary": "Request to add a built-in 'listQueries' query to the Java SDK for listing available queries in a workflow.",
      "category": "feature",
      "subcategory": "queries",
      "apis": [
        "listQueries"
      ],
      "components": [
        "workflow-query",
        "query-handler"
      ],
      "concepts": [
        "workflow-queries",
        "query-discovery",
        "introspection"
      ],
      "severity": "low",
      "userImpact": "Users cannot programmatically discover what queries are available in a workflow.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #335",
      "related": [
        335,
        51
      ],
      "keyQuote": "Closing as duplicate of #335",
      "number": 840,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:46:07.901Z"
    },
    {
      "summary": "WorkflowExecutionUtils fails to deserialize history JSONs produced by newer protocol versions with added fields. Proto allows adding fields for backwards compatibility, but the current implementation throws errors on unknown fields.",
      "category": "bug",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "WorkflowExecutionUtils",
        "history-deserialization",
        "proto-compatibility"
      ],
      "concepts": [
        "backwards-compatibility",
        "proto-versioning",
        "json-deserialization",
        "schema-evolution",
        "field-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot read history JSONs from workflows created with newer SDK versions, breaking workflow replay and analysis capabilities.",
      "rootCause": "JSON deserializer configuration rejects unknown fields instead of ignoring them as per proto spec for backwards compatibility.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Proto allows adding new fields preserving backwards compatibility. So, the history jsons that are produced from new history proto objects with added fields should be deserializable into old history proto objects.",
      "number": 836,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:46:08.094Z"
    },
    {
      "summary": "Request to add workflow search query APIs to the Java SDK, similar to Go's ListOpenWorkflow capability. The issue discusses whether to expose elasticsearch search functionality and administrative APIs through the SDK client.",
      "category": "feature",
      "subcategory": "workflow-search",
      "apis": [
        "ListOpenWorkflow"
      ],
      "components": [
        "client",
        "workflow-client",
        "elasticsearch-integration"
      ],
      "concepts": [
        "workflow-search",
        "elasticsearch",
        "admin-api",
        "api-design",
        "server-queries"
      ],
      "severity": "medium",
      "userImpact": "Java developers cannot easily query for open workflow executions like in the Go SDK, requiring them to use low-level gRPC stubs or query elasticsearch directly.",
      "rootCause": "Java SDK lacks a user-facing API for workflow search queries that other SDKs provide, forcing users to work with raw protobuf entities.",
      "proposedFix": "Expose workflow search functionality through a dedicated API, either on WorkflowClient or a separate admin client, similar to the Go SDK's ListOpenWorkflow.",
      "workaround": "Use gRPC stubs directly with raw protobuf entities or query elasticsearch directly.",
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #1552.",
      "related": [
        1552
      ],
      "keyQuote": "If this is our officially supported feature of SDK, we should provide an access that doesn't require digging into gRPC stubs and proto Request/Responses.",
      "number": 835,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:46:09.554Z"
    },
    {
      "summary": "Builder classes for *Option need refactoring to move validation logic from validateBuildWithDefaults to standard build method, and normalize validation patterns across all Option classes which currently have inconsistent validation strategies.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [],
      "components": [
        "option-builders",
        "validation",
        "api-design"
      ],
      "concepts": [
        "builder-pattern",
        "validation",
        "api-normalization",
        "interface-cleanup",
        "defaults",
        "consistency"
      ],
      "severity": "medium",
      "userImpact": "Users are forced to call validateBuildWithDefaults explicitly instead of using standard build method, and validation behavior is inconsistent across different Option classes.",
      "rootCause": "validateBuildWithDefaults is mixed with the standard build pattern, and validation logic is scattered across different Option classes with no consistent approach.",
      "proposedFix": "Move validation logic from validateBuildWithDefaults into standard build method, rename current build to partialBuild, and establish consistent validation patterns across all Option classes.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed through API cleanup and normalization of builder patterns.",
      "related": [],
      "keyQuote": "Our users are forced to use Builder#validateBuildWithDefaults everywhere. It's not ideal behavior.",
      "number": 833,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:45:29.621Z"
    },
    {
      "summary": "NullPointerException occurs in RetryOptions#merge when attempting to merge non-primitive Duration values. The merge method fails to properly handle null Duration parameters.",
      "category": "bug",
      "subcategory": "retry-policy",
      "apis": [
        "RetryOptions"
      ],
      "components": [
        "retry-options",
        "merge-logic"
      ],
      "concepts": [
        "null-handling",
        "retry-configuration",
        "duration",
        "merge-operation",
        "type-safety"
      ],
      "severity": "high",
      "userImpact": "Users cannot properly merge retry options when maximum intervals are involved, blocking retry policy configuration.",
      "rootCause": "The merge method calls Duration.class merge with non-primitive Duration values that may be null, causing NullPointerException without proper null handling.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bug was fixed by adding proper null handling in the RetryOptions#merge method for non-primitive Duration values.",
      "related": [],
      "keyQuote": "RetryOptions#merge(RetryOptions o) calls to merge(getMaximumInterval(), o.getMaximumInterval(), Duration.class) which throws NullPointer for non-primitive values.",
      "number": 832,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:45:28.797Z"
    },
    {
      "summary": "Test flake in testUntypedChildStubWorkflowAsyncInvoke when using in-memory test service. This appears to be related to issue #814 and suggests a common underlying problem with the test framework or in-memory service implementation.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-service",
        "in-memory-service",
        "child-workflow"
      ],
      "concepts": [
        "test-flakiness",
        "async-invocation",
        "in-memory-testing",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Developers experience intermittent test failures when using the in-memory test service with typed child stub async invocations, reducing test reliability.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified as related to #814 and resolved as part of addressing the underlying test framework problem.",
      "related": [
        814
      ],
      "keyQuote": "This failure looks very similar to #814. They are most likely related and should be evaluated together.",
      "number": 830,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:45:29.395Z"
    },
    {
      "summary": "Request to expose a health check method on WorkflowServiceStubs or WorkflowClient to allow users to verify the underlying channel/connection to the Temporal server is healthy. This is a cross-SDK feature request with similar issues filed for Go and Node.js SDKs.",
      "category": "feature",
      "subcategory": "client-health-check",
      "apis": [
        "WorkflowServiceStubs",
        "WorkflowClient"
      ],
      "components": [
        "workflow-service-stubs",
        "grpc-channel",
        "client-connection"
      ],
      "concepts": [
        "health-check",
        "connection-status",
        "grpc-health-service",
        "client-reliability",
        "server-connectivity",
        "channel-management"
      ],
      "severity": "medium",
      "userImpact": "Users can programmatically verify their WorkflowClient connection to the Temporal server is healthy without attempting actual workflow operations.",
      "rootCause": null,
      "proposedFix": "Implement healthCheck method that invokes gRPC Health Checking Protocol on the workflow service and returns a boolean indicating health status.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Health check method was exposed on WorkflowServiceStubs following the gRPC health check protocol pattern.",
      "related": [
        595,
        312
      ],
      "keyQuote": "Temporal SDK should expose a method like `WorkflowServiceStubs#healthCheck` or `WorkflowServiceStubs#isHealthy` that allows users to check if the WorkflowClient/WorkflowServiceStubs underlying channel / connection to Temporal server is healthy.",
      "number": 828,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:44:50.263Z"
    },
    {
      "summary": "Request for a recommended approach to pass configuration into workflow instances while maintaining determinism. Proposes using interceptors and side effects to store and access configuration.",
      "category": "feature",
      "subcategory": "workflow-configuration",
      "apis": [
        "Workflow"
      ],
      "components": [
        "workflow",
        "interceptors",
        "side-effects",
        "dependency-injection"
      ],
      "concepts": [
        "configuration",
        "determinism",
        "dependency-injection",
        "workflow-initialization",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Users lack a standard, deterministic way to pass configuration to workflows, making it difficult to implement parameterized workflow logic.",
      "rootCause": null,
      "proposedFix": "Implement configuration passing at the interceptor level, storing configuration in a side effect with utility methods on Workflow class for access during execution.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If dependency injection into the workflow is discouraged, we need to provide a way for an external code to pass all kinds of configurations into Workflow instances.",
      "number": 827,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:44:48.165Z"
    },
    {
      "summary": "SDK worker should automatically supply binary checksum (hash of worker image) to workflow task completion calls instead of requiring users to provide it or leaving it empty.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "RespondWorkflowTaskCompleted",
        "RespondWorkflowTaskFailed"
      ],
      "components": [
        "worker",
        "workflow-task-handler",
        "protocol"
      ],
      "concepts": [
        "binary-checksum",
        "worker-image",
        "automation",
        "configuration",
        "task-completion"
      ],
      "severity": "medium",
      "userImpact": "Users must manually manage and supply binary checksums for workflow task completions, adding unnecessary operational burden.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "SDK worker should automatically supply binary checksum (which is a hash on the worker image) to all calls of RespondWorkflowTaskCompeleted/Failed/etc.",
      "number": 818,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:44:47.927Z"
    },
    {
      "summary": "Workflow.await(duration, condition) doesn't properly handle workflow cancellation, throwing CanceledFailure but then causing a \"closed\" error. WorkflowStub.getResult() also fails to return when await has a duration, unlike the working await(condition) variant.",
      "category": "bug",
      "subcategory": "workflow-cancellation",
      "apis": [
        "Workflow.await"
      ],
      "components": [
        "timer-state-machine",
        "deterministic-runner",
        "workflow-executor",
        "cancellation-handler"
      ],
      "concepts": [
        "cancellation",
        "await",
        "duration",
        "timer",
        "workflow-execution",
        "state-machine"
      ],
      "severity": "high",
      "userImpact": "Workflows using await with duration and cancelation experience crashes instead of proper cancellation, preventing graceful shutdown and hanging getResult() calls.",
      "rootCause": "Timer callback tries to execute in workflow thread after DeterministicRunner is closed, causing cascading failure in state machine handling.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by properly handling cancellation in the timer state machine to avoid executing callbacks on closed deterministic runner.",
      "related": [],
      "keyQuote": "CanceledFailure is thrown but after that, it's followed by: java.lang.Error: closed",
      "number": 816,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:44:09.921Z"
    },
    {
      "summary": "Port Go SDK's DNS-based approach for distributing connections across multiple frontend servers. The original feature request sought to allow multiple host:port specifications and distribute pollers across multiple connections for better load distribution.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [],
      "components": [
        "worker",
        "connection-pool",
        "frontend-client"
      ],
      "concepts": [
        "load-distribution",
        "connection-pooling",
        "dns-resolution",
        "frontend-servers",
        "pollers"
      ],
      "severity": "medium",
      "userImpact": "Users with multiple workers and multiple frontend servers can better distribute polling load across servers instead of concentrating on a single connection.",
      "rootCause": null,
      "proposedFix": "Implement DNS-based approach for distributing connections across multiple frontend servers, following the Go SDK implementation pattern.",
      "workaround": "Users must start more workers to achieve load distribution across frontend servers.",
      "resolution": "wontfix",
      "resolutionDetails": "Closed in favor of DNS-based approach which was adopted instead of explicit multiple host:port specification.",
      "related": [
        577,
        582
      ],
      "keyQuote": "Closing as original Go PR was closed in favour of DNS based approach",
      "number": 815,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:44:08.644Z"
    },
    {
      "summary": "Test `testUntypedChildStubWorkflowAsync` flaked in CI due to a test service internal state machine exception. This appears related to issue #830 and was resolved through PR #1289.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-service",
        "state-machine",
        "child-workflow"
      ],
      "concepts": [
        "flakiness",
        "state-machine",
        "test-reliability",
        "async-child-workflow",
        "ci-failure"
      ],
      "severity": "medium",
      "userImpact": "Test flakiness in CI reduces confidence in the SDK build and may block releases or contributions.",
      "rootCause": "Test service internal state machine exception causing non-deterministic test failures",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by PR #1289",
      "related": [
        830,
        1289
      ],
      "keyQuote": "This failure looks very similar to #830. They are most likely related and should be evaluated together.",
      "number": 814,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:44:08.281Z"
    },
    {
      "summary": "Request to add a test framework capability for replaying partial JSON workflow history and continuing execution to simulate failure recovery and worker cache eviction scenarios. Currently supported for state machines testing but missing from workflow integration testing framework.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowReplayer",
        "queryWorkflowExecution"
      ],
      "components": [
        "test-service",
        "workflow-replayer",
        "history-replay",
        "worker"
      ],
      "concepts": [
        "history-replay",
        "failure-recovery",
        "state-restoration",
        "worker-cache-eviction",
        "replayability-testing",
        "compatibility-testing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test workflow replayability after partial history replays or simulate recovery from failures, limiting test coverage for state machine permutations and compatibility with older SDK versions.",
      "rootCause": null,
      "proposedFix": "Add ability for TestService to load partial workflow history from JSON, restore workflow mutable state, and dispatch workflow tasks to continue execution simulating restoring after failure or cache eviction.",
      "workaround": "Simulate a failure at the desired replay point during test execution, but this doesn't allow testing compatibility with histories from older SDK versions.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We don't have a way to make a replay of a partial json history and continue the execution (aka restoring from a failure).",
      "number": 811,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:43:30.077Z"
    },
    {
      "summary": "Request for Workflow.retry to accept a predicate function that can execute custom logic to decide if a retry is needed, rather than relying only on string matching of exception types in doNotRetry list.",
      "category": "feature",
      "subcategory": "retry-handling",
      "apis": [
        "Workflow.retry",
        "RetryOptions"
      ],
      "components": [
        "workflow-execution",
        "retry-logic",
        "exception-handling"
      ],
      "concepts": [
        "retry",
        "predicate",
        "exception-matching",
        "error-handling",
        "workflow-control"
      ],
      "severity": "medium",
      "userImpact": "Users cannot implement sophisticated retry logic based on exception details or contextual information within workflows, forcing them to use only string-based exception type matching.",
      "rootCause": "Current RetryOptions.doNotRetry relies on string matching of exception types, which is insufficient for complex retry decisions that depend on specific exception properties or workflow state.",
      "proposedFix": "Add a doNotRetryPredicate or retryOnPredicate function parameter to RetryOptions that accepts a lambda to execute custom retry logic, with retryOnPredicate being preferred by users for positive logic rather than negative.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "An API that takes a function (or lambda) that can execute random user provided logic to decide if retry is needed.",
      "number": 806,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:43:29.723Z"
    },
    {
      "summary": "StickyWorkerTest#whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows test flakes intermittently when running with Dockerized Temporal service in CI/CD pipeline.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "sticky-worker",
        "child-workflows",
        "test-framework"
      ],
      "concepts": [
        "test-flakiness",
        "sticky-execution",
        "workflow-caching",
        "docker",
        "ci-cd",
        "race-condition"
      ],
      "severity": "medium",
      "userImpact": "CI/CD builds intermittently fail due to flaky tests, reducing confidence in test reliability and blocking development workflows.",
      "rootCause": "Timing-related issue with workflow caching behavior when using Dockerized Temporal service, likely due to resource contention or timing sensitivity.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved as indicated by author's follow-up comment 'not anymore'.",
      "related": [],
      "keyQuote": "StickyWorkerTest#whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows flakes with Dockerized Temporal service in buildkite.",
      "number": 802,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:43:29.062Z"
    },
    {
      "summary": "The activity_endtoend_latency metric measures the latency of a single activity execution attempt rather than the total time from start to successful completion across all retries. This causes the metric to misrepresent the actual end-to-end latency experienced by users.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "activity-executor",
        "retry-handler"
      ],
      "concepts": [
        "latency",
        "metrics",
        "retry",
        "activity-execution",
        "measurement",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot accurately monitor the true end-to-end latency of activities with retries, making it difficult to diagnose performance issues.",
      "rootCause": "The metric is calculated on each activity execution attempt rather than from the initial start to final successful completion.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The metric calculation was corrected to measure from activity start through successful completion including all retry attempts.",
      "related": [
        573
      ],
      "keyQuote": "activity_endtoend_latency should be a time from the start of the activity to its successful execution.",
      "number": 799,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:42:48.083Z"
    },
    {
      "summary": "Context propagators configured at WorkflowClient level are not being invoked when starting workflows. Users must configure them on WorkflowOptions instead, but should be able to set them once at the client level and have them applied to all workflow stubs created from that client.",
      "category": "bug",
      "subcategory": "context-propagation",
      "apis": [
        "WorkflowClient",
        "WorkflowClientOptions",
        "WorkflowOptions",
        "WorkerFactory"
      ],
      "components": [
        "workflow-client",
        "context-propagation",
        "workflow-stub"
      ],
      "concepts": [
        "context-propagation",
        "client-configuration",
        "interceptors",
        "workflow-invocation",
        "options-inheritance"
      ],
      "severity": "medium",
      "userImpact": "Users must redundantly configure context propagators on each WorkflowOptions instead of setting them once at the WorkflowClient level, increasing boilerplate and configuration complexity.",
      "rootCause": "Context propagators defined in WorkflowClientOptions are not being passed through to WorkflowStubImpl, RootWorkflowClientInvoker, or RootWorkflowClientHelper during workflow creation.",
      "proposedFix": "Propagate context propagators from WorkflowClientOptions to workflow stubs created via client.newWorkflowStub() so they are automatically applied without requiring separate configuration on WorkflowOptions.",
      "workaround": "Set context propagators on individual WorkflowOptions, or use an interceptor to add them to all client stubs centrally.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was acknowledged as a bug and fixed in a later SDK version (targeted for 1.4.0 or 1.5.0).",
      "related": [],
      "keyQuote": "If in the snippets above context propagators are not promoted to the stubs created this way, it's a bug.",
      "number": 796,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:42:50.133Z"
    },
    {
      "summary": "Java SDK lacks metrics reporting for workflow replays. Currently, replay completions are not reported in metrics, limiting visibility into replay behavior and anomalies during replay execution.",
      "category": "feature",
      "subcategory": "metrics-reporting",
      "apis": [],
      "components": [
        "metrics",
        "workflow-replay",
        "worker"
      ],
      "concepts": [
        "metrics-reporting",
        "replay-tracking",
        "anomaly-detection",
        "observability",
        "system-monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users cannot monitor or detect anomalous replay behavior because replay metrics are not reported, limiting visibility into system health during replay operations.",
      "rootCause": null,
      "proposedFix": "Implement replay metrics reporting with decisions needed on: reporting by status codes, total replay counts, and whether to include partial replays.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Replay metrics could be important for detecting the anomaly behavior of the system.",
      "number": 794,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:42:47.660Z"
    },
    {
      "summary": "IdentityInPendingActivityTest#testPendingActivityHasIdentity flakes intermittently in both in-memory and dockerized server environments during CI builds.",
      "category": "bug",
      "subcategory": "test-flakiness",
      "apis": [],
      "components": [
        "test-framework",
        "activity-pending",
        "in-memory-server",
        "docker-server"
      ],
      "concepts": [
        "flakiness",
        "test-reliability",
        "pending-activity",
        "identity",
        "ci-builds"
      ],
      "severity": "medium",
      "userImpact": "Unreliable test suite causes false CI failures and reduces confidence in build validation.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed through test reliability improvements",
      "related": [],
      "keyQuote": "IdentityInPendingActivityTest.testPendingActivityHasIdentity flakes for both I'm-memory and dockerized service in buildkite.",
      "number": 793,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:42:09.600Z"
    },
    {
      "summary": "Test `testSuccessfulActivity` in DescribeTest fails when running with Docker, likely due to changes from merging a pull request to the Test Service.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-service",
        "describe-test",
        "activity-executor"
      ],
      "concepts": [
        "testing",
        "docker",
        "test-service-integration",
        "describe-workflow"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot run the test suite successfully in Docker environments, blocking CI/CD pipelines.",
      "rootCause": "Changes merged from temporalio/temporal#2007 to the Test Service caused testSuccessfulActivity test to fail with Docker",
      "proposedFix": "Implement changes to Test Service and testSuccessfulActivity test as done for issue #766",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by pull request #782",
      "related": [
        766,
        782
      ],
      "keyQuote": "It's most likely a result of merging https://github.com/temporalio/temporal/pull/2007",
      "number": 790,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:42:09.610Z"
    },
    {
      "summary": "Test environment history output is not compliant with tctl format, preventing generated histories from being used directly in the replayer. The test framework needs to produce tctl-compatible history for proper replay testing.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-environment",
        "history-generation",
        "replayer"
      ],
      "concepts": [
        "history-format",
        "tctl-compatibility",
        "replay-testing",
        "protobuf-serialization",
        "test-helpers"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use test-generated histories directly for replaying workflows, requiring manual formatting conversions.",
      "rootCause": "Test environment generates history in TextFormat for human readability, but tctl uses protobuf JsonFormat with Base64-encoded ByteString, creating an incompatibility.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        300
      ],
      "keyQuote": "The test environment should produce histories that can be used in the replayer.",
      "number": 779,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:42:09.607Z"
    },
    {
      "summary": "Epic to improve the Java SDK's threading model by reducing thread churn through pooling, event loops, or work-stealing mechanisms to minimize resource overhead and enable better resource management for individual workflows.",
      "category": "feature",
      "subcategory": "threading-performance",
      "apis": [],
      "components": [
        "workflow-executor",
        "thread-pool",
        "worker",
        "task-processor"
      ],
      "concepts": [
        "threading-model",
        "resource-management",
        "thread-pooling",
        "event-loop",
        "work-stealing",
        "performance",
        "scalability"
      ],
      "severity": "high",
      "userImpact": "Users experience unnecessary resource overhead and poor scalability due to excessive thread creation for workflow execution.",
      "rootCause": "Absence of coroutines in Java leads to creation of many short-lived threads for various SDK operations, resulting in thread churn and inefficient resource utilization.",
      "proposedFix": "Implement pooling, event loops, work-stealing, or similar solutions to minimize thread creation and enable resource constraining per workflow.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Epic closed as GitHub issues are no longer used for epic tracking; progress tracked through individual issue completion.",
      "related": [
        294,
        214,
        1120,
        760,
        998,
        1456,
        343,
        1413,
        878,
        1707,
        1211
      ],
      "keyQuote": "Closing since we no longer want to use GH issues as epics",
      "number": 778,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:41:31.645Z"
    },
    {
      "summary": "Worker identity should be reported when a worker picks up an activity task to populate the lastWorkerIdentity field in PendingActivityTask. Currently this field remains empty because the server expects the identity to be sent at task pickup, not during heartbeat.",
      "category": "feature",
      "subcategory": "activity-worker-identity",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "heartbeat"
      ],
      "concepts": [
        "worker-identity",
        "activity-task-pickup",
        "pending-activity-tracking",
        "server-synchronization",
        "task-metadata"
      ],
      "severity": "medium",
      "userImpact": "Users cannot identify which worker processed an activity task because lastWorkerIdentity is not populated despite heartbeat implementation.",
      "rootCause": "Worker identity is sent during heartbeat but the Temporal server records the identity when the worker picks up the activity task, not when it heartbeats.",
      "proposedFix": "Report worker identity when Worker picks up the activity task instead of only during heartbeat, following the pattern implemented in the Test Server (see temporalio/temporal#2007).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was unblocked after temporalio/temporal#1999 was completed, with implementation guidance provided in temporalio/temporal#2007.",
      "related": [
        590,
        765,
        1999
      ],
      "keyQuote": "JavaSDK should report worker identity when Worker picks up the activity task for `lastWorkerIdentity` to be correctly populated.",
      "number": 766,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:41:31.742Z"
    },
    {
      "summary": "Worker identity is not being included in describeWorkflow results and recordActivityTaskHeartbeatById calls when using a dockerized Temporal server, causing tests that verify worker identity to fail.",
      "category": "bug",
      "subcategory": "worker-identity",
      "apis": [
        "describeWorkflow",
        "recordActivityTaskHeartbeatById"
      ],
      "components": [
        "worker",
        "activity-heartbeat",
        "docker-integration"
      ],
      "concepts": [
        "worker-identity",
        "heartbeat",
        "describe-workflow",
        "docker-compose"
      ],
      "severity": "high",
      "userImpact": "Tests validating worker identity fail with dockerized Temporal servers, and applications cannot reliably track worker identity in heartbeats.",
      "rootCause": "Worker identity field (last_worker_identity) is missing from describeWorkflow results and not being included in recordActivityTaskHeartbeatById calls when using docker-compose Temporal server.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker identity tracking was implemented in #698 but did not work correctly with dockerized Temporal servers; this regression was fixed.",
      "related": [
        698
      ],
      "keyQuote": "last_worker_identity is missing from the result of `describeWorkflow` with dockerized temporal.",
      "number": 765,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:41:30.569Z"
    },
    {
      "summary": "AuthorizationGrpcMetadataProvider class lacks a public constructor, making it impossible to instantiate outside its package. Users must either extend the class or wait for a future fix.",
      "category": "bug",
      "subcategory": "authorization",
      "apis": [
        "AuthorizationGrpcMetadataProvider"
      ],
      "components": [
        "authorization",
        "grpc-metadata",
        "client-api"
      ],
      "concepts": [
        "constructor",
        "visibility",
        "access-control",
        "instantiation",
        "api-design"
      ],
      "severity": "medium",
      "userImpact": "Users cannot directly instantiate AuthorizationGrpcMetadataProvider and must extend the class or use workarounds.",
      "rootCause": "AuthorizationGrpcMetadataProvider constructor is not public, restricting instantiation to the same package.",
      "proposedFix": null,
      "workaround": "Extend the AuthorizationGrpcMetadataProvider class and expose the constructor.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in version 1.4.0 by making the constructor public.",
      "related": [],
      "keyQuote": "If you need a workaround now, please extend the `AuthorizationGrpcMetadataProvider ` class and expose the constructor.",
      "number": 762,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:40:49.784Z"
    },
    {
      "summary": "Add a convenience method to create untyped WorkflowStub directly from a workflow interface and workflowId, without needing to first create a typed stub and then convert it. This addresses a common use case of needing an untyped stub for sending signals or queries.",
      "category": "feature",
      "subcategory": "workflow-stubs",
      "apis": [
        "WorkflowClient.newUntypedWorkflowStub",
        "WorkflowStub.fromTyped"
      ],
      "components": [
        "workflow-client",
        "workflow-stubs",
        "api"
      ],
      "concepts": [
        "stub-creation",
        "typed-to-untyped-conversion",
        "workflow-interface",
        "signal-query",
        "api-convenience"
      ],
      "severity": "low",
      "userImpact": "Users can create untyped stubs more conveniently without the extra step of creating a typed stub first when they have a workflow interface and workflowId.",
      "rootCause": null,
      "proposedFix": "Add a simple newUntypedWorkflowStub(String workflowId) method that internally calls newUntypedWorkflowStub(workflowId, Optional.empty(), Optional.empty())",
      "workaround": "Create typed stub first with WorkflowClient.newWorkflowStub(), then convert to untyped using WorkflowStub.fromTyped()",
      "resolution": "fixed",
      "resolutionDetails": "Implemented as a simplified convenience method wrapping existing functionality with empty optionals",
      "related": [],
      "keyQuote": "We have an interface and a workflowId, we want to get an untyped stub to send a signal or query.",
      "number": 761,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:40:51.030Z"
    },
    {
      "summary": "Workflow Task pollers should implement backpressure by pausing polling when no executor threads are available, rather than continuously polling and causing task backlog. This prevents configuration imbalances between pollers and executors from creating significant delays.",
      "category": "feature",
      "subcategory": "workflow-task-polling",
      "apis": [],
      "components": [
        "poller",
        "executor",
        "workflow-task-processor"
      ],
      "concepts": [
        "backpressure",
        "polling",
        "thread-pool",
        "queue-management",
        "load-balancing"
      ],
      "severity": "medium",
      "userImpact": "Users experiencing misconfigured poller/executor ratios will see reduced task processing delays and better adaptive behavior to workload changes.",
      "rootCause": "Pollers always poll first before attempting to send tasks to executors, causing task backlog when executor capacity is limited.",
      "proposedFix": "Implement backpressure logic to pause polling until a processing thread becomes available, similar to the activity polling implementation.",
      "workaround": "Manually scale by decreasing pollers or increasing worker threads to match workload.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented via PR #1431 with backpressure mechanism for workflow task pollers.",
      "related": [
        286,
        1431
      ],
      "keyQuote": "Poller should pause polling in this case until a processing thread is freed up.",
      "number": 760,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:40:51.420Z"
    },
    {
      "summary": "Querying a completed workflow incorrectly increments the 'temporal_workflow_completed_total' metrics counter, treating query operations as new workflow completions. This causes inaccurate metrics reporting where the counter increases with each query request rather than reflecting actual workflow completions.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics-reporter",
        "micrometer",
        "workflow-service"
      ],
      "concepts": [
        "metrics",
        "monitoring",
        "prometheus",
        "workflow-completion",
        "query-operations",
        "counter-accuracy"
      ],
      "severity": "medium",
      "userImpact": "Users receive incorrect metrics for workflow completion rates, making it difficult to accurately monitor workflow execution and performance.",
      "rootCause": "The SDK appears to be incrementing the workflow completion counter when querying completed workflows, rather than only when workflows actually complete.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Querying a completed workflow increments the 'temporal_workflow_completed_total' for the relevant 'workflow_type' by 1 per Query request.",
      "number": 759,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:40:11.035Z"
    },
    {
      "summary": "AbandonOnCancelActivityTest flakes in build pipelines due to a NullPointerException in the test activity implementation, causing intermittent test failures.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "test-framework",
        "thread-pool"
      ],
      "concepts": [
        "test-flakiness",
        "null-pointer-exception",
        "cancellation",
        "activity-execution",
        "thread-safety"
      ],
      "severity": "medium",
      "userImpact": "Intermittent test failures in CI/CD pipelines reduce developer confidence and cause unpredictable build results.",
      "rootCause": "NullPointerException in TestActivitiesImpl.lambda$activityWithDelay$0 at TestActivities.java:234, likely due to uninitialized or null field access during activity execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The underlying null pointer issue was identified and fixed in the test activity implementation.",
      "related": [],
      "keyQuote": "Exception in thread \"pool-1-thread-1\" java.lang.NullPointerException at io.temporal.workflow.shared.TestActivities$TestActivitiesImpl.lambda$activityWithDelay$0",
      "number": 756,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:40:11.275Z"
    },
    {
      "summary": "Request to support dynamic activity timeout configuration via a Supplier<ActivityOptions> instead of requiring application redeployment. This would allow workers to update activity timeouts on a faster cycle in response to incidents without rebuilding and restarting the entire application.",
      "category": "feature",
      "subcategory": "activity-options",
      "apis": [
        "ActivityOptions",
        "WorkerImplementationOptions"
      ],
      "components": [
        "worker",
        "activity-executor",
        "configuration"
      ],
      "concepts": [
        "dynamic-configuration",
        "timeout",
        "activity-options",
        "supplier-pattern",
        "deployment-cycle"
      ],
      "severity": "medium",
      "userImpact": "Users must currently rebuild and redeploy applications to change activity timeouts, creating long turnaround times for operational changes in response to incidents.",
      "rootCause": null,
      "proposedFix": "Add support for ActivityOptions provided via Supplier<ActivityOptions> in WorkerImplementationOptions to enable dynamic configuration from external stores.",
      "workaround": "Changing configs in code and redeploying, or restarting workers after configuration changes",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "ActivityOptions provided via WorkerImplementationOptions to support a Supplier<ActivityOptions> would help allow us to plugin a dynamic config store",
      "number": 753,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:40:11.328Z"
    },
    {
      "summary": "Refactoring epic to improve code quality and maintainability of ActivityExecutionContext, ActivityCompletionClient, and ManualActivityCompletionClient. Addresses inconsistent error handling, missing documentation, and heartbeat behavior issues across these activity lifecycle components.",
      "category": "other",
      "subcategory": "activity-execution-context",
      "apis": [
        "ActivityExecutionContext",
        "ActivityCompletionClient",
        "ManualActivityCompletionClient"
      ],
      "components": [
        "activity-executor",
        "activity-completion",
        "heartbeat-mechanism"
      ],
      "concepts": [
        "heartbeat",
        "error-handling",
        "manual-completion",
        "code-quality",
        "maintainability",
        "throttling"
      ],
      "severity": "medium",
      "userImpact": "Developers working with manual activity completion and heartbeating experience inconsistent error handling and lack of documentation, making it harder to use these features correctly.",
      "rootCause": "ActivityExecutionContext, ActivityCompletionClient, and ManualActivityCompletionClient have grown with inconsistent patterns for error handling, heartbeat behavior, and documentation.",
      "proposedFix": "Refactor these components to improve code quality, unify error handling approaches, add documentation for throttling behavior, and ensure consistent heartbeat error handling.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Issue was closed because GitHub issues are no longer used as epics for tracking ongoing work. The specific sub-tasks were addressed in individual issues (#943, #1181, #1233, #1354).",
      "related": [
        943,
        1181,
        1233,
        1354
      ],
      "keyQuote": "Code quality and readability around ActivityExecutionContext, ActivityCompletionClient, ManualActivityCompletionClient requires refactoring to make code more maintainable.",
      "number": 752,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:39:32.255Z"
    },
    {
      "summary": "TestEnvironmentOptions.Builder.validateAndBuildWithDefaults() fails in SDK v1.3.1 with 'Only one of the target and channel options can be set at a time' error when creating a TestWorkflowEnvironment, whereas the same code works fine with just build().",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment",
        "TestEnvironmentOptions",
        "WorkflowClientOptions",
        "WorkerFactoryOptions",
        "WorkflowServiceStubs"
      ],
      "components": [
        "test-environment",
        "service-client",
        "workflow-service-stubs",
        "builder-validation"
      ],
      "concepts": [
        "in-memory-service",
        "channel-configuration",
        "service-target",
        "option-building",
        "validation"
      ],
      "severity": "high",
      "userImpact": "Users upgrading from v1.1 to v1.3.1+ cannot initialize test environments using validateAndBuildWithDefaults(), blocking test setup.",
      "rootCause": "validateAndBuildWithDefaults() creates default service options with a default target address, which conflicts with the in-memory channel automatically added by WorkflowServiceStubsImpl, causing mutual exclusivity validation to fail.",
      "proposedFix": "Remove the target when populating the channel in the service options initialization.",
      "workaround": "Use build() instead of validateAndBuildWithDefaults() when creating TestEnvironmentOptions.",
      "resolution": "fixed",
      "resolutionDetails": "PR was created to remove target when populating the channel, resolving the conflict between default target and in-memory channel.",
      "related": [],
      "keyQuote": "Only one of the target and channel options can be set at a time",
      "number": 749,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:39:32.344Z"
    },
    {
      "summary": "Request to provide a way to inject options (RetryOptions, ActivityOptions) into Workflow instances for configuration-driven behavior and unit testing, since dependency injection is discouraged.",
      "category": "feature",
      "subcategory": "dependency-injection",
      "apis": [
        "RetryOptions",
        "ActivityOptions"
      ],
      "components": [
        "workflow-instance",
        "options-framework",
        "test-support"
      ],
      "concepts": [
        "dependency-injection",
        "configuration",
        "options",
        "testing",
        "retry-policy",
        "activity-options"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily configure workflow behavior dynamically or inject test options without relying on discouraged dependency injection patterns.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If injection to Workflow instances is discouraged, we should have a way to provide options to the workflow instances.",
      "number": 748,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:39:30.316Z"
    },
    {
      "summary": "Request for JUnit test rules to enable unit testing of Workflow code with full Temporal API support. Includes ability to mock non-deterministic methods like Workflow.randomUUID for predictable tests, designed to be reusable across other testing frameworks.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.randomUUID"
      ],
      "components": [
        "workflow-testing",
        "junit-rules",
        "test-utilities"
      ],
      "concepts": [
        "unit-testing",
        "test-rules",
        "mocking",
        "determinism",
        "workflow-execution",
        "testing-framework"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot easily unit test workflow code without complex setup, limiting their ability to verify workflow logic independently.",
      "rootCause": null,
      "proposedFix": "Provide JUnit test rules that execute workflow methods in proper workflow context and allow mocking of non-deterministic methods.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented with test-related features and enhancements to the SDK testing utilities.",
      "related": [],
      "keyQuote": "We should provide JUnit Test Rules that allow writing unit tests for Workflow code. These test rules should execute the code in a workflow method context to provide a full usage of Temporal APIs.",
      "number": 747,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:38:50.258Z"
    },
    {
      "summary": "ActivityStubs created outside of a workflow context (e.g., via DI frameworks as singletons) leak between workflow instances, causing cryptic event loop errors. The issue requests either better diagnostics to identify this misconfiguration or making ActivityStubs safely shareable across workflows.",
      "category": "feature",
      "subcategory": "activity-stubs",
      "apis": [
        "ActivityStub",
        "LocalActivityStub"
      ],
      "components": [
        "activity-stub",
        "dependency-injection",
        "workflow-context",
        "event-loop"
      ],
      "concepts": [
        "context-isolation",
        "singleton-misuse",
        "workflow-isolation",
        "diagnostic-error-messages",
        "stub-lifecycle",
        "thread-safety"
      ],
      "severity": "high",
      "userImpact": "Users employing dependency injection frameworks may accidentally create workflow-instance-agnostic activity stubs that fail with misleading event loop errors instead of clear diagnostics.",
      "rootCause": "ActivityStubs are bound to a specific workflow context/event loop. When improperly configured as singletons in DI frameworks, they're reused across workflow instances, violating the context requirement and causing cryptic IllegalStateException errors.",
      "proposedFix": "Either (1) detect when ActivityStubs are reused across workflow instances and provide clear diagnostic errors, or (2) refactor ActivityStubs to be workflow context-independent by making internal changes to safely share them.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "if somebody uses Dependency Injection frameworks with Temporal it's very easy to misconfigure the wiring... We should detect or provide better protection or diagnostic if this happens",
      "number": 746,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:38:51.586Z"
    },
    {
      "summary": "Improve support and safety of Dependency Injection with the Java SDK by discouraging injection into workflow instances (deemed unsafe and non-deterministic) while providing alternative solutions for common DI use cases.",
      "category": "feature",
      "subcategory": "dependency-injection",
      "apis": [],
      "components": [
        "workflow",
        "dependency-injection"
      ],
      "concepts": [
        "dependency-injection",
        "non-determinism",
        "safety",
        "workflow-design",
        "best-practices"
      ],
      "severity": "medium",
      "userImpact": "Guides users away from unsafe dependency injection practices in workflows and provides recommended alternatives for common scenarios.",
      "rootCause": null,
      "proposedFix": "Provide documentation and alternative solutions for problems users typically solve with DI, discourage DI into workflow instances.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed as epic pattern no longer used for GitHub issue tracking.",
      "related": [
        746,
        747,
        748,
        718,
        466,
        827
      ],
      "keyQuote": "Dependency Injection into Workflow instances should be strongly discouraged. It's deemed unsafe and leads to practices that create non-deterministic workflows.",
      "number": 745,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:38:50.730Z"
    },
    {
      "summary": "Workflows intermittently get stuck in Running state with WorkflowTaskFailed error when 20-100 instances are triggered simultaneously. The root cause is a ClassCastException when handling scala.runtime.NonLocalReturnControl, which isn't recognized as a workflow failure exception.",
      "category": "bug",
      "subcategory": "workflow-task-handling",
      "apis": [],
      "components": [
        "workflow-worker",
        "workflow-task-handler",
        "state-machine",
        "exception-wrapper"
      ],
      "concepts": [
        "exception-handling",
        "workflow-execution",
        "state-machine",
        "retry-logic",
        "concurrent-execution",
        "throwable-casting",
        "workflow-failure"
      ],
      "severity": "high",
      "userImpact": "Workflows appear stuck in Running state under concurrent load, requiring worker redeployment or manual intervention to resolve.",
      "rootCause": "ClassCastException in CheckedExceptionWrapper when handling scala.runtime.NonLocalReturnControl (a Throwable that doesn't extend Exception). The SDK only treats TemporalFailure subclasses as workflow failures, causing non-TemporalFailure exceptions to trigger indefinite retries.",
      "proposedFix": "Wrap scala.runtime.NonLocalReturnControl into TemporalFailure or use WorkflowImplementationOptions#setFailWorkflowExceptionTypes to specify it as a workflow-failing exception type.",
      "workaround": "Use WorkflowImplementationOptions#setFailWorkflowExceptionTypes to configure scala.runtime.NonLocalReturnControl as a workflow failure exception, or redeploy workers after fixing the exception.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in version 1.4.0 with improved error messages and better handling of non-Exception Throwables. ClassCastException will be caught and workflow failures properly reported.",
      "related": [],
      "keyQuote": "If you want the `scala.runtime.NonLocalReturnControl` Throwable be treated as a workflow execution failure, wrap it into TemporalFailure class",
      "number": 744,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:38:11.494Z"
    },
    {
      "summary": "SignalTest#testSignalUntyped was a flaky test that was disabled. After investigation and re-enabling, the test has been stable for some time and no longer exhibits flakiness.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "signal-handling",
        "untyped-signals"
      ],
      "concepts": [
        "test-flakiness",
        "signal-testing",
        "test-stability",
        "thread-timing",
        "race-conditions"
      ],
      "severity": "low",
      "userImpact": "Flaky tests reduce confidence in the SDK and make it harder to validate signal handling functionality.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Test was re-enabled and has been stable without flaking for some time.",
      "related": [],
      "keyQuote": "This test is reenabled back for some time and doesn't flake. Close for now.",
      "number": 743,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:38:08.947Z"
    },
    {
      "summary": "The Java SDK uses non-standard SNAPSHOT versioning (x.y.z-SNAPSHOT instead of x.y+1.0-SNAPSHOT) and ignores version suffixes in tags, preventing external forks from releasing custom versions with company or feature-specific postfixes.",
      "category": "bug",
      "subcategory": "versioning",
      "apis": [],
      "components": [
        "versioning.gradle",
        "version-management",
        "build-system"
      ],
      "concepts": [
        "versioning",
        "SNAPSHOT",
        "Maven-conventions",
        "version-suffixes",
        "external-forks",
        "release-management"
      ],
      "severity": "medium",
      "userImpact": "External forks cannot create custom-branded releases with version suffixes without manually modifying build configuration, violating Maven conventions and hindering fork maintenance.",
      "rootCause": "The versioning.gradle functions ignore tag postfixes and use non-standard SNAPSHOT version format that contradicts Java/Maven conventions.",
      "proposedFix": "Update versioning.gradle to follow Maven conventions: use x.y+1.0-SNAPSHOT for snapshots and preserve version suffixes from tags.",
      "workaround": "Manually hack versioning.gradle to support custom version suffixes.",
      "resolution": "fixed",
      "resolutionDetails": "The versioning system was updated to follow Maven conventions and support version suffixes for custom forks.",
      "related": [],
      "keyQuote": "If the last released version if 1.3.1, the SNAPSHOT version is 1.3.1-SNAPSHOT which is contradicting with a common practice in Java/Maven repos.",
      "number": 738,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:38:10.420Z"
    },
    {
      "summary": "Remove the deprecated TestWorkflowRule#testTimeoutSeconds method that was deprecated in version 1.4. This cleanup task involves removing the deprecated implementation from the TestWorkflowRule class as part of the 1.5 release.",
      "category": "other",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowRule",
        "test-framework"
      ],
      "concepts": [
        "deprecation",
        "cleanup",
        "testing",
        "timeout",
        "release-management"
      ],
      "severity": "low",
      "userImpact": "Users will have a cleaner test framework API without deprecated methods when upgrading to version 1.5.",
      "rootCause": null,
      "proposedFix": "Remove TestWorkflowRule#testTimeoutSeconds implementation during the 1.5 release cycle.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        719
      ],
      "keyQuote": "We should clean up the implementation from TestWorkflowRule in 1.5",
      "number": 732,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:37:30.630Z"
    },
    {
      "summary": "Activities that return with the interrupted flag set are not properly reported as completed, causing subsequent gRPC calls to fail. The activity result should be reported successfully even when the thread's interrupted flag is set.",
      "category": "bug",
      "subcategory": "activity-execution",
      "apis": [],
      "components": [
        "activity-executor",
        "gRPC-client",
        "thread-pool"
      ],
      "concepts": [
        "interrupted-flag",
        "thread-interruption",
        "activity-completion",
        "result-reporting",
        "state-restoration"
      ],
      "severity": "high",
      "userImpact": "Activities that handle thread interruptions may fail to report their results to the server, causing workflow execution to hang or fail.",
      "rootCause": "When an activity returns with the interrupted flag set to true, subsequent gRPC calls fail and prevent the activity result from being reported to the server.",
      "proposedFix": "Hide the interrupted flag before reporting the activity result to the server, then restore it afterward to allow proper thread pool shutdown.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        722
      ],
      "keyQuote": "if activity returns with an interrupted flag turned on, subsequent gRPC calls fail and the Activity result never gets reported",
      "number": 731,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:37:31.005Z"
    },
    {
      "summary": "SelfAdvancingTimerImplTest flakes intermittently in CI pipelines when the test machine is under load, showing timing assertion failures where the actual elapsed time exceeds the expected value by 55ms.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "SelfAdvancingTimerImpl",
        "test-service",
        "timing-logic"
      ],
      "concepts": [
        "flaky-test",
        "timing-sensitive",
        "load-dependent",
        "test-reliability",
        "timer-accuracy"
      ],
      "severity": "medium",
      "userImpact": "Test flakiness reduces confidence in test suite reliability and makes it harder to identify real failures in CI pipelines.",
      "rootCause": "SelfAdvancingTimerImpl test is sensitive to machine load, causing timer assertions to fail when actual elapsed time exceeds expected values under system resource contention.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "expected:<20000.0> but was:<20055.0>",
      "number": 726,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:37:31.218Z"
    },
    {
      "summary": "The TEMPORAL_DEBUG flag is not being checked by the deadlock detector in the SyncWorkflow eventLoop, preventing developers from disabling deadlock detection during testing and debugging.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "SyncWorkflow",
        "eventLoop",
        "deadlock-detector"
      ],
      "concepts": [
        "debugging",
        "deadlock-detection",
        "testing",
        "flag-handling",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot disable the deadlock detector during debugging and testing, even with the TEMPORAL_DEBUG flag set.",
      "rootCause": "SyncWorkflow#eventLoop is missing a check for the TEMPORAL_DEBUG flag before applying deadlock detection logic.",
      "proposedFix": "Add a check for TEMPORAL_DEBUG flag in SyncWorkflow#eventLoop to skip or bypass deadlock detection when enabled.",
      "workaround": "Users can use snapshot builds or fork/build their own artifacts with a fix applied.",
      "resolution": "fixed",
      "resolutionDetails": "The missing TEMPORAL_DEBUG flag check was added to the eventLoop deadlock detector.",
      "related": [],
      "keyQuote": "SyncWorkflow#eventLoop lacks a check for `TEMPORAL_DEBUG` flag",
      "number": 724,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:36:51.373Z"
    },
    {
      "summary": "CleanWorkerShutdownTest::testShutdownNow fails when running with Docker. The test appears to have environment-specific issues with worker shutdown behavior in containerized environments.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "worker",
        "shutdown",
        "test-framework"
      ],
      "concepts": [
        "graceful-shutdown",
        "docker",
        "test-environment",
        "timing",
        "resource-cleanup"
      ],
      "severity": "medium",
      "userImpact": "Tests fail in Docker environments, preventing reliable CI/CD validation of worker shutdown behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through fixes to the test or worker shutdown logic to handle Docker environment conditions.",
      "related": [],
      "keyQuote": "Fails with docker",
      "number": 721,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:36:50.788Z"
    },
    {
      "summary": "Spring proxy beans marked with @Component fail to register as activity implementations because the proxy class doesn't properly expose the @ActivityInterface. The issue is that Spring's CGLIB proxies wrap the activity instance but only implement marker interfaces, not the actual activity interfaces.",
      "category": "bug",
      "subcategory": "spring-integration",
      "apis": [
        "registerActivitiesImplementations",
        "registerActivityImplementation"
      ],
      "components": [
        "POJOActivityImplMetadata",
        "POJOActivityTaskHandler",
        "SyncActivityWorker",
        "spring-integration"
      ],
      "concepts": [
        "dependency-injection",
        "proxy",
        "spring-framework",
        "activity-registration",
        "interface-detection",
        "cglib"
      ],
      "severity": "medium",
      "userImpact": "Users cannot register Spring-managed activity beans as activity implementations when using proxy-based dependency injection patterns.",
      "rootCause": "POJOActivityImplMetadata.java doesn't properly detect @ActivityInterface annotations on proxy classes generated by Spring's CGLIB enhancement. The proxy class name (ActivityImpl$$EnhancerBySpringCGLIB$$...) doesn't implement the actual activity interfaces, only marker interfaces.",
      "proposedFix": "Modify the interface detection logic to unwrap Spring proxies and inspect the underlying target class for @ActivityInterface annotations.",
      "workaround": "Inject specific Activity interfaces directly rather than using marker interfaces to request collections of beans from Spring container.",
      "resolution": "invalid",
      "resolutionDetails": "Issue reporter could not provide reproduction case. Maintainer verified that activity beans can be initialized and registered when properly wired, suggesting the issue was with the user's specific Spring configuration rather than a SDK bug.",
      "related": [],
      "keyQuote": "If you inject (or request from the Spring container) specific Activity interfaces - Spring proxies should implement the right Activity interfaces.",
      "number": 718,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:36:53.252Z"
    },
    {
      "summary": "DynamicWorkflow fails to handle ApplicationFailure.newNonRetryableFailure correctly, causing workflows to hang and timeout instead of failing immediately as expected.",
      "category": "bug",
      "subcategory": "dynamic-workflow",
      "apis": [
        "ApplicationFailure"
      ],
      "components": [
        "dynamic-workflow",
        "failure-handling",
        "workflow-execution"
      ],
      "concepts": [
        "non-retryable-failure",
        "exception-handling",
        "workflow-timeout",
        "failure-propagation"
      ],
      "severity": "high",
      "userImpact": "Users attempting to use non-retryable failures in dynamic workflows experience unexpected timeouts instead of immediate failure.",
      "rootCause": "DynamicWorkflow does not properly handle the non-retryable failure flag when processing ApplicationFailure exceptions.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved in a subsequent version after 1.0.9",
      "related": [],
      "keyQuote": "A dynamic workflow that throws ApplicationFailure.newNonRetryableFailure should fail immediately.",
      "number": 716,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:36:10.555Z"
    },
    {
      "summary": "A regression in GrpcRetryer causes requests failing with DEADLINE_EXCEEDED to not be retried when GrpcDeadlineInterceptor sets more granular deadlines than the root gRPC context, potentially causing 1.3.0 to throw exceptions that were previously retried.",
      "category": "bug",
      "subcategory": "grpc-retry",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "GrpcDeadlineInterceptor",
        "gRPC"
      ],
      "concepts": [
        "retry",
        "deadline",
        "timeout",
        "error-handling",
        "regression"
      ],
      "severity": "high",
      "userImpact": "Users may experience unexpected exceptions in version 1.3.0 when requests timeout at granular deadline levels, breaking backward compatibility with previous retry behavior.",
      "rootCause": "GrpcRetryer was modified to respect DEADLINE_EXCEEDED status, but does not account for layered deadline interceptors that set more granular deadlines than the root gRPC context.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by adjusting GrpcRetryer to handle deadline exceeded scenarios correctly when layered with GrpcDeadlineInterceptor.",
      "related": [],
      "keyQuote": "A recent modification of GrpcRetryer to respect DEADLINE_EXCEEDED causes a situation when an underlying request fails with DEADLINE_EXCEEDED and is not being retried anymore",
      "number": 708,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:36:11.443Z"
    },
    {
      "summary": "In-memory Temporal test framework throws DEADLINE_EXCEEDED error after 70 seconds for long-running workflows, while external Temporal instances work fine. The issue occurs when workflow execution time exceeds 70 seconds due to a timeout on the client-side gRPC call.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "getWorkflowExecutionHistory"
      ],
      "components": [
        "test-workflow-extension",
        "workflow-client",
        "grpc-stub"
      ],
      "concepts": [
        "timeout",
        "deadline",
        "long-running-workflows",
        "in-memory-testing",
        "rpc-timeout",
        "client-side-wait"
      ],
      "severity": "high",
      "userImpact": "Developers cannot test workflows longer than 70 seconds using in-memory Temporal, forcing them to use external Temporal instances for testing long-running workflows.",
      "rootCause": "The getWorkflowExecutionHistory gRPC call uses a default rpcLongPollTimeout that is applied to client-side waits, causing a DEADLINE_EXCEEDED error after ~70 seconds regardless of actual workflow duration.",
      "proposedFix": "Addressed by issues #709 and #713 (implementation details not specified in this issue)",
      "workaround": "Set rpcLongPollTimeout to a higher value in WorkflowServiceStubsOptions, though this was not clearly documented at the time of reporting",
      "resolution": "fixed",
      "resolutionDetails": "Issues #709 and #713 were created to address this problem, indicating the timeout issue was resolved in subsequent releases",
      "related": [
        709,
        713
      ],
      "keyQuote": "This happens if there is long running activity or if a workflow is executing several short activities but as long as total workflow running time exceeds 70 seconds, this exception gets thrown.",
      "number": 707,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:36:12.891Z"
    },
    {
      "summary": "Removing Workflow#getVersion calls breaks workflow replay even after all old workflow instances complete, preventing clean code removal. The versioning system requires keeping version markers in code indefinitely to maintain replay compatibility.",
      "category": "bug",
      "subcategory": "workflow-versioning",
      "apis": [
        "Workflow#getVersion",
        "Worker#replayWorkflowExecution"
      ],
      "components": [
        "workflow-versioning",
        "history-replay",
        "version-state-machine"
      ],
      "concepts": [
        "versioning",
        "workflow-replay",
        "history-compatibility",
        "code-evolution",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Developers cannot safely remove versioning code after migrations complete, forcing them to maintain deprecated code paths indefinitely.",
      "rootCause": "Java SDK version state machine does not properly ignore version markers when getVersion calls are removed, causing replay failures.",
      "proposedFix": "Version markers should be ignored if the getVersion call is removed from the workflow code, allowing safe removal of versioning calls.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Recognized as a Java SDK version state machine bug that should be fixed to allow version markers to be ignored when getVersion is removed.",
      "related": [],
      "keyQuote": "Version marker should be ignored if `getVersion` call is removed and it's a supported behavior. So it looks like java-sdk Version state machine bug for me.",
      "number": 706,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:35:32.830Z"
    },
    {
      "summary": "Activity failures using ApplicationFailure.nonRetryableError are logged as errors, polluting logs and external monitoring systems like Sentry. Users request customizable logging for expected activity failures to distinguish them from unexpected failures.",
      "category": "feature",
      "subcategory": "activity-logging",
      "apis": [
        "ApplicationFailure"
      ],
      "components": [
        "activity-executor",
        "logger",
        "error-handling"
      ],
      "concepts": [
        "logging",
        "expected-failures",
        "error-classification",
        "monitoring",
        "activity-execution",
        "exception-handling"
      ],
      "severity": "medium",
      "userImpact": "Users experience polluted logs and external monitoring noise from expected activity failures, making it harder to track genuine issues.",
      "rootCause": "Activity failure logging does not differentiate between expected and unexpected failures, causing all ApplicationFailure instances to be logged as errors.",
      "proposedFix": "Create a logger per error type or implement customizable logging configuration to allow users to control how expected failures are logged.",
      "workaround": "Model expected failures into return types instead of using ApplicationFailure.nonRetryableError.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented in PR #2485, allowing customizable exception logging for activity failures similar to Go SDK implementation.",
      "related": [
        78
      ],
      "keyQuote": "expected activity failures will pollute the log and would prefer to only log unexpected failures",
      "number": 704,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:35:32.596Z"
    },
    {
      "summary": "When an async activity with a primitive return type completes with null, the value is incorrectly converted to zero instead of raising a NullPointerException. This occurs when the activity is invoked synchronously from the workflow, requiring unboxing of the null completion value.",
      "category": "bug",
      "subcategory": "activity-completion",
      "apis": [
        "useLocalManualCompletion"
      ],
      "components": [
        "activity-executor",
        "async-completion",
        "type-conversion"
      ],
      "concepts": [
        "null-handling",
        "primitive-types",
        "auto-unboxing",
        "manual-completion",
        "type-safety"
      ],
      "severity": "medium",
      "userImpact": "Users completing activities asynchronously with null values for primitive return types receive zero instead of an error, causing silent data corruption.",
      "rootCause": "The async completion mechanism converts null to the default primitive value (zero) instead of preserving null for proper unboxing error handling.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was confirmed as a real bug that needed fixing - null propagation should either be prevented at completion or properly handled during unboxing to generate NPE.",
      "related": [
        846
      ],
      "keyQuote": "The missing detail in the reproduction steps is to invoke the activity synchronously from the workflow, so that there's unboxing required from the null completion value to the local primitive variable.",
      "number": 701,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:35:32.295Z"
    },
    {
      "summary": "Port the fix for following execution chains from the Go SDK to Java SDK. This involves adding an option to opt-out of following runs when waiting for workflow results, consistent with implementations in Python, TypeScript, and Go SDKs.",
      "category": "feature",
      "subcategory": "workflow-client",
      "apis": [
        "execute",
        "result"
      ],
      "components": [
        "workflow-client",
        "client-api"
      ],
      "concepts": [
        "execution-chain",
        "following-runs",
        "workflow-result",
        "opt-out",
        "cross-sdk-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users will have the ability to control whether workflow result queries automatically follow execution chains, matching behavior available in other SDKs.",
      "rootCause": null,
      "proposedFix": "Implement followRuns option on execute and result methods in Java workflow client, similar to TypeScript SDK implementation at workflow-client.ts lines 403 and 509.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        527,
        791
      ],
      "keyQuote": "We also have a way to opt-out of following runs when waiting for the result in Python, TS, and now Go.",
      "number": 696,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:34:52.864Z"
    },
    {
      "summary": "LocalActivitiesWorkflowTaskHeartbeatTest#testLocalActivitiesWorkflowTaskHeartbeat test is flaky in buildkite, timing out after 15 seconds.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "local-activities",
        "workflow-task-heartbeat"
      ],
      "concepts": [
        "flakiness",
        "timeout",
        "test-reliability",
        "heartbeat",
        "local-activities",
        "timing"
      ],
      "severity": "high",
      "userImpact": "Flaky tests reduce developer confidence in the build system and make it difficult to distinguish real failures from timing issues.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through test framework improvements or timing adjustments to eliminate the flakiness.",
      "related": [],
      "keyQuote": "test timed out after 15 seconds",
      "number": 693,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:34:51.781Z"
    },
    {
      "summary": "Memo serialization is implemented inconsistently across the SDK, with some code using user-defined data converters and other code using a default converter. The inconsistency should be resolved by removing reliance on HeaderUtils#intoPayloadMapWithDefaultConverter for all memo serialization.",
      "category": "bug",
      "subcategory": "serialization",
      "apis": [
        "WorkflowClientOptions"
      ],
      "components": [
        "HeaderUtils",
        "WorkflowInternal",
        "data-converter",
        "memo-handling"
      ],
      "concepts": [
        "serialization",
        "deserialization",
        "data-converter",
        "consistency",
        "configuration",
        "payload-conversion"
      ],
      "severity": "high",
      "userImpact": "Users with custom data converters may experience unexpected behavior when memo payloads are serialized with the default converter instead of their configured converter.",
      "rootCause": "Mixed usage of user-defined converter (WorkflowInternal) and default converter (HeaderUtils#intoPayloadMapWithDefaultConverter) throughout the codebase for memo serialization.",
      "proposedFix": "Remove usage of HeaderUtils#intoPayloadMapWithDefaultConverter and consistently use the user-defined data converter specified in WorkflowClientOptions for all memo serialization.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by standardizing memo serialization to use user-defined converters consistently across the SDK.",
      "related": [
        611
      ],
      "keyQuote": "Serialization of Memo shouldn't use HeaderUtils#intoPayloadMapWithDefaultConverter",
      "number": 677,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:34:52.375Z"
    },
    {
      "summary": "LocalDateTime serialization in search attributes fails against Docker due to format mismatch. The server rejects ISO 8601 datetime strings like '2021-08-26T13:21:52.059738' as invalid values for Datetime-type search attributes, suggesting either a documentation or implementation bug in datetime handling.",
      "category": "bug",
      "subcategory": "search-attributes",
      "apis": [
        "SearchAttribute",
        "WorkflowOptions"
      ],
      "components": [
        "search-attributes",
        "serialization",
        "datetime-handling"
      ],
      "concepts": [
        "serialization",
        "datetime-format",
        "iso8601",
        "type-validation",
        "server-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use LocalDateTime objects as search attribute values when running against Docker, blocking datetime-based workflow search functionality.",
      "rootCause": "Mismatch between Java LocalDateTime serialization format (ISO 8601) and what the server's json.Unmarshal expects for time.Time values, or incorrect server-side validation of datetime format.",
      "proposedFix": null,
      "workaround": "The issue mentions commented-out lines in the test (lines 82-84) suggesting a workaround exists, but specifics are not detailed in the body.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "2021-08-26T13:21:52.059738 is not a valid value for search attribute CustomDatetimeField of type Datetime",
      "number": 673,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:34:13.399Z"
    },
    {
      "summary": "LongLocalActivityWorkflowTaskHeartbeatFailureTest is flaky in buildkite CI, failing with an assertion error where an activity executed 3 times instead of the expected 2 times.",
      "category": "bug",
      "subcategory": "test-flakiness",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "test-framework",
        "activity-executor",
        "workflow-task-heartbeat"
      ],
      "concepts": [
        "flaky-test",
        "heartbeat",
        "local-activity",
        "test-reliability",
        "assertion-failure"
      ],
      "severity": "medium",
      "userImpact": "Flaky tests reduce confidence in the SDK build process and make CI/CD pipelines unreliable.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was identified as a test flakiness problem related to local activity workflow task heartbeat handling.",
      "related": [],
      "keyQuote": "expected:<2> but was:<3>",
      "number": 672,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:34:11.783Z"
    },
    {
      "summary": "JWT token authorization for server calls currently requires implementing custom gRPC interceptors, which is cumbersome. The enhancement request seeks a simpler, more user-friendly way to provide JWT tokens, either through built-in JWT-specific interceptors or HeaderProviders on WorkflowClientOptions.",
      "category": "feature",
      "subcategory": "authentication",
      "apis": [
        "WorkflowServiceStubsOptions",
        "WorkflowClientOptions"
      ],
      "components": [
        "grpc-client",
        "authentication",
        "workflow-service-stubs"
      ],
      "concepts": [
        "jwt",
        "authorization",
        "http-headers",
        "interceptors",
        "server-authentication"
      ],
      "severity": "medium",
      "userImpact": "Users implementing JWT-based server authentication must write boilerplate code with multiple interceptor implementations, creating friction for a common security pattern.",
      "rootCause": null,
      "proposedFix": "Provide either built-in JWT-specific gRPC interceptors or allow setting HeaderProviders on WorkflowClientOptions for easier header management.",
      "workaround": "Implement custom gRPC Stubs interceptors and specify them in WorkflowServiceStubsOptions#Builder#setBlockingStubInterceptor and setFutureStubInterceptor.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It's a painful way for one of the server's default features and we should come up with a better way.",
      "number": 671,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:34:13.114Z"
    },
    {
      "summary": "GrpcRetryer loses the underlying cause exception when retries exhaust and result in DEADLINE_EXCEEDED, replacing it with the deadline exception and reducing debuggability for users investigating failures.",
      "category": "bug",
      "subcategory": "grpc-retry",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "exception-handling"
      ],
      "concepts": [
        "retry",
        "deadline",
        "exception-handling",
        "debuggability",
        "timeout"
      ],
      "severity": "medium",
      "userImpact": "Users lose visibility into the actual underlying exceptions that caused retries, making it harder to diagnose and investigate failures.",
      "rootCause": "When retries fail with DEADLINE_EXCEEDED, the exception is thrown as-is, discarding previous retryable exceptions that led to the deadline being reached.",
      "proposedFix": "If DEADLINE_EXCEEDED occurs during retries, discard it and return the previous exception instead to preserve the actual root cause, simulating normal timeout behavior.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If DEADLINE_EXCEEDED happened during retries, we can discard DEADLINE_EXCEEDED and return a previous exception if it exists.",
      "number": 666,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:33:33.464Z"
    },
    {
      "summary": "Users need a way to configure or influence RpcRetryOptions for gRPC retries to tune Temporal for their specific use cases (e.g., microservice orchestration vs. batch processing). The SDK currently provides safe defaults that don't work for all scenarios, particularly regarding initial retry periods.",
      "category": "feature",
      "subcategory": "rpc-retry-configuration",
      "apis": [],
      "components": [
        "grpc-client",
        "retry-handler",
        "rpc-configuration"
      ],
      "concepts": [
        "retry-policy",
        "configuration",
        "rpc-tuning",
        "microservices",
        "batch-processing",
        "backoff-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users cannot optimize Temporal client retry behavior for their specific use cases and are forced to use default retry periods that may not fit their infrastructure requirements.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we should come up with some ability to influence/specify RpcRetryOptions for our users to allow them to tune Temporal for their specific use case",
      "number": 665,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:33:33.494Z"
    },
    {
      "summary": "GrpcRetryer should treat ResourceExhausted exceptions as retryable by default and implement special handling such as more aggressive backoff strategies.",
      "category": "other",
      "subcategory": "grpc-retry-handling",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "exception-handling",
        "backoff-strategy"
      ],
      "concepts": [
        "retry",
        "backoff",
        "resource-exhaustion",
        "exception-handling",
        "resilience"
      ],
      "severity": "medium",
      "userImpact": "Users experience better resilience when the gRPC layer encounters resource exhaustion errors, with appropriate retry logic.",
      "rootCause": "ResourceExhausted exceptions were not being retried by default in GrpcRetryer despite their transient nature.",
      "proposedFix": "Add special handling for ResourceExhausted exceptions with more aggressive backoff strategy in GrpcRetryer.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by PR #1465 which implemented special handling for ResourceExhausted exceptions in GrpcRetryer.",
      "related": [
        1465
      ],
      "keyQuote": "ResourceExhausted should be a retryable exception for GrpcRetryer by default, at the same time it probably needs a special handling",
      "number": 664,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:33:32.419Z"
    },
    {
      "summary": "Test DefaultActivityOptionsSetOnWorkflowTest#testSetWorkflowImplementationOptions fails inconsistently when run with Dockerized Temporal, with activity timeout being PT2S instead of expected PT3S.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "activity-options",
        "test-framework",
        "docker-testing"
      ],
      "concepts": [
        "timeout",
        "activity-options",
        "flaky-test",
        "timing",
        "docker-environment"
      ],
      "severity": "medium",
      "userImpact": "Tests fail inconsistently in CI/CD environments with Docker, blocking reliable test execution and development workflows.",
      "rootCause": "Timing sensitivity in test when run with Dockerized Temporal - activity timeout duration differs from expected value, likely due to Docker performance variability or timing precision issues.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "expected:<PT3S> but was:<PT2S>",
      "number": 663,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:32:54.795Z"
    },
    {
      "summary": "GrpcRetryer's sync methods hide InterruptedException and instead set an Interrupted flag, making exception handling non-idiomatic. The proposal is to make GrpcRetryer methods explicitly throw InterruptedException to enforce proper handling and make the code more idiomatic.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "retry-logic",
        "exception-handling"
      ],
      "concepts": [
        "InterruptedException",
        "retry",
        "GRPC",
        "StatusRuntimeException",
        "interrupted-flag",
        "idiomatic-java"
      ],
      "severity": "medium",
      "userImpact": "Users must be aware of hidden Interrupted flags and process them correctly, leading to brittle error handling code; explicit InterruptedException would enforce proper handling patterns.",
      "rootCause": "GrpcRetryer catches InterruptedException from timers and GRPC CANCELLED status, converting them to Interrupted flags instead of throwing the exception, which is non-idiomatic Java and error-prone.",
      "proposedFix": "Change GrpcRetryer methods to throw explicit InterruptedException instead of hiding it and setting an Interrupted flag, making the API idiomatic and enforcing correct exception handling.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "To make code more idiomatic and enforce the correct handling of InterruptedException and awareness of its possibility inside GrpcRetryer, we should change GrpcRetryer methods to throw explicit InterruptedExceptions.",
      "number": 661,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:32:54.730Z"
    },
    {
      "summary": "WorkflowExecutionUtils and GrpcRetryer don't respect gRPC deadline propagation from the context, causing them to ignore DEADLINE_EXCEEDED exceptions and continue retrying indefinitely even after the deadline has passed.",
      "category": "bug",
      "subcategory": "grpc-deadline-propagation",
      "apis": [
        "WorkflowExecutionUtils",
        "GrpcRetryer"
      ],
      "components": [
        "WorkflowExecutionUtils",
        "GrpcRetryer",
        "grpc-context-handling"
      ],
      "concepts": [
        "deadline",
        "grpc-context",
        "deadline-propagation",
        "timeout",
        "retry",
        "context-propagation"
      ],
      "severity": "high",
      "userImpact": "Users experience indefinite retry loops when gRPC deadlines expire, potentially causing 24-day delays before operations fail instead of failing immediately.",
      "rootCause": "WorkflowExecutionUtils ignores the absolute deadline in gRPC Context when calculating deadlines, and GrpcRetryer doesn't check if the current moment has passed the absolute deadline before retrying, resulting in ignored DEADLINE_EXCEEDED exceptions.",
      "proposedFix": "Check the absolute deadline from gRPC Context before calculating new deadlines and respect DEADLINE_EXCEEDED exceptions instead of retrying indefinitely.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue includes unit test reproductions demonstrating the problem with deadline handling across workflow execution and retry scenarios.",
      "related": [],
      "keyQuote": "gRPC ignores these new deadlines that are later than the current deadline already presented in the GRPC Context",
      "number": 653,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:32:54.910Z"
    },
    {
      "summary": "The getResult() timeout on WorkflowStub is not configurable through WorkflowOptions when using the proxy API. Currently, users must use the low-level stub API to set a custom timeout, while the proxy API defaults to Integer.MAX_VALUE, preventing reasonable timeouts from being enforced.",
      "category": "feature",
      "subcategory": "workflow-options",
      "apis": [
        "WorkflowStub",
        "WorkflowOptions",
        "WorkflowClient"
      ],
      "components": [
        "WorkflowStub",
        "WorkflowOptions",
        "workflow-proxy"
      ],
      "concepts": [
        "timeout",
        "configuration",
        "API design",
        "workflow-execution",
        "user-supplied-limits"
      ],
      "severity": "medium",
      "userImpact": "Users cannot enforce reasonable timeouts when calling workflows through the proxy API, limiting their ability to prevent indefinite blocking on getResult() calls.",
      "rootCause": "WorkflowOptions lacks a getResult timeout field; the proxy API hardcodes Integer.MAX_VALUE while only the low-level stub API allows custom timeouts.",
      "proposedFix": "Add a configurable getResult timeout field to WorkflowOptions that is used when calling the proxy API.",
      "workaround": "Use the low-level WorkflowStub API directly to set custom timeouts on getResult() calls.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        88
      ],
      "keyQuote": "We should allow defining the #getResult timeout on WorkflowOptions to allow the neat proxy API to enforce reasonable timeouts.",
      "number": 652,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:32:15.513Z"
    },
    {
      "summary": "WorkflowExecutionUtils#getInstanceCloseEvent lacks exponential backoff, causing clients to hammer the server during outages. The proposal is to add configurable retry behavior with backoff coefficients and maximum intervals.",
      "category": "feature",
      "subcategory": "workflow-utilities",
      "apis": [
        "WorkflowExecutionUtils#getInstanceCloseEvent"
      ],
      "components": [
        "WorkflowExecutionUtils",
        "retry-logic",
        "client-networking"
      ],
      "concepts": [
        "exponential-backoff",
        "retry-strategy",
        "server-outage",
        "rate-limiting",
        "client-resilience"
      ],
      "severity": "medium",
      "userImpact": "Clients can overwhelm servers during outages by repeatedly calling getInstanceCloseEvent without backoff, degrading system stability.",
      "rootCause": "No exponential backoff mechanism implemented in WorkflowExecutionUtils#getInstanceCloseEvent",
      "proposedFix": "Add backoffCoefficient parameter, set maximumInterval to reasonable value, and implement related issue #652 to allow workflow stub proxies to pass timeout parameters",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        652
      ],
      "keyQuote": "We have no exponential backoff on WorkflowExecutionUtils#getInstanceCloseEvent and we should add it to avoid clients hammering the server",
      "number": 651,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:32:15.199Z"
    },
    {
      "summary": "WorkflowExecutionUtils class lacks unit test coverage due to being untestable and unmockable. The class needs to be decoupled into testable pieces, starting with tests for the getInstanceCloseEvent method and issues fixed in PR #472.",
      "category": "feature",
      "subcategory": "testing",
      "apis": [
        "WorkflowExecutionUtils"
      ],
      "components": [
        "WorkflowExecutionUtils",
        "GrpcRetryer",
        "test-framework"
      ],
      "concepts": [
        "testability",
        "unit-testing",
        "mocking",
        "decoupling",
        "code-coverage"
      ],
      "severity": "medium",
      "userImpact": "Lack of unit tests for WorkflowExecutionUtils makes it difficult for users to verify correct behavior and contributes to lower code quality.",
      "rootCause": "WorkflowExecutionUtils is tightly coupled and not designed for testability or mocking.",
      "proposedFix": "Decouple WorkflowExecutionUtils into testable pieces and add unit tests for getInstanceCloseEvent.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was mostly resolved through extensive GrpcRetryer reworking and testing completed over the following months.",
      "related": [
        472
      ],
      "keyQuote": "This was mostly covered by extensive GrpcRetryer reworking and testing done in the last couple of months.",
      "number": 650,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:32:15.494Z"
    },
    {
      "summary": "Workflow.getVersion() calls during replays cause premature workflow task completion, leading to different task structures between original execution and replays. This breaks command-event matching for cancelations, causing replay failures when timers are canceled within the same workflow task.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "getVersion"
      ],
      "components": [
        "state-machine",
        "replay-handler",
        "workflow-task-handler",
        "command-matching"
      ],
      "concepts": [
        "replay",
        "state-machine",
        "command-event-matching",
        "workflow-task-structure",
        "cancelation",
        "timer-management"
      ],
      "severity": "critical",
      "userImpact": "Workflows using getVersion with timer cancelations fail to replay correctly, breaking determinism guarantees and preventing workflow execution recovery.",
      "rootCause": "getVersion waits until end of workflow task to match events and publish callbacks, causing workflow tasks to end prematurely during replay. This changes the task structure compared to original execution, misaligning command-event sequences.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Workflow.getVersion call during replays causes the end of workflow task every single time...This causes a difference in the structure of workflow tasks in the original run and its replays.",
      "number": 648,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:31:36.055Z"
    },
    {
      "summary": "Request to make the `ApplicationFailure#newFromValues` method public so developers can set the `cause` field on ApplicationFailure instances. Currently, the method is not accessible for public use.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [
        "ApplicationFailure"
      ],
      "components": [
        "exception-handling",
        "api-surface"
      ],
      "concepts": [
        "error-construction",
        "failure-cause",
        "exception-customization",
        "api-visibility"
      ],
      "severity": "low",
      "userImpact": "Developers cannot programmatically construct ApplicationFailure instances with specific cause information, limiting error handling flexibility.",
      "rootCause": null,
      "proposedFix": "Make `ApplicationFailure#newFromValues` method public",
      "workaround": "Error log prior to throwing ApplicationFailure",
      "resolution": "fixed",
      "resolutionDetails": "The method was made public to allow developers to construct ApplicationFailure instances with custom cause values.",
      "related": [],
      "keyQuote": "Would be nice to have access to `ApplicationFailure#newFromValues` so that we can set the `cause` on the ApplicationFailure.",
      "number": 647,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:31:34.227Z"
    },
    {
      "summary": "Workflow Task Completed events are unexpectedly being replayed and causing state machine failures in Java SDK benchmarks, particularly in the reactor_stress test with sticky worker eviction. The state machines receive duplicate events they've already processed, leading to workflow execution failures.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [],
      "components": [
        "state-machines",
        "replay-handler",
        "sticky-worker",
        "workflow-cache"
      ],
      "concepts": [
        "event-replay",
        "cache-eviction",
        "state-machine",
        "workflow-task",
        "sticky-queue",
        "history-replay"
      ],
      "severity": "high",
      "userImpact": "Workflows can fail or hang during query operations after cache eviction, causing timeouts in stress test scenarios and production workloads.",
      "rootCause": "When workflows are evicted from the cache and queried, the sticky queue contains events that are then replayed as part of the new workflow task. State machines don't allow partial histories to contain events already processed, causing IllegalArgumentException on duplicate EVENT_TYPE_WORKFLOW_TASK_COMPLETED events.",
      "proposedFix": "Two solutions identified: (1) State machines should allow partial histories to contain events already handled, and (2) Reset sticky queue on cache invalidation or eviction (related to issue #883).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by addressing state machine handling of duplicate events in partial histories and implementing sticky queue reset on cache eviction.",
      "related": [
        883
      ],
      "keyQuote": "State machines should allow partial histories sent with Workflow Tasks to contain events that were already handled",
      "number": 643,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:31:37.001Z"
    },
    {
      "summary": "NullPointerException occurring during performance tests in WorkflowThreadContext.runUntilBlocked(), indicating a potential multithreading issue or race condition in workflow execution.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "WorkflowThreadContext",
        "DeterministicRunnerImpl",
        "SyncWorkflow",
        "ReplayWorkflowExecutor"
      ],
      "concepts": [
        "multithreading",
        "race-condition",
        "null-pointer",
        "workflow-replay",
        "performance-testing",
        "event-loop"
      ],
      "severity": "high",
      "userImpact": "Users running performance tests experience crashes due to NPE in workflow execution, preventing load testing and performance validation.",
      "rootCause": "Potential race condition or partial publishing in multithreaded workflow execution context, causing null reference in runUntilBlocked method.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved, likely through fixing the race condition in the workflow threading implementation.",
      "related": [],
      "keyQuote": "NPE during performance tests that points to some multithreading issue / race / partial publishing",
      "number": 641,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:30:56.525Z"
    },
    {
      "summary": "TestWorkflowRule enforces a 10-second global timeout by default, which creates unnecessary friction for users and duplicates JUnit's built-in timeout capabilities. The proposal is to move timeout logic to the internal SDKTestWorkflowRule, remove it from the public TestWorkflowRule, and deprecate the functionality.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowRule",
        "SDKTestWorkflowRule",
        "test-infrastructure"
      ],
      "concepts": [
        "timeout",
        "test-configuration",
        "junit-integration",
        "api-design",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users must work around or disable the default 10-second timeout unnecessarily, reducing developer productivity.",
      "rootCause": "TestWorkflowRule conflates SDK test infrastructure concerns with user-facing test utilities, enforcing a timeout that duplicates JUnit capabilities.",
      "proposedFix": "Move timeout implementation to internal SDKTestWorkflowRule, remove from public TestWorkflowRule, deprecate timeout functionality in public API with removal planned for the release after next.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Timeout logic was relocated to internal SDKTestWorkflowRule and removed from public TestWorkflowRule API.",
      "related": [],
      "keyQuote": "Move existing global timeout implementation into Temporal internal `SDKTestWorkflowRule`. Remove logic of TestWorkflowRule that enforces timeout.",
      "number": 634,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:30:56.177Z"
    },
    {
      "summary": "TestWorkflowRule enforces a 10-second timeout by default for tests, which is problematic during debugging. The request is to disable this timeout when the TEMPORAL_DEBUG environment variable is present to improve developer productivity.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowRule",
        "test-framework",
        "debugging"
      ],
      "concepts": [
        "timeout",
        "testing",
        "debugging",
        "environment-variable",
        "productivity",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers debugging tests are forced to wait for or work around the 10-second timeout, reducing debugging productivity.",
      "rootCause": null,
      "proposedFix": "Disable TestWorkflowRule timeout when TEMPORAL_DEBUG environment variable is present",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Enhancement implemented to disable timeouts when TEMPORAL_DEBUG env variable is set",
      "related": [],
      "keyQuote": "This is useful during running a build with all tests, but it's annoying for debugging and hurts productivity.",
      "number": 632,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:30:54.976Z"
    },
    {
      "summary": "DeterministicRunner logs noisy warnings about unaccessed cancelled scopes and timers, even though this is expected behavior. When a cancellation scope is cancelled, it's normal that promises created within it won't be accessed, so the warning should be suppressed in these cases.",
      "category": "bug",
      "subcategory": "deterministic-runner",
      "apis": [],
      "components": [
        "DeterministicRunner",
        "CancellationScope",
        "Promise"
      ],
      "concepts": [
        "cancellation",
        "exception-handling",
        "determinism",
        "logging",
        "promise-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users see unnecessary warning logs that obscure actual issues and create noise in production logs.",
      "rootCause": "DeterministicRunner warns about all unaccessed failed promises without distinguishing between legitimate cancellation scenarios and actual problems that need attention.",
      "proposedFix": "Suppress or modify the warning when a promise failure is due to cancellation scope cancellation, since not accessing promises in a cancelled scope is expected behavior.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If the cancellation scope is canceled, it should be normal and expected to don't access the promises created in this scope and the logic above shouldn't be noisy about it.",
      "number": 631,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:30:17.174Z"
    },
    {
      "summary": "Test `testShouldReturnQueryResultAfterWorkflowTimeout` is flaky and fails with 'Unknown query type' error when querying a workflow after it times out. The root cause is that query handlers are not reinitialized during workflow replay after a timeout, leaving the QueryDispatcher empty.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "query"
      ],
      "components": [
        "QueryDispatcher",
        "ReplayWorkflowExecutor",
        "WorkflowTaskStateMachine",
        "TestWorkflowEnvironmentInternal"
      ],
      "concepts": [
        "timeout",
        "replay",
        "query-handler",
        "event-loop",
        "state-machine",
        "flaky-test"
      ],
      "severity": "medium",
      "userImpact": "Users cannot query workflows after they timeout, and tests for this behavior are unreliable and difficult to reproduce.",
      "rootCause": "When workflow task times out and history is replayed, a new QueryDispatcher is created without query handlers. The event loop is not triggered during replay, preventing workflow from reinitializing query handlers.",
      "proposedFix": "Trigger event loop during replay to reinitialize query handlers, or move query handler initialization earlier so it executes during replay phase.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        391,
        531
      ],
      "keyQuote": "It creates a brand new QueryDispatcher object that doesn't have query handlers by default, and because we never run event loop during replay workflow doesn't get a chance to initialize query handlers again.",
      "number": 630,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:30:16.784Z"
    },
    {
      "summary": "TestWorkflowEnvironment's getResult() hangs indefinitely after terminate() instead of throwing WorkflowFailedException like the real server does. The test environment should match production behavior when a workflow is terminated.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowStub.getResult()",
        "WorkflowStub.terminate()"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "workflow-stub",
        "test-harness"
      ],
      "concepts": [
        "termination",
        "exception-handling",
        "test-behavior-parity",
        "blocking-operation",
        "timeout"
      ],
      "severity": "high",
      "userImpact": "Tests using TestWorkflowEnvironment hang when calling getResult() on terminated workflows, making it difficult to properly test termination scenarios.",
      "rootCause": "TestWorkflowEnvironment does not properly simulate server behavior when a workflow is terminated, failing to throw WorkflowFailedException immediately",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Against the real temporal server, calling WorkflowStub.getResult() for a workflow that has been terminated immediately throws a WorkflowFailedException. The test environment should behave the same way.",
      "number": 628,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:30:15.572Z"
    },
    {
      "summary": "Testing activities that constantly fail with large timeout values causes excessive retries (thousands) in test framework, slowing down tests. Request to add option to limit retries or skip time during testing to handle this edge case.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ActivityOptions",
        "RetryOptions"
      ],
      "components": [
        "test-framework",
        "activity-retry",
        "test-environment"
      ],
      "concepts": [
        "timeout",
        "retry",
        "testing",
        "activity-failure",
        "time-skipping",
        "test-performance"
      ],
      "severity": "medium",
      "userImpact": "Tests run extremely slowly when activities fail with long timeouts, requiring thousands of retries before timeout, making the testing experience cumbersome.",
      "rootCause": "Test framework applies realistic retry behavior based on timeout duration, so 5-day timeout with 1-second retry interval results in ~432,000 retries during time-skipping.",
      "proposedFix": "Add ability to override ActivityOptions (specifically RetryOptions#maxRetries) in test framework to limit retries, or provide built-in test mode that defaults maxRetries to a reasonable value like 1.",
      "workaround": "Manually set ActivityOptions#RetryOptions#maxRetries=1 for test scenarios, though this requires modifying workflow code or using environment variable detection.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        499
      ],
      "keyQuote": "Ability to overwrite whole/parts of the activity options in the test (when ActivityOptions are defined inside the tested workflow code).",
      "number": 626,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:29:36.983Z"
    },
    {
      "summary": "Use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` as the cause when responding to failed workflow tasks that result from non-deterministic user workflow logic. This aligns the Java SDK with the Temporal server's error classification.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "RespondWorkflowTaskFailed"
      ],
      "components": [
        "workflow-task-handler",
        "error-handling"
      ],
      "concepts": [
        "non-determinism",
        "workflow-replay",
        "error-classification",
        "failure-reporting"
      ],
      "severity": "low",
      "userImpact": "Enables clearer error diagnosis by properly classifying non-deterministic workflow failures with the appropriate error cause code.",
      "rootCause": null,
      "proposedFix": "Use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` as the cause value in `RespondWorkflowTaskFailed` when non-deterministic workflow logic is detected.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented to use the correct error cause for non-deterministic workflow failures, aligning with server-side error classification.",
      "related": [
        1726
      ],
      "keyQuote": "use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` as cause for `RespondWorkflowTaskFailed` if user workflow logic is non-deterministic",
      "number": 625,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:29:35.597Z"
    },
    {
      "summary": "Add support for upsert memo operations during workflow execution. Currently, users can only set memo at workflow start time, but they should be able to modify/upsert memo during execution using the existing ModifyWorkflowPropertiesCommandAttributes command.",
      "category": "feature",
      "subcategory": "workflow-properties",
      "apis": [
        "ModifyWorkflowPropertiesCommandAttributes"
      ],
      "components": [
        "workflow-execution",
        "memo-management",
        "command-handler"
      ],
      "concepts": [
        "memo",
        "workflow-properties",
        "upsert",
        "visibility",
        "execution-modification"
      ],
      "severity": "medium",
      "userImpact": "Users can optimize API requests by updating memo during workflow execution instead of only at start time, enabling better advanced visibility patterns.",
      "rootCause": null,
      "proposedFix": "Implement upsert memo support using the existing ModifyWorkflowPropertiesCommandAttributes command during workflow execution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented in the Java SDK to allow memo modification during workflow execution.",
      "related": [],
      "keyQuote": "Workflow Executions should have an ability to modify/upsert the memo during the execution, not just at the start time.",
      "number": 623,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:29:35.689Z"
    },
    {
      "summary": "OpenTracing integration with Jaeger tracer fails with UnsupportedFormatException for TEXT_MAP_INJECT format. The Java SDK's OpenTracing support is incompatible with Jaeger client's format handling strategy.",
      "category": "bug",
      "subcategory": "opentracing-integration",
      "apis": [],
      "components": [
        "opentracing",
        "tracer",
        "jaeger-client"
      ],
      "concepts": [
        "opentracing",
        "distributed-tracing",
        "jaeger",
        "format-encoding",
        "text-map-codec"
      ],
      "severity": "high",
      "userImpact": "Users cannot use Jaeger tracer with the Java SDK's OpenTracing support due to format incompatibility.",
      "rootCause": "Jaeger OpenTracing Java client does not support TEXT_MAP_INJECT and TEXT_MAP_EXTRACT format strategies that the Temporal SDK requires.",
      "proposedFix": "Implement a workaround encoding strategy in the Temporal SDK to work around Jaeger client's format limitations.",
      "workaround": "Use alternative tracer implementation or wait for Jaeger client fix.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #624 with a workaround for Jaeger client format incompatibility and integration test.",
      "related": [
        624,
        789
      ],
      "keyQuote": "Jaeger OpenTracing java client doesn't support TEXT_MAP_INJECT and TEXT_MAP_EXTRACT strategies",
      "number": 621,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:28:56.401Z"
    },
    {
      "summary": "Java SDK logs ERROR-level exceptions when a load balancer closes idle polling connections, causing log spam despite no functional impact. The SDK should recognize these as harmless transient errors and log them at DEBUG level instead.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "poller",
        "grpc-retryer",
        "error-handler"
      ],
      "concepts": [
        "idle-timeout",
        "load-balancer",
        "connection-management",
        "logging-level",
        "transient-errors",
        "retry-logic"
      ],
      "severity": "medium",
      "userImpact": "Excessive ERROR-level logging clogs application logs and forces users to disable Poller logger entirely to suppress false alarms.",
      "rootCause": "The Poller's error handler treats all gRPC UNAVAILABLE errors the same way and logs them at ERROR level, even when they are expected transient failures from load balancer idle timeouts that the SDK recovers from automatically.",
      "proposedFix": "Change the default log level for sync retrier exceptions from WARN to DEBUG, so transient connection errors are logged at a lower level while actual failures after retry exhaustion are still logged at INFO+ level.",
      "workaround": "Disable logging from the Poller logger entirely to suppress the error messages.",
      "resolution": "fixed",
      "resolutionDetails": "Log level for gRPC retry errors was adjusted from WARN to DEBUG as part of other work to reduce noise from transient connection failures.",
      "related": [],
      "keyQuote": "Probably this error could be recognized as harmless and logged at a lower logging level?",
      "number": 618,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:28:57.436Z"
    },
    {
      "summary": "WorkflowInfo.getSearchAttributes() currently returns serialized protobuf data, making it difficult for users to read and interpret. Users need deserialized search attributes in an easily consumable format.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [
        "WorkflowInfo.getSearchAttributes"
      ],
      "components": [
        "workflow-info",
        "search-attributes",
        "serialization"
      ],
      "concepts": [
        "deserialization",
        "search-attributes",
        "protobuf",
        "api-usability",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily interpret search attributes returned from WorkflowInfo without manual protobuf deserialization.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Search attributes were updated to be deserialized and returned in a user-friendly format instead of raw protobuf.",
      "related": [],
      "keyQuote": "WorkflowInfo.getSearchAttributes return something that can be easily read/interpreted by the user",
      "number": 617,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:28:55.515Z"
    },
    {
      "summary": "State Machine fails to handle certain corner cases with Workflow.getVersion calls, as demonstrated in PR #583. The versioning logic does not correctly process all scenarios.",
      "category": "bug",
      "subcategory": "workflow-versioning",
      "apis": [
        "Workflow.getVersion"
      ],
      "components": [
        "state-machine",
        "workflow-versioning",
        "version-handler"
      ],
      "concepts": [
        "state-machine",
        "versioning",
        "corner-cases",
        "workflow-execution",
        "backward-compatibility",
        "replay",
        "history-reconciliation"
      ],
      "severity": "high",
      "userImpact": "Users implementing workflow versioning may encounter incorrect behavior when using Workflow.getVersion in specific edge case scenarios, potentially breaking workflow replay and version compatibility.",
      "rootCause": "State Machine implementation has gaps in handling certain corner cases of Workflow.getVersion calls during workflow execution.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed through the PR #583 reproduction case analysis and subsequent fixes to state machine versioning logic.",
      "related": [
        583
      ],
      "keyQuote": "There is a reproduction submitted in https://github.com/temporalio/sdk-java/pull/583 which demonstrates some corner cases with our State Machines fail to handle `Workflow.getVersion` calls correctly.",
      "number": 615,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:28:16.813Z"
    },
    {
      "summary": "When a workflow stub is created using a workflowId, calling a workflow method should block waiting for the result if a workflow with that ID is already running, rather than throwing an exception. Currently it throws an exception instead.",
      "category": "feature",
      "subcategory": "workflow-stub",
      "apis": [
        "WorkflowClient.newWorkflowStub"
      ],
      "components": [
        "workflow-client",
        "workflow-stub",
        "workflow-id-reuse"
      ],
      "concepts": [
        "workflow-reconnection",
        "synchronous-execution",
        "workflow-id-reuse-policy",
        "blocking-call",
        "workflow-completion"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably wait for workflow completion when reconnecting to existing workflows by ID, forcing them to handle exceptions instead of blocking naturally.",
      "rootCause": null,
      "proposedFix": "Modify the workflow stub to block and wait for the workflow result when invoked with an existing workflowId, only throwing an exception if no workflow with that ID exists.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When a workflow stub is created by a workflowId and the workflow method is invoked then the call should block waiting for a workflow result if a workflow with the given id is already running.",
      "number": 613,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:28:17.142Z"
    },
    {
      "summary": "JUnit's @Test(timeout) annotation should override the default 10-second timeout set on SDKTestWorkflowRule, but currently it doesn't. Users must work around this by setting a different timeout on the rule itself, which affects all tests in the class.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "SDKTestWorkflowRule",
        "test-timeout",
        "junit-integration"
      ],
      "concepts": [
        "timeout",
        "test-configuration",
        "annotation-override",
        "junit-integration",
        "testing"
      ],
      "severity": "medium",
      "userImpact": "Test developers cannot use standard JUnit timeout annotations to override per-test timeouts, forcing them to modify rule-level settings that affect all tests.",
      "rootCause": "SDKTestWorkflowRule does not respect or check for @Test(timeout) annotations on individual test methods.",
      "proposedFix": "JUnit @Test(timeout) annotation should be detected and used to override the rule's default timeout setting.",
      "workaround": "Set a different timeout in SDKTestWorkflowRule.newBuilder().setTestTimeoutSeconds(15).build(), but this affects all tests in the class.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "JUnit @Test(timeout) should override timeouts set on the SDKTestWorkflowRule, which is 10s by default.",
      "number": 612,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:28:17.104Z"
    },
    {
      "summary": "GRPC falls into in-process server long polls after thread interruption, causing Worker Poller threads to hang during graceful shutdown. This occurs only with the in-process test server and specific timing conditions where long poll tasks are submitted after thread interruption.",
      "category": "bug",
      "subcategory": "test-server",
      "apis": [
        "pollWorkflowTaskQueue"
      ],
      "components": [
        "worker-poller",
        "grpc-client",
        "test-service",
        "thread-pool"
      ],
      "concepts": [
        "interruption",
        "graceful-shutdown",
        "long-polling",
        "in-process-server",
        "thread-synchronization",
        "deadlock"
      ],
      "severity": "high",
      "userImpact": "Tests hang unpredictably during shutdown when using the in-process test server, making the test suite flaky and unreliable.",
      "rootCause": "GRPC swallows InterruptedException and continues execution, allowing a long poll task from another poller thread to be submitted to the interrupted thread's executor, causing the thread to block in the GRPC in-process server implementation.",
      "proposedFix": null,
      "workaround": "Trigger shutdown of GRPC in-process Temporal server before shutting down workers to prevent GRPC client from falling into a long poll after interruption.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        455,
        601
      ],
      "keyQuote": "Interruption in the client thread ends up ignored and a Poller thread falls into a long poll inside the in-process GRPC server implementation.",
      "number": 608,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:27:38.351Z"
    },
    {
      "summary": "Request to automate pre-release SDK testing against samples-java and canary-java repositories. Currently this testing is performed manually and needs to be automated as part of the release process.",
      "category": "feature",
      "subcategory": "testing-automation",
      "apis": [],
      "components": [
        "ci-cd",
        "testing-infrastructure",
        "release-process"
      ],
      "concepts": [
        "automation",
        "pre-release",
        "testing",
        "canary",
        "samples",
        "quality-assurance"
      ],
      "severity": "medium",
      "userImpact": "Automated pre-release testing ensures SDK quality and compatibility with sample applications before release, reducing risk of regressions reaching users.",
      "rootCause": null,
      "proposedFix": "Automate the testing process (specific implementation details not provided in discussion).",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Moved to internal infrastructure/Notion as it is an internal process rather than a user-facing feature or bug fix.",
      "related": [],
      "keyQuote": "It's an internal infrastructure related issue, please move to Notion.",
      "number": 607,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:27:36.540Z"
    },
    {
      "summary": "User requested the ability to set custom ContextPropagators on LocalActivityOptions, similar to ActivityOptions. This was marked invalid as a duplicate of issue #490, with the resolution that ContextPropagators should be configured via WorkerOptions instead.",
      "category": "feature",
      "subcategory": "context-propagation",
      "apis": [
        "LocalActivityOptions",
        "ActivityOptions",
        "ContextPropagator",
        "WorkerOptions"
      ],
      "components": [
        "local-activity",
        "activity-options",
        "context-propagation",
        "worker-configuration"
      ],
      "concepts": [
        "context-propagation",
        "cross-cutting-concerns",
        "activity-configuration",
        "client-side-behavior",
        "worker-setup"
      ],
      "severity": "low",
      "userImpact": "Users cannot set context propagators per local activity and must configure them globally at the worker level instead.",
      "rootCause": "ContextPropagators are fundamentally client-side only and cannot be applied on the worker side, making per-activity configuration unnecessary.",
      "proposedFix": null,
      "workaround": "Use WorkerOptions#contextPropagators to configure context propagators globally instead of per activity.",
      "resolution": "duplicate",
      "resolutionDetails": "Duplicate of issue #490. Resolved by clarifying that ContextPropagators are client-side only and should be configured via WorkerOptions, not per activity.",
      "related": [
        490
      ],
      "keyQuote": "ActivityOptions#contextPropagators stay on the client-side only and can't be applied on a worker side. Use WorkerOptions#contextPropagators instead.",
      "number": 600,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:27:37.517Z"
    },
    {
      "summary": "MDC (Mapped Diagnostic Context) entries like WorkflowId and RunId were not being propagated to LocalActivities, causing logging context information to be missing when local activities were invoked. The ActivityWorker had MDC setup code that was absent in LocalActivityWorker.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [],
      "components": [
        "LocalActivityWorker",
        "ActivityWorker",
        "MDC"
      ],
      "concepts": [
        "logging",
        "context-propagation",
        "diagnostic-context",
        "local-activities",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access workflow context information (WorkflowId, RunId) in logs from local activities, making debugging and tracing execution flow difficult.",
      "rootCause": "LocalActivityWorker.handle() method was missing MDC setup code that was present in ActivityWorker, preventing context propagation to local activity threads.",
      "proposedFix": "Add the MDC setup section from ActivityWorker (line 182) to LocalActivityWorker.handle() method",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "This was a duplicate of issue #489 which had already been fixed. A unit test was added to verify MDC propagation to local activities.",
      "related": [
        489
      ],
      "keyQuote": "This a duplicate of https://github.com/temporalio/sdk-java/issues/489 and it's fixed. We also have a unit test checking exactly MDC propagation to local activities",
      "number": 599,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:26:58.318Z"
    },
    {
      "summary": "Assertions that fail in TestWorkflowEnvironment.registerDelayedCallback are swallowed instead of propagating to the test, causing tests that should fail to succeed with only error logs.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowEnvironment",
        "registerDelayedCallback"
      ],
      "components": [
        "test-environment",
        "timer-callback",
        "assertion-handling"
      ],
      "concepts": [
        "test-failure",
        "error-propagation",
        "callback-execution",
        "assertion",
        "testing"
      ],
      "severity": "medium",
      "userImpact": "Test developers cannot rely on assertions in delayed callbacks to properly fail tests, making it difficult to catch bugs in callback logic.",
      "rootCause": "The SelfAdvancingTimerImpl catches exceptions in timer callbacks and logs them as errors instead of propagating them to fail the test.",
      "proposedFix": "Propagate the error from the callback to the test method so assertions properly fail the test.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When assertions fail in TestWorkflowEnvironment.registerDelayedCallback, the errors in the callback are swallowed. This is counterintuitive.",
      "number": 597,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:26:57.976Z"
    },
    {
      "summary": "Signal method overloading is rejected even when @SignalMethod(name=...) assigns different signal names. The validation logic doesn't consider the signal name annotation when checking for duplicate methods, preventing legitimate method overloads.",
      "category": "bug",
      "subcategory": "signal-methods",
      "apis": [
        "SignalMethod"
      ],
      "components": [
        "signal-validation",
        "method-dispatcher",
        "annotation-processor"
      ],
      "concepts": [
        "method-overloading",
        "signal-routing",
        "annotation-handling",
        "duplicate-detection",
        "method-signatures"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot use method overloading with different signal names, forcing them to use different method names or refactor their signal handler interfaces.",
      "rootCause": "The duplicate method validation logic checks method signatures (name and parameters) but does not account for @SignalMethod(name=...) annotations that map methods to different signal names.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "I can give a Signal Method a name via @SignalMethod(name = \"foo\"), but the name is not considered when evaluating if a signal method already exists or not.",
      "number": 591,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:26:57.182Z"
    },
    {
      "summary": "Worker identity is not being recorded in the lastWorkerIdentity field during activity heartbeats. The field remains empty instead of containing the worker's identity information.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "worker",
        "heartbeat",
        "activity-executor"
      ],
      "concepts": [
        "worker-identity",
        "heartbeat",
        "monitoring",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot identify which worker executed an activity when reviewing heartbeat records, reducing observability and debugging capability.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by implementing worker identity recording during heartbeat operations.",
      "related": [],
      "keyQuote": "lastWorkerIdentity is not empty",
      "number": 590,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:26:16.405Z"
    },
    {
      "summary": "User requested the ability to set TEMPORAL_DEBUG via code instead of environment variables, to simplify debugging workflows in tests without needing multiple IDE run configurations.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowExtension"
      ],
      "components": [
        "test-framework",
        "workflow-client",
        "junit-extensions"
      ],
      "concepts": [
        "debugging",
        "test-configuration",
        "environment-variables",
        "deadlock-detection",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers can debug workflows in tests more easily without creating multiple IDE run configurations.",
      "rootCause": null,
      "proposedFix": "Add a setDebug(boolean) method to TestWorkflowExtension.Builder or similar API to enable TEMPORAL_DEBUG programmatically.",
      "workaround": "Use WorkerOptions.Builder#setDefaultDeadlockDetectionTimeout to override the deadlock detector timeout in tests instead.",
      "resolution": "fixed",
      "resolutionDetails": "User discovered that WorkerOptions.Builder#setDefaultDeadlockDetectionTimeout provides sufficient functionality for their use case, addressing the underlying need.",
      "related": [],
      "keyQuote": "Make `TEMPORAL_DEBUG` definable via code while setting up either the workflow client (or whatever), or optionally, via the Junit4/5 extensions.",
      "number": 588,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:26:18.128Z"
    },
    {
      "summary": "Add TemporalChangeVersion search attribute to Java SDK when workflow version is updated, enabling users to query workflows by their version state. This feature is already implemented in the Go SDK but missing from Java.",
      "category": "feature",
      "subcategory": "workflow-versioning",
      "apis": [
        "Workflow.upsertTypedSearchAttributes",
        "Workflow.getVersion"
      ],
      "components": [
        "workflow-versioning",
        "search-attributes",
        "history-events"
      ],
      "concepts": [
        "workflow-versioning",
        "search-attributes",
        "query-workflows",
        "backwards-compatibility",
        "state-machine"
      ],
      "severity": "high",
      "userImpact": "Users cannot query running workflows by their version state in Java SDK, limiting visibility into version deployment across workflows.",
      "rootCause": "Java SDK versioning implementation differs significantly from Go SDK; versioning state machine is complex and writing search attributes creates non-deterministic workflow changes when removing old version code paths.",
      "proposedFix": "Set TemporalChangeVersion search attribute to the changeid-version when a new version is set on workflow, similar to Go SDK implementation.",
      "workaround": "Use workflow history markers to query version information, though this requires custom querying logic not provided by SDK.",
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to set TemporalChangeVersion search attribute when workflow version is updated.",
      "related": [],
      "keyQuote": "This is a really needed feature when using workflow versioning. It works in Go SDK already.",
      "number": 587,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:26:18.878Z"
    },
    {
      "summary": "Activities advised with AspectJ are not recognized as implementing @ActivityInterface when Spring CGLIB proxies create wrapper classes. The SDK's metadata validation fails because it receives the proxy class instead of the actual implementation class.",
      "category": "bug",
      "subcategory": "activity-registration",
      "apis": [
        "registerActivitiesImplementations"
      ],
      "components": [
        "worker",
        "activity-registration",
        "metadata-validation",
        "spring-integration"
      ],
      "concepts": [
        "aop-proxying",
        "cglib-enhancement",
        "interface-detection",
        "spring-beans",
        "reflection"
      ],
      "severity": "high",
      "userImpact": "Spring Boot applications using @Aspect advisors on Activity implementations fail to start with IllegalArgumentException.",
      "rootCause": "POJOActivityImplMetadata validation uses Class.getInterfaces() which returns empty for CGLIB proxies because the proxy class doesn't directly implement @ActivityInterface - the target does.",
      "proposedFix": "Enhance interface detection to unwrap CGLIB proxies and check the target class's interfaces, or support interface specification via ProxyFactory customization.",
      "workaround": "Create a custom AnnotationAwareAspectJAutoProxyCreator that adds the @ActivityInterface to the ProxyFactory before creating the proxy.",
      "resolution": "fixed",
      "resolutionDetails": "The SDK was updated to detect and handle proxied activity implementations by checking the target class when a proxy is encountered.",
      "related": [],
      "keyQuote": "Class doesn't implement any non empty interface annotated with @ActivityInterface: com.example.test.InitialActivityImpl$$EnhancerBySpringCGLIB$$10ca071e",
      "number": 586,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:25:39.702Z"
    },
    {
      "summary": "WorkflowStub.getResult() skips timers in TestEnv without requiring testEnv.sleep(). User expected the second timer to wait 10 minutes but it completes immediately after the first timer, suggesting time-skipping behavior that wasn't documented.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowStub",
        "getResult",
        "Workflow.await",
        "Workflow.sleep"
      ],
      "components": [
        "test-environment",
        "time-locking-interceptor",
        "workflow-stub"
      ],
      "concepts": [
        "time-skipping",
        "timer",
        "test-execution",
        "synchronous-waiting",
        "workflow-completion"
      ],
      "severity": "low",
      "userImpact": "Users testing workflows with multiple timers may be confused by automatic time-skipping behavior in TestEnv that differs from documented expectations.",
      "rootCause": "TimeLockingInterceptor enables unlimited time skipping after getResult() is called to simplify test writing, which causes subsequent timers to complete immediately without explicit testEnv.sleep() calls.",
      "proposedFix": null,
      "workaround": "Call testEnv.sleep() explicitly for each timer duration instead of relying on getResult() to handle all time advancement.",
      "resolution": "invalid",
      "resolutionDetails": "Maintainer clarified this is intentional behavior (not a bug) implemented via TimeLockingInterceptor to remove frustration from unit test writers. When getResult() is called, the framework automatically skips time until workflow completion.",
      "related": [],
      "keyQuote": "This is actually not a bug, but a feature. It's implemented in `TimeLockingInterceptor` that is used by default in the test environment.",
      "number": 578,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:25:39.345Z"
    },
    {
      "summary": "Test hangs when workflowExecutionTimeout is set on workflow options and testEnv.sleep() is used in the same test. The timeout conflicts with the test environment's time advancement mechanism, causing deadlock.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowOptions",
        "TestWorkflowEnvironment",
        "WorkflowClient",
        "WorkflowStub"
      ],
      "components": [
        "test-environment",
        "workflow-execution",
        "timeout-handler",
        "time-advancement"
      ],
      "concepts": [
        "timeout",
        "test-execution",
        "time-advancement",
        "deadlock",
        "workflow-execution",
        "test-harness"
      ],
      "severity": "high",
      "userImpact": "Users cannot set workflowExecutionTimeout in test environments when using testEnv.sleep(), blocking the use of this standard feature in tests.",
      "rootCause": "workflowExecutionTimeout conflicts with testEnv.sleep() time advancement mechanism, causing the test to deadlock instead of progressing",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the interaction between workflowExecutionTimeout and test environment time advancement",
      "related": [],
      "keyQuote": "setting this makes the test hang... this normally works outside of TestWorkflowEnv",
      "number": 577,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:25:37.910Z"
    },
    {
      "summary": "TestEnv fails when signaling a terminated external workflow execution from another workflow, throwing a FAILED_PRECONDITION error about adding an event after completion instead of properly signaling ApplicationFailure like it does for closed workflows.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "signal",
        "newExternalWorkflowStub",
        "terminate",
        "getResult"
      ],
      "components": [
        "test-environment",
        "workflow-execution",
        "external-workflow-signal",
        "mutable-state"
      ],
      "concepts": [
        "external-workflow",
        "signal-handling",
        "workflow-termination",
        "event-state",
        "test-simulation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test scenarios where one workflow signals a terminated external workflow in TestEnv, breaking test coverage for error handling.",
      "rootCause": "TestWorkflowMutableStateImpl incorrectly handles signaling to terminated workflows by attempting to add a WORKFLOW_EXECUTION_SIGNALED event after the workflow has already completed, violating the event state machine.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was fixed by properly handling signal events to terminated workflows in the test service's mutable state implementation.",
      "related": [],
      "keyQuote": "FAILED_PRECONDITION: Attempt to add an eBuilder after a completion eBuilder: event_type: EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED",
      "number": 576,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:24:59.214Z"
    },
    {
      "summary": "Local activity failures are incorrectly incremented under the temporal_activity_execution_failed counter instead of the temporal_local_activity_failed counter, causing metric tracking to be inaccurate for systems using only local activities.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "local-activity",
        "metrics",
        "activity-executor"
      ],
      "concepts": [
        "metrics",
        "counter",
        "local-activity",
        "monitoring",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot accurately track local activity failures through metrics, making it difficult to monitor and debug issues in systems using only local activities.",
      "rootCause": "The local activity failure metric is routed to the wrong counter (temporal_activity_execution_failed instead of temporal_local_activity_failed).",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The metric counter routing for local activity failures was corrected to use the appropriate temporal_local_activity_failed counter.",
      "related": [],
      "keyQuote": "The temporal_activity_execution_failed counter is incremented instead.",
      "number": 555,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:24:56.678Z"
    },
    {
      "summary": "WorkflowReplayer cannot parse workflow history JSON exported by tctl because the event type names differ from what the Java SDK expects. The tctl output uses EVENT_TYPE_ prefixes (e.g., EVENT_TYPE_WORKFLOW_EXECUTION_STARTED) while WorkflowReplayer expects names without the prefix (e.g., WORKFLOW_EXECUTION_STARTED).",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "WorkflowReplayer"
      ],
      "components": [
        "workflow-replayer",
        "testing",
        "history-parsing"
      ],
      "concepts": [
        "workflow-history",
        "json-format",
        "event-serialization",
        "testing-tools",
        "tctl-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot replay workflow executions using history JSON exported from tctl, limiting testing and debugging capabilities.",
      "rootCause": "Mismatch between the event type naming convention used by tctl export (EVENT_TYPE_* prefix) and the naming convention expected by WorkflowReplayer.",
      "proposedFix": "Update WorkflowReplayer to accept the event type names generated by tctl, or update the JSON export format to match the expected naming convention.",
      "workaround": "Manually reformat the tctl JSON output to use the expected event type names before passing to WorkflowReplayer.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #729, which resolved the event naming mismatch.",
      "related": [
        729
      ],
      "keyQuote": "cannot be used for the Java SDK WorkflowReplayer... main difference are the event names, for example: EVENT_TYPE_WORKFLOW_EXECUTION_STARTED instead of WORKFLOW_EXECUTION_STARTED",
      "number": 553,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:24:58.313Z"
    },
    {
      "summary": "ProtobufJsonPayloadConverter is using a default JsonFormat.Printer instead of the custom printer passed through the constructor, due to a variable shadowing issue on line 60.",
      "category": "bug",
      "subcategory": "payload-conversion",
      "apis": [],
      "components": [
        "ProtobufJsonPayloadConverter",
        "JsonFormat.Printer",
        "payload-converter"
      ],
      "concepts": [
        "serialization",
        "protobuf",
        "json-conversion",
        "configuration",
        "variable-shadowing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot customize the JSON serialization behavior of Protocol Buffer payloads when using ProtobufJsonPayloadConverter.",
      "rootCause": "Variable shadowing: a local JsonFormat.Printer is created on line 60, shadowing the instance field printer that holds the custom configuration.",
      "proposedFix": "Use the instance field printer instead of creating a new default printer on line 60.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The variable shadowing issue was fixed to use the custom printer passed through the constructor.",
      "related": [],
      "keyQuote": "ProtobufJsonPayloadConverter using predefined (passed through constructor) JsonFormat.Printer",
      "number": 551,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:24:17.018Z"
    },
    {
      "summary": "Open tracing span context is not propagated when activities or child workflows are invoked asynchronously, resulting in isolated traces instead of a continuous trace chain. The issue was fixed for both Kotlin method references and async lambdas.",
      "category": "bug",
      "subcategory": "distributed-tracing",
      "apis": [
        "Async.procedure",
        "Async.function",
        "StartChildWorkflowExecution"
      ],
      "components": [
        "opentracing",
        "async-invocation",
        "context-propagation",
        "child-workflow"
      ],
      "concepts": [
        "span-context",
        "trace-propagation",
        "async-execution",
        "observability",
        "distributed-tracing",
        "kotlin-interop"
      ],
      "severity": "high",
      "userImpact": "Users cannot correlate async activity and child workflow execution with parent workflow traces, making debugging and monitoring distributed workflows difficult.",
      "rootCause": "Span context was not being propagated through the async invocation mechanism for both lambda-based and method reference-based async calls.",
      "proposedFix": null,
      "workaround": "Use synchronous activity/workflow invocation instead of async patterns for tracing to work correctly.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed span context propagation for both Kotlin method references and async lambdas. Tests were added in da1a432 to verify OT context propagation to child workflows.",
      "related": [],
      "keyQuote": "Result trace for the main WF doesn't contain spans for async activities / child WF - their execution is represented in isolated traces instead.",
      "number": 537,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:24:18.813Z"
    },
    {
      "summary": "Request to add thread pool metrics for the pollExecutor to help understand SDK thread usage and tune workers. The main challenge is identifying worker groups consistently across process deployments while maintaining unique identity per worker.",
      "category": "feature",
      "subcategory": "metrics-monitoring",
      "apis": [
        "WorkflowClientOptions"
      ],
      "components": [
        "poller",
        "thread-pool",
        "metrics",
        "worker"
      ],
      "concepts": [
        "thread-pool-metrics",
        "monitoring",
        "observability",
        "worker-identity",
        "performance-tuning",
        "resource-tracking"
      ],
      "severity": "medium",
      "userImpact": "Enables users to monitor thread pool usage and tune worker performance more effectively through deterministic metric tags that persist across deployments.",
      "rootCause": "Current identity scheme uses process-unique values, preventing metric correlation across worker instances and deployments.",
      "proposedFix": "Add an optional 'identityGroup' property to WorkflowClientOptions to provide a static, non-unique identifier for grouping workers across processes for metric correlation.",
      "workaround": "Users could set a static identity value, but this would lose the ability to identify individual pollers uniquely.",
      "resolution": "fixed",
      "resolutionDetails": "Rob was able to solve the problem using existing APIs and capabilities that Temporal provides.",
      "related": [],
      "keyQuote": "what I'm describing is impossible if there is more than 1 poller in the process. Defining a static identity value would provide us this capability, but then we would lose the ability to identify pollers uniquely",
      "number": 535,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:24:18.261Z"
    },
    {
      "summary": "Enhancement request to allow context propagators and interceptors to populate ActivityExecutionContext, enabling cleaner access to propagated context information from activities instead of relying on ThreadLocal patterns.",
      "category": "feature",
      "subcategory": "context-propagation",
      "apis": [
        "ActivityExecutionContext"
      ],
      "components": [
        "context-propagator",
        "interceptor",
        "activity-executor"
      ],
      "concepts": [
        "context-propagation",
        "ergonomics",
        "activity-context",
        "data-accessibility",
        "interceptor-integration"
      ],
      "severity": "low",
      "userImpact": "Users can access propagated context from activities with improved ergonomics compared to managing ThreadLocal variables.",
      "rootCause": null,
      "proposedFix": "Extend ActivityExecutionContext to be populatable by context propagators and interceptors, providing a standard mechanism for accessing propagated values.",
      "workaround": "Use ThreadLocal pattern in context propagators to make data accessible from activities.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Being able to access propagated context via `Activity.getExecutionContext()` would be have better ergonomics.",
      "number": 525,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:23:38.780Z"
    },
    {
      "summary": "Java SDK 1.0.8 logs InterruptedException and StatusRuntimeException errors during graceful worker shutdown, despite the shutdown completing successfully. These errors pollute application logs and appear to be related to thread interruption in gRPC polling operations.",
      "category": "bug",
      "subcategory": "worker-shutdown",
      "apis": [
        "pollWorkflowTaskQueue"
      ],
      "components": [
        "worker",
        "poller",
        "grpc-client",
        "thread-executor"
      ],
      "concepts": [
        "graceful-shutdown",
        "thread-interruption",
        "error-logging",
        "polling",
        "worker-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Graceful worker shutdown produces noisy error logs that alarm users despite successful operation, making it difficult to distinguish actual errors from expected shutdown behavior.",
      "rootCause": "Worker threads are interrupted during graceful shutdown, causing gRPC's ThreadlessExecutor to throw InterruptedException and StatusRuntimeException. These exceptions are logged even though they're expected during shutdown.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved in a later version by suppressing or properly handling the expected exceptions during shutdown.",
      "related": [],
      "keyQuote": "Graceful worker shutdown should result in no errors in application logs.",
      "number": 521,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:23:39.232Z"
    },
    {
      "summary": "The DescribeWorkflowExecution gRPC method is not implemented in the Java test service, causing failures when tests attempt to use this method.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "DescribeWorkflowExecution"
      ],
      "components": [
        "test-service",
        "grpc-server",
        "workflow-service"
      ],
      "concepts": [
        "test-framework",
        "grpc-implementation",
        "workflow-introspection",
        "service-methods",
        "testing-infrastructure"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test code that relies on DescribeWorkflowExecution when using the Java test service.",
      "rootCause": "The DescribeWorkflowExecution method handler was not implemented in the test service gRPC server implementation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The method was implemented in the Java test service to handle DescribeWorkflowExecution requests.",
      "related": [
        470
      ],
      "keyQuote": "Method temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution is unimplemented.",
      "number": 514,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:23:38.671Z"
    },
    {
      "summary": "WorkflowInfo interface is missing a getMemo() method to retrieve memos set via WorkflowOptions.Builder.setMemo(), making the memo feature impractical in the Java SDK.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo",
        "WorkflowOptions"
      ],
      "components": [
        "workflow-info",
        "workflow-options",
        "workflow-context"
      ],
      "concepts": [
        "metadata",
        "workflow-configuration",
        "information-retrieval",
        "builder-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users cannot retrieve memo information from running workflows despite being able to set it, severely limiting the utility of the memo feature.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "getMemo() method was added to WorkflowInfo interface to retrieve workflow memos.",
      "related": [],
      "keyQuote": "WorkflowOptions.Builder has method `.setMemo` that allows setting memos. There is no corresponding WorkflowInfo method to retrieve this information",
      "number": 512,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:22:58.309Z"
    },
    {
      "summary": "User requests making the DEFAULT_DEADLOCK_DETECTION_TIMEOUT configurable because their custom data converter can exceed the 1 second timeout under certain cluster conditions. Currently hardcoded, this limitation forces users to fork the SDK to work around it.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "DeterministicRunner",
        "worker",
        "data-converter"
      ],
      "concepts": [
        "timeout",
        "configuration",
        "deadlock-detection",
        "data-conversion",
        "worker-options"
      ],
      "severity": "medium",
      "userImpact": "Users with slow custom data converters are forced to fork the SDK or work around the 1 second timeout limitation.",
      "rootCause": "DEFAULT_DEADLOCK_DETECTION_TIMEOUT is hardcoded and not exposed as a configurable worker option.",
      "proposedFix": "Add a new worker option to make DEFAULT_DEADLOCK_DETECTION_TIMEOUT configurable.",
      "workaround": "Fork the SDK to modify the hardcoded timeout value.",
      "resolution": "fixed",
      "resolutionDetails": "Added as a configurable worker option as suggested in the discussion.",
      "related": [],
      "keyQuote": "Make DEFAULT_DEADLOCK_DETECTION_TIMEOUT configurable",
      "number": 503,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:22:59.035Z"
    },
    {
      "summary": "Request to make OpenTracing span naming and tagging pluggable to support different APM systems like DataDog that expect different span naming conventions (e.g., generic span names with metadata in tags rather than concatenated names).",
      "category": "feature",
      "subcategory": "opentracing-observability",
      "apis": [],
      "components": [
        "opentracing",
        "tracing-options",
        "span-naming"
      ],
      "concepts": [
        "observability",
        "tracing",
        "apm-integration",
        "span-naming",
        "tagging-strategy",
        "datadog",
        "pluggable-strategy"
      ],
      "severity": "medium",
      "userImpact": "Users integrating with APM systems like DataDog cannot use OpenTracing with Temporal because span naming conventions don't match system expectations.",
      "rootCause": "OpenTracing implementation uses hardcoded span naming strategy (RunWorkflow_<Name>, RunActivity_<Name>) that doesn't align with all APM providers' expectations.",
      "proposedFix": "Create an OperationNameAndTagsProvider interface to allow custom span naming and tagging strategies, with multiple standard implementations (including current default and DataDog-compatible variant).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented with pluggable strategy interface following the JaxRS/Jersey pattern referenced in discussion.",
      "related": [],
      "keyQuote": "It would be great if the OpenTracingOptions provided the ability to completely override the strategy for naming/tagging spans.",
      "number": 502,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:23:00.320Z"
    },
    {
      "summary": "Child workflow signal and cancellation operations incorrectly include RunId and set ChildWorkflowOnly to false, which can cause signals to be delivered to unrelated workflows if the child workflow completes and a new workflow reuses the same workflow ID.",
      "category": "bug",
      "subcategory": "child-workflow-signals",
      "apis": [
        "SignalChildWorkflow",
        "CancelChildWorkflow"
      ],
      "components": [
        "child-workflow-handler",
        "signal-dispatcher",
        "cancellation-manager"
      ],
      "concepts": [
        "child-workflow",
        "signal-delivery",
        "workflow-id-reuse",
        "race-condition",
        "continue-as-new"
      ],
      "severity": "high",
      "userImpact": "Users' signals and cancellations intended for child workflows may be incorrectly routed to unrelated workflows if timing conditions cause workflow ID reuse.",
      "rootCause": "Child workflow signal/cancellation commands set RunId and ChildWorkflowOnly=false, instead of leaving RunId unset with ChildWorkflowOnly=true, allowing signals to target any workflow with matching workflow ID.",
      "proposedFix": "Set RunId unset and ChildWorkflowOnly to true when signaling or canceling child workflows.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fix was implemented without adding new tests due to difficulty reproducing the race condition, relying on existing test suite to verify no regressions.",
      "related": [],
      "keyQuote": "What if child workflow does continue as new, or child workflow is reseted.",
      "number": 501,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:22:20.960Z"
    },
    {
      "summary": "Feature request to handle all exceptions as non-retryable when TEMPORAL_DEBUG environment variable is set, to improve troubleshooting during development by preventing automatic retries of core exceptions like NullPointerException and InvalidArgumentException.",
      "category": "feature",
      "subcategory": "debugging",
      "apis": [],
      "components": [
        "workflow-executor",
        "activity-executor",
        "error-handling"
      ],
      "concepts": [
        "debugging",
        "retry-policy",
        "exception-handling",
        "development-mode",
        "error-behavior"
      ],
      "severity": "low",
      "userImpact": "Developers would have easier troubleshooting during development cycles when TEMPORAL_DEBUG is enabled, as exceptions would fail fast instead of being retried.",
      "rootCause": null,
      "proposedFix": "Reuse the existing TEMPORAL_DEBUG environment variable to configure exception handling behavior to treat all exceptions as non-retryable when the flag is set.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "TEMPORAL_DEBUG env variable is already in use to assist with debugging (e.g. timeouts) and it could be reused to handle all exception as non-retryable by default.",
      "number": 499,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:22:20.225Z"
    },
    {
      "summary": "Feature request to add LocalActivityOption#contextPropagators to support context propagation for local activities, analogous to the existing ActivityOption#contextPropagators API.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOption",
        "ActivityOption",
        "ContextPropagators",
        "WorkerOptions"
      ],
      "components": [
        "local-activity-executor",
        "context-propagation",
        "activity-options",
        "worker"
      ],
      "concepts": [
        "context-propagation",
        "local-activities",
        "api-consistency",
        "cross-language-support",
        "worker-configuration"
      ],
      "severity": "low",
      "userImpact": "Users cannot specify custom context propagators for local activities, limiting context propagation capabilities when using local activities with different codebases.",
      "rootCause": "LocalActivityOption API lacks feature parity with ActivityOption for context propagators, and context propagators on ActivityOptions only apply client-side rather than worker-side.",
      "proposedFix": "Add LocalActivityOption#contextPropagators with the same semantic as ActivityOption#contextPropagators, though with awareness of the limited applicability.",
      "workaround": "Specify ContextPropagators on WorkerOptions to apply them for all activities on both caller and worker sides.",
      "resolution": "wontfix",
      "resolutionDetails": "Authors concluded that ActivityOption#contextPropagators has extremely limited usage and are only applied client-side. The proper approach is to specify ContextPropagators on WorkerOptions instead, making the feature addition for local activities unnecessary and potentially misleading.",
      "related": [
        489
      ],
      "keyQuote": "ActivityOptions#contextPropagators should be used carefully with full understanding that they are applied only to the client/stub side.",
      "number": 490,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:22:21.158Z"
    },
    {
      "summary": "ContextPropagators are not being applied to local activities despite working correctly for regular activities. This causes context propagation to fail for local activity invocations.",
      "category": "bug",
      "subcategory": "context-propagation",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "context-propagators",
        "local-activity-executor",
        "activity-framework"
      ],
      "concepts": [
        "context-propagation",
        "local-activities",
        "activity-execution",
        "context-management"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably propagate context (like tracing headers, credentials, or custom context) when using local activities, limiting their ability to maintain end-to-end context in distributed tracing and observability.",
      "rootCause": "ContextPropagators implementation does not properly handle the local activity execution path, likely missing hooks or adapters for local activity invocation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by PR #491 which likely added context propagator support to the local activity execution pipeline.",
      "related": [
        491
      ],
      "keyQuote": "ContextPropagators should be respected and work correctly for LocalActivities the same way as for normal Activities.",
      "number": 489,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:21:40.945Z"
    },
    {
      "summary": "User asks how to update search attribute values during workflow/activity runtime, particularly for use cases like tracking when the last email was sent. A solution using `Workflow.upsertSearchAttributes` is provided, though it only works from workflow code, not from activities.",
      "category": "question",
      "subcategory": "search-attributes",
      "apis": [
        "WorkflowOptions",
        "Workflow.upsertSearchAttributes",
        "Workflow.currentTimeMillis"
      ],
      "components": [
        "workflow-execution",
        "search-attributes",
        "activity-runtime"
      ],
      "concepts": [
        "search-attributes",
        "workflow-state",
        "runtime-updates",
        "activity-limitations",
        "query-capability"
      ],
      "severity": "low",
      "userImpact": "Users need to understand how to dynamically update search attributes during workflow execution to track runtime state changes like task completion timestamps.",
      "rootCause": "Activities do not have access to Workflow methods like upsertSearchAttributes, creating an asymmetry in update capabilities between workflow and activity contexts.",
      "proposedFix": "Use Workflow.upsertSearchAttributes from within the workflow code to update search attributes at runtime.",
      "workaround": "Perform search attribute updates only from the workflow code, not from activities.",
      "resolution": "fixed",
      "resolutionDetails": "Answer provided: Workflow.upsertSearchAttributes is available for updating search attributes from workflow code, though activities cannot perform this operation.",
      "related": [],
      "keyQuote": "There is `Workflow.upsertSearchAttributes` to add/update search attributes from the workflow code. It's not possible from Activities runtime though, activities don't have an access to `Workflow` methods.",
      "number": 487,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:21:41.584Z"
    },
    {
      "summary": "Workflow replay fails with an IllegalStateException when local activity versioning is added using Workflow.getVersion(). The error occurs when replaying event history that contains local activity markers that were executed before the versioning logic was introduced.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.getVersion",
        "Workflow.DEFAULT_VERSION"
      ],
      "components": [
        "WorkflowStateMachines",
        "local-activity",
        "event-replay"
      ],
      "concepts": [
        "workflow-versioning",
        "event-history",
        "backward-compatibility",
        "replay",
        "conditional-logic",
        "state-machine"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely add workflow versioning logic to existing workflows because replaying historical events fails with an IllegalStateException.",
      "rootCause": "The WorkflowStateMachines.handleLocalActivityMarker() method encounters a local activity ID in the event history that doesn't match the current workflow logic path, causing an IllegalStateException when the version branch doesn't execute the local activity.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed after the reporter could not provide a reproduction case that matched the expected behavior. The maintainer's test case did not reproduce the issue.",
      "related": [],
      "keyQuote": "workflow replay should be able to process event history after adding conditional logic based on the version",
      "number": 482,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:21:41.858Z"
    },
    {
      "summary": "Request to allow workers to gracefully fail and stop retrying when the server is unavailable, with configurable backoff and maximum retry periods to improve deployment health checks in containerized environments.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkflowServiceStubsOptions"
      ],
      "components": [
        "worker",
        "poller",
        "client-stubs",
        "retry-logic"
      ],
      "concepts": [
        "backoff",
        "retry",
        "server-availability",
        "connection-failure",
        "health-check",
        "exponential-backoff",
        "maximum-interval"
      ],
      "severity": "medium",
      "userImpact": "Users deploying workers in Kubernetes need better control over retry behavior when the server is unavailable to avoid excessive logging and implement proper deployment failure semantics.",
      "rootCause": "Workers continue retrying indefinitely at exponential backoff intervals (up to 1 minute) when server is unavailable, which doesn't integrate well with container orchestration health checks.",
      "proposedFix": "Expose backoff configuration parameters (backoffCoefficient, pollBackoffInitialInterval, pollBackoffMaximumInterval) and optionally implement a maximum retry period after which workers fail, similar to Go SDK implementation.",
      "workaround": "Implement custom health check logic to validate namespace existence before starting workers.",
      "resolution": "fixed",
      "resolutionDetails": "Health check functionality was implemented in the Java SDK based on the Go SDK pattern (client.go#L417), allowing workers to fail gracefully when the server is unavailable.",
      "related": [
        472
      ],
      "keyQuote": "the workers will die after configured time or attempt count passes",
      "number": 481,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:21:02.393Z"
    },
    {
      "summary": "GrpcRetryer#retryWithResultAsync fails to perform retries when exceptions are thrown from the supplied function because CompletionException is not properly unwrapped and processed.",
      "category": "bug",
      "subcategory": "retry-logic",
      "apis": [],
      "components": [
        "GrpcRetryer",
        "exception-handling",
        "async-processing"
      ],
      "concepts": [
        "retry",
        "exception-handling",
        "CompletionException",
        "async-operations",
        "error-recovery"
      ],
      "severity": "high",
      "userImpact": "gRPC operations fail to retry properly when exceptions occur, causing operations to fail prematurely instead of respecting the retry timeout.",
      "rootCause": "CompletionException is not processed and unwrapped correctly in the retryWithResultAsync method",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #477 with proper CompletionException unwrapping",
      "related": [
        477
      ],
      "keyQuote": "GrpcRetryer#retryWithResultAsync returns after the first retry if an exception is thrown from the supplied function instead of being provided in the returned CompletableFuture.",
      "number": 476,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:21:00.749Z"
    },
    {
      "summary": "Child workflows are not created with search attributes and memo, unlike regular workflows. The issue is traced to missing code in SyncWorkflowContext::executeChildWorkflow that should set these properties.",
      "category": "bug",
      "subcategory": "child-workflows",
      "apis": [
        "executeChildWorkflow"
      ],
      "components": [
        "SyncWorkflowContext",
        "workflow-execution",
        "child-workflow-handler"
      ],
      "concepts": [
        "search-attributes",
        "memo",
        "workflow-metadata",
        "child-workflows",
        "execution-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot track or search child workflows using search attributes and memo like they can with parent workflows.",
      "rootCause": "SyncWorkflowContext::executeChildWorkflow is missing code to propagate search attributes and memo to child workflow execution.",
      "proposedFix": "Add code to SyncWorkflowContext::executeChildWorkflow to set search attributes and memo on child workflow creation, matching the behavior of regular workflow creation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Code was added to propagate search attributes and memo to child workflows in SyncWorkflowContext.",
      "related": [],
      "keyQuote": "Child workflows are not being created with search attributes and memo. This can be seen when you look at the child workflow's `WorkflowExecutionStarted` event in the history.",
      "number": 474,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:21:01.505Z"
    },
    {
      "summary": "WorkflowExecutionUtils#getInstanceCloseEvent can enter an infinite loop after a timeout when receiving empty responses, never enforcing the timeout check.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "GetWorkflowExecutionHistory"
      ],
      "components": [
        "WorkflowExecutionUtils",
        "history-client",
        "timeout-handling"
      ],
      "concepts": [
        "infinite-loop",
        "timeout",
        "retry",
        "empty-response",
        "control-flow"
      ],
      "severity": "high",
      "userImpact": "Workflow execution utilities can hang indefinitely after network timeouts, requiring process restart to recover.",
      "rootCause": "Timeout check is performed after the continue statement, so if an empty response is received after timeout expiration, the loop never exits.",
      "proposedFix": "Move timeout check before the continue statement to ensure timeout is enforced even with empty responses.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #472",
      "related": [
        472
      ],
      "keyQuote": "if we are here and it's a timeout - we will never return from this cycle, we will never get to the following timeout check",
      "number": 471,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:20:20.664Z"
    },
    {
      "summary": "DataConverter is unexpectedly applied to custom search attributes in addition to workflow/activity arguments, causing serialization issues when values are sent to Elasticsearch. The proper behavior should distinguish between serializing workflow/activity parameters versus search attributes and memo.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "DataConverter",
        "SearchAttributes"
      ],
      "components": [
        "data-converter",
        "search-attributes",
        "serialization"
      ],
      "concepts": [
        "serialization",
        "custom-converter",
        "search-attributes",
        "payload-conversion",
        "backwards-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users implementing custom DataConverters for workflow arguments inadvertently apply those converters to search attributes, causing Elasticsearch indexing errors and requiring workarounds.",
      "rootCause": "DataConverter is used for all wire serialization including search attributes, but search attributes have a fixed serialization format defined by the service that should not use custom converters.",
      "proposedFix": "Replace custom DataConverter usage for search attributes with the default converter, as proposed in PR #483, while using custom converters only for workflow/activity arguments through separate toPayload/toPayloads methods.",
      "workaround": "Implement custom DataConverter instead of custom PayloadConverter, and selectively apply custom serialization only through toPayloads while delegating toPayload to the default data converter.",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by distinguishing between toPayload (used for search attributes/memo) and toPayloads (used for workflow/activity args), allowing custom converters to apply only to the latter.",
      "related": [
        483
      ],
      "keyQuote": "search attributes and memo should be passed verbatim since these values ultimately need to be indexed by ES / read by humans so encoding them would be incorrect",
      "number": 468,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:20:22.110Z"
    },
    {
      "summary": "Request to register multiple activity names for a single activity to support refactoring scenarios where activity names change. This enables smooth migration where workers can recognize both old and new activity names, with potential for marking names as deprecated.",
      "category": "feature",
      "subcategory": "activity-registration",
      "apis": [
        "ActivityMethod"
      ],
      "components": [
        "activity-registry",
        "worker",
        "activity-method-annotation"
      ],
      "concepts": [
        "activity-naming",
        "backwards-compatibility",
        "migration",
        "refactoring",
        "activity-aliases",
        "deprecation"
      ],
      "severity": "medium",
      "userImpact": "Users performing activity name refactors currently face deployment challenges and errors, as workers reject activities with unregistered names.",
      "rootCause": null,
      "proposedFix": "Add name aliases mechanism to @ActivityMethod annotation to allow multiple activity names for a single activity implementation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        396
      ],
      "keyQuote": "I would like to have the ability to register multiple activity names for an activity - this way one could deploy the activity name change and then on the next deploy delete the previous activity name.",
      "number": 467,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:20:20.845Z"
    },
    {
      "summary": "User asks if proxy objects (commonly used with Quarkus interceptors) can be passed to registerActivitiesImplementations. Discussion suggests this should already work if proxies implement ActivityInterface, but user seeks confirmation or feature enhancement for better interceptor support.",
      "category": "question",
      "subcategory": "activity-registration",
      "apis": [
        "registerActivitiesImplementations",
        "DynamicActivity"
      ],
      "components": [
        "activity-registration",
        "activity-implementation",
        "interceptor-support"
      ],
      "concepts": [
        "proxy-objects",
        "interceptors",
        "dependency-injection",
        "activity-interface",
        "quarkus-extension"
      ],
      "severity": "low",
      "userImpact": "Quarkus extension developers need clarity on whether proxy-based interceptor patterns are supported for activity implementation registration.",
      "rootCause": null,
      "proposedFix": "Consider supporting factory methods or explicit proxy handling; alternatively, clarify that existing proxy objects should work if they implement ActivityInterface.",
      "workaround": "Use DynamicActivity as an alternative approach.",
      "resolution": "invalid",
      "resolutionDetails": "Community responded that proxy objects should already work if implementing ActivityInterface, suggesting the feature is not needed and the user's approach is valid.",
      "related": [],
      "keyQuote": "I believe you should be able to provide Proxy objects to registerActivitiesImplementations just fine if these Proxies are implementing an ActivityInterface.",
      "number": 466,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:19:41.895Z"
    },
    {
      "summary": "Request to support proxy objects in registerActivitiesImplementations to enable Quarkus interceptor integration. The user is building a Quarkus extension for Temporal and needs to pass proxy objects created by Quarkus interceptors for activities.",
      "category": "feature",
      "subcategory": "activity-registration",
      "apis": [
        "registerActivitiesImplementations"
      ],
      "components": [
        "activity-registration",
        "activity-executor",
        "interceptor-support"
      ],
      "concepts": [
        "proxy-objects",
        "interceptor-integration",
        "dependency-injection",
        "framework-extension",
        "activity-implementation"
      ],
      "severity": "low",
      "userImpact": "Users building framework extensions with interceptor support cannot pass proxy objects to activity registration, limiting integration with frameworks like Quarkus.",
      "rootCause": null,
      "proposedFix": "Support a factory method for creating activity implementations and pass the activity interface along with proxy objects to registerActivitiesImplementations",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was implemented to support proxy objects in activity registration, allowing framework extensions like Quarkus to pass interceptor-based proxies.",
      "related": [],
      "keyQuote": "I want to support quarkus interceptors in Activities. quarkus handle interceptor interceptions with Proxy and Invocation Handler",
      "number": 465,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:19:41.776Z"
    },
    {
      "summary": "Request to add ActivityCompletionClient support in TestActivityEnvironment to enable asynchronous activity completion testing. This is a duplicate of issue #2097.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ActivityCompletionClient",
        "TestActivityEnvironment"
      ],
      "components": [
        "activity-executor",
        "test-framework",
        "activity-completion"
      ],
      "concepts": [
        "asynchronous-completion",
        "testing",
        "activity-lifecycle",
        "test-utilities"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test activities that use asynchronous completion patterns with TestActivityEnvironment, limiting test coverage for complex activity scenarios.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Duplicate of issue #2097, which tracks the same feature request.",
      "related": [
        1185,
        2097
      ],
      "keyQuote": "Please add ActivityCompletionClient support in TestActivityEnvironment",
      "number": 460,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:19:41.494Z"
    },
    {
      "summary": "TestWorkflowEnvironment.sleep() hangs instead of skipping workflow timers as expected. When using testEnv.sleep() to advance past Workflow.await() calls with long durations, tests hang indefinitely rather than progressing through the workflow execution.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "Workflow.await",
        "TestWorkflowEnvironment.sleep"
      ],
      "components": [
        "test-environment",
        "workflow-timer",
        "test-utilities"
      ],
      "concepts": [
        "test-execution",
        "time-advancement",
        "timer-mocking",
        "test-hanging",
        "workflow-testing"
      ],
      "severity": "high",
      "userImpact": "Tests using testEnv.sleep() to advance past long-duration Workflow.await() calls hang indefinitely, blocking test execution and requiring timeouts to fail tests.",
      "rootCause": "TestWorkflowEnvironment.sleep() does not properly skip internal workflow timers, causing actual sleep instead of advancing the workflow clock.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bug was identified and fixed in a pull request by the maintainer.",
      "related": [],
      "keyQuote": "testEnv.sleep() should skip workflow's internal timer without actually sleeping.",
      "number": 459,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:19:03.071Z"
    },
    {
      "summary": "Test environment hangs indefinitely when waiting for completion of a duplicate concurrent workflow with WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE, while the same code works correctly with real Temporal containers.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowClient.execute"
      ],
      "components": [
        "test-environment",
        "workflow-client",
        "duplicate-workflow-handling"
      ],
      "concepts": [
        "duplicate-workflow-id",
        "workflow-id-reuse-policy",
        "concurrent-workflows",
        "workflow-proxy",
        "completable-future",
        "blocking-call",
        "test-server"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test workflows with duplicate IDs in the test environment, as the second workflow execution call blocks indefinitely instead of returning the first workflow's result.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": "Ensure the first workflow is fully completed before starting the second workflow with the same ID.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "With Test Environment the second f2.get() call hangs forever. If the first workflow is fully completed before starting the second, all works OK.",
      "number": 456,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:19:03.004Z"
    },
    {
      "summary": "Test testExceptionOnStart flakes intermittently due to a deadlock when gRPC channel shutdown is blocked by a long poll from a worker thread. The workflow poller holds a lock while waiting on a queue poll, preventing the channel from shutting down properly.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "pollWorkflowTaskQueue"
      ],
      "components": [
        "test-framework",
        "grpc-channel",
        "workflow-poller",
        "worker"
      ],
      "concepts": [
        "deadlock",
        "thread-blocking",
        "channel-shutdown",
        "long-polling",
        "concurrency",
        "test-reliability"
      ],
      "severity": "high",
      "userImpact": "Test suite experiences intermittent timeouts, reducing reliability of test execution and developer productivity.",
      "rootCause": "Host Local Workflow Poller thread holds a lock on InProcessClientStream while blocked on LinkedBlockingQueue.poll(), preventing the test framework from shutting down the gRPC channel within the test timeout.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the threading and locking mechanism in the test service to prevent the deadlock between channel shutdown and worker polling operations.",
      "related": [],
      "keyQuote": "The test fails due to gRPC channel shutdown getting blocked on the long poll emitted from a worker.",
      "number": 455,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:19:03.357Z"
    },
    {
      "summary": "Worker logs ERROR when rejecting a workflow close request due to a signal race condition, but the workflow eventually closes successfully after signal processing. The log level should be INFO instead of ERROR since this is expected behavior in concurrent signal/close scenarios.",
      "category": "bug",
      "subcategory": "workflow-closing",
      "apis": [],
      "components": [
        "worker",
        "signal-handler",
        "workflow-task-processor"
      ],
      "concepts": [
        "race-condition",
        "signal-processing",
        "error-logging",
        "workflow-state",
        "concurrent-operations"
      ],
      "severity": "medium",
      "userImpact": "Users are misled by ERROR logs that indicate failures, when the operation actually succeeds after signal processing, causing confusion during troubleshooting.",
      "rootCause": "A signal arrives at the service while the worker is processing a workflow close task, causing the service to reject the close request. The worker logs this rejection as ERROR, but the workflow eventually closes successfully after the signal is processed.",
      "proposedFix": "Change the log level from ERROR to INFO for this specific failure case, since it's expected behavior in signal race condition scenarios and the workflow recovers successfully.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The log level was changed from ERROR to INFO for failed workflow task closures caused by signal race conditions, as this is expected and recoverable behavior.",
      "related": [],
      "keyQuote": "When the worker tries to close the workflow, the service will reject the request to close the workflow... But everything will be fine after the signal is processed",
      "number": 446,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:18:24.010Z"
    },
    {
      "summary": "MicrometerClientStatsReporter overrides the MeterRegistry's native naming convention and always uses snake_case, which breaks compatibility with applications using different conventions like Datadog's dot-separated format.",
      "category": "bug",
      "subcategory": "metrics-reporting",
      "apis": [],
      "components": [
        "MicrometerClientStatsReporter",
        "MeterRegistry"
      ],
      "concepts": [
        "metrics",
        "naming-convention",
        "compatibility",
        "configuration",
        "datadog"
      ],
      "severity": "medium",
      "userImpact": "Users with MeterRegistry instances using non-snake_case naming conventions have their metric names forcibly converted, breaking integration with monitoring systems like Datadog.",
      "rootCause": "MicrometerClientStatsReporter hardcodes snake_case naming convention instead of respecting the MeterRegistry's native naming convention.",
      "proposedFix": "MicrometerClientStatsReporter should use the naming convention provided by the MeterRegistry instead of overriding it.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, likely fixed by allowing MicrometerClientStatsReporter to respect the MeterRegistry's native naming convention.",
      "related": [],
      "keyQuote": "MicrometerClientStatsReporter always overrides MeterRegistry's naming convention with snakeCase.",
      "number": 432,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:18:23.711Z"
    },
    {
      "summary": "TestWorkflowService doesn't pass headers into workflow retry. When workflow retries occur after a failure, the retry runs receive empty headers instead of the same headers as the initial run.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowService",
        "workflow-retry",
        "header-propagation"
      ],
      "concepts": [
        "retry",
        "headers",
        "testing",
        "workflow-execution",
        "test-isolation"
      ],
      "severity": "medium",
      "userImpact": "Developers testing workflows with retry logic in TestWorkflowService cannot properly verify that headers are correctly propagated across retry attempts.",
      "rootCause": "TestWorkflowService does not propagate headers from the initial workflow execution to subsequent retry attempts.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Addressed in PR #419",
      "related": [
        419
      ],
      "keyQuote": "When we use TestWorkflowService, workflow retry runs get an empty set of headers.",
      "number": 420,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:18:23.033Z"
    },
    {
      "summary": "TestWorkflowRule incorrectly merges workerInterceptors from two different sources, causing user-provided interceptors to be discarded when both setWorkerFactoryOptions() and setWorkerInterceptors() are used.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "TestWorkflowRule",
        "WorkerFactoryOptions"
      ],
      "components": [
        "test-framework",
        "worker-factory",
        "interceptor-handling"
      ],
      "concepts": [
        "interceptor-merging",
        "configuration-conflict",
        "test-setup",
        "refactoring-regression"
      ],
      "severity": "high",
      "userImpact": "Users' custom worker interceptors are silently ignored when setting both WorkerFactoryOptions and workerInterceptors, breaking test configurations.",
      "rootCause": "Incorrect refactoring when setWorkerInterceptors() method was added; the method overwrites workerInterceptors in WorkerFactoryOptions instead of merging them, and naming confusion between different interceptor types (client vs worker).",
      "proposedFix": "Remove the separate setWorkerInterceptors() method from TestWorkflowRule and Builder completely; supply workerInterceptors exclusively through WorkerFactoryOptions, consistent with how WorkflowClientOptions handles client interceptors.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed by the referenced refactoring to properly handle interceptor configuration through WorkerFactoryOptions.",
      "related": [],
      "keyQuote": "Remove this separate new setWorkflowInterceptors method from TestWorkflowRule and Builder completely and supply workerInterceptors inside WorkerFactoryOptions.",
      "number": 417,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:17:44.236Z"
    },
    {
      "summary": "Workflow retry after activity failure doesn't work correctly with TestService. When an activity is configured to fail once then succeed, and the workflow is configured to retry, the workflow fails in unit tests instead of retrying, but passes when using an external service.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "retryOptions",
        "maxAttempt"
      ],
      "components": [
        "TestService",
        "workflow-retry",
        "activity-retry"
      ],
      "concepts": [
        "retry-logic",
        "activity-failure",
        "test-execution",
        "workflow-execution",
        "error-handling",
        "state-management"
      ],
      "severity": "high",
      "userImpact": "Unit tests for workflows with retry logic fail incorrectly, making it impossible to properly test retry scenarios without using external services.",
      "rootCause": "Issue is in TestService implementation rather than retry logic itself, as confirmed by test passing with external service",
      "proposedFix": null,
      "workaround": "Use external service instead of TestService for testing retry scenarios",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If uncomment .setUseExternalService(true) the test passes which points that the issue is probably in TestService implementation",
      "number": 414,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:17:43.871Z"
    },
    {
      "summary": "The Workflow#newActivityStub(activityInterface) method without ActivityOptions produces invalid activity stubs because ActivityOptions lacks default values for required timeouts (startToClose or scheduleToClose). The method needs either proper defaults or to enforce validation that throws an exception when timeouts are missing.",
      "category": "bug",
      "subcategory": "activity-options",
      "apis": [
        "newActivityStub",
        "ActivityOptions"
      ],
      "components": [
        "activity-stub",
        "workflow-client",
        "activity-options-builder"
      ],
      "concepts": [
        "timeout",
        "default-values",
        "validation",
        "activity-configuration",
        "startToClose",
        "scheduleToClose"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably create activity stubs without ActivityOptions due to invalid defaults, making the no-argument method essentially unusable.",
      "rootCause": "ActivityOptions requires either startToClose or scheduleToClose but provides no default values for these required fields, creating invalid default options.",
      "proposedFix": "Either set a default value for scheduleToClose (e.g., 10 seconds) or enforce validation in ActivityOptions#Builder#validateAndBuildWithDefaults to throw an exception when both timeouts are uninitialized.",
      "workaround": "Use WorkflowImplementationOptions to set default activity options instead of relying on Workflow#newActivityStub(activityInterface).",
      "resolution": "fixed",
      "resolutionDetails": "Resolved by allowing default activity options to be set through WorkflowImplementationOptions, and improving validation to enforce required timeout parameters.",
      "related": [],
      "keyQuote": "default ActivityOptions is actually invalid... this method never really can be used right now",
      "number": 413,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:17:45.142Z"
    },
    {
      "summary": "Enforce runtime checks to prevent WorkflowClient and Activity interface usage from workflow code, which violates nondeterminism requirements and can cause bugs. New developers may inadvertently use these prohibited APIs without understanding the constraints.",
      "category": "feature",
      "subcategory": "workflow-enforcement",
      "apis": [
        "WorkflowClient",
        "ActivityCompletionClient",
        "WorkflowServiceStubs"
      ],
      "components": [
        "workflow-runtime",
        "enforcement-checks",
        "activity-client"
      ],
      "concepts": [
        "nondeterminism",
        "workflow-isolation",
        "api-validation",
        "thread-safety",
        "developer-experience"
      ],
      "severity": "high",
      "userImpact": "Developers are protected from accidentally introducing nondeterministic code by receiving explicit exceptions when prohibited APIs are called from workflow threads.",
      "rootCause": "Lack of runtime enforcement allowing incorrect usage patterns from workflow code, leading to subtle bugs related to nondeterminism violations.",
      "proposedFix": "Add explicit checks that throw exceptions from WorkflowClient and Activity APIs if called from workflow threads, with an optional environment variable for backward compatibility.",
      "workaround": "Set environment variable `TEMPORAL_DISABLE_NON_WORKFLOW_CODE_ENFORCEMENTS` to 'true' for legacy implementations, though this is discouraged for new code.",
      "resolution": "fixed",
      "resolutionDetails": "Implemented prohibition of WorkflowClient, ActivityCompletionClient, and WorkflowServiceStubs from workflow threads with configurable enforcement via environment variable.",
      "related": [],
      "keyQuote": "Add explicit checks that throw exceptions from WorkflowClient and Activity APIs if they are called from workflow threads.",
      "number": 402,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:17:04.250Z"
    },
    {
      "summary": "Activity retries are not being executed in cron workflows. When a cron workflow is triggered multiple times and activities fail, the retries don't occur as expected - activities are only called once per workflow run instead of with configured retry attempts.",
      "category": "bug",
      "subcategory": "activity-retry",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-executor",
        "cron-workflow",
        "retry-handler",
        "workflow-execution"
      ],
      "concepts": [
        "retry",
        "cron-workflow",
        "activity-failure",
        "attempt-tracking",
        "temporal-testing"
      ],
      "severity": "high",
      "userImpact": "Users relying on activity retries within cron workflows will experience silent failures as activities are not retried after transient errors.",
      "rootCause": "The cron workflow execution logic does not properly propagate or reset retry counters across multiple workflow runs, causing activities to bypass retry logic.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Resolved as invalid - the issue reporter did not respond to clarification attempts. The maintainer demonstrated that the expected behavior (3 retries per workflow run) was working correctly in a reproduction test.",
      "related": [],
      "keyQuote": "As expected I've seen 3 attempts for each workflow run",
      "number": 401,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:17:04.398Z"
    },
    {
      "summary": "Cron workflow in Java SDK test framework executes twice as many times as expected. A workflow scheduled to run every 30 days executes 6 times in 90 days instead of the expected 3 times, with the root cause being that the workflow executes immediately on start plus additional unexpected executions.",
      "category": "bug",
      "subcategory": "cron-scheduling",
      "apis": [
        "WorkflowOptions",
        "setCronSchedule",
        "setRetryOptions"
      ],
      "components": [
        "test-framework",
        "workflow-execution",
        "cron-scheduler"
      ],
      "concepts": [
        "cron-scheduling",
        "workflow-timing",
        "test-environment",
        "execution-count",
        "schedule-expression"
      ],
      "severity": "medium",
      "userImpact": "Users testing cron workflows with TestWorkflowEnvironment get incorrect execution counts, making it difficult to verify workflow behavior.",
      "rootCause": "Cron workflow executes immediately on start (which is a bug) plus executes on the 1st and 31st of each month per the cron expression format, resulting in duplicate executions in the test environment.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Marked as invalid/question - the behavior was explained as a known issue where workflows execute immediately (acknowledged as a bug) but the actual cron scheduling works correctly on real server.",
      "related": [],
      "keyQuote": "you're getting 6 runs because when you start a cron workflow, it executes immediately (1st run) and then every 1st and 31st of the month per this doc. The fact that your workflow executes immediately in this case is a bug, but with real server should work correctly.",
      "number": 400,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:17:05.172Z"
    },
    {
      "summary": "Feature request to make activity name generation pluggable through ClientOptions and WorkerOptions, allowing users to implement custom naming standards for activities instead of relying on automatic method-name-based generation.",
      "category": "feature",
      "subcategory": "activity-naming",
      "apis": [
        "ClientOptions",
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "activity-executor",
        "client-options"
      ],
      "concepts": [
        "naming-convention",
        "pluggable-provider",
        "activity-registration",
        "dynamic-naming",
        "customization"
      ],
      "severity": "medium",
      "userImpact": "Users cannot implement custom activity naming standards, limiting flexibility in organizing and identifying activities in complex workflows.",
      "rootCause": "Activity name generation is hardcoded to use method names without allowing user-defined logic for different naming conventions.",
      "proposedFix": "Implement a pluggable activity name provider interface accessible through ClientOptions and WorkerOptions to allow custom name generation logic.",
      "workaround": "Users can implement custom WorkflowOutboundCallsInterceptor to handle activity naming logic (mentioned by mfateev in comments).",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        141
      ],
      "keyQuote": "Different users of the SDK have different opinions on how this name should be generated.",
      "number": 396,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:12:01.993Z"
    },
    {
      "summary": "TimeLockingFuture's time-skipping functionality breaks when CompletableFuture is chained using standard methods like thenApply(). The implementation is brittle because it only intercepts get() and join() calls on the original future, not on chained futures, making the feature unreliable for typical async patterns.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowStub.getResult",
        "WorkflowStub.getResultAsync"
      ],
      "components": [
        "TimeLockingFuture",
        "TestWorkflowService",
        "WorkflowStub"
      ],
      "concepts": [
        "time-skipping",
        "testing",
        "CompletableFuture",
        "future-chaining",
        "test-utilities",
        "async-execution"
      ],
      "severity": "high",
      "userImpact": "Test developers using TestWorkflowService cannot reliably use time-skipping with chained futures, forcing them to avoid standard CompletableFuture composition patterns or lose time-skipping functionality.",
      "rootCause": "TimeLockingFuture only overrides get() and join() methods, but chaining operations like thenApply() return new CompletableFuture instances that don't have the overridden methods, bypassing the time-skipping logic.",
      "proposedFix": "Remove built-in time-skipping from WorkflowStub and TimeLockingFuture. Instead, expose a helper method (e.g., TimeSkipUtils.forStub(workflowStub).skipTimeSegment()) that returns an AutoCloseable resource to control time-skipping scope, allowing developers to opt-in where needed.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "even trivial chaining completely and unexpectedly breaks the time-skipping feature",
      "number": 392,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:16:25.024Z"
    },
    {
      "summary": "Querying a terminated workflow throws a WorkflowQueryException due to improper handling of the WORKFLOW_EXECUTION_TERMINATED event during query processing. The replay mechanism fails when attempting to handle this event, resulting in an IllegalArgumentException for unexpected events.",
      "category": "bug",
      "subcategory": "query-handling",
      "apis": [
        "query"
      ],
      "components": [
        "query-processor",
        "replay-engine",
        "state-machine",
        "workflow-stub"
      ],
      "concepts": [
        "workflow-termination",
        "event-replay",
        "query-execution",
        "workflow-state",
        "error-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot query terminated workflows, receiving an exception instead of a valid response or graceful error.",
      "rootCause": "The replay engine's handleEvent method does not properly handle EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED events when processing queries on terminated workflows, throwing an IllegalArgumentException for unexpected events.",
      "proposedFix": "Selectively ignore or handle the WORKFLOW_EXECUTION_TERMINATED event in the query workflow task handler to allow queries on terminated workflows to proceed without throwing exceptions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fix was implemented to handle the terminated event properly during query processing, allowing queries on terminated workflows without exceptions.",
      "related": [
        630
      ],
      "keyQuote": "Terminate a workflow and run a query against it.",
      "number": 391,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:15:43.805Z"
    },
    {
      "summary": "API documentation for WorkflowOptions incorrectly states that the default WorkflowIdReusePolicy is AllowDuplicateFailedOnly, when it should be AllowDuplicate.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "WorkflowOptions"
      ],
      "components": [
        "documentation",
        "client-api",
        "workflow-options"
      ],
      "concepts": [
        "default-values",
        "api-documentation",
        "workflow-configuration",
        "reuse-policy",
        "correctness"
      ],
      "severity": "low",
      "userImpact": "Developers may implement workflows with incorrect assumptions about the default WorkflowIdReusePolicy behavior.",
      "rootCause": "Documentation comment was not updated to reflect actual default behavior.",
      "proposedFix": "Update the documentation comment in WorkflowOptions.java line 134 to correctly state AllowDuplicate as the default.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #1307 which updated the documentation.",
      "related": [
        1307
      ],
      "keyQuote": "According to maxim, the default is `AllowDuplicate`",
      "number": 387,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:11:19.828Z"
    },
    {
      "summary": "Add support for injecting context into headers when starting workflows and executing activities through client and activity interceptors.",
      "category": "feature",
      "subcategory": "interceptors",
      "apis": [
        "StartWorkflow",
        "ExecuteActivity"
      ],
      "components": [
        "client-interceptor",
        "activity-interceptor",
        "header-management"
      ],
      "concepts": [
        "context-injection",
        "interceptors",
        "headers",
        "metadata-propagation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently set custom headers from client and activity interceptors, limiting context propagation capabilities.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was fully implemented as confirmed by Spikhalskiy in the issue comments.",
      "related": [],
      "keyQuote": "It should be possible to inject context into the header when starting workflow and executing an activity.",
      "number": 373,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:11:19.050Z"
    },
    {
      "summary": "Workflow cancellation requests return 204 but fail to cancel workflows that are stuck after a workflow task failure. The workflow continues running indefinitely with no way to cancel it via the API, though new workflows can be canceled normally.",
      "category": "bug",
      "subcategory": "workflow-cancellation",
      "apis": [
        "WorkflowImplementationOptions"
      ],
      "components": [
        "workflow-engine",
        "cancellation-handler",
        "task-processor"
      ],
      "concepts": [
        "cancellation",
        "workflow-failure",
        "exception-handling",
        "workflow-state",
        "api-response"
      ],
      "severity": "high",
      "userImpact": "Users cannot cancel workflows that fail during task processing, requiring them to use terminate commands as a workaround.",
      "rootCause": "When a workflow task fails, the workflow gets stuck and doesn't properly handle cancellation requests. NPE and unknown exceptions cause workflows to get stuck by default, waiting for a new deployment.",
      "proposedFix": "Configure WorkflowImplementationOptions.failWorkflowExceptionTypes to include Throwable.class so workflows fail immediately on exceptions instead of getting stuck.",
      "workaround": "Use the terminate command instead of cancel, or configure failWorkflowExceptionTypes to fail the workflow on all exceptions.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by explaining the default behavior of exception handling and providing configuration guidance. Users should set failWorkflowExceptionTypes to handle exceptions appropriately.",
      "related": [],
      "keyQuote": "By default NPE (as well as any unknown exception) will cause the workflow to get stuck. This is to give you chance to find the bug and fix it through a new deployment.",
      "number": 371,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:11:22.453Z"
    },
    {
      "summary": "Request to support per-method activity options in Java SDK, allowing different timeouts and configurations for individual activities within a common activity interface without requiring separate stubs.",
      "category": "feature",
      "subcategory": "activity-options",
      "apis": [
        "ActivityMethod",
        "ActivityOptions"
      ],
      "components": [
        "activity-stub",
        "activity-interface",
        "activity-executor"
      ],
      "concepts": [
        "timeout",
        "activity-configuration",
        "per-method-options",
        "activity-interface",
        "configuration-management",
        "stub-creation"
      ],
      "severity": "medium",
      "userImpact": "Users must currently create separate activity stubs for each activity requiring different options, reducing code reusability and increasing complexity.",
      "rootCause": "ActivityMethod annotation only supports name overriding, not full options configuration like timeouts and retry policies.",
      "proposedFix": "Add ActivityOptions annotation support to @ActivityMethod to allow specifying per-method options directly on activity interface methods.",
      "workaround": "Create separate activity stub instances for each activity type, each with its own ActivityOptions configuration.",
      "resolution": "fixed",
      "resolutionDetails": "Enhancement implemented to support per-method activity options configuration.",
      "related": [],
      "keyQuote": "Support per activity type options when configuring activity stub instance. Consider adding ActivityOptions annotation to the activity method.",
      "number": 370,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:10:34.528Z"
    },
    {
      "summary": "Java SDK workers experience connection timeouts and availability issues during Temporal cluster deployments. The SDK fails to transparently recover from topology changes and server-side connection closures, causing activity pollers to report UNAVAILABLE and DEADLINE_EXCEEDED errors.",
      "category": "bug",
      "subcategory": "connection-management",
      "apis": [
        "pollWorkflowTaskQueue"
      ],
      "components": [
        "worker",
        "poller",
        "grpc-client",
        "connection-pool"
      ],
      "concepts": [
        "connection-management",
        "cluster-deployment",
        "resilience",
        "backoff",
        "keep-alive",
        "service-mesh"
      ],
      "severity": "high",
      "userImpact": "Users experience workflow and activity execution failures, timeouts, and error logging noise during cluster deployments or topology changes.",
      "rootCause": "gRPC backoff increases up to 2 minutes per retry when backend is unavailable; server-side connection closures cause client to think connections are still active until TCP timeout; lack of proactive keep-alive checking on client side.",
      "proposedFix": "Periodically reset gRPC backoff every 10 seconds; add connection re-establishment to server periodically; enable keep-alive checking on client side with configurable interval; improve logging to differentiate transient errors from persistent failures.",
      "workaround": "Enable keep-alive mechanism with short interval (e.g., 30 seconds) as a temporary solution; configure service mesh (Envoy) to retry on UNAVAILABLE and DEADLINE_EXCEEDED errors.",
      "resolution": "fixed",
      "resolutionDetails": "Addressed in version 1.0.6 with backoff reset mechanism and connection re-establishment improvements; keep-alive checking added (initially disabled, can be enabled via configuration). Further refined with better logging and configuration options.",
      "related": [
        351,
        367
      ],
      "keyQuote": "During cluster deployments I see timeouts and periods of unavailability...Any connection failures due to these changes should be transparently 'fixed up' by the SDK.",
      "number": 362,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:10:37.452Z"
    },
    {
      "summary": "The default WorkflowIdReusePolicy in the Java SDK is set to AllowDuplicate instead of AllowDuplicateFailedOnly as documented. This allows duplicate workflow IDs to execute concurrently when they should only be allowed for failed workflows.",
      "category": "bug",
      "subcategory": "workflow-id-reuse-policy",
      "apis": [
        "StartWorkflow",
        "WorkflowIdReusePolicy"
      ],
      "components": [
        "workflow-client",
        "workflow-options",
        "id-reuse-policy"
      ],
      "concepts": [
        "workflow-id",
        "reuse-policy",
        "duplicate-handling",
        "workflow-execution",
        "idempotency",
        "default-behavior"
      ],
      "severity": "high",
      "userImpact": "Users may unintentionally allow duplicate workflow IDs to run concurrently, bypassing the intended protection against duplicate workflow executions.",
      "rootCause": "The default WorkflowIdReusePolicy constant is set to AllowDuplicate instead of AllowDuplicateFailedOnly, misaligning with documented behavior and best practices.",
      "proposedFix": "Change the default WorkflowIdReusePolicy from AllowDuplicate to AllowDuplicateFailedOnly to match documentation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The default policy was corrected to AllowDuplicateFailedOnly to match the official documentation.",
      "related": [],
      "keyQuote": "Default WorkflowIdReusePolicy should be AllowDuplicateFailedOnly as per documentation",
      "number": 361,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:10:34.605Z"
    },
    {
      "summary": "Query page shows blank 'no queries registered' message after upgrading to server 1.6.3, even though workflows have query methods defined. The issue is caused by a change in error message format where the SDK no longer returns registered query names in the exception message.",
      "category": "bug",
      "subcategory": "query-handling",
      "apis": [
        "Query"
      ],
      "components": [
        "QueryDispatcher",
        "SyncWorkflowContext",
        "query-engine"
      ],
      "concepts": [
        "query-discovery",
        "error-messaging",
        "web-ui-integration",
        "backward-compatibility",
        "exception-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot see registered queries in the Temporal Web UI after upgrading to server 1.6.3, breaking the query listing functionality.",
      "rootCause": "Between SDK versions 1.6.1 and 1.6.3, the error message format changed from including registered query names in the exception to an IllegalStateException without query type information, preventing the web UI from discovering available queries.",
      "proposedFix": "Restore the error message to include known query types similar to SDK-Go implementation: 'unknown queryType __cadence_web_list. KnownQueryTypes=[...]'",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified as an SDK-Java regression and reassigned to SDK team for resolution.",
      "related": [
        335,
        258,
        54
      ],
      "keyQuote": "sdk-java used to return an error message that would contain registered queries... Please find what caused the change and make it return the old error message again",
      "number": 357,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:09:56.284Z"
    },
    {
      "summary": "Activity failure logs in POJOActivityTaskHandler lack workflow ID and run ID context, making it difficult to trace activities back to their workflows. The request is to include these identifiers in log messages since they're already available in ActivityInfo.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "POJOActivityTaskHandler",
        "ActivityWorker",
        "logging"
      ],
      "concepts": [
        "logging",
        "activity-tracking",
        "workflow-context",
        "observability",
        "MDC",
        "diagnostics"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily search for or trace specific workflows when debugging activity failures due to missing workflow and run ID context in log messages.",
      "rootCause": "Log messages in POJOActivityTaskHandler were not including workflow ID and run ID fields that are available via ActivityInfo and MDC.",
      "proposedFix": "Configure MDC (Mapped Diagnostic Context) in logger configuration to include workflowID and runID fields in log output format.",
      "workaround": "Configure your log format to include MDC fields as shown in Logback/Log4j documentation examples.",
      "resolution": "invalid",
      "resolutionDetails": "Marked invalid because the feature already exists - workflowID and runID are available through MDC (Mapped Diagnostic Context) that can be configured in logger format.",
      "related": [],
      "keyQuote": "The workflowID and runID are already part of MDC. Change your log format to include MDC fields.",
      "number": 353,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:09:55.697Z"
    },
    {
      "summary": "WorkflowClient.execute initiates a long poll for execution history immediately upon being called, rather than lazily when the returned CompletableFuture is actually waited on. This causes unnecessary polling even when the result is never accessed.",
      "category": "other",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowClient.execute"
      ],
      "components": [
        "workflow-client",
        "execution-polling",
        "completion-handling"
      ],
      "concepts": [
        "lazy-evaluation",
        "long-polling",
        "resource-efficiency",
        "future-resolution",
        "execution-history"
      ],
      "severity": "medium",
      "userImpact": "Users experience unnecessary network overhead and server load when they call execute but never wait for the result.",
      "rootCause": "GetWorkflowExecutionHistory poll is initiated eagerly when execute() is called, not lazily when future.get() is invoked.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #1212",
      "related": [
        1212
      ],
      "keyQuote": "The problem is that the GetWorkflowExecutionHistory is initiated as soon as the execute is called, not when future.get is called.",
      "number": 343,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:09:55.185Z"
    },
    {
      "summary": "Request to publish official Maven packages for the Java SDK to Maven Central Repository, similar to the existing Cadence client package. Currently requires using snapshots from Sonatype.",
      "category": "feature",
      "subcategory": "maven-distribution",
      "apis": [],
      "components": [
        "maven",
        "package-distribution",
        "build-system"
      ],
      "concepts": [
        "maven-central",
        "package-distribution",
        "release-management",
        "backward-compatibility",
        "snapshot-repository"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily add Temporal Java SDK as a dependency from Maven Central, requiring workarounds with snapshot repositories.",
      "rootCause": "Backward incompatible changes needed to be completed before making an official release to Maven Central.",
      "proposedFix": null,
      "workaround": "Use 0.20.0-SNAPSHOT release from https://oss.sonatype.org/content/repositories/snapshots/ repository",
      "resolution": "fixed",
      "resolutionDetails": "Official Maven packages were eventually released to Maven Central after completing backward incompatible changes.",
      "related": [],
      "keyQuote": "We are waiting for completing all the backward incompatible changes before making an official release.",
      "number": 342,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:09:16.176Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not support robfig-style cron expressions like \"@every 30s\", which work on a real Temporal server but fail with an INVALID_ARGUMENT error indicating the expression format is incorrect.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflowExecution"
      ],
      "components": [
        "TestWorkflowEnvironment",
        "cron-expression-parser",
        "workflow-client"
      ],
      "concepts": [
        "cron-scheduling",
        "test-environment",
        "expression-validation",
        "compatibility",
        "robfig-syntax"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test cron workflows using robfig-style expressions in TestWorkflowEnvironment, forcing them to switch expression formats between testing and production.",
      "rootCause": "TestWorkflowEnvironment uses a cron expression parser that only accepts standard 5-field cron format, while the production Temporal server supports robfig-style shorthand expressions like \"@every 30s\".",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Invalid cron expression \"@every 30s\": Cron expression contains 2 parts but we expect one of [5]",
      "number": 341,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:09:16.785Z"
    },
    {
      "summary": "Feature request to add a workflow metadata query that returns supported queries and signals. Currently, UI must emit unsupported queries and parse error messages to discover supported operations, causing unnecessary service logging.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [
        "WorkflowQuery"
      ],
      "components": [
        "workflow-engine",
        "query-handler",
        "metadata-service"
      ],
      "concepts": [
        "workflow-metadata",
        "query-discovery",
        "signal-discovery",
        "dynamic-capabilities",
        "workflow-introspection"
      ],
      "severity": "medium",
      "userImpact": "UI developers must implement unreliable workarounds to discover workflow capabilities, generating error logs and requiring custom parsing logic.",
      "rootCause": "No standard mechanism exists for workflows to expose their supported queries and signals metadata to callers.",
      "proposedFix": "Add a built-in metadata query that returns lists of supported queries and signals for a workflow, accessible through all SDKs.",
      "workaround": "UI can emit unsupported queries and parse the returned error message to infer supported operations, though this is unreliable and generates service-level error logs.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        51
      ],
      "keyQuote": "Add a query that would return metadata about workflow. Lists of supported queries and signals should be included into the result.",
      "number": 335,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:09:16.339Z"
    },
    {
      "summary": "TestWorkflowEnvironment was moved from io.temporal.testing to a new temporal-testing module in v1.0.5, breaking imports for users upgrading from v1.0.4. User requests better documentation of breaking changes.",
      "category": "docs",
      "subcategory": "migration-guide",
      "apis": [
        "TestWorkflowEnvironment"
      ],
      "components": [
        "testing",
        "module-structure",
        "imports"
      ],
      "concepts": [
        "breaking-change",
        "version-upgrade",
        "test-framework",
        "module-reorganization",
        "migration"
      ],
      "severity": "medium",
      "userImpact": "Users upgrading to v1.0.5 experience compilation failures due to moved test APIs and lack of clear breaking change documentation.",
      "rootCause": "Test support code was moved to temporal-testing module in v1.0.5 release (PR #292) without sufficient documentation of the breaking change.",
      "proposedFix": "Add breaking change documentation pointing users to include the new temporal-testing package.",
      "workaround": "Revert to v1.0.4 or add the temporal-testing module as a new dependency.",
      "resolution": "fixed",
      "resolutionDetails": "Issue resolved by providing information about the module move and suggesting improved changelog documentation for breaking changes.",
      "related": [
        292
      ],
      "keyQuote": "What might be helpful is have a change log that points out 'Breaking Change' and then point out that users need to include a new package.",
      "number": 334,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:08:37.433Z"
    },
    {
      "summary": "Testing with mock activities fails when using Mockito version 2+ due to annotation copying behavior. The error 'This annotation can be used only on the interface method it implements' occurs because newer Mockito versions copy all annotations to mocks, conflicting with Temporal's POJOActivityImplMetadata validation.",
      "category": "bug",
      "subcategory": "testing",
      "apis": [],
      "components": [
        "mock-framework",
        "activity-metadata",
        "testing-utilities"
      ],
      "concepts": [
        "mocking",
        "annotations",
        "testing",
        "compatibility",
        "activity-interface"
      ],
      "severity": "medium",
      "userImpact": "Users testing with Mockito 2+ versions cannot mock activities without workarounds, requiring manual configuration of mock settings.",
      "rootCause": "Mockito 2.x+ copies all annotations from source interfaces to mocks, but Temporal's POJOActivityImplMetadata validator expects clean interfaces without inherited annotations.",
      "proposedFix": "Make Temporal's annotation validation more lenient to handle mocks created with annotation copying, or document the withoutAnnotations() workaround.",
      "workaround": "Use Mockito.mock(ActivityInterface.class, Mockito.withSettings().withoutAnnotations()) when creating activity mocks (available in Mockito 2.11.2+).",
      "resolution": "wontfix",
      "resolutionDetails": "Issue was closed without a fix, with recommendation to upgrade examples to show proper Mockito 3 usage and withoutAnnotations() pattern.",
      "related": [],
      "keyQuote": "Mockito has switched to annotating mock with all the annotations it can find on the source class or interface, which makes Temporal's POJOActivityImplMetadata unhappy.",
      "number": 332,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:08:37.900Z"
    },
    {
      "summary": "User requests ability to customize gRPC retry options in ServiceStubsOptions. Currently, gRPC retries for up to 1 minute on deadline exceeded, which is too long for their use case. They want finer control over retry behavior similar to existing timeout configuration options.",
      "category": "feature",
      "subcategory": "rpc-configuration",
      "apis": [],
      "components": [
        "ServiceStubsOptions",
        "gRPC",
        "retry-logic"
      ],
      "concepts": [
        "retry",
        "deadline",
        "timeout",
        "configuration",
        "gRPC",
        "network-resilience"
      ],
      "severity": "medium",
      "userImpact": "Users cannot customize gRPC retry behavior, forcing them to accept long retry periods (1 minute) that may not match their application requirements.",
      "rootCause": null,
      "proposedFix": "Add customizable RPC retry parameters to ServiceStubsOptions and propagate them similarly to existing deadline settings (rpcTimeout, rpcLongPollTimeout, rpcQueryTimeout).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "RPC retry options were added to ServiceStubsOptions configuration.",
      "related": [],
      "keyQuote": "We would like to control how many times grpc retries. Currently, it will retry for a total of 1 mins when deadline exceeded, and it is too long for us.",
      "number": 330,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:08:36.590Z"
    },
    {
      "summary": "JSON deserialization fails when workflow/activity input data classes change between deployments (fields added, removed, or type-changed). Old workers cannot deserialize new data formats, breaking backward compatibility during rolling updates.",
      "category": "docs",
      "subcategory": "serialization-compatibility",
      "apis": [],
      "components": [
        "data-converter",
        "jackson-json-payload-converter",
        "workflow-input"
      ],
      "concepts": [
        "serialization",
        "backward-compatibility",
        "data-migration",
        "schema-evolution",
        "versioning",
        "jackson-configuration"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely evolve data class schemas used in workflow/activity methods without breaking old workers during rolling deployments.",
      "rootCause": "Temporal uses Jackson's default mapper configuration which rejects unknown properties by default; users must configure '@JsonIgnoreProperties(ignoreUnknown = true)' or customize data converters, but this is undocumented.",
      "proposedFix": "Improve documentation to explain that users should configure their serializer (Jackson) with compatible settings when making data class changes, and document best practices for schema evolution.",
      "workaround": "Annotate data classes with '@JsonIgnoreProperties(ignoreUnknown = true)' or implement custom data converters with appropriate Jackson mapper configuration.",
      "resolution": "invalid",
      "resolutionDetails": "Closed as misconfiguration, not a bug. Temporal correctly delegates serialization to Jackson; users must understand their serializer's configuration and compatibility requirements. Documentation improvements suggested rather than code changes.",
      "related": [],
      "keyQuote": "You should be aware of the serializer that you use and its configuration and make changes to data classes that are compatible with your combination of serializer and options",
      "number": 328,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:07:58.085Z"
    },
    {
      "summary": "Javadoc for WorkflowClient class refers to an incorrect method signature `newInstance(temporalServiceHost, temporalServicePort, namespace)` that doesn't exist in the actual API. The documentation needs to be updated to reference the correct method.",
      "category": "docs",
      "subcategory": "javadoc",
      "apis": [
        "WorkflowClient"
      ],
      "components": [
        "WorkflowClient",
        "documentation"
      ],
      "concepts": [
        "API documentation",
        "method signature",
        "javadoc",
        "API reference"
      ],
      "severity": "low",
      "userImpact": "Users following the documentation may attempt to use a non-existent API method, leading to compilation errors.",
      "rootCause": "Javadoc references an outdated or incorrect method signature that is not available in the current implementation.",
      "proposedFix": "Update the Javadoc to reference the actual available method signature for creating WorkflowClient instances.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was corrected to reference the correct API method signature.",
      "related": [],
      "keyQuote": "The Javadoc for WorkflowClient class refers to `WorkflowClient.newInstance(temporalServiceHost, temporalServicePort, namespace)` API... This `newInstance` method signature is not available.",
      "number": 325,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:07:55.985Z"
    },
    {
      "summary": "WorkflowFailedException wrapping makes it difficult for callers to handle errors consistently, as the same ApplicationFailure thrown from different execution contexts (Activity vs Workflow) gets wrapped differently (ActivityFailure vs ApplicationFailure), requiring callers to know internal implementation details.",
      "category": "feature",
      "subcategory": "exception-handling",
      "apis": [
        "ApplicationFailure",
        "ActivityFailure",
        "WorkflowFailedException"
      ],
      "components": [
        "exception-handling",
        "activity-executor",
        "workflow-execution"
      ],
      "concepts": [
        "exception-wrapping",
        "error-handling",
        "abstraction",
        "consistency",
        "caller-awareness"
      ],
      "severity": "medium",
      "userImpact": "Developers must add complex boilerplate code to handle the same business error differently depending on whether it originated from an Activity or Workflow, making code fragile to refactoring.",
      "rootCause": "ActivityFailure wraps ApplicationFailure exceptions from Activities, forcing callers to unwrap multiple layers to access error type information, while direct Workflow-thrown ApplicationFailure requires different handling logic.",
      "proposedFix": "Three proposed solutions: (1) Add common fields like getType() to WorkflowFailedException, (2) Make ApplicationFailure and ActivityFailure derive from common TemporalFailure base, or (3) Preserve ApplicationFailure type when thrown from Activity instead of wrapping it.",
      "workaround": "Unwrap exceptions in the workflow to standardize the exception a client would see, or manually check exception types and unwrap nested causes.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer indicated that changing exception structure would be a breaking change not considered at this time, and recommended using exception unwrapping as a workaround instead.",
      "related": [],
      "keyQuote": "caller does not really need to know if error happened in Activity or Application, it just needs to know error type, because this logic can change",
      "number": 324,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:07:58.118Z"
    },
    {
      "summary": "Local activities incorrectly retry when throwing ApplicationFailure.newNonRetryableFailure, while regular activities handle this correctly. The non-retryable failure exception is being ignored by the local activity execution framework.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "Workflow.newLocalActivityStub",
        "ApplicationFailure.newNonRetryableFailure"
      ],
      "components": [
        "local-activity-executor",
        "activity-retry-handler",
        "failure-processing"
      ],
      "concepts": [
        "retry-policy",
        "non-retryable-failure",
        "exception-handling",
        "local-activities",
        "activity-options"
      ],
      "severity": "high",
      "userImpact": "Users cannot prevent local activities from retrying using non-retryable failures, forcing them to use workarounds like extensive doNotRetry exception lists.",
      "rootCause": "Local activity execution framework does not properly recognize and respect ApplicationFailure.newNonRetryableFailure, treating it as a retriable failure instead.",
      "proposedFix": null,
      "workaround": "Use setDoNotRetry() with an extensive list of exceptions in LocalActivityOptions.RetryOptions.",
      "resolution": "unknown",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "throwing with ApplicationFailure.newNonRetryableFailure in Activity (launched via Workflow.newLocalActivityStub) results for workflow to keep retrying, which is incorrect behavior.",
      "number": 323,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:07:16.953Z"
    },
    {
      "summary": "The Gradle check-updates plugin is deprecated and should be replaced with automatic dependency update tools like Renovate or Dependabot.",
      "category": "other",
      "subcategory": "build-tooling",
      "apis": [],
      "components": [
        "gradle-build",
        "dependency-management"
      ],
      "concepts": [
        "deprecation",
        "dependency-updates",
        "build-configuration",
        "tooling"
      ],
      "severity": "low",
      "userImpact": "Build warnings are generated when using the Java SDK build configuration with the deprecated plugin.",
      "rootCause": "The name.remal.check-updates Gradle plugin has been deprecated by its maintainers.",
      "proposedFix": "Replace the deprecated check-updates plugin with automatic dependency update tools like Renovate or Dependabot.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The build configuration was updated to remove the deprecated plugin and adopt modern dependency management practices.",
      "related": [],
      "keyQuote": "Plugin name.remal.check-updates is deprecated: Use automatic dependency updates software like Renovate, Dependabot, etc...",
      "number": 321,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:07:16.923Z"
    },
    {
      "summary": "Generated sources for protobuf-generated code in temporal-serviceclient are not being published in source/javadoc JARs alongside compiled artifacts. While hand-written sources are included, the generated gRPC service client sources are missing from published Maven artifacts.",
      "category": "bug",
      "subcategory": "build-publishing",
      "apis": [],
      "components": [
        "gradle-build",
        "source-jar-task",
        "generated-code",
        "temporal-serviceclient"
      ],
      "concepts": [
        "artifact-publication",
        "source-distribution",
        "generated-sources",
        "build-configuration",
        "gradle-plugins",
        "maven-publishing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access or debug generated service client source code when using the SDK as a dependency, limiting source code visibility and IDE support for generated APIs.",
      "rootCause": "The sourceJar Gradle task is not configured to include generated sources from the build directory. A license checker plugin bug prevents adding generated sources to the main sourceSet.",
      "proposedFix": "Either (1) fix license plugin exclude configuration to allow adding generated sources to main sourceSet, or (2) debug and configure sourceJar task to explicitly include generated source files.",
      "workaround": "Add `sourceSets.main.java.srcDirs = [\"$buildDir/generated/main/java\",\"src/main/java\"]` to build.gradle, though this breaks license checking.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        145,
        57,
        78
      ],
      "keyQuote": "You are right, I don't see sources for the generated code.",
      "number": 317,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:07:18.288Z"
    },
    {
      "summary": "Tag names are inconsistent between Temporal Server and SDKs (Java, Go), causing SDK metrics to not appear in Grafana dashboards. The issue involves discrepancies like 'Namespace' in SDK vs 'namespace' in Server, preventing real namespace data from being displayed.",
      "category": "bug",
      "subcategory": "metrics-tagging",
      "apis": [],
      "components": [
        "metrics",
        "logging-tags",
        "serviceclient"
      ],
      "concepts": [
        "metrics",
        "tags",
        "grafana",
        "prometheus",
        "namespace",
        "consistency",
        "dashboard"
      ],
      "severity": "medium",
      "userImpact": "Users cannot see SDK metrics in Grafana dashboards due to tag name mismatches between server and SDK implementations.",
      "rootCause": "Tag naming conventions differ between Server (common/metrics/tags.go) and SDKs (MetricsTag.java, internal_logging_tags.go), with inconsistencies like case sensitivity and naming (e.g., 'Namespace' vs 'namespace', 'WorkflowType' vs 'workflowType').",
      "proposedFix": "Standardize tag names across Server and all SDKs, and update Grafana dashboard JSON to use consistent tag names. PRs #318 (Java SDK), #345 (Go SDK), and dashboards #8 were proposed to address this.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Addressed through coordinated PRs in Java SDK (#318), Go SDK (#345), and dashboards repository (#8) to standardize tag names.",
      "related": [
        318,
        345
      ],
      "keyQuote": "The graphana dashboard use names like namespace, workerType etc which seems to be in consistent with tags originated from server",
      "number": 315,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:06:38.328Z"
    },
    {
      "summary": "Stack trace queries on closed workflows throw an INVALID_ARGUMENT error instead of gracefully returning empty stack or a human-readable message indicating the workflow is closed.",
      "category": "bug",
      "subcategory": "workflow-query",
      "apis": [
        "query"
      ],
      "components": [
        "SyncWorkflow",
        "DeterministicRunnerImpl",
        "ReplayWorkflowExecutor"
      ],
      "concepts": [
        "workflow-closure",
        "query-handling",
        "error-messaging",
        "stack-trace",
        "workflow-state"
      ],
      "severity": "medium",
      "userImpact": "Users cannot query stack traces for completed, failed, or terminated workflows and receive cryptic errors instead of clear feedback.",
      "rootCause": "DeterministicRunnerImpl.checkClosed() throws an error when querying a closed workflow instead of returning empty results or a descriptive message.",
      "proposedFix": "Return empty stack trace or a human-readable message indicating the workflow is closed instead of throwing INVALID_ARGUMENT error.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by modifying stack trace query handling to gracefully handle closed workflows.",
      "related": [],
      "keyQuote": "A human readable string that indicates that workflow is closed.",
      "number": 310,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:06:36.825Z"
    },
    {
      "summary": "WorkflowServiceStubs instantiation fails in Spring service due to gRPC version mismatch. The application requires grpc-netty-shaded 1.33.1+ (method maxInboundMessageSize added in later versions), but the user's dependency tree shows 1.30.2.",
      "category": "bug",
      "subcategory": "dependency-compatibility",
      "apis": [
        "WorkflowServiceStubs"
      ],
      "components": [
        "service-client",
        "grpc-netty",
        "dependency-management"
      ],
      "concepts": [
        "dependency-conflict",
        "version-mismatch",
        "classpath-resolution",
        "Spring-integration",
        "gRPC-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot instantiate WorkflowServiceStubs in Spring applications if their dependency tree includes incompatible gRPC versions.",
      "rootCause": "SDK upgraded grpc-netty-shaded from 1.30.2 to 1.33.1 between v1.0.2 and v1.0.3, but users with transitive dependencies pulling older versions experience method-not-found errors.",
      "proposedFix": "Update grpc-netty-shaded version to 1.33.1 or higher in project configuration, or use dependency exclusions/management to override transitive dependencies.",
      "workaround": "Explicitly set grpc-netty-shaded version to 1.33.1+ in dependency management.",
      "resolution": "wontfix",
      "resolutionDetails": "Issue closed by maintainer as user configuration problem, not an SDK bug. User must manage their own dependency versions. Team continues upgrading gRPC versions proactively.",
      "related": [],
      "keyQuote": "You must be overriding netty-shadded version in your configuration somewhere. We are trying to keep all grpc packages up to date.",
      "number": 309,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:06:38.439Z"
    },
    {
      "summary": "ActivityCompletionClient's completeExceptionally method throws an IllegalStateException when used with ApplicationFailure exceptions because the converter is not set, preventing proper exception serialization.",
      "category": "bug",
      "subcategory": "activity-completion",
      "apis": [
        "ActivityCompletionClient",
        "ApplicationFailure"
      ],
      "components": [
        "activity-completion-client",
        "failure-converter",
        "manual-activity-completion"
      ],
      "concepts": [
        "exception-handling",
        "async-completion",
        "failure-serialization",
        "converter",
        "non-retryable-failure"
      ],
      "severity": "high",
      "userImpact": "Users cannot use ActivityCompletionClient.completeExceptionally() with ApplicationFailure without encountering errors and error logs.",
      "rootCause": "The FailureConverter attempts to convert exceptions to Failure objects but the payload converter is not initialized when called from ManualActivityCompletionClientImpl.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Addressed by PR #307 according to comment from vitarb",
      "related": [
        307
      ],
      "keyQuote": "converter not set at io.temporal.common.converter.EncodedValues.toPayloads(EncodedValues.java:48)",
      "number": 308,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:05:58.390Z"
    },
    {
      "summary": "Saga compensations are currently executed in the current cancellation scope, which prevents them from running when the workflow is cancelled. The feature request is to execute compensations in a disconnected cancellation scope by default, with an option to disable this behavior.",
      "category": "feature",
      "subcategory": "saga-compensation",
      "apis": [
        "Saga.compensate"
      ],
      "components": [
        "saga",
        "cancellation-scope",
        "compensation"
      ],
      "concepts": [
        "cancellation",
        "compensation",
        "disconnected-scope",
        "error-handling",
        "workflow-cancellation"
      ],
      "severity": "medium",
      "userImpact": "Users must manually wrap Saga.compensate in a detached scope to ensure compensations run during workflow cancellation, which is error-prone and not obvious from samples.",
      "rootCause": "Saga.compensate executes in the current cancellation scope, inheriting cancellation semantics that prevent execution during workflow cancellation",
      "proposedFix": "Execute compensation actions in a disconnected cancellation scope by default, and add Saga.Option to disable this behavior if needed",
      "workaround": "Manually wrap Saga.compensate calls in a detached cancellation scope",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "By default execute compensation actions in a disconnected cancellation scope. Add Saga.Option to disable this behavior.",
      "number": 305,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:05:57.483Z"
    },
    {
      "summary": "StackTrace is empty when failure comes from another language SDK. The system cannot deserialize stack traces from other languages into Java-specific format, making cross-language error debugging difficult.",
      "category": "bug",
      "subcategory": "cross-language-errors",
      "apis": [],
      "components": [
        "exception-handling",
        "deserialization",
        "failure-proto"
      ],
      "concepts": [
        "stack-trace",
        "cross-language",
        "error-messaging",
        "deserialization",
        "debugging"
      ],
      "severity": "medium",
      "userImpact": "Users debugging cross-language workflows cannot see stack traces from non-Java SDKs, hindering troubleshooting of distributed failures.",
      "rootCause": "Temporal cannot deserialize stack traces from other languages into language-specific Java stack trace objects.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporal can't deserialize a stacktrace from another language into a language-specific stack trace.",
      "number": 302,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:05:56.872Z"
    },
    {
      "summary": "Worker.replayWorkflowExecution() swallows all exceptions without reporting replay failures, causing replay tests to never fail even when breaking changes are made to the workflow. The method catches and silently ignores all exceptions, preventing detection of workflow incompatibilities.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Worker.replayWorkflowExecution",
        "WorkflowReplayer.replayWorkflowExecutionFromResource"
      ],
      "components": [
        "worker",
        "testing-framework",
        "workflow-replayer"
      ],
      "concepts": [
        "replay-testing",
        "exception-handling",
        "workflow-validation",
        "test-failure-detection",
        "backward-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably test workflow changes using replay functionality because test failures are silently swallowed, preventing detection of breaking changes.",
      "rootCause": "The replayWorkflowExecution() method has an empty catch block that swallows all exceptions without re-throwing or reporting them.",
      "proposedFix": "The catch block should properly handle and report exceptions instead of silently ignoring them.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The empty catch block was fixed to properly propagate exceptions during replay execution.",
      "related": [
        300
      ],
      "keyQuote": "The replay test with Java SDK never fails given it can successfully parse the workflow history, regardless of what changes are made to the workflow",
      "number": 301,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:05:19.347Z"
    },
    {
      "summary": "WorkflowExecutionHistory.fromJson() cannot deserialize workflow history exported from Temporal Web console or CLI, due to differences in JSON schema (date/time format and enum representation) compared to what the Java SDK expects.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "WorkflowReplayer",
        "WorkflowExecutionHistory"
      ],
      "components": [
        "workflow-replayer",
        "history-deserialization",
        "json-marshaling"
      ],
      "concepts": [
        "serialization",
        "json-schema",
        "replay-testing",
        "format-compatibility",
        "enum-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot use workflow history exported from Web console or CLI for replay testing without manually converting the JSON format, blocking a key testing pattern.",
      "rootCause": "WorkflowExecutionHistory.fromJson() expects a specific internal JSON schema, but Web console and CLI export formats use different representations for timestamps (RFC3339 strings vs protobuf Duration objects) and enums (string values vs UPPER_CASE names).",
      "proposedFix": "Update WorkflowExecutionHistory.fromJson() to support multiple JSON formats (Web console, CLI, and internal SDK format) with appropriate deserializers.",
      "workaround": "Manually convert tctl JSON output by replacing enum values with matching SDK enum format and converting timestamp fields from RFC3339 strings to the expected protobuf format.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        268
      ],
      "keyQuote": "Both formats do not work with Java SDK's WorkflowReplayer and fail when it tries to run WorkflowExecutionHistory.fromJson() due to various JSON deserialization issues.",
      "number": 300,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:05:19.835Z"
    },
    {
      "summary": "Request to support GraalVM native image compilation for the Java SDK to enable reduced memory footprint and faster startup times. The community has provided native-image descriptors and the team has documented the approach for users to provide their own proxy configurations.",
      "category": "feature",
      "subcategory": "graalvm-native-image",
      "apis": [],
      "components": [
        "graalvm-native-image",
        "reflection-metadata",
        "proxy-configuration"
      ],
      "concepts": [
        "native-compilation",
        "memory-optimization",
        "startup-performance",
        "ahead-of-time-compilation",
        "descriptor-generation",
        "reflection-handling"
      ],
      "severity": "medium",
      "userImpact": "Users can now compile Temporal Java SDK applications as GraalVM native images for significantly faster startup times and reduced memory usage in containerized environments.",
      "rootCause": "GraalVM native image compilation requires reflection metadata descriptors (native-image.properties, reflect-config.json, proxy-config.json) which must be provided for the SDK and user-defined classes.",
      "proposedFix": "SDK provides native-image descriptors for Temporal classes; users supply descriptors for their own workflows using GraalVM tracing agent or manual configuration.",
      "workaround": "Use GraalVM tracing agent during testing to automatically generate native-image descriptors, then manually clean and integrate them; or manually create proxy-config.json entries for workflow interfaces.",
      "resolution": "fixed",
      "resolutionDetails": "Documentation added at docs/AOT-native-image.md with guidance on generating descriptors using the tracing agent; community-provided descriptors cleaned and integrated into the SDK.",
      "related": [],
      "keyQuote": "The performance of a Java application running on a native image is super impressive.",
      "number": 295,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:05:19.512Z"
    },
    {
      "summary": "Workflow.getInfo() method fails when called from within a query handler because the query thread is not a workflow thread. Users need access to workflow information from query methods.",
      "category": "bug",
      "subcategory": "workflow-queries",
      "apis": [
        "Workflow.getInfo"
      ],
      "components": [
        "workflow-query-handler",
        "workflow-context"
      ],
      "concepts": [
        "workflow-information",
        "query-execution",
        "thread-context",
        "workflow-metadata"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access workflow metadata (like execution details) from query handler methods, limiting query functionality.",
      "rootCause": "Query execution runs on a different thread than the workflow thread, causing Workflow.getInfo() to fail with thread context validation.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Support was added to allow Workflow.getInfo() to be called from query method bodies.",
      "related": [],
      "keyQuote": "Workflow.getInfo returns workflow information",
      "number": 294,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:04:39.438Z"
    },
    {
      "summary": "The whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows test is flaky, failing intermittently with an assertion error expecting 2 but getting 1. The test verifies that workflows are properly cached when sticky worker mode is enabled for child workflows.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "sticky-worker",
        "child-workflow",
        "test-framework"
      ],
      "concepts": [
        "caching",
        "sticky-workers",
        "test-flakiness",
        "child-workflows",
        "timing"
      ],
      "severity": "medium",
      "userImpact": "Test flakiness undermines confidence in the sticky worker caching feature for child workflows, making it difficult to verify correct behavior in CI/CD pipelines.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved as indicated by the comment 'Not anymore', suggesting the underlying test flakiness was fixed in a subsequent change.",
      "related": [],
      "keyQuote": "java.lang.AssertionError: 1 expected:<2> but was:<1>",
      "number": 290,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:04:39.593Z"
    },
    {
      "summary": "TestWorkflowEnvironment does not set the close time on the visibility record for workflow execution info. This causes tests to not properly reflect workflow completion time metadata.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowExecutionInfo"
      ],
      "components": [
        "test-workflow-environment",
        "visibility-record",
        "workflow-execution-info"
      ],
      "concepts": [
        "test-server",
        "workflow-execution",
        "metadata",
        "close-time",
        "visibility"
      ],
      "severity": "medium",
      "userImpact": "Users testing workflows with TestWorkflowEnvironment cannot properly validate or inspect workflow execution close time, affecting test completeness and accuracy.",
      "rootCause": "TestWorkflowEnvironment is not populating the close time field on the visibility record when workflows complete.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "TestWorkflowEnvironment does not set WorkflowExecutionInfo closeTime",
      "number": 262,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:04:38.926Z"
    },
    {
      "summary": "Create a @WorkflowTest JUnit rule to encapsulate WorkflowTestEnvironment setup, teardown, and configuration (globalTimeout, watchman) to reduce boilerplate code in test classes.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowTestEnvironment"
      ],
      "components": [
        "test-framework",
        "junit-integration",
        "workflow-testing"
      ],
      "concepts": [
        "test-setup",
        "boilerplate-reduction",
        "junit-rule",
        "test-environment",
        "configuration-simplification"
      ],
      "severity": "low",
      "userImpact": "Test developers can simplify their workflow test code by using a declarative rule instead of manual setup and teardown.",
      "rootCause": null,
      "proposedFix": "Create a @WorkflowTest JUnit rule that encapsulates WorkflowTestEnvironment initialization, teardown, globalTimeout, and watchman setup.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Addressed as part of PR #286 which implemented the WorkflowTest rule.",
      "related": [
        286
      ],
      "keyQuote": "Create `@WorkflowTest` rule that would encapsulate all of these to simplify code.",
      "number": 259,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:04:00.871Z"
    },
    {
      "summary": "Request to add an OpenTracing context propagator for the Java SDK. The implementation should be compatible with OpenTelemetry since OpenTracing is now part of the OpenTelemetry project.",
      "category": "feature",
      "subcategory": "context-propagation",
      "apis": [],
      "components": [
        "context-propagator",
        "opentracing",
        "opentelemetry"
      ],
      "concepts": [
        "context-propagation",
        "distributed-tracing",
        "observability",
        "interoperability"
      ],
      "severity": "medium",
      "userImpact": "Users can integrate Temporal workflows with OpenTracing/OpenTelemetry observability platforms for distributed tracing.",
      "rootCause": null,
      "proposedFix": "Reference implementation in Cadence Java client pull request #478",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Addressed in PR #418 which implements context propagation with OpenTelemetry support",
      "related": [
        418
      ],
      "keyQuote": "Since opentracing is now part of opentelemetry, it would be great if you could check that the new context propagator will work with opentelemetry as well.",
      "number": 258,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:04:00.708Z"
    },
    {
      "summary": "Add API to expose the failure of a previous workflow run through the workflow context, similar to the existing getLastCompletionResult API. This is needed when continueAsNew is triggered due to cron or retry policy.",
      "category": "feature",
      "subcategory": "workflow-context",
      "apis": [
        "getLastCompletionResult"
      ],
      "components": [
        "workflow-context",
        "cron-retry",
        "continuation"
      ],
      "concepts": [
        "failure-handling",
        "previous-run",
        "continueAsNew",
        "retry-policy",
        "cron",
        "workflow-state"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access failure information from the previous workflow run when using continueAsNew, limiting error handling and retry logic capabilities.",
      "rootCause": null,
      "proposedFix": "Expose a lastFailure API through the workflow context to expose the failure of the previous run.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by #260 which implements the lastFailure API",
      "related": [
        260
      ],
      "keyQuote": "Expose lastFailure api which exposes failure of previous run but we still did a continueAsNew because of cron or retry policy.",
      "number": 257,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:04:01.601Z"
    },
    {
      "summary": "Activities fail with heartbeat errors when tasks are queued and workers are at max concurrency. The activity expires in the buffer before any worker can start it, causing heartbeat attempts to fail with 'workflow already completed' errors.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-worker",
        "activity-poller",
        "task-executor"
      ],
      "concepts": [
        "heartbeat",
        "timeout",
        "concurrency",
        "activity-queuing",
        "start-to-close",
        "buffering"
      ],
      "severity": "high",
      "userImpact": "Users experience unexpected activity failures when running workflows with queued activities and limited worker concurrency, impacting reliability of activity execution.",
      "rootCause": "Activity pollers prefetch tasks into a buffer even when no executors are available, causing activities with shorter start-to-close timeouts to expire while waiting for an executor to become free.",
      "proposedFix": "Implement prefetch prevention when executors are unavailable, similar to the fix in PR #286 which prevents activity pollers from prefetching when there are no available executors.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by implementing prefetch prevention in activity pollers to avoid buffering tasks when no executors are available (PR #286).",
      "related": [
        286
      ],
      "keyQuote": "Activity pollers don't prefetch activities if there is no executors available. It was implemented in #286",
      "number": 256,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:03:22.593Z"
    },
    {
      "summary": "The test service's PollActivityTaskQueue doesn't return empty polls after a timeout like the real service does, causing gRPC-level request timeouts. The feature request is to make the test service return an empty poll after one minute of no available tasks.",
      "category": "feature",
      "subcategory": "test-service",
      "apis": [
        "PollActivityTaskQueue"
      ],
      "components": [
        "test-service",
        "activity-poller",
        "grpc-transport"
      ],
      "concepts": [
        "polling",
        "timeout",
        "empty-response",
        "task-queue",
        "request-timeout"
      ],
      "severity": "low",
      "userImpact": "Users see scary gRPC timeout warnings in logs when running tests with the test service, even though they're benign.",
      "rootCause": "TestWorkflowStoreImpl.PollActivityTaskQueue blocks indefinitely instead of returning an empty poll after the standard one-minute timeout.",
      "proposedFix": "Modify test service to return an empty poll after one minute, matching the behavior of the real service.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by #713, which implements the empty poll timeout behavior.",
      "related": [
        713
      ],
      "keyQuote": "Service returns an empty poll after a minute if no tasks are available. The test service never returns an empty poll, blocking until a task is available.",
      "number": 248,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:03:22.148Z"
    },
    {
      "summary": "Request to support dynamic loading of activity and workflow implementations at runtime, similar to Java app engines using class loaders. The SDK should expose a factory interface that allows providing untyped activity/workflow implementations based on their type.",
      "category": "feature",
      "subcategory": "activity-loading",
      "apis": [],
      "components": [
        "worker",
        "activity-registry",
        "workflow-registry"
      ],
      "concepts": [
        "dynamic-loading",
        "factory-pattern",
        "class-loader",
        "extension-point",
        "runtime-registration"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to dynamically load and register activity and workflow implementations at runtime instead of requiring pre-compiled registrations.",
      "rootCause": null,
      "proposedFix": "Expose an extension point/factory interface that the SDK calls with activity or workflow type to retrieve untyped implementations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support dynamic activity and workflow loading through extension points.",
      "related": [],
      "keyQuote": "Expose an extension point for dynamic activity loading...should provide a factory interface that is called with activity or workflow type to provide an untyped activity implementation.",
      "number": 245,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:03:21.899Z"
    },
    {
      "summary": "User requests the ability to configure PollerOptions.uncaughtExceptionHandler through WorkflowOptions or similar configuration mechanism, as currently there is no way to customize exception handling for uncaught exceptions thrown by the poller.",
      "category": "feature",
      "subcategory": "exception-handling",
      "apis": [],
      "components": [
        "PollerOptions",
        "WorkflowOptions",
        "WorkflowWorker"
      ],
      "concepts": [
        "exception-handling",
        "configuration",
        "error-logging",
        "task-processing",
        "worker-threads"
      ],
      "severity": "medium",
      "userImpact": "Users cannot customize how uncaught exceptions from the poller are handled, limiting their ability to integrate with monitoring and error tracking systems.",
      "rootCause": null,
      "proposedFix": "Expose uncaughtExceptionHandler configuration through WorkflowOptions or another accessible configuration mechanism",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It would be good if I can configure my own uncaughtExceptionHandler from workflowOptions or somewhere else.",
      "number": 235,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:02:43.513Z"
    },
    {
      "summary": "temporal-serviceclient library cannot be compiled with JDK 9 or later due to missing javax.annotation.Generated class. The JSR-250 javax.annotation package needs to be added as a dependency for JDK 9+ compatibility.",
      "category": "bug",
      "subcategory": "build-compatibility",
      "apis": [],
      "components": [
        "temporal-serviceclient",
        "build-system",
        "grpc-code-generation"
      ],
      "concepts": [
        "jdk-compatibility",
        "dependency-management",
        "java-modules",
        "code-generation",
        "build-gradle"
      ],
      "severity": "high",
      "userImpact": "Users cannot build the temporal-serviceclient library with JDK 9 or later versions, blocking adoption of newer Java versions.",
      "rootCause": "JSR-250 javax.annotation package is not included as a dependency in temporal-serviceclient's build.gradle, which is required for JDK 9+ where it was removed from the standard library.",
      "proposedFix": "Add the JSR-250 javax.annotation package as a dependency in temporal-serviceclient's build.gradle file when building with JDK 9 or later.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fix was implemented to add JSR-250 javax.annotation dependency for JDK 9+ compatibility (see PR #231).",
      "related": [
        231
      ],
      "keyQuote": "The temporal-serviceclient library cannot be compiled with JDK 15 (actually, JDK 9 or later)",
      "number": 232,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:02:43.607Z"
    },
    {
      "summary": "Workflow code currently cannot access activity start and completion time information that exists in the workflow history. Users need an API to retrieve full activity execution details including the exact time an activity started and completed on the worker.",
      "category": "feature",
      "subcategory": "activity-execution-info",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "workflow-execution",
        "activity-executor",
        "history"
      ],
      "concepts": [
        "activity-timing",
        "execution-metadata",
        "worker-information",
        "history-access",
        "activity-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users cannot track actual activity start/completion times in real-time across workflows, limiting visibility into distributed execution and cross-service logging capabilities.",
      "rootCause": null,
      "proposedFix": "Expose an API to get full information about activity execution including start time, completion time, and worker identity from workflow code.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1009
      ],
      "keyQuote": "The workflow history contains information about the time and identity of the activity worker that started and completed an activity. But this information is not available to the workflow code.",
      "number": 228,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:02:43.766Z"
    },
    {
      "summary": "WorkflowQueue needs to implement Serializable to enable storing ordered event processing across workflow executions without long-running workflows. This is a Java SDK enhancement that would allow the technique described in a community discussion to be properly implemented.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [
        "WorkflowQueue"
      ],
      "components": [
        "workflow-queue",
        "serialization",
        "java-sdk"
      ],
      "concepts": [
        "event-ordering",
        "serialization",
        "long-running-workflows",
        "workflow-state",
        "entity-processing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use WorkflowQueue for ordered event processing across workflow executions because it does not implement Serializable, forcing them to use alternative approaches.",
      "rootCause": "WorkflowQueue does not implement the Serializable interface, which is required for persisting workflow state.",
      "proposedFix": "Implement Serializable on WorkflowQueue class",
      "workaround": "Use Java Queue instead of WorkflowQueue",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        792
      ],
      "keyQuote": "To implement this solution, we need WorkflowQueue to be serializable. At this time we can not use this technique as the WorkflowQueue is not implementing Serializable.",
      "number": 227,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:02:05.037Z"
    },
    {
      "summary": "Signal methods in Java SDK currently execute in separate threads per signal, allowing concurrent handling. Request is to add threading configuration option to @SignalMethod to support single-threaded sequential signal processing with built-in queueing.",
      "category": "feature",
      "subcategory": "signal-threading",
      "apis": [
        "SignalMethod"
      ],
      "components": [
        "signal-dispatcher",
        "workflow-threading",
        "signal-handler"
      ],
      "concepts": [
        "threading",
        "concurrency",
        "signal-delivery",
        "flow-control",
        "queueing",
        "thread-pool"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily enforce sequential signal processing, limiting their ability to control signal handling flow and implement backpressure mechanisms.",
      "rootCause": "Signal dispatch architecture uses thread-per-signal model without configuration options for alternative threading strategies.",
      "proposedFix": "Add @SignalMethod parameter to configure threading mode (e.g., single-threaded vs multi-threaded), defaulting to single-thread with option for concurrent dispatch.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Default signal handling to a single thread and provide an option through @SignalMethod parameter to multithreaded dispatch.",
      "number": 214,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:02:04.897Z"
    },
    {
      "summary": "CheckedExceptionWrapper uses reflection to access java.lang.Throwable.cause, triggering illegal reflective access warnings in Java 9+. These warnings appear when running workflows and persist across versions.",
      "category": "bug",
      "subcategory": "exception-handling",
      "apis": [],
      "components": [
        "CheckedExceptionWrapper",
        "exception-handling",
        "internal-common"
      ],
      "concepts": [
        "reflection",
        "Java-modules",
        "illegal-access",
        "exception-wrapping",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users see warning messages in console output when running workflows, which may cause confusion and appears unprofessional despite the code functioning correctly.",
      "rootCause": "io.temporal.internal.common.CheckedExceptionWrapper uses reflective access to Throwable.cause field, which violates Java 9+ module encapsulation rules and triggers warnings.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #251, which addressed the illegal reflective access operation",
      "related": [
        251
      ],
      "keyQuote": "Illegal reflective access by io.temporal.internal.common.CheckedExceptionWrapper to field java.lang.Throwable.cause",
      "number": 205,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:02:04.515Z"
    },
    {
      "summary": "A block of code appears to be duplicated in ActivityPollTask.java around line 78, though it doesn't appear to cause functional issues. This was resolved as a duplicate of issue #478.",
      "category": "bug",
      "subcategory": "code-quality",
      "apis": [],
      "components": [
        "ActivityPollTask",
        "worker"
      ],
      "concepts": [
        "code-duplication",
        "code-cleanup",
        "refactoring"
      ],
      "severity": "low",
      "userImpact": "No direct user impact as the duplicate code does not cause problems, but indicates code quality concerns.",
      "rootCause": "Accidental code duplication during development",
      "proposedFix": null,
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #478",
      "related": [
        478
      ],
      "keyQuote": "Looks like there was a block of code copied twice here... Does not look like it is a problem though.",
      "number": 204,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:01:24.526Z"
    },
    {
      "summary": "The testService's ensureDefaultFieldsForActivityRetryPolicy method does not rewrite nonRetryableErrorTypes field, causing retry policies to be incomplete. This blocks users from properly testing setDoNotRetry retry policies in unit tests.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "RetryPolicy"
      ],
      "components": [
        "testservice",
        "state-machines",
        "retry-policy"
      ],
      "concepts": [
        "retry",
        "error-handling",
        "test-framework",
        "policy-defaults"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly test or verify that setDoNotRetry retry policies are respected in unit tests, blocking upgrades to affected versions.",
      "rootCause": "The ensureDefaultFieldsForActivityRetryPolicy method is missing logic to rewrite the nonRetryableErrorTypes field when setting default retry policy values.",
      "proposedFix": "Add one-liner instruction to rewrite nonRetryableErrorTypes in the ensureDefaultFieldsForActivityRetryPolicy method, with corresponding tests.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed by PR #223 which implements the missing nonRetryableErrorTypes rewriting logic.",
      "related": [
        223
      ],
      "keyQuote": "ensureDefaultFieldsForActivityRetryPolicy don't rewrite nonRetryableErrorTypes. There are no corresponding instructions in the method.",
      "number": 203,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:01:25.435Z"
    },
    {
      "summary": "The STICKY_CACHE_THREAD_FORCED_EVICTION metric is being incremented twice when a workflow thread evicts from cache due to full thread pool - once in WorkflowThreadImpl#start and again inside cache.evictAnyNotInProcessing. Additionally, there are concerns about the retry logic that attempts resubmission after successful eviction despite no change in thread pool availability.",
      "category": "bug",
      "subcategory": "metrics-reporting",
      "apis": [],
      "components": [
        "WorkflowThreadImpl",
        "sticky-cache",
        "thread-pool",
        "metrics"
      ],
      "concepts": [
        "double-reporting",
        "cache-eviction",
        "thread-pool-rejection",
        "metrics-accuracy",
        "concurrency"
      ],
      "severity": "medium",
      "userImpact": "Users see inflated metrics for cache evictions, making it difficult to accurately monitor and tune workflow thread pool behavior.",
      "rootCause": "WorkflowThreadImpl#start unconditionally increments the STICKY_CACHE_THREAD_FORCED_EVICTION counter before calling cache.evictAnyNotInProcessing, which also increments the same counter, causing double reporting.",
      "proposedFix": "Remove the unconditional increment from WorkflowThreadImpl#start and rely on the increment inside cache.evictAnyNotInProcessing which is more accurate and checked.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The double reporting was fixed by removing the unconditional metric increment from WorkflowThreadImpl#start, keeping only the increment inside cache.evictAnyNotInProcessing.",
      "related": [],
      "keyQuote": "Remove unconditional increment from `WorkflowThreadImpl#start` and leave more correct and checked increment inside `cache.evictAnyNotInProcessing`",
      "number": 201,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:01:26.272Z"
    },
    {
      "summary": "PrometheusRegistry rejects metrics from MicrometerClientStatsReporter because different SDK components report the same metric with inconsistent tag sets. Prometheus requires all meters with the same name to have identical tag keys, but the SDK attempts to maximize useful data by dynamically including/excluding tags based on operation context.",
      "category": "bug",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "MicrometerClientStatsReporter",
        "GrpcMetricsInterceptor",
        "metrics-registry"
      ],
      "concepts": [
        "metrics-consistency",
        "prometheus-compatibility",
        "tag-cardinality",
        "metric-registration",
        "observability"
      ],
      "severity": "high",
      "userImpact": "Users cannot export metrics to Prometheus using PrometheusRegistry because the SDK fails at runtime with IllegalArgumentException when attempting to register metrics with inconsistent tag schemas.",
      "rootCause": "The SDK does not enforce consistent tag key sets across all metric registration paths. Different operations report the same metric (e.g., 'temporal_request_latency_seconds') with different tag setssome with only [Operation], others with [Namespace, Operation, TaskQueue, WorkflowType]violating Prometheus's constraint that identical metric names must always have identical tag keys.",
      "proposedFix": null,
      "workaround": "Pre-populate the root metric scope with default dummy values for all common metric tags (Namespace, ActivityType, OperationName, SignalName, QueryType, TaskQueue, StatusCode, Exception, WorkflowType) so all metrics are registered with the complete tag set from the first registration.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the SDK to ensure consistent tag key sets across all metric registrations, ensuring Prometheus compatibility.",
      "related": [],
      "keyQuote": "Prometheus requires each unique metric key to be always reported with the same set of tags. Unfortunately our SDK does not respect this constraint and tries to maximize amount of useful data that it publishes.",
      "number": 200,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:00:46.663Z"
    },
    {
      "summary": "Refactor workflow state machines to eliminate self-transitions and hidden conditional logic by introducing explicit states. This includes eliminating self-transitions in ActivityStateMachine and converting cancellationType from conditional logic to state-based modeling.",
      "category": "feature",
      "subcategory": "state-machine-refactoring",
      "apis": [],
      "components": [
        "ActivityStateMachine",
        "state-machine",
        "activity-execution",
        "cancellation-logic"
      ],
      "concepts": [
        "state-machine-design",
        "self-transitions",
        "explicit-modeling",
        "activity-cancellation",
        "conditional-logic",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Improves code maintainability and clarity for SDK developers by making complex activity execution logic explicitly modeled rather than hidden in conditional branches.",
      "rootCause": "Self-transitions and conditional logic in state machines obscure the actual state flow and make it difficult to understand and maintain activity execution logic across SDKs.",
      "proposedFix": "Introduce additional states to eliminate self-transitions where events can only be applied once. Convert activity cancellationType from if/else conditions to dedicated states in the state machine model.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The goal of these changes is to make sure that all of the complex logic related to activity execution is explicitly modeled.",
      "number": 193,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:00:43.464Z"
    },
    {
      "summary": "Intermittent NioEventLoop exceptions causing gRPC selector failures in unit tests, manifesting as 'Invalid argument' errors in the KQueue selector on macOS.",
      "category": "bug",
      "subcategory": "grpc-netty-transport",
      "apis": [],
      "components": [
        "grpc-netty",
        "event-loop",
        "selector"
      ],
      "concepts": [
        "network-io",
        "selector-loop",
        "threading",
        "platform-specific",
        "intermittent-failure"
      ],
      "severity": "medium",
      "userImpact": "Unit tests intermittently block with gRPC errors, reducing test reliability and developer experience.",
      "rootCause": "KQueue selector receiving 'Invalid argument' error in poll operation, likely due to file descriptor state or platform-specific NIO issue",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was not noticed in recent unit test configurations, indicating it may have been resolved through dependency updates or environment changes",
      "related": [],
      "keyQuote": "Intermittently unit tests get blocked producing a bunch of exceptions into the log: java.io.IOException: Invalid argument",
      "number": 192,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:00:44.021Z"
    },
    {
      "summary": "A ClassCastException occurs when an Activity throws an Error instead of an Exception, preventing proper error propagation and masking the actual failure. This happens because the activity handler tries to cast a Throwable to Exception without handling Error subclasses.",
      "category": "bug",
      "subcategory": "activity-error-handling",
      "apis": [
        "Activity"
      ],
      "components": [
        "POJOActivityTaskHandler",
        "ActivityWorker",
        "error-propagation"
      ],
      "concepts": [
        "exception-handling",
        "type-casting",
        "error-propagation",
        "activity-execution",
        "throwable-hierarchy"
      ],
      "severity": "high",
      "userImpact": "When Activities throw Errors, the actual failure is masked by a ClassCastException, making debugging difficult and preventing proper error handling.",
      "rootCause": "POJOActivityTaskHandler attempts to cast Throwable to Exception without handling the Error subclass, which is also a Throwable but not an Exception.",
      "proposedFix": "Handle both Exception and Error cases in the activity error handling logic, or broaden the catch clause to accept any Throwable.",
      "workaround": "Ensure Activities only throw Exception subclasses rather than Error subclasses, and avoid calling Workflow.getInfo() from Activities.",
      "resolution": "fixed",
      "resolutionDetails": "The casting logic was corrected to properly handle Error instances alongside Exceptions.",
      "related": [],
      "keyQuote": "java.lang.Error cannot be cast to java.lang.Exception",
      "number": 187,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:00:04.792Z"
    },
    {
      "summary": "Incorrect error handling in POJOActivityInboundCallsInterceptor loses the root cause exception (java.lang.Error) and masks it with a ClassCastException. When calling Workflow methods from within an Activity, the meaningful error message is lost.",
      "category": "bug",
      "subcategory": "activity-error-handling",
      "apis": [
        "Workflow.newLocalActivityStub",
        "LocalActivityOptions",
        "WorkflowOptions",
        "newWorkflowStub"
      ],
      "components": [
        "POJOActivityInboundCallsInterceptor",
        "POJOActivityTaskHandler",
        "LocalActivityWorker",
        "error-handling"
      ],
      "concepts": [
        "exception-masking",
        "error-propagation",
        "local-activities",
        "thread-safety",
        "error-casting",
        "debugging"
      ],
      "severity": "high",
      "userImpact": "Users encounter obscure ClassCastException errors instead of the meaningful original exception, making it difficult to diagnose and debug activity failures.",
      "rootCause": "POJOActivityInboundCallsInterceptor incorrectly casts java.lang.Error to java.lang.Exception, causing a ClassCastException that masks the original error message.",
      "proposedFix": "Create an Error subclass for Temporal Exceptions that need to be propagated through exception handling, allowing proper error handling in POJOActivityInboundCallsInterceptor.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by #190 with improved error handling in POJOActivityInboundCallsInterceptor.",
      "related": [
        190
      ],
      "keyQuote": "The root cause is completely lost and overridden by incorrect handling inside POJOActivityInboundCallsInterceptor#execute.",
      "number": 185,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:00:04.931Z"
    },
    {
      "summary": "Add support for building the Java SDK with recent JDK versions (JDK 11 and JDK 14). The changes required are minimal: updating the annotations module for JDK 9 compatibility and handling the `yield` keyword that became reserved in JDK 14.",
      "category": "feature",
      "subcategory": "build-system",
      "apis": [],
      "components": [
        "build-system",
        "java-compiler",
        "annotations-module"
      ],
      "concepts": [
        "JDK-compatibility",
        "build-toolchain",
        "language-features",
        "backwards-compatibility"
      ],
      "severity": "low",
      "userImpact": "Developers using recent JDK versions (11+) can build the SDK without encountering compatibility errors.",
      "rootCause": "Java SDK build configuration not updated for JDK 9+ features; `yield` keyword conflict in JDK 14",
      "proposedFix": "Update annotations module for JDK 9 support and replace deprecated constructor calls; handle `yield` keyword in JDK 14",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "PR was opened to address the JDK 9 and JDK 14 compatibility issues",
      "related": [],
      "keyQuote": "The changes to support JDK 9 are minor (annotations module, a deprecated constructor call), and JDK 14 requires one change for `yield` having become a Java keyword",
      "number": 176,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T18:00:03.934Z"
    },
    {
      "summary": "LocalActivityOptions builder allows creating activity stubs without required timeout constraints (scheduleToCloseTimeout or both scheduleToStartTimeout and startToCloseTimeout), violating documented requirements. Validation was moved to the service but should also be enforced in the SDK for local activities.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity-executor",
        "options-validation",
        "activity-stub"
      ],
      "concepts": [
        "timeout-constraints",
        "validation",
        "configuration",
        "local-activities",
        "defaults",
        "service-validation"
      ],
      "severity": "high",
      "userImpact": "Users can create invalid local activity configurations that pass in tests but fail at runtime, making it harder to catch configuration errors early in development.",
      "rootCause": "Validation logic was moved to the service, but local activity validation was not implemented in the SDK, creating an inconsistency between local and non-local activities.",
      "proposedFix": "Implement validation logic in the SDK for local activity options to enforce required timeout constraints at configuration time.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #194 which implemented proper validation for local activity timeout constraints in the SDK.",
      "related": [
        194
      ],
      "keyQuote": "These indeed should be done in the SDK.",
      "number": 175,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:59:23.570Z"
    },
    {
      "summary": "When RetryOptions is configured without specifying maxInterval for local activities, the SDK silently uses PT0S (zero duration) which causes an IllegalArgumentException during activity execution. This leads to cryptic errors and complete workflow hangs.",
      "category": "bug",
      "subcategory": "local-activities",
      "apis": [
        "Workflow.newLocalActivityStub",
        "LocalActivityOptions",
        "RetryOptions"
      ],
      "components": [
        "local-activity-worker",
        "retry-options",
        "activity-executor"
      ],
      "concepts": [
        "retry-policy",
        "backoff-interval",
        "configuration-validation",
        "error-handling",
        "timeout"
      ],
      "severity": "high",
      "userImpact": "Developers using local activities with incomplete RetryOptions configuration experience unclear exceptions and workflow hangs instead of helpful validation errors.",
      "rootCause": "RetryOptions.Builder.setMaximumInterval() is being called with PT0S when maxInterval is not explicitly set, causing an IllegalArgumentException that breaks local activity processing.",
      "proposedFix": "Either provide a sensible default for maxInterval in RetryOptions, or validate and provide a clear error message when maxInterval is not specified.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by improving RetryOptions validation to handle missing maxInterval configuration with appropriate defaults or error messages.",
      "related": [],
      "keyQuote": "java.lang.IllegalArgumentException: Invalid interval: PT0S",
      "number": 174,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:59:23.609Z"
    },
    {
      "summary": "ArithmeticException occurs in ReplayWorkflowExecutor after ~30 requests when executing multiple workflows without a workflow execution timeout. The exception is caused by time skipping logic jumping years ahead for completed workflow timers, leading to durations that M3 metrics cannot handle.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.newLocalActivityStub",
        "WorkflowOptions"
      ],
      "components": [
        "ReplayWorkflowExecutor",
        "ProtobufTimeUtils",
        "time-skipping-logic",
        "timer-queue"
      ],
      "concepts": [
        "timeout",
        "time-skipping",
        "duration-overflow",
        "workflow-completion",
        "local-activity",
        "metrics"
      ],
      "severity": "high",
      "userImpact": "Users running multiple workflows in tests or with test-server experience crashes after ~30 executions due to arithmetic overflow when calculating durations.",
      "rootCause": "Time skipping logic advances time to the next timer queue task, including timers for completed workflows. Running 1000 workflows causes time to jump ~10 years per execution, eventually creating durations too large for M3 metrics to handle.",
      "proposedFix": "Ignore time skipping for tasks that belong to completed workflows to prevent excessive time jumps.",
      "workaround": "Set setWorkflowExecutionTimeout() on WorkflowOptions to prevent the arithmetic exception.",
      "resolution": "stale",
      "resolutionDetails": "No known reproduction reported for over a year; closed as stale with instruction to reopen if new reports emerge.",
      "related": [],
      "keyQuote": "The time skipping automatically moves time to the next task in a timer queue... When running 1k workflows it jumps 10 years ahead after every execution.",
      "number": 173,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:59:25.311Z"
    },
    {
      "summary": "Failing to mark an Activity or Workflow interface as public produces a cryptic runtime error about invoking a public abstract method instead of a clear diagnostic message indicating the interface must be public.",
      "category": "bug",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "worker",
        "interface-registration",
        "error-messages"
      ],
      "concepts": [
        "visibility",
        "access-modifiers",
        "diagnostics",
        "validation",
        "developer-experience"
      ],
      "severity": "medium",
      "userImpact": "Developers waste time debugging a confusing runtime error when they forget to make their Activity or Workflow interface public.",
      "rootCause": "The framework does not validate that Activity and Workflow interfaces are public during registration, leading to runtime errors with misleading messages.",
      "proposedFix": "Add validation during registration/worker start to check that interfaces are public and provide a clear error message if they are not.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Improved error message added to provide clear diagnostic when interface is not public",
      "related": [],
      "keyQuote": "A nice error message indicating that the interface needs to be marked as \"public\" during registration / worker start",
      "number": 171,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:58:41.463Z"
    },
    {
      "summary": "Regression in 0.28.0 where workflows implementing empty marker interfaces fail with IllegalArgumentException. The code now throws an exception for interfaces without Temporal annotations, whereas 0.26.0 allowed them.",
      "category": "bug",
      "subcategory": "workflow-interface-metadata",
      "apis": [],
      "components": [
        "POJOWorkflowInterfaceMetadata",
        "POJOWorkflowImplMetadata",
        "workflow-implementation-factory"
      ],
      "concepts": [
        "interface-validation",
        "annotation-processing",
        "backward-compatibility",
        "reflection",
        "metadata-extraction"
      ],
      "severity": "high",
      "userImpact": "Existing code that uses marker interfaces in workflow implementations fails at runtime after upgrading to 0.28.0.",
      "rootCause": "POJOWorkflowInterfaceMetadata.newInstanceSkipWorkflowAnnotationCheck() now throws an exception for interfaces without methods, while 0.26.0 silently skipped them. The validation logic changed to be stricter for all interfaces regardless of Temporal annotations.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Interface doesn't contain any methods: WorkflowMarker - regression from 0.26.0 where empty marker interfaces were allowed",
      "number": 165,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:58:42.003Z"
    },
    {
      "summary": "Spring-based Temporal applications generate several non-fatal exceptions related to gRPC and PerfMark during initialization and execution, including Epoll availability errors, missing census stats classes, and PerfMark initialization failures. While these exceptions do not prevent workflows from executing correctly, they cause confusing debug output.",
      "category": "bug",
      "subcategory": "grpc-integration",
      "apis": [
        "WorkflowServiceStubs",
        "WorkflowClient",
        "WorkerFactory",
        "Worker"
      ],
      "components": [
        "grpc-client",
        "service-stubs",
        "worker-initialization",
        "dependency-management"
      ],
      "concepts": [
        "spring-integration",
        "classpath-configuration",
        "optional-dependencies",
        "debug-logging",
        "grpc-channel-setup"
      ],
      "severity": "low",
      "userImpact": "Users running Temporal with Spring Boot see confusing exception messages during initialization even though their workflows execute successfully, making it difficult to distinguish real errors from harmless dependency issues.",
      "rootCause": "Missing optional dependencies (PerfMark, census stats, platform-specific libraries) that gRPC attempts to load via reflection, combined with Spring's aggressive classloading behavior. The exceptions are gracefully handled by gRPC but logged at DEBUG level, appearing alarming to users.",
      "proposedFix": null,
      "workaround": "These are expected warnings from gRPC's optional dependency loading and can be safely ignored. Configure logging to suppress DEBUG messages from gRPC packages if desired.",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainers determined these are not Temporal SDK issues but rather expected behavior from gRPC's optional dependency handling. The exceptions are properly caught by gRPC and do not affect functionality. Responsibility lies with the application to manage its classpath if these dependencies are needed.",
      "related": [],
      "keyQuote": "The only place across all our transitive dependencies that uses this class is this one method in io.grpc.Context from io.grpc:grpc-context and it doesn't throw if the class is not available",
      "number": 162,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:58:44.802Z"
    },
    {
      "summary": "Java SDK payload headers protocol is out of sync with Go SDK and the server. A protocol change was made in the Go SDK that needs to be implemented in the Java SDK to maintain compatibility.",
      "category": "bug",
      "subcategory": "payload-serialization",
      "apis": [],
      "components": [
        "payload-handler",
        "protocol-serialization",
        "wire-format"
      ],
      "concepts": [
        "protocol-alignment",
        "interoperability",
        "payload-headers",
        "wire-protocol",
        "compatibility"
      ],
      "severity": "high",
      "userImpact": "Java SDK users may experience incompatibility issues with the Go SDK and Temporal server due to misaligned payload header protocols.",
      "rootCause": "Go SDK protocol changed for payload description on the wire, but Java SDK was not updated to match.",
      "proposedFix": "Update Java SDK payload header protocol to align with the Go SDK and server implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the Java SDK was brought into alignment with the Go SDK and server payload protocol.",
      "related": [],
      "keyQuote": "This PR changed the protocol for how payloads are described on the wire. The change has been landed in the Go SDK and is used by the server/the CLI, but the Java SDK is out of date.",
      "number": 155,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:58:03.184Z"
    },
    {
      "summary": "OffsetDateTime deserialization fails in version 0.27.0 due to Jackson not being able to deserialize the ZoneOffset component. This is a regression from version 0.26.0 and causes workflow execution failures.",
      "category": "bug",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "JacksonJsonPayloadConverter",
        "DefaultDataConverter",
        "serialization"
      ],
      "concepts": [
        "deserialization",
        "jackson",
        "java.time",
        "OffsetDateTime",
        "ZoneOffset"
      ],
      "severity": "high",
      "userImpact": "Workflows fail to execute when OffsetDateTime objects are used in activity results or workflow state.",
      "rootCause": "Jackson version upgrade lost support for OffsetDateTime deserialization; ZoneOffset cannot be deserialized from Object value without proper module configuration.",
      "proposedFix": null,
      "workaround": "Register JavaTimeModule from jackson-datatype-jsr310 with the ObjectMapper.",
      "resolution": "fixed",
      "resolutionDetails": "PR #191 added validation that OffsetDateTime is convertible, indicating the issue was resolved in a subsequent release.",
      "related": [
        191
      ],
      "keyQuote": "Cannot construct instance of `java.time.ZoneOffset` (although at least one Creator exists): cannot deserialize from Object value",
      "number": 153,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:58:03.706Z"
    },
    {
      "summary": "Activity.wrap and Workflow.wrap fail when wrapping an ActivityFailure with a chained Throwable cause instead of an Exception. The issue occurs in CheckedExceptionWrapper.unwrap which incorrectly assumes exception causes are either Error or Exception, not arbitrary Throwable types.",
      "category": "bug",
      "subcategory": "exception-handling",
      "apis": [
        "Activity.wrap",
        "Workflow.wrap"
      ],
      "components": [
        "CheckedExceptionWrapper",
        "FailureConverter",
        "LocalActivityWorker"
      ],
      "concepts": [
        "exception-handling",
        "type-casting",
        "failure-wrapping",
        "activity-execution",
        "error-propagation"
      ],
      "severity": "high",
      "userImpact": "Users cannot wrap activities with chained Throwable causes, causing runtime failures in local activity execution.",
      "rootCause": "CheckedExceptionWrapper.unwrap assumes exception causes are either Error or Exception subclasses, but does not handle cases where the cause is a Throwable that is neither, causing ClassCastException.",
      "proposedFix": "Modify CheckedExceptionWrapper.unwrap to properly handle Throwable types in the exception cause chain without casting assumptions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by pull request #172 and validated by issue #194.",
      "related": [
        172,
        194
      ],
      "keyQuote": "The bug is in the CheckedExceptionWrapper.unwrap which assumes that a cause of an exception is either Error or Exception, but never any other child of Throwable or Throwable itself.",
      "number": 149,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:58:03.466Z"
    },
    {
      "summary": "Workflow methods throwing unexpected exceptions should block the workflow for fixing rather than fail it outright. Currently only Errors block workflows; the proposal is to extend this behavior to exceptions not in a failure list, allowing workflows to resume automatically after code fixes without manual intervention.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-executor",
        "decision-task",
        "exception-handling"
      ],
      "concepts": [
        "exception-handling",
        "workflow-blocking",
        "error-recovery",
        "decision-task",
        "code-deployment",
        "workflow-resumption"
      ],
      "severity": "high",
      "userImpact": "Users experience simpler recovery from code bugs in workflows - automatic resumption after fixes instead of requiring manual reset operations.",
      "rootCause": null,
      "proposedFix": "Change default behavior to block workflow execution on any exception not specified in a FailList, similar to current Error handling behavior.",
      "workaround": "Keep current behavior and use reset to restart failed workflows.",
      "resolution": "fixed",
      "resolutionDetails": "The behavior was implemented to block workflows on exceptions and allow resumption after code fixes without manual intervention.",
      "related": [],
      "keyQuote": "An Error thrown from a workflow method already doesn't fail workflow, but fails a decision task, essentially blocking the workflow execution until the error is fixed.",
      "number": 146,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:57:24.928Z"
    },
    {
      "summary": "The newUntypedWorkflowStub method should check if runId is present before calling get() to avoid potential NullPointerException. This is a defensive programming issue in the WorkflowClientInternal class.",
      "category": "bug",
      "subcategory": "workflow-stub",
      "apis": [
        "newUntypedWorkflowStub"
      ],
      "components": [
        "WorkflowClientInternal",
        "workflow-stub-creation"
      ],
      "concepts": [
        "null-safety",
        "optional-handling",
        "defensive-programming",
        "runtime-error"
      ],
      "severity": "medium",
      "userImpact": "Users may encounter NullPointerException when creating untyped workflow stubs without proper runId validation.",
      "rootCause": "The code calls get() on an Optional runId without first checking if it is present, violating safe Optional usage patterns.",
      "proposedFix": "Add a check for runId.isPresent() before calling get() to safely handle the optional value.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed via pull request #148 which added proper Optional checking before get() call.",
      "related": [
        148
      ],
      "keyQuote": "newUntypedWorkflowStub should check if runId.isPresent() before calling get",
      "number": 144,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:57:24.457Z"
    },
    {
      "summary": "Users need access to the ObjectMapper created by JacksonJsonPayloadConverter to add custom Jackson modules (e.g., for Scala types, Kotlin data classes, or org-specific serialization). Currently, users must resort to reflection to modify the private mapper field.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [
        "JacksonJsonPayloadConverter",
        "DefaultDataConverter"
      ],
      "components": [
        "data-converter",
        "jackson-payload-converter",
        "serialization"
      ],
      "concepts": [
        "objectmapper",
        "jackson-modules",
        "custom-serialization",
        "scala-interop",
        "kotlin-interop",
        "reflection"
      ],
      "severity": "medium",
      "userImpact": "Scala and Kotlin users cannot easily configure Jackson to handle their language-specific types without resorting to brittle reflection hacks.",
      "rootCause": "JacksonJsonPayloadConverter does not expose the ObjectMapper, forcing users to either use reflection or create their own data converter.",
      "proposedFix": "Provide a public constructor that accepts a pre-configured ObjectMapper, or add a getObjectMapper() method to allow augmentation after creation.",
      "workaround": "Use reflection to access and modify the private 'mapper' field, though this is fragile and not recommended.",
      "resolution": "fixed",
      "resolutionDetails": "A public constructor accepting ObjectMapper was added to JacksonJsonPayloadConverter via PR #150.",
      "related": [
        150
      ],
      "keyQuote": "A new constructor for JacksonJsonPayloadConverter that allows us to pass our own ObjectMapper.",
      "number": 139,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:57:24.893Z"
    },
    {
      "summary": "Request to include local activity input data into the marker decision/event in the history for better troubleshooting, with configurable option through LocalActivityOptions to manage history size.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity",
        "event-history",
        "marker-decision"
      ],
      "concepts": [
        "activity-input",
        "event-history",
        "troubleshooting",
        "marker",
        "history-size",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users would have access to local activity inputs in event history for improved troubleshooting and debugging capabilities.",
      "rootCause": null,
      "proposedFix": "Add input field to marker decision/event with a configurable option in LocalActivityOptions to control inclusion",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to include local activity input in marker decisions with configurable LocalActivityOptions",
      "related": [],
      "keyQuote": "For troubleshooting having activity input available in the event history is very useful.",
      "number": 135,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:56:45.128Z"
    },
    {
      "summary": "Intermittent test failure in testWorkflowMetrics when running in constrained CI/CD environments. The test asserts a timing constraint (3.39s) that fails sporadically under resource constraints.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "metrics",
        "test-framework",
        "workflow-execution"
      ],
      "concepts": [
        "timing-constraint",
        "resource-constraint",
        "test-flakiness",
        "ci-environment",
        "performance-variability"
      ],
      "severity": "medium",
      "userImpact": "Test reliability is compromised in CI/CD environments, causing intermittent build failures that reduce developer confidence in the test suite.",
      "rootCause": "Test uses hard-coded timing assertions that fail when system resources are constrained, likely due to GC pauses or CPU contention in the CI environment.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified as possibly fixed by vitarb, suggesting a solution was implemented to handle timing variability.",
      "related": [],
      "keyQuote": "When running in a constrained CI/CD environment it sometimes fails",
      "number": 107,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:56:44.872Z"
    },
    {
      "summary": "Request for a health check mechanism to verify worker/factory connection health to Temporal servers. Users need a way to check connection status (e.g., `factory.isHealthy()`) for Kubernetes health check endpoints and automatic service restart on connection loss.",
      "category": "feature",
      "subcategory": "health-check",
      "apis": [],
      "components": [
        "worker",
        "factory",
        "connection-management"
      ],
      "concepts": [
        "health-check",
        "connection-monitoring",
        "service-recovery",
        "kubernetes",
        "liveness-probe",
        "reconnection"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably detect connection failures between workers and Temporal servers, making it difficult to implement automatic recovery in containerized environments.",
      "rootCause": null,
      "proposedFix": "Implement a health checking mechanism similar to the TChannel meta health check used in Cadence Java client, providing an API like `factory.isHealthy()` for connection status verification.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "A health checking mechanism that allows me to check whether the workers/factory have a healthy connection",
      "number": 102,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:56:45.464Z"
    },
    {
      "summary": "NullPointerException occurs when calling continueAsNew on a workflow method without arguments. The SDK fails to handle null input when creating ContinueAsNewWorkflowExecutionDecisionAttributes.",
      "category": "bug",
      "subcategory": "workflow-continuation",
      "apis": [
        "continueAsNewWorkflow"
      ],
      "components": [
        "DecisionsHelper",
        "ContinueAsNewWorkflowExecutionDecisionAttributes",
        "workflow-execution"
      ],
      "concepts": [
        "null-handling",
        "continue-as-new",
        "input-validation",
        "workflow-method",
        "argument-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot use continue as new pattern with workflow methods that have no arguments, causing runtime exceptions in production workflows.",
      "rootCause": "DecisionsHelper.continueAsNewWorkflowExecution does not properly handle null input when the workflow method has no parameters.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by adding proper null input handling in the continueAsNewWorkflowExecution method to support zero-argument workflow methods.",
      "related": [],
      "keyQuote": "java.lang.NullPointerException\\n\\tat io.temporal.proto.decision.ContinueAsNewWorkflowExecutionDecisionAttributes$Builder.setInput",
      "number": 98,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:56:06.729Z"
    },
    {
      "summary": "SimulatedTimeoutException of ScheduleToStart type should not be retried according to the retry policy. The test demonstrates this exception is being incorrectly retried, violating expected timeout behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "retry-policy",
        "timeout-handling",
        "test-framework"
      ],
      "concepts": [
        "timeout",
        "retry",
        "simulated-timeout",
        "error-handling",
        "test-fixture",
        "schedule-to-start"
      ],
      "severity": "medium",
      "userImpact": "Tests may pass with incorrect retry behavior, potentially masking real timeout handling issues in production code.",
      "rootCause": "SimulatedTimeoutException was incorrectly retried according to the retry policy instead of failing immediately.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "SimulatedTimeoutException support was removed from the Java SDK as it was making error handling convoluted and was considered incorrect. The mechanism will be reimplemented from scratch if needed in the future.",
      "related": [],
      "keyQuote": "There is no more simulated timeout exception in temporal java-sdk for some time, support of that class was incorrect and was making error handling convoluted.",
      "number": 94,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:56:06.782Z"
    },
    {
      "summary": "Feature request to add binary checksum support to WorkerOptions in the Java SDK, allowing developers to mark bad builds similar to functionality in other SDKs.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "worker-options",
        "binary-checksum"
      ],
      "concepts": [
        "binary-checksum",
        "build-validation",
        "worker-configuration",
        "quality-assurance"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently set binary checksums in the Java SDK to mark and identify bad builds.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by issue #270",
      "related": [
        270
      ],
      "keyQuote": "Currently there is no way to set binary checksum used for marking bad builds in JavaSDK.",
      "number": 89,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:56:05.912Z"
    },
    {
      "summary": "Users need the ability to specify a timeout for workflow start calls in Java SDK. Currently, there's no way to set a deterministic deadline (like Go's context deadline), causing issues when fallback workflows need guaranteed success/failure timing.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "client",
        "grpc-transport",
        "workflow-starter"
      ],
      "concepts": [
        "timeout",
        "deadline",
        "retry-policy",
        "gRPC-configuration",
        "client-options",
        "concurrent-fallback"
      ],
      "severity": "high",
      "userImpact": "Users cannot guarantee workflow start succeeds or fails within a specific time window, preventing reliable fallback mechanisms and causing potential concurrent execution issues.",
      "rootCause": "Java SDK lacks context/deadline support for gRPC calls, unlike Go SDK which uses context.Context with deadlines.",
      "proposedFix": "Add ability to override gRPC timeout for StartWorkflow calls in the Java SDK client options.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If we can't start workflow for an operation in X secs, we have a fallback option. Now, the fallback option AND workflow can't run concurrently. Hence, it's important that the start workflow deterministically succeeds or fails within X secs.",
      "number": 88,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:53:25.183Z"
    },
    {
      "summary": "Users cannot specify a business-level activity ID during activity invocation, which prevents asynchronous activity completion by ID. The feature request asks for a way to pass activityId through ActivityOptions similar to other SDKs.",
      "category": "feature",
      "subcategory": "activity-invocation",
      "apis": [
        "ActivityOptions"
      ],
      "components": [
        "activity-stub",
        "activity-invocation",
        "activity-executor"
      ],
      "concepts": [
        "activity-id",
        "asynchronous-completion",
        "business-level-id",
        "activity-options",
        "per-invocation-options"
      ],
      "severity": "medium",
      "userImpact": "Users cannot complete activities asynchronously by ID and must work around this by creating new stubs for each invocation.",
      "rootCause": null,
      "proposedFix": "Add support for specifying activityId via ActivityOptions during activity invocation, consistent with other SDKs.",
      "workaround": "Create a new stub every time (mentioned in comments as current workaround).",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1009
      ],
      "keyQuote": "It is not possible to specify a business level ID for an activity during its invocation. This is a problem for completing activities asynchronously by ID.",
      "number": 86,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:53:24.043Z"
    },
    {
      "summary": "TestWorkflowService generates task tokens that only include workflow and activity IDs, making them non-unique across retries. The real service generates unique tokens per retry, causing the test service to incorrectly allow a previous activity retry to complete a subsequent retry.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "TestWorkflowService",
        "task-token-generation",
        "retry-handling"
      ],
      "concepts": [
        "retry",
        "task-token",
        "test-service",
        "idempotency",
        "token-uniqueness"
      ],
      "severity": "medium",
      "userImpact": "Test assertions may pass incorrectly when testing retry logic, failing to catch real bugs that would occur against the actual Temporal service.",
      "rootCause": "Task tokens generated by TestWorkflowService include only workflow and activity IDs without incorporating retry count, unlike the real service which generates unique tokens per retry attempt.",
      "proposedFix": "Include retry count in the token generation logic to make tokens unique across retries, matching real service behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Token generation was updated to include retry count, making test service behavior consistent with real service.",
      "related": [],
      "keyQuote": "We don't include retry count into the token, which is why previous activity retry can complete next one in the test service.",
      "number": 84,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:53:24.106Z"
    },
    {
      "summary": "Workflow.getVersion() markers are not being respected during replay when new version markers are added before existing ones in a V2 implementation. Previously recorded version markers return -1 instead of reusing their recorded values, despite the DecisionsHelper logic that should preserve them.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "Workflow.getVersion"
      ],
      "components": [
        "workflow-executor",
        "decision-helper",
        "version-marker",
        "replay-engine"
      ],
      "concepts": [
        "versioning",
        "replay",
        "decision-history",
        "marker-preservation",
        "workflow-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely add new version markers before existing ones in workflow updates without breaking replay of existing workflow instances, which return -1 for all version checks.",
      "rootCause": "Version markers in history are not being properly matched and reused during replay when the order of Workflow.getVersion() calls changes between implementations.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by fixing the logic in DecisionsHelper to properly respect and reuse version markers from history during replay regardless of order changes.",
      "related": [],
      "keyQuote": "Why did changeFoo not reuse the previous version 1 from the marker? It is falling into here, in DecisionsHelper",
      "number": 80,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:35:52.090Z"
    },
    {
      "summary": "Activity failures are not logged, making it difficult to debug during unit tests with automatic activity retries. Logging was added to improve visibility into activity execution failures.",
      "category": "bug",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "activity-executor",
        "logging",
        "test-framework"
      ],
      "concepts": [
        "logging",
        "activity-failures",
        "debugging",
        "unit-tests",
        "retries",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users cannot see activity failure details during unit tests with automatic retries, making debugging difficult.",
      "rootCause": "Activity failures were not being logged to output",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by PR #172 which added logging for activity failures",
      "related": [
        172
      ],
      "keyQuote": "Currently activity failures are not logged which is very inconvenient during unit tests that do automatic activity retries.",
      "number": 79,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:35:49.742Z"
    },
    {
      "summary": "User requests a shaded release JAR with all dependencies bundled under an internal namespace to prevent version conflicts with other libraries (particularly netty and guava) when Temporal activities make external calls.",
      "category": "feature",
      "subcategory": "packaging",
      "apis": [],
      "components": [
        "packaging",
        "dependency-management",
        "gradle"
      ],
      "concepts": [
        "dependency-shading",
        "uber-jar",
        "namespace-conflict",
        "version-conflict",
        "library-compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users integrating Temporal with applications using different versions of common dependencies like netty may experience classpath conflicts without a shaded JAR option.",
      "rootCause": "Temporal SDK exports dependencies like netty and guava at their original namespaces, causing conflicts when activities call external libraries with different dependency versions.",
      "proposedFix": "Add a shaded JAR to release artifacts with all dependencies relocated to an internal namespace.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved via issue #1656, which implemented the shaded JAR release artifact.",
      "related": [
        1656
      ],
      "keyQuote": "if I make a REST call in an activity using a library dependent on a different version of netty, the classes could conflict, right?",
      "number": 75,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:35:51.046Z"
    },
    {
      "summary": "Parent workflows may exit before child workflows start when using abandon parent policy, leaving children permanently unstarted. The proposal is to delay workflow completion until child workflows with abandon parent policy have successfully started.",
      "category": "feature",
      "subcategory": "child-workflows",
      "apis": [
        "ChildWorkflowStub.getExecution()"
      ],
      "components": [
        "workflow-execution",
        "child-workflow-manager",
        "parent-child-coordination"
      ],
      "concepts": [
        "parent-child-workflows",
        "abandon-policy",
        "workflow-completion",
        "lifecycle-management"
      ],
      "severity": "medium",
      "userImpact": "Users can inadvertently create unstarted child workflows if parent workflows exit before child start requests complete, requiring obscure workarounds.",
      "rootCause": "Parent workflow completion is not synchronized with child workflow start lifecycle when using abandon parent close policy.",
      "proposedFix": "Automatically delay workflow completion until outstanding child start requests with abandon parent policy have successfully started. Also apply to cancellation requests for children with abandon parent policy.",
      "workaround": "Call Promise returned from ChildWorkflowStub.getExecution() to wait for child startup.",
      "resolution": "wontfix",
      "resolutionDetails": "Resolved as server-side implementation in temporal repository issue #685 instead of SDK-side due to complexity handling events after completion.",
      "related": [
        685
      ],
      "keyQuote": "The delay of completion is easy by the SDK. But dealing with events that happened after completion was requested and children have started is really hard without service support.",
      "number": 74,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:19:00.533Z"
    },
    {
      "summary": "MaxConcurrentActivityExecutionSize limit is not respected when using asynchronous activity completion. A new API for same-process async completion is needed to properly enforce the concurrency limits.",
      "category": "bug",
      "subcategory": "activity-execution",
      "apis": [
        "setMaxConcurrentActivityExecutionSize",
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "activity-executor",
        "async-completion"
      ],
      "concepts": [
        "concurrency-limit",
        "activity-completion",
        "async-processing",
        "backpressure",
        "throughput-control"
      ],
      "severity": "high",
      "userImpact": "Users relying on async activity completion with Kotlin coroutines cannot limit concurrent activity execution, risking resource exhaustion.",
      "rootCause": "The async activity completion API was designed for cross-process completion and does not properly account for concurrency limits when used within the same process.",
      "proposedFix": "Implement a special API for async activity completion from the same process that correctly performs concurrency counting.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved via PR #291, which implements proper concurrency counting for same-process async activity completion.",
      "related": [
        14
      ],
      "keyQuote": "setMaxConcurrentActivityExecutionSize(2) don't seem to work if we do asynchronous activity completion",
      "number": 70,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:19:00.239Z"
    },
    {
      "summary": "System.nanoTime() is incorrectly used for obtaining wall clock time measurements. Since nanoTime() has no correlation with actual wall clock time, the implementation should instead use currentTimeMillis() multiplied by 1,000,000 to get nanoseconds.",
      "category": "bug",
      "subcategory": "timing",
      "apis": [],
      "components": [
        "ActivityWorker",
        "timing"
      ],
      "concepts": [
        "wall-clock-time",
        "nanotime",
        "time-measurement",
        "precision",
        "timing-accuracy"
      ],
      "severity": "medium",
      "userImpact": "Activity worker timing measurements may be inaccurate or inconsistent due to misuse of System.nanoTime(), potentially affecting activity timeouts and scheduling.",
      "rootCause": "System.nanoTime() was being used for wall clock time measurements, but nanoTime() is designed for measuring elapsed time intervals and has no correlation with actual calendar time.",
      "proposedFix": "Replace nanoTime() calls with currentTimeMillis() multiplied by 1,000,000 to obtain proper nanosecond-precision wall clock time.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed through PR #68",
      "related": [
        68
      ],
      "keyQuote": "nanoTime() has no correlation with the actual wall clock time. If we want nanoseconds, call currentTimeMillis and multiply by 1M.",
      "number": 66,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T17:18:59.558Z"
    },
    {
      "summary": "Worker and client need automatic reconnection when service IP address changes, particularly in Kubernetes deployment scenarios. Currently requires a full restart to handle IP changes behind DNS records.",
      "category": "feature",
      "subcategory": "connection-resilience",
      "apis": [],
      "components": [
        "worker",
        "client",
        "connection-manager",
        "dns-resolver"
      ],
      "concepts": [
        "reconnection",
        "service-discovery",
        "ip-address-change",
        "kubernetes",
        "deployment",
        "dns",
        "fault-tolerance"
      ],
      "severity": "high",
      "userImpact": "Users running in Kubernetes environments must manually restart workers and clients when service IP addresses change, causing downtime and operational overhead.",
      "rootCause": "Client and worker do not automatically reconnect or refresh DNS resolution when the underlying service IP address changes",
      "proposedFix": null,
      "workaround": "Restart worker and client manually when service IP changes",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "During various failure/deployment scenarios especially in K8s the service IP might change. Currently a worker and client restart is needed to deal with it.",
      "number": 57,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:47:02.172Z"
    },
    {
      "summary": "Request to support @SignalMethod and @QueryMethod in independent interfaces separate from the main workflow interface, enabling registration and invocation of signal/query handlers as standalone components that can be reused across multiple workflows.",
      "category": "feature",
      "subcategory": "signal-query-handlers",
      "apis": [
        "registerHandler"
      ],
      "components": [
        "workflow-interface",
        "signal-handler",
        "query-handler",
        "client-stub"
      ],
      "concepts": [
        "handler-registration",
        "interface-composition",
        "reusable-components",
        "independent-handlers",
        "workflow-modularity",
        "code-sharing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently create reusable signal/query handler libraries that can be shared across multiple workflows, limiting code modularity and reusability.",
      "rootCause": null,
      "proposedFix": "Support registering signal and query handlers via independent interfaces annotated with @SignalMethod and @QueryMethod, allowing client stub creation from these interfaces (e.g., client.newStub(MySignal.class, workflowId))",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support independent signal and query method interfaces",
      "related": [],
      "keyQuote": "This would allow implementing independent reusable libraries which could be shared by multiple workflows.",
      "number": 55,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:47:03.511Z"
    },
    {
      "summary": "Issue requesting explicit @ActivityInterface and @WorkflowInterface annotations to disambiguate which interfaces define activity types, solving problems with Spring proxies and multiple activity implementations sharing the same interface.",
      "category": "feature",
      "subcategory": "activity-interface-discovery",
      "apis": [
        "ActivityInterface",
        "WorkflowInterface",
        "ActivityMethod",
        "WorkflowMethod"
      ],
      "components": [
        "activity-worker",
        "activity-stub",
        "interface-discovery",
        "registration"
      ],
      "concepts": [
        "annotation-based-configuration",
        "interface-inheritance",
        "activity-type-naming",
        "multiple-implementations",
        "proxy-compatibility",
        "activity-discovery"
      ],
      "severity": "high",
      "userImpact": "Users cannot use Spring proxies or other frameworks that add mixins to activity implementations, and cannot have multiple implementations of the same activity interface.",
      "rootCause": "Currently all interfaces implemented by a class are treated as activity interfaces when registered with an activity worker, causing issues when mixin interfaces are shared across implementations.",
      "proposedFix": "Introduce @ActivityInterface annotation to explicitly mark interfaces that define activity types, optionally with @ActivityImplementation qualifier at class level to support multiple implementations of the same interface.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The Java SDK implemented explicit annotations (@WorkflowInterface, @ActivityInterface) for marking workflow and activity definition interfaces, resolving the ambiguity and supporting multiple implementations.",
      "related": [],
      "keyQuote": "We should solve this with another common requirement to support multiple implementations of the same interface for activities.",
      "number": 43,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:47:03.910Z"
    },
    {
      "summary": "Workflow code that mistakenly uses Java synchronization primitives (e.g., synchronized methods) causes deadlocks since the dispatcher relies on cooperative multithreading. This feature proposes implementing a deadlock detector that fails the decision task with a clear error message when such blocking primitives are detected.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-dispatcher",
        "workflow-executor",
        "synchronization-detection"
      ],
      "concepts": [
        "deadlock-detection",
        "cooperative-multithreading",
        "synchronization-primitives",
        "workflow-safety",
        "thread-blocking",
        "error-detection"
      ],
      "severity": "high",
      "userImpact": "Developers who accidentally use Java locking primitives in workflows experience mysterious deadlocks that are difficult to diagnose; clearer early detection would save significant debugging time.",
      "rootCause": "Workflow dispatcher uses cooperative multithreading, but Java synchronized primitives cause hard blocking that prevents the scheduler from making progress when multiple threads contend for the same lock.",
      "proposedFix": "Implement a deadlock detection feature that monitors for Java synchronization primitives usage within workflow code and fails the decision task with a descriptive error message when detected.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to detect and prevent Java synchronization primitives in workflow code.",
      "related": [],
      "keyQuote": "Currently if a workflow code by mistake uses Java synchronization primitives it deadlocks as dispatcher relies on cooperative multithreading.",
      "number": 28,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:35:51.139Z"
    },
    {
      "summary": "ActivityOptions lacks support for WaitForCancellation, leaving no way to wait for activity cancellation when it occurs. Activities are currently abandoned on cancellation without a way to handle cleanup or wait for completion.",
      "category": "feature",
      "subcategory": "activity-cancellation",
      "apis": [
        "ActivityOptions"
      ],
      "components": [
        "activity-executor",
        "cancellation-handler",
        "activity-options"
      ],
      "concepts": [
        "cancellation",
        "activity-lifecycle",
        "resource-cleanup",
        "async-operations",
        "graceful-shutdown"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly handle activity cancellation or wait for activities to complete their cancellation logic, making it difficult to implement cleanup operations.",
      "rootCause": "ActivityOptions API does not provide a WaitForCancellation option to control cancellation behavior.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed through PR #61 which added WaitForCancellation support to ActivityOptions.",
      "related": [
        61
      ],
      "keyQuote": "Currently on cancellation activity is abandoned. There is no way to wait for its cancellation.",
      "number": 27,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:35:50.205Z"
    },
    {
      "summary": "getVersion() returns different values for the same changeID when unversioned workflows resume with versioned code. Java client records a MarkerRecorded event while the Go client does not.",
      "category": "bug",
      "subcategory": "versioning",
      "apis": [
        "getVersion"
      ],
      "components": [
        "versioning-system",
        "workflow-replay",
        "marker-recording"
      ],
      "concepts": [
        "version-consistency",
        "workflow-resume",
        "changeID",
        "marker-tracking",
        "code-versioning"
      ],
      "severity": "high",
      "userImpact": "Workflow resumption with versioned code produces inconsistent behavior and markers across Java and Go clients, potentially breaking version management logic.",
      "rootCause": "getVersion() implementation does not consistently return the same value for identical changeID when workflows transition from unversioned to versioned.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved through implementation fix to ensure version consistency across client transitions.",
      "related": [],
      "keyQuote": "When an unversioned workflow \"resumes\" with versioned code, that doesn't cause a MarkerRecorded in Golang. But it does cause a MarkerRecorded in the Java client.",
      "number": 24,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:35:50.148Z"
    },
    {
      "summary": "Replace Activity.getTask() which exposes low-level protobuf with Activity.getInfo() for a simpler API. Also add Activity.getTimeUntilTimeout() method to help activities know when they will timeout.",
      "category": "feature",
      "subcategory": "activity-api",
      "apis": [
        "Activity.getInfo",
        "Activity.getTimeUntilTimeout"
      ],
      "components": [
        "activity-executor",
        "activity-context",
        "api-design"
      ],
      "concepts": [
        "timeout",
        "activity-lifecycle",
        "api-abstraction",
        "protobuf",
        "user-api"
      ],
      "severity": "medium",
      "userImpact": "Users will have a cleaner, higher-level API for accessing activity task information instead of dealing with low-level protobuf objects.",
      "rootCause": "Activity.getTask() exposes protobuf-generated ActivityTask which is too low-level for user code.",
      "proposedFix": "Replace Activity.getTask() with Activity.getInfo() and add Activity.getTimeUntilTimeout() method.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "API was refactored to replace low-level getTask() with higher-level getInfo() and getTimeUntilTimeout() methods.",
      "related": [],
      "keyQuote": "ActivityTask is protobuf which is too low level to expose to the activity code.",
      "number": 23,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:31:26.986Z"
    },
    {
      "summary": "Request to add support for scheduling activities and child workflows across different domains/namespaces. This feature is currently not supported by the Temporal server.",
      "category": "feature",
      "subcategory": "cross-domain-scheduling",
      "apis": [
        "ExecuteActivity",
        "StartChildWorkflow"
      ],
      "components": [
        "activity-executor",
        "workflow-executor",
        "domain-routing"
      ],
      "concepts": [
        "cross-domain",
        "cross-namespace",
        "activity-scheduling",
        "workflow-scheduling",
        "multi-tenancy"
      ],
      "severity": "medium",
      "userImpact": "Users cannot schedule activities or child workflows in different namespaces, limiting flexibility in multi-tenant and complex workflow architectures.",
      "rootCause": "Server-side restriction that explicitly prevents cross-namespace scheduling",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Feature explicitly not supported by the Temporal server architecture",
      "related": [],
      "keyQuote": "Cross-namespace activity or workflow scheduling is currently explicitly not supported by the server.",
      "number": 21,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:31:27.950Z"
    },
    {
      "summary": "Worker registration methods (registerActivitiesImpl and registerWorkflowImplementationTypes) use confusing naming conventions. These methods fully override the list rather than accumulating, which contradicts their names - they should be renamed to 'set' methods to accurately reflect their behavior.",
      "category": "bug",
      "subcategory": "worker-registration",
      "apis": [
        "Worker.registerActivitiesImpl",
        "Worker.registerWorkflowImplementationTypes"
      ],
      "components": [
        "worker",
        "registration",
        "api-design"
      ],
      "concepts": [
        "method-naming",
        "api-clarity",
        "registration-override",
        "accumulation"
      ],
      "severity": "medium",
      "userImpact": "Developers are confused by method names that suggest accumulation but actually override existing registrations, leading to unexpected behavior.",
      "rootCause": "Method naming conventions inconsistent with actual behavior - methods use 'register' prefix but perform 'set' (override) operations.",
      "proposedFix": "Rename registerActivitiesImpl and registerWorkflowImplementationTypes to setActivitiesImpl and setWorkflowImplementationTypes to match their actual behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Methods were renamed to use 'set' prefix to accurately reflect override behavior; separate accumulating 'register' methods were added.",
      "related": [],
      "keyQuote": "The current `Worker.registerActivitiesImpl` and `registerWorkflowImplementationTypes` are confusing as it takes a list and fully overrides it which is expected from `set<foo>` methods.",
      "number": 20,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:31:28.057Z"
    },
    {
      "summary": "The Java SDK's Worker and WorkflowClient classes do not expose RPC timeout configuration, defaulting to 1 second which is insufficient for some use cases. Customer requests the ability to set RPC timeout from client code.",
      "category": "feature",
      "subcategory": "rpc-configuration",
      "apis": [
        "Worker",
        "WorkflowClient"
      ],
      "components": [
        "worker",
        "workflow-client",
        "rpc-layer"
      ],
      "concepts": [
        "timeout",
        "rpc",
        "configuration",
        "client-settings",
        "connection-management"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure RPC timeout for their use cases, forcing them to work around the 1-second default which may be too short for their operations.",
      "rootCause": null,
      "proposedFix": "Expose RPC timeout as a configurable parameter on Worker and WorkflowClient classes.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "RPC timeout configuration was exposed to client code in Worker and WorkflowClient classes.",
      "related": [],
      "keyQuote": "Worker and WorkflowClient classes from the Java client do not expose a way to set the RPC timeout. It defaults to 1 second, which was not enough in some of my testing scenarios.",
      "number": 19,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:14:12.102Z"
    },
    {
      "summary": "Workflow.getLogger() throws an exception when called outside of workflow context. Proposal is to make getLogger() gracefully fall back to a standard logger instead of ReplayAwareLogger when invoked outside workflow context.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [
        "Workflow.getLogger"
      ],
      "components": [
        "logger",
        "workflow-context",
        "replay-aware-logger"
      ],
      "concepts": [
        "context-awareness",
        "logging",
        "graceful-fallback",
        "utility-code-reuse"
      ],
      "severity": "medium",
      "userImpact": "Utility code that needs to log cannot be safely invoked from both workflow and non-workflow contexts due to exceptions.",
      "rootCause": "Workflow.getLogger() is hardcoded to only work within workflow context and throws an exception when called outside of it.",
      "proposedFix": "Modify getLogger() to return a standard logger when called outside of workflow context instead of throwing an exception.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed by pull request #143, allowing getLogger() to work in both activity and workflow contexts.",
      "related": [
        143
      ],
      "keyQuote": "Some utility code can be invoked from workflow context as well as outside of it. Workflow.getLogger fails with an exception when invoked outside of a workflow.",
      "number": 18,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:14:11.220Z"
    },
    {
      "summary": "When an activity is cancelled, the CancellationException's stack trace points to the internal handleActivityTaskCanceled method instead of the actual caller of the activity, making debugging difficult.",
      "category": "bug",
      "subcategory": "activity-cancellation",
      "apis": [],
      "components": [
        "activity-executor",
        "replay",
        "decision-context"
      ],
      "concepts": [
        "stack-trace",
        "cancellation",
        "exception-handling",
        "debugging",
        "activity-execution",
        "error-visibility"
      ],
      "severity": "medium",
      "userImpact": "Users see confusing stack traces when activities are cancelled, making it harder to debug where the activity was actually called.",
      "rootCause": "The CancellationException is being thrown from within handleActivityTaskCanceled, so the stack trace starts there rather than at the actual activity invocation point.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Stack trace was corrected to show the caller of the activity rather than the internal cancellation handler.",
      "related": [],
      "keyQuote": "When an activity is cancelled the thrown CancellationException contains stack trace of the handleActivityTaskCanceled, not the caller of the activity",
      "number": 15,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T16:14:11.100Z"
    },
    {
      "summary": "Request to simplify async activity implementation by supporting CompletableFuture-returning methods without tying up threads. Proposes ActivityAsync adapter class and dynamic proxy pattern for converting async implementations to standard activity interfaces.",
      "category": "feature",
      "subcategory": "async-activities",
      "apis": [],
      "components": [
        "activity-implementation",
        "dynamic-proxy",
        "worker"
      ],
      "concepts": [
        "asynchronous-execution",
        "completable-future",
        "thread-efficiency",
        "adapter-pattern",
        "activity-interface"
      ],
      "severity": "medium",
      "userImpact": "Allows users to implement activities with CompletableFuture without blocking threads, improving resource efficiency for I/O-bound operations.",
      "rootCause": null,
      "proposedFix": "Add ActivityAsync adapter class with overloaded methods similar to workflow Async class, and implement dynamic proxy pattern to convert async implementations to standard activity interfaces using @ActivitiesImplementation annotation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by providing a completion client that simplifies async activity implementation, as referenced in PR #291.",
      "related": [
        291
      ],
      "keyQuote": "add adapter methods that can be called from activity (similar to Async class from workflow package)",
      "number": 14,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:56:40.699Z"
    },
    {
      "summary": "Remove InterruptedException from WorkflowQueue to ensure workflow code uses CancellationScope for cancellation instead of throwing InterruptedException, which should never occur in workflow code.",
      "category": "feature",
      "subcategory": "cancellation-handling",
      "apis": [
        "CancellationScope"
      ],
      "components": [
        "workflow-queue",
        "cancellation-handler",
        "workflow-execution"
      ],
      "concepts": [
        "cancellation",
        "exception-handling",
        "thread-interruption",
        "workflow-isolation",
        "error-semantics"
      ],
      "severity": "medium",
      "userImpact": "Prevents users from accidentally using InterruptedException patterns in workflow code, ensuring consistent cancellation semantics through CancellationScope.",
      "rootCause": "WorkflowQueue currently allows InterruptedException to propagate, which conflicts with Temporal's cancellation model.",
      "proposedFix": "Remove InterruptedException from WorkflowQueue implementation and enforce CancellationScope usage for all cancellation scenarios.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "WorkflowQueue was updated to remove InterruptedException, enforcing CancellationScope as the sole cancellation mechanism.",
      "related": [],
      "keyQuote": "Workflow code should never throw InterruptedException as CancellationScope should be used for cancellation.",
      "number": 12,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:56:40.134Z"
    },
    {
      "summary": "Epic tracking Spring Boot integration for the Java SDK. Includes core integration tasks and related bugs/improvements to be addressed.",
      "category": "feature",
      "subcategory": "spring-boot-integration",
      "apis": [],
      "components": [
        "spring-boot",
        "java-sdk",
        "configuration"
      ],
      "concepts": [
        "framework-integration",
        "dependency-injection",
        "auto-configuration",
        "spring-ecosystem"
      ],
      "severity": "medium",
      "userImpact": "Enables Spring Boot developers to easily integrate Temporal into their Spring applications with minimal configuration.",
      "rootCause": null,
      "proposedFix": "Implement Spring Boot starter with auto-configuration and provide configuration options based on user feedback.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Initial Spring Boot integration released in Temporal JavaSDK 1.16 with additional functionality to evolve from user feedback.",
      "related": [
        1305,
        1363,
        1370,
        1463,
        1479,
        1550,
        1619,
        1597,
        1394,
        1488,
        1449,
        1634,
        1647
      ],
      "keyQuote": "Initial Spring Boot integration will be released in Temporal JavaSDK 1.16, additional functionality and configuration options will evolve from user feedback",
      "number": 8,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:56:40.633Z"
    },
    {
      "summary": "Migrate the Java Client from Thrift/TChannel to gRPC for improved performance and compatibility with the Temporal server.",
      "category": "feature",
      "subcategory": "client-transport",
      "apis": [],
      "components": [
        "client",
        "transport-layer",
        "grpc",
        "communication"
      ],
      "concepts": [
        "protocol-migration",
        "grpc",
        "thrift",
        "tchannel",
        "client-server-communication"
      ],
      "severity": "high",
      "userImpact": "Users will benefit from improved performance and reduced maintenance overhead with the industry-standard gRPC protocol.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Java client was successfully migrated from Thrift/TChannel to gRPC",
      "related": [],
      "keyQuote": null,
      "number": 7,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:40:15.200Z"
    },
    {
      "summary": "Add gRPC code generation for Java SDK by integrating temporal-proto repository and implementing Gradle build rules to generate Java bindings from protobuf definitions.",
      "category": "feature",
      "subcategory": "code-generation",
      "apis": [],
      "components": [
        "gradle-build",
        "protobuf-generation",
        "grpc-bindings"
      ],
      "concepts": [
        "code-generation",
        "protobuf",
        "grpc",
        "build-system",
        "java-bindings",
        "temporal-proto"
      ],
      "severity": "high",
      "userImpact": "Enables the Java SDK to support gRPC communication by generating necessary Java bindings from protocol buffer definitions.",
      "rootCause": null,
      "proposedFix": "Add dependency on temporal-proto repository and implement Gradle rules to build Java bindings",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "gRPC code generation was implemented with temporal-proto dependency and Gradle build rules",
      "related": [],
      "keyQuote": "Add dependency on https://github.com/temporalio/temporal-proto and Gradle rules to build Java bindings.",
      "number": 6,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:40:16.263Z"
    },
    {
      "summary": "Enable automated testing infrastructure for Java Client using Buildkite CI/CD platform. This involves setting up Buildkite to automatically test all pull requests.",
      "category": "feature",
      "subcategory": "ci-cd",
      "apis": [],
      "components": [
        "ci-pipeline",
        "testing-infrastructure",
        "build-system"
      ],
      "concepts": [
        "continuous-integration",
        "automated-testing",
        "pull-request-validation",
        "buildkite"
      ],
      "severity": "medium",
      "userImpact": "Ensures code quality and prevents regressions by automatically validating all contributions before merge.",
      "rootCause": null,
      "proposedFix": "Integrate Buildkite CI/CD platform for automated PR testing",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Buildkite integration was successfully implemented for Java SDK CI/CD pipeline",
      "related": [],
      "keyQuote": "Any PR should be tested automatically using buildkite",
      "number": 5,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:40:15.784Z"
    },
    {
      "summary": "Move Java SDK codebase from com.uber.cadence packages to io.temporal packages to align with Temporal branding and namespace.",
      "category": "feature",
      "subcategory": "package-migration",
      "apis": [],
      "components": [
        "package-structure",
        "imports",
        "build-system"
      ],
      "concepts": [
        "namespace-migration",
        "branding",
        "code-organization",
        "compatibility",
        "refactoring"
      ],
      "severity": "medium",
      "userImpact": "Users need to update imports and dependencies as the SDK transitions to the io.temporal namespace.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The package migration was completed, moving the codebase from com.uber.cadence to io.temporal packages.",
      "related": [],
      "keyQuote": null,
      "number": 4,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:39:36.225Z"
    },
    {
      "summary": "Refactor hardcoded MDC initialization and replay context logic from WorkflowThreadImpl into a generic interceptor pattern. Currently, WorkflowThread has hardcoded dependencies that should be moved to interceptors to improve extensibility and separation of concerns.",
      "category": "feature",
      "subcategory": "interceptor-framework",
      "apis": [],
      "components": [
        "WorkflowThreadImpl",
        "interceptor-framework",
        "MDC-initialization"
      ],
      "concepts": [
        "interceptor",
        "thread-initialization",
        "dependency-injection",
        "extensibility",
        "workflow-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot customize thread initialization behavior or MDC setup without modifying core framework code.",
      "rootCause": "Hardcoded MDC and replay context initialization in WorkflowThreadImpl prevents extensibility through interceptors.",
      "proposedFix": "Move MDC initialization logic into a new Interceptor that intercepts WorkflowThread creation, leveraging existing interceptor capabilities.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We should refactor out MDC initialization logic from `WorkflowThreadImpl` into a new Interceptor. Interceptors already allow intercepting creation of WorkflowThreads.",
      "number": 2,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:39:37.827Z"
    },
    {
      "summary": "Replace the default DataConverter implementation with Jackson for better maintenance and Java 11 support.",
      "category": "feature",
      "subcategory": "data-converter",
      "apis": [],
      "components": [
        "data-converter",
        "serialization"
      ],
      "concepts": [
        "serialization",
        "json",
        "data-conversion",
        "java-compatibility",
        "library-upgrade"
      ],
      "severity": "low",
      "userImpact": "Users benefit from improved library maintenance and better Java 11 compatibility for data serialization.",
      "rootCause": "The existing DataConverter implementation uses a less-maintained library without adequate Java 11 support.",
      "proposedFix": "Switch to Jackson library for default DataConverter implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented as part of PR #101.",
      "related": [
        101
      ],
      "keyQuote": "Jackson looks like better maintained with Java 11 support.",
      "number": 1,
      "repo": "temporalio-sdk-java",
      "generatedAt": "2026-01-11T15:39:36.070Z"
    }
  ]
}