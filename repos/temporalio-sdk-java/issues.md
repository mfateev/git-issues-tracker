# temporalio/sdk-java - Complete Issue Dump

**Generated:** 2026-01-09
**Total Issues:** 940
**Total Upvotes:** 281
**Total Comments:** 1151

## Table of Contents

- [Summary](#summary)
- [Top Labels](#top-labels)
- [Issue Index](#issue-index)
- [All Issues](#all-issues)

## Summary

| Metric | Value |
|--------|-------|
| Open Issues | 940 |
| Issues with Upvotes | 98 (10%) |
| Total Upvotes | 281 |
| Total Comments | 1151 |

## Top Labels

| Label | Count |
|-------|-------|
| enhancement | 399 |
| bug | 137 |
| test server | 45 |
| Mend: dependency security vulnerability | 36 |
| wontfix | 16 |
| epic | 15 |
| question | 15 |
| good first issue | 10 |
| invalid | 9 |
| documentation | 3 |
| next-gen | 1 |
| java | 1 |

## Issue Index

| # | üëç | üí¨ | Title |
|---|-----|-----|-------|
| [#1448](#1448) | 25 | 1 | Support for virtual threads (project Loom) |
| [#1845](#1845) | 15 | 8 | Support different coroutine models in workflows and activities |
| [#1693](#1693) | 16 | 5 | Support listWorkflowExecutions in test server |
| [#587](#587) | 10 | 15 | Set TemporalChangeVersion when workflow version is updated |
| [#8](#8) | 11 | 1 | Spring Boot Integration |
| [#2100](#2100) | 8 | 6 | Scheduled workflow retries do not work |
| [#1407](#1407) | 0 | 22 | ARM64 build for Test Server |
| [#1804](#1804) | 10 | 0 | Add the possibility to run Temporal CLI server from test  |
| [#1849](#1849) | 9 | 1 | Expose an async API to start a workflow which would allow mapping it to a Kotlin coroutine |
| [#2738](#2738) | 7 | 4 | Spring Boot 4 Support |
| [#2665](#2665) | 6 | 6 | Serialization with `kotlinx.serialization` |
| [#623](#623) | 7 | 1 | Upsert memo support |
| [#162](#162) | 0 | 14 | Exceptions being thrown on execution with Spring related to gRPC and PerfMark |
| [#295](#295) | 0 | 13 | Native image descriptor for GraalVM |
| [#1999](#1999) | 0 | 12 | GrpcRetryer fails without retrying request if "getServiceCapabilities" request fails |
| [#1837](#1837) | 3 | 6 | Use Spring Boot ApplicationReadyEvent to start workers |
| [#1256](#1256) | 6 | 0 | Last cached activity heartbeat should be discarded or drained with activity completion or worker shutdown |
| [#865](#865) | 5 | 2 | Add init method to workflow |
| [#704](#704) | 3 | 6 | Allow exception logging to be customizable for activity failures |
| [#537](#537) | 0 | 12 | Open tracing span context not propagated when activity or child workflow invoked asynchronously  |
| [#214](#214) | 6 | 0 | @SignalMethod threading configuration |
| [#1565](#1565) | 0 | 11 | Test server seems to not enable time skipping in this specific scenario |
| [#1007](#1007) | 2 | 7 | Scala module |
| [#745](#745) | 5 | 1 | üçÉ Dependency Injection |
| [#2724](#2724) | 5 | 0 | Allow Configuration Option to Enable Spring Application Startup Even When Temporal is Unavailable |
| [#1489](#1489) | 2 | 6 | Support Scala references to workflow methods |
| [#1133](#1133) | 2 | 6 | TestActivityEnvironment: calling "close" in test method fails tests |
| [#952](#952) | 0 | 10 | OpenTracing duplicates user created spans during replay |
| [#102](#102) | 4 | 2 | Health check between service + temporal servers |
| [#2466](#2466) | 0 | 9 | Spring boot starter behavior changes on app startup |
| [#1669](#1669) | 0 | 9 | Inheritance with @WorkflowMethod annotation |
| [#1536](#1536) | 3 | 3 | Activity stub throws IllegalArgumentException from toString method |
| [#2676](#2676) | 1 | 6 | temporal java sdk is using an older version of grpc-netty-shaded with vulnerabilities |
| [#2057](#2057) | 0 | 8 | Java SDK seems to not play well with Replay tests. Setting child workflow ID using Temporal library seems to be throwing a non-deterministic error |
| [#1876](#1876) | 0 | 8 | WorkflowLocal shares initial value between all Workflows |
| [#1832](#1832) | 4 | 0 | Support for using Temporal Annotations as Meta Annotation |
| [#1708](#1708) | 2 | 4 | Synchronous workflow update |
| [#1417](#1417) | 0 | 8 | Aling information provided by metrics temporal_activity_schedule_to_start_latency_seconds_bucket and temporal_workflow_task_schedule_to_start_latency_seconds_bucket |
| [#1387](#1387) | 0 | 8 | Jackson configuration is cumbersome |
| [#1241](#1241) | 1 | 6 | DynamicWorkflow not taking in account WorkflowImplementationOptions |
| [#827](#827) | 4 | 0 | Provide a recommended way to pass configuration into workflow  |
| [#371](#371) | 0 | 8 | When a workflow task fails and the workflow is still running, cancel request doesn't seem to work |
| [#2671](#2671) | 3 | 1 | Tracing - Native OpenTelemetry Interceptors |
| [#2508](#2508) | 0 | 7 | The version of grpc needs to be updated |
| [#2388](#2388) | 3 | 1 | Support testing Schedules |
| [#2305](#2305) | 0 | 7 | Test environment hangs if activity is not defined, and `scheduleToStartTimeout` is ignored |
| [#2075](#2075) | 3 | 1 | Add the ability to keep heartbeating while the worker is shutting down |
| [#2046](#2046) | 2 | 3 | Failed promise before calling allOf is not failing the wrapped promise. |
| [#1985](#1985) | 0 | 7 | Upgrade grpc dependencies |
| [#1793](#1793) | 0 | 7 | Support for generic workflow failure handler via interceptor |
| [#1698](#1698) | 0 | 7 | WorkflowImplementationOptions.FailWorkflowExceptionTypes ignored for service failures |
| [#1333](#1333) | 3 | 1 | High level API for schedules |
| [#1332](#1332) | 0 | 7 | Seeing SIGSEGV error while calling WorkflowServiceStubs.newServiceStub |
| [#1310](#1310) | 3 | 1 | Provide a way to set Heartbeat details in TestActivityEnvironment |
| [#1163](#1163) | 3 | 1 | Allow contributions of tags of root worker metricsscope per workflow execution |
| [#1044](#1044) | 0 | 7 | Remote Data Encoder |
| [#643](#643) | 0 | 7 | Unexpected WFT Completed events in java bench runs |
| [#396](#396) | 0 | 7 | Pluggable activity name provider |
| [#362](#362) | 1 | 5 | Connection management issues with Java SDK |
| [#2746](#2746) | 3 | 0 | Jackson 3 support |
| [#2474](#2474) | 0 | 6 | NonRootBeanPostProcessor eagerly depends on MeterRegistry which can have undesirable side effects |
| [#2413](#2413) | 1 | 4 | Adding a new parameter type List to a workflow input causes the data converter to fail |
| [#2132](#2132) | 0 | 6 | Add option to configure the deadline of `ChannelManager#getServerCapabilities` |
| [#2042](#2042) | 0 | 6 | Activity options merging logic is not correct |
| [#1962](#1962) | 0 | 6 | Tracing context does not propagate into .thenCompose |
| [#1823](#1823) | 1 | 4 | Have a config flag to disable temporal entirely with spring-boot-auto-configure-alpha |
| [#1430](#1430) | 1 | 4 | Workflow.getVersion() could cause NonDeterminsticError with multithreading + timer |
| [#1426](#1426) | 0 | 6 | Test server timeouts improperly set to 10 years when not user set |
| [#1347](#1347) | 0 | 6 | The first getClusterInfo fails after restarting a temporalite cluster in a multi cluster environment |
| [#1158](#1158) | 0 | 6 | Implement temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace in test-server |
| [#1106](#1106) | 0 | 6 | Workflow metadata resolution code doesn't respect generics specified down the hierarchy |
| [#976](#976) | 1 | 4 | üß∞ Additional APIs |
| [#863](#863) | 2 | 2 | Internal error in gRPC channel of WorkflowServiceStubs |
| [#806](#806) | 0 | 6 | Workflow.retry that takes a function to decide if retry is needed |
| [#796](#796) | 0 | 6 | Context propagation is not invoked when a workflow start and is configured using WorkflowClientOptions |
| [#707](#707) | 0 | 6 | DEADLINE_EXCEEDED: deadline exceeded after 69.999644732s |
| [#671](#671) | 3 | 0 | Add an easy way to provide JWT tokens to java-sdk for server calls |
| [#626](#626) | 0 | 6 | Excessive retries in test workflow environment |
| [#139](#139) | 2 | 2 | Need ability to modify ObjectMapper created by JacksonJsonPayloadConverter |
| [#2565](#2565) | 1 | 3 | Upgrade grpc version |
| [#2557](#2557) | 0 | 5 | Support fetching workflow id and workflow run id through ScheduleActionExecution |
| [#2498](#2498) | 0 | 5 | [Feature] Make Jackson serialization an optional and separate module |
| [#2203](#2203) | 0 | 5 | Async activity inputs potential memory leak |
| [#2177](#2177) | 0 | 5 | Include Package Version Information in manifest  |
| [#1378](#1378) | 0 | 5 | Pass real WorkflowId for full replay exposed to users in Worker#replayWorkflowExecution |
| [#1056](#1056) | 0 | 5 | ParameterizedTypeImpl class cast exception |
| [#849](#849) | 2 | 1 | Logging |
| [#744](#744) | 0 | 5 | Some jobs are forever in 'Running' State with WorkflowTaskFailed Error  |
| [#706](#706) | 2 | 1 | Unable to remove`Workflow#getVersion` calls once added to a workflow |
| [#621](#621) | 1 | 3 | Opentracing: "UnsupportedFormatException: Builtin.TEXT_MAP_INJECT" with Jaeger tracer |
| [#481](#481) | 0 | 5 | Allow configuration of workers to back off completely if the server is not available |
| [#413](#413) | 1 | 3 | Workflow#newActivityStub(activityInterface) method produces broken activity stubs |
| [#79](#79) | 2 | 1 | Log activity failures |
| [#2642](#2642) | 2 | 0 | TestWorkflowEnvironment sleep incorrect behaviour |
| [#2564](#2564) | 0 | 4 | Bug: workers-auto-discovery in Spring Boot scans packages not in specified list |
| [#2443](#2443) | 2 | 0 | 1.28.1 release - springboot config - apiKeys |
| [#2414](#2414) | 0 | 4 | Expose Workflow cancel cause/reason |
| [#2412](#2412) | 1 | 2 | Marker Commands being sent with empty names in the wild |
| [#2394](#2394) | 2 | 0 | Pure opentelemetry based tracing support instead of using tracershim |
| [#2391](#2391) | 1 | 2 | [Bug] Cancelling an activity results in `FailedPrecondition: ACTIVITY_UNKNOWN` error on time skipping server |
| [#2276](#2276) | 1 | 2 | Null pointer exception on passing empty search attribute in workflow options |
| [#2189](#2189) | 0 | 4 | Schedules without a catch up window use the min catch up window instead of the default catch up window |
| [#2180](#2180) | 0 | 4 | Workflow.newExternalWorkflowStub |
| [#2128](#2128) | 0 | 4 | NoClassDefFoundError: com/google/protobuf/GeneratedMessageV3 | Spring 3.3.1 |
| [#2121](#2121) | 0 | 4 | @Profile annotation is not working on @WorkflowImpl with `workers-auto-discovery` |
| [#2103](#2103) | 1 | 2 | Java SDK is not reporting workflow_failures from the code path via the FailWorkflowExceptionTypes |
| [#2097](#2097) | 1 | 2 | TestActivityEnvironment does not work with Asynchronous Activity Completion |
| [#2092](#2092) | 1 | 2 | activity_succeed_endtoend_latency not reported when completing the activity with ActivityCompletionClient |
| [#2047](#2047) | 0 | 4 | Add toString method to WorkflowServiceStubsOptions |
| [#1994](#1994) | 0 | 4 | RunID is needed oftimes when relying on HasWorkflowSerializationContext in a PayloadCodec or Converter |
| [#1980](#1980) | 0 | 4 | MDC Context not propogating |
| [#1969](#1969) | 0 | 4 | Provide WorkflowStatus in WorkflowNotFoundException when signing a workflow |
| [#1944](#1944) | 0 | 4 | If an update request continues-as-new the SDK should complete the request with a specific response |
| [#1940](#1940) | 0 | 4 | Support Java Modules |
| [#1931](#1931) | 0 | 4 | sdk-java 1.22.3 breaks queries after testEnv.sleep |
| [#1783](#1783) | 0 | 4 | Test server for linux_arm64 target |
| [#1666](#1666) | 0 | 4 | Schedule API example with Spring boot |
| [#1626](#1626) | 1 | 2 | Allow WorkflowImplementationOptions to be passed in TestWorkflowExtension->setWorkflowTypes |
| [#1558](#1558) | 0 | 4 | Issue with ReplayAwareLogger and CanceledFailure |
| [#1550](#1550) | 0 | 4 | Dynamic & interpolated taskQueues  |
| [#1518](#1518) | 0 | 4 | Multiple tests launched from test class with mocked activity method fail, but each when launch separately passes |
| [#1424](#1424) | 2 | 0 | Test server should not require task queue on continue as new |
| [#1200](#1200) | 0 | 4 | Search attributes are not carried forward on ContinueAsNew |
| [#1120](#1120) | 2 | 0 | Cannot return value of WorkflowLocal var from query method |
| [#1025](#1025) | 1 | 2 | In case of existing workflow both sync and async executions should have an option to error out or return an existing execution |
| [#995](#995) | 0 | 4 | Inheritance of workflow interfaces is not supported |
| [#940](#940) | 0 | 4 | Header support for signals and queries |
| [#928](#928) | 1 | 2 | TestActivityExtension lifecycle problems with more than a single test case |
| [#915](#915) | 0 | 4 | Improve signalWithStart usability |
| [#811](#811) | 2 | 0 | Add test framework for partial json history replay and continuing of execution |
| [#761](#761) | 0 | 4 | Add an ability to create WorkflowStub from workflowInterface |
| [#701](#701) | 0 | 4 | Async activity completion with primitive return value converts null to zero |
| [#631](#631) | 2 | 0 | DeterministicRunner is noisy about not accessed cancelled scopes and timers |
| [#618](#618) | 0 | 4 | a load balancer with an idle timeout causes java sdk to log UNAVAILABLE errors |
| [#588](#588) | 0 | 4 | Make `TEMPORAL_DEBUG` definable via code |
| [#535](#535) | 0 | 4 | Add pollExecutor thread pool metrics |
| [#525](#525) | 1 | 2 | Allow context propagators & interceptors to populate ActivityExecutionContext |
| [#468](#468) | 0 | 4 | DataConverter is (surprisingly?) used for custom search attributes |
| [#467](#467) | 1 | 2 | Register multiple activity names for an activity |
| [#460](#460) | 1 | 2 | Please add ActivityCompletionClient support in TestActivityEnvironment |
| [#357](#357) | 0 | 4 | [Bug] Query page broken after upgrading to 1.6.3 server |
| [#332](#332) | 0 | 4 | Test with mock activity doesn't work with Mockito version 2 |
| [#317](#317) | 0 | 4 | Published artifacts do not include sources for the generated code |
| [#315](#315) | 0 | 4 | inconsistent tag names between server and sdk |
| [#308](#308) | 1 | 2 | ActivityCompletionClient's completeExceptionally doesn't work with ApplicationFailure  |
| [#256](#256) | 0 | 4 | Unexpected Heartbeat errors when activities are queued up |
| [#205](#205) | 1 | 2 | WARNING: An illegal reflective access operation has occurred |
| [#175](#175) | 0 | 4 | The constraint about activity's scheduleToClose or scheduleToStart & startToClose should be defined is not enforced |
| [#86](#86) | 0 | 4 | Support passing activityId to an activity invocation |
| [#2679](#2679) | 1 | 1 | WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE does not throw WorkflowExecutionAlreadyStarted |
| [#2652](#2652) | 0 | 3 | UNKNOWN GRPC error on describe in TestWorkflowEnvironment |
| [#2647](#2647) | 0 | 3 | Activity Type not registered error when using RetryOptions with maxAttempts(1) |
| [#2504](#2504) | 0 | 3 | Temporal versions 1.28.3 1.29.0 compatibility with Springboot spring-boot-starter-parent 3.3.11 |
| [#2350](#2350) | 0 | 3 | WorkflowLock.tryLock should not create a timer if the lock is available |
| [#2312](#2312) | 1 | 1 | `Workflow.await(duration, condition)` does not automatically cancel the timer if the condition is resolved |
| [#2194](#2194) | 0 | 3 | Thread `LocalActivitySlotSupplierQueue` prevent JVM from termination |
| [#2076](#2076) | 0 | 3 | Querying a running workflow makes it spam previously logged messages |
| [#2056](#2056) | 1 | 1 | Allow users to implement update asynchronously in Java natively |
| [#2049](#2049) | 0 | 3 | Async Activity support for Java async API |
| [#1988](#1988) | 1 | 1 | Have a built-in way to override activityOptions in tests |
| [#1933](#1933) | 0 | 3 | `No PayloadConverter is registered for an encoding: binary/null` |
| [#1921](#1921) | 0 | 3 | Workflow executions frozen after Temporal exception |
| [#1866](#1866) | 1 | 1 | Allow to get the retry policy set for execution from client via WorkflowInfo |
| [#1799](#1799) | 1 | 1 | [Springboot] add support for multiple namespaces |
| [#1736](#1736) | 0 | 3 | Workflow Task Exception eats up the exception sent by code |
| [#1684](#1684) | 0 | 3 | Closing metric subscopes surprisingly closes the parent scope as well |
| [#1647](#1647) | 1 | 1 | Allow WorkflowImplementationOptions to be set via config for Spring Boot  |
| [#1540](#1540) | 0 | 3 | Test service time skipping broken in a child workflow |
| [#1516](#1516) | 0 | 3 | spring-boot-dependencies-2.7.5.pom: 7 vulnerabilities (highest severity is: 9.8) - autoclosed |
| [#1504](#1504) | 0 | 3 | Don't request eager activities when worker started with no activities configured |
| [#1493](#1493) | 0 | 3 | spring-boot-starter-2.7.5.jar: 7 vulnerabilities (highest severity is: 8.3) - autoclosed |
| [#1488](#1488) | 1 | 1 | Spring Boot - add config options for WorkerFactory and Workers |
| [#1411](#1411) | 0 | 3 | temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT: 5 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1400](#1400) | 0 | 3 | spring-boot-starter-2.7.3.jar: 5 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1395](#1395) | 0 | 3 | Workflow failed by Worker after DEADLINE_EXCEEDED is thrown by WorkflowHistoryIterator |
| [#1369](#1369) | 0 | 3 | Calling synchronous workflow stub should propagate workflow exceptions |
| [#1291](#1291) | 0 | 3 | Workflow execution with Workflow.await(condition) times out in unit tests with enabled time skipping |
| [#1281](#1281) | 0 | 3 | Local Activity asynchronously started at the end of the workflow implementation leads to failure |
| [#1260](#1260) | 0 | 3 | Multiple workers reporting workflow gauges |
| [#1246](#1246) | 1 | 1 | Query is not picked up by the worker executing local activity for more than a minute |
| [#1093](#1093) | 0 | 3 | Add ResetWorkflowExecution support in Test Server |
| [#1010](#1010) | 0 | 3 | Workflow should have an access to an activity id of the activity it scheduled |
| [#835](#835) | 0 | 3 | Workflow search queries APIs |
| [#630](#630) | 0 | 3 | Flaky testShouldReturnQueryResultAfterWorkflowTimeout |
| [#578](#578) | 0 | 3 | TestEnv: WorkflowStub.getResult seems to skip timer  |
| [#502](#502) | 0 | 3 | OpenTracing: support pluggable strategy for span naming/tagging |
| [#482](#482) | 0 | 3 | Unable to replay a workflow after adding workflow versioning |
| [#459](#459) | 0 | 3 | testEnv.sleep doesn't work as expected and hangs |
| [#402](#402) | 1 | 1 | Prohibit use of WorkflowClient and Activity interfaces in workflow code. |
| [#391](#391) | 0 | 3 | Query failure on terminated workflow |
| [#228](#228) | 1 | 1 | Expose activity start and completion information to the workflow code. |
| [#203](#203) | 0 | 3 | ensureDefaultFieldsForActivityRetryPolicy in testService don't rewrite nonRetryableErrorTypes |
| [#173](#173) | 0 | 3 | ArithmeticException in ReplayWorkflowExecutor after some amount of requests |
| [#43](#43) | 0 | 3 | Require explicit annotation for Workflow and Activity interfaces. |
| [#2741](#2741) | 1 | 0 | Support non-workflow activities |
| [#2730](#2730) | 0 | 2 | INTERNAL: Panic! This is a bug! in wrapStartException |
| [#2680](#2680) | 0 | 2 | Spring Boot application startup failure - DEADLINE_EXCEEDED |
| [#2637](#2637) | 0 | 2 | strange behaviour when registrating activities with worker in java sdk |
| [#2595](#2595) | 0 | 2 | Request: Support for Kotlin 2.0 and Newer Versions of gRPC, Netty, and Related Dependencies |
| [#2594](#2594) | 0 | 2 | Request: Support for Kotlin 2.0 and Newer Versions of gRPC, Netty, and Related Dependencies |
| [#2579](#2579) | 1 | 0 | Non-root namespace Spring dependencies fail on app startup |
| [#2473](#2473) | 0 | 2 | Cancellation scopes and async procedures are canceled in non-deterministic order when workflow is canceled |
| [#2449](#2449) | 1 | 0 | SpringBoot - create ScheduleClient per namespace that has namespace pre-configured in its ScheduleClientOptions |
| [#2329](#2329) | 0 | 2 | Mock Workflow.currentTimeMillis() return value in test environment |
| [#2308](#2308) | 0 | 2 | Add WorkflowIdConflictPolicy in child workflow options  |
| [#2290](#2290) | 1 | 0 | Support workflow init in our spring boot integration  |
| [#2287](#2287) | 0 | 2 | metric not exposed without workersAutoDiscovery property when using spring boot actuator. |
| [#2139](#2139) | 1 | 0 | Support "query" when listing schedules |
| [#2122](#2122) | 0 | 2 | Java SDK does not have option to register workflow name statically |
| [#2119](#2119) | 0 | 2 | Missing metric reporting in local activity execution |
| [#2090](#2090) | 0 | 2 | Warn or error when update handlers dangle across CAN or workflow exit |
| [#2064](#2064) | 0 | 2 | Native image descriptor for GraalVM in the temporal-spring-boot-starter-alpha |
| [#2063](#2063) | 1 | 0 | Extend TestWorkflowExtension to support specifying a custom task queue name |
| [#2034](#2034) | 0 | 2 | Provide way to populate activity execution context for activity unit tests |
| [#2018](#2018) | 0 | 2 | Kotlin `ActivityStubExt.execute*` extension functions wrap arguments in list |
| [#2006](#2006) | 0 | 2 | ‚¨ÜÔ∏è Bump Protobuf Plugin |
| [#1997](#1997) | 0 | 2 | API key client option |
| [#1984](#1984) | 1 | 0 | [Temporal Spring-boot Starter] customizing workflow options by workflow type |
| [#1959](#1959) | 0 | 2 | Missing Retry Policy on Continue-As-New |
| [#1954](#1954) | 0 | 2 | TemporalTestServer add support to test schedules |
| [#1937](#1937) | 0 | 2 | Support a promise-based await |
| [#1889](#1889) | 0 | 2 | spring-boot-starter-2.7.12.jar: 7 vulnerabilities (highest severity is: 9.8) - autoclosed |
| [#1867](#1867) | 0 | 2 | use spring boot sdk, how to run workflow |
| [#1824](#1824) | 0 | 2 | Make ProtobufPayloadConverter and ProtobufJsonPayloadConverter not final |
| [#1811](#1811) | 0 | 2 | SpringBoot - add @Primary to temporalWorkflowClient WorkflowClient Bean |
| [#1803](#1803) | 0 | 2 | guava-31.1-jre.jar: 1 vulnerabilities (highest severity is: 7.1) |
| [#1802](#1802) | 0 | 2 | [Test server] ConcurrentModificationException on Workflow.upsertSearchAttributes in tests |
| [#1785](#1785) | 0 | 2 | Detailed message for exceptions |
| [#1738](#1738) | 0 | 2 | spring-boot-dependencies-2.7.9.pom: 2 vulnerabilities (highest severity is: 6.5) - autoclosed |
| [#1722](#1722) | 0 | 2 | Signal with a local activity in the last Workflow Task hangs the workflow execution |
| [#1715](#1715) | 1 | 0 | WorkerOptions should enforce an amount of executors to be not less than an amount of pollers |
| [#1709](#1709) | 1 | 0 | Cancellation of external workflow needs test coverage |
| [#1703](#1703) | 0 | 2 | WorkerFactoryOptions getDefaultInstance() does not return the default instance |
| [#1700](#1700) | 0 | 2 | spring-boot-starter-2.7.9.jar: 7 vulnerabilities (highest severity is: 9.8) - autoclosed |
| [#1681](#1681) | 0 | 2 | Exceptions thrown from workflow executor code shouldn't be subject to failWorkflowExceptionTypes |
| [#1676](#1676) | 0 | 2 | Child WF fails on signaling a 'not found' WF although the signal was handled |
| [#1597](#1597) | 0 | 2 | issue - when   @Autowired spring cloud open feign client bean into  bean with @ActivityImpl @Component, this.workerFactory.start(); gonna start workers so that could not auto register other workers |
| [#1584](#1584) | 0 | 2 | ExternalWorkflowStub query |
| [#1557](#1557) | 0 | 2 | Return not-found with `NamespaceNotFoundFailure` when namespace not found (and other errordetails) |
| [#1551](#1551) | 0 | 2 | Error while implementing Inheritance | Java SDK |
| [#1541](#1541) | 0 | 2 | TLS server for java sdk connection option. |
| [#1531](#1531) | 0 | 2 | Declaring ActivityStub using annotation instead of newActivityStub |
| [#1519](#1519) | 0 | 2 | Add num_pollers metric |
| [#1479](#1479) | 0 | 2 | Spring Boot Starter dependency problem when using Maven |
| [#1449](#1449) | 1 | 0 | Spring Boot - add support for dynamic worklows |
| [#1358](#1358) | 1 | 0 | Add CI testing for the native test server |
| [#1346](#1346) | 1 | 0 | Await on Local Activities shouldn't occupy workflow executor thread |
| [#1306](#1306) | 0 | 2 | Use client OpenTracing/OpenTelemetry spans for signal and queries |
| [#1303](#1303) | 0 | 2 | Cancelation of Local Activities |
| [#1300](#1300) | 0 | 2 | Provide WorkflowInfo#getHistoryLength() |
| [#1219](#1219) | 0 | 2 | Disabled time skipping becomes re-enabled when calling `WorkflowStub.getResult` |
| [#1211](#1211) | 1 | 0 | MDC context logging properties not propagating inside promise.handle |
| [#1135](#1135) | 0 | 2 | jaeger-client-1.8.0.jar: 1 vulnerabilities (highest severity is: 7.7) - autoclosed |
| [#1094](#1094) | 0 | 2 | üö≤ Test Server |
| [#1046](#1046) | 0 | 2 | Worker warning messages: DEADLINE_EXCEEDED: deadline exceeded after 69.999 |
| [#1036](#1036) | 0 | 2 | Add describeWorkflowExecution |
| [#1012](#1012) | 0 | 2 | OpenTracing interceptor should be able to ignore certain failures |
| [#966](#966) | 0 | 2 | Provide a way to recreate workers on a started WorkerFactory |
| [#950](#950) | 0 | 2 | Opentelemetry tracing support for java  |
| [#947](#947) | 0 | 2 | Rework HeartbeatContext to use GrpcRetryer with exponential backoff for network issues |
| [#918](#918) | 0 | 2 | Update gRPC to 1.42.1 |
| [#914](#914) | 1 | 0 | Shutdown of the workers doesn't destroy in-flight cached workflows |
| [#900](#900) | 0 | 2 | Worker doesn't log failure during sending workflow task completion request |
| [#896](#896) | 0 | 2 | Workflow should be able to ignore CancellationFailure and finish successfully |
| [#883](#883) | 0 | 2 | Workers don't reset sticky queue when workflow execution is evicted from the cache |
| [#790](#790) | 0 | 2 | DescribeTest#testSuccessfulActivity fails with Docker |
| [#766](#766) | 0 | 2 | Worker identity should be reported and recorded when worker picks up an Activity task |
| [#752](#752) | 0 | 2 | Revisit ActivityExecutionContext and ActivityCompletion clients |
| [#749](#749) | 0 | 2 | TestEnvironmentOptions.Builder.validateAndBuildWithDefaults fails |
| [#724](#724) | 0 | 2 | TEMPORAL_DEBUG flag is ignored by deadlock detector in eventLoop  |
| [#718](#718) | 0 | 2 | Support Spring Proxy classes marked with @Component for activities |
| [#696](#696) | 0 | 2 | Port fix for following execution chain from Go SDK |
| [#613](#613) | 1 | 0 | Calling workflow method on the workflow stub should always wait for the workflow completion. |
| [#553](#553) | 0 | 2 | Fix workflow event JSON to work with Java SDK WorkflowReplayer |
| [#501](#501) | 0 | 2 | Child workflow signal / cancellation should not use run ID |
| [#466](#466) | 0 | 2 | Allow passing proxy objects to registerActivitiesImplementations  |
| [#446](#446) | 1 | 0 | Change log level from ERROR to INFO for failed workflow task caused by signal race condition |
| [#401](#401) | 0 | 2 | Activity retry not happening in cron workflow |
| [#353](#353) | 0 | 2 | Log messages emitted by POJOActivityTaskHandler should include workflow ID and run ID |
| [#343](#343) | 0 | 2 | Don't perform a long poll of the execution result if nobody waits on it |
| [#334](#334) | 0 | 2 | Was io.temporal.testing.TestWorkflowEnvironment removed with 1.0.4? |
| [#324](#324) | 0 | 2 | Better handling of WorkflowFailedException exception |
| [#323](#323) | 0 | 2 | Throwing non-retriable failure ignored by local activities |
| [#309](#309) | 0 | 2 | WorkflowServiceStubs (sdk 1.0.4) instantiation fails within spring service |
| [#259](#259) | 0 | 2 | Add WorkflowTest Rule |
| [#258](#258) | 0 | 2 | Add opentracing context propagator |
| [#200](#200) | 0 | 2 | Java SDK metrics don't work correctly with PrometheusRegistry |
| [#70](#70) | 0 | 2 | Add support for MaxConcurrentActivityExecutionSize for async activities |
| [#14](#14) | 0 | 2 | Simplify async activity implementation |
| [#2](#2) | 0 | 2 | Refactor ReplayWorkflowContext out of WorkflowThread |
| [#2753](#2753) | 0 | 1 | Unexpected Activity Timeout Behavior After Worker Crash & Need for CancellationScope Status Check |
| [#2737](#2737) | 0 | 1 | Returning custom RuntimeException from FailureConverter leads to stuck workflows |
| [#2733](#2733) | 0 | 1 | activity_schedule_to_start_latency reports activity_type unexpectedly |
| [#2728](#2728) | 0 | 1 | ScheduleRange to check end |
| [#2687](#2687) | 0 | 1 | How to Register a Custom ContextPropagator for Multiple Temporal Namespaces in Spring Boot |
| [#2674](#2674) | 0 | 1 | TestEnvironment with external service - failing tests throws IllegalStateException errors |
| [#2670](#2670) | 0 | 1 | TestWorkflowEnvironment#sleep hangs indefinitely |
| [#2638](#2638) | 0 | 1 | Spring Boot: Allow multiple TemporalOptionsCustomizer per namespace ordered by Springboot convention  |
| [#2611](#2611) | 0 | 1 | Spring Boot Autoconfigure README link invalid |
| [#2608](#2608) | 0 | 1 | NonRootBeanPostProcessor causes meter-registry eager init |
| [#2580](#2580) | 0 | 1 | Add Summary to LocalActivityOptions |
| [#2578](#2578) | 0 | 1 | `startUpdate` JavaDoc says "asynchronously" when it may not be |
| [#2573](#2573) | 0 | 1 | Support for ManualCompletion in TestActivity Env |
| [#2537](#2537) | 0 | 1 | Support for Custom Client Identity on Schedule Trigger |
| [#2534](#2534) | 0 | 1 | [SpringBoot] Add option to fail worker autodiscovery on TypeAlreadyRegisteredException on activities |
| [#2499](#2499) | 0 | 1 | Support pluggable workflow caches |
| [#2484](#2484) | 0 | 1 | Warn when the server-provided task start time is fairly different than time SDK begins processing the task |
| [#2482](#2482) | 0 | 1 | Merging ActivityOptions fails with UnsupportedOperationException when using immutable lists for context propagators |
| [#2461](#2461) | 0 | 1 | [Feature Request] Utility to detect when deadlock detector triggers |
| [#2451](#2451) | 0 | 1 | Worfklow StartDelay not working with TestWorkflowEnvironment |
| [#2434](#2434) | 0 | 1 | Spring boot initialization should fail if activity names (per worker) are duplicated |
| [#2423](#2423) | 0 | 1 | Remove old workflow run operation token format |
| [#2420](#2420) | 0 | 1 | `temporal-serviceclient` library is incompatible with `protobuf-java` 4.x |
| [#2418](#2418) | 0 | 1 | workflow_task_execution_failed metric sometime doesn't have `failure_reason` tag |
| [#2404](#2404) | 0 | 1 | temporal-test-server for ARM64 |
| [#2392](#2392) | 0 | 1 | [Bug] Test environment sleep hangs on child workflows  |
| [#2364](#2364) | 0 | 1 | TestWorkflowEnvironment issue with setting search attributes in ContinueAsNewOptions |
| [#2346](#2346) | 0 | 1 | Manual completion client does unlimited retries for non-retryable error |
| [#2340](#2340) | 0 | 1 | Consider renaming WorkflowStub.update => WorkflowStub.executeUpdate |
| [#2321](#2321) | 0 | 1 | TestWorkflowEnvironment does not allow signalWithStart when workflow already exists |
| [#2263](#2263) | 0 | 1 | TestWorkflowEnvironment does not support workflows with start delay |
| [#2256](#2256) | 0 | 1 | Support actual versions of spring boot |
| [#2254](#2254) | 0 | 1 | RetryOption.setMaximumAttempts(0) seems broken for LocalActivities |
| [#2247](#2247) | 0 | 1 | Implement Nexus operation cancellation type |
| [#2245](#2245) | 0 | 1 | Handle Nexus links |
| [#2236](#2236) | 0 | 1 | Call ShutdownWorker API on worker shutdown |
| [#2217](#2217) | 0 | 1 | workflow metadata query |
| [#2213](#2213) | 0 | 1 | Signal w/ Start API Improvements - Java |
| [#2200](#2200) | 0 | 1 | `Workflow.newUntypedActivityStub` does not inherit default options the same way `Workflow.newActivityStub` does |
| [#2179](#2179) | 0 | 1 | Interceptor Configurations - exclusions based on workflow/activity type and task queue |
| [#2166](#2166) | 0 | 1 | Workflow-init support |
| [#2142](#2142) | 0 | 1 | Test server should treat update/poll-update as long-poll |
| [#2124](#2124) | 0 | 1 | MDC custom naming convention |
| [#2117](#2117) | 0 | 1 | Allow customization of OTel span tags |
| [#2109](#2109) | 0 | 1 | WorkflowHistoryLoader fails to load decoded event history |
| [#2106](#2106) | 0 | 1 | Confirm non-utf8 proto string behavior |
| [#2086](#2086) | 0 | 1 | Upgrade grpc version , version 1.54.0 crashes JVM on Alpine |
| [#2071](#2071) | 0 | 1 | KotlinObjectMapperFactory is not forwards compatible |
| [#2069](#2069) | 0 | 1 | Wrap GRPC::CANCELED and DEADLINE_EXCEEDED in an SDK Timeout exception for Update |
| [#2065](#2065) | 0 | 1 | It's impossible to send unset duration |
| [#2058](#2058) | 0 | 1 | Set Temporal-Namespace header on every namespace-specific gRPC request |
| [#2054](#2054) | 0 | 1 | Local activity support for next-retry-delay |
| [#2016](#2016) | 0 | 1 | Investigate bad `isReplaying` value on direct query when workflow is not in cache |
| [#1996](#1996) | 0 | 1 | SpringBoot - add "server-name" property to connection options |
| [#1965](#1965) | 0 | 1 | Heartbeat activity retries first heartbeat data instead of last |
| [#1963](#1963) | 0 | 1 | Schedule creation should create tracing span by default |
| [#1960](#1960) | 0 | 1 | json-path-2.8.0.jar: 1 vulnerabilities (highest severity is: 5.3) |
| [#1955](#1955) | 0 | 1 | Worker dynamic config |
| [#1953](#1953) | 0 | 1 | Add WorkflowImplementationOptions to TestWorkflowExtension |
| [#1927](#1927) | 0 | 1 | io.grpc:grpc-core:1.59.0 Has a breaking ABI change requiring us to update our grpc dependency |
| [#1914](#1914) | 0 | 1 | Support cancellation of long client calls |
| [#1913](#1913) | 0 | 1 | Remove WorkflowClientCallsInterceptor.pollWorkflowUpdate |
| [#1903](#1903) | 0 | 1 | Test Server hanging or reporting completed on start update requests |
| [#1901](#1901) | 0 | 1 | Failed Read-Only check should cause a WFT failure in an update validator, not fail the update |
| [#1883](#1883) | 0 | 1 | Unable to build on Ubuntu Linux for aarch64 (ARM) |
| [#1855](#1855) | 0 | 1 | Typed Search Attributes |
| [#1850](#1850) | 0 | 1 | Exponential backoff for all server requests (including/especially poll) |
| [#1842](#1842) | 0 | 1 | okhttp-4.10.0.jar: 1 vulnerabilities (highest severity is: 7.5) |
| [#1840](#1840) | 0 | 1 | Spring Boot 3 native image support |
| [#1788](#1788) | 0 | 1 | Add build id versioning feature support to test server |
| [#1768](#1768) | 0 | 1 | spring-boot-autoconfigure-2.7.9.jar: 1 vulnerabilities (highest severity is: 7.5) |
| [#1763](#1763) | 0 | 1 | Register Same Interface Multiple Times |
| [#1751](#1751) | 0 | 1 | Making activity prefix and name generation pluggable |
| [#1746](#1746) | 0 | 1 | Add capability and SDK metadata field for test server |
| [#1744](#1744) | 0 | 1 | Write ProtocolMessageCommand along with protocol messages |
| [#1741](#1741) | 0 | 1 | Workflow Update: Java |
| [#1731](#1731) | 0 | 1 | Add attempt to MDC context of the activity worker handler |
| [#1729](#1729) | 0 | 1 | Jackson serialization issue when activity returns s3 object as response. |
| [#1725](#1725) | 0 | 1 | temporal-testing-1.20.0-SNAPSHOT: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1717](#1717) | 0 | 1 | temporal-testing-1.19.0-SNAPSHOT: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1716](#1716) | 0 | 1 | json-path-2.7.0.jar: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1710](#1710) | 0 | 1 | Test Code Coverage |
| [#1707](#1707) | 0 | 1 | ServiceWorkflowHistoryIterator should eagerly request the next page |
| [#1680](#1680) | 0 | 1 | Improve shutdown of workers with wait for releasing of all reserved local dispatch slots |
| [#1671](#1671) | 0 | 1 | New Failure types |
| [#1667](#1667) | 0 | 1 | WorkflowStub.getExecution returns null on Temporal Java SDK 1.18.1 when workflow is started via signalWithStart |
| [#1648](#1648) | 0 | 1 | Workers not auto starting in spring boot starter |
| [#1646](#1646) | 0 | 1 | Eager Workflow Task Dispatch |
| [#1613](#1613) | 0 | 1 | spring-boot-dependencies-2.7.8.pom: 7 vulnerabilities (highest severity is: 9.8) - autoclosed |
| [#1611](#1611) | 0 | 1 | error_prone_core-2.18.0.jar: 3 vulnerabilities (highest severity is: 7.5) |
| [#1596](#1596) | 0 | 1 | issue - when   @Autowired other bean into  bean with @ActivityImpl @Component, this.workerFactory.start(); gonna start workers so that could not auto register other workers |
| [#1590](#1590) | 0 | 1 | workflow_completed counter counts successful completions of workflow method instead of workflow executions |
| [#1588](#1588) | 0 | 1 | error_prone_core-2.17.0.jar: 3 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1585](#1585) | 0 | 1 |  Do not auto-retry gRPC-message-size-too-large errors |
| [#1564](#1564) | 0 | 1 | spring-boot-starter-2.7.6.jar: 7 vulnerabilities (highest severity is: 9.8) - autoclosed |
| [#1559](#1559) | 0 | 1 | kotlin-stdlib-jdk8-1.4.32.jar: 1 vulnerabilities (highest severity is: 5.3) |
| [#1552](#1552) | 0 | 1 | High level API to list workflows |
| [#1522](#1522) | 0 | 1 | How to gracefully shut down a temporal worker |
| [#1511](#1511) | 0 | 1 | Cron Jitter support |
| [#1509](#1509) | 0 | 1 | Data Converter |
| [#1505](#1505) | 0 | 1 | IllegalStateException: Signal received after workflow is closed |
| [#1483](#1483) | 0 | 1 | error_prone_core-2.16.jar: 3 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1482](#1482) | 0 | 1 | spring-boot-starter-2.7.4.jar: 5 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1476](#1476) | 0 | 1 | error_prone_core-2.11.0.jar: 1 vulnerabilities (highest severity is: 4.3) - autoclosed |
| [#1475](#1475) | 0 | 1 | temporal-sdk-1.17.0-SNAPSHOT: 1 vulnerabilities (highest severity is: 4.3) - autoclosed |
| [#1469](#1469) | 0 | 1 | jackson-databind-2.13.4.jar: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1464](#1464) | 0 | 1 | Allow setting WorkflowOptions via WorkflowImplementationOptions |
| [#1422](#1422) | 0 | 1 | MicrometerClientStatsReporter does not report histograms |
| [#1402](#1402) | 0 | 1 | Split PayloadCodec into two Encoder/Decoder interfaces and have a separate config for each |
| [#1394](#1394) | 0 | 1 | [Spring Boot] Support user defined *Customizers for all *Options classes |
| [#1393](#1393) | 0 | 1 | kotlin-stdlib-1.5.31.jar: 1 vulnerabilities (highest severity is: 5.3) |
| [#1374](#1374) | 0 | 1 | External workflow signal from a workflow code throws incorrect exceptions |
| [#1373](#1373) | 0 | 1 | Child Workflow creation API should allow user to specify a custom data converter |
| [#1371](#1371) | 0 | 1 | Eviction of workflow due to too advanced state fails query |
| [#1361](#1361) | 0 | 1 | üèöÔ∏è Local Activities |
| [#1357](#1357) | 0 | 1 | Latest test-server is broken |
| [#1338](#1338) | 0 | 1 | PoC - Static analyzer for determinism |
| [#1321](#1321) | 0 | 1 | An api to know if the current Thread is running under Workflow Context |
| [#1293](#1293) | 0 | 1 | Support robfig style cron defs in TestWorkflowEnvironment |
| [#1287](#1287) | 0 | 1 | kotlin-stdlib-1.5.20.jar: 1 vulnerabilities (highest severity is: 5.3) - autoclosed |
| [#1286](#1286) | 0 | 1 | kotlin-scripting-compiler-embeddable-1.4.32.jar: 1 vulnerabilities (highest severity is: 5.3) - autoclosed |
| [#1230](#1230) | 0 | 1 | Allow dynamic creation and shutdown of workers |
| [#1226](#1226) | 0 | 1 | Disabling time skipping in 1.11.0 is not working? |
| [#1223](#1223) | 0 | 1 | Test server generates the same activity task token on retry |
| [#1222](#1222) | 0 | 1 | Consider making std-out of Test Server more useful. |
| [#1220](#1220) | 0 | 1 | Test Server fails when starting a workflow that already exists. |
| [#1203](#1203) | 0 | 1 | Rework long poll code to use an absolute deadline instead of calculating an elapsed time |
| [#1202](#1202) | 0 | 1 | Remove RpcRetryOptions from the public API |
| [#1201](#1201) | 0 | 1 | Revisit continue-as-new that doesn't carry over some attributes of parent run if not set explicitly |
| [#1195](#1195) | 0 | 1 | Support dynamic values for custom tags in metrics. |
| [#1189](#1189) | 0 | 1 | Expose assertHistoryEvent utility method from TestWorkflowRule |
| [#1177](#1177) | 0 | 1 | WorkflowStub.getResult and getResultAsync do not throw TimeoutException |
| [#1139](#1139) | 0 | 1 | TestWorkflowEnvironment - add support for filtering for ListOpenWorkflowExecutions |
| [#1138](#1138) | 0 | 1 | Test server does not decrement time skipping lock for outstanding activities on workflow completion |
| [#1126](#1126) | 0 | 1 | Add pass through for Payloads to the default DataConverter |
| [#1125](#1125) | 0 | 1 | PotentialDeadlockException may collect inconsistent stacktraces  |
| [#1114](#1114) | 0 | 1 | Suspend and resume Worker can cause Workflow stuck |
| [#1112](#1112) | 0 | 1 | error_prone_core-2.9.0.jar: 1 vulnerabilities (highest severity is: 5.5) - autoclosed |
| [#1111](#1111) | 0 | 1 | protobuf-java-util-3.19.4.jar: 1 vulnerabilities (highest severity is: 7.7) - autoclosed |
| [#1110](#1110) | 0 | 1 | jackson-databind-2.13.1.jar: 1 vulnerabilities (highest severity is: 7.5) - autoclosed |
| [#1107](#1107) | 0 | 1 | Workflow metadata resolution code registers an overridden method from parent class as a second query |
| [#1104](#1104) | 0 | 1 | Permissions Error for Links Followed via javadoc.io Search |
| [#1097](#1097) | 0 | 1 | Incompatible protobuf-java-util library usage |
| [#1091](#1091) | 0 | 1 | Maven depends for temporal-sdk 1.8.1 does not respect range constraints for protobuf version |
| [#1085](#1085) | 0 | 1 | range dependency declaration in 1.8.1 causes NoSuchMethodError: com.google.protobuf.GeneratedMessageV3.isStringEmpty |
| [#1080](#1080) | 0 | 1 | Bug when building WorkerOptions |
| [#1051](#1051) | 0 | 1 | PollWorkflowTaskQueueResponse should be available for interception |
| [#1042](#1042) | 0 | 1 | Add ability to dynamically limit number of parallel activities |
| [#1032](#1032) | 0 | 1 | Add ability to disable workflow worker |
| [#1030](#1030) | 0 | 1 | Rename poller related WorkerOptions options |
| [#1028](#1028) | 0 | 1 | Missing WorkflowExecutionUtils.describeWorkflowInstance() |
| [#1027](#1027) | 0 | 1 | Javadocs |
| [#1011](#1011) | 0 | 1 | UX - Java SDK |
| [#1005](#1005) | 0 | 1 | Provide ActivityExecutionContext#isCancelled |
| [#989](#989) | 0 | 1 | Retry Interval doesn't work for LocalActivity, default value is used instead |
| [#979](#979) | 0 | 1 | Gauge metrics disappear after ~60 seconds |
| [#977](#977) | 0 | 1 | Static and synthetic methods are considered Activity methods in activity interfaces |
| [#955](#955) | 0 | 1 | Expose a method allowing user code to defined if they are inside workflow thread |
| [#929](#929) | 0 | 1 | Can't register activity implementation that uses inheritance |
| [#901](#901) | 0 | 1 | Workers hammering server with incorrectly formed commands without rate limit or backoff |
| [#886](#886) | 0 | 1 | testActivityScheduleToCloseTimeout is flaky with dockerized service |
| [#878](#878) | 0 | 1 | Implement autoscaling of Pollers |
| [#856](#856) | 0 | 1 | WorkflowClient#execute doesn't pair correctly with workflowStub.getResult() |
| [#850](#850) | 0 | 1 | Document gRPC retrying logic and parameters across SDKs and normalize the approach |
| [#842](#842) | 0 | 1 | Test env - ListOpenWorkflowExecutionsResponse exec status is always WORKFLOW_EXECUTION_STATUS_UNSPECIFIED |
| [#840](#840) | 0 | 1 | Add "listQueries" built-in query |
| [#828](#828) | 0 | 1 | Expose health check on WorkflowServiceStubs or WorkflowClient |
| [#815](#815) | 0 | 1 | [Port] Allow multiple host:port to be specified for connection |
| [#814](#814) | 0 | 1 | testUntypedChildStubWorkflowAsync flaked in CI with test service internal state machine exception |
| [#802](#802) | 0 | 1 | whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows flakes with Dockerized service |
| [#779](#779) | 0 | 1 | History produced by test environment should be compliant with tctl history format |
| [#778](#778) | 0 | 1 | üßµ Performance & Threading model |
| [#762](#762) | 0 | 1 | AuthorizationGrpcMetadataProvider doesn't have a public constructor |
| [#760](#760) | 0 | 1 | Implement Workflow Tasks backpressure for Pollers if there is no available executors |
| [#743](#743) | 0 | 1 | SignalTest#testSignalUntyped is flaky |
| [#664](#664) | 0 | 1 | GrpcRetryer should have a special handling of ResourceExhausted exception |
| [#652](#652) | 0 | 1 | Make WorkflowStub#getResult timeout configurable on WorkflowOptions |
| [#650](#650) | 0 | 1 | Add unit tests for WorkflowExecutionUtils#getInstanceCloseEvent  |
| [#628](#628) | 0 | 1 | In TestWorkflowEnviornment, getResult() hangs after terminate() |
| [#607](#607) | 0 | 1 | Automate pre-release SDK testing against samples-java & canary-java |
| [#600](#600) | 0 | 1 | Allow context propagator to be set on LocalActivityOptions |
| [#599](#599) | 0 | 1 | Default MDC entries not propagated to LocalActivities |
| [#586](#586) | 0 | 1 | Activities advised with AspectJ are not recognised as implementation of @ActivityInterface anymore |
| [#514](#514) | 0 | 1 | DescribeWorkflowExecution is not implemented for the java test service. |
| [#503](#503) | 0 | 1 | Make DEFAULT_DEADLOCK_DETECTION_TIMEOUT configurable |
| [#499](#499) | 0 | 1 | Handle all exceptions as non-retryable when TEMPORAL_DEBUG is set |
| [#490](#490) | 0 | 1 | Add LocalActivityOption#contextPropagators |
| [#489](#489) | 0 | 1 | ContextPropagators don't work for local activities |
| [#487](#487) | 0 | 1 | How to set / update search attribute values during Workflow / Activity runtime ? |
| [#476](#476) | 0 | 1 | GrpcRetryer#retryWithResultAsync doesn't perform retries in some cases |
| [#471](#471) | 0 | 1 | WorkflowExecutionUtils#getInstanceCloseEvent could get into infinite loop after timeout |
| [#420](#420) | 0 | 1 | TestWorkflowService doesn't pass headers into workflow retry |
| [#417](#417) | 0 | 1 | TestWorkflowRule get workerInterceptors from two different sources and merges them incorrectly |
| [#414](#414) | 0 | 1 | Workflow retry after Activity failure works incorrectly with TestService |
| [#400](#400) | 0 | 1 | Workflow as a cron job executing more number of times than expected |
| [#387](#387) | 0 | 1 | API docs erroneously claim WorkflowIdReusePolicy default is AllowDuplicateFailedOnly |
| [#373](#373) | 0 | 1 | Interceptors: Add missing header to activity and client interceptors |
| [#361](#361) | 0 | 1 | Default WorkflowIdReusePolicy is AllowDuplicate and not AllowDuplicateFailedOnly |
| [#342](#342) | 0 | 1 | maven packages for java client |
| [#341](#341) | 0 | 1 | Support robfig style cron defs in TestWorkflowEnvironment |
| [#335](#335) | 0 | 1 | Support workflow metadata query |
| [#330](#330) | 0 | 1 | Customizable RpcRetryOptions in ServiceStubsOptions |
| [#328](#328) | 0 | 1 | JSON de-serializer fails on field additions and removals |
| [#310](#310) | 0 | 1 | Do not fail stack trace query on a closed workflow. But return empty stack |
| [#305](#305) | 0 | 1 | Run Saga compensations in a disconnected scope |
| [#302](#302) | 0 | 1 | Print stacktrace coming from another language in the exception message |
| [#300](#300) | 0 | 1 | WorkflowExecutionHistory.fromJson does not support JSONs exported via Web console or CLI  |
| [#290](#290) | 0 | 1 | Flaky whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows test |
| [#257](#257) | 0 | 1 | Expose previous run failure though workflow context API |
| [#248](#248) | 0 | 1 | PollActivityTaskQueue should return empty poll after a minute |
| [#204](#204) | 0 | 1 | Block of copied code |
| [#201](#201) | 0 | 1 | STICKY_CACHE_THREAD_FORCED_EVICTION double reporting |
| [#192](#192) | 0 | 1 | Netty NioEventLoop exception |
| [#185](#185) | 0 | 1 | Incorrect Temporal Error handling in POJOActivityInboundCallsInterceptor |
| [#176](#176) | 0 | 1 | Support development with recent JDK |
| [#153](#153) | 0 | 1 | java.time.OffsetDateTime deserialization failing |
| [#149](#149) | 0 | 1 | Workflow.wrap and Activity.wrap fail on chained Throwable |
| [#144](#144) | 0 | 1 | newUntypedWorkflowStub should check if runId.isPresent() before calling get |
| [#107](#107) | 0 | 1 | Intermittent testWorkflowMetrics Unit test failure |
| [#94](#94) | 0 | 1 | Do not retry SimulatedTimeoutException |
| [#89](#89) | 0 | 1 | Add binary checksum to WorkerOptions |
| [#88](#88) | 0 | 1 | Customer needs to specify timeout for start workflow call |
| [#84](#84) | 0 | 1 | TestWorkflowService: Make tokens unique across retries |
| [#75](#75) | 0 | 1 | Provide shaded release JAR |
| [#74](#74) | 0 | 1 | Delay workflow completion until abandoned workflows start |
| [#66](#66) | 0 | 1 | Fix incorrect use of System.nanoTime |
| [#57](#57) | 0 | 1 | Automatically reconnect to the service when it changes ip address |
| [#28](#28) | 0 | 1 | Add workflow deadlock detector |
| [#27](#27) | 0 | 1 | Add support for ActivityOptions.WaitForCancellation |
| [#24](#24) | 0 | 1 | Fix getVersion |
| [#21](#21) | 0 | 1 | Add support for cross domain activity and child workflow scheduling |
| [#20](#20) | 0 | 1 | Rename Worker.register... to Worker.set |
| [#18](#18) | 0 | 1 | Add Logger that works in both activity and workflow context |
| [#1](#1) | 0 | 1 | Switch to Jackson for default DataConverter |
| [#2755](#2755) | 0 | 0 | Support using Temporal failures in Nexus APIs |
| [#2754](#2754) | 0 | 0 | Environment Configuration does not read the correct file path on macOS |
| [#2752](#2752) | 0 | 0 | OpenTracingWorkflowClientCallsInterceptor - support for updateWithStart is not present |
| [#2750](#2750) | 0 | 0 | Tests not passing: TestStatsReporter Flush not flushing |
| [#2747](#2747) | 0 | 0 | @WorkflowImpl(workers = "...") should support Spring property placeholders like taskQueues does |
| [#2745](#2745) | 0 | 0 | WorkerOptions isUsingVirtualThreadsOnWorkflowWorker issue |
| [#2735](#2735) | 0 | 0 | Non-root namespaces should be able to use the in-memory test server |
| [#2732](#2732) | 0 | 0 | Set GrpcMessageTooLarge as failure_reason for workflow task failed metric |
| [#2726](#2726) | 0 | 0 | Allow overriding of the Worker Deployment Version when invoking a Child Workflow |
| [#2716](#2716) | 0 | 0 | Worker Heartbeating |
| [#2714](#2714) | 0 | 0 | Improper file path for envconfig |
| [#2707](#2707) | 0 | 0 | duplicated error message "invalid interval:..."  in RPCRetryOptions |
| [#2705](#2705) | 0 | 0 | Default task failure cause to "workflow worker unhandled failure" |
| [#2703](#2703) | 0 | 0 | [java] Plugin + SimplePlugin |
| [#2702](#2702) | 0 | 0 | Add support for static summary for side effects and mutable side effects |
| [#2689](#2689) | 0 | 0 | Use normal task queue name for sticky task queue client metrics |
| [#2666](#2666) | 0 | 0 | Test server needs to set metadata `type` for search attribute payloads |
| [#2661](#2661) | 0 | 0 | Set history size and suggest continue as new on task start attributes in test server |
| [#2659](#2659) | 0 | 0 | temporal-testing for Java does not propagate headers for signals in interceptors |
| [#2657](#2657) | 0 | 0 | Expose Temporal Nexus operation info to Temporal Nexus operation authors |
| [#2656](#2656) | 0 | 0 | Springboot Multi Namespace: Add annotation to specify Namespace a bean belongs too |
| [#2655](#2655) | 0 | 0 | Testing server continue-as-new doesn't carry memo/search attributes |
| [#2651](#2651) | 0 | 0 | Add overload for `WorkflowStub.cancel` to target exact workflow execution |
| [#2650](#2650) | 0 | 0 | Ensure tests exist to confirm custom slot supplier slot info has proper fields |
| [#2644](#2644) | 0 | 0 | `workflow_task_queue_poll_succeed` is not emitted when poller autoscaling is on |
| [#2643](#2643) | 0 | 0 | [Feature Request] Reclassify Benign Application errors in OpenTelemetry |
| [#2629](#2629) | 0 | 0 | Clarify nexus operation cancellation failure |
| [#2626](#2626) | 0 | 0 | Plugin support |
| [#2620](#2620) | 0 | 0 | OpenTracingClientInterceptor add support for updateWithStart |
| [#2614](#2614) | 0 | 0 | In a Nexus handler only pass a completion callback if a completion URL is provided |
| [#2612](#2612) | 0 | 0 | Align Nexus handler failure conversion with other SDKs |
| [#2610](#2610) | 0 | 0 | Spring boot with namespaces configuration Connection refused: /127.0.0.1:7233 in tests |
| [#2606](#2606) | 0 | 0 | TestWorkflowMutableStateImpl - race condition between TimerFired event and CancelTimer command |
| [#2601](#2601) | 0 | 0 | ApplicationFailure.Builder requires Category be set |
| [#2598](#2598) | 0 | 0 | Allow specifying activity options for specific activity call |
| [#2593](#2593) | 0 | 0 | Created accidentally |
| [#2592](#2592) | 0 | 0 | Python Nexus tests failing under Java test server |
| [#2590](#2590) | 0 | 0 | When parsing operation token, treat `null` as zero |
| [#2588](#2588) | 0 | 0 | Use operation token for the OPERATION_TOKEN header value |
| [#2586](#2586) | 0 | 0 | Time skipping server drops headers in workflow signal |
| [#2582](#2582) | 0 | 0 | Null cause in Nexus HandlerException is not handled correctly |
| [#2562](#2562) | 0 | 0 | Environment configuration |
| [#2559](#2559) | 0 | 0 | [java] Add `WorkflowTaskFailedCause` to `RespondQueryTaskCompletedRequest` |
| [#2552](#2552) | 0 | 0 | Add poller autoscaling options for Spring |
| [#2550](#2550) | 0 | 0 | deploymentOptions should be set on all poll requests, not just workflow polls |
| [#2538](#2538) | 0 | 0 | [Feature Request]  Add counter metric for unaccessed failed promises |
| [#2533](#2533) | 0 | 0 | NonRootNamespaceAutoConfiguration#nonRootBeanPostProcessor breaks MeterRegistry customizations |
| [#2523](#2523) | 0 | 0 | Expose StartWorkflowExecutionResponse fields to ExecuteWorkflow API |
| [#2521](#2521) | 0 | 0 | Workflow instance should be accessible in test environment for simple assertion |
| [#2502](#2502) | 0 | 0 | Remove license headers from files |
| [#2494](#2494) | 0 | 0 | Test server not showing user metadata for workflow start in history |
| [#2493](#2493) | 0 | 0 | NP–ï in ScheduleDescription.getMemo (should check `memoPayload == null`, not `memo`) |
| [#2488](#2488) | 0 | 0 | [java] SDK support for activity reset |
| [#2481](#2481) | 0 | 0 | Show retry policy on activity info |
| [#2480](#2480) | 0 | 0 | Memo-s not present in listOpenWorkflowExecutions when running with temporal-testing |
| [#2475](#2475) | 0 | 0 | Apply application failure logging and metrics behaviour according to `ApplicationErrorCategory` |
| [#2469](#2469) | 0 | 0 | [Java] Worker Versioning high level client |
| [#2465](#2465) | 0 | 0 | Heartbeating activities should be interrupted when the activities are paused. |
| [#2459](#2459) | 0 | 0 | Test server can overwrite last heartbeat details when not on fail request |
| [#2458](#2458) | 0 | 0 | Support New Worker Versioning API |
| [#2450](#2450) | 0 | 0 | GenericWorkflowClient can prevent exit of JVM |
| [#2442](#2442) | 0 | 0 | Add summary to Nexus operation |
| [#2432](#2432) | 0 | 0 | Expose static summary/details on workflow execution description |
| [#2430](#2430) | 0 | 0 | Expose root workflow execution |
| [#2426](#2426) | 0 | 0 | Built-in query responses should use "RawValue" |
| [#2425](#2425) | 0 | 0 | Support "RawValue" non-converted values |
| [#2402](#2402) | 0 | 0 | Support musl-based build of test server |
| [#2399](#2399) | 0 | 0 | Support Priority Annotations |
| [#2393](#2393) | 0 | 0 | Add `patched()` and `deprecatePatch()` APIs |
| [#2368](#2368) | 0 | 0 | Special behavior for Temporal built-in prefixes |
| [#2367](#2367) | 0 | 0 | Removing a `Workflow.getVersion` with a succeeding `Workflow.sideEffect` causes NDE |
| [#2362](#2362) | 0 | 0 | Provide client from activity context |
| [#2361](#2361) | 0 | 0 | Access to workflow/activity instance from context |
| [#2359](#2359) | 0 | 0 | Clarify `UnableToAcquireLockException` |
| [#2358](#2358) | 0 | 0 | Nexus error rehydration |
| [#2349](#2349) | 0 | 0 | Failure to allocate thread can lock up local activities |
| [#2333](#2333) | 0 | 0 | `taskTimeoutWillRescheduleTheTaskOnTheGlobalList ` on the test server is flaky |
| [#2331](#2331) | 0 | 0 | [Bug] CI build will soon get broken due to GHA dropping support for node16-based actions |
| [#2328](#2328) | 0 | 0 | Add an interceptor for listExecutions |
| [#2317](#2317) | 0 | 0 | Do runtime check to ensure update validator has the same parameter signature as update it validates |
| [#2314](#2314) | 0 | 0 | Clear MDC context after each Task |
| [#2307](#2307) | 0 | 0 | Removing a `Workflow.GetVersion` call can cause NDE if there are multiple parallel workflow threads running. |
| [#2299](#2299) | 0 | 0 | Springboot workflow implementation with non default constructors fail in 1.26.0 |
| [#2289](#2289) | 0 | 0 | Allow for API key authentication instead of mTLS in Spring Boot Autoconfigure |
| [#2285](#2285) | 0 | 0 | Workflow update with start does not pass Workflow arguments  |
| [#2284](#2284) | 0 | 0 | Workflow update with start cannot use a `UpdateWithStartWorkflowOperation` created from a String update name |
| [#2283](#2283) | 0 | 0 | Auto-skip time in time-skipping testing environment when waiting on update result |
| [#2273](#2273) | 0 | 0 | Add Nexus failure_reason metric tag |
| [#2268](#2268) | 0 | 0 | Add "summary" to activities |
| [#2265](#2265) | 0 | 0 | Add high-level workflow describe |
| [#2246](#2246) | 0 | 0 | Time-skipping past activity‚Äôs startToCloseTimeout causes worker not to close |
| [#2237](#2237) | 0 | 0 | Show update handler and ID in logging context |
| [#2235](#2235) | 0 | 0 | Add Nexus Support to TestWorkflowExtension |
| [#2232](#2232) | 0 | 0 | Fix inconsistency in javadoc for WorkflowInterface |
| [#2229](#2229) | 0 | 0 | Add TestNexusEnvironment similar to TestActivityEnvironment |
| [#2227](#2227) | 0 | 0 | Test Server: Fill in namespace capabilities in describe response |
| [#2220](#2220) | 0 | 0 | Add Nexus Worker interceptor |
| [#2219](#2219) | 0 | 0 | Test Server: Add support for user metadata |
| [#2216](#2216) | 0 | 0 | MVP support for user meta data on workflows and events  |
| [#2215](#2215) | 0 | 0 | Test Server does not treat internal errors as retryable from Nexus operations  |
| [#2212](#2212) | 0 | 0 | UpdateHandle should have a getResult method |
| [#2209](#2209) | 0 | 0 | Nexus handler - well known Temporal error translation |
| [#2208](#2208) | 0 | 0 | Add `getMetricsScope` to `WorkflowOutboundCallsInterceptor` |
| [#2192](#2192) | 0 | 0 | Missing Attempt value on MDC for logging purposes |
| [#2184](#2184) | 0 | 0 | Fix workflow start delay docs to say signal does not interrupt delay |
| [#2181](#2181) | 0 | 0 | Type safe async update API |
| [#2178](#2178) | 0 | 0 | Carry over search attributes on continue-as-new if none are explicitly specified |
| [#2165](#2165) | 0 | 0 | Enable Nexus test server docker functional tests once 1.25 is released |
| [#2160](#2160) | 0 | 0 | Child workflow cancellation can trigger SDK event loop without a WFT Started |
| [#2157](#2157) | 0 | 0 | CI: Get rid of buildjet-2vcpu-ubuntu-1804 GHA runners |
| [#2155](#2155) | 0 | 0 | WorkflowTask failure because of an invalid state transition in LocalActivity state machine |
| [#2152](#2152) | 0 | 0 | Support schedule search attribute update |
| [#2150](#2150) | 0 | 0 | Generated Google proto classes are part of generated service client classes |
| [#2149](#2149) | 0 | 0 | Revisit local activity backpressure logic w/ no-max slot suppliers |
| [#2148](#2148) | 0 | 0 | Better toString representations on service stub options |
| [#2127](#2127) | 0 | 0 | Test server sometimes fails to include signal in first WFT |
| [#2116](#2116) | 0 | 0 | Workflow-friendly concurrency control |
| [#2114](#2114) | 0 | 0 | Testing |
| [#2113](#2113) | 0 | 0 | Testing |
| [#2112](#2112) | 0 | 0 | Testing |
| [#2111](#2111) | 0 | 0 | Testing |
| [#2107](#2107) | 0 | 0 | Concurrent Modification Exception when executing workflow with local activities |
| [#2094](#2094) | 0 | 0 | Java SDK `StartUpdate` waits outside of intercepted call |
| [#2093](#2093) | 0 | 0 | Expose UpdateID in an update handler |
| [#2091](#2091) | 0 | 0 | Provide methods to wait for all handlers to finish |
| [#2078](#2078) | 0 | 0 | Add the ability to specify worker identity for each worker |
| [#2077](#2077) | 0 | 0 | TestWorkflowEnvironment, TestWorkflowRule, TestWorkflowExtension - auto-register search attributes from WorkflowStub  |
| [#2073](#2073) | 0 | 0 | Send original update request back in accept/reject response |
| [#2068](#2068) | 0 | 0 | Disallow continue as new in update handlers |
| [#2060](#2060) | 0 | 0 | Call describe namespace on worker start |
| [#2059](#2059) | 0 | 0 | Cloud Operations API Client |
| [#2051](#2051) | 0 | 0 | Ability to specify activity timeouts via annotation in Java SDK |
| [#2048](#2048) | 0 | 0 | ScheduleClient is missing an option to add interceptors |
| [#2045](#2045) | 0 | 0 | Make startUpdate users aware that it's synchronous w/ worker |
| [#2044](#2044) | 0 | 0 | Fail workflow task on illegal calls in `Workflow.await` |
| [#2038](#2038) | 0 | 0 | [CI] StickyWorkflowDrainShutdownTest.testShutdown is flaky |
| [#2035](#2035) | 0 | 0 | Expose defaultConnection() method to switch between localhost and cloud based on env |
| [#2033](#2033) | 0 | 0 | Support for WorkflowIdConflictPolicy |
| [#2031](#2031) | 0 | 0 | Add SpringBoot integration for `SlotSupplier`s |
| [#2030](#2030) | 0 | 0 | Add `PauseableSlotSupplier` |
| [#2026](#2026) | 0 | 0 | [SpringBoot] Add graceful shutdown wait time as property |
| [#2020](#2020) | 0 | 0 | `ReplayWorkflowTaskHandler.failureToWFTResult` does not use a `SeralizationContext` when serializing an exception for a direct query |
| [#2017](#2017) | 0 | 0 | [Feature Request] Use macOS M1/ARM runners for all SDK CI |
| [#2002](#2002) | 0 | 0 | [Feature Request] SDK should not return an update handle if the update has not reached the desired state |
| [#1990](#1990) | 0 | 0 | grpc-api-1.54.1.jar: 1 vulnerabilities (highest severity is: 7.1) |
| [#1987](#1987) | 0 | 0 | Configurable workflow exception types at the worker level |
| [#1983](#1983) | 0 | 0 | Expose next retry delay on Application Failure in all SDKs |
| [#1982](#1982) | 0 | 0 | Verify DynamicWorkflows implementation applies serialization  |
| [#1981](#1981) | 0 | 0 | Add source code to shaded library |
| [#1978](#1978) | 0 | 0 |  Disable eager activities if task queue rate limits is set |
| [#1973](#1973) | 0 | 0 | WorkflowUpdateException incorrectly wrapped by ExecutionException in some edge case |
| [#1971](#1971) | 0 | 0 | Fix start-workers config |
| [#1966](#1966) | 0 | 0 | Workflow stub with only an update method fails |
| [#1956](#1956) | 0 | 0 | Worker autotuning - Pollers |
| [#1952](#1952) | 0 | 0 | ktlint-0.47.1.jar: 2 vulnerabilities (highest severity is: 7.5) |
| [#1951](#1951) | 0 | 0 | spring-boot-dependencies-2.7.12.pom: 1 vulnerabilities (highest severity is: 7.5) |
| [#1945](#1945) | 0 | 0 | Fail task on unknown event when HistoryEvent.worker_may_ignore is false |
| [#1938](#1938) | 0 | 0 | `toProtoDuration` may throw an `ArithmeticException` if Duration is too large |
| [#1929](#1929) | 0 | 0 | [Feature Request] Tag workflow_task_execution_failed with error type |
| [#1928](#1928) | 0 | 0 | Flag signal after workflow complete as NonDeterminism |
| [#1920](#1920) | 0 | 0 | Support bind address for test server |
| [#1915](#1915) | 0 | 0 | Java SDK should verify it replays up to `StartedEventId` when processing a workflow task |
| [#1911](#1911) | 0 | 0 | com.google.api.grpc:proto-google-common-protos is not included in shaded SDK |
| [#1895](#1895) | 0 | 0 | Verify DataConverters apply SerializationContext consistently  |
| [#1893](#1893) | 0 | 0 | Identity not set on `Terminate` call |
| [#1890](#1890) | 0 | 0 | spring-boot-starter-2.7.12.jar: 9 vulnerabilities (highest severity is: 9.8) |
| [#1888](#1888) | 0 | 0 | kotlin-klib-commonizer-embeddable-1.5.32.jar: 1 vulnerabilities (highest severity is: 5.3) |
| [#1885](#1885) | 0 | 0 | Metric temporal_workflow_task_execution_failed is unexpectedly incremented on server-side task completion send failure |
| [#1880](#1880) | 0 | 0 | Speculative workflow task can cause WFT failure |
| [#1875](#1875) | 0 | 0 | TestWorkflowEnvironment Workflow.getTypedSearchAttributes |
| [#1872](#1872) | 0 | 0 | Enable TCP Keep alive by default |
| [#1870](#1870) | 0 | 0 | `UnableToAcquireLockException` exception causes slots to not get freed |
| [#1864](#1864) | 0 | 0 | Null pointer exception on creating schedule with `TriggerImmediately` and no `Policy` |
| [#1863](#1863) | 0 | 0 | Add start delay to start workflow options |
| [#1862](#1862) | 0 | 0 | Support build ID reachability API |
| [#1858](#1858) | 0 | 0 | Worker can get stuck only polling sticky queue |
| [#1856](#1856) | 0 | 0 | expose worker versioning via spring boot autoconfig |
| [#1854](#1854) | 0 | 0 | Fix WorkerOptions equals method |
| [#1847](#1847) | 0 | 0 | Typed search attributes aren't consistent with schedules |
| [#1839](#1839) | 0 | 0 | Add HealthIndicator to spring-boot library |
| [#1838](#1838) | 0 | 0 | Update sdk-name and sdk-version in task-level metadata if changed |
| [#1830](#1830) | 0 | 0 | WorkflowReplayer throws unclear exception when LocalActivityOptions are misconfigured |
| [#1825](#1825) | 0 | 0 | Support the certificate with linebreak strings from env variable |
| [#1820](#1820) | 0 | 0 | Exceptions thrown from ScheduleClient and ScheduleHandle should be wrapped in a TemporalException |
| [#1817](#1817) | 0 | 0 | RootScheduleClientInvoker.createSchedule swallows errors |
| [#1815](#1815) | 0 | 0 | SpringBoot - setting target to "local" does not register ServiceStubOptionsTemplate |
| [#1812](#1812) | 0 | 0 | Spring support for ScheduleClient |
| [#1808](#1808) | 0 | 0 | DataConverter interface does not provide a default implementation for `failureToException` and `exceptionToFailure` |
| [#1797](#1797) | 0 | 0 | Expose started time in activity info |
| [#1781](#1781) | 0 | 0 | Validate update protocol message type on replay |
| [#1770](#1770) | 0 | 0 | Timeouts should be detected locally during activity execution |
| [#1769](#1769) | 0 | 0 | [Test Server] Support speculative workflow tasks for Update |
| [#1767](#1767) | 0 | 0 | Log server-side task failure caused by invalid command in test server |
| [#1761](#1761) | 0 | 0 | Calling WorkflowLocal.set(null) results in the next call to WorkflowLocal.get() to throw a NullPointerException |
| [#1759](#1759) | 0 | 0 | Allow property placeholders in @ActivityImpl and @WorkflowImpl task queue name |
| [#1750](#1750) | 0 | 0 | Pass activity in init to ActivityInboundCallInterceptor |
| [#1748](#1748) | 0 | 0 | Run update validators in a limited workflow context |
| [#1745](#1745) | 0 | 0 | Support sync update request |
| [#1743](#1743) | 0 | 0 | Support Async Update Polling |
| [#1742](#1742) | 0 | 0 | Add support for workflow update to Test Server |
| [#1727](#1727) | 0 | 0 | inconsistency on MaximumAttempts attribute between local activities and "normal" activities |
| [#1712](#1712) | 0 | 0 | Test server not accessible |
| [#1711](#1711) | 0 | 0 | Start of child workflow from a cancelled workflow context needs test code coverage |
| [#1694](#1694) | 0 | 0 | Make Serialization Context available for PayloadCodecs and PayloadConverters |
| [#1692](#1692) | 0 | 0 | Implement workflow_start_delay in test server |
| [#1685](#1685) | 0 | 0 | Add API to count workflows |
| [#1682](#1682) | 0 | 0 | Add support for TerminateIfRunning WorkflowIdReusePolicy in Test Server |
| [#1672](#1672) | 0 | 0 | LongLocalActivityFailsWhileHeartbeatingMeteringTest flakes in codecoverage runs |
| [#1668](#1668) | 0 | 0 | Subsequent MutableSideEffect calls inside one Workflow Task may explode with non-determinism on replay |
| [#1655](#1655) | 0 | 0 | Utilize Signal requestId field for signal gRPC retries deduplication |
| [#1644](#1644) | 0 | 0 | ContextPropagator redesign |
| [#1642](#1642) | 0 | 0 | Add history pagination to Test Server |
| [#1639](#1639) | 0 | 0 | Workers with java-sdk 1.18.0 experience "required property congestionInitialInterval not set" |
| [#1634](#1634) | 0 | 0 | Add support for interceptor beans to Spring Boot |
| [#1621](#1621) | 0 | 0 | Allow setting *additional* memo values in ContinueAsNewOptions |
| [#1619](#1619) | 0 | 0 | Support for Spring Boot 3.0 in integration |
| [#1618](#1618) | 0 | 0 | Test server with child workflow and signal is timing out when attemping unlock-with-sleep |
| [#1615](#1615) | 0 | 0 | TemporalFailure thrown from Signal method should fail Workflow Execution  |
| [#1601](#1601) | 0 | 0 | Query on a stub used to start a workflow unexpectedly targets only the first run |
| [#1587](#1587) | 0 | 0 | Fix javadoc for ActivityExecutionContext.getHeartbeatDetails‚Äã and consider adding getLastHeartbeatDetails‚Äã |
| [#1586](#1586) | 0 | 0 | Opt-in to having stack trace query use custom data converter |
| [#1579](#1579) | 0 | 0 | [Feature Request] Improving replay issue for Timers |
| [#1563](#1563) | 0 | 0 | Local Activity Execution should stop making attempts if Workflow Task or subsequent heartbeat fails |
| [#1562](#1562) | 0 | 0 | Please return OriginalExecutionRunID in Workflow info |
| [#1561](#1561) | 0 | 0 | Unregistered Local Activity should fail Workflow Task |
| [#1553](#1553) | 0 | 0 | FailureConverter API |
| [#1549](#1549) | 0 | 0 | Metric scope for workflow instance should ignore metrics written after a destruction of the instance is requested |
| [#1538](#1538) | 0 | 0 | Test service continue-as-new implementation is not atomic |
| [#1535](#1535) | 0 | 0 | Improve diagnostic message printed by TestWorkflowRule on timeout. |
| [#1533](#1533) | 0 | 0 | Error in a local activity should fail the WorkflowTask instead of failing an activity execution |
| [#1532](#1532) | 0 | 0 | io.temporal.api is not included in the distributed javadoc.jar for temporal-serviceclient |
| [#1512](#1512) | 0 | 0 | Add scheduleToStart to LocalActivityOptions |
| [#1510](#1510) | 0 | 0 | Investigate and fix graceful shutdown problems  |
| [#1494](#1494) | 0 | 0 | Multi-history replay |
| [#1463](#1463) | 0 | 0 | Spring Boot - auto configured TestWorkflowEnvironment not registering data converter |
| [#1457](#1457) | 0 | 0 | State machine exception during termination |
| [#1456](#1456) | 0 | 0 | Pollers should use just one thread to perform async gRPC requests |
| [#1440](#1440) | 0 | 0 | Reflect activity vs local activity difference in tracing spans |
| [#1429](#1429) | 0 | 0 | Test server does not error on already-started child workflow |
| [#1427](#1427) | 0 | 0 | Test server heartbeat timeout issue |
| [#1425](#1425) | 0 | 0 | Test server not populating DescribeWorkflowExecutionResponse.workflow_execution_info.task_queue |
| [#1413](#1413) | 0 | 0 | Deduplicate getResultAsync calls inside WorkflowClient or WorkflowStub |
| [#1412](#1412) | 0 | 0 | Setting MetricsScope on TestEnvironmentOptions is confusing  |
| [#1408](#1408) | 0 | 0 | addWorkflowImplementationFactory with no ImplementationOptions fails workflow execution on any Throwable |
| [#1403](#1403) | 0 | 0 | Test Server should add warning logging if no workers listen on a task queue with tasks |
| [#1398](#1398) | 0 | 0 | Align Test Server behavior with the real one if WorkflowExecutionCompleted is not the last command |
| [#1396](#1396) | 0 | 0 | Set larger maxInboundMetadataSize to accommodate unbounded Server error messages |
| [#1377](#1377) | 0 | 0 | Predictable log statement when test server is ready for use |
| [#1370](#1370) | 0 | 0 | Add an ability to register custom DataConverter in Spring Boot Autoconfiguration |
| [#1354](#1354) | 0 | 0 | Unit Test for  ActivityCompletionClient methods that don't use taskToken |
| [#1350](#1350) | 0 | 0 | Wire #reason parameter in workflow cancellation request |
| [#1348](#1348) | 0 | 0 | Query to a workflow that was failed by the workflow code produces noisy Error log with not enough context |
| [#1345](#1345) | 0 | 0 | Data Converters should have method deserializing all the Payloads at once |
| [#1339](#1339) | 0 | 0 | Eager activity dispatch |
| [#1331](#1331) | 0 | 0 | Jacoco fails to produce report due to tests failing |
| [#1319](#1319) | 0 | 0 | TestServer erroneously propagates timeouts of the parent workflow to the child  |
| [#1318](#1318) | 0 | 0 | Cleanup and improve ApplicationFailure javadoc |
| [#1315](#1315) | 0 | 0 | Client and Workers shouldn't retry INTERNAL errors with newer versions of Server  |
| [#1312](#1312) | 0 | 0 | Call getSystemInfo before a first client call to obtain server capabilities |
| [#1301](#1301) | 0 | 0 | Implement an ability to disable deadlock detector for data converters performing IO |
| [#1288](#1288) | 0 | 0 | Test Server is unstable for child workflows reporting completion fast |
| [#1273](#1273) | 0 | 0 | provide an option to print trace-id and span-id on java-sdk  |
| [#1272](#1272) | 0 | 0 | Add toString method to ActivityInfo and WorkflowInfo |
| [#1266](#1266) | 0 | 0 | Add unit test covering scenario of Server outage during Worker sending workflow task execution result |
| [#1262](#1262) | 0 | 0 | Workflows stuck on local activity call |
| [#1261](#1261) | 0 | 0 | Local Activities fail and don't retry after reaching LocalRetryThreshold |
| [#1258](#1258) | 0 | 0 | Make activity heartbeats more robust to network outages by retrying them |
| [#1257](#1257) | 0 | 0 | Cached activity heartbeat prevents worker from a quick shutdown |
| [#1243](#1243) | 0 | 0 | getResultAsync with test environment leads to unbalanced time locking |
| [#1242](#1242) | 0 | 0 | Revisit history pagination  |
| [#1239](#1239) | 0 | 0 | getVersion call with a range that doesn't include DEFAULT_VERSION tolerates unversioned code |
| [#1238](#1238) | 0 | 0 | Improve Worker start logging with more diagnostic information |
| [#1237](#1237) | 0 | 0 | Workflow.getWorkflowExecution fails if stub created via Workflow.newExternalWorkflowStub  |
| [#1234](#1234) | 0 | 0 | Provide default implementation of Prometheus scrape endpoint |
| [#1233](#1233) | 0 | 0 | Javadocs for ActivityCompletionClient |
| [#1221](#1221) | 0 | 0 | Test Server does not populate `WorkflowExecutionStartedEventAttributes.FirstExecutionRunId` in the history. |
| [#1216](#1216) | 0 | 0 | Log activity thread stack trace if it times out or fails to heartbeat |
| [#1212](#1212) | 0 | 0 | Cancel long poll if a Future returned from getResultAsync is not referenced anymore by the user code |
| [#1208](#1208) | 0 | 0 | Remove verbose exceptions logging from GrpcRetryer |
| [#1206](#1206) | 0 | 0 | Implement immediate dispatch of new Workflow Task in a workflow task completion response |
| [#1205](#1205) | 0 | 0 | Test server throws a null pointer if query without a deadline |
| [#1198](#1198) | 0 | 0 | WorkflowStub#cancel and #terminate throw StatusRuntimeException instead of WorkflowNotFoundException |
| [#1197](#1197) | 0 | 0 | getResultAsync long poll request gets terminated by rpcTimeout |
| [#1194](#1194) | 0 | 0 | Start with signal does not add search attributes |
| [#1190](#1190) | 0 | 0 | Test Server Query for non-cached execution causes SDK state machines problem |
| [#1187](#1187) | 0 | 0 | LocalActivity completion advances workflow task timestamp to the current time instead of using an offset |
| [#1179](#1179) | 0 | 0 | workflow_active_thread_count metric should not be tagged with WORKFLOW_TYPE |
| [#1162](#1162) | 0 | 0 | Open Tracing interceptor logs failure for internal temporal errors |
| [#1153](#1153) | 0 | 0 | temporal-test-server pom seems incorrect |
| [#1146](#1146) | 0 | 0 | Code using WorkflowRunLockManager may release locks that are owned by other threads |
| [#1141](#1141) | 0 | 0 | Deadlock Detector unexpectedly firing on a cold JVM |
| [#1113](#1113) | 0 | 0 | Unbalance external workflow configuration? |
| [#1098](#1098) | 0 | 0 | Provide ActivityStub#fromTyped |
| [#1081](#1081) | 0 | 0 | Test flakes with Real Temporal Server leading to infinite activity retry |
| [#1079](#1079) | 0 | 0 | Issue with TestWorkflowEnvironment and ParentClosePolicy |
| [#1069](#1069) | 0 | 0 | TestWorkflowEnvironment schedules the first activity retry immediately |
| [#1066](#1066) | 0 | 0 | Deadlock Detector leads to workflow code getting "Operation allowed only while eventLoop is running" |
| [#1050](#1050) | 0 | 0 | Activity interface which extends an interface with some method using generic types always throws a ClassCastException when said method is called in a Workflow |
| [#1037](#1037) | 0 | 0 | Canceling of child workflow schedule command problem |
| [#1035](#1035) | 0 | 0 | Add metric for time passed from the activity scheduling to the last attempt |
| [#1033](#1033) | 0 | 0 | java-sdk 1.8.0 can't be used with maven |
| [#1019](#1019) | 0 | 0 | Log long poll failures (but not too frequently to avoid spamming) |
| [#1009](#1009) | 0 | 0 | Provide ActivityStub that is bound to the specific activityType or a specific invocation |
| [#1004](#1004) | 0 | 0 | Local Activity Worker ignores startToClose and scheduleToClose timeouts |
| [#998](#998) | 0 | 0 | Bring Pollers & Workers on par with Core and Go implementations |
| [#991](#991) | 0 | 0 | Add Jackson jdk8 support in JacksonJsonPayloadConverter |
| [#988](#988) | 0 | 0 | Make WorkflowServiceStubsOptions#rpcLongPollTimeout configurable |
| [#986](#986) | 0 | 0 | Add metrics for active executors threads |
| [#975](#975) | 0 | 0 | Provide WorkflowImplementationOptions.setLocalActivityOptions |
| [#964](#964) | 0 | 0 | Version ranges are lost during artifact publication |
| [#948](#948) | 0 | 0 | Local DynamicActivity has a regular activity context |
| [#925](#925) | 0 | 0 | SimpleSslContextBuilder works only with PKCS8 while all Temporal TSL examples and manuals are with PKCS12 |
| [#922](#922) | 0 | 0 | OpenTracing context is not propagated in some cases |
| [#912](#912) | 0 | 0 | startWithSignal exception with configured opentracing |
| [#906](#906) | 0 | 0 | Heartbeat throttling interval should be configurable and default interval should be greater than 0 |
| [#902](#902) | 0 | 0 | Exception in one of several "parallel" workflow async functions leads to non-deterministic execution |
| [#898](#898) | 0 | 0 | RetryOptions allows to be built with maximumInterval < minimumInterval and later fails on the server |
| [#888](#888) | 0 | 0 | Upgrade gRPC connections configuration and strategies to support round-robin resolving for frontends |
| [#887](#887) | 0 | 0 | Expose WorkflowInfo.getCronSchedule |
| [#882](#882) | 0 | 0 | Allow to register new search attributes |
| [#880](#880) | 0 | 0 | Legacy query path leads to thread leaks in case of state machine exceptions |
| [#871](#871) | 0 | 0 | Deadlock during activity state machine cancelation |
| [#864](#864) | 0 | 0 | Improve documentation for Signal Methods |
| [#862](#862) | 0 | 0 | Make tracing tags consistent across SDKs |
| [#860](#860) | 0 | 0 | Passing too large blob as an Activity input ends with non-descriptive gRPC error |
| [#857](#857) | 0 | 0 | Expose SignalExternalWorkflowExecutionCommandAttributes.ChildWorkflowOnly in SDK API |
| [#851](#851) | 0 | 0 | Allow more granular setting of QueryRejectCondition  |
| [#847](#847) | 0 | 0 | testCronWorkflowWithIncrementSchedule fails |
| [#844](#844) | 0 | 0 | OpenTracing doesn't work correctly with continueAsNew |
| [#836](#836) | 0 | 0 | WorkflowExecutionUtils fails reading history jsons produced by newer protocol versions |
| [#833](#833) | 0 | 0 | Cleanup and normalization of interfaces of *Option classes |
| [#832](#832) | 0 | 0 | NullPointer in RetryOptions#merge |
| [#830](#830) | 0 | 0 | testUntypedChildStubWorkflowAsyncInvoke flake with in-memory service |
| [#818](#818) | 0 | 0 | Automatically supply binaryChecksum |
| [#816](#816) | 0 | 0 | `Workflow.await(duration, condition)` doesn't work correctly with workflow cancelation |
| [#799](#799) | 0 | 0 | activity_endtoend_latency is a latency of one activity run instead of the whole sequence of retries |
| [#794](#794) | 0 | 0 | Report replay metrics |
| [#793](#793) | 0 | 0 | IdentityInPendingActivityTest#testPendingActivityHasIdentity flakes for both in-memory and dockerized server |
| [#765](#765) | 0 | 0 | Tests checking worker identity are failing with docker-compose Temporal server |
| [#759](#759) | 0 | 0 | Querying a completed workflow increments "temporal_workflow_completed_total" metrics counter |
| [#756](#756) | 0 | 0 | AbandonOnCancelActivityTest flake |
| [#753](#753) | 0 | 0 | Offer ActivityOptions via Supplier to support dynamic configs |
| [#748](#748) | 0 | 0 | Provide a way to inject options into Workflow instances |
| [#747](#747) | 0 | 0 | Support for unit testing of Workflows code |
| [#746](#746) | 0 | 0 | Reuse of ActivityStubs from another workflow should produce a usable diagnostic or be allowed |
| [#738](#738) | 0 | 0 | Non-conventional SNAPSHOT version, lack of support for versions with suffixes |
| [#732](#732) | 0 | 0 | Remove TestWorkflowRule#testTimeoutSeconds |
| [#731](#731) | 0 | 0 | Activities that return with interrupted flag should be successfully reported as Completed |
| [#726](#726) | 0 | 0 | SelfAdvancingTimerImplTest flakes when test machine is under load |
| [#721](#721) | 0 | 0 | CleanWorkerShutdownTest::testShutdownNow[Docker] |
| [#716](#716) | 0 | 0 | DynamicWorkflow does not handle ApplicationFailure.newNonRetryableFailure correclty |
| [#708](#708) | 0 | 0 | Regression on GrpcRetryer + GrpcDeadlineInterceptor |
| [#693](#693) | 0 | 0 | Flaky LocalActivitiesWorkflowTaskHeartbeatTest#testLocalActivitiesWorkflowTaskHeartbeat |
| [#677](#677) | 0 | 0 | Memo serialization implemented inconsistently |
| [#673](#673) | 0 | 0 | SearchAttributesTest fails against docker due to LocalDateTime serialization problem |
| [#672](#672) | 0 | 0 | [Flaky] LongLocalActivityWorkflowTaskHeartbeatFailureTest |
| [#666](#666) | 0 | 0 | GrpcRetryer could lose a real cause in case of DEADLINE_EXCEEDED |
| [#665](#665) | 0 | 0 | Allow users to specify or influence RpcRetryOptions for all kinds of GrpcRetries |
| [#663](#663) | 0 | 0 | Failing DefaultActivityOptionsSetOnWorkflowTest#testSetWorkflowImplementationOptions with Dockerized Temporal |
| [#661](#661) | 0 | 0 | Sync versions of GrpcRetryer should throw InterruptedException  |
| [#653](#653) | 0 | 0 | WorkflowExecutionUtils  and GrpcRetryer don't respect reaching deadline from GRPC context and downstream DEADLINE_EXCEEDED exceptions |
| [#651](#651) | 0 | 0 | Change the default behavior of retries in WorkflowExecutionUtils#getInstanceCloseEvent |
| [#648](#648) | 0 | 0 | Version StateMachine causes different in workflow task structure in replays breaking cancelations and leading to incorrect command-event matches |
| [#647](#647) | 0 | 0 | Make `ApplicationFailure#newFromValues` public |
| [#641](#641) | 0 | 0 | NPE during performance testing |
| [#634](#634) | 0 | 0 | Global timeout should be relocated from TestWorkflowRule to SDKTestWorkflowRule |
| [#632](#632) | 0 | 0 | Running in TEMPORAL_DEBUG mode should turn off TestWorkflowRule timeouts |
| [#625](#625) | 0 | 0 | Use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` for non-deterministic workflow |
| [#617](#617) | 0 | 0 | Deserialize Search Attributes |
| [#615](#615) | 0 | 0 | State Machine fails to handle correctly some corner cases of Workflow Versioning |
| [#612](#612) | 0 | 0 | JUnit's @test(timeout) annotation should override TestWorkflowRule settings |
| [#608](#608) | 0 | 0 | GRPC falling into in-process server long polls after interruption breaks graceful Worker Pollers shutdown |
| [#597](#597) | 0 | 0 | Support assertions in `TestWorkflowEnvironment.registerDelayedCallback` |
| [#591](#591) | 0 | 0 | Method overrides should be allowed when signal names are different |
| [#590](#590) | 0 | 0 | Worker identity is not recorded during heartbeat |
| [#577](#577) | 0 | 0 | TestEnv: using workflowExecutionTimeout with testEnv.sleep() makes the test hang |
| [#576](#576) | 0 | 0 | TestEnv: Failure signalling an *terminated* external workflow execution from another workflow |
| [#555](#555) | 0 | 0 | temporal_local_activity_failed never logged |
| [#551](#551) | 0 | 0 | ProtobufJsonPayloadConverter not using custom printer |
| [#521](#521) | 0 | 0 | Java SDK 1.0.8 is noisy on shutdown |
| [#512](#512) | 0 | 0 | Missing getMemo functionality in WorkflowInfo |
| [#474](#474) | 0 | 0 | Child workflows do not receive search attributes (or memo) |
| [#465](#465) | 0 | 0 | Allow passing proxy objects to registerActivitiesImplementations |
| [#456](#456) | 0 | 0 | Duplicate concurrent workflow - hangs on completion |
| [#455](#455) | 0 | 0 | Flaky test: testExceptionOnStart |
| [#432](#432) | 0 | 0 | MicrometerClientStatsReporter overrides registry's naming convention |
| [#392](#392) | 0 | 0 | TimeLockingFuture implementation is incorrect and easy to break  |
| [#370](#370) | 0 | 0 | Add per method activity options |
| [#325](#325) | 0 | 0 | Javadoc for WorkflowClient refers to wrong API |
| [#321](#321) | 0 | 0 | check-updates is deprecated |
| [#301](#301) | 0 | 0 | Worker.replayWorkflowExecution does not report replay failures |
| [#294](#294) | 0 | 0 | Support Workflow.getInfo from query method body |
| [#262](#262) | 0 | 0 | TestWorkflowEnvironment: Set close time on the visibility record |
| [#245](#245) | 0 | 0 | Support dynamic activity and workflow implementations |
| [#235](#235) | 0 | 0 | Make PollerOptions.uncaughtExceptionHandler from workflowOptions etc. |
| [#232](#232) | 0 | 0 | Support building with JDK 9 or later |
| [#227](#227) | 0 | 0 | Enable Serialization on WorkflowQueue  |
| [#193](#193) | 0 | 0 | Update all state machines to avoid self transitions and hidden logic |
| [#187](#187) | 0 | 0 | ClassCastException interfering with error propagation |
| [#174](#174) | 0 | 0 | Not specifying optional maxInterval in RetryOptions causes an cryptic exception if activity fails |
| [#171](#171) | 0 | 0 | Failing to mark Activity or Workflow interface as public is hard to diagnose |
| [#165](#165) | 0 | 0 | Regression with a workflow implementing an empty marker interface |
| [#155](#155) | 0 | 0 | Java SDK payload headers is out of sync with what go SDK / server uses |
| [#146](#146) | 0 | 0 | Block workflow instead of failing on unexpected exceptions |
| [#135](#135) | 0 | 0 | Include local activity input into its marker decision |
| [#98](#98) | 0 | 0 | NPE on null input when calling continue as new |
| [#80](#80) | 0 | 0 | Workflow versioning marker not respected on replay |
| [#55](#55) | 0 | 0 | Support @SignalMethod and @QueryMethod in independent interfaces |
| [#23](#23) | 0 | 0 | Change Activity.getTask to Activity.getInfo |
| [#19](#19) | 0 | 0 | Expose RPC timeout to the client code |
| [#15](#15) | 0 | 0 | Fix CancellationException stack trace |
| [#12](#12) | 0 | 0 | Remove InterruptedException from WorkflowQueue |
| [#7](#7) | 0 | 0 | Migrate Java Client from Thrift/TChannel to gRPC |
| [#6](#6) | 0 | 0 | Implement temporal gRPC code generation |
| [#5](#5) | 0 | 0 | Enable Buildkite for Java Client |
| [#4](#4) | 0 | 0 | Move code from com.uber.cadence to io.temporal packages |

---

## All Issues

Issues are sorted by priority score (upvotes √ó 2 + comments).

---

<a id="1448"></a>

### #1448: Support for virtual threads (project Loom)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1448 |
| **State** | CLOSED |
| **Author** | dano (Dan O'Reilly) |
| **Created** | 2022-09-20 16:07:19.000 UTC (3y 3m ago) |
| **Updated** | 2024-11-04 05:13:07.000 UTC |
| **Closed** | 2024-11-04 05:13:07.000 UTC |
| **Upvotes** | 25 |
| **Comments** | 1 |
| **Priority Score** | 51 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 25 üëÄ 5 |

#### Description

JDK 19 introduces a [preview version of Virtual Threads](https://openjdk.org/jeps/425) to Java. This enables applications to block a thread while waiting for some I/O to complete, without actually blocking any underlying OS thread. It seems like this would have big benefits for the Java SDK, since it currently does block OS threads while I/O is happening, and requires quite a bit of implementation complexity to evict those blocked threads from the cache, as well as carrying a performance penalty.

Are there plans to try to support this feature in the SDK? Obviously it is still a bit early, since the feature is just a preview right now, but it seems like it's worth looking into, given the potential benefits.

#### Comments (1)

<details>
<summary><strong>s-aliasgar</strong> commented on 2024-09-19 13:27:31.000 UTC</summary>

Now that Virtual Threads is a full-fledged feature in java https://openjdk.org/jeps/444
Can it please be adopted in Java-SDK

</details>


---

<a id="1845"></a>

### #1845: Support different coroutine models in workflows and activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1845 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-08-16 16:00:21.000 UTC (2y 4m ago) |
| **Updated** | 2025-12-28 18:33:03.000 UTC |
| **Upvotes** | 15 |
| **Comments** | 8 |
| **Priority Score** | 38 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 15 üëÄ 7 |

#### Description

**Describe the solution you'd like**

Need to several things:

* May need to slightly abstract workflow concurrency impl to support (but may not)
* Update Kotlin project to add support for Kotlin coroutines in workflows and activities as Kotlin `suspend fun` calls (may need to be opt-in in some way). There is an internal POC implementation from @mfateev we can leverage here.
* Create a new Java 21+ only "temporal-virtual-threads" project that uses virtual threads for workflow concurrency and runs activities in virtual threads (may need to be opt-in in some way)

This is kinda a big project, so some discussion should happen first. The above is just speculation about what to do.

#### Comments (8)

<details>
<summary><strong>rocketraman</strong> commented on 2023-11-17 17:50:36.000 UTC</summary>

As a Kotlin user who is getting started with Temporal, I would love to see this. Calls like `Workflow.sleep()` block a platform thread, which isn't scalable and is annoying in principle even where its not an actual scalability issue :-)

Kotlin coroutines, and more recently with the release of JDK 21 and Java virtual threads, are a perfect solution to this problem as they take up almost no resources while blocked on workflow sleep or activity calls.

I know nothing about the Java SDK internals, but looking at it from the outside in, the most basic abstraction of an async call is a callback. These are easy to bridge to suspending calls in Kotlin, and presumably to Java fibers. So if the SDK exposed async versions of its API that took a callback to resume the workflow execution, this would be easy to turn back into regular synchronous but non-blocking code via coroutines, and presumably fibers.

Issues which are probably duplicates or at least related to this one, based on the search I just did:
* https://github.com/temporalio/sdk-java/issues/1849
* https://github.com/temporalio/sdk-java/issues/778


Reactions: üëç 6

</details>

<details>
<summary><strong>pol-osei</strong> commented on 2025-06-17 19:03:18.000 UTC</summary>

Did anyone ever figure out a good way of doing this?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-17 19:12:58.000 UTC</summary>

The Temporal Java SDK already supports Java Virtual Threads, there are currently no active plans to support Kotlin coroutines at this time.

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2025-06-17 19:52:53.000 UTC</summary>

> The Temporal Java SDK already supports Java Virtual Threads

üëç 

> there are currently active plans to support Kotlin coroutines at this time.

@Quinn-With-Two-Ns The "at this time" makes this confusing. Did you mean "**no** active plans to support Kotlin coroutines at this time" here?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-17 20:07:30.000 UTC</summary>

Yes thank you, updated my comment

</details>

<details>
<summary><strong>smocherla-brex</strong> commented on 2025-12-08 14:48:31.000 UTC</summary>

I still think supporting coroutines as a first class async-primitive in the Temporal SDK would be a important/highly useful feature. The problem with using Temporal Java SDK in Kotlin is we have to bridge the workflow/activity context thread locals into a coroutine context for proper context propagation and cancellation when using it in Kotlin, and it makes it a lot more work for consumers of the SDK. It's not clear to me that using virtual threads in itself solves that problem.

Reactions: üëç 1

</details>

<details>
<summary><strong>alekseev-a-v</strong> commented on 2025-12-23 11:54:12.000 UTC</summary>

I would like to work on this (suspend fun support)

Reactions: üöÄ 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-28 18:33:03.000 UTC</summary>

@alekseev-a-v Thank you for the offer, but this is not something we are accepting contributions for at this time

</details>


---

<a id="1693"></a>

### #1693: Support listWorkflowExecutions in test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1693 |
| **State** | OPEN |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2023-03-09 01:14:15.000 UTC (2y 10m ago) |
| **Updated** | 2025-02-26 16:57:59.000 UTC |
| **Upvotes** | 16 |
| **Comments** | 5 |
| **Priority Score** | 37 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 16 |

#### Description

Test server only implements list open / closed, need support for this since all SDKs now have a high level API to list workflows that relies on this endpoint.

#### Comments (5)

<details>
<summary><strong>subhidh-agarwal</strong> commented on 2024-06-15 16:56:20.000 UTC</summary>

Hey anything yet?

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2024-10-29 22:34:19.000 UTC</summary>

According to [the forum post that pointed me to this issue](https://community.temporal.io/t/inability-to-list-workflow-executions-with-test-environment/7471/4) we can use the `ListOpenWorkflowExecutionsRequest` or `ListClosedWorkflowExecutionsRequest` endpoints instead. Is there a way to access these endpoints via the Java SDK?


</details>

<details>
<summary><strong>rocketraman</strong> commented on 2024-11-01 13:52:27.000 UTC</summary>

> According to [the forum post that pointed me to this issue](https://community.temporal.io/t/inability-to-list-workflow-executions-with-test-environment/7471/4) we can use the `ListOpenWorkflowExecutionsRequest` or `ListClosedWorkflowExecutionsRequest` endpoints instead. Is there a way to access these endpoints via the Java SDK?

This is the code I used:

```kotlin
  fun listOpenWorkflowExecutions(client: WorkflowClient, workflowTypeName: String): List<WorkflowExecutionInfo> {
    val stub = client.workflowServiceStubs.blockingStub()
    val request = ListOpenWorkflowExecutionsRequest.newBuilder()
      .setNamespace(client.options.namespace)
      .setTypeFilter(WorkflowTypeFilter.newBuilder().setName(workflowTypeName).build())
      .build()
    return stub.listOpenWorkflowExecutions(request).executionsList
  }
```

Reactions: üëç 1

</details>

<details>
<summary><strong>jakubbrzeski</strong> commented on 2025-02-26 15:33:28.000 UTC</summary>

Hi, are there any updates on this ? I need to query workflow executions with specific search attribute and then terminate and delete the execution. Test Environment doesn't support neither `workflowClient.getWorkflowServiceStubs().blockingStub().listWorkflowExecutions` nor `workflowClient.getWorkflowServiceStubs().blockingStub().listWorkflowExecutions`.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-26 16:57:58.000 UTC</summary>

Any update would be posted on this issue. This is a large amount of work to add because the test server currently has no support for querying search attribute.

</details>


---

<a id="587"></a>

### #587: Set TemporalChangeVersion when workflow version is updated

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/587 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2021-07-12 19:46:20.000 UTC (4y 6m ago) |
| **Updated** | 2025-05-28 22:47:40.000 UTC |
| **Closed** | 2025-05-28 22:47:40.000 UTC |
| **Upvotes** | 10 |
| **Comments** | 15 |
| **Priority Score** | 35 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | Next |
| **Reactions** | üëç 10 |

#### Description

**Is your feature request related to a problem? Please describe.**
This feature is implemented in Go SDK, not in Java.

**Describe the solution you'd like**
Set TemporalChangeVersion search attribute to the changeid-version when a new one is set on workflow.
This will allow users to use search queries, like shown here: https://community.temporal.io/t/list-of-running-workflows-having-a-specific-version/1731

**Describe alternatives you've considered**
Don't implement

This is a really needed feature when using workflow versioning. It works in Go SDK already.


#### Comments (15)

<details>
<summary><strong>vitarb</strong> commented on 2021-07-19 17:27:42.000 UTC</summary>

We need to do backwards compatibility for this one.

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2022-02-07 20:04:57.000 UTC</summary>

Hi any progress on this one? 

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2022-04-13 21:01:31.000 UTC</summary>

Hi any progress on this? I have added this in Cadence long time ago. You may copy some code from it which can make it easier: https://github.com/uber/cadence-java-client/pull/650

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-13 21:54:02.000 UTC</summary>

Not yet. It's a pretty tricky task to do because of the backward compatibility and the fact that the Version State Machine is one of the trickiest ones already. It's on my radar though and I will prioritize it when I get a chance.

Reactions: ‚ù§Ô∏è 3 üëÄ 4

</details>

<details>
<summary><strong>hmolinari-attentive</strong> commented on 2023-06-20 19:38:43.000 UTC</summary>

Hi, is there any update on this?

Reactions: üëç 1

</details>

<details>
<summary><strong>rrogers-turo</strong> commented on 2023-10-24 23:19:01.000 UTC</summary>

I'm also curious, I tried to query the TemporalChangeVersion and nothing showed up in the TemporalUI because I used the JavaSDK to do a patch on the workflow.

Reactions: üëç 1

</details>

<details>
<summary><strong>mnichols</strong> commented on 2024-10-08 02:22:15.000 UTC</summary>

@Quinn-With-Two-Ns is there an alternative workaround you might recommend to discover versions of WF so that users can more easily remove chunks of code with confidence?

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2024-10-08 02:24:11.000 UTC</summary>

> @Quinn-With-Two-Ns is there an alternative workaround you might recommend to discover versions of WF so that users can more easily remove chunks of code with confidence?

Try this design pattern https://medium.com/@qlong/how-to-overcome-some-maintenance-challenges-of-temporal-cadence-workflow-versioning-f893815dd18d

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-08 05:49:45.000 UTC</summary>

Also this sample https://github.com/temporalio/samples-java/pull/664

</details>

<details>
<summary><strong>mnichols</strong> commented on 2024-10-08 18:40:53.000 UTC</summary>

Thanks @longquanzheng and @Quinn-With-Two-Ns for the references! 

</details>

<details>
<summary><strong>luispollo</strong> commented on 2025-01-28 16:56:17.000 UTC</summary>

Hi there! This issue has been open for quite a long time. Any updates on prioritization?

Also, I wanted to call out that, at Netflix, we ran into a problem with a similar solution to the sample shared above when removing code paths for old versions, because the call to `Workflow.upsertTypedSearchAttributes` writes an event to the workflow history, so removing it is a backwards-incompatible (aka non-deterministic) workflow change. So if you have long-running workflows, even with continue-as-new, chances are you'll run into a `NonDeterministicException` when doing deployments (which we tend to do frequently), which then gets the workflows stuck.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-01-28 17:20:20.000 UTC</summary>

This issue is a high priority for us, but some bugs related to `GetVersion` needed to be resolved first. This is not a trivial feature to implement due to backward compatibility and the complexity around the versioning state machine. I hope to make some progress on this soon.

Reactions: üëç 2

</details>

<details>
<summary><strong>luispollo</strong> commented on 2025-01-29 05:19:18.000 UTC</summary>

Thanks for the update, @Quinn-With-Two-Ns. Glad to hear you're prioritizing improvements around this. Out of curiosity, can you please elaborate a bit on the backward compatibility and complexity if this is already supported in the Go SDK? I assume versioning is ultimately implemented at the low level of the protocol/server, so what's special about Java that makes it more difficult to expose the same feature there?

P.S. The original issue proposes a specific solution, which is to use search attributes. Personally, I don't care as much about the implementation detail, so long as there's a way for us to query for what workflows have what changes/versions enabled. For example, if there was a way to query the data that's already recorded in the workflow history as in the example below, that would be fine with me.

![Image](https://github.com/user-attachments/assets/196c0575-4c5a-4898-a44e-860f3f6b3c7a)

Looks like the version is recorded using the concept of a "marker" -- if there was a way to query for markers, we'd be set. üôÇ 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-01-29 19:35:55.000 UTC</summary>

>I assume versioning is ultimately implemented at the low level of the protocol/server...

No, versioning is implemented entirely in the SDK and the implementation in Go is very different then Java so there is no shared logic. Every SDK uses search attributes here so the Java SDK would as well

</details>

<details>
<summary><strong>luispollo</strong> commented on 2025-01-30 06:49:53.000 UTC</summary>

@Quinn-With-Two-Ns Thanks for the context.

</details>


---

<a id="8"></a>

### #8: Spring Boot Integration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/8 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-01-18 18:08:30.000 UTC (5y 11m ago) |
| **Updated** | 2025-05-05 21:45:41.000 UTC |
| **Closed** | 2022-08-23 23:36:25.000 UTC |
| **Upvotes** | 11 |
| **Comments** | 1 |
| **Priority Score** | 23 |
| **Labels** | epic |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.16.0 |
| **Reactions** | üëç 11 üëÄ 5 |

#### Description

## Tasks

- [x] #1305
- [x] #1363

## Bugs/Improvements

- [x] #1370
- [x] #1463
- [x] #1479
- [x] #1550
- [x] #1619
- [x] #1597  
- [x] #1394 
- [x] #1488 
- [x] #1449
- [x] #1634 
- [ ] #1647

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-23 23:36:25.000 UTC</summary>

Initial Spring Boot integration will be released in Temporal JavaSDK 1.16, additional functionality and configuration options will evolve from user feedback

</details>


---

<a id="2100"></a>

### #2100: Scheduled workflow retries do not work

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2100 |
| **State** | CLOSED |
| **Author** | mikita-charnukhin |
| **Created** | 2024-05-24 14:00:13.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-26 16:46:12.000 UTC |
| **Closed** | 2024-06-26 16:46:11.000 UTC |
| **Upvotes** | 8 |
| **Comments** | 6 |
| **Priority Score** | 22 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 8 ‚ù§Ô∏è 1 üöÄ 5 |

#### Description

## Issue description
I am trying to configure a retry policy for a scheduled workflow. By scheduled workflow I mean this feature: [Features - Java SDK feature guide | Temporal Documentation 1](https://docs.temporal.io/dev-guide/java/features#schedule-a-workflow) . Unfortunately it seems not working for me. I am expecting that when I add a `RetryOptions` object to the `Schedule` ‚Üí `ScheduleActionStartWorkflow` ‚Üí `WorkflowOptions` then retries will be working according to the provided configuration. I haven‚Äôt seen any notes about additional actions which might be required to enable retries for scheduled workflow executions. But maybe I am missing something..

## Notes

1. I am using Temporal v1.23.1.
2. Activity retries are working as expected for scheduled workflows.
3. When I fail the activity by throwing a `RuntimeException` then after activity retries exhausted the scheduled workflow execution fails without expected retries (following any configured retry policy).
4. I noticed that a retry policy which I set for a scheduled workflow is not visible for a workflow in the Temporal UI as usual (in Workflows ‚Üí choose Workflow ‚Üí Event History ‚Üí WorkflowExecutionStarted event ‚Üí Retry Policy).
5. The same `RetryOptions` works as expected if I use them to trigger a single workflow execution (without a schedule).
Example of a single workflow execution which I meant:
`workflowClient.newWorkflowStub(SomeWorkflow.class, workflowOptions).runSomeWorkflow(someInput);`
6. If I throw a RuntimeException not on the activity level but in the workflow implementation code then a scheduled workflow retries with a some weird retry policy (not following the rules which I set). For example: backoffCoefficient = 1.9; initialInterval = 5m; maxAttempts = 0; maxInterval = 3h. So I am expecting the following retry sequence: 5m ‚Üí 9.5m ‚Üí 18.05m ‚Üí 34.295m ‚Üí 65.1605 ‚Üí ‚Ä¶ ‚Üí 180m . But the actual retry sequence is: 0.037s ‚Üí 0.058s ‚Üí 10s ‚Üí 10s ‚Üí 14s ‚Üí 20s ‚Üí 27s ‚Üí 47s ‚Üí 78s.

## Code example
```
    final var retryOptions = RetryOptions.newBuilder()
        .setMaximumAttempts(0)
        .setInitialInterval(Duration.ofMinutes(5))
        .setBackoffCoefficient(1.9)
        .setMaximumInterval(Duration.ofHours(3))
        .build();
    final var workflowOptions = WorkflowOptions.newBuilder()
        .setRetryOptions(retryOptions)
        .setWorkflowId(workflowIdGenerator.getScheduledWorkflowId(scheduleId))
        .setTaskQueue(TASK_QUEUE_NAME)
        .build();
    final var scheduleAction = ScheduleActionStartWorkflow.newBuilder()
            .setWorkflowType(SomeWorkflow.class)
            .setArguments(input)
            .setOptions(workflowOptions)
            .build();
    final var schedulePolicy = SchedulePolicy.newBuilder().build();
    final var scheduleSpec = ScheduleSpec.newBuilder()
        .setTimeZoneName(timezone)
        .setCronExpressions(cronSchedule)
        .build();
    final var schedule = Schedule.newBuilder()
        .setAction(scheduleAction)
        .setPolicy(schedulePolicy)
        .setSpec(scheduleSpec)
        .build();
    final var scheduleOptions = ScheduleOptions.newBuilder().build();
    scheduleClient.createSchedule(scheduleId, schedule, scheduleOptions);
```

Is there any issue with scheduled workflows which breaks the retry mechanism?
Or maybe you can see an obvious mistake in my configuration..

Thank you in advance!

#### Comments (6)

<details>
<summary><strong>glebremniov</strong> commented on 2024-05-24 14:12:30.000 UTC</summary>

Yeah, upvoting this üëçüèª 

</details>

<details>
<summary><strong>aminmansour</strong> commented on 2024-05-24 14:24:31.000 UTC</summary>

Seems like a basic enough feature to have for schedules

</details>

<details>
<summary><strong>alexpetroaica</strong> commented on 2024-05-24 15:21:46.000 UTC</summary>

Also facing this, even the most basic example seems to completely ignore the retryOptions set on a workflow when it is part of a schedule

</details>

<details>
<summary><strong>dnr</strong> commented on 2024-06-07 16:55:21.000 UTC</summary>

I tried reproducing this with a schedule client in the Go SDK and retries worked correctly. There might be an issue with Java SDK.

</details>

<details>
<summary><strong>mikita-charnukhin</strong> commented on 2024-06-19 11:55:01.000 UTC</summary>

Hi @dnr 
Yes, as I mentioned in the issue description above the retries issue exists in Java SDK.
If you go to ScheduleClientImpl.createSchedule(...) -> ScheduleClientCallsInterceptor.createSchedule(...) -> RootScheduleClientInvoker.createSchedule(...) -> ScheduleProtoUtil.scheduleToProto(...) -> ScheduleProtoUtil.actionToProto(...) then you‚Äôll see that RetryOptions object is ignored when doing mapping of ScheduleAction object from the ‚Äútemporal-sdk-java‚Äù module to the ScheduleAction object from the ‚Äútemporal-serviceclient‚Äù module.
During that mapping ScheduleAction.action_.retryPolicy_ stays null (action_ is of type NewWorkflowExecutionInfo).
RetryOptions object which we pass to the Temporal client is being ignored. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-26 16:46:11.000 UTC</summary>

Resolved with https://github.com/temporalio/sdk-java/pull/2082 which is included in Java SDK `v1.24.0`

Reactions: üéâ 1

</details>


---

<a id="1407"></a>

### #1407: ARM64 build for Test Server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1407 |
| **State** | CLOSED |
| **Author** | dominik-pakosz (Dominik Pakosz) |
| **Created** | 2022-09-06 13:48:10.000 UTC (3y 4m ago) |
| **Updated** | 2025-06-06 19:22:31.000 UTC |
| **Closed** | 2025-04-21 15:53:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 22 |
| **Priority Score** | 22 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Test server running

## Actual Behavior
Exception: `qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory` thrown

## Steps to Reproduce the Problem

  1. download latest release binary
  2. run ./temporal-test-server
  3. no profit - seeing error

## Specifications

  - Version: latest - [v1.16.0](https://github.com/temporalio/sdk-java/releases/tag/v1.16.0)
  - Platform: MacOS ARM M1 Pro


#### Comments (22)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-06 14:43:21.000 UTC</summary>

We use Palantir Graal plugin for our native builds. Unfortunately, Palantir doesn't accept contributions or PRs to this project (they just get stale and closed) and doesn't actively develop it.
To fix this issue, this has to happen: https://github.com/palantir/gradle-graal/pull/469

An official Graal plugin for Gradle doesn't have this problem, but it doesn't provision GraalVM and native-image and requires them to be installed and configured in the system. This makes the usage tricky in an open-source project until https://github.com/graalvm/native-build-tools/issues/100 is resolved.
It looks like Gradle team is moving quite slow with an essential feature and dependency to make it happen: https://github.com/gradle/gradle/pull/18028

Temporal has to fork Palantir Graal Plugin, merge required fixes and publish to the Sonatype repo at some moment if this becomes a burning issue.

</details>

<details>
<summary><strong>cv65kr</strong> commented on 2022-09-06 20:05:43.000 UTC</summary>

@Spikhalskiy thanks for explanation. I think is quite important topic, a lot companies started exchanging old intel macbooks with new one with arm. I am using Temporal and for me is a big problem because now I need to use CI which tooks ages and don't have a control.

Proper testing is basic of good application.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-09-06 20:18:11.000 UTC</summary>

@cv65kr which download did you use?
Try this one: https://github.com/temporalio/sdk-java/releases/download/v1.16.0/temporal-test-server_1.16.0_macOS_amd64.tar.gz.
It's for Mac OS and should work with no additional steps, IIRC, with Rosetta.
Which SDK are you using? The TypeScript and Python SDKs both automatically install the right executable for you.

</details>

<details>
<summary><strong>cv65kr</strong> commented on 2022-09-06 20:31:37.000 UTC</summary>

The newest one for Temporal test server (In general I tried multiple versions). 

PHP SDK - https://github.com/temporalio/sdk-php/blob/master/testing/src/Downloader.php#L29 looks like is not working out of box

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-09-06 20:53:20.000 UTC</summary>

Hmm.. the code you sent LGTM at first glance, can you check which file it downloads?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-06 21:01:59.000 UTC</summary>

@cv65kr Could you download, unpack and try to run the specific artifact @bergundy pointed?
https://github.com/temporalio/sdk-java/releases/download/v1.16.0/temporal-test-server_1.16.0_macOS_amd64.tar.gz
This one is expected to work on M1. If it doesn't, let us know.

</details>

<details>
<summary><strong>dominik-pakosz</strong> commented on 2022-09-12 09:56:48.000 UTC</summary>

@Spikhalskiy I tried this artifact.
Result:
```
‚ùØ docker-compose exec container-apache /bin/sh
# ./temporal-test-server
/bin/sh: 2: ./temporal-test-server: Exec format error
# exit
```

```
‚ùØ docker-compose exec container-apache /bin/bash
root@a479b2380cc8:/src# ./temporal-test-server
bash: ./temporal-test-server: cannot execute binary file: Exec format error
root@a479b2380cc8:/src# exit
exit
```

Can you advise something more on that as it's not working as expected? ü§î 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-12 14:54:46.000 UTC</summary>

@bergundy Can you verify the same on your M1 Mac (https://github.com/temporalio/sdk-java/releases/download/v1.16.0/temporal-test-server_1.16.0_macOS_amd64.tar.gz)?
It works just fine for me on Intel Mac, so I would expect M1 to be fine too, but let's double-check.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-09-12 15:01:06.000 UTC</summary>

@dominik-pakosz you‚Äôre running in a docker container not directly on mac. We don‚Äôt yet have test server arm builds for linux 

</details>

<details>
<summary><strong>cv65kr</strong> commented on 2022-09-12 16:46:37.000 UTC</summary>

@bergundy is there any workaround for that? We are running tests inside arm dockers.
I can say that outside of docker working properly.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-09-12 17:12:58.000 UTC</summary>

You can run your containers with `--platform amd64` it slows things down but it works.
We want to support arm builds for both mac and linux, I hope we can get the done relatively soon.

</details>

<details>
<summary><strong>cv65kr</strong> commented on 2022-09-13 09:32:21.000 UTC</summary>

@bergundy is there any time frame when you expect releases?

</details>

<details>
<summary><strong>dominik-pakosz</strong> commented on 2022-09-13 09:35:14.000 UTC</summary>

Yea, I can't as I'm installing a lot of packages depending on arm64 or aarch64. From our SRE team point of view we should not go in this direction.
Is there any other solution?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-13 15:42:50.000 UTC</summary>

This issue is blocked by https://github.com/palantir/gradle-graal/pull/469 as an external dependency. Temporal doesn't typically provide time commitments for improvements.
We accept contributions and the Palantir Graal plugin we depend on to make it happen has an Apache license.

</details>

<details>
<summary><strong>otan</strong> commented on 2024-10-28 12:52:54.000 UTC</summary>

> This issue is blocked by https://github.com/palantir/gradle-graal/pull/469 as an external dependency. Temporal doesn't typically provide time commitments for improvements.

the palantir/gradle-graal repo is now deprecated. is there a plan to get this up and running?
running on ARM for CI is significantly cheaper and more prevalent nowadays.

</details>

<details>
<summary><strong>diogotorres97</strong> commented on 2025-02-24 14:40:22.000 UTC</summary>

Any updates on this one? We also want to run our CI in ARM servers üòÑ 

</details>

<details>
<summary><strong>purkhusid</strong> commented on 2025-03-11 17:37:28.000 UTC</summary>

This is quite painful since ARM has become such a common arch to run on developer laptops. Has there been any progress on this?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-11 19:35:39.000 UTC</summary>

This is on our roadmap, this issue will be closed once it is resolved

</details>

<details>
<summary><strong>weslien</strong> commented on 2025-03-12 09:17:30.000 UTC</summary>

Same here, spent a bucketload of time trying to get this to work on apple silicon. Problem is that I can't even force it to download the amd64 version when running inside a docker container with --platform override (at substantial performance degradation). 

My "solution" in the end was to monkey-patch the TS SDK to actually resolve arch to linux/amd64 and get that artifact from temporal.download ü´£

Looking forward to a proper solution

</details>

<details>
<summary><strong>diogotorres97</strong> commented on 2025-04-29 12:05:07.000 UTC</summary>

Do we have any ETA to get this released?

Reactions: üëç 1

</details>

<details>
<summary><strong>diogotorres97</strong> commented on 2025-06-06 14:18:43.000 UTC</summary>

@Quinn-With-Two-Ns ?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-06 19:22:30.000 UTC</summary>

@diogotorres97 It will be included in the next release, there is no ETA.

</details>


---

<a id="1804"></a>

### #1804: Add the possibility to run Temporal CLI server from test 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1804 |
| **State** | OPEN |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2023-06-30 10:23:35.000 UTC (2y 6m ago) |
| **Updated** | 2023-06-30 10:23:35.000 UTC |
| **Upvotes** | 10 |
| **Comments** | 0 |
| **Priority Score** | 20 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 10 |

#### Description

**Is your feature request related to a problem? Please describe.**

Other SDKs allows starting a full Temporal server locally for testing purpose.

Eg typescript: `TestWorkflowEnvironment.createLocal()`

I would like to have the same in Java, it will help to test features that are not implemented in test env, like listWorkflowExecution 


**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="1849"></a>

### #1849: Expose an async API to start a workflow which would allow mapping it to a Kotlin coroutine

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1849 |
| **State** | CLOSED |
| **Author** | raghukiran (Raghu) |
| **Created** | 2023-08-24 18:18:31.000 UTC (2y 4m ago) |
| **Updated** | 2025-09-09 19:36:16.000 UTC |
| **Closed** | 2025-09-09 19:36:16.000 UTC |
| **Upvotes** | 9 |
| **Comments** | 1 |
| **Priority Score** | 19 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 9 |

#### Description

**Is your feature request related to a problem? Please describe.**
https://community.temporal.io/t/kotlin-coroutines-to-start-workflows/9257

**Describe the solution you'd like**
To be able to start workflows from a Kotlin coroutine(using a dispatcher with a thread pool)
```kotlin
suspend fun callWorkflow() {
 withContext(Dispatchers.IO) {
          val workflow = workflowClient.newWorkflowStub(
            MyWorkflow::class.java,
            WorkflowOptions.newBuilder()
                .setWorkflowId(workflowId)
                .setTaskQueue(MyWorkflowFlow.QUEUE_NAME)
                .build()
        )
         workflow.myWorkflowMethod(request) // async method to start workflow that gets tied to a coroutine
     }
}
```

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2025-09-09 19:36:16.000 UTC</summary>

Closing in favor of https://github.com/temporalio/sdk-java/issues/1845

</details>


---

<a id="2738"></a>

### #2738: Spring Boot 4 Support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2738 |
| **State** | OPEN |
| **Author** | anatoliy-pylypchuk-kg (Anatoliy Pylypchuk) |
| **Created** | 2025-11-27 09:43:59.000 UTC (1 months ago) |
| **Updated** | 2025-12-09 23:15:35.000 UTC |
| **Upvotes** | 7 |
| **Comments** | 4 |
| **Priority Score** | 18 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 7 |

#### Description

**Is your feature request related to a problem? Please describe.**

Currently, Temporal SDK [supports Spring Boot 2 and 3](https://docs.temporal.io/develop/java/spring-boot-integration). Spring Boot 4 has [already come out](https://spring.io/blog/2025/11/20/spring-boot-4-0-0-available-now), so it would be great if Temporal SDK adds support for it as well.

**Describe the solution you'd like**

I haven't tested it, so maybe it already works as-is, but I'm almost sure some changes will be required to support Spring Boot 4 due to [its modularization](https://spring.io/blog/2025/10/28/modularizing-spring-boot).

**Describe alternatives you've considered**

Of course, it's possible to use a custom Spring Boot integration layer based on the core Temporal SDK which supports Spring Boot 4, but since it was released only a week ago, it doesn't make sense to rush and upgrade instantly, so we can wait.

**Additional context**

Since the open-source support of Spring Boot 2 ended in 2023, I think it would be reasonable to drop support for this version in Temporal SDK and only support the latest two versions of Spring Boot. Of course, it's up to you to decide, this is just a suggestion.

#### Comments (4)

<details>
<summary><strong>anatoliy-pylypchuk-kg</strong> commented on 2025-11-27 09:45:44.000 UTC</summary>

Also, while Spring Boot 4 supports Jackson 2, this support is deprecated, so in order to fully support Spring Boot 4, support for Jackson 3 will also be required.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-01 17:15:00.000 UTC</summary>

Yes Springboot 4 support is something we are interested in. Will require some investigation on what if any changes are needed and how we can maintain compatibility with previous versions. 

I am not aware of any Jackson 3 related issues.

Reactions: üëç 2

</details>

<details>
<summary><strong>GreyTeardrop</strong> commented on 2025-12-03 13:26:06.000 UTC</summary>

> I am not aware of any Jackson 3 related issues.

[Jackson 3](https://github.com/FasterXML/jackson/wiki/Jackson-Release-3.0) is an entirely incompatible major version - different artifact names, different packages, different exception hierarchies, etc. Supporting Jackson 3 would probably require new `Jackson3JsonPayloadConverter`. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-09 23:11:41.000 UTC</summary>

> Supporting Jackson 3 would probably require new Jackson3JsonPayloadConverter.

Yes agree there, but Jackson 3 support in the SDK is a separate issue from Spring Boot 4 support. tracked [here](https://github.com/temporalio/sdk-java/issues/2746)

Reactions: üëç 2

</details>


---

<a id="2665"></a>

### #2665: Serialization with `kotlinx.serialization`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2665 |
| **State** | CLOSED |
| **Author** | martin-ncs (Martin Scotta) |
| **Created** | 2025-09-23 01:20:19.000 UTC (3 months ago) |
| **Updated** | 2025-10-07 23:07:05.000 UTC |
| **Closed** | 2025-10-07 22:30:54.000 UTC |
| **Upvotes** | 6 |
| **Comments** | 6 |
| **Priority Score** | 18 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 6 |

#### Description


We have recently start using temporal in our mature and 100% Koltin stack.

We are seeing some serialization issues and we would like to request guidance.


**Problem**:

The existing `PayloadConverter` interface provides a method `Optional<Payload> toData(Object value)`, which fits well with libraries like Jackson/Gson.

However `kotlinx.serialization` works with compile-time information to resolve the correct strategy to encode values. In particular it uses `encodeToString(SerializationStrategy<T>, value: T): String` to encode.

This technical difference means that Kotlin relies on a-priori information, which the current `PayloadConverter` interface method does not provides, so there's a big impedance mismatch between these two worlds making it impossible to write a custom adapter between them.


**Impact**:

There are two problems when creating workflow/activities:

1. **very commonly serializable objects cannot be serialized**. This is simply kotlin unable to proceed due to missing information, like for instance trying to encode `List<Int>` but receiving an `ArrayList`. While these are problematic, developers can work around these by swapping these values for plain blob strings, and then manually deserializing from the other side.


2. **object are silently incorrectly serialized**. We believe this is because the `DataConverter` falls back into default Jackson behavior. This category is quite problematic as the workflows/activities have been already been created with invalid input data, the exception will happen during the deserialization phase, which temporal will attempt to retry only to face the same error again.


---

We'd like to hear if others have faced similar experiences, in particular those working with Kotlin stacks.

Any insights or workaround would be greatly appreciated. Thanks!

#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-23 23:47:55.000 UTC</summary>

>However kotlinx.serialization works with compile-time information to resolve the correct strategy to encode values. In particular it uses encodeToString(SerializationStrategy<T>, value: T): String to encode.

I don't think `kotlinx.serialization` isn't using any compile time information. You can pass a custom [SerializationStrategy](https://kotlinlang.org/api/kotlinx.serialization/kotlinx-serialization-core/kotlinx.serialization/-serialization-strategy/) which you can do in your data converter or you could call the overload that doesn't take a `SerializationStrategy` https://kotlinlang.org/api/kotlinx.serialization/kotlinx-serialization-json/kotlinx.serialization.json/-json/encode-to-string.html

>Like for instance trying to encode List<Int> but receiving an ArrayList

That seems like an issue with your custom `DataConverter`. More complex type can absolutely be support. The default data converter for example : https://github.com/temporalio/sdk-java/blob/5629f0c1603c561d552e5df6fd59218c329a342a/temporal-kotlin/src/test/kotlin/io/temporal/client/WorkflowClientExtTest.kt#L62 supports them fine so there is no reason in principle your custom data converter can't as well.

</details>

<details>
<summary><strong>martin-ncs</strong> commented on 2025-09-24 05:32:12.000 UTC</summary>

HI @Quinn-With-Two-Ns thanks for your reply.

It's true that kotlin uses `SerializationStrategy` interface, although that works under the hood.

The common approach is to use one of these two:

- `inline fun <reified T> encodeToString(value: T): String`: most commonly used, simply transforms a value into string

- `inline fun <reified T> serializer(): KSerializer<T>`: used in low-level scenarios, to get the strategy to serialize with

Both of these are using reified types, which are only available during compile-time; at runtime these values are never accessible.

Moreso, here's another key difference: in kotlin the serialized payload is not a function of the runtime object, instead it's **a function of the compile-time information**.

Consider the following example:

```kotlin

@Serializable
sealed interface Sealed {

    @Serializable
    data class Foo(
        val foo: String,
    ) : Sealed
}

val json = kotlinx.serialization.json.Json {
    classDiscriminator = "type"
}

val foo = Sealed.Foo("123")

// 1. encoding the object as [Sealed.Foo]
json.encodeToString<Sealed.Foo>(foo).also(::println) // prints {"foo":"123"}

// 2. encoding the same instance but now as a [Sealed]
json.encodeToString<Sealed>(foo).also(::println) // prints {"type":"Sealed.Foo","foo":"123"}
```

The same object will result in different payloads as kotlin relies on the type information available to encode/decode.

This is essentially what makes writing the adapter quite challenging. 

Just for reference here's one draft (read naive) implementation of how this adapter might look like:

```kotlin
internal class KotlinDataConverter(
    private val json: Json,
) : DataConverter {

    override fun <T> toPayload(value: T?): Optional<Payload> {

        if (value == null) return Optional.empty()

        val serializer = json.serializersModule.serializer(value::class.java) // <-- here's where we hit the wall

        val data = json.encodeToString(serializer, value)
            .toByteArray()
            .let(ByteString::copyFrom)

        return Payload.newBuilder()
            .setData(data)
            .build()
            .let(Optional<Payload>::of)
    }
```


**Is the type `T` known on both ends of the wire?** One possible solution might be to expose `valueType` and `valueGenericType` during serialization, similar to what `fromPayloads` does.

</details>

<details>
<summary><strong>martin-ncs</strong> commented on 2025-10-07 17:42:56.000 UTC</summary>

hello @Quinn-With-Two-Ns -- any update?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-07 22:24:45.000 UTC</summary>

Sorry I didn't realize you were waiting for an update. Not sure what update I can provide. My recommendation is still the same as above. The Temporal Java SDK is a Java library and cannot use Kotlin specific features like reified generics so obviously we don't have type information during serialization because of type erasure. If we ever build a Kotlin SDK then we would of course support them.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-07 22:30:54.000 UTC</summary>

I am going to close this issue since we don't like to use github issue for community discussion, in the future please use our [forum](https://community.temporal.io/) or [community slack ](https://temporal.io/community) Thanks!

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-07 23:07:04.000 UTC</summary>

We prefer to keep Github issues for bug reports and/or feature requests thanks for your understanding.

Reactions: üëç 1

</details>


---

<a id="623"></a>

### #623: Upsert memo support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/623 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-08-09 16:47:37.000 UTC (4y 5m ago) |
| **Updated** | 2024-09-05 14:45:16.000 UTC |
| **Closed** | 2024-09-05 14:45:16.000 UTC |
| **Upvotes** | 7 |
| **Comments** | 1 |
| **Priority Score** | 15 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 7 |

#### Description

Memo can be utilized by users as an "additional" workflow result that is not explicitly populated in the workflow result object.
Workflow Executions should have an ability to modify/upsert the memo during the execution, not just at the start time.
There is a `ModifyWorkflowPropertiesCommandAttributes` command in place for this already.

#### Comments (1)

<details>
<summary><strong>aleskovets</strong> commented on 2024-05-03 03:34:47.000 UTC</summary>

Sad that java sdk does not have it. Great feature to optimize number of requests with advanced visibility 

</details>


---

<a id="162"></a>

### #162: Exceptions being thrown on execution with Spring related to gRPC and PerfMark

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/162 |
| **State** | CLOSED |
| **Author** | fcruzel (Fran) |
| **Created** | 2020-07-30 06:10:34.000 UTC (5y 5m ago) |
| **Updated** | 2023-01-27 17:28:16.000 UTC |
| **Closed** | 2022-05-20 17:37:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 14 |
| **Priority Score** | 14 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Running Temporal with Spring generates some exceptions that are not thrown in a standalone Temporal instance.

```java
// App.java 

@ComponentScan
@EnableAutoConfiguration(exclude = {MetricFilterAutoConfiguration.class, MetricRepositoryAutoConfiguration.class})
@EnableConfigurationProperties({LiquibaseProperties.class, ApplicationProperties.class, JHipsterExtraProperties.class})
public class App {
  public static void main(String[] args) {
    SpringApplication app = new SpringApplication(App.class);

    // some calls here ...

    // Init Temporal
    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();
    WorkflowClient client = WorkflowClient.newInstance(service);
    WorkerFactory factory = WorkerFactory.newInstance(client);

    Worker worker = factory.newWorker("Queue1");
    worker.registerWorkflowImplementationTypes(HelloWorldImpl.class); // workflow calls the activity and returns the result
    worker.registerActivitiesImplementations(new SayHiActivityImpl()); // activity returns "Hello world"

    factory.start();

    HelloWorld workflow = client.newWorkflowStub(HelloWorld.class, WorkflowOptions.newBuilder().setTaskQueue("Queue1").build());

    System.out.println("Workflow result: " + workflow.sayHello()); // prints "Hello World"
  }
}
```

With this code, several exceptions are generated. However, they do not prevent the workflow and the activity from being correctly executed.

---

This next exceptions are thrown on line 84, which corresponds to the line `WorkflowServiceStubs service = WorkflowServiceStubs.newInstance()`;

```stacktrace
2020-07-27 09:43:17.509 [main] DEBUG
        i.g.netty.shaded.io.grpc.netty.Utils - Epoll is not available, using Nio. 
java.lang.ExceptionInInitializerError: null
	at io.grpc.netty.shaded.io.netty.channel.epoll.Epoll.<clinit>(Epoll.java:39)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at io.grpc.netty.shaded.io.grpc.netty.Utils.isEpollAvailable(Utils.java:284)
	at io.grpc.netty.shaded.io.grpc.netty.Utils.<clinit>(Utils.java:107)
	at io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder.<clinit>(NettyChannelBuilder.java:74)
	at io.temporal.internal.grpc.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:108)
	at io.temporal.serviceclient.WorkflowServiceStubs.newInstance(WorkflowServiceStubs.java:34)
	at my.App.main(App.java:84)
Caused by: java.lang.IllegalStateException: Only supported on Linux
	at io.grpc.netty.shaded.io.netty.channel.epoll.Native.loadNativeLibrary(Native.java:225)
	at io.grpc.netty.shaded.io.netty.channel.epoll.Native.<clinit>(Native.java:58)
	... 9 common frames omitted
```

```stacktrace
2020-07-27 09:43:17.603 [main] DEBUG
        i.g.i.AbstractManagedChannelImplBuilder - Unable to apply census stats 
java.lang.ClassNotFoundException: io.grpc.census.InternalCensusStatsAccessor
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at io.grpc.internal.AbstractManagedChannelImplBuilder.getEffectiveInterceptors(AbstractManagedChannelImplBuilder.java:534)
	at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:517)
	at io.temporal.internal.grpc.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:119)
	at io.temporal.serviceclient.WorkflowServiceStubs.newInstance(WorkflowServiceStubs.java:34)
	at my.App.main(App.java:84)
2020-07-27 09:43:17.603 [main] DEBUG
        i.g.i.AbstractManagedChannelImplBuilder - Unable to apply census stats 
java.lang.ClassNotFoundException: io.grpc.census.InternalCensusTracingAccessor
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at io.grpc.internal.AbstractManagedChannelImplBuilder.getEffectiveInterceptors(AbstractManagedChannelImplBuilder.java:569)
	at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:517)
	at io.temporal.internal.grpc.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:119)
	at io.temporal.serviceclient.WorkflowServiceStubs.newInstance(WorkflowServiceStubs.java:34)
	at my.App.main(App.java:84)
```

---

And this one is thrown after client.newWorkflowStub is called.

```stacktrace
2020-07-27 09:43:17.992 [Activity Poller taskQueue="Queue1", namespace="default": 3] DEBUG
        io.perfmark.PerfMark - Error during PerfMark.<clinit> 
java.lang.ClassNotFoundException: io.perfmark.impl.SecretPerfMarkImpl$PerfMarkImpl
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at io.perfmark.PerfMark.<clinit>(PerfMark.java:36)
	at io.grpc.internal.ClientCallImpl.<init>(ClientCallImpl.java:109)
	at io.grpc.internal.ManagedChannelImpl$RealChannel.newCall(ManagedChannelImpl.java:890)
	at io.grpc.internal.ServiceConfigInterceptor.interceptCall(ServiceConfigInterceptor.java:137)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.grpc.internal.ManagedChannelImpl.newCall(ManagedChannelImpl.java:855)
	at io.grpc.internal.ForwardingManagedChannel.newCall(ForwardingManagedChannel.java:63)
	at io.temporal.internal.grpc.GrpcMetricsInterceptor$MetricsClientCall.<init>(GrpcMetricsInterceptor.java:88)
	at io.temporal.internal.grpc.GrpcMetricsInterceptor.interceptCall(GrpcMetricsInterceptor.java:74)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.temporal.internal.grpc.GrpcDeadlineInterceptor.interceptCall(GrpcDeadlineInterceptor.java:69)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.grpc.stub.MetadataUtils$HeaderAttachingClientInterceptor.interceptCall(MetadataUtils.java:74)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:128)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2682)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:95)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:38)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:273)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
```

```
2020-07-27 09:43:18.009 [Activity Poller taskQueue="Queue1", namespace="default": 3] DEBUG
        io.grpc.Context - Storage override doesn't exist. Using default 
java.lang.ClassNotFoundException: io.grpc.override.ContextStorageOverride
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at io.grpc.Context$LazyStorage.createStorage(Context.java:142)
	at io.grpc.Context$LazyStorage.<clinit>(Context.java:131)
	at io.grpc.Context.storage(Context.java:119)
	at io.grpc.Context.current(Context.java:185)
	at io.grpc.internal.ClientCallImpl.<init>(ClientCallImpl.java:118)
	at io.grpc.internal.ManagedChannelImpl$RealChannel.newCall(ManagedChannelImpl.java:890)
	at io.grpc.internal.ServiceConfigInterceptor.interceptCall(ServiceConfigInterceptor.java:137)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.grpc.internal.ManagedChannelImpl.newCall(ManagedChannelImpl.java:855)
	at io.grpc.internal.ForwardingManagedChannel.newCall(ForwardingManagedChannel.java:63)
	at io.temporal.internal.grpc.GrpcMetricsInterceptor$MetricsClientCall.<init>(GrpcMetricsInterceptor.java:88)
	at io.temporal.internal.grpc.GrpcMetricsInterceptor.interceptCall(GrpcMetricsInterceptor.java:74)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.temporal.internal.grpc.GrpcDeadlineInterceptor.interceptCall(GrpcDeadlineInterceptor.java:69)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.grpc.stub.MetadataUtils$HeaderAttachingClientInterceptor.interceptCall(MetadataUtils.java:74)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:128)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2682)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:95)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:38)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:273)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
```

---

## Expected Behavior

Exceptions should not be thrown.

## Actual Behavior

Exceptions are thrown for no apparent reason, since the same code in a standalone Temporal application doesn't throw any exceptions.

## Steps to Reproduce the Problem

  1. Use Temporal with a Spring app.
  1. Register a workflow.
  1. Execute it.

## Specifications

  - Version: v0.2.7
  - Platform: Windows 10


#### Comments (14)

<details>
<summary><strong>kkcmadhu</strong> commented on 2020-08-27 05:25:58.000 UTC</summary>

Ok, my understanding was ideally  this should not clash, cause library conflicts etc https://temporalio.slack.com/archives/CTT84KXK9/p1591634665191200

could this be the jhipster or @metricautoconfig related?
i dont see these in my spring boot apps, but i don't use the metric or jhipster related annotations as well..

my set of annotation presently are @SpringBootApplication,@EnableTransactionManagement,@EnableJpaRepositories,@EntityScan,@EnableCaching

</details>

<details>
<summary><strong>ponson-thankavel-finastra</strong> commented on 2021-04-07 04:07:51.000 UTC</summary>

I am facing exactly the same problem. @fcruzel, were you able to resolve this problem?

</details>

<details>
<summary><strong>fcruzel</strong> commented on 2021-04-07 06:17:10.000 UTC</summary>

@ponson-thankavel-finastra I stopped working on this and couldn't investigate further down

</details>

<details>
<summary><strong>J-DK</strong> commented on 2022-05-20 17:26:41.000 UTC</summary>

Is there any update on this?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-20 17:34:18.000 UTC</summary>

@J-DK Do you experience this issue?
This issue is stale, doesn't have a reproduction, and looks like a misconfigured classpath and logger.


Temporal obviously has nothing to do with `ClassNotFoundException`, especially from classes Temporal doesn't need and use like `java.lang.ClassNotFoundException: io.perfmark.impl.SecretPerfMarkImpl$PerfMarkImpl`
Users need to make sure the right classes are available in the classpath.

```
2020-07-27 09:43:17.509 [main] DEBUG
        i.g.netty.shaded.io.grpc.netty.Utils - Epoll is not available, using Nio. 
java.lang.ExceptionInInitializerError: null
	at io.grpc.netty.shaded.io.netty.channel.epoll.Epoll.<clinit>(Epoll.java:39)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at io.grpc.netty.shaded.io.grpc.netty.Utils.isEpollAvailable(Utils.java:284)
	at io.grpc.netty.shaded.io.grpc.netty.Utils.<clinit>(Utils.java:107)
	at io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder.<clinit>(NettyChannelBuilder.java:74)
	at io.temporal.internal.grpc.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:108)
	at io.temporal.serviceclient.WorkflowServiceStubs.newInstance(WorkflowServiceStubs.java:34)
	at my.App.main(App.java:84)
Caused by: java.lang.IllegalStateException: Only supported on Linux
	at io.grpc.netty.shaded.io.netty.channel.epoll.Native.loadNativeLibrary(Native.java:225)
	at io.grpc.netty.shaded.io.netty.channel.epoll.Native.<clinit>(Native.java:58)
	... 9 common frames omitted
```

This is not even a problem, it's gRPC logging an internal exception and diagnostic information with DEBUG level. Just configure the logger if you don't want to see it.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-20 17:37:49.000 UTC</summary>

I'm going to close this issue, it's not actionable and it looks like not a temporal sdk issue, but user side configuration issue. 
@J-DK if you experience the issue, feel free to submit a new one and we can investigate there.

</details>

<details>
<summary><strong>J-DK</strong> commented on 2022-05-20 18:25:23.000 UTC</summary>



```
i.g.stub.ClientCalls$ThreadlessExecutor : Runnable threw exception
java.lang.NoClassDefFoundError: io/perfmark/PerfMark
at io.grpc.internal.ClientCallImpl.<init>(ClientCallImpl.java:106) ~[grpc-core-1.43.0.jar:1.43.0]
```



I faced the above issue and it is fixed by explicitly adding the below dependency in the build file 
`implementation 'io.perfmark:perfmark-api:0.25.0' `

Reactions: üëç 2

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-20 18:33:34.000 UTC</summary>

@J-DK It looks like the correct thing to do here. Temporal JavaSDK doesn't use or need perfmark itself, so we are not going to add it as a transitive dependency.

Reactions: üëç 1

</details>

<details>
<summary><strong>CharlieReitzel</strong> commented on 2022-11-17 19:31:56.000 UTC</summary>

My application stops at `factory.start()` because the `java.lang.ClassNotFoundException: io.grpc.override.ContextStorageOverride` exception is thrown.  I'll try to pull in the jar as a direct dependency, but this appears to be a transitive dependency of Temporal that is missing.

The comment in WorkerFactory.java, lines 216-218, looks relevant:
```
    // Workers check and require that Temporal Server is available during start to fail-fast in case
    // of configuration issues.
    workflowClient.getWorkflowServiceStubs().connect(null);
```
I am connecting to a remote Temporal instance attempting use a mix of 1 local workflow and some remote activities.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-17 19:38:52.000 UTC</summary>

@CharlieReitzel Temporal SDK doesn't use `ContextStorageOverride` or any classes from "io.grpc.override". So, Temporal will not be providing them.
The only place across all our transitive dependencies that uses this class is this one method in `io.grpc.Context` from io.grpc:grpc-context and it doesn't throw if the class is not available:

```
    private static Storage createStorage(
        AtomicReference<? super ClassNotFoundException> deferredStorageFailure) {
      try {
        Class<?> clazz = Class.forName("io.grpc.override.ContextStorageOverride");
        // The override's constructor is prohibited from triggering any code that can loop back to
        // Context
        return clazz.asSubclass(Storage.class).getConstructor().newInstance();
      } catch (ClassNotFoundException e) {
        deferredStorageFailure.set(e);
        return new ThreadLocalContextStorage();
      } catch (Exception e) {
        throw new RuntimeException("Storage override failed to initialize", e);
      }
    }
```

it just logs it later:


```
      storage = createStorage(deferredStorageFailure);
      Throwable failure = deferredStorageFailure.get();
      // Logging must happen after storage has been set, as loggers may use Context.
      if (failure != null) {
        log.log(Level.FINE, "Storage override doesn't exist. Using default", failure);
      }
```

Please post the full exception you are getting.

</details>

<details>
<summary><strong>Nishant-Pathak</strong> commented on 2023-01-27 07:19:21.000 UTC</summary>

Hitting the same issue, not sure if this is Closed in the right way.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-27 10:36:00.000 UTC</summary>

It's Closed as unrelated to Temporal and something that can't and will not be addressed in Java SDK as I provided more context above.
JavaSDK doesn't use `io.grpc.override.ContextStorageOverride` or any other classes from `io.grpc.override.*`. If your application needs this class for any reason, it's the responsibility of your application to make sure this class is present in a classpath.

I also don't see how this exception

```
java.lang.ClassNotFoundException: io.grpc.override.ContextStorageOverride
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at io.grpc.Context$LazyStorage.createStorage(Context.java:142)
	at io.grpc.Context$LazyStorage.<clinit>(Context.java:131)
	at io.grpc.Context.storage(Context.java:119)
	at io.grpc.Context.current(Context.java:185)
	at io.grpc.internal.ClientCallImpl.<init>(ClientCallImpl.java:118)
	at io.grpc.internal.ManagedChannelImpl$RealChannel.newCall(ManagedChannelImpl.java:890)
	at io.grpc.internal.ServiceConfigInterceptor.interceptCall(ServiceConfigInterceptor.java:137)
	at io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at io.grpc.internal.ManagedChannelImpl.newCall(ManagedChannelImpl.java:855)
	at io.grpc.internal.ForwardingManagedChannel.newCall(ForwardingManagedChannel.java:63)
```

is possible on any modern grpc version, because `ClassNotFoundException` from the unavailability of `io.grpc.override.ContextStorageOverride` is getting gracefully handled in grpc-java: https://github.com/grpc/grpc-java/blob/master/context/src/main/java/io/grpc/Context.java#L134

I may be able to help if you submit a reproduction. Otherwise, it's not a java-sdk issue and it doesn't reproduce with the dependencies java-sdk currently uses.

</details>

<details>
<summary><strong>Nishant-Pathak</strong> commented on 2023-01-27 16:11:43.000 UTC</summary>

Sure, here are my setup details

Java version
```
‚ûú  test git:(prod) java --version
openjdk 17.0.5 2022-10-18
OpenJDK Runtime Environment (build 17.0.5+8-Ubuntu-2ubuntu122.04)
OpenJDK 64-Bit Server VM (build 17.0.5+8-Ubuntu-2ubuntu122.04, mixed mode, sharing)
```
`Spring boot` Running Spring Boot 2.7.3

Temporal `'io.temporal:temporal-sdk:1.17.0'`

Do let me know if you need more info to reproduce. Else I am happy to jump over call and show the issue.


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-27 17:22:01.000 UTC</summary>

This setup (Java 17, Spring Boot 2.7.3) works just fine and it's one of the configurations we routinely test as a part of our CI. This is not enough information for me to reproduce. Because the problem is with your application, your specific dependencies graph or classpath, not with JavaSDK.
If you need help with your application, I can take a peek. But I need a minimal reproduction: source code that I can run that fails with the same error that you observe. Only then I can tell you what's up with that reproduction and probably your application.

You can also try to post a runtime dependency tree of your project and the specific exception you observe. That may show something.

</details>


---

<a id="295"></a>

### #295: Native image descriptor for GraalVM

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/295 |
| **State** | CLOSED |
| **Author** | mostafacs (Mostafa) |
| **Created** | 2021-01-08 03:00:53.000 UTC (5 years ago) |
| **Updated** | 2023-03-10 17:49:19.000 UTC |
| **Closed** | 2023-02-21 15:54:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 13 |
| **Priority Score** | 13 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ‚ù§Ô∏è 1 |

#### Description

Last two months I learned temporal and changed my background jobs to use temporal and it so slink and fast and fix many issues for me because of the long-running workflows. 

GraalVm native image has many features like reduce memory and the start time of apps. 

Is it possible to support native image build?



#### Comments (13)

<details>
<summary><strong>averri</strong> commented on 2023-02-17 20:09:42.000 UTC</summary>

Is this completed? I didn't find any Java SDK to use with native GraalVm.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-17 20:15:43.000 UTC</summary>

@averri No, it's not. 

We actually do have native-image descriptors for the test server here: 
https://github.com/temporalio/sdk-java/tree/15df866f9c91219f6cf61533aee8fc2139ad7c93/temporal-test-server/src/main/resources/META-INF/native-image/io.temporal/temporal-test-server
Our test server depends on java-sdk and uses some pieces of it. But I don't know if they are enough or not for a full java-sdk. They may be, but they are likely not.
If you work with Graal and want to embed java-sdk in the native image, these descriptors may be a great start. Also if you develop your own java-sdk descriptors and wish to upstream them, we will be happy to accept this contribution.

</details>

<details>
<summary><strong>averri</strong> commented on 2023-02-17 20:19:32.000 UTC</summary>

Hi @Spikhalskiy, thanks for informing that.

These are the issues related to using the Java SDK when building native images on Graalvm, happen at build time:

```
Error: Classes that should be initialized at run time got initialized during image building:
 io.grpc.netty.shaded.io.netty.buffer.UnpooledDirectByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.UnpooledDirectByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.UnpooledDirectByteBuf
io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeDirectByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeDirectByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeDirectByteBuf
io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator the class was requested to be initialized at run time (from 'META-INF/native-image/io.grpc.netty.shaded.io.netty/buffer/native-image.properties' in 'file:///home/app/libs/grpc-netty-shaded-1.53.0.jar' with 'io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator'). To see why io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator
io.grpc.netty.shaded.io.netty.util.AbstractReferenceCounted the class was requested to be initialized at run time (from 'META-INF/native-image/io.grpc.netty.shaded.io.netty/common/native-image.properties' in 'file:///home/app/libs/grpc-netty-shaded-1.53.0.jar' with 'io.grpc.netty.shaded.io.netty.util.AbstractReferenceCounted'). To see why io.grpc.netty.shaded.io.netty.util.AbstractReferenceCounted got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.util.AbstractReferenceCounted
io.grpc.netty.shaded.io.netty.buffer.ByteBufAllocator the class was requested to be initialized at run time (from 'META-INF/native-image/io.grpc.netty.shaded.io.netty/buffer/native-image.properties' in 'file:///home/app/libs/grpc-netty-shaded-1.53.0.jar' with 'io.grpc.netty.shaded.io.netty.buffer.ByteBufAllocator'). To see why io.grpc.netty.shaded.io.netty.buffer.ByteBufAllocator got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.ByteBufAllocator
io.grpc.netty.shaded.io.netty.buffer.PooledByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.PooledByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.PooledByteBuf
io.grpc.netty.shaded.io.netty.buffer.UnpooledHeapByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.UnpooledHeapByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.UnpooledHeapByteBuf
io.grpc.netty.shaded.io.netty.handler.ssl.PemPrivateKey the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.util.AbstractReferenceCounted). To see why io.grpc.netty.shaded.io.netty.handler.ssl.PemPrivateKey got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.handler.ssl.PemPrivateKey
io.grpc.netty.shaded.io.netty.handler.ssl.PemValue the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.util.AbstractReferenceCounted). To see why io.grpc.netty.shaded.io.netty.handler.ssl.PemValue got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.handler.ssl.PemValue
io.grpc.netty.shaded.io.netty.buffer.PooledSlicedByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.PooledSlicedByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.PooledSlicedByteBuf
io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf the class was requested to be initialized at run time (from 'META-INF/native-image/io.grpc.netty.shaded.io.netty/buffer/native-image.properties' in 'file:///home/app/libs/grpc-netty-shaded-1.53.0.jar' with 'io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf'). To see why io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf
io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil the class was requested to be initialized at run time (from 'META-INF/native-image/io.grpc.netty.shaded.io.netty/buffer/native-image.properties' in 'file:///home/app/libs/grpc-netty-shaded-1.53.0.jar' with 'io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil'). To see why io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil
io.grpc.netty.shaded.io.netty.buffer.UnpooledUnsafeDirectByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.UnpooledUnsafeDirectByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.UnpooledUnsafeDirectByteBuf
io.grpc.netty.shaded.io.netty.buffer.PooledUnsafeDirectByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.PooledUnsafeDirectByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.PooledUnsafeDirectByteBuf
io.grpc.netty.shaded.io.netty.buffer.AbstractPooledDerivedByteBuf the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf). To see why io.grpc.netty.shaded.io.netty.buffer.AbstractPooledDerivedByteBuf got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.AbstractPooledDerivedByteBuf
To see how the classes got initialized, use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.UnpooledDirectByteBuf,io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeDirectByteBuf,io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator,io.grpc.netty.shaded.io.netty.util.AbstractReferenceCounted,io.grpc.netty.shaded.io.netty.buffer.ByteBufAllocator,io.grpc.netty.shaded.io.netty.buffer.PooledByteBuf,io.grpc.netty.shaded.io.netty.buffer.UnpooledHeapByteBuf,io.grpc.netty.shaded.io.netty.handler.ssl.PemPrivateKey,io.grpc.netty.shaded.io.netty.handler.ssl.PemValue,io.grpc.netty.shaded.io.netty.buffer.PooledSlicedByteBuf,io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf,io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil,io.grpc.netty.shaded.io.netty.buffer.UnpooledUnsafeDirectByteBuf,io.grpc.netty.shaded.io.netty.buffer.PooledUnsafeDirectByteBuf,io.grpc.netty.shaded.io.netty.buffer.AbstractPooledDerivedByteBuf
Error: Use -H:+ReportExceptionStackTraces to print stacktrace of underlying exception
``` 

All of them are related to the `io.grpc.netty.shaded` package. 

I have read some of the native descriptors you mentioned above, it seems they try to fix the errors I mentioned. I'll try later and update here.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-17 20:25:31.000 UTC</summary>

@averri 
This specific issue is most likely resolved in the test server descriptors I referenced earlier:
https://github.com/temporalio/sdk-java/blob/cd33a808caa16f94838697e27991de7ef3577ec0/temporal-test-server/src/main/resources/META-INF/native-image/io.temporal/temporal-test-server/native-image.properties#L23

Take what we already have as a starting point. I don't promise it will resolve all the issues, but it will bring you closer to the result.

Also, this Readme segment may be of use to you https://github.com/temporalio/sdk-java/blob/fd701f8903000c57feafb5db0d26487ce6e2681e/temporal-test-server/README.md#graalvm-native-image-configuration if you just start with native-image. 
I believe their documentation wasn't too vocal about this approach and it saves a lot of time.

Reactions: ‚ù§Ô∏è 1

</details>

<details>
<summary><strong>averri</strong> commented on 2023-02-17 20:51:30.000 UTC</summary>

@Spikhalskiy, I have tested the descriptors, it has resolved all of the issues, except one:

```
Error: Classes that should be initialized at run time got initialized during image building:
 io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder the class was requested to be initialized at run time (from 'META-INF/native-image/io.grpc/grpc-netty-shaded/native-image.properties' in 'file:///home/app/resources/' with 'io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder'). To see why io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder
To see how the classes got initialized, use --trace-class-initialization=io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder
Error: Use -H:+ReportExceptionStackTraces to print stacktrace of underlying exception```

</details>

<details>
<summary><strong>averri</strong> commented on 2023-02-17 21:22:12.000 UTC</summary>

Hi @Spikhalskiy, I have run the application with the GraalVM tracing enabled, and that generated the required descriptors. Now I can use the Temporal Java SDK with native GraalVM. Cool! 

Thank you for your hints. 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-17 21:23:39.000 UTC</summary>

@averri That's great. Please feel free to share the changes you had to make (or just the final descriptors) if you don't mind!

</details>

<details>
<summary><strong>averri</strong> commented on 2023-02-17 21:26:02.000 UTC</summary>

Sure thing. I was about to do that. I see that the tracing has added lots of other classes from my application, I'll remove them and leave just the ones related to Temporal SDK dependencies.

</details>

<details>
<summary><strong>averri</strong> commented on 2023-02-18 00:37:28.000 UTC</summary>

I'm attaching here the complete descriptors, including extra classes from my application. It needs some cleaning, leaving only the relevant parts, like the package `io.grpc.netty.shaded` and other ones required by Temporal. I'll do the cleaning later and test again, trying to determine the minimum configuration that allows Temporal Java SDK client to work with a native binary. 

I think the ideal solution would be to configure a continuous integration job in the repo `/temporalio/sdk-java` to run the tracing during the automated tests, and update the `native-image` directory with the results automatically. 

I'm using the Maven artifact `io.temporal:temporal-sdk:1.18.1`.

[META-INF.zip](https://github.com/temporalio/sdk-java/files/10772556/META-INF.zip)

The performance of a Java application running on a native image is super impressive.


Reactions: ‚ù§Ô∏è 1

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-18 00:39:25.000 UTC</summary>

@averri Appreciate it. And don't worry, I can do the cleaning myself and I will compare it with what we have currently to make sure it all makes sense for java-sdk. Thank you!

> The performance of a Java application running on a native image is super impressive.

You just need to give the normal JVM time to heat up and do all the JIT and other optimizations for a fair comparison ;)

Reactions: ‚ù§Ô∏è 1

</details>

<details>
<summary><strong>carlosedp</strong> commented on 2023-03-10 17:42:07.000 UTC</summary>

Thanks for this @averri ... I was battling thru making my small app work with native-image and found your package. It was a total pain finding all required configs.

The missing piece for me was:

```
  {
    "interfaces": [
      "EchoWorkflow",
      "io.temporal.internal.sync.StubMarker"
    ]
  }
```

on `proxy-config.json`. 

I wonder if there is a way to dynamically add my workflows to this or maybe I'll make a script that does this automatically.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-10 17:45:41.000 UTC</summary>

@carlosedp we can't generate these descriptors for all user classes obviously (`EchoWorkflow` is not Temporal java-sdk class), so users will need to provide the native-image proxy descriptors for their own classes. 
I added [the info about the least painful way for users to approach it](https://github.com/temporalio/sdk-java/blob/7c534738163d6a02ce38a33815ce72a64564fecb/docs/AOT-native-image.md#native-image) to our docs with relevant links.

</details>

<details>
<summary><strong>carlosedp</strong> commented on 2023-03-10 17:49:19.000 UTC</summary>

Thanks Dmitry, I didn't knew about the tracing agent... will look into it!

</details>


---

<a id="1999"></a>

### #1999: GrpcRetryer fails without retrying request if "getServiceCapabilities" request fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1999 |
| **State** | CLOSED |
| **Author** | aleskovets (Anton) |
| **Created** | 2024-02-29 15:49:36.000 UTC (1y 10m ago) |
| **Updated** | 2024-12-23 10:29:59.000 UTC |
| **Closed** | 2024-12-23 10:29:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 12 |
| **Priority Score** | 12 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Request to temporal service is retried according to RpcRetryOptions

## Actual Behavior
https://github.com/temporalio/sdk-java/blob/2b05f073e4b45a79cb447fdeae6ef8f704ee1423/temporal-serviceclient/src/main/java/io/temporal/internal/retryer/GrpcRetryer.java#L60
If serviceCapabilities.get() fails (not initialized yet + network issue or whatever) actual request under retry is not getting retried according to retry policies, but fails immediately instead.

## Steps to Reproduce the Problem
  1. Create brand new WorkflowClient to temporal server that returns an error upon system info request (i.e. HTTP 503). Basically any response that is not successful or UNIMPLEMENTED in grpc terms
  1. Send any command
  1. Request fails immediately without retrying

## Specifications
temporal-sdk
  - Version: 1.22.3


#### Comments (12)

<details>
<summary><strong>cretz</strong> commented on 2024-02-29 16:02:20.000 UTC</summary>

I believe this is intentional because this is basically a connect-time call that should fail the connect attempt not hang it. I think we want connection failures (which we define connection as TCP connect + this call) to fail immediately.

</details>

<details>
<summary><strong>aleskovets</strong> commented on 2024-02-29 16:07:51.000 UTC</summary>

it is weird though. If you track down usage it _only_ affects error case and result of this call is only used to read "differentiate internal errors" flag. However, failure in this request prevents real request from getting retried in a good way that would have been retried and recovered otherwise.

It is really less about whther "systemCapabilities.get()" itself retried, but rather about "real" request being retried according to RpcRertyOptions.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-29 16:35:31.000 UTC</summary>

> result of this call is only used to read "differentiate internal errors" flag

Not exactly. This call replaced our traditional gRPC health check call which means it also eagerly checks connectivity and auth. It just so happens that the result is a set of capabilities (which is why we moved away from gRPC health check, because we wanted to provide more information on the eager-RPC-to-check-connectivity call).

We use this call as a health/connectivity check.

</details>

<details>
<summary><strong>aleskovets</strong> commented on 2024-02-29 16:39:15.000 UTC</summary>

It makes sense that it is a health/connectivity check, but my point is that even if service is temporarily unhealthy (perfectly normal in real world of networking/pod restarts/whatever) it is expected that workflow client call is retried according to the rpc retry options. I.e. I know it could be temporarily down and I want workflow start call to be retried for a minute before giving up. Connectivity check failure basically prevents it making retry options useless.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-29 16:51:51.000 UTC</summary>

>  it is expected that workflow client call is retried according to the rpc retry options

Correct, actual client call should but connection doesn't retry based on those options, and the health call is part of connecting. I think this may be due to lazy connectivity. If you want to separate the connection from the first call with a client, you can use `WorkflowServiceStubs.newConnectedServiceStubs`. This will guarantee that your workflow client calls don't lazily attempt connectivity (which is not a retryable thing).

</details>

<details>
<summary><strong>aleskovets</strong> commented on 2024-02-29 17:04:39.000 UTC</summary>

Sure, this would have solved my narrow issue. But now it creates inconsistent behavior where eagerly created `WorkflowServiceStubs.newConnectedServiceStubs` are getting retried on instantiation in a good way vs lazy ones are just yolo'ing system info requests once at a random time and give up

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-29 18:29:26.000 UTC</summary>

> `WorkflowServiceStubs.newConnectedServiceStubs` are getting retried on instantiation

From what I understand, they aren't getting retried on instantiation. I don't believe connection (which is connect + get-system-info) is ever retried, only the post-connection RPC calls. This just shifts where connection happens, but the behavior is the same. We want connection to succeed or fail immediately without retry, regardless of whether it's eager or lazy. Sorry if I am misunderstanding.

</details>

<details>
<summary><strong>aleskovets</strong> commented on 2024-02-29 19:46:15.000 UTC</summary>

First of all, thank you for engaging with me - I appreciate your time.

Let's try to look at this issue from end user perspective - maybe I am having the wrong expectations.

> WorkflowServiceStubsOptions.setRpcRetryOptions
> 
> Allows customization of retry options for the outgoing RPC calls to temporal service.
> 
> Note that default values should be reasonable for most users, be cautious when changing these values as it may result in increased load to the temporal backend or bad network instability tolerance.
> 
> Defaults are:
> 
>     Retries are limited by the maximum period of 1 minute
>     Initial period between retries: 50ms
>     Exponential Backoff Coefficient (exponential rate) for the retry period is 2

By reading this - the purpose of configuring retries is to make `WorkflowClient` service calls reliable. Presumably - it is to mitigate intermittent issues that might occur during RPC request to temporal. Is it correct understanding?
If so - failures might occur if target temporal instance is temporarily unreachable/unhealthy and thus they would be automatically retried according to RpcRetryOptions to overcome an issue, right?
However, what really happens when service is temporarily unreachable/unhealthy is request failure due to pre-connection health request failure. Which makes no sense as service being temporary unreachable/unhealthy is exactly the problem that RPC retry is supposed to solve.

Following is IMO: it should not matter whether pre-conneciton or post-connection part of request is failing - from the usage perspective those are inseparable and should be treated as such when retry operation is applied.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-29 20:27:17.000 UTC</summary>

> First of all, thank you for engaging with me - I appreciate your time.

No prob! Also feel free to join us on `#java-sdk` on https://t.mp/slack.

> the purpose of configuring retries is to make WorkflowClient service calls reliable. Presumably - it is to mitigate intermittent issues that might occur during RPC request to temporal. Is it correct understanding?

Yes

> If so - failures might occur if target temporal instance is temporarily unreachable/unhealthy and thus they would be automatically retried according to RpcRetryOptions to overcome an issue, right?

For the actual RPC call, not for first connection to the actual service though (which includes the get-system-info). But for connection failure of an already established client, definitely.

>  However, what really happens when service is temporarily unreachable/unhealthy is request failure due to pre-connection health request failure. Which makes no sense as service being temporary unreachable/unhealthy is exactly the problem that RPC retry is supposed to solve.

Only if you chose to combine RPC calls with initial connection. If you already made initial connection, then RPC calls are just RPC calls. RPC retry is only for RPC calls, not for initial connection. Initial connection in this case is defined as "open TCP + get-system-info call".

> Following is IMO: it should not matter whether pre-conneciton or post-connection part of request is failing - from the usage perspective those are inseparable and should be treated as such when retry operation is applied.

It is unreasonable for many users to not eagerly fail when initially connecting (for host unreachable, auth fail, etc). Imagine writing a Java CLI that takes several seconds to fail for an unreachable host because initial connection is retried. But what you say makes perfect sense on failure after initial connection.

The retry applies to the single gRPC request the high-level client call is wrapping, not the entire high-level client call that may lazily connect and make get-system-info call. If you want the gRPC request to be 1:1 with the high-level client call (and therefore retry to apply to the high-level client call), eagerly connect thereby ensuring there is no conn+get-system-info call done lazily.

</details>

<details>
<summary><strong>aleskovets</strong> commented on 2024-02-29 20:37:25.000 UTC</summary>

> Imagine writing a Java CLI 

Funny you said that as it is exactly the thing I am solving for. My CLI app is run as a part of longer pipeline and is meant to connect to temporal, send command (start workflow) and exit. If temporal server is unavailable - it is going to fail "lazy" request. So, it looks like, the _only_ real option for CLI apps is to always use eager connection with decent timeout as alternative is just not reliable.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-02-29 20:39:57.000 UTC</summary>

> So, it looks like, the only real option for CLI apps is to always use eager connection with decent timeout as alternative is just not reliable.

Definitely. In fact, I would always suggest using eager connection (and in every one of our SDKs besides Java that is strongly preferred). This will help you differentiate between connection failure and RPC failure.

Also note that for connection-already-established clients that have some form of connection failure, connection is often reestablished internally by gRPC as part of the RPC call so from the RPC caller POV it does perform standard retries. It's just the very first connection that does not retry.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 10:29:59.000 UTC</summary>

This call is now retried 

</details>


---

<a id="1837"></a>

### #1837: Use Spring Boot ApplicationReadyEvent to start workers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1837 |
| **State** | CLOSED |
| **Author** | osialr (Ryan Osial) |
| **Created** | 2023-08-07 20:33:29.000 UTC (2y 5m ago) |
| **Updated** | 2023-10-11 14:47:14.000 UTC |
| **Closed** | 2023-10-11 14:47:13.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 6 |
| **Priority Score** | 12 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

**Is your feature request related to a problem? Please describe.**
Hi there :wave:!

After #1614, users must put `applicationContext.start()` in unit tests and main methods.  Invoking `start()` is not idiomatic Spring Boot and leads to confusion when workers haven't started. (#1648).  Even Spring Boot's [Sample Application](https://spring.io/guides/gs/spring-boot/) does not use `start()`

**Describe the solution you'd like**
Use Spring Boot's `ApplicationReadyEvent` instead of Spring's `ContextStartedEvent`.  

As described in [Application Events and Listeners](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners), _An ApplicationReadyEvent is sent after any application and command-line runners have been called._  

This represents the same application state as when `SpringApplication.run()` has returned and where users are instructed to manually add a call `start()`.

Additionally, using `ApplicationReadyEvent` removes the need for every test to contain the boilerplate 
```java
  @Autowired ConfigurableApplicationContext applicationContext;

  @BeforeEach
  void setUp() {
    applicationContext.start();
  }
```

**Describe alternatives you've considered**
* Put big bold text at the top of the README calling out this unusual requirement of a spring-boot library.
* Detect when the user should have put in a call `.start()` and emit a warning.

**Additional context**

I have a PR ready to submit if the feature is approved.

#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-08 14:46:12.000 UTC</summary>

Looking at this issue on the Spring Boot github https://github.com/spring-projects/spring-boot/issues/35936 I think your right that the current approach is not correct.

Is `ApplicationReadyEvent` the idiomatic Spring Boot way? I looked at the Spring Boot included http servers and did not see it being used there. From the description it sounds too late in the lifecyle to be starting the workers.

>This represents the same application state as when SpringApplication.run() has returned and where users are instructed to manually add a call start().

Can you point me towards the docs that suggest this?

</details>

<details>
<summary><strong>osialr</strong> commented on 2023-08-08 21:35:49.000 UTC</summary>

> Is ApplicationReadyEvent the idiomatic Spring Boot way? I looked at the Spring Boot included http servers and did not see it being used there. From the description it sounds too late in the lifecyle to be starting the workers. 

I suggested `ApplicationReadyEvent` to as closely preserve the existing behavior.  It may not be the right phase over something like `ApplicationStartedEvent`.

One example in spring-boot that uses `ApplicationReadyEvent` is [BackgroundPreinitializer](https://github.com/spring-projects/spring-boot/blob/647b20bb30ebef0f428129390470c53470736422/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L84-L91).  It starts a thread after `ApplicationEnvironmentPreparedEvent` then at `ApplicationReadyEvent` waits for the the initialization to finish if it hasn't already.

>> This represents the same application state as when SpringApplication.run() has returned and where users are instructed to manually add a call start().

> Can you point me towards the docs that suggest this?

In the docs for [ApplicationReadyEvent](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/event/ApplicationReadyEvent.html) 
_Event published as late as conceivably possible to indicate that the application is ready to service requests._

There is also a comment in [spring-boot#33935](https://github.com/spring-projects/spring-boot/issues/33935#issuecomment-1400247823):
 _The ApplicationReadyEvent is published to indicate within the application that it is now ready to service requests. This readiness should include all of your application's own components which should have got ready during bean initialization or as application or command-line runners. Once this event has been published and all listeners are aware that servicing of requests may now begin, the AvailabilityChangeEvent is published to make this readiness visible externally so that requests are routed to the application._

I ran an empty `spring-boot-starter` project with some event handlers and debug logging. The filtered output is

```
com.example.springboot.Application       : Invoking SpringApplication::run
com.example.springboot.Application       : Starting Application using Java 17.0.8 with PID 730127
com.example.springboot.Application       : Started Application in 0.779 seconds (process running for 1.237)
com.example.springboot.Application       : Received ApplicationStartedEvent
o.s.b.a.ApplicationAvailabilityBean      : Application availability state LivenessState changed to CORRECT
com.example.springboot.Application       : Received AvailabilityChangeEvent
com.example.springboot.Application       : Received ApplicationReadyEvent
o.s.b.a.ApplicationAvailabilityBean      : Application availability state ReadinessState changed to ACCEPTING_TRAFFIC
com.example.springboot.Application       : Received AvailabilityChangeEvent
com.example.springboot.Application       : SpringApplication::run has completed.  Invoking ConfigurableApplicationContext::start
com.example.springboot.Application       : Received ContextStartedEvent
com.example.springboot.Application       : ConfigurableApplicationContext::start has completed
```

Whether `ApplicationReadyEvent` or `ApplicationStartedEvent` is better depends on whether the application LivenessState should be updated before or after the connection has been attempted.


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-09 23:24:30.000 UTC</summary>

My concern with [ApplicationReadyEvent](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/event/ApplicationReadyEvent.html) is this part 

```
The ApplicationReadyEvent is published to indicate within the application that it is now ready to service requests.
```

Since workers service requests I believe they should be started before this event. Looking at the spring integration with http servers, like tomcat, it looks like they don't listen for either of these events, they just assume people will use sprint bean lifecycles to make sure there beans start before the server if there is a dependency. Perhaps temporal workers autostart should work the same.

</details>

<details>
<summary><strong>osialr</strong> commented on 2023-08-10 21:14:54.000 UTC</summary>

There's upsides and downsides to invoking `workferFactory.start()` within a bean lifecycle instead of on a application event.  


The upside is that it's fail-fast and the application will quit if on connection failure.  The downside is that there are cases where I want the web servlet to start up even when temporal connection fails.  The main one is the [`/health` endpoint](https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/#health)) plus custom Health Indicators to monitor system state. 

If the application aborts at startup then that I have to dig through the logs instead of using the health endpoint to see what's going wrong.  Additionally, external monitoring tools expect to have a health check endpoint.  A good connection at startup could always enter a bad state later.

So if you were to go that route, I'd make aborting a configuration option, something like `continue-on-failure: true/false`.  Where the two states are
1) When `continue-on-failure` is false, call `workerFactory.start()` in a spring-bean initialization and allow exceptions to propagate.
2) When `continue-on-failure` is true:,  call workerFactory.start() with a try/catch that only logs.

Regardless of the decisions in this ticket, adding a [HealthIndicator](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/actuate/health/HealthIndicator.html) to this repo would be helpful.


I couldn't deduce why there's a deferred startup, the Starter goes all the way back to the initial project commit. If the goal was to delay start to allow external configurations, the code could be modified to like [WebMvcConfigurer](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html).

Something like:
```java
WorkerFactory createWorkerFactory(Collection<WorkerFactoryConfigurer> configurer) {
  WorkerFactory workerFactory = ...; // existing codebase
  
  // Apply custom configuration
  for (var c : configurer) {
     c.doConfig(workerFactory);
  }
  
  // Start factory, no more configuration.
  try {
     workerFactaory.start();
  } catch (Exception e) {
    if (!config.continueOnFailure) {
      throw e;
    }
    LOG.warn("Failed to start temporal", e);
  }

  return workerFactory;
}
```

Sorry for the long post if you were simply debating `ApplicationReadyEvent` vs `ApplicationStartedEvent` :sweat_smile: 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-10 21:25:57.000 UTC</summary>

No I appreciate the long response.

 I was debating `ApplicationReadyEvent` vs `ApplicationStartedEvent` vs using bean lifecycle. I think another benefit of using bean lifecycles is if a users has beans they want to start after the worker starts that would be easy to setup. That being said I think the inverse (beans start before workers) is more common and all options support that.
 
 Yeah adding some sort of `HealthIndicator` for temporal spring is reasonable, could you open a separate ticket for that?

</details>

<details>
<summary><strong>osialr</strong> commented on 2023-08-15 15:53:59.000 UTC</summary>

> another benefit of using bean lifecycles is if a users has beans they want to start after the worker starts that would be easy to setup

True, the event system is kind of a kludge; there's an implicit bound.

But with current spring-boot library deferring `.start()` until an event, I can add more workers dynamically like in the [base example](https://docs.temporal.io/dev-guide/java/foundations#run-a-dev-worker)

```java
    WorkerFactory factory = WorkerFactory.newInstance(client);
    Worker yourWorker = factory.newWorker("your_task_queue");

    // Register Workflow
    // and/or register Activities

    factory.start();
```

with
```java
@Configuration
public class CustomWorkerConfig {
   @AutoWired
   FactoryWorker factoryWorker;

   @PostConstruct
   void addMyWorker() {
     var worker = factoryWorker.newWorker("other_task_queue");
    // Register Workflow
    // and/or register Activities
   }
}
```

I needed this capability because I am implementing the host specific task queue like in the [File Processing](https://github.com/temporalio/samples-java/blob/main/core/src/main/java/io/temporal/samples/fileprocessing/FileProcessingWorker.java) example.

If the WorkerFactory is started at the time it becomes a bean, then the above wouldn't work.  I'm unsure if there is a lifecycle phase that can call `start()` and have the bean available to others.

(Also, I opened #1839 about health indicators.)

Reactions: üëç 1

</details>


---

<a id="1256"></a>

### #1256: Last cached activity heartbeat should be discarded or drained with activity completion or worker shutdown

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1256 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-09 17:47:38.000 UTC (3y 7m ago) |
| **Updated** | 2025-05-26 15:05:59.000 UTC |
| **Closed** | 2025-05-26 15:05:59.000 UTC |
| **Upvotes** | 6 |
| **Comments** | 0 |
| **Priority Score** | 12 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | Next |
| **Reactions** | üëç 6 |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, if an Activity heartbeat too often and the heartbeat gets throttled and cached, an activity finishes without draining or canceling the heartbeat.

**Describe the solution you'd like**
The last cached heartbeat should be either drained before the activity completion or discarded/canceled.
This also should be happening during graceful worker shutdown.



---

<a id="865"></a>

### #865: Add init method to workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/865 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-10 18:26:33.000 UTC (4y 2m ago) |
| **Updated** | 2024-09-17 01:28:01.000 UTC |
| **Closed** | 2024-09-17 01:28:01.000 UTC |
| **Upvotes** | 5 |
| **Comments** | 2 |
| **Priority Score** | 12 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 5 |

#### Description

We should add an init method to workflows that allow some code to be run before any query, signal, or workflow method is processed.
This method should have access to workflow method input parameters.
This method doesn't have the same properties and guarantees as a workflow method. It shouldn't omit commands and doesn't work with WFT, because it would make it indistinguishable from the workflow method. It should be just a regular Java method.

This should solve the following situation:
1. A signal method can arrive before the workflow main method execution (reset preserving the signals on the first workflow task)
2. A signal method may require some initialization to be done.
3. General advice is to perform the initialization in the constructor or init block, BUT some initialization may require access to workflow input parameters. In this situation, users have to perform non-trivial gymnastics saving the signals in the field and processing them in a delayed manner in the workflow code.

It will also make it extra clear that Signals may arrive before the workflow code in triggered and the initialization should be handled with caution in some cases.

An alternative is to make the constructor such an init method. It will play nicely because it will be clear that it's not a workflow code and doesn't have properties of the workflow code.

# Dynamic Workflow
With regular typed workflows, listeners (signals and queries) are registered by SDK before processing signals. Currently, it's impossible to mimic this behavior with Dynamic Workflows.
Right now the only way to register listeners in Dynamic Workflow is to call the register methods from the workflow code. 
But with signalToStart, signal is getting delivered before the execution of the workflow method, at the moment when Dynamic Workflow code didn't execute yet, hence no listener is present. 
This makes init() method a necessity for Dynamic Workflows, not a convenience.


Related to #864
Related to a discussion under a user request in a community slack: https://temporalio.slack.com/archives/CTT84KXK9/p1636375128042600


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-08-06 17:28:10.000 UTC</summary>

Saw #2166 was marked as dupe.

I do want to make sure there is a clear difference between "run any code before start/signal/update" and "initialize state before start/signal/update". I think `@WorkflowInit` can be a constructor annotation that, when set, means the constructor accepts the exact params as the primary workflow method (enforced at registration). Users can use this to set `final` fields that rely on start parameters. But I don't think we'd want to encourage command-creating logic in the constructor (though I guess it's technically possible in Java where you don't have to mark it async). I think general initialization code that creates commands is a different topic.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-06 17:34:06.000 UTC</summary>

> I think general initialization code that creates commands is a different topic.

I agree, but that is not covered by the [feature request](https://github.com/temporalio/features/issues/400)

Reactions: üëç 1

</details>


---

<a id="704"></a>

### #704: Allow exception logging to be customizable for activity failures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/704 |
| **State** | CLOSED |
| **Author** | markcho (Mark Cho) |
| **Created** | 2021-09-08 23:30:30.000 UTC (4y 4m ago) |
| **Updated** | 2025-10-04 14:17:26.000 UTC |
| **Closed** | 2025-10-04 14:17:26.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 6 |
| **Priority Score** | 12 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

**Is your feature request related to a problem? Please describe.**
We have some use cases where we leverage ApplicationFailure.nonRetryableError for some failures that we expect to happen from an activity.

In these cases, we don‚Äôt want these failures to be logged as error. Since we also use a service like Sentry for exception monitoring in our prod services, these expected activity failures will pollute the log and would prefer to only log unexpected failures.

**Describe the solution you'd like**
Some approach to customize activity failure error logging.
Maxim's proposal was to create a logger per error type as described in here: https://community.temporal.io/t/java-sdk-allow-exception-logging-to-be-customizable-for-activity-failures/2887

**Describe alternatives you've considered**
An alternative I've considered was to never let expected failures to cause an `ApplicationFailure` but to model this into a return type.



#### Comments (6)

<details>
<summary><strong>mfateev</strong> commented on 2022-02-13 00:14:05.000 UTC</summary>

My current view is that we should add a flag (or separate method for creation) to allow creating an ApplicationFailure that is not logged. All other failures are logged.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-20 21:03:29.000 UTC</summary>

We should also cover the generation of activity exceptions in the `ActivityTaskExecutor` when executing the activity. Specifically for data converter exceptions.

</details>

<details>
<summary><strong>inspell</strong> commented on 2024-02-19 08:53:13.000 UTC</summary>

I also need to customize the logging configuration. I use activities for polling, and I throw exceptions from the activity to retry the poll. This currently pollutes the logs. Is there any update on this?

</details>

<details>
<summary><strong>darshan-au</strong> commented on 2024-08-08 18:15:18.000 UTC</summary>

+1 on this
We use activities for polling and the constant failures pollute the logs a lot

Reactions: üëç 1

</details>

<details>
<summary><strong>inspell</strong> commented on 2025-07-02 11:28:05.000 UTC</summary>

Hello! I am also tracking this issue. My initial "want" was this: https://github.com/temporalio/sdk-go/issues/78
Which is already implemented in the Go SDK. Will this also be available in the Java SDK? It appears to be exactly what this ticket describes.

EDIT: It looks like it is already available: https://github.com/temporalio/sdk-java/pull/2485

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-04 14:17:26.000 UTC</summary>

https://github.com/temporalio/sdk-java/pull/2485

</details>


---

<a id="537"></a>

### #537: Open tracing span context not propagated when activity or child workflow invoked asynchronously 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/537 |
| **State** | CLOSED |
| **Author** | smax48 (Maxim Chuvilyaev) |
| **Created** | 2021-06-11 01:59:52.000 UTC (4y 7m ago) |
| **Updated** | 2022-01-05 15:18:52.000 UTC |
| **Closed** | 2022-01-05 15:13:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 12 |
| **Priority Score** | 12 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.7.0 |

#### Description

## Expected Behavior

Given a workflow that invokes some activities and/or child workflows in an async way, trace context should correctly propagate into those async activities/child WF. Also the result trace should not be broken into multiple unrelated chunks

## Actual Behavior

Result trace for the main WF doesn't contain spans for async activities / child WF - their execution is represented in isolated traces instead.

## Steps to Reproduce the Problem

The easiest way to reproduce is to use SpanContextPropagationTest from temporal-opentracing and change activity invocation to Async.function {...}.get()

## Specifications

  - Version: Temporal Java SDK 1.0.9


#### Comments (12)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-06-11 03:12:44.000 UTC</summary>

@smax48 thanks for the report, it does look like a bug.

Failing unit test: https://github.com/Spikhalskiy/java-sdk/commit/1811aa0818df841ee97d4d44d857335662e24c83#diff-b6c10900bd776516302d896d09b7946aaf53b70297ec46c5f75eb0d76b212998R124

</details>

<details>
<summary><strong>smax48</strong> commented on 2021-06-11 03:32:33.000 UTC</summary>

@Spikhalskiy , thanks for confirming this!
Async execution is always a problem for things like tracing where you need to preserve the single context across multiple threads... 
For example, in Armeria framework they use their own request context to store the trace context - so it correctly flows across threads.
For temporal, I think that if "normal" workflow context propagation (`ContextPropagator` interface) works correctly with async (I do hope, but need to check that) - that can be potentially used in the open tracing scenario. 
But it might be an easier way - you definitely know this better! :) 


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-06-11 05:09:19.000 UTC</summary>

A little bit more context after an initial investigation.

If workflow triggers an async activity using method reference like this:
``` 
Async.function(activity::activity, input).get();
```
Interceptors and propagation actually work correctly. Here is the unit test verifying it:
https://github.com/Spikhalskiy/java-sdk/commit/59d620a2c319659c447e72a6617a74b4cf20c8e9#diff-b6c10900bd776516302d896d09b7946aaf53b70297ec46c5f75eb0d76b212998R146

But if workflow triggers the activity asynchronously using lambda:
```
Async.function(() -> activity.activity(input)).get();
```
the context is lost and interceptors don't see the context of the original thread. Here is a failing unit test verifying it:
https://github.com/Spikhalskiy/java-sdk/commit/59d620a2c319659c447e72a6617a74b4cf20c8e9#diff-b6c10900bd776516302d896d09b7946aaf53b70297ec46c5f75eb0d76b212998R186

The difference comes from how differently these two cases are processed inside `AsyncInternal`:
```
  private static <R> Promise<R> execute(boolean async, Functions.Func<R> func) {
    if (async) {
      initAsyncInvocation();
      try {
        func.apply();
        return getAsyncInvocationResult();
      } catch (Exception e) {
        return Workflow.newFailedPromise(Workflow.wrap(e));
      } finally {
        closeAsyncInvocation();
      }
    } else {
      CompletablePromise<R> result = Workflow.newPromise();
      WorkflowInternal.newThread(
              false,
              () -> {
                try {
                  result.complete(func.apply());
                } catch (Exception e) {
                  result.completeExceptionally(Workflow.wrap(e));
                }
              })
          .start();
      return result;
    }
  }
```

Method reference-based implementation (correctly working) goes to the first branch (`async = true`) because temporal code is able to understand that it's a call to a temporal activity stub and we are able to execute it asynchronously.
The second (incorrectly working) execution goes to the second branch (`async = false`) and actually schedules the execution of the lambda on a new thread because it's just a piece of code. And as the result, it doesn't have thread locals of the original thread or the state of tracer scope.
It's not an OpenTracing bug, it probably affects any Interceptors and potentially ContextPropagators or something more don't work correctly in this case too, while I didn't verify it.

@smax48 You can use this information to make a workaround. If you trigger activity asynchronously using method reference - you will be fine. This is not a trivial bug and fixing it properly will take some time.

</details>

<details>
<summary><strong>smax48</strong> commented on 2021-06-11 08:56:09.000 UTC</summary>

@Spikhalskiy , thanks a lot, that's a very interesting info! 

But the problem is that we are using kotlin... :-D 

So for some reason even when I use this invocation: `Async.function(activity::activity, input).get();` , I get `async`  false inside `execute()`  (`toSerializedLambda` returns null) !!! 

Seems like I need to dig a bit deeper into how kotlin compiler works in this case.
I will update you when I find more info.

**UPDATE**
Looks like kotlin compiler happily ignores the fact that functional interface extends Serializable... So the resulting object doesn't have all those expected methods, checked in `toSerializedLambda` ...

The quickest workaround I found is to use a Java wrapper method like this:
```
    public static Promise<String> activity1Function(SpanContextPropagationTest.TestActivity activity) {
        return Async.function(activity::activity1);
    }
```

Kotlin test works when I call the activity this way!

Thanks again!

**PS**
I am not sure what Temporal does with serialized lamdas, but having better support for Kotlin would be much appreciated :-) 



</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-06-11 13:49:03.000 UTC</summary>

@smax48 This is a known problem. Kotlin generates "method references" differently than java, as the result Temporal code responsible for detecting a method reference to a temporal stub can't do its job correctly. I made an attempt to tackle this problem in this PR: https://github.com/temporalio/sdk-java/pull/319 bit I never got a chance to finalize it to any decent state.
Please use the workarounds for now while these two issues are not resolved.

UPDATE
https://github.com/temporalio/sdk-java/pull/319 with the Kotlin/Async fix is polished is merged into master.


Reactions: üëç 1

</details>

<details>
<summary><strong>smax48</strong> commented on 2021-09-22 00:57:46.000 UTC</summary>

Hi @Spikhalskiy , what is the current state of this bug? I can see that Kotlin async support is added in v1.3.x - is there anything else that left to finish this? I briefly tested with 1.3, kotlin method references work OK now - but kotlin lambdas still don't. Is that what you plan to fix before 1.4 ? :)

Basically, `Async.function(activity::activity1).get()` works OK
`Async.function { activity.activity1() }.get()` - doesn't work 

Thanks!

UPDATE
I re-read this thread, looks like you mentioned that lambdas do not work correctly even with Java...

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-22 01:04:47.000 UTC</summary>

@smax48 Hey. Didn't work on it. Not because it's hard, the hard part is done as a part of #557, just didn't have hands for it. We can fix it in 1.4 scope if it affects you.

Reactions: üëç 1

</details>

<details>
<summary><strong>smax48</strong> commented on 2021-09-22 01:06:00.000 UTC</summary>

Working method references with Kotlin are OK for us at the moment, so no rush :) 
Thanks!

Reactions: üëç 1

</details>

<details>
<summary><strong>smax48</strong> commented on 2021-11-08 23:02:05.000 UTC</summary>

Some update on this issue - it seems that the span context is NOT propagated into child workflows when they are started asynchronously this way in kotlin:
```
        Async.procedure(childWorkflow::method, request)
        // Wait for child to start
        Workflow.getWorkflowExecution(childWorkflow).get()
```
In this case I have a fully separate trace for the child workflow which is very inconvenient...

Not sure if this is related to kotlin or something has changed in the trace propagation logic with child workflows (as it worked at some (long) time ago)


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-04 21:53:05.000 UTC</summary>

> Some update on this issue - it seems that the span context is NOT propagated into child workflows when they are started asynchronously this way in kotlin:
> 
> ```
>         Async.procedure(childWorkflow::method, request)
>         // Wait for child to start
>         Workflow.getWorkflowExecution(childWorkflow).get()
> ```
> 
> In this case I have a fully separate trace for the child workflow which is very inconvenient...
> 
> Not sure if this is related to kotlin or something has changed in the trace propagation logic with child workflows (as it worked at some (long) time ago)

@smax48
I can't reproduce this.
Please see tests in https://github.com/Spikhalskiy/java-sdk/commit/da1a4327e5ded29c1cecdf7c4db85725a1dae237
OT context is passing correctly to a child workflow triggered the way you propose in Kotlin. I also tested on kotlin 1.4 and 1.6.

</details>

<details>
<summary><strong>smax48</strong> commented on 2022-01-05 00:36:40.000 UTC</summary>

@Spikhalskiy - Well, something is very strange... I checked several traces in our production just before Christmas / NY holidays - and they were broken.

But when I just randomly checked histories right now - I cannot find a broken one anymore.... All WFs have the full history, including the child WF activities (temporal sdk was not updated over holiday period).

I think that could be possible because I previously checked those workflows that had some other issues (like big s2s latencies etc) - maybe there was something wrong there...

I will try to find something today.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-05 15:18:52.000 UTC</summary>

@smax48 I closed this issue because both propagations into stub method references in Kotlin and propagation into async lambdas are fixed now. If you are able to make a reproduction for propagation into child workflows, please feel free to open a new issue with details.

Reactions: üëç 1

</details>


---

<a id="214"></a>

### #214: @SignalMethod threading configuration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/214 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-09-18 03:22:24.000 UTC (5y 3m ago) |
| **Updated** | 2020-09-18 03:22:24.000 UTC |
| **Upvotes** | 6 |
| **Comments** | 0 |
| **Priority Score** | 12 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 6 |

#### Description

**Is your feature request related to a problem? Please describe.**
Each signal causes execution of a method annotated with @SignalMethod in its own thread. It means if the signal handling method blocks execution all other signals are still delivered through other threads.

In some scenarios the preferred semantic would be using a single thread to deliver all signals of the given type. This way workflow can flow control their processing. So while signal handling method is blocked all other signals are queued up waiting for thread to become available.

**Describe the solution you'd like**
Default signal handling to a single thread and provide an option through @SignalMethod parameter to multithreaded dispatch. Or do not provide multithreaded dispatch at all.

**Describe alternatives you've considered**
Keep it as it is.




---

<a id="1565"></a>

### #1565: Test server seems to not enable time skipping in this specific scenario

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1565 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-12-10 00:15:45.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-10 03:37:23.000 UTC |
| **Closed** | 2022-12-10 03:37:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 11 |
| **Priority Score** | 11 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ‚ù§Ô∏è 1 |

#### Description

## Expected Behavior

W2 7 day timer should be unblocked immediately.

## Actual Behavior

Timer is not unblocked.

## Steps to Reproduce the Problem

(I have not run this myself and verified, this is pseudo code I got from a user on [slack](https://temporalio.slack.com/archives/C01DKSMU94L/p1670625163595479))

```ts
async function W1() {
    await A1();
    ...
}

async function A1() {
  const ids = runDBQuery();

  const { workflowClient } = getContext();

  await Promise.all(
    ids.map((id) =>
      workflowClient.signalWithStart(W2, {
        taskQueue: "default",
        workflowId: `W2-${id}`,
        args: [
          {
            ...
          },
        ],
        signal: S1,
        signalArgs: [{ ... }],
      })
    ),
  );
}

async function W2() {
    await sleep("7 days");
    await A2();
    ...
}

async function A2() {
    // produce side effect
}

describe("test T1", () => {
    it("alls A2", async () => {
        const testActivities = {
          ...activities,
          A2: jest.fn(),
        };


        const testEnv = await TestWorkflowEnvironment.createTimeSkipping();
        const worker = await Worker.create({
          connection: testEnv.nativeConnection,
          workflowsPath: require.resolve("./allWorkflows"),
          interceptors: appendDefaultInterceptors(
            {
              activityInbound: [
                (ctx) =>
                  new CustomActivityInboundInterceptor(ctx, {
                    workflowClient: testEnv.client.workflow,
                  }),
              ],
            },
            console
          ),
          activities: testActivities,
          taskQueue: "default",
        });

        await worker.runUntil(() => 
          testEnv.client.workflow.execute(
            W1,
            {
              workflowId: randomUUID(),
              taskQueue: "default",
              args: [
                {
                  ...
                },
              ],
            }
          )
        )

        const handle = testEnv.client.workflow.getHandle(`W2-id1`);
        await handle.result();

        expect(testActivities.A2).toHaveBeenCalled();
    })
})
```

#### Comments (11)

<details>
<summary><strong>maxgurewitz</strong> commented on 2022-12-10 00:23:48.000 UTC</summary>

Thank you!

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-10 00:46:50.000 UTC</summary>

Workflow Time Skipping is getting disabled for the period of activity execution. You don't want the Server timestamp to become Long.MAX_LONG while the worker executes the activity for a second or two. Instead, you want it to reflect the actual time of the activity execution.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-10 00:50:09.000 UTC</summary>

The WorkflowClient that is used in the activity A2 may be reconfigured to use the time-skipping workflow client, the `testEnv.client` one to address this change. This doesn't require a Test Server change.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-10 00:59:29.000 UTC</summary>

What does A1 wait for in this code sample? Does it wait for workflow start or completion? 

</details>

<details>
<summary><strong>maxgurewitz</strong> commented on 2022-12-10 01:38:27.000 UTC</summary>

> Does it wait for workflow start or completion?

A1 just waits until the `workflowClient.signalWithStart` calls finish, which as I understand it will just wait until W2 starts, not completes.

</details>

<details>
<summary><strong>maxgurewitz</strong> commented on 2022-12-10 01:41:09.000 UTC</summary>

If this is not a bug, is there some recommended fix for the above pseudocode?

</details>

<details>
<summary><strong>maxgurewitz</strong> commented on 2022-12-10 01:49:23.000 UTC</summary>

> The WorkflowClient that is used in the activity A2 may be reconfigured to use the time-skipping workflow client, the testEnv.client one to address this change. This doesn't require a Test Server change.

If I'm understanding you, I believe I'm doing that by injecting the time-skipping workflow client with an interceptor.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-10 01:49:28.000 UTC</summary>

@maxgurewitz Thanks for the clarification, it makes more sense if they wait only for a start. I will try to repro it and get back to you, I don't expect it to be a Test Server bug, but it may be a TS SDK bug. 
How many workflows does A1 start in your test? One or several?

Reactions: üëç 1

</details>

<details>
<summary><strong>maxgurewitz</strong> commented on 2022-12-10 01:50:43.000 UTC</summary>

> How many workflows does A1 start in your test? One or several?

It can start several, but I can repro this issue where it only starts 1 (`ids` has 1 item).

</details>

<details>
<summary><strong>maxgurewitz</strong> commented on 2022-12-10 02:44:59.000 UTC</summary>

I've added a repo for a simple working reproduction of this issue, with setup instructions. Thanks!

https://github.com/ideamarketinc/temporal-repro/tree/activity-waiting

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-12-10 03:37:23.000 UTC</summary>

Looks like the worker in this example is shut down before the second workflow gets a chance to complete.

</details>


---

<a id="1007"></a>

### #1007: Scala module

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1007 |
| **State** | OPEN |
| **Author** | doruchiulan (Doru Chiulan) |
| **Created** | 2020-04-28 21:47:27.000 UTC (5y 8m ago) |
| **Updated** | 2025-05-13 16:52:05.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 7 |
| **Priority Score** | 11 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

I'll go with a top-to-bottom approach with the things I encountered, and how I tried to solve them in my project.

1. **WorkflowClient**
 - WorkflowClient.start with `io.temporal.workflow.Functions.Func` arguments
 - WorkflowClient.start with `io.temporal.workflow.Functions.Proc` arguments
 - WorkflowClient.execute with `io.temporal.workflow.Functions.Func` arguments
 - WorkflowClient.execute with `io.temporal.workflow.Functions.Proc` arguments

> Solved this by writing some small wrappers. I don't think this is the way, but the code inside might be useful. These are the only type of functions I needed, didn't convert them all (e.g the ones that take more arguments)

 ```
def startAsync(f: T => Unit, arg: T): WorkflowExecution = {
    WorkflowClient.start(new Proc1[T]() {
      override def apply(j: T): Unit = f(j)
    }, t)
  }

  def executeAsyncVoid(f: () => Unit): Future[Unit] = {
    import scala.compat.java8.FutureConverters._

    WorkflowClient.execute(new Proc {
      override def apply(): Unit = f()
    }).toScala.map[Unit](_ => ())
  }

  def executeAsync[T](f: () => T): Future[T] = {
    import scala.compat.java8.FutureConverters._

    WorkflowClient.execute(new Func[T] {
      override def apply(): T = f()
    }).toScala
  }
```

2. **Scala specific object types serialization/deserialization**

 - Option
 - List (basically all Scala collections)

> We can probably solve this when Jackson will be integrated in java-sdk

3. **Workflow.await requiring a Supplier, instead of passing a function reference**

> Again, solved in a simple wrapper

```
 def await(duration: Duration, f: () => Boolean) {
    Workflow.await(duration, new Supplier[lang.Boolean] {
      override def get(): lang.Boolean = f()
    })
  }
```


4. **Java way of referencing some method (not sure how this syntax it's called in Java)**
(Mostly the same as 1. but I put it in a different issue as it's a little bit a different problem)

`WorkflowClient.execute(workflow::getGreeting, "World")` -> notice the double colon

5. **Accepting Scala Duration type**

#### Comments (7)

<details>
<summary><strong>Krever</strong> commented on 2020-04-30 09:12:10.000 UTC</summary>

Hey, we have some experience in using cadence with scala and can contribute our experiences and maybe even some code.

Reg 2) Serialization is a tough topic, in general, typeclass-based serialization is more idiomatic and safer in modern scala. But this would be something to have in scala native sdk and so is out of the scope of this issue probably.

1 & 3 are already solved in scala 2.12 and later -> https://www.scala-lang.org/news/2.12.0/#lambda-syntax-for-sam-types

2 & 5 as proposed are not possible without adding scala stdlib as a dependency of java sdk, which doesn't sound plausible. Whereas 2) Is quite hard, the 5) is easily solved by https://github.com/scala/scala-java8-compat#converters-between-scalaconcurrentdurationfiniteduration-and-javatimeduration



Reactions: üëç 1

</details>

<details>
<summary><strong>grouzen</strong> commented on 2021-03-15 10:46:08.000 UTC</summary>

Hello!

Just wondering about the progress with scala-sdk for Temporal? Any updates? 


Reactions: üëÄ 3

</details>

<details>
<summary><strong>doruchiulan</strong> commented on 2021-03-18 15:58:35.000 UTC</summary>

Not really using cadence in my current projects, but I'm still keeping an eye on this as this is a project which I really like and which I will happily include in any project that suits it. So if somebody takes over, has a plan/architecture and leads this, I will happily contribute with pieces of code.

Reactions: üëç 2

</details>

<details>
<summary><strong>jvican</strong> commented on 2022-01-26 20:50:30.000 UTC</summary>

Hi. Really interested in helping this move forward by creating an integration. Is there a guide I can use to start making the integration possible?

</details>

<details>
<summary><strong>ktham</strong> commented on 2022-02-20 18:01:25.000 UTC</summary>

Would love the additional support for Scala üëç it could potentially unlock some interesting use-cases if I can pitch Temporal to my team

Reactions: üëç 7

</details>

<details>
<summary><strong>vitaliihonta</strong> commented on 2022-06-22 10:49:34.000 UTC</summary>

Hi everyone I‚Äôve implemented Scala SDK, which supports most temporal features.
https://github.com/vitaliihonta/zio-temporal

It also allows using protobuf format via ScalaPB.

Currently, it‚Äôs tied to ZIO

Reactions: üéâ 11

</details>

<details>
<summary><strong>scoplin</strong> commented on 2022-10-06 22:49:24.000 UTC</summary>

I got bit by a problem with the reflection logic that attempts to determine whether `Async.function` is being passed a method reference in `MethodReferenceDisassembler#isAsyncJava`.  Turns out that a method reference in Scala has a different result from `getImplMethodKind`.  It returns `MethodHandleInfo.REF_invokeStatic` instead of `MethodHandleInfo.REF_invokeInterface`.  We had to invoke this through a small java shim to get it to function correctly and not execute directly on the local workflow executor.

I think ztemporal may have the same problem.  It also appears to me to call `Async.function` passing a Scala lambda expression.

</details>


---

<a id="745"></a>

### #745: üçÉ Dependency Injection

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/745 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-21 17:33:37.000 UTC (4y 3m ago) |
| **Updated** | 2025-05-13 17:05:18.000 UTC |
| **Closed** | 2025-05-13 16:41:03.000 UTC |
| **Upvotes** | 5 |
| **Comments** | 1 |
| **Priority Score** | 11 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 5 |

#### Description

# Description

Improve support and/or safety of Dependency Injection with JavaSDK.

# Core objectives

Dependency Injection into Workflow instances should be strongly discouraged. It's deemed unsafe and leads to practices that create non-deterministic workflows at the end. But Temporal needs to provide alternative solutions for the common problems and goals that users are addressing with dependency injection.

# Tasks

- [ ] #746
- [x] #747
- [ ] #748
- [ ] Documentation page describing why in the vast majority of cases injection into workflow instances is dangerous with examples of situations when it's a legit approach and when it's not (and what alternative should be used)
- [x] https://github.com/temporalio/samples-java/issues/168
- [x] #8
- [x] #827

# Related user requests / reports

- [x] #718
- [x] #466


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:41:03.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="2724"></a>

### #2724: Allow Configuration Option to Enable Spring Application Startup Even When Temporal is Unavailable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2724 |
| **State** | CLOSED |
| **Author** | ccrouse-atlassian |
| **Created** | 2025-11-10 16:00:24.000 UTC (2 months ago) |
| **Updated** | 2025-11-10 17:15:36.000 UTC |
| **Closed** | 2025-11-10 17:15:36.000 UTC |
| **Upvotes** | 5 |
| **Comments** | 0 |
| **Priority Score** | 10 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 5 |

#### Description

**Is your feature request related to a problem? Please describe.**

- As mentioned in https://community.temporal.io/t/spring-boot-starter-behavior-changes-on-app-startup/12239/6 ; when the spring application fails to connect to temporal server, the spring application fails to start.

- Temporal is _Not_ a hard dependency for some applications to remain available, this is preventing my application from starting if temporal is unavailable.

**Describe the solution you'd like**

Allow configuration to still allow spring application startup, even when temporal is down.


**Describe alternatives you've considered**

- Open to suggestions here. Not sure about feasibility of conditionally scanning for worker / activity beans based on temporal availability.


**Additional context**

See https://community.temporal.io/t/spring-boot-starter-behavior-changes-on-app-startup/12239/6



---

<a id="1489"></a>

### #1489: Support Scala references to workflow methods

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1489 |
| **State** | CLOSED |
| **Author** | scoplin (Scott Coplin) |
| **Created** | 2022-10-20 15:58:35.000 UTC (3y 2m ago) |
| **Updated** | 2025-06-02 15:20:36.000 UTC |
| **Closed** | 2025-06-02 15:20:35.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 6 |
| **Priority Score** | 10 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 üëÄ 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

If the `Async.function` (or similar) methods is called in an attempt to dispatch a child workflow from a Scala class, it fails to properly detect the attempt to call a workflow method on a temporal stub, and instead falls back to submitting the function to a new workflow thread in `AsyncInternal`.  As a result, we saw excessive threads being created and consumed in workers, eventually resulting in `RejectedExectionException` being thrown from the underlying executor.

For reference, the structure of the Scala code to demonstrate the problem is:

    val stub = Workflow.newChildWorkflowStub(classOf[MyWorkflow], workflowOptions)
    val result = Async.function(stub.performMyWorkflow, workflowInput)  // Problem occurs here

**Describe the solution you'd like**

The logic in `MethodReferenceDisassembler.isAsync(Object)` should be modified to account for Scala method references.  When I investigated this with a debugger, I saw that [this line](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/async/MethodReferenceDisassembler.java#L57) in `isAsyncJava` appeared to be where a modification could be made:

    && lambda.getImplMethodKind() == MethodHandleInfo.REF_invokeInterface);

With a Scala method reference, the implementation method kind is equal to `MethodHandleInfo.REF_invokeStatic`.  In my particular case, both Java and Scala are giving me a target reference of type `AsyncInternal.AsyncMarker`.  I'm hoping that a fix is as simple as allowing both types of method implementation kinds may be all that's required here.

This is substantially less than the request for full Scala support covered by #1007.  That is obviously a lot more work.

**Describe alternatives you've considered**

I was able to work around this issue by creating a small java shim class to call `Async.function` using a Java method reference.

**Additional context**

My local debugging was done against Scala 2.12.  I am not sure to what degree these behaviors differ across Scala versions.

It appears to me that the [vitaliihonta/ztemporal](https://github.com/vitaliihonta/ztemporal) project _may_ also run afoul of this introspection problem based upon how it uses `Async` in its [ZPromise](https://github.com/vitaliihonta/zio-temporal/blob/9e21f23857ebd376e35ed7c6622029487b64c60b/core/src/main/scala/zio/temporal/promise/ZPromise.scala#L86).

#### Comments (6)

<details>
<summary><strong>ploddi</strong> commented on 2023-02-11 16:13:29.000 UTC</summary>

@scoplin can you share you Java workaround?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-12 21:00:54.000 UTC</summary>

I solved the same problem for Kotlin here: [KotlinMethodReferenceDisassemblyService](https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-kotlin/src/main/kotlin/io/temporal/internal/async/KotlinMethodReferenceDisassemblyService.kt#L28)

There is a handy abstraction that can be implemented for Scala (if at all possible to do) to support their method references as natively as Java ones: [MethodReferenceDisassemblyService](https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/internal/async/spi/MethodReferenceDisassemblyService.java#L31)

There are also tests in KotlinAsyncChildWorkflowTest, KotlinAsyncCompanionFunctionTest, KotlinAsyncLambdaTest that may give a framework for the same tests for Scala.

If you are interested in researching and disassembling Scala's method references, we would be open to getting a `temporal-scala` module that will bring the method reference disassembly service for Scala.

</details>

<details>
<summary><strong>ploddi</strong> commented on 2023-02-14 12:42:41.000 UTC</summary>

@Spikhalskiy I believe that Scala can use same `DisassemblyService` as Java, with the only difference that Scala compiler generates different implementation method kinds for lambdas, so actual `stub` checking method should be adjusted for Scala specific method references.

</details>

<details>
<summary><strong>ploddi</strong> commented on 2023-02-14 12:45:19.000 UTC</summary>

Do we even need this check?
```java
&& lambda.getImplMethodKind() == MethodHandleInfo.REF_invokeInterface);
```
Because without it Scala method references will work.

</details>

<details>
<summary><strong>scoplin</strong> commented on 2023-02-14 15:20:29.000 UTC</summary>

@ploddi My workaround was method-specific.  I simply took this line:
```
val result = Async.function(stub.performMyWorkflow, workflowInput)  // Problem occurs here
``` 
And wrote/compiled it in java instead as a trivial static method.  Then I called that wrapper method from scala.

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-02 15:20:35.000 UTC</summary>

This would be covered when/if we add a dedicated scala module

</details>


---

<a id="1133"></a>

### #1133: TestActivityEnvironment: calling "close" in test method fails tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1133 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-04-11 14:19:12.000 UTC (3y 9m ago) |
| **Updated** | 2022-08-04 20:46:42.000 UTC |
| **Closed** | 2022-08-04 20:46:42.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 6 |
| **Priority Score** | 10 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |
| **Reactions** | üëç 2 |

#### Description

To reproduce:
ActivityOptionsTest: https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/test/java/io/temporal/activity/ActivityOptionsTest.java

Add "testEnv.close()" at the end of each test method. The test env should be recreated in the "@Before" method but instead
this throws:

                java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@590c73d3 rejected from java.util.concurrent.ThreadPoolExecutor@6b9ce1bf[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
      io.temporal.internal.sync.WorkflowRejectedExecutionError: java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@590c73d3 rejected from java.util.concurrent.ThreadPoolExecutor@6b9ce1bf[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
	      at io.temporal.internal.sync.WorkflowThreadImpl.start(WorkflowThreadImpl.java:266)
	      at io.temporal.internal.sync.DeterministicRunnerImpl.runUntilAllBlocked(DeterministicRunnerImpl.java:160)
	      at io.temporal.internal.sync.DeterministicRunnerWrapper.invoke(DeterministicRunnerWrapper.java:53)
	      at com.sun.proxy.$Proxy13.activity1(Unknown Source)
	      at io.temporal.activity.ActivityOptionsTest.testActivityOptionsDefaultInstance(ActivityOptionsTest.java:95)
	      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	      at java.lang.reflect.Method.invoke(Method.java:498)
	      at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	      at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	      at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	      at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	      at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	      at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	      at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	      at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	      at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	      at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	      at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	      at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	      at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	      at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	      at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	      at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	      at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	      at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110)
	      at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)
	      at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)
	      at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62)
	      at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	      at java.lang.reflect.Method.invoke(Method.java:498)
	      at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	      at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	      at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
	      at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
	      at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	      at org.gradle.api.internal.tasks.testing.worker.TestWorker$2.run(TestWorker.java:176)
	      at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129)
	      at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100)
	      at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60)
	      at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)
	      at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133)
	      at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71)
	      at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69)
	      at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74)
      Caused by: java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@590c73d3 rejected from java.util.concurrent.ThreadPoolExecutor@6b9ce1bf[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
	      at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	      at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	      at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	      at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)
	      at io.temporal.internal.sync.WorkflowThreadImpl.start(WorkflowThreadImpl.java:250)
	      ... 48 more


#### Comments (6)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-13 22:03:59.000 UTC</summary>

Likely related: https://github.com/temporalio/sdk-java/issues/928

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-07-27 04:36:34.000 UTC</summary>

Any update?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-27 04:37:49.000 UTC</summary>

The issue will be closed if the problem is resolved.

Reactions: üòï 1

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-07-27 17:38:00.000 UTC</summary>

The root cause appears to be a static `ExecutorService activityWorkerExecutor` that is used for all `TestActivityEnvironmentInternal` instances, where a new `TestActivityEnvironmentInternal` instance is created for each test method, and the static executor is closed as part of each test method as well:

## beforeEach

https://github.com/temporalio/sdk-java/blob/ae5fb81293a62f2d9c83f53d57fb1ab683713da1/temporal-testing/src/main/java/io/temporal/testing/TestActivityExtension.java#L145-L148

https://github.com/temporalio/sdk-java/blob/ae5fb81293a62f2d9c83f53d57fb1ab683713da1/temporal-testing/src/main/java/io/temporal/testing/TestActivityEnvironment.java#L66-L68

https://github.com/temporalio/sdk-java/blob/ae5fb81293a62f2d9c83f53d57fb1ab683713da1/temporal-testing/src/main/java/io/temporal/testing/TestActivityEnvironmentInternal.java#L79-L80

## during

https://github.com/temporalio/sdk-java/blob/ae5fb81293a62f2d9c83f53d57fb1ab683713da1/temporal-testing/src/main/java/io/temporal/testing/TestActivityEnvironmentInternal.java#L322-L325

## afterEach

https://github.com/temporalio/sdk-java/blob/ae5fb81293a62f2d9c83f53d57fb1ab683713da1/temporal-testing/src/main/java/io/temporal/testing/TestActivityExtension.java#L154-L158

https://github.com/temporalio/sdk-java/blob/ae5fb81293a62f2d9c83f53d57fb1ab683713da1/temporal-testing/src/main/java/io/temporal/testing/TestActivityEnvironmentInternal.java#L239-L242

The same appears to be true for `heartbeatExecutor` and `deterministicRunnerExecutor` as well.

## Possible fixes:
1. Make these fields not static (creating a new thread pool per test may be sub-optimal for performance but is probably acceptable for most testing use cases)
2. Do not close these static fields as part of `AfterAllCallback`/`TestActivityEnvironment#close` and instead use something like `TestExecutionListener#testPlanExecutionFinished` or a shutdown hook

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-27 17:56:18.000 UTC</summary>

Thank you for giving the detailed root cause analysis, much appreciated! Confirm that your findings look right.

> Make these fields not static (creating a new thread pool per test may be sub-optimal for performance but is probably acceptable for most testing use cases)

Is the cleanest approach. #close of an instance shouldn't be closing static member as the instance creation or initialization didn't cause their creation in the first place (Class loading did). Let's make everything that is needed by TestActivityEnvironmentInternal and that needs a lifecycle management non-static: `heartbeatExecutor`, `activityWorkerExecutor`, `deterministicRunnerExecutor`.

Will you be interested in making a PR?


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-04 20:46:42.000 UTC</summary>

Closed by #1329

</details>


---

<a id="952"></a>

### #952: OpenTracing duplicates user created spans during replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/952 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-05 17:05:12.000 UTC (4 years ago) |
| **Updated** | 2024-12-17 21:26:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 10 |
| **Priority Score** | 10 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

If we have the following code somewhere in workflow:

```
void execute() {
  ...
  withSpan(() -> {
    activity.runActivity();
  })
  ...
  //end of replay somewhere down from the above code block
}
```

If we replay the code above, we should ignore the span creation, because this span was already reported during the original execution.

## Actual Behavior

The second span will be created during replay.

## Proposed solution

We should create a thin layer on top of `Tracer`, `ScopeManager`, `Scope` or `Span` that will check if we are still replaying on span finalization and if we are - discard the span instead of finalizing it.

## Notes
The issue is raised here:
#951
https://github.com/temporalio/sdk-java/pull/951#pullrequestreview-844189585

And the solution is originally proposed here:
https://github.com/temporalio/sdk-java/pull/951#issuecomment-1005896960

#### Comments (10)

<details>
<summary><strong>bergundy</strong> commented on 2022-01-05 17:20:58.000 UTC</summary>

> But what is true, the user-created span may be ignored during replay (depends on its location) with my original proposal. And in your sample, the activity may end up directly under the WorkflowRun span. But this is a smaller issue, let me think about it.
I really believe that we can resolve it just as inside a thin Tracer wrapper that can make some smart "buffering" of spans during replays inside and track when isReplaying switches from true to false.
Or even simpler, the tracer can always open spans when requested but check isReplaying on .finish() call and discard the span if isReplaying is still true. At first sight, it looks like it will work.

So the problem is that right now with a user created span the activity span will be parentless because the parent span (the user created one) is never emitted.
The only way to fix this is to recreate the same span with the exact same spanId on replay.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-05 17:25:20.000 UTC</summary>

@bergundy 

> So the problem is that right now with a user created span the activity span will be parentless because the parent span (the user created one) is never emitted.

it's not. For this specific reason, JavaSDK always creates WorkflowRun span. As you can see in the test that I pointed and it's javadoc: https://github.com/temporalio/sdk-java/blob/a2bc9373201dd58a607197ac39b7f87c1c0059c2/temporal-opentracing/src/test/java/io/temporal/opentracing/ActivityFailureTest.java#L131 The activity span will not be parentless, it will have WorkflowRun span as a parent.

But yes, it will not have a user-created span as a parent. I'm fairly confident that the proposed solution will address it well.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-05 17:29:00.000 UTC</summary>

@bergundy 

> The only way to fix this is to recreate the same span with the exact same spanId on replay.

It's not. Even more, OpenTracing and OpenTelemetry specifications don't allow this (creation of a span with a specific spanId). A span that was finished can't be just reopened for appending, it's not a part of spec. Check 
OT [`SpanBuilder`  interface](https://javadoc.io/doc/io.opentracing/opentracing-api/0.31.0/io/opentracing/Tracer.SpanBuilder.html).

Each run/replay has its own WorkflowRun span (it's the case right now)
The user span should be duplicated under each WorkflowRun span and contain only activities that were actually executed and not replayed in that run.
If span was fully executed in the previous run - it shouldn't be recreated in the next run.
The decision if the span was fully executed in the previous run should be made on the span `.finish` call - this way we are sure if we are still replaying when the span is finishing.
This solution will be congruent with the current JavaSDK approach and OpenTracing/OpenTelemetry spec. This solution will also be good for debugging, because of the level of detail that it provides.


</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-01-05 17:35:13.000 UTC</summary>

> A span that was finished can't be just reopened for appending

In the case I've illustrated in #951 the span is unfinished (the workflow is evicted from cache before the activity can complete)

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-05 17:43:40.000 UTC</summary>

> In the case I've illustrated in #951 the span is unfinished (the workflow is evicted from cache before the activity can complete)

In Java the [conventional code](https://github.com/opentracing/opentracing-java/blob/master/opentracing-api/src/main/java/io/opentracing/ScopeManager.java#L45) working with spans looks like:

```
 Span span = tracer.buildSpan("...").start();
 try (Scope scope = tracer.scopeManager().activate(span)) {
     ...
     activity1.execute()
     activity2.execute()
     ...
 } catch (Exception e) {
     span.log(...);
 } finally {
     span.finish();
 }
```

Opened scope and span will be finished and reported in case of eviction or any other Exception/Error halfway.
As it should. You don't really want to lose all the info collected in the spans (with potentially logs, tags, and other details that can't be restored during replay) including from the underlying activities just because the workflow got evicted. And it will be lost if the parent span is not finished.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-01-05 17:54:39.000 UTC</summary>

Okay, I see, it works differently than in TS where we completely discard the workflow from memory when it's evicted without running any cleanup.

So in this case if the workflow is replayed before it can execute activity2, activity2's parent span will be the root workflow span which isn't that bad.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-05 17:59:08.000 UTC</summary>

@bergundy Yeah, in Java you can't just nuke something without running the corresponding `.finally()` blocks.
Which has its own advantages (here) and creates its own challenges (potential non-determinism if somebody puts an activity execution in `.finally()`) for us.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-01-05 18:05:40.000 UTC</summary>

There's also another issue with this approach where if we evict the workflow the user's span will end erroneously while when looking at it from the code perspective everything seems fine.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2022-01-23 21:55:36.000 UTC</summary>

I don't think that approach that doesn't create a span on replay would work. The problem is that a newly executed code can create a child span and needs a parent span. But parent span wouldn't be present on replay. The ideal solution would allow assigning span-id deterministically on replay. But unfortunately none of the tracing libraries supports assigning span ids.

The other solution is to serialize the span into the history and then recreate it from the serialized data on replay.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-23 21:58:19.000 UTC</summary>

> But parent span wouldn't be present on replay.

Don't forget that each workflow run (and replay to this matter) has its own workflow run parent span. So, each replay-followed-by-run has its own Span. This gives us a lot of power and flexibility here.

I will reiterate the solution I am convinced will work here, let's discuss this specific offer, not the objective. Because I don't see any reason why it shouldn't work and it's aligned with the current general spans structure.

> Each run/replay has its own WorkflowRun span (it's the case right now)
> The user span should be duplicated under each WorkflowRun span and contain only activities that were actually executed and not replayed in that run.
> If span was fully executed in the previous run - it shouldn't be recreated in the next run.
> The decision if the span was fully executed in the previous run should be made on the span `.finish` call - this way we are sure if we are still replaying when the span is finishing.
> This solution will be congruent with the current JavaSDK approach and OpenTracing/OpenTelemetry spec. This solution will also be good for debugging, because of the level of detail that it provides.

</details>


---

<a id="102"></a>

### #102: Health check between service + temporal servers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/102 |
| **State** | CLOSED |
| **Author** | AngerM-DD (Matt Anger) |
| **Created** | 2020-06-16 17:20:20.000 UTC (5y 6m ago) |
| **Updated** | 2021-06-02 18:24:49.000 UTC |
| **Closed** | 2021-06-02 18:24:49.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 2 |
| **Priority Score** | 10 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 4 |

#### Description

**Is your feature request related to a problem? Please describe.**
With cadence we have seen issues where clients lose their connection and are unable to reconnect to the cadence servers

**Describe the solution you'd like**
A health checking mechanism that allows me to check whether the workers/factory have a healthy connection. This would allow us to check something like `factory.isHealthy()` in a k8s health check endpoint and restart the worker services if necessary

**Describe alternatives you've considered**
None.

**Additional context**
We built this into the cadence java client by forking it and using the TChannel meta health check that cadence looks to already implement.


#### Comments (2)

<details>
<summary><strong>bbottema</strong> commented on 2021-05-20 07:36:19.000 UTC</summary>

Yep, we're spinning up a Temporal container to use in our cucumber tests, but currently have no way of knowing if the server is up.

</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-05-29 05:09:26.000 UTC</summary>

@bbottema does this pull request address your issue?

</details>


---

<a id="2466"></a>

### #2466: Spring boot starter behavior changes on app startup

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2466 |
| **State** | CLOSED |
| **Author** | parinmaru2 (parin maru) |
| **Created** | 2025-04-02 05:51:26.000 UTC (9 months ago) |
| **Updated** | 2025-12-24 13:48:39.000 UTC |
| **Closed** | 2025-05-06 16:32:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Old SDK versions (older than v1.22.0)
- If temporal server is unavailable, the worker service would still be able to startup successfully though it would have errors in the logs about the server being unavailable.


## Actual Behavior
New SDK versions (>= v1.22.0)
- Worker service wouldn't come up if the temporal server is unavailable.


## Desired Behavior
- It's fine to keep the default behavior where worker wouldn't be able to startup if the temporal server is unavailable. However, it would be good if a config is provided that customers can override if they want the older behavior where the worker service wouldn't crash in case the server is unavailable.


More details can be found in this conversation: https://community.temporal.io/t/spring-boot-starter-behavior-changes-on-app-startup/12239

#### Comments (9)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-02 14:22:29.000 UTC</summary>

To start a worker the Temporal service must be up and reachable, this is a requirement across all of our SDKs including Java. There was not change to this requirement in `v1.22.0`. In Springboot if you don't want to start a worker on application start up you can set `start-workers: false`. See the [readme](https://github.com/temporalio/sdk-java/tree/master/temporal-spring-boot-autoconfigure#explicit-configuration) for more details 

</details>

<details>
<summary><strong>parinmaru2</strong> commented on 2025-04-02 22:39:01.000 UTC</summary>

@Quinn-With-Two-Ns If you looked at the [attached link,](https://community.temporal.io/t/spring-boot-starter-behavior-changes-on-app-startup/12239) there are screenshots about the before/after behavior.

Before (on v1.21.2):

![Image](https://github.com/user-attachments/assets/4da9d147-287a-43c1-a9e4-86539b27e676)


After (on v1.23.2):

![Image](https://github.com/user-attachments/assets/78bc65be-c218-4c67-976c-b286d551d366)


I believe @mfateev commented on that thread that this change was done in v1.22.0.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-02 22:49:12.000 UTC</summary>

https://github.com/temporalio/sdk-java/issues/1837 changes when a worker we exactly started, but workers have always required a connection to Temporal to start. If you would like to control worker start you can set `start-workers: false` as I described above. 

</details>

<details>
<summary><strong>parinmaru2</strong> commented on 2025-04-02 22:54:21.000 UTC</summary>

@Quinn-With-Two-Ns I am not sure how `start-workers: false` will help us here.

My goal is to be able to start my temporal workflow worker even if the upstream temporal server isn't available. How will `start-workers: false` help here? Apologize if I am missing something.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-02 23:07:48.000 UTC</summary>

You should only start your worker if the temporal service is available. Why is your Temporal service not avaialbe when you are trying to start a worker?

</details>

<details>
<summary><strong>parinmaru2</strong> commented on 2025-04-02 23:15:10.000 UTC</summary>

Totally agree with you @Quinn-With-Two-Ns . However, we provide self-hosted Temporal servers within our company as a managed-service. And one of our customers has this very peculiar use case where they want the worker to startup successfully even if Temporal service is not available. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-30 15:06:11.000 UTC</summary>

If a worker cannot connect to the Temporal service the worker cannot successfully start. I would recommend fixing the issue causing the worker to start before the Temporal service is up.

If you are okay with the worker start blocking until it connects to the Temporal server you can increase the time for the first connection request by increasing `WorkflowServiceStubsOptions.Builder.setSystemInfoTimeout` and start the worker manually.

</details>

<details>
<summary><strong>parinmaru2</strong> commented on 2025-04-30 17:01:00.000 UTC</summary>

Thanks @Quinn-With-Two-Ns 

</details>

<details>
<summary><strong>Daverkex</strong> commented on 2025-12-24 13:48:39.000 UTC</summary>

Hi @Quinn-With-Two-Ns, a microservice best practice is to make a difference between my application crashing and my application needing something not possible now.
[Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/) and [Spring Boot](https://spring.io/blog/2020/03/25/liveness-and-readiness-probes-with-spring-boot) implement this with the readiness vs liveness probes.
The mechanism allows avoiding cascading failures overheating the container orchestrator.

It's not the same for an application to not be responding as for an application to be waiting for "backends".
In the 1st case, the orchestrator does nothing (in reality, K8s service pointing to the pods remains empty).
In the 2nd case, the orchestrator will rotate the pod.

In a microsystem architecture, a good handle on this behavior is critical. It's the difference between a service being down and all services in the system being down (cascade failure).

Knowing that, could you rethink integrating a way to make a difference between liveness and readiness in the Temporal client for spring?

</details>


---

<a id="1669"></a>

### #1669: Inheritance with @WorkflowMethod annotation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1669 |
| **State** | CLOSED |
| **Author** | Bennett-Lynch (Bennett Lynch) |
| **Created** | 2023-02-22 18:48:26.000 UTC (2y 10m ago) |
| **Updated** | 2023-02-22 21:43:07.000 UTC |
| **Closed** | 2023-02-22 18:56:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 9 |
| **Priority Score** | 9 |
| **Labels** | question, wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'd like to create base interfaces and abstract classes for common workflow patterns. While possible, Temporal does not discover the `@WorkflowMethod` annotation from parent classes:

> You can create interface inheritance hierarchies to reuse components across other Workflow interfaces. The interface inheritance approach does not apply to `@WorkflowMethod` annotations. [[source]](https://legacy-documentation-sdks.temporal.io/java/how-to-develop-a-workflow-definition-in-java)

Is there any reason for this limitation? If the risk is multi-inheritance of `@WorkflowMethod` methods, could that simply be a runtime violation or unspecified behavior?

The workaround is to redeclare and annotate the method, which results in unnecessary code and may be more error prone.

#### Comments (9)

<details>
<summary><strong>cretz</strong> commented on 2023-02-22 18:50:59.000 UTC</summary>

I'll let @Spikhalskiy answer for Java, but I can say we have the same intentional attribute/decorator inheritance limitation in .NET/Python very specifically because we _want_ you to have to annotate the most overridden form. These annotations mark methods as special and therefore hiding whether they are special up the inheritance chain is error prone.

> which results in unnecessary code and may be more error prone.

We intentionally accept that it adds more code, but how is it more error prone?

Reactions: üëç 1

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2023-02-22 18:55:41.000 UTC</summary>

It can be more error prone in that someone implementing an abstract workflow class may not know they need to redeclare and annotate methods, and these misses may not be discovered until runtime (often with obscure serialization errors). It's counter-intuitive to how people normally interact with abstract classes.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-22 18:56:49.000 UTC</summary>

@WorkflowMethod annotation pretty much defines a specific workflow type and there should be one workflow of the specific type in most apps.
```
public @interface WorkflowMethod {
  /** Name of the workflow type. Default is {short class name} */
  String name() default "";
}
```

We don't want this annotation to be placed on a parent class with multiple children explicitly to point this out.

You can still use inheritance and have several implementations of the same type if you want to. Just implement the workflow method in the parent without an annotation, override the method in the child, annotate it with a right @WorkflowMethod and delegate it to the parent.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-22 18:58:09.000 UTC</summary>

> these misses may not be discovered until runtime (often with obscure serialization errors)

In some languages we validate up the inheritance chain at registration time. So if you have an override that doesn't define the Temporal annotation its base signature does, we error at registration time. I could see that extra validation having value.

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2023-02-22 19:06:21.000 UTC</summary>

> @WorkflowMethod annotation pretty much defines a specific workflow type and there should be one workflow of the specific type in most apps.

Isn't this true for `@WorkflowInterface` but not necessarily `@WorkflowMethod`?

I'll give a slightly more concrete example for a use case I have in mind:

I'm designing an interface and corresponding abstract class for a workflow that is primarily signal-driven. The abstract class facilitates polling for signals, deduplicating signals, etc. Implementations of the abstract class can then simply instrument the behavior to react to the signal and decide if it's terminal.

In this scenario I want to offer this abstract class as a library, and there may be multiple implementations of it within a single application. So I would not wish to declare `@WorkflowInterface` at the parent interface level, but it does make sense to declare `@WorkflowMethod` at the parent interface level.

Implementations of the parent interface then need to mostly pointlessly redeclare the `startworkflow` method just to add an annotation. In my opinion it makes sense and offers value for Temporal to be able to discover this annotation through inheritance. It should probably be used with caution, but I'd rather leave that judgment to the interface author.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-22 19:27:37.000 UTC</summary>

We don't want `@WorkflowMethod`'s to be flying around and leaking without any attachment to the `@WorkflowInterface`, this is the idea and a design.
Both `@WorkflowInterface` and `@WorkflowMethod` work together to define a workflow type.
What a `@WorkflowMethod` annotation with a specified `name` in the parent class means if it's not a WorkflowInterface implementation at all?

> So I would not wish to declare @WorkflowInterface at the parent interface level, but it does make sense to declare @WorkflowMethod at the parent interface level.

You parent class is not implementing a @WorkflowInterface, it shouldn't have WorkflowMethods. It's not workflow methods. It's just methods.
Children that implement @WorkflowInterface may MAKE them @WorkflowMethod by overriding them. 
If you want to make clear for your library users what method of a parent class is intended to be a workflow method, you can make your own documenting annotation like @WorkflowMethodCandidate or @WorkflowMethodArchetype. But they are not @WorkflowMethod without @WorkflowInterface.

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2023-02-22 19:38:52.000 UTC</summary>

Thanks @Spikhalskiy. I can understand that reasoning even if I'm not 100% in agreement with the design.

However, if you argue that these workflow-related annotations are meaningless when not associated with a workflow interface, wouldn't the same be true for something like `@Signal`? But the documentation [here](https://legacy-documentation-sdks.temporal.io/java/workflows) suggests creating reusable interface components as follows:

```
public interface Retryable {
    @SignalMethod
    void retryNow();
}
```

```
@WorkflowInterface
public interface MediaProcessingWorkflow extends Retryable {

    @WorkflowMethod
    String processBlob(Arguments args);
}
```

`Retryable` is not a workflow interface so by the same logic it should not be allowed to contain any workflow-related annotations. (I understand that a workflow can have multiple `@SignalMethod`s and only one `@WorkflowMethod`, but I think the same logic still applies.)

(In my opinion the above pattern _does_ offer value and the same value could be extended to `@WorkflowMethod`. However I'm also not sure if the documentation is correct. From my local testing it does not seem that `@SignalMethod` is discoverable via inheritance either.)

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-02-22 21:26:31.000 UTC</summary>

"Mixins" (not a term you hear in Java much but applicable in other langs where we have this same rule) and multi-inherited interfaces can have value for signals and queries which can have > 1 arity and be composable with unrelated sets of each other, but workflow methods are singular and not composable in that way.

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2023-02-22 21:43:06.000 UTC</summary>

IMHO, regardless of arity, inheritance is just a way to help organize and abstract code and it would be nice if the Temporal SDK allowed developers to make their own judgment call on how it is structured. I'll make one final plea to consider the same and otherwise I appreciate the opinions and respect the design decision. :)

</details>


---

<a id="1536"></a>

### #1536: Activity stub throws IllegalArgumentException from toString method

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1536 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-11-26 18:04:46.000 UTC (3y 1m ago) |
| **Updated** | 2024-11-22 15:41:54.000 UTC |
| **Closed** | 2024-11-22 15:41:54.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 3 |
| **Priority Score** | 9 |
| **Labels** | bug, good first issue |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

## Expected Behavior
Activity stub returns string information about its configuration and state.

## Actual Behavior
IllegalArgumentException is thrown.

```
Caused by: java.lang.IllegalArgumentException: Unknown method: public java.lang.String java.lang.Object.toString()
	at io.temporal.common.metadata.POJOActivityInterfaceMetadata.getMethodMetadata(POJOActivityInterfaceMetadata.java:124)
	at io.temporal.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:56)
	at com.sun.proxy.$Proxy46.toString(Unknown Source)
	at io.temporal.samples.moneytransfer.AccountTransferWorkflowImpl.transfer(AccountTransferWorkflowImpl.java:35)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.execute(POJOWorkflowImplementationFactory.java:302)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:277)
	at io.temporal.internal.sync.WorkflowExecuteRunnable.run(WorkflowExecuteRunnable.java:71)
	at io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:116)
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:102)
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:106)
	at io.temporal.worker.ActiveThreadReportingExecutor.lambda$submit$0(ActiveThreadReportingExecutor.java:53)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	... 3 common frames omitted
```


## Steps to Reproduce the Problem

  1. Call toString on any activity stub.



#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-29 21:53:05.000 UTC</summary>

The same is true for Workflow stubs also

</details>

<details>
<summary><strong>jessicalostinspace</strong> commented on 2024-01-31 16:53:07.000 UTC</summary>

Following this thread as I'm also running into this issue. My activity is only returning: 
    `return enum1 != null && enum2 != null && enum1 != enum2;` which doesn't _explicitly_ call toString(). 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-31 17:26:29.000 UTC</summary>

@jessicalostinspace can you share the exception and stack trace of the error you go?

</details>


---

<a id="2676"></a>

### #2676: temporal java sdk is using an older version of grpc-netty-shaded with vulnerabilities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2676 |
| **State** | OPEN |
| **Author** | susie-oracle |
| **Created** | 2025-10-07 21:08:53.000 UTC (3 months ago) |
| **Updated** | 2025-12-05 09:06:45.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 6 |
| **Priority Score** | 8 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior

upgrade grpc-netty-shaded to 1.75.0
## Actual Behavior


## Steps to Reproduce the Problem

  1.check dependencies of temporal java-sdk
  1.https://www.cve.org/CVERecord?id=CVE-2025-55163
  1.

## Specifications

  - Version: 1.28.1, ..,1.31.0
  - Platform:


#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-07 22:17:26.000 UTC</summary>

A few points,
1. This [vulnerability](https://github.com/netty/netty/security/advisories/GHSA-prj3-ccx8-p6x4) does not apply to how the Java SDK uses netty since the Java SDK is only a client.

2. If the issue is simply the vulnerability scan then you can update the version of `gRPC` the SDK uses. As part of our CI we test the Java SDK with the latest version of Java gRPC. Note, this is what we always recommend anyway.

</details>

<details>
<summary><strong>mike706574</strong> commented on 2025-11-12 14:44:00.000 UTC</summary>

> A few points,
> 
> 1. This [vulnerability](https://github.com/netty/netty/security/advisories/GHSA-prj3-ccx8-p6x4) does not apply to how the Java SDK uses netty since the Java SDK is only a client.
> 2. If the issue is simply the vulnerability scan then you can update the version of `gRPC` the SDK uses. As part of our CI we test the Java SDK with the latest version of Java gRPC. Note, this is what we always recommend anyway.

I think it might be helpful if this context and the recommendation were documented somewhere more formally. I found it here, and I also found it [in this community thread](https://community.temporal.io/t/dependency-security-issue-cve-2025-55163/18479), but might have saved me some time if it were more front and center. Maybe the README? There's already a note about Protobuf versions in there, so doesn't seem like it would be too out of place there? Just a thought.

</details>

<details>
<summary><strong>Vishal-Joshi</strong> commented on 2025-12-01 14:14:33.000 UTC</summary>

Is there a plan to update temporal SDK to latest version of gRPC? Even if I update gRPC to v1.76.*, temporal SDK has dependencies on classes of gRPC v1.58.* which are not in gRPC v.176.*

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-12-01 18:07:23.000 UTC</summary>

@Vishal-Joshi please see the comment [above](https://github.com/temporalio/sdk-java/issues/2676#issuecomment-3378905321). The Java SDK is fully compatible with the latest gRPC.

</details>

<details>
<summary><strong>Vishal-Joshi</strong> commented on 2025-12-03 10:26:14.000 UTC</summary>

> [@Vishal-Joshi](https://github.com/Vishal-Joshi) please see the comment [above](https://github.com/temporalio/sdk-java/issues/2676#issuecomment-3378905321). The Java SDK is fully compatible with the latest gRPC.

Thanks @Quinn-With-Two-Ns. I applied your fix and tested with gRPC 1.76.0 BOM

```
<dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-bom</artifactId>
            <version>1.76.0</version>
            <type>pom</type>
  </dependency>
```
But I see then our tests start to break as `io.temporal:temporal-testing:jar:1.31.0` has some internal dependency

```
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [io.temporal.testing.TestWorkflowEnvironment]: Factory method 'testWorkflowEnvironment' threw exception with message: io/grpc/internal/AbstractServerImplBuilder
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.lambda$instantiate$0(SimpleInstantiationStrategy.java:200)
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiateWithFactoryMethod(SimpleInstantiationStrategy.java:89)
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:169)
        at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653)
        ... 176 more
Caused by: java.lang.NoClassDefFoundError: io/grpc/internal/AbstractServerImplBuilder
        at java.base/java.lang.ClassLoader.defineClass1(Native Method)
        at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1027)
        at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150)
        at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862)
        at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760)
        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681)
        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639)
        at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)
        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:526)
```


It is not only testing. If I try to run the temporal managed by spring-boot v3.5.7, the application fails to start up with same error
Temporal related dependencies in pom are
```
<dependency>
                <groupId>io.temporal</groupId>
                <artifactId>temporal-spring-boot-starter</artifactId>
                <version>1.31.0</version>
            </dependency>
            <dependency>
                <groupId>io.temporal</groupId>
                <artifactId>temporal-spring-boot-autoconfigure</artifactId>
                <version>1.31.0</version>
            </dependency>
            <dependency>
                <groupId>io.temporal</groupId>
                <artifactId>temporal-kotlin</artifactId>
                <version>1.31.0</version>
            </dependency>
```
```Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'temporalScheduleClient' defined in class path resource [io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.class]: Unsatisfied dependency expressed through method 'scheduleClient' parameter 0: Error creating bean with name 'temporalClientTemplate' defined in class path resource [io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.class]: Unsatisfied dependency expressed through method 'clientTemplate' parameter 0: Error creating bean with name 'temporalRootNamespaceTemplate' defined in class path resource [io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.class]: Unsatisfied dependency expressed through method 'rootNamespaceTemplate' parameter 1: Error creating bean with name 'temporalWorkflowServiceStubs' defined in class path resource [io/temporal/spring/boot/autoconfigure/ServiceStubsAutoConfiguration.class]: Failed to instantiate [io.temporal.serviceclient.WorkflowServiceStubs]: Factory method 'workflowServiceStubsTemplate' threw exception with message: io/grpc/internal/AbstractManagedChannelImplBuilder
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:804)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:546)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1375)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1205)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:569)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:529)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:339)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:373)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1770)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1653)
	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:913)
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)
	... 21 common frames omitted
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'temporalClientTemplate' defined in class path resource [io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.class]: Unsatisfied dependency expressed through method 'clientTemplate' parameter 0: Error creating bean with name 'temporalRootNamespaceTemplate' defined in class path resource [io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.class]: Unsatisfied dependency expressed through method 'rootNamespaceTemplate' parameter 1: Error creating bean with name 'temporalWorkflowServiceStubs' defined in class path resource [io/temporal/spring/boot/autoconfigure/ServiceStubsAutoConfiguration.class]: Failed to instantiate [io.temporal.serviceclient.WorkflowServiceStubs]: Factory method 'workflowServiceStubsTemplate' threw exception with message: io/grpc/internal/AbstractManagedChannelImplBuilder
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:804)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:546)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1375)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1205)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:569)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:529)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:339)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:373)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1770)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1653)
	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:913)
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)
	... 35 common frames omitted
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'temporalRootNamespaceTemplate' defined in class path resource [io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.class]: Unsatisfied dependency expressed through method 'rootNamespaceTemplate' parameter 1: Error creating bean with name 'temporalWorkflowServiceStubs' defined in class path resource [io/temporal/spring/boot/autoconfigure/ServiceStubsAutoConfiguration.class]: Failed to instantiate [io.temporal.serviceclient.WorkflowServiceStubs]: Factory method 'workflowServiceStubsTemplate' threw exception with message: io/grpc/internal/AbstractManagedChannelImplBuilder
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:804)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:546)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1375)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1205)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:569)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:529)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:339)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:373)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1708)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1653)
	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:913)
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)
	... 49 common frames omitted
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'temporalWorkflowServiceStubs' defined in class path resource [io/temporal/spring/boot/autoconfigure/ServiceStubsAutoConfiguration.class]: Failed to instantiate [io.temporal.serviceclient.WorkflowServiceStubs]: Factory method 'workflowServiceStubsTemplate' threw exception with message: io/grpc/internal/AbstractManagedChannelImplBuilder
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:657)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:645)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1375)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1205)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:569)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:529)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:339)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:373)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1770)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1653)
	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:913)
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791)
	... 62 common frames omitted
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [io.temporal.serviceclient.WorkflowServiceStubs]: Factory method 'workflowServiceStubsTemplate' threw exception with message: io/grpc/internal/AbstractManagedChannelImplBuilder
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.lambda$instantiate$0(SimpleInstantiationStrategy.java:200)
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiateWithFactoryMethod(SimpleInstantiationStrategy.java:89)
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:169)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653)
	... 76 common frames omitted
Caused by: java.lang.NoClassDefFoundError: io/grpc/internal/AbstractManagedChannelImplBuilder
	at java.base/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:962)
	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:132)
	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:776)
	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:691)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:620)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:578)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:490)
	at io.temporal.serviceclient.ChannelManager.prepareChannel(ChannelManager.java:186)
	at io.temporal.serviceclient.ChannelManager.<init>(ChannelManager.java:98)
	at io.temporal.serviceclient.ChannelManager.<init>(ChannelManager.java:78)
	at io.temporal.serviceclient.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:64)
	at io.temporal.serviceclient.WorkflowServiceStubs.newServiceStubs(WorkflowServiceStubs.java:46)
	at io.temporal.serviceclient.WorkflowServiceStubs.newLocalServiceStubs(WorkflowServiceStubs.java:23)
	at io.temporal.spring.boot.autoconfigure.template.ServiceStubsTemplate.createServiceStubs(ServiceStubsTemplate.java:50)
	at io.temporal.spring.boot.autoconfigure.template.ServiceStubsTemplate.getWorkflowServiceStubs(ServiceStubsTemplate.java:38)
	at io.temporal.spring.boot.autoconfigure.ServiceStubsAutoConfiguration.workflowServiceStubsTemplate(ServiceStubsAutoConfiguration.java:51)
	at io.temporal.spring.boot.autoconfigure.ServiceStubsAutoConfiguration$$SpringCGLIB$$0.CGLIB$workflowServiceStubsTemplate$1(<generated>)
	at io.temporal.spring.boot.autoconfigure.ServiceStubsAutoConfiguration$$SpringCGLIB$$FastClass$$1.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:258)
	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:400)
	at io.temporal.spring.boot.autoconfigure.ServiceStubsAutoConfiguration$$SpringCGLIB$$0.workflowServiceStubsTemplate(<generated>)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:565)
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.lambda$instantiate$0(SimpleInstantiationStrategy.java:172)
	... 79 common frames omitted
Caused by: java.lang.ClassNotFoundException: io.grpc.internal.AbstractManagedChannelImplBuilder
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:580)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:490)
	... 104 common frames omitted

Process finished with exit code 1
```

</details>

<details>
<summary><strong>Vishal-Joshi</strong> commented on 2025-12-05 09:05:45.000 UTC</summary>

I have resolved this issue by adding gRPC in "dependencyManagement" of maven with scope import.
```
<dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-bom</artifactId>
                <version>1.76.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

</details>


---

<a id="2057"></a>

### #2057: Java SDK seems to not play well with Replay tests. Setting child workflow ID using Temporal library seems to be throwing a non-deterministic error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2057 |
| **State** | CLOSED |
| **Author** | gauravojha (Gaurav Ojha) |
| **Created** | 2024-05-08 20:19:31.000 UTC (1y 8m ago) |
| **Updated** | 2025-06-10 22:22:36.000 UTC |
| **Closed** | 2025-06-10 22:22:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Details attached on the temporal forum support request - https://community.temporal.io/t/workflowreplayer-replayworkflowexecution-throwing-nondeterministicexception-when-reading-workflow-id-from-workflow/12040/6

Copied from the post above

========

Here is a sample repo which replicates the error. The repo also has replay tests and sample workflow history if required under the src/test folder
https://github.com/gauravojha/learningTemporal/tree/master

So what we are trying to do is

(Also mentioned here, hope this helps - [learningTemporal/src/main/java/dev/ojha/learningtemporal/workflows/HelloWorldWorkflowImpl.java at master ¬∑ gauravojha/learningTemporal ¬∑ GitHub](https://github.com/gauravojha/learningTemporal/blob/master/src/main/java/dev/ojha/learningtemporal/workflows/HelloWorldWorkflowImpl.java#L35-L40))

* Have a parent workflow trigger a child workflow
* What we are trying to do is, reusing the parent workflows ID (this we get by using the provided Temporal utility method - `Workflow.getInfo().getWorkflowId()`, and then using this is a prefix and just append "-child" to it. So for instance if the parent workflow ID is "helloWorld", we are assigning our child workflow ID as "helloWorld-child", as this simplifies some usecases of tracing and audit for our usecases
  * When we do this, and replay the payload through the replay tests, we get an undeterministic error, I have attached the trace for this specific case at the end
  * `Failure handling event 5 of type 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED' during replay. [TMPRL1100] Command COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION doesn't match event EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED with EventId=5 on check workflowId with an expected value 'workflow_id_in_replay-child' and an actual value 'HelloWorldWorkflow-child'`
* However, if we don't reuse the parent's workflow ID, and let temporal use a random ID as the workflow ID of the child, then the replay tests pass.

#### Comments (8)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-08 23:06:31.000 UTC</summary>

How are you replaying history? If you are using `WorkflowReplayer.replayWorkflowExecution`  then when you [construct ](https://github.com/temporalio/sdk-java/blob/a41c64ece3876f584ebde70903668b817c5455d8/temporal-sdk/src/main/java/io/temporal/internal/common/WorkflowExecutionHistory.java#L60C10-L60C34)`WorkflowExecutionHistory` you need to specify the workflow ID 

</details>

<details>
<summary><strong>gauravojha</strong> commented on 2024-05-09 07:27:07.000 UTC</summary>

> How are you replaying history? If you are using `WorkflowReplayer.replayWorkflowExecution` then when you [construct ](https://github.com/temporalio/sdk-java/blob/a41c64ece3876f584ebde70903668b817c5455d8/temporal-sdk/src/main/java/io/temporal/internal/common/WorkflowExecutionHistory.java#L60C10-L60C34)`WorkflowExecutionHistory` you need to specify the workflow ID

@Quinn-With-Two-Ns sorry, i am not sure i understand.. I am not doing anything complicated in my code if you see it. my workflow implementation is pretty simple, it only triggers a child workflow. I am not doing any special replaying in there. Any replay is being done in the replay test which is written using instructions at https://docs.temporal.io/dev-guide/java/durable-execution#add-replay-test . I don't see any specific instructions on providing a workflow ID here if i am providing a history extracted from temporal

This is the workflow implementation - https://github.com/gauravojha/learningTemporal/blob/652d2ba76e80b7d1a96946fae42b3d1dec0b3b3f/src/main/java/dev/ojha/learningtemporal/workflows/HelloWorldWorkflowImpl.java#L35-L40

This is the only place where any replay happens (in the WorkflowReplayer in a unit test) -  https://github.com/gauravojha/learningTemporal/blob/652d2ba76e80b7d1a96946fae42b3d1dec0b3b3f/src/test/java/dev/ojha/learningtemporal/TemporalTesting.java#L45

From [the forum question](https://community.temporal.io/t/workflowreplayer-replayworkflowexecution-throwing-nondeterministicexception-when-reading-workflow-id-from-workflow/12040/6) where this is originally posted, it seems to be a bug in the SDK? The repository I have attached is a very small repository which can be used to reproduce the error. The entire history is downloaded from temporal UI after a sample workflow got over from the above repro repo, so I think I am not constructing the history, it is a history which temporal gives me if I am not mistaken?


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-10 13:17:33.000 UTC</summary>

Where you are calling the replayer you are not specifying the workflow ID. You need to specificy a workflow ID when using the replayer since it is not always in history.

```
        assertDoesNotThrow(() -> WorkflowReplayer.replayWorkflowExecution(eventHistoryFile,
                HelloWorldWorkflowImpl.class));
```

needs to be something like

```
        assertDoesNotThrow(() -> WorkflowReplayer.replayWorkflowExecution(WorkflowExecutionHistory.WorkflowExecutionHistory(WorkflowHistoryLoader.readHistory(eventHistoryFile), "YOUR WORKFLOW ID"),
                HelloWorldWorkflowImpl.class));
```

Reactions: ‚ù§Ô∏è 1

</details>

<details>
<summary><strong>gauravojha</strong> commented on 2024-05-10 16:32:12.000 UTC</summary>

Got it.. Let me try @Quinn-With-Two-Ns, and thank you for pointing in the right direction, that worked on the sample repo I shared above :)  .. i couldnt find this recommendation in the starting replay test documentation. If this is a critical statement, I feel this should be mentioned in the intial stages in the document, since as a new user I may end up only looking at the first recommendation from the doc? 

Just adding some more color to this. So we wrote tests for 10 different workflows, and only one of them failed. Rest 9 passed, and we didn't have to pass in a workflow ID to 9 which passed, as we didn't get to the point that we may have to specify the workflow ID. If the following recommendation by you would have been mentioned in the initial stags of the replay test document, it would have helped us keep an eye out for it. Hope this helps?

> You need to specificy a workflow ID when using the replayer since it is not always in history

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-14 14:33:21.000 UTC</summary>

Yes I agree we should improve the documentation here. Passing the workflow ID is only important if the workflow uses the workflow ID as part of its logic which most don't.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-01 16:40:16.000 UTC</summary>

Workflow ID is now in the [WorkflowExecutionStartedEventAttributes](https://github.com/temporalio/api/blob/52b8544d8f7e27883c0e93a23275098b1c99b992/temporal/api/history/v1/message.proto#L83) so the SDK can automatically extract it if it was written

Reactions: üëç 1

</details>

<details>
<summary><strong>dmytrodanilenkov</strong> commented on 2025-06-03 19:45:51.000 UTC</summary>

@Quinn-With-Two-Ns can you look to my PR?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-03 20:25:06.000 UTC</summary>

@dmytrodanilenkov Yes I looked and approved CI to run yesterday and today.

</details>


---

<a id="1876"></a>

### #1876: WorkflowLocal shares initial value between all Workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1876 |
| **State** | CLOSED |
| **Author** | dano (Dan O'Reilly) |
| **Created** | 2023-09-28 17:48:59.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-03 18:16:41.000 UTC |
| **Closed** | 2023-10-02 23:52:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
If I create a `WorkflowLocal` via `WorkflowLocal.withInitial() -> new MyClass())`, I get a unique instance of `MyClass` the first time I call `workflowLocal.get()` in a given Workflow.

## Actual Behavior
I get the same instance of `MyClass` returned in every Workflow.

## Steps to Reproduce the Problem

This test demonstrates the issue:

``` java
    @Test
    void test(TestWorkflowEnvironment env, WorkflowClient client, Worker worker) {
        worker.registerWorkflowImplementationFactory(ChildWf.class, () -> () -> {
            var r = ref.get();
            System.out.println(r.get());
        });
        worker.registerWorkflowImplementationFactory(ParentWf.class, () -> () -> {
            var r = ref.get();
            r.set("hi");
            Workflow.newChildWorkflowStub(ChildWf.class).executeChild();
        });
        env.start();
        client.newWorkflowStub(ParentWf.class, WorkflowOptions.newBuilder()
                        .setTaskQueue(worker.getTaskQueue())
                .validateBuildWithDefaults()).execute();
    }

    private static final WorkflowLocal<AtomicReference<String>> ref = WorkflowLocal.withInitial(() -> new AtomicReference<>("bye"));

    @WorkflowInterface
    public interface ParentWf {
        @WorkflowMethod
        void execute();
    }

    @WorkflowInterface
    public interface ChildWf {
        @WorkflowMethod
        void executeChild();
    }
```
This should print "bye" (which is the 1.19.1 behavior), but instead it prints "hi".

## Specifications
  - Version: 1.21.1


#### Comments (8)

<details>
<summary><strong>dano</strong> commented on 2023-09-28 19:37:17.000 UTC</summary>

I took a crack at implementing a fix for this here: https://github.com/temporalio/sdk-java/compare/master...dano:sdk-java:fix-wflocal-caching?expand=1

It doesn't break any existing tests, and fixes the issue I'm seeing. If it seems like the right approach, I can clean up the tests a bit, add some additional comments, and open a PR.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-02 15:46:50.000 UTC</summary>

@dano Thanks for implementing a fix, thinking about it a bit more I think caching the result of `withInitial` even if implemented correctly is a breaking change to `WorkflowLocal`. Therefore I think we should just remove the caching logic all together.

</details>

<details>
<summary><strong>dano</strong> commented on 2023-10-02 16:17:10.000 UTC</summary>

@Quinn-With-Two-Ns do you mean that this test should pass?
``` java
WorkflowLocal<AtomicInteger> wf = WorkflowLocal.withInitial(() -> new AtomicInteger(0));
assertNotSame(wf.get(), wf.get());
```
Meaning that repeatedly calling `wf.get()` without ever calling `set` always results in the `withInitial` callback being re-executed?

It's true that this matches the previous behavior of `WorkflowLocal`, but I think that behavior was surprising and arguably a bug.  `ThreadLocal`, which this API seems to be emulating, only calls `withInitial` once for a given thread. Not caching also makes it tricky to use this API correctly. If you're storing a mutable value, you essentially always have use to the API like this to be safe, which is a bit tedious and error-prone:
```
var myValue = wf.get();
// use myValue here
wf.set(myValue); // Ensure it gets cached.
```
Otherwise, you risk that the `get()` call you made returns a value from the `withInitial` callback that is going to just get thrown away. I actually can't think of a situation where the non-caching behavior is desirable.

That said, it is true that adding caching behavior is a backwards compatibility break. If we must avoid that, even if we agree caching is better behavior, could we add a new factory that implements caching? Something like `withInitialCached`, or just a new `withInitial` overload that takes a `useCaching` boolean?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-02 16:26:11.000 UTC</summary>

>do you mean that this test should pass?

correct

I agree with your points, but backwards compatibility it one of the most important parts of the SDK and we prioritize it above almost everything else. Adding an overload for caching or a different function is a backwards compatible change and that would be OK.

</details>

<details>
<summary><strong>dano</strong> commented on 2023-10-02 16:33:01.000 UTC</summary>

Understood. I will update my branch to add a new API that uses the caching behavior and open a PR

Would you consider deprecating the non-caching `withInitial` API, in favor of the new caching version? If so I'll add that to the branch as well.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-02 16:51:05.000 UTC</summary>

Yes I'd be open to deprecating the non-caching API. 

Note: we will probably never actually remove the API

</details>

<details>
<summary><strong>dano</strong> commented on 2023-10-02 17:32:22.000 UTC</summary>

Thanks, @Quinn-With-Two-Ns. I've opened https://github.com/temporalio/sdk-java/pull/1878.

</details>

<details>
<summary><strong>dano</strong> commented on 2023-10-03 18:16:41.000 UTC</summary>

Thanks for merging the fix, @Quinn-With-Two-Ns. Do you have a rough idea of when a release that includes this fix will be made?

</details>


---

<a id="1832"></a>

### #1832: Support for using Temporal Annotations as Meta Annotation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1832 |
| **State** | OPEN |
| **Author** | madhur-spotnana (Madhur Singal) |
| **Created** | 2023-08-01 18:12:27.000 UTC (2y 5m ago) |
| **Updated** | 2023-08-01 18:16:45.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 0 |
| **Priority Score** | 8 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 4 |

#### Description

**Is your feature request related to a problem? Please describe.**
I am using temporal with a spring boot project and trying to create a custom annotation for defining activity interfaces. I need this custom annotation to define default options for activities like startToCloseTimeout or taskQueue. This is how I am planning to create the annotation:
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ActivityInterface
public @interface MyCustomAnnotation {

  long startToCloseTimeoutMs();

  String taskQueue();
}
```
This does not work because the `@ActivityInterface` cannot be used as [meta annotation](https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.html#beans-meta-annotations).

**Describe the solution you'd like**
Add support for using Temporal annotations (like `@WorkflowInterface`, `@ActivityInterface`, `@WorkflowMethod`) as meta annotations. To do this, the SDK needs to be modified to read the annotation using [this](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/AnnotationUtils.html#findAnnotation-java.lang.Class-java.lang.Class-), which recursively scans for annotation added as meta annotation.

**Describe alternatives you've considered**
To create this custom annotation I have used Byte Buddy to modify my activity interfaces at runtime and add the Temporal annotation where my custom annotation is present.



---

<a id="1708"></a>

### #1708: Synchronous workflow update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1708 |
| **State** | CLOSED |
| **Author** | manuver-khan (Manuver Khan) |
| **Created** | 2023-03-22 08:27:47.000 UTC (2y 9m ago) |
| **Updated** | 2023-06-16 18:43:38.000 UTC |
| **Closed** | 2023-06-16 18:43:38.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 4 |
| **Priority Score** | 8 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

**Is your feature request related to a problem? Please describe.**
Yes

A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
Provide the implementation on the Java SDK for following feature
https://github.com/temporalio/temporal/pull/3822

**Describe the solution you'd like**
https://github.com/temporalio/temporal/pull/3822

**Describe alternatives you've considered**
NA

**Additional context**
https://github.com/temporalio/temporal/pull/3822

#### Comments (4)

<details>
<summary><strong>bergundy</strong> commented on 2023-03-22 15:58:31.000 UTC</summary>

We are currently working on this.

Reactions: üëç 1

</details>

<details>
<summary><strong>jeenadeepak</strong> commented on 2023-04-13 11:39:33.000 UTC</summary>

@bergundy : Any update here?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-04-13 17:27:42.000 UTC</summary>

@jeenadeepak Still in progress, this issue will be closed when it is implemented.

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-16 18:43:38.000 UTC</summary>

Closing as implemented here https://github.com/temporalio/sdk-java/issues/1745 will be release in v1.20

</details>


---

<a id="1417"></a>

### #1417: Aling information provided by metrics temporal_activity_schedule_to_start_latency_seconds_bucket and temporal_workflow_task_schedule_to_start_latency_seconds_bucket

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1417 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2022-09-12 16:54:13.000 UTC (3y 4m ago) |
| **Updated** | 2025-05-16 22:40:26.000 UTC |
| **Closed** | 2025-05-16 22:40:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

reported here https://community.temporal.io/t/workflow-task-metrics-only-have-labels-with-the-workflow-type-none-for-the-java-sdk/5942

There is no alignment in the tags pupulated by both metrics (_temporal_activity_schedule_to_start_latency_seconds_bucket_ and _temporal_workflow_task_schedule_to_start_latency_seconds_bucket_). Either both should populate their respective tags, or none of them should. That is:
- _activity_type_ tag for _temporal_activity_schedule_to_start_latency_seconds_bucket_ . Right now this metric has both tags _activity_type_ and  _workflow_type_  populated.


i.e.: `temporal_activity_schedule_to_start_latency_seconds_bucket{activity_type="PerformB",exception="none",namespace="default",operation="none",query_type="none",signal_name="none",status_code="none",task_queue="metricsqueue",workerCustomTag1="workerCustomTag1Value",workerCustomTag2="workerCustomTag2Value",worker_type="ActivityWorker",workflow_type="MetricsWorkflow",le="0.001",} 0.0`

- _workflow_type_ tag for _temporal_workflow_task_schedule_to_start_latency_seconds_bucket_ . Right now this metric doesn't have the tag _workflow_type_ populated.

i.e.: `temporal_workflow_task_schedule_to_start_latency_seconds_bucket{activity_type="none",exception="none",namespace="default",operation="none",query_type="none",signal_name="none",status_code="none",task_queue="metricsqueue",workerCustomTag1="workerCustomTag1Value",workerCustomTag2="workerCustomTag2Value",worker_type="WorkflowWorker",workflow_type="none",le="0.001",} 0.0`



The documentation should be fixed:
- https://docs.temporal.io/references/sdk-metrics/#workflow_task_schedule_to_start_latency
- https://docs.temporal.io/references/sdk-metrics/#activity_schedule_to_start_latency

## Actual Behavior


## Steps to Reproduce the Problem

  1. run https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/metrics
  1. navigate to worker metrics
  1. search for temporal_workflow_task_schedule_to_start_latency_seconds_bucket and temporal_activity_schedule_to_start_latency_seconds_bucket

## Specifications

  - Version: sdk-java 1.16.0
  - Platform:


#### Comments (8)

<details>
<summary><strong>andrey-dubnik</strong> commented on 2022-09-12 17:28:50.000 UTC</summary>

Hi, considering one worker may service multiple workflow and activities types I would rather have everything populated. This seem reproduces self in Java SDK where for Go it worked fine with all the tags present (last time I checked)

Thanks,
A

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-12 17:32:50.000 UTC</summary>

This metric doesn't apply to workflow type (and activity type). "Schedule to start" is a metric of a poller. Poller works on a task queue level. Poller doesn't know about workflow or activity types and doesn't discriminate by them. So, this metric makes sense only for the whole task queue, not per workflow/activity types. Populating this field only creates more metrics with fewer samples for each of them, so damaging the sample size and blurring the meaning of the metric. "Type" tag on this metric is now just artificial for an underlying abstraction, but also detrimental to the usability of the metric.

We will discuss internally if we should just easy-fix this and populate `workflow_type` in Java. Or, actually, `workflow_type` and `activity_type` should be removed from this metric on all SDKs.

Reactions: üëç 2

</details>

<details>
<summary><strong>antmendoza</strong> commented on 2022-09-12 17:49:52.000 UTC</summary>

Please also review https://docs.temporal.io/references/sdk-metrics/#workflow_task_queue_poll_succeed , the documentation mention that the tag workflow_type should be present but it isn't 

`temporal_workflow_task_queue_poll_succeed_total{activity_type="none",exception="none",namespace="default",operation="none",query_type="none",signal_name="none",status_code="none",task_queue="sticky",workerCustomTag1="workerCustomTag1Value",workerCustomTag2="workerCustomTag2Value",worker_type="none",workflow_type="none",} 3.0`

</details>

<details>
<summary><strong>andrey-dubnik</strong> commented on 2022-09-13 11:25:20.000 UTC</summary>

adding a suggestion per the conversation in the community forum

It is not clear from the documentation when the metric is worker/poller specific or a workflow/activity aware as there is a group of metrics specific to the worker which does not apply to the workflow/activity. It would be great if documentation enabled the simplified grouping of such metrics (e.g. additional tag) or had a separate section related to the poller/worker.

</details>

<details>
<summary><strong>fitialovks</strong> commented on 2023-07-07 14:11:06.000 UTC</summary>

We have also found that in Java SDK `workflow_task_queue_poll_succeed` counter doesn't have a `workflow_type` label. It is present in Go SDK and can be easily added in Java, unless there is some performance consideration.

https://github.com/temporalio/sdk-java/blob/15337d9a7cfd12ca1d3096034e017a82f167ea45/temporal-sdk/src/main/java/io/temporal/internal/worker/WorkflowPollTask.java#L172

See also `response.getWorkflowType()` a few lines above.

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-07 15:06:06.000 UTC</summary>

There is no performance consideration. The reason it is not included is because this metric doesn't apply to workflow type because pollers works on a task queue level

</details>

<details>
<summary><strong>fitialovks</strong> commented on 2023-07-07 15:47:37.000 UTC</summary>

Would this be a correct summary of the `workflow_task_queue_poll_succeed` counter state?
1. Java SDK does not have a `workflow_type` label because it's irrelevant for the poller.
2. Go SDK and the dashboard example keep the label for backwards compatibility.

Here is the suggested dashboard https://github.com/temporalio/dashboards/blob/fe62b4e4567951497c511696b527b9037ef0a04f/sdk/sdk-general.json#L834

While irrelevant for the poller, the workflow type may be used for diagnostics. This seems to be the only metric marking a workflow task execution start. In case they are starting and not finishing (no success or failure events) I'd rather know which type it is. Current behavior may force us to use a queue per workflow just to get better metrics.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-07 21:10:58.000 UTC</summary>

Spoke with the team the conclusion was `workflow_type` label is only supported on the Go SDK and should be removed from the documentation since it is not relevant to pollers. I will open an issue with docs to remove.

@fitialovks for your use case you I think the best solution is a server side metric for workflow task timeout https://github.com/temporalio/temporal/issues/2526

</details>


---

<a id="1387"></a>

### #1387: Jackson configuration is cumbersome

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1387 |
| **State** | CLOSED |
| **Author** | Bennett-Lynch (Bennett Lynch) |
| **Created** | 2022-08-27 02:09:52.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-27 06:05:39.000 UTC |
| **Closed** | 2022-08-27 02:23:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | question, wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I need to register [jackson-module-kotlin](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-kotlin) with the Temporal SDK in order to support Kotlin data classes. As far as Jackson goes, this is accomplished with a fairly trivial modification to the `ObjectMapper`. However, the Temporal SDK currently makes it very cumbersome to get a hook onto that reference.

While it's possible to declare your entirely own `DataConverter`, it requires replicating a large portion of the default Temporal configuration. E.g., here is the code I would need to write if I just wanted to make one simple Jackson modification:

```
// Replicate the default Jackson configuration
val mapper = ObjectMapper()
mapper.configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false)
mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
mapper.registerModule(JavaTimeModule())
mapper.registerModule(Jdk8Module())
mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY)

// Enable my Jackson customization
mapper.registerKotlinModule()

// Replicate the default payload converters (in order) while overriding JacksonJsonPayloadConverter
val dataConverter = DefaultDataConverter(
    NullPayloadConverter(),
    ByteArrayPayloadConverter(),
    ProtobufJsonPayloadConverter(),
    ProtobufPayloadConverter(),
    JacksonJsonPayloadConverter(mapper)
)

// Register the global default
GlobalDataConverter.register(dataConverter)
```

This is a lot of boilerplate and prone to falling out of sync with the defaults that we're copy/pasting.

Alternatively, I can use reflection to modify the `ObjectMapper` that is already registered globally. E.g.,

```
val jacksonConverter = DefaultDataConverter.STANDARD_PAYLOAD_CONVERTERS.first { it is JacksonJsonPayloadConverter }
val mapperField = JacksonJsonPayloadConverter::class.java.getDeclaredField("mapper")
mapperField.isAccessible = true
val mapper = mapperField.get(jacksonConverter) as ObjectMapper
mapper.registerKotlinModule()
```

This is of course hacky, but I actually prefer it since I know my settings won't drift out of sync from Temporal's default configuration, and I'll get an explicit failure if something breaks with the reflection.

It would be nice if it was simpler and easier to be able to customize the Jackson-level configuration. Some potential solutions:

1. Similar to exposing a global `DataConverter`, expose a global `ObjectMapper`
2. Expose properties for `List<PayloadConverter>` and `ObjectMapper` that would allow a user to drill down into the current mapper to modify it (this still feels a little hacky, since I would rather treat the current mapper as immutable)
3. Expose something like a `UnaryOperator<ObjectMapper>` that allows a user to customize the mapper alongside Temporal's existing default configuration
4. Expose an environment variable that will trigger Temporal to call `mapper.registerKotlinModule()`
5. Expose an environment variable that will trigger Temporal to call `mapper.findAndRegisterModules()`

Related:
1. https://community.temporal.io/t/hi-deserialization-problem/474/4
6. https://github.com/temporalio/sdk-java/issues/139

Version: `1.16.0`


#### Comments (8)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-27 02:23:50.000 UTC</summary>

You don't need any of these complicated ways. 
Create a new `DataConverter` using `DefaultDataConverter#newDefaultInstance()`. Create new `JacksonJsonPayloadConverter` with a `ObjectMapper` configured the way you need. Register your custom `JacksonJsonPayloadConverter` on the created `DefaultDataConverter` using `DefaultDataConverter#withPayloadConverterOverrides`.
Register the resulted `DataConverter` wherever you need (WorkflowClientOptions or GlobalDataConverter)

A similar thing is done in this sample: https://github.com/temporalio/samples-java/blob/708324ffd1599df4d593b411e9516424be096033/src/main/java/io/temporal/samples/payloadconverter/crypto/Starter.java#L49

it‚Äôs not the most obvious interface and not the best names, I agree. But it does the job and we will not change it already for the sake of maintaining compatibility.

Exposing a global ObjectMapper is not a congruent option to our approach to payload converters, because some projects may not be using Jackson at all. User configured ObjectMapper is not an essential piece for a Temporal app or framework. 

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-08-27 04:36:05.000 UTC</summary>

Ah, I missed the `withPayloadConverterOverrides` method. That simplifies things a little bit, thanks. But it seems like I still need to replicate the following code:

https://github.com/temporalio/sdk-java/blob/d2edb5489d9d8e1185e9fcca70208dafc540c82f/temporal-sdk/src/main/java/io/temporal/common/converter/JacksonJsonPayloadConverter.java#L43-L51

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-08-27 04:50:50.000 UTC</summary>

For anyone else who stumbles upon this, I ended up with a solution like this:

```
val mapper = ObjectMapper().apply {
    configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false)
    configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
    findAndRegisterModules()
    setVisibility(PropertyAccessor.FIELD, Visibility.ANY)
}
val dataConverter = DefaultDataConverter.newDefaultInstance()
    .withPayloadConverterOverrides(JacksonJsonPayloadConverter(mapper))
GlobalDataConverter.register(dataConverter)
```

*\<edit\>* Now this:

```
val mapper = KotlinObjectMapperFactory.new()
val jacksonConverter = JacksonJsonPayloadConverter(mapper)
val dataConverter = DefaultDataConverter.newDefaultInstance()
    .withPayloadConverterOverrides(jacksonConverter)
GlobalDataConverter.register(dataConverter)
```

Reactions: üëç 1

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-27 04:58:17.000 UTC</summary>

@Bennett-Lynch You may also want to check out this class from our kotlin module: https://github.com/temporalio/sdk-java/blob/master/temporal-kotlin/src/main/kotlin/io/temporal/common/converter/KotlinObjectMapperFactory.kt

Reactions: üëç 1

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-08-27 05:00:39.000 UTC</summary>

> @Bennett-Lynch You may also want to check out this class from our kotlin module: https://github.com/temporalio/sdk-java/blob/master/temporal-kotlin/src/main/kotlin/io/temporal/common/converter/KotlinObjectMapperFactory.kt

Oh, awesome. Is there anyway the default configuration could pick this one up automatically? Either by using SPI or class path detection. Right now I'm having to manually set the global in my startup configuration and with a JUnit extension for tests.

Also it looks like the above class is missing the following:
```
configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false)
```

Perhaps both should stem from a common default?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-27 05:19:22.000 UTC</summary>

We are not gonna play with SPI as a part of the configuration of the core sdk. The consequences may be too severe if somebody has a magically picked up converter that they don‚Äôt expect to have. The benefits are not worth the risks.
Also, we do fully expect every project to customize their own Jackson (or another serializer) settings and these classes that we provide are just a starting point for users. For example, this configuration is not enough to handle some polymorphic class structures. So we are not saying that this configuration makes sense to every project and there likely will never be such a thing, so we will not automatically load or pick it up from the classpath. 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-27 05:47:15.000 UTC</summary>

> Perhaps both should stem from a common default?

Yeah, it looks like I made a fix only in java config some time ago.
https://github.com/temporalio/sdk-java/pull/1388

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-08-27 06:05:39.000 UTC</summary>

Offering automatic configuration via class-path module detection is a very convenient utility. Without it, I'll now be littering any project using Temporal and Kotlin with manual overrides in both prod/test configuration (which are somewhat cumbersome to insert, due to their global nature). In my case, I'm perfectly happy with the default serialization configuration otherwise. If including such detection in `temporal-kotlin` is too risky, I personally would love to have a separate and dedicated module option, like `temporal-kotlin-jackson`. Just my 2 cents, but I respect your opinion as the maintainer.

</details>


---

<a id="1241"></a>

### #1241: DynamicWorkflow not taking in account WorkflowImplementationOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1241 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-06-01 15:25:50.000 UTC (3y 7m ago) |
| **Updated** | 2024-03-21 02:30:21.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 6 |
| **Priority Score** | 8 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | Next |
| **Reactions** | üëç 1 |

#### Description

        WorkflowImplementationOptions options =
        WorkflowImplementationOptions.newBuilder()
            .setFailWorkflowExceptionTypes(NullPointerException.class)
            .build();
       worker.registerWorkflowImplementationTypes(options, DynamicGreetingWorkflowImpl.class);

throwing NullPointerException inside Dynamic workflow (workflow that implements DynamicWorkflow interface) 
does not take in account WorkflowImplementationOptions and will not fail when NPE is thrown. This works fine for "normal" workflow impls which would fail at this point.



#### Comments (6)

<details>
<summary><strong>drewhoskins-stripe</strong> commented on 2022-11-16 23:46:13.000 UTC</summary>

I ran into this bug today.  Any ETA for a fix?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-17 01:29:02.000 UTC</summary>

@drewhoskins-stripe Not yet, Drew. But I will put it up for prioritization or may take it during the next Bulk Bug Squash that I am able to do.

</details>

<details>
<summary><strong>drewhoskins-stripe</strong> commented on 2022-11-17 17:09:16.000 UTC</summary>

Thanks!

</details>

<details>
<summary><strong>jeffschoner-stripe</strong> commented on 2023-05-24 18:18:11.000 UTC</summary>

@Spikhalskiy Any updates on this one?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-24 18:19:12.000 UTC</summary>

No update at this time

</details>

<details>
<summary><strong>zuodimiaoyun</strong> commented on 2024-03-21 02:30:20.000 UTC</summary>

I have the same problem, do we have a plan to solve it?

</details>


---

<a id="827"></a>

### #827: Provide a recommended way to pass configuration into workflow 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/827 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-19 16:29:33.000 UTC (4y 2m ago) |
| **Updated** | 2021-10-19 17:58:24.000 UTC |
| **Upvotes** | 4 |
| **Comments** | 0 |
| **Priority Score** | 8 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 4 |

#### Description

If dependency injection into the workflow is discouraged, we need to provide a way for an external code to pass all kinds of configurations into Workflow instances. A potential solution to ensure determinism could be implementing it on interceptors level and storing configuration into a (mutable?) side effect and providing a set of handy utility methods (Probably on `Workflow`) to access it in the workflow implementation.


---

<a id="371"></a>

### #371: When a workflow task fails and the workflow is still running, cancel request doesn't seem to work

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/371 |
| **State** | CLOSED |
| **Author** | darewreck54 (Derek) |
| **Created** | 2021-03-01 10:23:38.000 UTC (4y 10m ago) |
| **Updated** | 2021-03-15 09:00:27.000 UTC |
| **Closed** | 2021-03-15 09:00:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 8 |
| **Priority Score** | 8 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I have a case where I'm not able to cancel the workflow.  The workflow itself experience a workflowTaskFail but keeps running infinitely since no timeout was specified which the UI marks as runnings.  When I try to send a request to cancel the workflow, the request return a 204 but the workflow is never canceled and is still running.  However, if i start a new workflow, the same request will actually cancel the workflow.

Below is a screen shot of the workflow history where you can see the results.

![image](https://user-images.githubusercontent.com/16171726/109483919-a4ff1280-7a34-11eb-8ddb-7ac88928f108.png)

## Expected Behavior
I expect that the workflow would cancel if it returns a 204

## Actual Behavior
Request returns a 204 but never cancels.

## Steps to Reproduce the Problem
1) Have a workflowTask fail
2) Try to cancel the workflow
 
## Specifications

  - Version:
  - Platform:


#### Comments (8)

<details>
<summary><strong>samarabbas</strong> commented on 2021-03-01 16:56:32.000 UTC</summary>

Can you share the complete `failure` message in screen shot above.  Also please also share the entire workflow execution history for this run.
Looks like the workflow task is failing most likely due to either workflow implementation logic or might be due to some java sdk issue.  Once the workflow execution goes into this state then workflow cancellation will not work as it requires the workflow task to be successfully processed.  In this situation if you want to stop the workflow execution then your only option is to `Terminate` it.

</details>

<details>
<summary><strong>darewreck54</strong> commented on 2021-03-01 19:41:10.000 UTC</summary>

```
io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 10 of 'EVENT_TYPE_WORKFLOW_TASK_STARTED' type. IsReplaying=false, PreviousStartedEventId=10, workflowTaskStartedEventId=10, Currently Processing StartedEventId=10 
io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:193)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleEvent(ReplayWorkflowRunTaskHandler.java:140)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:180)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:150)
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:201)
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:114)
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:314)
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:280)
io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
java.lang.Thread.run(Thread.java:748)

Caused By: java.lang.RuntimeException: WorkflowTask: failure executing SCHEDULED->WORKFLOW_TASK_STARTED, transition history is [CREATED->WORKFLOW_TASK_SCHEDULED] 
io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:140)
io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:91)
io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:63)
io.temporal.internal.statemachines.WorkflowStateMachines.handleEventImpl(WorkflowStateMachines.java:210)
io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:178)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleEvent(ReplayWorkflowRunTaskHandler.java:140)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:180)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:150)
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:201)
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:114)
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:314)
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:280)
io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
java.lang.Thread.run(Thread.java:748)

Caused By: java.lang.NullPointerException: type is marked non-null but is null 
....
```

What is the proper way to deal with exceptions thrown  in your workflow entry point?  It looks like i need to throw a specific type of exception so that temporal knows how to put it in a state taht can be canceled?

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-03-01 21:30:35.000 UTC</summary>

What is the stack trace for the last NullPointerException? Is it happening in your workflow code?

</details>

<details>
<summary><strong>darewreck54</strong> commented on 2021-03-02 00:26:24.000 UTC</summary>

@vitarb the stack trace is specific to my workflow code where a value was null when it shouldn't be.  I'm wondering how I'm suppose to properly handle it, so that the workflow will fail automatically without forcing me to send at terminate command

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-03-02 00:30:07.000 UTC</summary>

By default NPE (as well as any unknown exception) will cause the workflow to get stuck. This is to give you chance to find the bug and fix it through a new deployment. If you want your workflow to fail on all exceptions specify it through  WorkflowImplementationOptions.failWorkflowExceptionTypes:
```java
    worker.registerWorkflowImplementationTypes(
        WorkflowImplementationOptions.newBuilder()
            .setFailWorkflowExceptionTypes(Throwable.class)
            .build(),
        <YourWorkflowClass>.class);
```

</details>

<details>
<summary><strong>darewreck54</strong> commented on 2021-03-02 00:52:27.000 UTC</summary>

thanks! @mfateev 

</details>

<details>
<summary><strong>darewreck54</strong> commented on 2021-03-02 01:03:25.000 UTC</summary>

Just thinking out loud here.  In the case a user wants to trouble shoot, after a new deployment would you `replay` which would start from where it left off?  However, if there is something wrong with the inputs into the workflow then the only solution would to start the workflow with the correct input?  Does that sound correct?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-03-02 02:00:42.000 UTC</summary>

Yes, you cannot change inputs after the workflow has started.

</details>


---

<a id="2671"></a>

### #2671: Tracing - Native OpenTelemetry Interceptors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2671 |
| **State** | CLOSED |
| **Author** | AndresBena19 (Andres Benavides) |
| **Created** | 2025-09-25 15:45:07.000 UTC (3 months ago) |
| **Updated** | 2025-10-06 19:00:14.000 UTC |
| **Closed** | 2025-09-25 22:47:55.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 1 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

###  Is your feature request related to a problem? Please describe.

Currently, Temporal Java SDK users who need OpenTelemetry integration must rely on the temporal-opentracing module with an OpenTelemetry compatibility layer (https://github.com/open-telemetry/opentelemetry-java/tree/main/opentracing-shim).

  There are documented considerations in the https://opentelemetry.io/docs/specs/otel/compatibility/opentracing/#when-to-use, particularly with baggage propagation, as it specifically warns:  _"The related Baggage may not be properly propagated if the OpenTelemetry API is consumed along the OpenTracing Shim."_, _"Consuming both the OpenTracing Shim and the OpenTelemetry API in the same codebase is not recommended for the following scenarios"_

  The documentation explicitly recommends against using the shim when:  _"consuming both OpenTracing Shim and OpenTelemetry API in the same codebase,"_ which is precisely the scenario I am facing while trying to use [OpenTelemetry Baggage Span Processor.](https://github.com/open-telemetry/opentelemetry-java-contrib/tree/main/baggage-processor)

  As OpenTracing is in maintenance mode and OpenTelemetry is the industry standard (https://www.cncf.io/projects/opentelemetry/), a native implementation would provide the recommended path forward for reliable, feature-complete tracing in Temporal workflows.

###  Describe the solution you'd like

 I would like to contribute with a new temporal-opentelemetry module that provides native OpenTelemetry integration for the Temporal Java SDK. This module:

  1. Offers direct OpenTelemetry integration without requiring compatibility shims
  2. Provides full W3C TraceContext compatibility
  4. Integrates seamlessly with the broader OpenTelemetry ecosystem

  The module will be similar to opentracing but using native opentelemetry API components

###  Describe alternatives you've considered
  1. Continuing to use temporal-opentracing with the OpenTelemetry compatibility layer, but add new SpanProcessor to capture the baggage data but not using the recommend approach
 2. Create custom temporal interceptors in order to create out own traces and span using open-telemetry directly  


###   Additional context
This implementation parallels the structure of the `temporal-opentracing` module, making it easy for users to migrate to use native opentelemetry instrumentation without configure a shim/bridge. It provides a cleaner, more efficient way to integrate Temporal with OpenTelemetry observability stacks.



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-25 22:56:42.000 UTC</summary>

Yes we would like to add pure open telemetry tracing interceptor. The exact standard still needs to be designed across our various SDKs so this is something that would need to be done by a core Temporal member.

If you would like to share your own implementation of an open telemetry interceptor I would encourage you to share it on our [code exchange](https://temporal.io/code-exchange)



</details>


---

<a id="2508"></a>

### #2508: The version of grpc needs to be updated

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2508 |
| **State** | CLOSED |
| **Author** | fatekingsama (Hui Qiao) |
| **Created** | 2025-05-06 01:17:10.000 UTC (8 months ago) |
| **Updated** | 2025-05-08 04:11:48.000 UTC |
| **Closed** | 2025-05-07 15:21:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Some classes have been removed in the new version of grpc, and your grpc version is too old, causing startup errors

Caused by: java.lang.NoClassDefFoundError: io/grpc/internal/AbstractManagedChannelImplBuilder
	at java.base/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1027)
	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150)
	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862)
	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:526)
	at io.temporal.serviceclient.ChannelManager.prepareChannel(ChannelManager.java:206)
	at io.temporal.serviceclient.ChannelManager.<init>(ChannelManager.java:118)
	at io.temporal.serviceclient.ChannelManager.<init>(ChannelManager.java:98)
	at io.temporal.serviceclient.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:84)
	at io.temporal.serviceclient.WorkflowServiceStubs.newServiceStubs(WorkflowServiceStubs.java:66)

#### Comments (7)

<details>
<summary><strong>fatekingsama</strong> commented on 2025-05-06 07:04:47.000 UTC</summary>

I‚Äôve submitted a pull request to resolve the problem, but there are a few uncertainties in this update that I‚Äôd appreciate your input on.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-06 15:30:35.000 UTC</summary>

The Java SDK intentionally builds with an older version of gRPC Java to maintain compatibility with the widest range of versions for our users. You are free and encouraged to use a higher version in your end application. The specific error on this issue doesn't really make sense to me since this is a very [old issue](https://github.com/grpc/grpc-java/issues/7552) that shouldn't be an issue for any library that compiled with any version <`1.36.0`

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-06 15:38:22.000 UTC</summary>

I also manually confirmed the Java SDK CI all passes using `grpc-java` with `v1.72.0` as a test runtime depdency

</details>

<details>
<summary><strong>fatekingsama</strong> commented on 2025-05-07 01:26:23.000 UTC</summary>

@Quinn-With-Two-Ns Perhaps your test cases are not comprehensive enough? I have to forcefully upgrade your gRPC version to a newer one in order to avoid runtime errors. This issue doesn‚Äôt only affect your project‚ÄîQuarkus encountered the same error as early as 2023, and they eventually resolved it by updating the gRPC version. [https://github.com/quarkusio/quarkus/issues/37806](url)

</details>

<details>
<summary><strong>fatekingsama</strong> commented on 2025-05-07 01:33:37.000 UTC</summary>

You included some gRPC dependencies that I didn‚Äôt explicitly use, so their versions are brought in transitively through your library. This leads to certain errors, and I don‚Äôt think it‚Äôs fair for users of your library to bear the cost of diagnosing such issues. I firmly believe that open-source communities should strive to keep their third-party dependencies up to date. If some users require older versions of those dependencies, they can simply stick to using an older version of your library.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-07 15:21:03.000 UTC</summary>

>Perhaps your test cases are not comprehensive enough?

My tests are the entire SDK test suite.


>I have to forcefully upgrade your gRPC version to a newer one in order to avoid runtime errors.

Yes I would encourage you to use a later version of gRPC if you are able, I am glad you were able to resolve this issue.

As I said we use an older version of gRPC Java to maintain compatibility with the widest range of versions for our users. This is our teams current policy. I will look at adding the latest version of `grpc-java`  to our CI so we know the SDK will work with the latest version of `grpc-java` 


</details>

<details>
<summary><strong>fatekingsama</strong> commented on 2025-05-08 04:06:48.000 UTC</summary>

@Quinn-With-Two-Ns 
```groovy
// Manually include our versions to resolve incompatibility issues caused by the old gRPC version used in the Temporal SDK
api libs.grpc.inprocess
api libs.grpc.netty.shaded
```

These two JARs are not used directly in our codebase ‚Äî they are transitive dependencies brought in by your SDK. As a result, their versions are inconsistent with the other gRPC dependencies we explicitly use. Unfortunately, gRPC introduced significant breaking changes between these versions, which led to runtime errors in our application.

As I mentioned in the link I shared earlier, Quarkus encountered this exact issue back in 2023 and resolved it by updating their gRPC version. I hope your team can also consider this problem carefully. Over time, more users like myself may be forced to spend time debugging issues like this and adding manual fixes ‚Äî code that ideally shouldn‚Äôt be our responsibility to write.

Of course, I understand it‚Äôs impossible to make every version of your SDK compatible with every user setup. That‚Äôs why I suggest that future releases deprecate support for older gRPC versions. After all, users who need older versions can continue using an older version of your SDK, right?

Of course, this is just a suggestion. I respect your team's decision

</details>


---

<a id="2388"></a>

### #2388: Support testing Schedules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2388 |
| **State** | CLOSED |
| **Author** | lorensr (Loren ‚ò∫Ô∏è) |
| **Created** | 2025-01-24 21:09:53.000 UTC (11 months ago) |
| **Updated** | 2025-01-24 21:51:12.000 UTC |
| **Closed** | 2025-01-24 21:51:12.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 1 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

**Is your feature request related to a problem? Please describe.**

I have to run an instance of the server in order to test Schedules

**Describe the solution you'd like**

Maybe `TestScheduleEnvironment` or [createLocal](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#createlocal)


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-01-24 21:17:06.000 UTC</summary>

> Maybe TestScheduleEnvironment

It may not be reasonable to put an entire reimplementation of schedules in each SDK

> or [createLocal](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#createlocal)

This is a duplicate request of #1804. In the meantime, you can always obtain the CLI and run `temporal server start-dev` as a subprocess which is just what `createLocal` does.

</details>


---

<a id="2305"></a>

### #2305: Test environment hangs if activity is not defined, and `scheduleToStartTimeout` is ignored

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2305 |
| **State** | CLOSED |
| **Author** | rocketraman (Raman Gupta) |
| **Created** | 2024-10-31 15:58:13.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-31 17:53:25.000 UTC |
| **Closed** | 2024-10-31 17:11:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When using the Temporal test environment, if an activity is run which is not registered, the test hangs, and apparently forever. I've set the `scheduleToStartTimeout` to a few seconds but apparently the test Temporal server ignores it.

**Describe the solution you'd like**
Tests should fail immediately when an activity is called that is not registered. Alternatively, or in addition, the `scheduleToStartTimeout` should be respected.

**Describe alternatives you've considered**
None

**Additional context**
Temporal SDK 1.26.1


#### Comments (7)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-31 16:24:23.000 UTC</summary>

Can confirm Test server does support `scheduleToStartTimeout ` timeout 

https://github.com/temporalio/sdk-java/blob/b45e40d4056d4efc522a1e47ad83b1d0a434ecfa/temporal-sdk/src/test/java/io/temporal/workflow/activityTests/ActivityTimeoutTest.java#L282

`scheduleToStartTimeout` is not the right timeout to set if you want the activity to fail in this scenario since even if an activity is not registered on the worker, the server can still attempt to start it as long as a worker is listening on the underlying task queue. You want to set a `*ToCloseTimeout`. The behaviour you are describing is the same behaviour as the real Temporal Server. We do have another feature request for using a different retry policies when under test https://github.com/temporalio/sdk-java/issues/626.

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2024-10-31 16:32:02.000 UTC</summary>

> scheduleToStartTimeout is not the right timeout to set if you want the activity to fail in this scenario since even if an activity is not registered on the worker, the server can still attempt to start it as long as a worker is listening on the underlying task queue.

Ah, really? Looking at [this blog post](https://temporal.io/blog/activity-timeouts), `ScheduleToStart` should be a smaller timeout than any of the `ToClose` timeouts.

[The documentation](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html#setScheduleToStartTimeout(java.time.Duration)) says this:

> Time that the Activity Task can stay in the Task Queue before it is picked up by a Worker.

So if the activity task remains in the task queue (despite workers listening), why wouldn't the `ScheduleToStart` timeout apply?

If what you are saying is true, how would I configure the case in which my workflow can take hours or days of real time (and in my test environment I would use time skipping), but if its not started very quickly I want to bail out?


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-31 16:34:24.000 UTC</summary>

>how would I configure the case in which my workflow can take hours or days of real time, but if its not started very quickly I want to bail out?

You would use `ScheduleToStart `, but as I said an activity type not being registered does NOT cause any issue scheduling an activity, it only causes an issue when executing the activity. 

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2024-10-31 16:49:07.000 UTC</summary>

> > how would I configure the case in which my workflow can take hours or days of real time, but if its not started very quickly I want to bail out?
> 
> You would use `ScheduleToStart `, but as I said an activity type not being registered does NOT cause any issue scheduling an activity, it only causes an issue when executing the activity.

Ok. Isn't that weird and confusing? If an activity type is not registered and therefore an activity is scheduled, but not started, why would `ScheduleToStart` which subsumes both endpoints of this time, not apply? Is there a tracking issue or something I can follow for a timeout that covers the case of an activity not being started because no activity is registered?

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2024-10-31 17:11:33.000 UTC</summary>

Closing this because the behavior is working as designed (though the design seems questionable). I've opened [this community form post](https://community.temporal.io/t/understanding-schedule-to-start-timeout/14937) to explore this topic.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-31 17:13:18.000 UTC</summary>

I think there is a misunderstanding here, to be clear, If an activity type is not registered, but was scheduled **it will still be started** if any worker is listenting on the task queue.

This is how the protocol between the Temporal worker and server works and is important to safely roll out new Workflow/Activity types. Workers poll for work by task queue , not by activity type, if a worker is listening on a task queue it can get any tasks assigned to that task queue. Once a worker picks up a task the server considers that task as started. If the worker does not know how to handle that activity type then the worker will fail that activity attempt, but from the servers perspective the task was started. This behaviour is important when rolling out new types of activities/workflows that old workers may not understand 

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2024-10-31 17:53:24.000 UTC</summary>

Thank you for the explanation about what "started" actually means. I think it would be helpful if the docs included this information because this technical definition of "started" would not match most people's mental model of an activity being "started".

</details>


---

<a id="2075"></a>

### #2075: Add the ability to keep heartbeating while the worker is shutting down

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2075 |
| **State** | OPEN |
| **Author** | mintybayleaf (Bailey) |
| **Created** | 2024-05-23 18:49:56.000 UTC (1y 7m ago) |
| **Updated** | 2024-11-22 05:54:28.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 1 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

**Is your feature request related to a problem? Please describe.**

The `WorkerFactory.shutdown` call starts killing the heartbeats like it says in the documentation with the `ActivityWorkerShutdownException` but what is the point of waiting N units of time with `WorkerFactory.awaitTermination` if right when the worker shutdown is called the heartbeats die and then the activities die off because the heartbeats are no longer going....

**Describe the solution you'd like**

I want the ability to keep heartbeating while the worker is shutting down so my activities can actually finish my activities work with `WorkerFactory.awaitTermination` when my activities have heartbeats. 

For example: If I tell the `awaitTermination` call to wait 25 minutes my heartbeat calls should still be valid for 25 minutes and then the heartbeat call can start reporting the `ActivityWorkerShutdownException`

**Describe alternatives you've considered**

Call ActivityExecutionContext.useLocalManualCompletion() and then use the ManualActivityCompletionClient to heartbeat.

**Additional context**

See the Temporal Java SDK slack thread here: https://temporalio.slack.com/archives/CTT84KXK9/p1716488319315099



#### Comments (1)

<details>
<summary><strong>madhav2302</strong> commented on 2024-07-18 15:47:47.000 UTC</summary>

Do we have a timeline for the fix? 

Reactions: üëç 1

</details>


---

<a id="2046"></a>

### #2046: Failed promise before calling allOf is not failing the wrapped promise.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2046 |
| **State** | OPEN |
| **Author** | awx-michael-wang (Michael Wang) |
| **Created** | 2024-04-29 12:56:15.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-06 03:52:55.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 3 |
| **Priority Score** | 7 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

## Expected Behavior
`Promise.allOf(promises)` should fail as long as one of the `promises` fails, no matter it is already failed before calling the `allOf` or after.

## Actual Behavior
If one `Promise` in `promises` is already failed before calling `allOf`, the failure is ignored.

## How to reproduce

A workflow like following will ended successfully.
```Kotlin
        val promise1 = Async.procedure { throw RuntimeException() }
        val promise2 = Async.procedure {
            // do something else
        }
        someActivity.doSomething()

        Promise.allOf(promise1, promise2).get()
```

## Analysis

`AllOfPromise#addPromise` only handles the promise that is not completed.

## Specifications

  - Version: 1.20.0

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-29 17:50:38.000 UTC</summary>

Yes this is a bug, looks like we ignore the promise if it has completed regardless of how it completed

https://github.com/temporalio/sdk-java/blob/ed211fa611112288b576a2c979be9284e17fec89/temporal-sdk/src/main/java/io/temporal/internal/sync/AllOfPromise.java#L54 

We should check if it has completed exceptionally or not.

Fixing this though could break backwards compatibility since this could effect workflow code.  Any fix will need to make sure to preserve history compatibility with workflows that have this scenario.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-30 23:36:29.000 UTC</summary>

In the mean time the easiest way to workaround this bug I think is to implement a wrapper around `promiseAllOf` to check if any promise passed in failed 

``` java
static Promise<Void> allOf(Promise<?>... promises) {
  for (Promise<?> p : promises) {
      if (p.isCompleted() && p.getFailure() != null) {
        return Workflow.newFailedPromise(p.getFailure());
      }
    }
    return WorkflowInternal.promiseAllOf(promises);
  }
}
```

</details>

<details>
<summary><strong>awx-michael-wang</strong> commented on 2024-05-06 03:52:43.000 UTC</summary>

Thank you. I did implement a similar wrapper:
```Kotlin
fun <T> List<Promise<T>>.safeAllOf(): Promise<Void> {
    val existFailure = this.filter { it.isCompleted }
        .firstNotNullOfOrNull { it.failure }

    return if (existFailure != null) {
        Workflow.newFailedPromise(existFailure)
    } else {
        Promise.allOf(this)
    }
}
```

</details>


---

<a id="1985"></a>

### #1985: Upgrade grpc dependencies

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1985 |
| **State** | CLOSED |
| **Author** | isacandrei (Isac Andrei) |
| **Created** | 2024-02-05 14:56:02.000 UTC (1y 11m ago) |
| **Updated** | 2024-08-12 00:17:52.000 UTC |
| **Closed** | 2024-02-07 18:24:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement, question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We are currently using Quarkus 3.6.9 with the Temporal Java SDK to run Temporal workers. Quakus typically enforces quite a recent version of the `grpc-bom`. In the above mentioned version, it is `1.59.0`, but in the soon to be releases LTS version it will most likely be `1.61.1`.

The problem is that this version introduces breaking changes - [v1.59.0](https://github.com/grpc/grpc-java/releases/tag/v1.59.0), which forces us to enforce a lower version of the GRPC libraries in all projects using the Temporal SDK.

**Describe the solution you'd like**
Upgrade the grpc dependencies to a version > 1.59.

**Describe alternatives you've considered**
Right now, we pinpointing an older version for the `grpc-bom` and that works just fine as long as we don't use grpc for any other use-case within the same service.



#### Comments (7)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-05 15:07:49.000 UTC</summary>

What breaking changes in `1.59.0` are you referring to? The Java SDK with its current dependencies is not affected by the ABI breakage in `1.59.0` I am aware of users successfully using `1.59.0` with the Java SDK.

</details>

<details>
<summary><strong>isacandrei</strong> commented on 2024-02-05 15:16:25.000 UTC</summary>

The problem I ran into was coming from the the test tooling:
```
org.junit.jupiter.api.extension.TestInstantiationException: Failed to create test instance
        at app//io.quarkus.test.junit.QuarkusTestExtension.initTestState(QuarkusTestExtension.java:784)
        at app//io.quarkus.test.junit.QuarkusTestExtension.interceptTestClassConstructor(QuarkusTestExtension.java:750)
        at java.base@17.0.9/java.util.Optional.orElseGet(Optional.java:364)
        at java.base@17.0.9/java.util.ArrayList.forEach(ArrayList.java:1511)
        at java.base@17.0.9/java.util.ArrayList.forEach(ArrayList.java:1511)

        Caused by:
        java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
            at io.quarkus.runner.bootstrap.RunningQuarkusApplicationImpl.instance(RunningQuarkusApplicationImpl.java:90)
            at io.quarkus.test.junit.QuarkusTestExtension.createActualTestInstance(QuarkusTestExtension.java:790)
            at io.quarkus.test.junit.QuarkusTestExtension.initTestState(QuarkusTestExtension.java:778)
            ... 4 more

            Caused by:
            java.lang.reflect.InvocationTargetException
                at java.base/java.lang.reflect.Method.invoke(Method.java:568)
                at io.quarkus.runner.bootstrap.RunningQuarkusApplicationImpl.instance(RunningQuarkusApplicationImpl.java:88)
                ... 6 more

                Caused by:
                java.lang.NoClassDefFoundError: io/grpc/inprocess/InProcessServerBuilder
                    at io.temporal.internal.testservice.TestWorkflowService$Client.<init>(TestWorkflowService.java:135)
                    at io.temporal.internal.testservice.TestWorkflowService.<init>(TestWorkflowService.java:170)
                    at io.temporal.testing.TestWorkflowEnvironmentInternal.<init>(TestWorkflowEnvironmentInternal.java:64)
                    at io.temporal.testing.TestWorkflowEnvironment.newInstance(TestWorkflowEnvironment.java:95)
                    at io.beekeeper.data.governance.service.helpers.TemporalTestSupport.produceTestWorkflowEnvironment(TemporalTestSupport.java:43)
                    at io.beekeeper.data.governance.service.helpers.TemporalTestSupport_ProducerMethod_produceTestWorkflowEnvironment_de1jZMWvwvWHAR2TO30lLYEL0qE_Bean.doCreate(Unknown Source)
                    at io.beekeeper.data.governance.service.helpers.TemporalTestSupport_ProducerMethod_produceTestWorkflowEnvironment_de1jZMWvwvWHAR2TO30lLYEL0qE_Bean.create(Unknown Source)
                    at io.beekeeper.data.governance.service.helpers.TemporalTestSupport_ProducerMethod_produceTestWorkflowEnvironment_de1jZMWvwvWHAR2TO30lLYEL0qE_Bean.get(Unknown Source)
                    at io.beekeeper.data.governance.service.helpers.TemporalTestSupport_ProducerMethod_produceTestWorkflowEnvironment_de1jZMWvwvWHAR2TO30lLYEL0qE_Bean.get(Unknown Source)
                    at io.beekeeper.data.governance.service.workflows.definitions.TenantDataCleanupWorkflowTest_Bean.doCreate(Unknown Source)
                    at io.beekeeper.data.governance.service.workflows.definitions.TenantDataCleanupWorkflowTest_Bean.create(Unknown Source)
                    at io.beekeeper.data.governance.service.workflows.definitions.TenantDataCleanupWorkflowTest_Bean.get(Unknown Source)
                    at io.beekeeper.data.governance.service.workflows.definitions.TenantDataCleanupWorkflowTest_Bean.get(Unknown Source)
                    at io.quarkus.arc.impl.InstanceImpl.getBeanInstance(InstanceImpl.java:325)
                    at io.quarkus.arc.impl.InstanceImpl.getInternal(InstanceImpl.java:309)
                    at io.quarkus.arc.impl.InstanceImpl.get(InstanceImpl.java:190)
                    ... 8 more

                    Caused by:
                    java.lang.ClassNotFoundException: io.grpc.inprocess.InProcessServerBuilder
                        at io.temporal.internal.testservice.TestWorkflowService$Client.<init>(TestWorkflowService.java:135)
                        ... 23 more
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-07 16:37:30.000 UTC</summary>

I don't believe `InProcessServerBuilder` is affected by the ABI breakage. I am not familiar with Quarkus, but I can post a sample showing the `Java-SDK` working with the latest `grpc`.

</details>

<details>
<summary><strong>isacandrei</strong> commented on 2024-02-07 18:24:29.000 UTC</summary>

ok, I dug a little bit more into it. The problem is that the class `io/grpc/inprocess/InProcessServerBuilder` was moved from `io.grpc:grpc-core` to `io.grpc:grpc-inprocess`, which is not included in the temporal-sdk, as it only has been [published](https://mvnrepository.com/artifact/io.grpc/grpc-inprocess) since version 1.58.



Reactions: üëç 2

</details>

<details>
<summary><strong>ggrebert</strong> commented on 2024-08-11 22:14:20.000 UTC</summary>

@Quinn-With-Two-Ns
 
I have the same issue

Description from le GRPC release [1.59.0](https://github.com/grpc/grpc-java/releases/tag/v1.59.0):

> Class io.grpc.internal.AbstractServerImplBuilder is deleted, and no longer in the class hierarchy of the server builders:
> 
> io.grpc.netty.NettyServerBuilder
> io.grpc.inprocess.InProcessServerBuilder

So `InProcessServerBuilder` is inpacted. And in Quarkus, which is using a resent GRPC version this class is not found.



</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-11 23:04:21.000 UTC</summary>

@ggrebert as the issue suggest you may need to include `io.grpc:grpc-inprocess`. The Java SDK is not effected by the issue you liked to.

>Users that recompiled their code using grpc-java [v1.36.0](https://github.com/grpc/grpc-java/releases/tag/v1.36.0) (released on Feb 23, 2021) and later, ARE NOT AFFECTED.

</details>

<details>
<summary><strong>ggrebert</strong> commented on 2024-08-12 00:17:51.000 UTC</summary>

thank tou @Quinn-With-Two-Ns .

In fact, it works by adding the following deps:

```xml
<dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-inprocess</artifactId>
</dependency>
<dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-services</artifactId>
</dependency>
```


</details>


---

<a id="1793"></a>

### #1793: Support for generic workflow failure handler via interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1793 |
| **State** | CLOSED |
| **Author** | ddavidyuk |
| **Created** | 2023-06-20 07:56:49.000 UTC (2y 6m ago) |
| **Updated** | 2023-11-29 15:11:48.000 UTC |
| **Closed** | 2023-11-29 15:11:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We would like to implement a generic interceptor that can detect that the workflow is about to fail and in this case invoke an activity (send email / post a message to kafka / alert).

**Describe the solution you'd like**
Implement `WorkflowInbouldCallsInterceptor.execute`, wrap the code in try / catch and catch the exception. In the catch block invoke our activity. Would be nice to have some static utility method that could tell us that the current exception will fail the workflow, the method should take into account `WorkflowImplementationOptions.failWorkflowExceptionTypes`.

**Describe alternatives you've considered**
The alternative is to use a base workflow class / utility class with try / catch, but still there is no generic way to tell if the current exception will fail the workflow (`WorkflowImplementationOptions.failWorkflowExceptionTypes`).


#### Comments (7)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-21 01:50:47.000 UTC</summary>

There are a few problems with this idea. 

The Temporal service owns workflow execution and could fail a workflow in certain situations without the worker being notified to handle it. An example would be a workflow timeout. 

If we are only talking about workflow failures from exceptions then it is possible, ~but should probably be done in the workflow code.~

</details>

<details>
<summary><strong>ddavidyuk</strong> commented on 2023-06-21 06:30:33.000 UTC</summary>

Hello @Quinn-With-Two-Ns ! I was referring to an already existing interface `io.temporal.common.interceptors.WorkflowInboundCallsInterceptor#execute`, my understanding is that it already executes as part of the workflow code, so the interceptor code will be replayed in case of worker restart for example.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-21 08:20:54.000 UTC</summary>

hm yes you are correcy, my apologies.

 Originally I thought this should be done in the workflow, but looks like the Java SDK does not store `failWorkflowExceptionTypes` in history so exposing in workflows or workflows interceptors exposes a potential non determinism 
 
 I wonder if you could just catch  `WorkflowExecutionException` in the interceptor?  That should be thrown if the workflow has failed.

</details>

<details>
<summary><strong>ddavidyuk</strong> commented on 2023-06-21 10:08:02.000 UTC</summary>

I'll check, but looking at the Temporal SDK code it looks like this exception is thrown one level above the interceptor. Also good point about non-deterministic behaviour, isn't it the case already now? If I replay a workflow with different `WorkflowImplementationOptions.failWorkflowExceptionTypes` I might get different results?


</details>

<details>
<summary><strong>ddavidyuk</strong> commented on 2023-07-20 13:06:01.000 UTC</summary>

Apologies for the late response, I've checked and `WorkflowExecutionException` is not available to the interceptor, we only get `ActivityFailure` in case activity fails for example. `WorkflowExecutionException` is generated further up the stack.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-20 15:10:43.000 UTC</summary>

hm yes I believe you are correct. 

Since calling an activity conditional on an exception matching `failWorkflowExceptionTypes` is not deterministic I don't think we would want to add any feature that encourages this in the SDK.

If you still want to do this you can write your own interceptor or base worker and inject your `failWorkflowExceptionTypes` , but you  would need to be careful if you ever wanted to change `failWorkflowExceptionTypes` while you have workflows running

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 15:11:48.000 UTC</summary>

Closing as not planned since such a utility would not be deterministic. If a users really wants it they can implmenet it themselves since they control `failWorkflowExceptionTypes` and take on the risk of using it correctly.

</details>


---

<a id="1698"></a>

### #1698: WorkflowImplementationOptions.FailWorkflowExceptionTypes ignored for service failures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1698 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2023-03-14 15:50:18.000 UTC (2y 10m ago) |
| **Updated** | 2025-06-17 19:10:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When `WorkflowImplementationOptions.FailWorkflowExceptionTypes` is set to Throwable any workflow task failure leads to workflow failure.

## Actual Behavior
The service rejecting workflow task completion doesn't fail the workflow.


## Steps to Reproduce the Problem

  1. Set an invalid retry policy. For example, use a smaller maximumInterval than InitialInterval.
  1. Set FailWorkflowExceptionTypes to Throwable.
  1. Observe that workflow is stuck in workflow task failure retry loop.

Reproduction:

```
package io.temporal.samples.hello;

import io.temporal.activity.ActivityInterface;
import io.temporal.activity.ActivityMethod;
import io.temporal.activity.ActivityOptions;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowOptions;
import io.temporal.common.RetryOptions;
import io.temporal.serviceclient.WorkflowServiceStubs;
import io.temporal.worker.Worker;
import io.temporal.worker.WorkerFactory;
import io.temporal.worker.WorkflowImplementationOptions;
import io.temporal.workflow.Workflow;
import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;
import java.time.Duration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** Sample Temporal Workflow Definition that executes a single Activity. */
public class HelloActivity {

  // Define the task queue name
  static final String TASK_QUEUE = "HelloActivityTaskQueue";

  // Define our workflow unique id
  static final String WORKFLOW_ID = "HelloActivityWorkflow";

  /**
   * The Workflow Definition's Interface must contain one method annotated with @WorkflowMethod.
   *
   * <p>Workflow Definitions should not contain any heavyweight computations, non-deterministic
   * code, network calls, database operations, etc. Those things should be handled by the
   * Activities.
   *
   * @see io.temporal.workflow.WorkflowInterface
   * @see io.temporal.workflow.WorkflowMethod
   */
  @WorkflowInterface
  public interface GreetingWorkflow {

    /**
     * This is the method that is executed when the Workflow Execution is started. The Workflow
     * Execution completes when this method finishes execution.
     */
    @WorkflowMethod
    String getGreeting(String name);
  }

  /**
   * This is the Activity Definition's Interface. Activities are building blocks of any Temporal
   * Workflow and contain any business logic that could perform long running computation, network
   * calls, etc.
   *
   * <p>Annotating Activity Definition methods with @ActivityMethod is optional.
   *
   * @see io.temporal.activity.ActivityInterface
   * @see io.temporal.activity.ActivityMethod
   */
  @ActivityInterface
  public interface GreetingActivities {

    // Define your activity method which can be called during workflow execution
    @ActivityMethod(name = "greet")
    String composeGreeting(String greeting, String name);
  }

  // Define the workflow implementation which implements our getGreeting workflow method.
  public static class GreetingWorkflowImpl implements GreetingWorkflow {

    /**
     * Define the GreetingActivities stub. Activity stubs are proxies for activity invocations that
     * are executed outside of the workflow thread on the activity worker, that can be on a
     * different host. Temporal is going to dispatch the activity results back to the workflow and
     * unblock the stub as soon as activity is completed on the activity worker.
     *
     * <p>In the {@link ActivityOptions} definition the "setStartToCloseTimeout" option sets the
     * overall timeout that our workflow is willing to wait for activity to complete. For this
     * example it is set to 2 seconds.
     */
    private final GreetingActivities activities =
        Workflow.newActivityStub(
            GreetingActivities.class,
            ActivityOptions.newBuilder()
                .setStartToCloseTimeout(Duration.ofSeconds(2))
                .setRetryOptions(
                    RetryOptions.newBuilder()
                        .setInitialInterval(Duration.ofSeconds(10))
                        .setMaximumInterval(Duration.ofSeconds(5))
                        .build())
                .build());

    @Override
    public String getGreeting(String name) {
      // This is a blocking call that returns only after the activity has completed.
      return activities.composeGreeting("Hello", name);
    }
  }

  /** Simple activity implementation, that concatenates two strings. */
  static class GreetingActivitiesImpl implements GreetingActivities {
    private static final Logger log = LoggerFactory.getLogger(GreetingActivitiesImpl.class);

    @Override
    public String composeGreeting(String greeting, String name) {
      log.info("Composing greeting...");
      return greeting + " " + name + "!";
    }
  }

  /**
   * With our Workflow and Activities defined, we can now start execution. The main method starts
   * the worker and then the workflow.
   */
  public static void main(String[] args) {

    // Get a Workflow service stub.
    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();

    /*
     * Get a Workflow service client which can be used to start, Signal, and Query Workflow Executions.
     */
    WorkflowClient client = WorkflowClient.newInstance(service);

    /*
     * Define the workflow factory. It is used to create workflow workers for a specific task queue.
     */
    WorkerFactory factory = WorkerFactory.newInstance(client);

    /*
     * Define the workflow worker. Workflow workers listen to a defined task queue and process
     * workflows and activities.
     */
    Worker worker = factory.newWorker(TASK_QUEUE);

    /*
     * Register our workflow implementation with the worker.
     * Workflow implementations must be known to the worker at runtime in
     * order to dispatch workflow tasks.
     */
    worker.registerWorkflowImplementationTypes(
        WorkflowImplementationOptions.newBuilder()
            .setFailWorkflowExceptionTypes(Throwable.class)
            .build(),
        GreetingWorkflowImpl.class);

    /**
     * Register our Activity Types with the Worker. Since Activities are stateless and thread-safe,
     * the Activity Type is a shared instance.
     */
    worker.registerActivitiesImplementations(new GreetingActivitiesImpl());

    /*
     * Start all the workers registered for a specific task queue.
     * The started workers then start polling for workflows and activities.
     */
    factory.start();

    // Create the workflow client stub. It is used to start our workflow execution.
    GreetingWorkflow workflow =
        client.newWorkflowStub(
            GreetingWorkflow.class,
            WorkflowOptions.newBuilder()
                .setWorkflowId(WORKFLOW_ID)
                .setTaskQueue(TASK_QUEUE)
                .build());

    /*
     * Execute our workflow and wait for it to complete. The call to our getGreeting method is
     * synchronous.
     *
     * See {@link io.temporal.samples.hello.HelloSignal} for an example of starting workflow
     * without waiting synchronously for its result.
     */
    String greeting = workflow.getGreeting("World");

    // Display workflow execution results
    System.out.println(greeting);
    System.exit(0);
  }
}

```


#### Comments (7)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-14 15:53:46.000 UTC</summary>

This filter/rule is not applied for Service errors. The same way for other SDKs.
I don't think it's an expected behavior either. Users expect exception types in this filter to be applied to workflow code only pretty much.
If we want to make deeper levels of failure tolerance adjustable - we need a separate, more detailed mechanism.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-14 15:56:24.000 UTC</summary>

In addition, it's the Server that is failing the workflow task in this situation, not an SDK/Worker. When the workflow task is already failed by the Server, there is no way for SDK to fail the execution.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2023-11-08 00:38:59.000 UTC</summary>

SDK can fail the execution by emitting FailWorkflowExecution command.

</details>

<details>
<summary><strong>Domonion</strong> commented on 2025-06-17 11:42:10.000 UTC</summary>

are there any updates? 
cc @mfateev @Spikhalskiy 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-17 15:42:37.000 UTC</summary>

@Domonion The situation is still the same as described [here](https://github.com/temporalio/sdk-java/issues/1698#issuecomment-1468367754) 

</details>

<details>
<summary><strong>Domonion</strong> commented on 2025-06-17 17:10:21.000 UTC</summary>

@Quinn-With-Two-Ns are there any plans to change the situation? 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-17 19:10:05.000 UTC</summary>

There is no update on this specific issue. Without knowing more about the your problem I can't say if there is any plans. Temporal is always adding new features, If you can share the particular problem you are encountering then I can provide more detail.

</details>


---

<a id="1333"></a>

### #1333: High level API for schedules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1333 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-07-30 00:19:50.000 UTC (3y 5m ago) |
| **Updated** | 2023-06-15 11:12:33.000 UTC |
| **Closed** | 2023-06-15 11:12:32.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 1 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |
| **Reactions** | üëç 3 ‚ù§Ô∏è 3 |

#### Description

See https://github.com/temporalio/sdk-features/issues/73

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-06-15 11:12:32.000 UTC</summary>

Fixed in #1776 

Reactions: üéâ 1

</details>


---

<a id="1332"></a>

### #1332: Seeing SIGSEGV error while calling WorkflowServiceStubs.newServiceStub

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1332 |
| **State** | CLOSED |
| **Author** | shubhati (Shubham Tiwari) |
| **Created** | 2022-07-29 17:27:11.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-10 21:41:36.000 UTC |
| **Closed** | 2022-08-01 00:23:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |

#### Description

While running workflow worker in kubernetes pod, the below error is seen 
```
 A fatal error has been detected by the Java Runtime Environment:

  SIGSEGV (0xb) at pc=0x0000000000003fd6, pid=7, tid=0x00007fc7329e8ae8

 JRE version: OpenJDK Runtime Environment (8.0_275-b01) (build 1.8.0_275-b01)
 Java VM: OpenJDK 64-Bit Server VM (25.275-b01 mixed mode linux-amd64 compressed oops)
 Derivative: IcedTea 3.17.1
 Distribution: Custom build (Tue Feb 16 18:40:09 UTC 2021)
 Problematic frame:
 C  0x0000000000003fd6

 Core dump written. Default location: //core or core.7

 An error report file with more information is saved as:
 //hs_err_pid7.log
```
 If you would like to submit a bug report, please include
 instructions on how to reproduce the bug and visit:
   https://icedtea.classpath.org/bugzilla 


the hs_err_pid7.log file is uploaded with this issue. The error occurs when newservicestub method is called to start the workflow worker. The code is below
```
PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
        StatsReporter reporter = new MicrometerClientStatsReporter(registry);
        Scope scope = new RootScopeBuilder()
                .reporter(reporter)
                .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));
        HttpServer scrapeEndpoint = startPrometheusScrapeEndpoint(registry, 8002);
        Runtime.getRuntime().addShutdownHook(new Thread(() -> scrapeEndpoint.stop(1)));
        WorkflowServiceStubsOptions options = WorkflowServiceStubsOptions.newBuilder()
                .setMetricsScope(scope)
                .setTarget("temporaltest-frontend.temporal.svc.cluster.local:7233")
                .build();
        WorkflowServiceStubs stubs = WorkflowServiceStubs.newServiceStubs(options);
```

Not able to proceed because of this error. please help me out
[hs_err_pid7.log](https://github.com/temporalio/sdk-java/files/9222049/hs_err_pid7.log)

## Expected Behavior

## Actual Behavior


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version: sdk version 1.12.0
  - Platform: linux machine kubernetes pod


#### Comments (7)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-29 17:33:15.000 UTC</summary>

What specific Linux distribution is used?

</details>

<details>
<summary><strong>shubhati</strong> commented on 2022-07-31 18:35:38.000 UTC</summary>

Linux version: `Linux version 5.4.196-108.356.amzn2.x86_64 (mockbuild@ip) (gcc version 7.3.1 20180712 (Red Hat 7.3.1-13) (GCC)) #1 SMP Thu May 26 12:49:47 UTC 2022`


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-01 00:22:37.000 UTC</summary>

@shubhati I don't think the dump attached to this issue happened on Red Hat Enterprise Linux. I see this in the dump:

```
---------------  S Y S T E M  ---------------

OS:NAME="Alpine Linux"
ID=alpine
VERSION_ID=3.8.2
PRETTY_NAME="Alpine Linux v3.8"
HOME_URL="http://alpinelinux.org"
BUG_REPORT_URL="http://bugs.alpinelinux.org"
```

So, this crash likely happened on Alpine.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-01 00:23:05.000 UTC</summary>

Please reference https://github.com/grpc/grpc-java/issues/8751 for a solution.
Basically, you have three options (other than moving from Alpine):
1. Passing `-Dio.grpc.netty.shaded.io.netty.transport.noNative=true` to JVM. I don't recommend this option long-term as it will have performance implications, but it may be a temporary workaround.
2. LD_PRELOAD fix: https://github.com/grpc/grpc-java/issues/8751#issuecomment-998199569
3. Wait for the v1.15 release of Temporal JavaSDK that brings an updated [grpc-java 1.48 with an updated netty 4.1.77](https://github.com/grpc/grpc-java/releases/tag/v1.48.0) with a [change](https://github.com/netty/netty/pull/12313) that MAY help this issue. UPDATE: v1.15.1 is out.

Closing as this issue is not caused and can't be solved in Temporal JavaSDK.

</details>

<details>
<summary><strong>shubhati</strong> commented on 2022-08-01 05:07:56.000 UTC</summary>

Strange, the output was the content of `/proc/version` file of the pod's VM. But surely will try the solutions suggested. Thanks a lot for quick help @Spikhalskiy 

</details>

<details>
<summary><strong>deltamualpha</strong> commented on 2022-08-10 21:28:55.000 UTC</summary>

I ran into this issue with alpine and 1.14.0 of the SDK; the same version of alpine combined with 1.15.0 did not exhibit the crash after upgrade.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-10 21:41:19.000 UTC</summary>

Thanks, @deltamualpha for the confirmation that it's indeed fixed in the new Netty.

</details>


---

<a id="1310"></a>

### #1310: Provide a way to set Heartbeat details in TestActivityEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1310 |
| **State** | CLOSED |
| **Author** | tylercunnion (Tyler Cunnion) |
| **Created** | 2022-07-16 01:14:27.000 UTC (3y 5m ago) |
| **Updated** | 2023-01-05 22:13:13.000 UTC |
| **Closed** | 2023-01-05 22:13:13.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 1 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

**Is your feature request related to a problem? Please describe.**
It doesn't seem easy (or possible) to test Activity methods which make use of HeartbeatDetails for resuming an aborted process, etc. The `TestActivityEnvironment` does not allow for Activity retries (all exceptions are set to non-retryable), and there is no method for "faking" a previous heartbeat call before calling the Activity method under test.

**Describe the solution you'd like**
I'd like to be able to call a method to simulate a previous heartbeat. Whatever mechanism this is would have to be accessible from the `executeActivity` method [here](https://github.com/temporalio/sdk-java/blob/9d843cd927cc0039eb77d30182080f40926eac62/temporal-testing/src/main/java/io/temporal/testing/TestActivityEnvironmentInternal.java#L270). Since the only real externally-facing part of the test environment is the `TestActivityEnvironment` object itself, that would probably be the place to hook into. We'd have to add something like a `setHeartbeatDetails` with parameters indicating the Activity name to apply this heartbeat to as well as the heartbeat payload. Then, inside `executeActivity` it would call a `getHeartbeatDetails` for the given Activity name which would return the heartbeat payload and clear the buffer. (Definitely not married to any of the specifics here, just my initial thought)

**Describe alternatives you've considered**
Allowing the `TestActivityEnvironment` to retry Activity executions could also work, as long as heartbeats are persisted and available to the retry as normal.
The final option would be to work around this entirely and use `TestWorkflowEnvironment` together with an ad-hoc Workflow that only executes the Activity being tested.

#### Comments (1)

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-09-07 20:49:21.000 UTC</summary>

+1. Have a long-running activity that resumes from a previous heartbeat's checkpoint and it's difficult or not possible to test.

</details>


---

<a id="1163"></a>

### #1163: Allow contributions of tags of root worker metricsscope per workflow execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1163 |
| **State** | OPEN |
| **Author** | mdeinum (Marten Deinum) |
| **Created** | 2022-04-21 06:57:45.000 UTC (3y 8m ago) |
| **Updated** | 2024-12-17 21:26:49.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 1 |
| **Priority Score** | 7 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

We are using Temporal to handle workflows for registrations. Those registrations are for a certain region/country. We are sending the metrics to New Relic to create a dashboard to get insights in how many workflows have started, failed, cancelled or completed. This works fine. The region is part of the input that starts the workflow. 

However we would like to split those metrics based on the region, we tried several hooks but apart from sending a custom metric on the start of a workflow we aren't able to solve this. What we want is that when a workflow starts, it contributes a tag to the metrics (in our case the region) so that we can use that as an additional dimension/facet in New Relic to group things by. 

We are using the Java SDK and haven't found a foolproof way of doing that, apart from a custom metric at the start of the workflow. 

What we currently have is we have a single `WorkflowServiceStubs` which we cannot use to set the region. We tried to create a `WorkflowServiceStubs` instance per region, but that starts to break as soon as we need to react to signals, we there loose the region and cannot use the proper one. 

We tried to create a `WorkflowClientInterceptor` which doesn't give us access to the correct `MetricScope` to add tags. 

We also tried a `ContextPropagator` although we can pass the region around there is no way to contribute it as a tag to the metrics. 

All in all the only thing that worked was a custom metric at the start of a workflow, but that still leaves out the cancelled, failed and completed events we need to have. 

It would be nice to have a way that when starting a workflow, we could add custom tags to the metrics and that those would be added to all events being send to New Relic. Currently it seems to hard or to be to inflexible. 


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-22 06:18:25.000 UTC</summary>

It's not possible right now to set custom tags on core worker metrics from the workflow code. There is no easy, clean and reliable way to achieve and do it with Temporal distributed execution model. For example, an activity worker will somehow have to get custom tags from the workflow execution to fit your "regions" usecase (so, need to bring ContextPropagator here).
We don't have plans to make it possible. Too large pain, customization, and risk of unsafety for a narrow use-case. Core worker metrics should be unified and simple. Giving each workflow execution an opportunity to configure a unique scope for each execution doesn't look like a good practice or a good idea.
Hence, "won't fix".
You can set your own scope in each workflow for your custom workflow metrics though.

> What we currently have is we have a single WorkflowServiceStubs which we cannot use to set the region. We tried to create a WorkflowServiceStubs instance per region, but that starts to break as soon as we need to react to signals, we there loose the region and cannot use the proper one.

You can have separate task queues for each "region" and start separate workers for each of them. Each worker will be configured with its own task queue and its own MetricsScope. This way signals will be routed only to the worker attributed to the right task queue and region and will get correct tags on signals.

</details>


---

<a id="1044"></a>

### #1044: Remote Data Encoder

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1044 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-18 20:54:51.000 UTC (3y 10m ago) |
| **Updated** | 2022-08-05 16:33:48.000 UTC |
| **Closed** | 2022-08-05 16:33:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |

#### Description

Provide a framework for serving and consuming data encoding via HTTP across all our SDKs. 

1. Frees users to write their encryption code in whichever of our SDK-supported languages they prefer.
2. Allows users to restrict access to their encryption keys or KMS API usage to only the remote decoder process rather than developer workstations.
3. Allows `tctl` to encode payloads for `tctl workflow start`. Note: This will not work for any encoders which require workflow context. Fixing this is outside the scope of the MVP

[Remote_Data_Encoder_protocol.pdf](https://github.com/temporalio/sdk-java/files/8100346/Remote_Data_Encoder_protocol.pdf)

GoSDK reference implementation: https://github.com/temporalio/sdk-go/pull/717 https://github.com/temporalio/sdk-go/pull/733

#### Comments (7)

<details>
<summary><strong>robholland</strong> commented on 2022-02-18 21:28:00.000 UTC</summary>

Please note protocol update (Payloads vs Payload): https://github.com/temporalio/sdk-go/pull/733

</details>

<details>
<summary><strong>robholland</strong> commented on 2022-02-18 21:28:38.000 UTC</summary>

The linked PDF is correct and matches https://github.com/temporalio/sdk-go/pull/733

</details>

<details>
<summary><strong>robholland</strong> commented on 2022-07-06 12:21:48.000 UTC</summary>

Go and TS SDKs both have nice APIs for this now, would be great to get this in Java too.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-06 14:06:26.000 UTC</summary>

It's not really our preferred or advised method to do that. It's more of a workaround if the standard approach to data converters is not applicable in extreme scenarios. It should be done at some moment, but I don't see a big need until there is a specific ask. Is a particular client and use case asking for it in Java SDK?

</details>

<details>
<summary><strong>robholland</strong> commented on 2022-07-06 14:41:44.000 UTC</summary>

This is not for extreme scenarios at all, it's a requirement for anyone who is using encryption (or similar use cases) and wants to be able to see the plaintext in the Web UI or tctl output.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-06 14:44:56.000 UTC</summary>

The majority of users should stick to the standard data converters approach for a variety of reasons as long as they could. And security is one of them.

</details>

<details>
<summary><strong>StevenLangbroek</strong> commented on 2022-07-11 06:37:44.000 UTC</summary>

Hey! Temporal Cloud customer here, we'd love for the Java SDK to have parity with the other SDKs in this specific area.

</details>


---

<a id="643"></a>

### #643: Unexpected WFT Completed events in java bench runs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/643 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2021-08-17 16:59:57.000 UTC (4y 4m ago) |
| **Updated** | 2022-04-12 17:25:01.000 UTC |
| **Closed** | 2022-04-12 17:25:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

The Java benches have consistently been having issues with the `reactor_stress` test, resulting in worker logs that look like the below. Eventually this causes the test to time out. I would not discount the possibility that the bencher itself is actually the problem here and not something in the SDK

```
16:54:23.234 [Workflow Executor taskQueue="temporal-bench", namespace="java-bench": 13767] ERROR i.t.i.r.ReplayWorkflowTaskHandler - Workflow task failure. startedEventId=73, WorkflowId=config-driven-throughputstress-re ‚îÇ
‚îÇ actor_stress_i9wr-0-585, RunId=fc0f95b5-58c6-48d4-b069-cf088d2be395. If see continuously the workflow might be stuck.                                                                                                       ‚îÇ
‚îÇ io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 67 of 'EVENT_TYPE_WORKFLOW_TASK_COMPLETED' type. IsReplaying=true, PreviousStartedEventId=66, workflowTaskStartedEventId=73, Currently Pr ‚îÇ
‚îÇ ocessing StartedEventId=66                                                                                                                                                                                                  ‚îÇ
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:193)                                                                                                                 ‚îÇ
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleEvent(ReplayWorkflowRunTaskHandler.java:140)                                                                                                          ‚îÇ
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:180)                                                                                               ‚îÇ
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:150)                                                                                                   ‚îÇ
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:201)                                                                                        ‚îÇ
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:114)                                                                                                         ‚îÇ
‚îÇ     at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:319)                                                                                                                           ‚îÇ
‚îÇ     at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:279)                                                                                                                           ‚îÇ
‚îÇ     at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)                                                                                                                              ‚îÇ
‚îÇ     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)                                                                                                                                      ‚îÇ
‚îÇ     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)                                                                                                                                      ‚îÇ
‚îÇ     at java.lang.Thread.run(Thread.java:748)                                                                                                                                                                                ‚îÇ
‚îÇ Caused by: java.lang.IllegalArgumentException: Unexpected event:event_id: 67                                                                                                                                                ‚îÇ
‚îÇ event_time {                                                                                                                                                                                                                ‚îÇ
‚îÇ   seconds: 1629219263                                                                                                                                                                                                       ‚îÇ
‚îÇ   nanos: 10300937                                                                                                                                                                                                           ‚îÇ
‚îÇ }                                                                                                                                                                                                                           ‚îÇ
‚îÇ event_type: EVENT_TYPE_WORKFLOW_TASK_COMPLETED                                                                                                                                                                              ‚îÇ
‚îÇ task_id: 2107374                                                                                                                                                                                                            ‚îÇ
‚îÇ workflow_task_completed_event_attributes {                                                                                                                                                                                  ‚îÇ
‚îÇ   scheduled_event_id: 65                                                                                                                                                                                                    ‚îÇ
‚îÇ   started_event_id: 66                                                                                                                                                                                                      ‚îÇ
‚îÇ   identity: "1@java-bench-temporal-bench-6f6f76fccf-hpxgm"                                                                                                                                                                  ‚îÇ
‚îÇ }                                                                                                                                                                                                                           ‚îÇ
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleNonStatefulEvent(WorkflowStateMachines.java:419)                                                                                                      ‚îÇ
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventImpl(WorkflowStateMachines.java:215)                                                                                                             ‚îÇ
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:178)                                                                                                                 ‚îÇ
‚îÇ     ... 11 common frames omitted 
```

#### Comments (7)

<details>
<summary><strong>Sushisource</strong> commented on 2021-08-17 17:02:04.000 UTC</summary>

History for the above WF: 
[config driven throughputstress reactor_stress_i9wr 0 585 - fc0f95b5-58c6-48d4-b069-cf088d2be395.json.zip](https://github.com/temporalio/sdk-java/files/7001736/config.driven.throughputstress.reactor_stress_i9wr.0.585.-.fc0f95b5-58c6-48d4-b069-cf088d2be395.json.zip)


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-19 18:40:21.000 UTC</summary>

Occurred during running unit tests towards Temporal docker, so looks like a bug.
https://buildkite.com/temporal/java-sdk/builds/1931#36436399-a39d-499e-94ca-4acf598e6a9a
[java-sdk_build_1931_java-unit-test-with-docker-service.log](https://github.com/temporalio/sdk-java/files/7017060/java-sdk_build_1931_java-unit-test-with-docker-service.log)


</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-08-19 19:58:16.000 UTC</summary>

This test: [workflowsCanBeQueriedAfterEviction](https://github.com/temporalio/sdk-java/blob/25da5d2064a6c024148e236e060c34d286283b56/temporal-sdk/src/test/java/io/temporal/worker/StickyWorkerTest.java#L441)

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-22 22:05:21.000 UTC</summary>

Just a note: happens in `workflowsCanBeQueriedAfterEviction` in a stable manner, every run, it's not a flake. 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-12 04:54:06.000 UTC</summary>

normal WFT
Handle 1 event EVENT_TYPE_WORKFLOW_EXECUTION_STARTED
Handle 2 event EVENT_TYPE_WORKFLOW_TASK_SCHEDULED
Handle 3 event EVENT_TYPE_WORKFLOW_TASK_STARTED

// Eviction from the workflow cache

legacyQuery WFT
Handle 1 event EVENT_TYPE_WORKFLOW_EXECUTION_STARTED
Handle 2 event EVENT_TYPE_WORKFLOW_TASK_SCHEDULED
Handle 3 event EVENT_TYPE_WORKFLOW_TASK_STARTED
Handle 4 event EVENT_TYPE_WORKFLOW_TASK_COMPLETED

normal WFT
Handle 4 event EVENT_TYPE_WORKFLOW_TASK_COMPLETED
^ exception because the state machines of the cached workflow already handled it

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-12 04:59:12.000 UTC</summary>

There are two problems here:
1. State machines should allow partial histories sent with Workflow Tasks to contain events that were already handled
2. We should reset sticky queue on cache invalidation or eviction. We have a task for it: https://github.com/temporalio/sdk-java/issues/883

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-12 05:39:26.000 UTC</summary>

User report about a similar problem: https://community.temporal.io/t/getting-error-in-workflow-when-waiting-for-2-hours-and-querying-at-the-same-time/4398

</details>


---

<a id="396"></a>

### #396: Pluggable activity name provider

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/396 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-03-23 17:35:41.000 UTC (4y 9m ago) |
| **Updated** | 2023-05-30 12:47:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 7 |
| **Priority Score** | 7 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The activity type name is automatically generated from its method name.  Different users of the SDK have different opinions on how this name should be generated. For example, see [this forum post](url).

**Describe the solution you'd like**
The proposal is to make activity name generation pluggable through ClientOptions and WorkerOptions. This way each user can implement its own standard to name activities automatically.



#### Comments (7)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-26 00:21:35.000 UTC</summary>

Also consider feature request made in #467 we might be able to come up with a solution that addresses both at the same time.

</details>

<details>
<summary><strong>kkuntim</strong> commented on 2023-05-18 18:57:03.000 UTC</summary>

We also need this feature; any suggestion on how to implement the same.


</details>

<details>
<summary><strong>kkuntim</strong> commented on 2023-05-18 19:19:40.000 UTC</summary>

Capturing our requirement. 
1. Say I have a DB table migration activity ("migrateTable") and based on need we might end up calling the same activity multiple times for migrating n Tables 
2.  We would like to see the activities as "migrateTable1", "migrateTable2"... instead of "migrateTable 
3. We have defined a name for Activity (using Annotation) 
4. We are able to change the AcvityName in Workflow Implementation code by overriding name Annotation value.
5. The challenge lies in Registering and Starting workers; as we might not know how many times we will end up calling the activity (hence different Names) during workflow execution (in case we are calling the Actitvity in loop).

Is there a workaround or can  we Map same Activity in Worker to Renamed Activities in Workflow Implementation call.
Please suggest... where to make this code change in Java SDk

Thanks in advance
Krishnendu

</details>

<details>
<summary><strong>kkuntim</strong> commented on 2023-05-22 07:32:45.000 UTC</summary>

Hi @mfateev Any suggestions on implementation approach. Thank you.

</details>

<details>
<summary><strong>kkuntim</strong> commented on 2023-05-23 05:46:35.000 UTC</summary>

I have two approach in mind:

1. Instead of exact typename match for a Activity we can go for a pattern match and derive the activity Name from Activity Stub call.
2. Have some kind of out of the box attribute list for Activity and have API to populate the same.
Please suggest...

Thank you
Krishnendu

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 06:08:53.000 UTC</summary>

@kkuntim From your requirements it sounds like you want activity names to be generated  dynamically base on the activity input?
Activity names must be know at worker startup time for routing so this feature cannot meet your requirements. 

I think [this](https://github.com/temporalio/features/issues/141) issue to allow passing some metadata with commands would be a better fit. We could allow passing along a `label` metadata field for activities and child workflows that you could specify how you want and use in the UI.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2023-05-30 12:47:37.000 UTC</summary>

I believe you can implement this logic by implementing custom WorkflowOutboundCallsInterceptor.

</details>


---

<a id="362"></a>

### #362: Connection management issues with Java SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/362 |
| **State** | CLOSED |
| **Author** | kelnos (Brian Tarricone) |
| **Created** | 2021-02-24 00:53:15.000 UTC (4y 10m ago) |
| **Updated** | 2024-12-23 12:50:31.000 UTC |
| **Closed** | 2024-12-23 12:50:31.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 5 |
| **Priority Score** | 7 |
| **Labels** | bug |
| **Assignees** | vitarb |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior

When I re-deploy my Temporal cluster, I expect workers and workflow run initiators to not even notice that the topology of the cluster has changed, or that some hosts have gone away and others have reappeared.  Any connection failures due to these changes should be transparently "fixed up" by the SDK.

## Actual Behavior

During cluster deployments I see timeouts and periods of unavailability (with many log error messages with the GRPC `UNAVAILABLE` error in the activity poller).  Sometimes workflow run invocations fail as well with timeout errors.

## Steps to Reproduce the Problem

  1. Build a temporal cluster with, say, 6 nodes. 
  1. Add some worker nodes implementing a simple workflow, set up to invoke the workflow fairly often, like once every 5 seconds.
  1. Redeploy the entire Temporal cluster.  (In our case, we do a rolling deploy, where we put a new node in, wait for it to join the cluster [checking by polling the cluster metadata endpoint], wait an additional 2 minutes to allow things to settle, and then take the old node out.)
  1. Watch metrics/logs on the worker nodes, and notice errors in the worker/activity pollers, as well as some failures to start workflows.

## Specifications

  - Version: 1.0.5
  - Platform: Linux x86_64

## More Information

Our network topology uses a service mesh sidecar to communicate between hosts.  A Temporal worker (or workflow-run-invoker) is instructed to talk to Temporal by connecting to a port on localhost that is backed by [Envoy](https://www.envoyproxy.io) running in HTTP2 mode.  Envoy will then (over HTTP2+TLS) connect to Envoy running on the Temporal server, which will then connect to the Temporal server itself (again using HTTP2).

In order to accommodate low-traffic workers, initially server-to-server and client-to-Envoy timeouts were set very long, on the order of 10 minutes.  However, that caused up to 10 minute periods of unavailability during deployments.  More recently I have dropped the timeouts down to 65 seconds, and have instructed Envoy to retry transparently on GRPC `UNAVAILABLE` and `DEADLINE-EXCEEDED` errors.  However, we still see intermittent failures during Temporal cluster deployments.

On the workers, we have left all the default timeouts alone in the Temporal client (as they seem fairly sane and short).

#### Comments (5)

<details>
<summary><strong>kelnos</strong> commented on 2021-02-24 21:20:55.000 UTC</summary>

Some logs with stack traces:
```
io.grpc.StatusRuntimeException: UNAVAILABLE: transport is closing
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2658)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:77)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller.run(Poller.java:273)
	at io.temporal.internal.worker.Poller.run(Poller.java:242)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
```
and
```
io.grpc.StatusRuntimeException: UNAVAILABLE: Network closed for unknown reason
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2658)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:77)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller.run(Poller.java:273)
	at io.temporal.internal.worker.Poller.run(Poller.java:242)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
```

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-03-01 19:16:36.000 UTC</summary>

There are two potential issues that can cause this:
1. gRPC backoff keeps increasing if the underlying backend is unavailable and can go up to 2 minutes per retry. We've addressed this by periodically resetting gRPC backoff every 10 seconds.
2. Connections are abruptly closed on the server side and client things that they are still active until TCP timeout occurs. For this issue, in the latest release (1.0.6), we've added simple connection management improvement in #351 which would re-establish connections to the server periodically. Also we've added a keep-alive checking on the client side, but it is currently disabled by default as server doesn't have keep-alive friendly configuration yet. Feel free to experiment with the configuration though (see #367 for the list of config parameters).

We know about these issues, and will be making more improvements in the future, including server-side connection management and enabling keep-alive check by default for all users.

</details>

<details>
<summary><strong>kelnos</strong> commented on 2021-03-02 19:48:01.000 UTC</summary>

Great, thank you @vitarb!  We'll be upgrading and doing some experiments over the next couple days.

</details>

<details>
<summary><strong>kelnos</strong> commented on 2021-03-06 22:48:24.000 UTC</summary>

Ok, we've tried 1.0.6 and enabled the keepalive (with a 30 second interval), and things do definitely seem to be better.  We've been unable to repro the issue (so far) with new workflow run invocations failing, though we still do see a bit of log noise from the activity poller threads.  It does appear that all workflows and activities do end up getting run, though I don't have numbers yet on if there's any increase in latency.

</details>

<details>
<summary><strong>kelnos</strong> commented on 2021-03-29 23:46:37.000 UTC</summary>

Things have been a lot better over the past few weeks, and we've gone through several Temporal cluster deployments without incident.  We've been using the keepalive mechanism with a 30-second ping.

One thing that has been a bit frustrating is that the [logging in Poller.java](https://github.com/temporalio/sdk-java/blob/v1.0.6/temporal-sdk/src/main/java/io/temporal/internal/worker/Poller.java#L70) is causing our pagers to go off, even though the poller reestablishes its connection and recovers on its own.  We end up with 15-20 instances of this error message[0] logged per worker host during the cluster deployment (some coming from `WorkflowPollTask` and some coming from `ActivityPollTask`).

I've considered adding custom rules to avoid paging in this case, but anything I can come up with feels brittle (and also possibly not safe, and could mask real issues), and these custom rules would have to be manually applied to every new service that starts using Temporal.

I think what would help us most is if the logging logic could log at `WARN` for an issue that could be transient, and then only escalate to `ERROR` if it's unable to re-establish a connection within a reasonable amount of time.  (In general we only page for some smallish number of occurrences of `ERROR` logs; some teams do page for `WARN`s but only in cases where there are a significantly large number of them.)

[0] We see several different exception messages on this:
* `UNAVAILABLE: upstream connect error or disconnect/reset before headers. reset reason: connection termination`
* `UNAVAILABLE: transport is closing`
* `DEADLINE_EXCEEDED: deadline exceeded after 69.999973290s. [remote_addr=127.0.0.1/127.0.0.1:17233]`
* `UNAVAILABLE: Network closed for unknown reason`
* `UNAVAILABLE: Subchannel shutdown invoked`

</details>


---

<a id="2746"></a>

### #2746: Jackson 3 support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2746 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-12-09 23:15:13.000 UTC (1 months ago) |
| **Updated** | 2025-12-09 23:15:13.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 0 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 3 |

#### Description

**Is your feature request related to a problem? Please describe.**
Add support for Jackson 3, the next major version of the library the SDK uses for JSON serialization.  

**Describe the solution you'd like**
Add support for Jackson 3 to the Java SDK. This would mainly involve creating a new Jackson 3 JSON data converter, and any other place the SDK calls into Jackson. Since Jackson 3 requires Java 17 at least we will need to support both for the foreseeable future.

**Additional context**
* Spring Boot 4 only has plans to support Jackson 3 long term https://spring.io/blog/2025/10/07/introducing-jackson-3-support-in-spring
* https://github.com/FasterXML/jackson/blob/main/jackson3/MIGRATING_TO_JACKSON_3.md


---

<a id="2474"></a>

### #2474: NonRootBeanPostProcessor eagerly depends on MeterRegistry which can have undesirable side effects

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2474 |
| **State** | CLOSED |
| **Author** | bruto1 |
| **Created** | 2025-04-09 08:44:30.000 UTC (9 months ago) |
| **Updated** | 2025-06-17 16:32:43.000 UTC |
| **Closed** | 2025-06-17 16:32:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
All Meter binders, filters, customizers present in Spring context applied timely and correctly

## Actual Behavior
After updating Temporal libs from 1.22.3 to 1.28.4 NonRootBeanPostProcessor, via Scope in MetricsScopeAutoConfiguration, caused MeterRegistry to be instantiated before MeterRegistryPostProcessor is added to bean factory's postprocessors and thus a lot of code relying on meter binders (like JvmMetricsAutoConfiguration) or Micrometer's globalRegistry containing all meter registries (which are added to it by said MeterRegistryPostProcessor) is unable to create Meters.

This happens because NonRootBeanPostProcessor is instantiated in the same loop as MeterRegistryPostProcessor and they're only added to bean factory later

Spring detects such situations and writes the following log message to make the user aware of them:
```
WARN 27112 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'prometheusMeterRegistry' of type [io.micrometer.prometheusmetrics.PrometheusMeterRegistry] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected/applied to a currently created BeanPostProcessor [nonRootBeanPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies/advisors. If this bean does not have to be post-processed, declare it with ROLE_INFRASTRUCTURE.  
```

So one or both dependencies (NonRootBeanPostProcessor on scope and scope on MeterRegistry) need to be made lazy

## Steps to Reproduce the Problem
You can take the repro case from here: https://github.com/spring-projects/spring-boot/issues/22926#issuecomment-673530300 - it's the same problem that occurred with a different set of libraries

## Specifications

  - Version: 1.28.4
  - Platform: all


#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-04-10 14:18:03.000 UTC</summary>

Hi, can you please included a self contained minimal reproduction with the Temporal SDK. The linked issue does not use the Temporal SDK, thank you.

</details>

<details>
<summary><strong>ajgassner</strong> commented on 2025-04-15 18:05:36.000 UTC</summary>

Could be caused by https://github.com/spring-projects/spring-boot/pull/45202

</details>

<details>
<summary><strong>kurtinaitis</strong> commented on 2025-05-09 13:35:37.000 UTC</summary>

Working correctly with version 1.24.2

</details>

<details>
<summary><strong>bruto1</strong> commented on 2025-05-12 09:19:58.000 UTC</summary>

@kurtinaitis that's because the class causing this problem was added in 1.28.0: https://github.com/temporalio/sdk-java/releases/tag/v1.28.0
https://github.com/temporalio/sdk-java/commit/c6375d676ca1a494bb693b21f3fb268b72a142c9#diff-9114a5eefb4b2ce6e22451e2650bbf67168630cdf3bc2bf0689fbccda393fed6


</details>

<details>
<summary><strong>ragutsky</strong> commented on 2025-05-21 17:38:35.000 UTC</summary>

Metrics exposed by Micrometer disappeared when I updated to 1.28.0 version.

I got the following message during bootstrap:

```
Bean 'io.temporal.spring.boot.autoconfigure.NonRootNamespaceAutoConfiguration' of type [io.temporal.spring.boot.autoconfigure.NonRootNamespaceAutoConfiguration$$SpringCGLIB$$0] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). The currently created BeanPostProcessor [nonRootBeanPostProcessor] is declared through a non-static factory method on that class; consider declaring it as static instead.
```

Spring expects BeanPostProcessor beans to be registered very early in the context lifecycle. Defining one via a non-static method forces early instantiation of the configuration class, which can cause:
- The configuration class itself and its beans to miss being proxied
- Other post-processors to be applied too late

Temporary workaround worked:
1. Added 
```yaml
spring:
  autoconfigure:
    exclude: io.temporal.spring.boot.autoconfigure.NonRootNamespaceAutoConfiguration
```
2. Copy pasted `NonRootNamespaceAutoConfiguration` and defined `NonRootBeanPostProcessor` via a static method:
```java
@Bean
public static NonRootBeanPostProcessor nonRootBeanPostProcessor(...) {
  ...
}
```

Reactions: üëç 1

</details>

<details>
<summary><strong>seanb4t</strong> commented on 2025-05-24 16:08:11.000 UTC</summary>

Definitely buggy - needs to be resolved.

</details>


---

<a id="2413"></a>

### #2413: Adding a new parameter type List to a workflow input causes the data converter to fail

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2413 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2025-02-11 14:32:23.000 UTC (11 months ago) |
| **Updated** | 2025-08-12 16:21:35.000 UTC |
| **Closed** | 2025-08-12 16:21:35.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
Adding new parameters to running/closed workflows should be safe for the data converter and converted to null during replay

## Actual Behavior

#### Adding a new parameter of type List to a workflow input causes the data converter to fail.

From: 
```
        @WorkflowMethod
        String execute(String name);
```
to :

```
        @WorkflowMethod
        String execute(String name, List<String> names);
```

throws during replay 

```
Caused by: java.lang.ClassCastException: class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl cannot be cast to class java.lang.Class (sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl and java.lang.Class are in module java.base of loader 'bootstrap')
	at io.temporal.common.converter.DataConverter.fromPayloads(DataConverter.java:162)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:349)
	at io.temporal.internal.sync.WorkflowExecutionHandler.runWorkflowMethod(WorkflowExecutionHandler.java:71)
```

#### Adding a new parameter of type String or Custom object works as expected.


From: 
```
        @WorkflowMethod
        String execute(String name);
```
to :

```
        @WorkflowMethod
        String execute(String name, String names);

        @WorkflowMethod
        String execute(String name, MyObject names);
```

 

## Steps to Reproduce the Problem

I have attached a project that reproduces the issue 

[Archive.zip](https://github.com/user-attachments/files/18751454/Archive.zip)

## Specifications

  - Version: SDK 1.27.1
  - Platform:


#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2025-02-11 16:12:31.000 UTC</summary>

> Adding new parameters to running/closed workflows should be safe for the data converter and converted to null during replay

~Hrmm, I am not sure this is true across all SDKs. We discard _extra_ arguments if too many come in, but I am not sure we make empty/zero values in all SDKs if the value is not there. In Go we might default to zero value because zero values are clear, but this is not necessarily the case with all SDKs. In .NET for instance we even have a specific error saying not enough payloads are present. If I had strict Java null annotation checking on in my analyzer and I only use the type-safe client calls, and my analyzer expects this parameter to be non-null, it would be surprising/bad if we just made it null. I believe adding a parameter is a backwards incompatible operation and is why we encourage using objects where fields can be added instead.~

~@Quinn-With-Two-Ns may need to double-check my assertions here.~

EDIT: Ignore this, this issue is about Java's inconsistency with itself on extra parameters (generic vs non), not new functionality.

</details>

<details>
<summary><strong>antmendoza</strong> commented on 2025-02-11 18:32:00.000 UTC</summary>

> I believe adding a parameter is a backwards incompatible operation and is why we encourage using objects where fields can be added instead.

Agreed Chad. 
I can update the request to have the data converter behaving consistently, regardless of the parameter type (meaning it should either always fail or never fail).

</details>

<details>
<summary><strong>cretz</strong> commented on 2025-02-11 19:27:27.000 UTC</summary>

Oh, I see now, we do allow extra non-generic parameters, we just don't allow generic parameters due to a bug. Disregard my comments, we should fix it to be consistent I agree.

Reactions: üëç 1

</details>

<details>
<summary><strong>antmendoza</strong> commented on 2025-02-12 06:28:17.000 UTC</summary>

thanks @cretz 

</details>


---

<a id="2132"></a>

### #2132: Add option to configure the deadline of `ChannelManager#getServerCapabilities`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2132 |
| **State** | CLOSED |
| **Author** | fextr |
| **Created** | 2024-07-02 10:56:34.000 UTC (1y 6m ago) |
| **Updated** | 2024-09-25 20:59:57.000 UTC |
| **Closed** | 2024-09-25 20:59:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When I [setRpcTimeout](https://github.com/temporalio/sdk-java/blob/abd9f2d1371a0355c01e85bc03763c79b1846ace/temporal-serviceclient/src/main/java/io/temporal/serviceclient/ServiceStubsOptions.java#L774) in WorkflowServiceStubsOptions it overrides the deadline in [getServerCapabilitiesWithRetryOrThrow](https://github.com/temporalio/sdk-java/blob/abd9f2d1371a0355c01e85bc03763c79b1846ace/temporal-serviceclient/src/main/java/io/temporal/serviceclient/SystemInfoInterceptor.java#L95)

## Actual Behavior

I'm enforced to use deprecated [setHealthCheckAttemptTimeout](https://github.com/temporalio/sdk-java/blob/abd9f2d1371a0355c01e85bc03763c79b1846ace/temporal-serviceclient/src/main/java/io/temporal/serviceclient/ServiceStubsOptions.java#L696) because it is still used in the [ChannelManager](https://github.com/temporalio/sdk-java/blob/master/temporal-serviceclient/src/main/java/io/temporal/serviceclient/ChannelManager.java#L327)

## Steps to Reproduce the Problem

1. Set `rpcTimeout` in `WorkflowServiceStubsOptions`.
2. Observe that it does not override the deadline in `getServerCapabilitiesWithRetryOrThrow`
3. Note the usage of the deprecated `healthCheckAttemptTimeout` in `ChannelManager`.

## Specifications

  - Version: Java SDK 1.24.0


#### Comments (6)

<details>
<summary><strong>fextr</strong> commented on 2024-07-02 10:57:36.000 UTC</summary>

If that is acceptable, I want to contribute to the project and fix this issue.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-02 14:33:11.000 UTC</summary>

 `getServerCapabilities` is intentionally overriding the rpc timeout. If you need to configure a different deadline on  `getServerCapabilities` it would need to be a separate option.

</details>

<details>
<summary><strong>fextr</strong> commented on 2024-07-03 08:39:55.000 UTC</summary>

> `getServerCapabilities` is intentionally overriding the rpc timeout. If you need to configure a different deadline on `getServerCapabilities` it would need to be a separate option.

Hey @Quinn-With-Two-Ns 

Is your suggestion to introduce a new option, such as `serverCapabilitiesTimeout`, in the `ServiceStubsOptions` correct?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 20:02:53.000 UTC</summary>

Yes, it should be called `getSystemInfoTimeout` though `serverCapabilities` is just an internal name to the Java SDK.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-03 20:03:26.000 UTC</summary>

Why do you need to configure the deadline on `getSystemInfo`?

</details>

<details>
<summary><strong>fextr</strong> commented on 2024-07-04 05:25:43.000 UTC</summary>

> Why do you need to configure the deadline on `getSystemInfo`?

We have encountered a problem connecting to Temporal after upgrading Java SDK from version 1.23.2 to 1.24.0. When we increased the timeout problem was solved. Stack trace:

``` java
| 2024-07-01 04:59:31.284 | at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:60) |
| 2024-07-01 04:59:31.280 | at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.getSystemInfo(WorkflowServiceGrpc.java:4645) |
| 2024-07-01 04:59:31.280 | at io.temporal.serviceclient.SystemInfoInterceptor.getServerCapabilitiesOrThrow(SystemInfoInterceptor.java:132) |
| 2024-07-01 04:59:31.280 | at io.temporal.serviceclient.SystemInfoInterceptor.lambda$getServerCapabilitiesWithRetryOrThrow$0(SystemInfoInterceptor.java:118) |
| 2024-07-01 04:59:31.280 | at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:69) |
| 2024-07-01 04:59:31.279 | io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 0.398648053s. Name resolution delay 2.493018773 seconds. [closed=[], open=[[buffered_nanos=695520709, remote_addr=namespace-dev.etmgc.tmprl.cloud/18.157.55.99:7233]]] |
| 2024-07-01 04:59:31.279 | at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:268) |
| 2024-07-01 04:59:31.279 | at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:249) |
| 2024-07-01 04:59:31.279 | at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:167) |
| 2024-07-01 04:59:24.584 | 04:59:24.584 [:] [main] INFO  i.t.s.WorkflowServiceStubsImpl - Created WorkflowServiceStubs for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=namespace-dev.etmgc.tmprl.cloud:7233}} |
```

PS: Actual namespace name is different


</details>


---

<a id="2042"></a>

### #2042: Activity options merging logic is not correct

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2042 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2024-04-18 01:21:27.000 UTC (1y 8m ago) |
| **Updated** | 2024-04-23 17:07:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
There are six potential sources for activity options:

1. [WorkflowImplementationOptions#defaultActivityOptions](https://github.com/temporalio/sdk-java/blob/1a0738c068a060f9aa174cf4286ffc357251b2a6/temporal-sdk/src/main/java/io/temporal/worker/WorkflowImplementationOptions.java#L97)
2. [WorkflowImplementationOptions#activityOptions](https://github.com/temporalio/sdk-java/blob/1a0738c068a060f9aa174cf4286ffc357251b2a6/temporal-sdk/src/main/java/io/temporal/worker/WorkflowImplementationOptions.java#L84) map
3. Workflow.setDefaultActivityOptions
4. Workflow.applyActivityOptions map
5. options argument passed to [WorkflowInternal#newActivityStub](https://github.com/temporalio/sdk-java/blob/bff4b6fe837095f610247806e97f03333a454cd0/temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java#L105)
6. activityMethodOptions map argument passed to [WorkflowInternal#newActivityStub](https://github.com/temporalio/sdk-java/blob/bff4b6fe837095f610247806e97f03333a454cd0/temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java#L105)

When all these options are specified for the given activity type, the logical behavior is to merge them in the same order as specified above.

## Actual Behavior

The current logic is split between:

https://github.com/temporalio/sdk-java/blob/8af4a2647dacab2cb0d4a3a613482e00bc297a39/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowInternal.java#L303

and 

https://github.com/temporalio/sdk-java/blob/16755a1bb7ebba29fb820b86a001c079cf4ffb62/temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityInvocationHandler.java#L70

The short description is:

1. options = options argument passed to [WorkflowInternal#newActivityStub] ? WorkflowImplementationOptions#defaultActivityOptions // not that they are not merged if the argument is present.

2. WorkflowImplementationOptions#activityOptions map is overridden by options found in activityMethodOptions map argument passed to WorkflowInternal#newActivityStub

3. options (from step 1) are overridden by a value (with the key equal to the activity type) from the map generated by step (2)

I believe that we should fix the merging logic to match the intuitive behavior explained in the "Expected Behavior" section.

#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-18 05:20:58.000 UTC</summary>

Ignoring backwards compatibility for a moment

>, the logical behavior is to merge them in the same order as specified above.

I would disagree that is intuitive or logical. Before reading the docs I would not expect all the options to be merged in order. Specifically I would not expect the default activity options to be merged with the specific activity options. If I pass a specific option it is because I don't want the default, I would not expect the default to still get merged if I passed a more specific option. Looking at the docs for [setActivityOptions](https://github.com/temporalio/sdk-java/blob/1a0738c068a060f9aa174cf4286ffc357251b2a6/temporal-sdk/src/main/java/io/temporal/worker/WorkflowImplementationOptions.java#L84) supports this.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2024-04-19 03:27:06.000 UTC</summary>

I see two separate questions here:

1. Do we merge options at all, or are they always replaced completely?
2. What is the precedence of merging/replacement?

I personally think we want merging as it allows overriding either specific values as well as all values.

The precedence outlined above is the only one that makes sense to me.

I see a specific exception for testing where the options sometimes need to be forcefully replaced through WorkflowTestEnvironment.

> Looking at the docs for `setActivityOptions` supports this.

The doc explicitly says about merging:

>      * Set individual activity options per activityType. Will be merged with the map from {@link
>      * io.temporal.workflow.Workflow#newActivityStub(Class, ActivityOptions, Map)} which has the
>      * highest precedence.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-19 03:47:55.000 UTC</summary>

>The precedence outlined above is the only one that makes sense to me.

I disagree, I find the outlined approach unintuitive for the reasons I state above , specifically merging defaultActivityOptions and activityOptions, and it disagrees with our documentation. 

</details>

<details>
<summary><strong>mfateev</strong> commented on 2024-04-19 03:56:00.000 UTC</summary>

 Would you specify the currently implemented rules for the 6 sources of options and what is the logic behind them?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-19 14:42:33.000 UTC</summary>

I am specifically talking about:
 
[WorkflowImplementationOptions#defaultActivityOptions](https://github.com/temporalio/sdk-java/blob/1a0738c068a060f9aa174cf4286ffc357251b2a6/temporal-sdk/src/main/java/io/temporal/worker/WorkflowImplementationOptions.java#L97)
[WorkflowImplementationOptions#activityOptions](https://github.com/temporalio/sdk-java/blob/1a0738c068a060f9aa174cf4286ffc357251b2a6/temporal-sdk/src/main/java/io/temporal/worker/WorkflowImplementationOptions.java#L84) map

If I set a default value for something and a specific value I would not expect them to be merged, the documentation does not say they will be merged.

The documentation for `setDefaultActivityOptions` explicitly say it will be overwritten. Ignoring the subjective concept of what is intuitive, I think from a backwards compatibility perspective I don't think we should change how the default options interact.

```
     * These activity options have the lowest precedence across all activity options. Will be
     * overwritten entirely by {@link io.temporal.workflow.Workflow#newActivityStub(Class,
     * ActivityOptions)} and then by the individual activity options if any are set through {@link
     * #setActivityOptions(Map)}
     *
     * @param defaultActivityOptions ActivityOptions for all activities in the workflow.
     */
```

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-19 20:38:59.000 UTC</summary>

To clarify my opinion is default options should not be used if a more specific option for an activity type is specified. A default is a preselect option if no other is present, not a base to build more specific options form . This is 
how we document `setDefaultActivityOptions`
```
  /**
   * Sets the default activity options that will be used for activity stubs that have no {@link
   * ActivityOptions} specified.<br>
   * This overrides a value provided by {@link
   * WorkflowImplementationOptions#getDefaultActivityOptions}.<br>
   * A more specific per-activity-type option specified in {@link
   * WorkflowImplementationOptions#getActivityOptions} or {@link #applyActivityOptions(Map)} takes
   * precedence over this setting.
   *
   * @param defaultActivityOptions {@link ActivityOptions} to be used as a default
   */
  public static void setDefaultActivityOptions(ActivityOptions defaultActivityOptions) {
    WorkflowInternal.setDefaultActivityOptions(defaultActivityOptions);
  }
```

The only time the default options should be considered is if no options are provided so , ignoring `null` options, I believe that is only if this method is used to construct a stub.

```
Workflow.newActivityStub(Class<T> activityInterface)
```

Otherwise, If activity options are provides we should use the activity options, again ignoring `null` options, with this method

```
 /**
   * Creates client stub to activities that implement given interface.
   *
   * @param activityInterface interface type implemented by activities
   * @param options options that together with the properties of {@link
   *     io.temporal.activity.ActivityMethod} specify the activity invocation parameters
   * @param activityMethodOptions activity method-specific invocation parameters
   */
  public static <T> T newActivityStub(
      Class<T> activityInterface,
      ActivityOptions options,
      Map<String, ActivityOptions> activityMethodOptions) 
```
* [WorkflowImplementationOptions#activityOptions](https://github.com/temporalio/sdk-java/blob/1a0738c068a060f9aa174cf4286ffc357251b2a6/temporal-sdk/src/main/java/io/temporal/worker/WorkflowImplementationOptions.java#L84)
* [Workflow.applyActivityOptions](https://github.com/temporalio/sdk-java/blob/ed211fa611112288b576a2c979be9284e17fec89/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowInternal.java#L276)
* `options`
* `activityMethodOptions`

Edit: I believe this is the documented and intended behaviour, but the documentation and code is spread out enough that it is not trivial obvious which we should fix.

</details>


---

<a id="1962"></a>

### #1962: Tracing context does not propagate into .thenCompose

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1962 |
| **State** | CLOSED |
| **Author** | ghaskins (Gregory Haskins) |
| **Created** | 2023-12-31 21:51:42.000 UTC (2 years ago) |
| **Updated** | 2025-01-16 21:07:22.000 UTC |
| **Closed** | 2025-01-16 21:07:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Temporal workflows and activities should generate related spans when the Temporal client is properly configured with OpenTracing interceptors.

## Actual Behavior

Some spans end up severed from the parent.  This seems to be isolated to spans that are generated with a promise chain using .thenCompose.  Other spans seem to work as expected.


## Steps to Reproduce the Problem

  1. Enable trace interceptors
  1. Write a workflow that has at least two activities that are composed serially via .executeAsync -> .thenCompose
  1. Observe that the workflow and first activity end up in one span, and the second activity ends up orphaned within its own span.

## Specifications

  - Version: Temporal Java SDK 1.22.3



#### Comments (6)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-08 22:45:39.000 UTC</summary>

Looking at how `thenCompose` is implemented

```
  @Override
  public <U> Promise<U> thenCompose(Functions.Func1<? super V, ? extends Promise<U>> fn) {
    return then(
        (result) -> {
          if (failure != null) {
            result.completeExceptionally(failure);
            return;
          }
          try {
            Promise<U> r = fn.apply(value);
            result.completeFrom(r);
          } catch (RuntimeException e) {
            result.completeExceptionally(e);
          }
        });
  }
...

  private <U> Promise<U> then(Functions.Proc1<CompletablePromise<U>> proc) {
    CompletablePromise<U> resultPromise = new CompletablePromiseImpl<>();
    if (completed) {
      proc.apply(resultPromise);
      unregisterWithRunner();
    } else {
      handlers.add(() -> proc.apply(resultPromise));
    }
    return resultPromise;
  }

```

Different code paths can be taken if the future is already complete or not by the time it is called. If the future is already complete then `fn` is run in the calling thread so the trace context should be setup, but if the future is not ready it will be run in a callback thread without the context set. 

</details>

<details>
<summary><strong>ghaskins</strong> commented on 2024-03-26 19:22:13.000 UTC</summary>

Just curious if there is any movement on this?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-26 19:35:49.000 UTC</summary>

No update at this time 

</details>

<details>
<summary><strong>ghaskins</strong> commented on 2024-04-15 13:58:35.000 UTC</summary>

Would you consider a PR if I submitted one?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-15 15:22:28.000 UTC</summary>

Yes, PRs are always welcome!

Reactions: üëç 1

</details>

<details>
<summary><strong>ghaskins</strong> commented on 2025-01-08 14:30:29.000 UTC</summary>

Hi @Quinn-With-Two-Ns, I'm just looking at this now and trying to devise a fix.  I may have questions.

</details>


---

<a id="1823"></a>

### #1823: Have a config flag to disable temporal entirely with spring-boot-auto-configure-alpha

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1823 |
| **State** | CLOSED |
| **Author** | stephenchen-humane |
| **Created** | 2023-07-21 18:59:22.000 UTC (2y 5m ago) |
| **Updated** | 2025-05-01 22:41:59.000 UTC |
| **Closed** | 2025-05-01 22:41:58.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Right now not all of our service environments are onboarded with temporal. So with the environments that do not have temporal but include the spring-boot-auto-configure-alpha dependency, there's no easy way to prevent the service from trying to instantiate temporal connection related beans. I have set the connection to `local` at the moment to have it error out and not crash the service.

**Describe the solution you'd like**
a `enabled` feature flag to conditionally create the temporal spring beans

**Describe alternatives you've considered**
I set the connection type to `local` and have it fail intentionally



#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2023-07-24 13:59:20.000 UTC</summary>

Maybe we want to make Temporal beans opt-in instead (e.g. you _have_ to provide a host:port for client bean to work). We should follow other Spring-supported dependencies/clients here which I assume only construct if some opt-in is performed. Have to weigh the costs of compatibility for people relying on this already (despite its alpha status).

Reactions: üëç 1

</details>

<details>
<summary><strong>stephenchen-humane</strong> commented on 2023-07-24 16:47:38.000 UTC</summary>

I agree. Technically, `ServiceStubsAutoConfiguration` is opt-in, because it depends on this condition:
```
@ConditionalOnExpression(
    "${spring.temporal.test-server.enabled:false} || '${spring.temporal.connection.target:}'.length() > 0")
 ```

And `RootNamespaceAutoConfiguration` is dependent on that. 

so I think adding an `enabled` flag that only applies if present should be simple and backwards compatible.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-07-24 16:51:58.000 UTC</summary>

Spring has a number of ways to disable specific auto configurations 

https://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/html/using-boot-auto-configuration.html#using-boot-disabling-specific-auto-configuration



</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-01 22:41:58.000 UTC</summary>

Closing since Spring provides built in way to disable auto configuration

</details>


---

<a id="1430"></a>

### #1430: Workflow.getVersion() could cause NonDeterminsticError with multithreading + timer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1430 |
| **State** | CLOSED |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2022-09-14 23:00:41.000 UTC (3y 3m ago) |
| **Updated** | 2023-07-17 17:48:32.000 UTC |
| **Closed** | 2023-07-17 17:48:32.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

Hey Temporal team,
We found that Workflow.getVersion() is letting workflow thread to yield, which causes NonDeterminsticError because the thread execution ordering is changed ‚Äî this has made it very hard for us to use this getVersion().
Imagine we have two threads:

ThreadA:
```
{
    executeActivity(A)
}
```
ThreadB
```
{
   Workflow.sleep()
}
```
And  thread A is invoked first.
And we got a JSON history for replay test. The history looks like this:
```
WF start
WF task scheduled
WF task started
WF task completed
activity task scheduled
timer scheduled
```

Then we are changing thread A to :
```
{
    if( Workflow.getVersion() >= X ){
        executeActivity(B)
    }
    executeActivity(A)
}
```
Then the replay test gets broken.
Because the thread A will yield at Workflow.getVersion() and thread B will then try to schedule before the activity A.
In Java SDK, it‚Äôs enforcing the eventId to be exactly matched with the history. So the replay test would run into NDE error.

Some thoughts to improve:
I think GoSDK is only forcing within a workflow task completed batch commands. This may be more reasonable because I don‚Äôt think the order really matter within a workflow task results.
Or if we could do special case in Workflow.getVersion() to let it not yield the current thread‚Ä¶



## To reproduce
```
public void anyWorklfowMethod(){
         Async.procedure( ()->{ 
             Workflow.sleep(1s)
         }   
         )
         activityStub.hello()      
}
```
Got a history for replay
Then change the code to:
```
public void anyWorklfowMethod(){
         Async.procedure( ()->{ 
                 Workflow.sleep(1s)
             }   
         )
         Workflow.getVersion("changeId, Workflow.DefaultVersion, 1) 
         activityStub.hello()      
}
```
And this should break the replay test



#### Comments (4)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-14 23:07:26.000 UTC</summary>

Which version of java-sdk are we talking about?
Can you provide original histories and related pieces of code or a reproduction?

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2022-09-14 23:13:34.000 UTC</summary>

> Which version of java-sdk are we talking about? Can you provide original histories and related pieces of code or a reproduction?

These are the versions we are using:
```
io.temporal:temporal-opentracing=1.13.0
io.temporal:temporal-sdk=1.13.0
io.temporal:temporal-serviceclient=1.13.0
io.temporal:temporal-test-server=1.13.0
io.temporal:temporal-testing=1.13.0
```



</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-14 23:40:15.000 UTC</summary>

Confirm. State machine bug.
It's happening here:
https://github.com/temporalio/sdk-java/blob/0ab17d8d913088340a5d8fca61aca06c021f85a1/temporal-sdk/src/main/java/io/temporal/internal/sync/SyncWorkflowContext.java#L678

It needs a very careful and probably very ugly fix to keep it backwards compatible.
Only replay shouldn't yield and ONLY if the actual version from history is default, which means that the original execution didn't have this call.

If we just fix it "right" and make getVersion not yielding, we will break existing histories generated by yielding version.

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2022-09-15 00:51:48.000 UTC</summary>

> Confirm. State machine bug. It's happening here:
> 
> https://github.com/temporalio/sdk-java/blob/0ab17d8d913088340a5d8fca61aca06c021f85a1/temporal-sdk/src/main/java/io/temporal/internal/sync/SyncWorkflowContext.java#L678
> 
> It needs a very careful and probably very ugly fix to keep it backwards compatible. Only replay shouldn't yield and ONLY if the actual version from history is default, which means that the original execution didn't have this call.
> 
> If we just fix it "right" and make getVersion not yielding, we will break existing histories generated by yielding version.

Just an idea. We could add a new field in workflow task started/completed to store some metadata of the sdk for the first workflow task of the workflow. Use the meta data (eg the sdk version) to decide the new behavior . 

This new field can be generic to solve many future problems as well

</details>


---

<a id="1426"></a>

### #1426: Test server timeouts improperly set to 10 years when not user set

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1426 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-14 14:11:54.000 UTC (3y 3m ago) |
| **Updated** | 2024-12-17 21:19:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Current server doesn't set `WorkflowExecutionStartedEventAttributes.workflow_execution_timeout` or `PollActivityTaskQueueResponse.schedule_to_close_timeout` if the user didn't

## Actual Behavior

Test server sets these to 10 years when not set. While this may make sense internally to bound the timer, e.g. the API for https://www.javadoc.io/static/io.temporal/temporal-sdk/1.16.0/io/temporal/activity/ActivityInfo.html#getScheduleToCloseTimeout() should be accurate.

#### Comments (6)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-10-25 15:07:28.000 UTC</summary>

This is a "feature". Instead of just hanging the unit test, we force the workflow to time out in the test environment if nothing would happen with it and it will hang.
But I see how this feature may be confusing. This needs a broader discussion. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-10-25 15:42:43.000 UTC</summary>

I can understand it makes sense to internally bound the timer, but we should make the API responses accurate though if possible

</details>

<details>
<summary><strong>jroof88</strong> commented on 2024-11-05 19:07:57.000 UTC</summary>

Hello. This issue just took down all of our production workflows cause we made an incorrect assumption that all of our Workflow Tests would've caught this issue.

Are there any updates on this? It feels odd to call this a feature since the test environment should mimic the production environment for proper testing. Is there a workaround where maybe instead of actually setting these values on the server we could just validate the config is correct?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-05 19:33:50.000 UTC</summary>

I am sorry to hear this caused an issue for you in production. There is no update here, but I am curious what the exact issue you hit was?

I would think of the test server as a good tool to unit test workflows, but it is no replacement for testing your workflows against a real Temporal cluster with the same settings as your production cluster before going to production.

>It feels odd to call this a feature since the test environment should mimic the production environment for proper testing. 

The overwhelming feedback we have received from users is the test server should optimize for the test experience over mimicking exact server behaviour.

>setting these values on the server we could just validate the config is correct?

Not sure exact settings you are referring to, but in general the Temporal server is the authority on what settings are valid or not valid as for some things it can depend on the servers dynamic configs what values are allowed so the SDK cannot know ahead of time.

</details>

<details>
<summary><strong>jroof88</strong> commented on 2024-11-05 23:48:07.000 UTC</summary>

Thanks for the quick response @Quinn-With-Two-Ns!

Our issue was with the need to set either the `ScheduleToStartTimeout` or `StartToCloseTimeout` for every activity invocation:
```
BadScheduleActivityAttributes: A valid StartToClose or ScheduleToCloseTimeout is not set on ScheduleActivityTaskCommand.
```

> I would think of the test server as a good tool to unit test workflows, but it is no replacement for testing your workflows against a real Temporal cluster with the same settings as your production cluster before going to production.

tbh this just feels like a LOT of work to test workflows then if this is the stance you are taking

> Not sure exact settings you are referring to

I might have used the wrong verbiage. Referring to the ActivityOption settings for timeouts for `ScheduleToStartTimeout` or `StartToCloseTimeout`. My suggestion was maybe there could just be validation in the test server that these are set prior to activity execution:
```go
// Psuedo-Code
func ExecuteActivity(...) error {
  if workflowCtx.ValidateTimeout() {
    // throw error
  }

  // Execute Activity as normal
}
```
I don't know enough about SDK Internals to know if this is feasible. Just throwing ideas out! In the interim, we are adding this validation on our side which feels like something we shouldn't have to worry about.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-06 00:05:41.000 UTC</summary>

>Our issue was with the need to set either the ScheduleToStartTimeout or StartToCloseTimeout for every activity invocation:

Hmm, well this is an options that the SDK can validate SDK side. So the Java SDK does validate that one of these options is set https://github.com/temporalio/sdk-java/blob/c8a27ce9073164141fc1f08ac4c80456f48b3c1d/temporal-sdk/src/test/java/io/temporal/activity/ActivityOptionsTest.java#L65, the test server also has a similar [check](https://github.com/temporalio/sdk-java/blob/c8a27ce9073164141fc1f08ac4c80456f48b3c1d/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java#L1064) as well. Can you share how a some self contained reproduction that passes against the test server but fails against a real server?

</details>


---

<a id="1347"></a>

### #1347: The first getClusterInfo fails after restarting a temporalite cluster in a multi cluster environment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1347 |
| **State** | CLOSED |
| **Author** | neshield (Nathan Shields) |
| **Created** | 2022-08-03 22:12:32.000 UTC (3y 5m ago) |
| **Updated** | 2025-06-03 14:51:50.000 UTC |
| **Closed** | 2025-06-03 14:51:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I am connecting to two different Temporalite clusters. If I turn a cluster off, `getClusterInfo` fails. When I turn the cluster back on, `getClusterInfo` should succeed on the first attempt.

## Actual Behavior
When I turn the cluster back on, `getClusterInfo` fails the first time it is called, and then succeeds after. It does not seem to matter how long this first call is after turning the cluster back on, it still fails. I did not see this same issue on a single cluster setup.

## Steps to Reproduce the Problem

Test code + comments:
```java
        WorkflowFacade primary = supplier.getHealthyFacade().orElseThrow();
        // Turn off primary cluster
        WorkflowFacade fallback = supplier.getHealthyFacade().orElseThrow();
        assertNotEquals(primary, fallback);
        // Turn the primary cluster on again
        // another == fallback, where it should be primary, because the health check on primary failed.
        WorkflowFacade another = supplier.getHealthyFacade().orElseThrow();
        // This assertion fails
        assertEquals(primary, another);
```

Health Check code:
```java
return ListenableFuturesExtra.toCompletableFuture(getService().futureStub()
                    .getClusterInfo(GetClusterInfoRequest.newBuilder().build()))
                    .thenApplyAsync(GetClusterInfoResponse::isInitialized)
                    .orTimeout(2000, TimeUnit.MILLISECONDS);
```

1. Set up an environment with two+ Temporal clusters, henceforth referred to as "primary" and "fallback"
1. Turn on both clusters and getClusterInfo the primary, which will succeed. ‚úÖ 
1. Turn off the primary cluster and getClusterInfo the primary, which will fail. ‚úÖ 
1. Turn **on** the primary cluster and getClusterInfo the primary, which will **fail**. We expect success here. I have waited over 2 minutes with the same result. ‚ùå 
1. getClusterInfo the primary, which will succeed, as expected. ‚úÖ 

Stack traces:
Step 3, after turning off primary:
```
2022-08-03 17:42:52.862  WARN [,,] 41628 --- [ce="default": 1] io.temporal.internal.worker.Poller       : Failure in poller thread Workflow Poller taskQueue="MY_QUEUE", namespace="default": 1

io.grpc.StatusRuntimeException: UNKNOWN: channel closed
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:271) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:252) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:165) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2803) ~[temporal-serviceclient-1.11.0.jar:na]
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:80) ~[temporal-sdk-1.11.0.jar:na]
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37) ~[temporal-sdk-1.11.0.jar:na]
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:266) ~[temporal-sdk-1.11.0.jar:na]
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:231) ~[temporal-sdk-1.11.0.jar:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
Caused by: java.nio.channels.ClosedChannelException: null
	at io.grpc.netty.shaded.io.grpc.netty.Utils.statusFromThrowable(Utils.java:271) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:500) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler.onError(Http2ConnectionHandler.java:641) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders0(DefaultHttp2ConnectionEncoder.java:251) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:167) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:53) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.StreamBufferingEncoder.writeHeaders(StreamBufferingEncoder.java:170) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.StreamBufferingEncoder.writeHeaders(StreamBufferingEncoder.java:158) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.createStreamTraced(NettyClientHandler.java:609) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.createStream(NettyClientHandler.java:592) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.write(NettyClientHandler.java:326) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:709) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:792) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:702) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline.write(DefaultChannelPipeline.java:1015) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannel.write(AbstractChannel.java:301) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue$AbstractQueuedCommand.run(WriteQueue.java:213) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue.flush(WriteQueue.java:128) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue.access$000(WriteQueue.java:34) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue$1.run(WriteQueue.java:46) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	... 1 common frames omitted
Caused by: io.grpc.netty.shaded.io.netty.channel.StacklessClosedChannelException: null
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
```

Step 3 from calling the health check:
```
2022-08-03 17:42:52.885 ERROR [,,] 41628 --- [    Test worker] c.me.temp.TemporalWorkflowFacade  : WorkflowFacade reported the cluster as unhealthy:

java.util.concurrent.ExecutionException: io.grpc.StatusRuntimeException: UNKNOWN: channel closed
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2022) ~[na:na]
	at com.me.temp.TemporalWorkflowFacade.isHealthy(TemporalWorkflowFacade.java:249) 
	at com.me.temp.multicluster.MultiClusterSpringBootAppIntegrationTest.testSupplierReturnsFallbackWhenPrimaryIsUnhealthy(MultiClusterSpringBootAppIntegrationTest.java:75) ~[integrationTest/:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) ~[spring-test-5.3.18.jar:5.3.18]
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) ~[spring-test-5.3.18.jar:5.3.18]
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) ~[spring-test-5.3.18.jar:5.3.18]
	at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:54) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:54) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.rules.RunRules.evaluate(RunRules.java:20) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) ~[spring-test-5.3.18.jar:5.3.18]
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110) ~[na:na]
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58) ~[na:na]
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38) ~[na:na]
	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62) ~[na:na]
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) ~[na:na]
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) ~[na:na]
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) ~[na:na]
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source) ~[na:na]
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:119) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) ~[na:na]
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) ~[na:na]
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) ~[na:na]
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) ~[na:na]
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) ~[na:na]
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) ~[na:na]
	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
Caused by: io.grpc.StatusRuntimeException: UNKNOWN: channel closed
	at io.grpc.Status.asRuntimeException(Status.java:535) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:542) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.grpc.PartialForwardingClientCallListener.onClose(PartialForwardingClientCallListener.java:39) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:23) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.grpc.ForwardingClientCallListener$SimpleForwardingClientCallListener.onClose(ForwardingClientCallListener.java:40) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.temporal.serviceclient.GrpcMetricsInterceptor$MetricsClientCall$1.onClose(GrpcMetricsInterceptor.java:123) ~[temporal-serviceclient-1.11.0.jar:na]
	at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:562) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:70) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:743) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:722) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133) ~[grpc-core-1.46.0.jar:1.46.0]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
	... 1 common frames omitted
Caused by: java.nio.channels.ClosedChannelException: null
	at io.grpc.netty.shaded.io.grpc.netty.Utils.statusFromThrowable(Utils.java:271) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:500) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler.onError(Http2ConnectionHandler.java:641) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders0(DefaultHttp2ConnectionEncoder.java:251) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:167) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:53) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.StreamBufferingEncoder.writeHeaders(StreamBufferingEncoder.java:170) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.handler.codec.http2.StreamBufferingEncoder.writeHeaders(StreamBufferingEncoder.java:158) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.createStreamTraced(NettyClientHandler.java:609) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.createStream(NettyClientHandler.java:592) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler.write(NettyClientHandler.java:326) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:709) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:792) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:702) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline.write(DefaultChannelPipeline.java:1015) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannel.write(AbstractChannel.java:301) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue$AbstractQueuedCommand.run(WriteQueue.java:213) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue.flush(WriteQueue.java:128) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue.access$000(WriteQueue.java:34) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.grpc.netty.WriteQueue$1.run(WriteQueue.java:46) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	... 1 common frames omitted
Caused by: io.grpc.netty.shaded.io.netty.channel.StacklessClosedChannelException: null
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
```

Step 4 after turning primary on:
```
2022-08-03 17:43:11.243  WARN [,,] 41628 --- [ce="default": 4] io.temporal.internal.worker.Poller       : Failure in poller thread Activity Poller taskQueue="MY_QUEUE", namespace="default": 4

io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:271) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:252) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:165) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2852) ~[temporal-serviceclient-1.11.0.jar:na]
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99) ~[temporal-sdk-1.11.0.jar:na]
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39) ~[temporal-sdk-1.11.0.jar:na]
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:266) ~[temporal-sdk-1.11.0.jar:na]
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:231) ~[temporal-sdk-1.11.0.jar:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
Caused by: io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: /127.0.0.1:7233
Caused by: java.net.ConnectException: Connection refused
	at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) ~[na:na]
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777) ~[na:na]
	at io.grpc.netty.shaded.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:330) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:710) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
```

Step 4 calling health check:
```
2022-08-03 17:43:11.310 ERROR [,,] 41628 --- [    Test worker] c.me.temp.TemporalWorkflowFacade  : WorkflowFacade reported the cluster as unhealthy:

java.util.concurrent.ExecutionException: io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2022) ~[na:na]
	at com.me.temp.TemporalWorkflowFacade.isHealthy(TemporalWorkflowFacade.java:249) 
	at com.me.temp.multicluster.MultiClusterSpringBootAppIntegrationTest.testSupplierReturnsFallbackWhenPrimaryIsUnhealthy(MultiClusterSpringBootAppIntegrationTest.java:78) ~[integrationTest/:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) ~[spring-test-5.3.18.jar:5.3.18]
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) ~[spring-test-5.3.18.jar:5.3.18]
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) ~[spring-test-5.3.18.jar:5.3.18]
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) ~[spring-test-5.3.18.jar:5.3.18]
	at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:54) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:54) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.rules.RunRules.evaluate(RunRules.java:20) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306) ~[junit-4.13.2.jar:4.13.2]
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413) ~[junit-4.13.2.jar:4.13.2]
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) ~[spring-test-5.3.18.jar:5.3.18]
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110) ~[na:na]
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58) ~[na:na]
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38) ~[na:na]
	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62) ~[na:na]
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) ~[na:na]
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) ~[na:na]
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) ~[na:na]
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source) ~[na:na]
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:119) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) ~[na:na]
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) ~[na:na]
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) ~[na:na]
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) ~[na:na]
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) ~[na:na]
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) ~[na:na]
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) ~[na:na]
	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
Caused by: io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
	at io.grpc.Status.asRuntimeException(Status.java:535) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:542) ~[grpc-stub-1.46.0.jar:1.46.0]
	at io.grpc.PartialForwardingClientCallListener.onClose(PartialForwardingClientCallListener.java:39) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:23) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.grpc.ForwardingClientCallListener$SimpleForwardingClientCallListener.onClose(ForwardingClientCallListener.java:40) ~[grpc-api-1.46.0.jar:1.46.0]
	at io.temporal.serviceclient.GrpcMetricsInterceptor$MetricsClientCall$1.onClose(GrpcMetricsInterceptor.java:123) ~[temporal-serviceclient-1.11.0.jar:na]
	at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:562) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:70) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:743) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:722) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37) ~[grpc-core-1.46.0.jar:1.46.0]
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133) ~[grpc-core-1.46.0.jar:1.46.0]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
	... 1 common frames omitted
Caused by: io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: /127.0.0.1:7233
Caused by: java.net.ConnectException: Connection refused
	at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) ~[na:na]
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777) ~[na:na]
	at io.grpc.netty.shaded.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:330) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:710) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[grpc-netty-shaded-1.46.0.jar:1.46.0]
	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
```

## Specifications
Temporalite was installed using `go install github.com/temporalio/temporalite/cmd/temporalite@latest`
- Version:
```
 go/bin ¬ª ./temporalite -v
temporal version 1.17.1
```
- Platform: Apple M1 Max, macOS 12.4


#### Comments (6)

<details>
<summary><strong>jlegrone</strong> commented on 2022-08-04 17:48:52.000 UTC</summary>

> 1. Set up an environment with two+ Temporal clusters, henceforth referred to as "primary" and "fallback"

How are you configuring your temporalite instances? Eg. does `temporalite start --ephemeral -p 7233` and `temporalite start --ephemeral -p 7234` work to reproduce?

> 4. Turn on the primary cluster and getClusterInfo the primary, which will fail. We expect success here. I have waited over 2 minutes with the same result.

Are you able to reproduce this step via the `tctl cluster health` command? I _think_ this may call the same API as `getClusterInfo` in the Java SDK. Also, are you running this program in a new process each time?

</details>

<details>
<summary><strong>neshield</strong> commented on 2022-08-04 22:25:44.000 UTC</summary>


> How are you configuring your temporalite instances? Eg. does `temporalite start --ephemeral -p 7233` and `temporalite start --ephemeral -p 7234` work to reproduce?

That command works to reproduce. I had been doing essentially the same thing: `./temporalite start --ephemeral --namespace default` and `./temporalite start --ephemeral --port 7234 --namespace default`





> > 4\. Turn on the primary cluster and getClusterInfo the primary, which will fail. We expect success here. I have waited over 2 minutes with the same result.
> 
> Are you able to reproduce this step via the `tctl cluster health` command?

If I call `tctl cluster health` after turning the primary cluster back on, it succeeds:
```
tctl cluster health                                                       
temporal.api.workflowservice.v1.WorkflowService: SERVING
```
However, the test still shows the same result. The first `getClusterInfo` fails with `Connection refused: /127.0.0.1:7233`.

> are you running this program in a new process each time?

Yes, it's a JUnit test. 

Reactions: üëç 1

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-08-05 16:36:01.000 UTC</summary>

This does not seem related to Temporalite specifically, but rather the Java SDK. To clarify @neshield, are you saying that your same client isn't able to successful call after server starts back up? Also, you say you have a "fallback" but all yours steps refer to "primary",...so "fallback" is not needed in the description to describe your issue? Or is the fallback used in some way?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-05 17:14:14.000 UTC</summary>

@neshield From what I see from Step 4 logs, gRPC actually tries to establish a new connection (as it should) and it fails, which causes the request to fail:

```
Caused by: io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: /127.0.0.1:7233
Caused by: java.net.ConnectException: Connection refused
```

It looks like the server was up according to your description, but for some reason, the connection attempt was refused.
Do we have any proxies in the middle here? Envoy maybe? Or it's a fully local setup and the SDK connects to Temporal Servers directly?

</details>

<details>
<summary><strong>neshield</strong> commented on 2022-08-05 20:30:42.000 UTC</summary>

@cretz 
> Also, you say you have a "fallback" but all yours steps refer to "primary",...so "fallback" is not needed in the description to describe your issue? Or is the fallback used in some way?

I thought I could only reproduce this in a two+ cluster environment, even though the "fallback" was never used. However, it seems like the second cluster isn't actually necessary.`WorkflowFacade` is a wrapper and a Spring Bean which gets created on startup. So, to narrow things down I managed to reproduce the error without the wrapper and without Spring. 

```java
public class SimpleTest {
    private static final WorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(
            WorkflowServiceStubsOptions.newBuilder()
                    .setTarget("127.0.0.1:7233")
                    .setRpcTimeout(Duration.ofMillis(100000))
                    .build());
    @Test public void testDoNotUseFacade() throws InterruptedException {
        // 1. turn on
        assertTrue(isHealthy(service));
        // 2. turn off
        assertFalse(isHealthy(service));
        int counter = 0;
        boolean isHealthy = false;
        // 3. turn on, doesn't seem to matter how long you wait before starting the loop
        while (!isHealthy) {
            isHealthy = isHealthy(service);
            counter++;
            Thread.sleep(500);
        }
        // This seems to always print 2, even if the sleep is for 500 millis or 2000.
        System.out.println("Cluster returned healthy after numAttempts: " + counter);
    }

    public boolean isHealthy(WorkflowServiceStubs service) {
        try {
            return ListenableFuturesExtra.toCompletableFuture(service.futureStub()
                            .getClusterInfo(GetClusterInfoRequest.newBuilder().build()))
                    .thenApplyAsync(GetClusterInfoResponse::isInitialized)
                    .orTimeout(20, TimeUnit.SECONDS).get();
        } catch (Exception e) {
            System.out.println("Threw exception :" + e.getMessage());
            return false;
        }
    }
}
```

Here are the full logs for a test run:

```
16:27:00.705 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework
16:27:00.711 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - -Dio.netty.noUnsafe: false
16:27:00.711 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - Java version: 11
16:27:00.713 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.theUnsafe: available
16:27:00.715 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.copyMemory: available
16:27:00.716 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - java.nio.Buffer.address: available
16:27:00.716 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - direct buffer constructor: unavailable: Reflective setAccessible(true) disabled
16:27:00.717 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - java.nio.Bits.unaligned: available, true
16:27:00.717 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable: class io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0$6 cannot access class jdk.internal.misc.Unsafe (in module java.base) because module java.base does not export jdk.internal.misc to unnamed module @4274d07b
16:27:00.718 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent0 - java.nio.DirectByteBuffer.<init>(long, int): unavailable
16:27:00.718 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - sun.misc.Unsafe: available
16:27:00.739 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - maxDirectMemory: 536870912 bytes (maybe)
16:27:00.739 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - -Dio.netty.tmpdir: /var/folders/ks/0wppmjz10dx67djf4r910hs40000gn/T (java.io.tmpdir)
16:27:00.739 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - -Dio.netty.bitMode: 64 (sun.arch.data.model)
16:27:00.740 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - Platform: MacOS
16:27:00.741 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - -Dio.netty.maxDirectMemory: -1 bytes
16:27:00.741 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - -Dio.netty.uninitializedArrayAllocationThreshold: -1
16:27:00.742 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.CleanerJava9 - java.nio.ByteBuffer.cleaner(): available
16:27:00.742 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - -Dio.netty.noPreferDirect: false
16:27:00.807 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.channel.MultithreadEventLoopGroup - -Dio.netty.eventLoopThreads: 20
16:27:00.819 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.InternalThreadLocalMap - -Dio.netty.threadLocalMap.stringBuilder.initialSize: 1024
16:27:00.819 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.InternalThreadLocalMap - -Dio.netty.threadLocalMap.stringBuilder.maxSize: 4096
16:27:00.823 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop - -Dio.netty.noKeySetOptimization: false
16:27:00.823 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop - -Dio.netty.selectorAutoRebuildThreshold: 512
16:27:00.828 [Test worker] DEBUG io.grpc.netty.shaded.io.netty.util.internal.PlatformDependent - org.jctools-core.MpscChunkedArrayQueue: available
16:27:01.014 [Test worker] INFO io.temporal.serviceclient.WorkflowServiceStubsImpl - Created WorkflowServiceStubs for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=127.0.0.1:7233}}
16:27:01.160 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.ResourceLeakDetector - -Dio.grpc.netty.shaded.io.netty.leakDetection.level: simple
16:27:01.161 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.ResourceLeakDetector - -Dio.grpc.netty.shaded.io.netty.leakDetection.targetRecords: 4
16:27:01.168 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.AbstractByteBuf - -Dio.grpc.netty.shaded.io.netty.buffer.checkAccessible: true
16:27:01.168 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.AbstractByteBuf - -Dio.grpc.netty.shaded.io.netty.buffer.checkBounds: true
16:27:01.169 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.ResourceLeakDetectorFactory - Loaded default ResourceLeakDetector: io.grpc.netty.shaded.io.netty.util.ResourceLeakDetector@6d5fe24
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.numHeapArenas: 5
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.numDirectArenas: 5
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.pageSize: 8192
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxOrder: 11
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.chunkSize: 16777216
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.smallCacheSize: 256
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.normalCacheSize: 64
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxCachedBufferCapacity: 32768
16:27:01.210 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.cacheTrimInterval: 8192
16:27:01.211 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.cacheTrimIntervalMillis: 0
16:27:01.212 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.useCacheForAllThreads: true
16:27:01.212 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxCachedByteBuffersPerChunk: 1023
16:27:01.268 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.channel.DefaultChannelId - -Dio.netty.processId: 30039 (auto-detected)
16:27:01.270 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.NetUtil - -Djava.net.preferIPv4Stack: false
16:27:01.270 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.NetUtil - -Djava.net.preferIPv6Addresses: false
16:27:01.276 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.NetUtilInitializations - Loopback interface: lo0 (lo0, 0:0:0:0:0:0:0:1%lo0)
16:27:01.277 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.NetUtil - Failed to get SOMAXCONN from sysctl and file /proc/sys/net/core/somaxconn. Default: 128
16:27:01.279 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.channel.DefaultChannelId - -Dio.netty.machineId: f4:d4:88:ff:fe:61:1a:a9 (auto-detected)
16:27:01.293 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil - -Dio.netty.allocator.type: pooled
16:27:01.293 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil - -Dio.netty.threadLocalDirectBufferSize: 0
16:27:01.293 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.buffer.ByteBufUtil - -Dio.netty.maxThreadLocalCharBufferSize: 16384
16:27:01.314 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.Recycler - -Dio.netty.recycler.maxCapacityPerThread: 4096
16:27:01.314 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.Recycler - -Dio.netty.recycler.ratio: 8
16:27:01.314 [grpc-default-executor-0] DEBUG io.grpc.netty.shaded.io.netty.util.Recycler - -Dio.netty.recycler.chunkSize: 32
16:27:01.333 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] OUTBOUND SETTINGS: ack=false settings={ENABLE_PUSH=0, MAX_CONCURRENT_STREAMS=0, INITIAL_WINDOW_SIZE=1048576, MAX_HEADER_LIST_SIZE=8192}
16:27:01.341 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] OUTBOUND WINDOW_UPDATE: streamId=0 windowSizeIncrement=983041
16:27:01.348 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND SETTINGS: ack=false settings={MAX_FRAME_SIZE=16384}
16:27:01.349 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] OUTBOUND SETTINGS: ack=true
16:27:01.361 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND SETTINGS: ack=true
16:27:01.374 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] OUTBOUND HEADERS: streamId=3 headers=GrpcHttp2OutboundHeaders[:authority: 127.0.0.1:7233, :path: /temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo, :method: POST, :scheme: http, content-type: application/grpc, te: trailers, user-agent: grpc-java-netty/1.46.0, client-version: 1.11.0, supported-server-versions: >=0.31.0 <2.0.0, client-name: temporal-java, grpc-accept-encoding: gzip, grpc-timeout: 99710624u] streamDependency=0 weight=16 exclusive=false padding=0 endStream=false
16:27:01.382 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] OUTBOUND DATA: streamId=3 padding=0 endStream=true length=5 bytes=0000000000
16:27:01.385 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND WINDOW_UPDATE: streamId=0 windowSizeIncrement=5
16:27:01.386 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND PING: ack=false bytes=145258749040133895
16:27:01.386 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] OUTBOUND PING: ack=true bytes=145258749040133895
16:27:01.390 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND HEADERS: streamId=3 headers=GrpcHttp2ResponseHeaders[:status: 200, content-type: application/grpc] padding=0 endStream=false
16:27:01.398 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND DATA: streamId=3 padding=0 endStream=false length=254 bytes=00000000f90a150a0b74656d706f72616c2d676f12063c322e302e300a150a0b74656d706f72616c2d756912063c332e302e300a190a0f74656d706f72616c2d...
16:27:01.398 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] OUTBOUND PING: ack=false bytes=1234
16:27:01.402 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND HEADERS: streamId=3 headers=GrpcHttp2ResponseHeaders[grpc-status: 0, grpc-message: ] padding=0 endStream=true
16:27:01.404 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 - R:/127.0.0.1:7233] INBOUND PING: ack=true bytes=1234
16:27:04.731 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 ! R:/127.0.0.1:7233] OUTBOUND HEADERS: streamId=5 headers=GrpcHttp2OutboundHeaders[:authority: 127.0.0.1:7233, :path: /temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo, :method: POST, :scheme: http, content-type: application/grpc, te: trailers, user-agent: grpc-java-netty/1.46.0, client-version: 1.11.0, supported-server-versions: >=0.31.0 <2.0.0, client-name: temporal-java, grpc-accept-encoding: gzip, grpc-timeout: 99999618u] streamDependency=0 weight=16 exclusive=false padding=0 endStream=false
16:27:04.735 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 ! R:/127.0.0.1:7233] OUTBOUND GO_AWAY: lastStreamId=2147483647 errorCode=2 length=0 bytes=
16:27:04.739 [grpc-nio-worker-ELG-1-3] DEBUG io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler - [id: 0x5af84be4, L:/127.0.0.1:56236 ! R:/127.0.0.1:7233] Sending GOAWAY failed: lastStreamId '2147483647', errorCode '2', debugData ''. Forcing shutdown of the connection.
io.grpc.netty.shaded.io.netty.channel.StacklessClosedChannelException: null
	at io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)
Threw exception :io.grpc.StatusRuntimeException: UNKNOWN: channel closed
Threw exception :io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
16:27:10.112 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] OUTBOUND SETTINGS: ack=false settings={ENABLE_PUSH=0, MAX_CONCURRENT_STREAMS=0, INITIAL_WINDOW_SIZE=1048576, MAX_HEADER_LIST_SIZE=8192}
16:27:10.116 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] OUTBOUND WINDOW_UPDATE: streamId=0 windowSizeIncrement=983041
16:27:10.118 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND SETTINGS: ack=false settings={MAX_FRAME_SIZE=16384}
16:27:10.118 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] OUTBOUND SETTINGS: ack=true
16:27:10.119 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND SETTINGS: ack=true
16:27:10.619 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] OUTBOUND HEADERS: streamId=3 headers=GrpcHttp2OutboundHeaders[:authority: 127.0.0.1:7233, :path: /temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo, :method: POST, :scheme: http, content-type: application/grpc, te: trailers, user-agent: grpc-java-netty/1.46.0, client-version: 1.11.0, supported-server-versions: >=0.31.0 <2.0.0, client-name: temporal-java, grpc-accept-encoding: gzip, grpc-timeout: 99999533u] streamDependency=0 weight=16 exclusive=false padding=0 endStream=false
16:27:10.621 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] OUTBOUND DATA: streamId=3 padding=0 endStream=true length=5 bytes=0000000000
16:27:10.623 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND WINDOW_UPDATE: streamId=0 windowSizeIncrement=5
16:27:10.624 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND PING: ack=false bytes=145258749040133895
16:27:10.625 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] OUTBOUND PING: ack=true bytes=145258749040133895
16:27:10.626 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND HEADERS: streamId=3 headers=GrpcHttp2ResponseHeaders[:status: 200, content-type: application/grpc] padding=0 endStream=false
16:27:10.627 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND DATA: streamId=3 padding=0 endStream=false length=254 bytes=00000000f90a150a0b74656d706f72616c2d756912063c332e302e300a190a0f74656d706f72616c2d73657276657212063c322e302e300a160a0c74656d706f...
16:27:10.627 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] OUTBOUND PING: ack=false bytes=1234
16:27:10.629 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND HEADERS: streamId=3 headers=GrpcHttp2ResponseHeaders[grpc-status: 0, grpc-message: ] padding=0 endStream=true
16:27:10.631 [grpc-nio-worker-ELG-1-7] DEBUG io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler - [id: 0x5463f454, L:/127.0.0.1:56261 - R:/127.0.0.1:7233] INBOUND PING: ack=true bytes=1234
16:27:10.895 [grpc-connection-manager-thread-0] DEBUG io.temporal.serviceclient.ChannelManager - Resetting gRPC connection backoff on the gRPC channel ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=127.0.0.1:7233}}
Cluster returned healthy after numAttempts: 2
```

>  To clarify @neshield, are you saying that your same client isn't able to successful call after server starts back up?

That is correct. The first call always fails, and the second one succeeds.

@Spikhalskiy 
> It looks like the server was up according to your description, but for some reason, the connection attempt was refused.
Do we have any proxies in the middle here? Envoy maybe? Or it's a fully local setup and the SDK connects to Temporal Servers directly?

This is a fully local environment. I'm running Java and temporalite on the same machine. I turned off my VPN just to make sure, and there was no difference in the result.

----
Given that this doesn't actually require a multi cluster environment, should the issue be renamed?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-03 14:51:49.000 UTC</summary>

Closing due to inactivity, for user support we prefer our slack or forum.

</details>


---

<a id="1158"></a>

### #1158: Implement temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace in test-server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1158 |
| **State** | CLOSED |
| **Author** | seregazhuk (Sergey Zhuk) |
| **Created** | 2022-04-20 07:43:07.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-21 04:03:34.000 UTC |
| **Closed** | 2022-04-21 04:03:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.11.0 |

#### Description

To start using test-sever in PHP-SDK we need the following functionality.

#### Comments (6)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-20 14:33:40.000 UTC</summary>

Other SDK successfully use test server without this functionality. If it's currently a prerequisite for using test server in PHP SDK, it shouldn't be. SDKs themselves never call describeNamespace, PHP shouldn't be different. 

</details>

<details>
<summary><strong>rustatian</strong> commented on 2022-04-20 15:18:03.000 UTC</summary>

> Other SDK successfully use test server without this functionality. If it's currently a prerequisite for using test server in PHP SDK, it shouldn't be. SDKs themselves never call describeNamespace, PHP shouldn't be different.

Hey @Spikhalskiy, Could you please point me to a doc or manual with a testing-server limitations? It would be great to see what API it doesn't support.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-20 15:38:25.000 UTC</summary>

This class: https://github.com/temporalio/sdk-java/blob/1816ad2499b8e98a20d158a8f0a4c64bb41a9a09/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java
implements WorkflowService, all methods that are not overridden will throw an UNIMPLEMENTED exception.

Currently, it's
```
  registerNamespace
  describeNamespace
  listNamespaces
  updateNamespace
  deprecateNamespace
  getWorkflowExecutionHistoryReverse
  resetWorkflowExecution
  listWorkflowExecutions
  listArchivedWorkflowExecutions
  scanWorkflowExecutions
  countWorkflowExecutions
  getSearchAttributes
  resetStickyTaskQueue
  describeTaskQueue
  getClusterInfo
  getSystemInfo
  listTaskQueuePartitions
```

Some notes:
registerNamespace is not needed for Test Server, you can just use any namespace name without registering with it
resetStickyTaskQueue probably should be implemented in a trivial way and just return silently without an exception. All SDKs just ignore any exception from the sticky queue reset, because it's not too important.



</details>

<details>
<summary><strong>rustatian</strong> commented on 2022-04-20 16:20:34.000 UTC</summary>

@Spikhalskiy Great, thank you for the help.

However, this is not a PHP-SDK error, as I figured out.
I have created a simple worker in go-sdk (I'm not a Java dev, so forgive me for the snippet in Go), without any activities or workflows registered. Here is the sample:
```go
package main

import (
	"log"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

func main() {
	// The client and worker are heavyweight objects that should be created once per process.
	c, err := client.NewClient(client.Options{
		HostPort: client.DefaultHostPort,
	})
	if err != nil {
		log.Fatalln("Unable to create client", err)
	}
	defer c.Close()

	w := worker.New(c, "greetings", worker.Options{})

	err = w.Run(worker.InterruptCh()) <-------- ERROR is here
	if err != nil {
		log.Fatalln("Unable to start worker", err)
	}
}
```

If you run this code snippet with a test-server, you'll get an error: `2022/04/20 18:16:05 Unable to start worker Method temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace is unimplemented`

EDIT: test-server version is: 1.10.0

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-20 16:53:54.000 UTC</summary>

Good catch, you are right. It was added to Go SDK here: https://github.com/uber-go/cadence-client/pull/196 
It's actually a discrepancy, we should either remove it from Go SDK or add it to other SDKs. Java, Typescript and I guess Python  SDKs don't do it right now. We will discuss it. I don't see too much reason to make this explicit all. 
But it looks like we should implement some stub describeNamespace in the test server just for the sake of compatibility with older versions of Go SDK.

Reactions: üëç 2

</details>

<details>
<summary><strong>rustatian</strong> commented on 2022-04-20 17:04:47.000 UTC</summary>

Got u, thanks ü§ù Looking forward to the solution üëçüèª 

</details>


---

<a id="1106"></a>

### #1106: Workflow metadata resolution code doesn't respect generics specified down the hierarchy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1106 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-03-31 00:35:29.000 UTC (3y 9m ago) |
| **Updated** | 2024-09-01 23:24:21.000 UTC |
| **Closed** | 2024-09-01 23:24:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

```
@WorkflowInterface
public interface ReportingWorkflow extends TemporalWorkflow<ReportQueriesResponse> {
  @WorkflowMethod
  ReportQueriesResponse runReport(ReportQueries reportQueries);
}

public interface TemporalWorkflow<T> extends TemporalRunnable {
  @QueryMethod
  T getResults();
}
```

Temporal JavaSDK should be able to understand that `ReportingWorkflow#getResults` returns ReportQueriesResponse and use this class as a target in data conversion.

## Actual Behavior

Data Converters try to decode query results into `Object`.

## Notes

Worth checking the same problem for Activity Metadata resolution. 

## Specifications

  - Version: 1.8.x


#### Comments (6)

<details>
<summary><strong>mfateev</strong> commented on 2022-12-12 10:12:47.000 UTC</summary>

I don't think this is a bug. Given that Java erases generics information at runtime, it is impossible to implement.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-12 13:07:34.000 UTC</summary>

> it is impossible to implement.

True, but there are utilities if we ever want to have user-specified generic values (e.g. maybe a default method that returns https://guava.dev/releases/21.0/api/docs/com/google/common/reflect/TypeToken.html for `T`)

But what I would recommend is to disallow annotations on generic methods. If Temporal needs to know concrete types, it should be an error not to be able to reflectively obtain them. So in the pasted sample, they'd need to provide an annotation on the concrete interface override instead.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-12 15:19:08.000 UTC</summary>

> Given that Java erases generics information at runtime, it is impossible to implement.

It's not exactly true. Java erases generic information for dynamically created instances of gentrified classes. But Java do preserve information about generic typed for defined standalone classes. Basically, if you have `class A extends/implements B<C>` - type of C is preserved and can be got from reflection.
It's possible and it's a bug (or missing and never implemented feature) from my point of view.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-12 15:35:30.000 UTC</summary>

You're going to have to have really complicated rules about how to derive `C` in complicated inheritance scenarios. And what if they never provide a type parameter? in an inherited interface? Or what if they do `? extends List<String>` or something. Or additional type constraints in multiple levels? Or if they have another that uses a more specific generic value than the base interface but still generic?

I think this is a can of worms that you can only half support. I can give lots of confusing scenarios. To me the most straightforward answer is "you cannot define Temporal annotations on generic items". It's harmless to ask someone to have a concrete override for use by stubs and other items.

If you're afraid of compatibility, leave current `Object` behavior and log warning.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-12 15:46:07.000 UTC</summary>

> I think this is a can of worms that you can only half support.
That's fine. Most things that user need is a very straightforward 1-1 unbounded resolution we 100% can and should support.

An implementer of this feature should think about scenarios and may ban some specific scenarios and throw an exception if something is too complicated to resolve like it's already done now we a diamond inheritance.

What most people want from this feature of supporting generics is totally doable and non-ambiguous. 



</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-12 16:07:42.000 UTC</summary>

```java
@WorkflowInterface
public interface ReportingWorkflow<T extends ReportQueriesResponse> extends TemporalRunnable {
  @WorkflowMethod
  String runReport(ReportQueries reportQueries);

  @QueryMethod
  T getResults();
}
```

If I register this interface, will you support this use case? If clear, no prob, just want to make sure the rules will be clear and users aren't surprised when something silently is not supported while something else silently is.

</details>


---

<a id="976"></a>

### #976: üß∞ Additional APIs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/976 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-14 06:14:47.000 UTC (3y 12m ago) |
| **Updated** | 2025-05-13 16:42:40.000 UTC |
| **Closed** | 2025-05-13 16:42:39.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 4 |
| **Priority Score** | 6 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

# Description

Provide APIs for additional functionality that users need that doesn't align with the purpose and interface of `WorkflowClient`.
_APIs to be used for implementation of Workflows and Activities don't belong to this Epic_

# Core Objectives

Temporal support chats and forums are filled with code snippets that we provide for our users to achieve this and that goal. It's usually some wrappers around the raw gRPC endpoints that are too non-intuitive for users.
We don't implement this functionality as a normal SDK API because it's not a part of normal Workflow implementations and they don't below to `WorkflowClient` interface. At the same time, we don't have any other class/interface to expose it on and there is no system in place to make this process manageable. 
SDK should systematize and expose such functionality and provide a reasonable structure of interfaces and classes to access it.

# Tasks

- [x] #1036


# Related user requests / reports

- [x] #835
- [ ] describeWorkflowExecution. Some users were using our internal method for that: https://github.com/temporalio/sdk-java/issues/1028

#### Comments (4)

<details>
<summary><strong>tsurdilo</strong> commented on 2022-02-03 15:57:59.000 UTC</summary>

@Spikhalskiy 
most of these utility methods are documented here: https://github.com/tsurdilo/temporal-java-workshop/blob/main/src/main/java/io/workshop/c1s1/S1WFUtils.java

so things like:

getWorkflowStatus
getActivitiesWithRetriesOver
getLastHistoryEvent
getFirstHistoryEvent
printFailedWorkflowsWithReason
resetWorkflow
terminateWorkflow
...

are things that i think we could create util methods for. Basically we should have a 1-1 mapping between tctl commands and out-of-box util methods in our sdk imo. This should at some point also please include admin apis that are currently not exposed via proto in sdks.

There is also one recent post on forum where user 
asked to get search attributes for specific id: https://community.temporal.io/t/search-attributes-always-null-when-fetched-from-service-library/3892/2 that would be nice to add as util method out of box as well

the "List" APIs are not really that bad, the problem is that noone knows/thinks of pagination and page size.
i think these util methods we add should handle pagination out of box so people don't have to think about it or forget and see issues.

Reactions: üëç 1 ‚ù§Ô∏è 1

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2022-02-03 15:59:32.000 UTC</summary>

another thing that would be really nice is to make it absolutely clear which "List" apis can be used 
with/without Elasticsearch enabled.

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2022-02-03 16:00:20.000 UTC</summary>

sorry one more :) 
in addition we should document apis to make it clear that those using enhanced visibility store are **eventually** consistent and may have delays compared to what users see in web ui or via tctl when querying persistent store

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:42:39.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="863"></a>

### #863: Internal error in gRPC channel of WorkflowServiceStubs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/863 |
| **State** | CLOSED |
| **Author** | smax48 (Maxim Chuvilyaev) |
| **Created** | 2021-11-09 01:59:18.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-23 02:03:57.000 UTC |
| **Closed** | 2021-11-23 02:03:46.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 2 |
| **Priority Score** | 6 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |
| **Reactions** | üëç 2 |

#### Description

## Expected Behavior
A single instance of WorkflowServiceStubs is created once per application and used for communication with Temporal frontend API.

## Actual Behavior
After long period of inactivity (~40min) at some point of time we see an internal exception when trying to start a new workflow: `io.grpc.StatusRuntimeException: INTERNAL: Panic! This is a bug!` and channel becomes unusable after that (i.e. all attempts to use it result in the same error.)

I cannot prove, but it might be related to some race condition between idleTimer in the netty channel (which has 30 min default timeout and is not configured by Temporal SDK) and Temporal own mechanism to reset gRPC connections via setGrpcReconnectFrequency() (that also calls to enterIdle() on the channel). I am not sure why the existing idleTimer is not used for this purpose in the first place, but maybe there are some specific considerations.

Full stack trace:
```
io.temporal.client.WorkflowServiceException: workflowId='XXX123', runId='', workflowType='SomeWorkflowType'}\
at io.temporal.internal.sync.WorkflowStubImpl.wrapStartException(WorkflowStubImpl.java:184)\
at io.temporal.internal.sync.WorkflowStubImpl.startWithOptions(WorkflowStubImpl.java:120)\
at io.temporal.internal.sync.WorkflowStubImpl.start(WorkflowStubImpl.java:138)\
at io.temporal.internal.sync.WorkflowInvocationHandler.startWorkflow(WorkflowInvocationHandler.java:192)\
at io.temporal.internal.sync.WorkflowInvocationHandler.access$300(WorkflowInvocationHandler.java:48)\
at io.temporal.internal.sync.WorkflowInvocationHandler$ExecuteWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:339)\
at io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)\
<app-specific call stack omitted>
............
at java.base/java.lang.Thread.run(Unknown Source)\
Caused by: io.grpc.StatusRuntimeException: INTERNAL: Panic! This is a bug!\
at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)\
at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)\
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)\
at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.startWorkflowExecution(WorkflowServiceGrpc.java:2615)\
at io.temporal.internal.external.GenericWorkflowClientExternalImpl.lambda$start$0(GenericWorkflowClientExternalImpl.java:88)\
at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:61)\
at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:51)\
at io.temporal.internal.external.GenericWorkflowClientExternalImpl.start(GenericWorkflowClientExternalImpl.java:81)\
at io.temporal.internal.client.RootWorkflowClientInvoker.start(RootWorkflowClientInvoker.java:55)\
at io.temporal.common.interceptors.WorkflowClientCallsInterceptorBase.start(WorkflowClientCallsInterceptorBase.java:35)\
at io.temporal.opentracing.internal.OpenTracingWorkflowClientCallsInterceptor.start(OpenTracingWorkflowClientCallsInterceptor.java:50)\
at io.temporal.internal.sync.WorkflowStubImpl.startWithOptions(WorkflowStubImpl.java:113)\
... 25 common frames omitted\
Caused by: java.lang.IllegalStateException: nameResolver is not started\
at com.google.common.base.Preconditions.checkState(Preconditions.java:502)\
at io.grpc.internal.ManagedChannelImpl.shutdownNameResolverAndLoadBalancer(ManagedChannelImpl.java:360)\
at io.grpc.internal.ManagedChannelImpl.enterIdleMode(ManagedChannelImpl.java:422)\
at io.grpc.internal.ManagedChannelImpl.access$900(ManagedChannelImpl.java:118)\
at io.grpc.internal.ManagedChannelImpl$IdleModeTimer.run(ManagedChannelImpl.java:352)\
at io.grpc.internal.Rescheduler$ChannelFutureRunnable.run(Rescheduler.java:103)\
at io.grpc.SynchronizationContext.drain(SynchronizationContext.java:95)\
at io.grpc.SynchronizationContext.execute(SynchronizationContext.java:127)\
at io.grpc.internal.Rescheduler$FutureRunnable.run(Rescheduler.java:80)\
at io.grpc.netty.shaded.io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\
at io.grpc.netty.shaded.io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)\
.............
```


## Specifications

  - Version: Java SDK 1.4.0


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-11-19 05:47:46.000 UTC</summary>

I was able to reproduce the bug within grpc-java source code without any Temporal code and submitted https://github.com/grpc/grpc-java/issues/8714

Reactions: üëç 1

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-11-23 02:03:38.000 UTC</summary>

A temporary workaround is implemented waiting for the related gRPC issue to be fixed.
This workaround will stay around for a while to allow the users to upgrade to the gRPC versions including the fix.
This whole manual calling of `enterIdle` to achieve load balancing should potentially go away as a part of #888

</details>


---

<a id="806"></a>

### #806: Workflow.retry that takes a function to decide if retry is needed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/806 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-10-09 15:49:57.000 UTC (4y 3m ago) |
| **Updated** | 2022-03-04 08:19:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
`Workflow.retry` RetryOptions.doNotRetry is a list of strings. So any exception is converted to a string before matching. In many scenarios, the retry is based on a specific information in a specific exception down the chain or even on some other information within the workflow body.

**Describe the solution you'd like**
An API that takes a function (or lambda) that can execute random user provided logic to decide if retry is needed.

**Additional context**
This only works for retries from the workflow code. The service side retries have to rely on string matching in the current architecture. An activity already can decide itself that the error is not retryable by throwing an non-retryable ApplicationFailure.

#### Comments (6)

<details>
<summary><strong>niegus</strong> commented on 2022-02-18 08:55:51.000 UTC</summary>

Is there an ETA about when this could be tackled? :) 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-02-18 16:29:08.000 UTC</summary>

@niegus We typically don't provide ETAs for feature requests. Contributions are welcomed, this is a great starter issue.

Reactions: üëç 1

</details>

<details>
<summary><strong>niegus</strong> commented on 2022-02-25 10:20:33.000 UTC</summary>

How do you envision this feature? `Workflow.retry` retries based on the expiration parameter, plus the maximum attempts configured in the `RetryOptions`, always if the exception is not set in the list of `doNotRetry` exceptions.

If there is a new function/lambda to decide if the retry is need, how it would work with the current behavior? Taking precedence over them? Validate on the creation of the `RetryOption` so there can not be contradictions between the "retryOn" and "doNotRetry"?

</details>

<details>
<summary><strong>niegus</strong> commented on 2022-03-03 10:52:08.000 UTC</summary>

cc: @Spikhalskiy @mfateev 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-03 16:32:30.000 UTC</summary>

I think to have it consistent, it should be `doNotRetryPedicate` and retry doesn't happen if `ex.getErrorType in retryOptions.getDoNotRetry() || doNotRetryPedicate(ex)`.

But I'm getting back the comment about the great starter issue. 
I thought about a bit different place in the system (workflow method exceptions and failures). 
`Workflow.retry` works with persisted side effects and it may get tricky. But if you want to give it a shot, the effort is very welcomed.

</details>

<details>
<summary><strong>niegus</strong> commented on 2022-03-04 08:19:36.000 UTC</summary>

@Spikhalskiy This feature request comes from this thread: https://community.temporal.io/t/temporal-queue-activities/3095/8 to retry in certain cases, `doNotRetryPredicate()` could do the trick, but it would require to write negative code üòÖ 

Eg.
```
doNotRetryPredicate(ex -> !(ex.getCause() instanceof TimeoutFailure && 
               ((TimeoutFailure) ex.getCause()).getTimeoutType() == TimeoutType.TIMEOUT_TYPE_SCHEDULE_TO_START))
```

IMHO (as a customer of this lib) it would be easier:
```
retryOnPredicate(ex -> ex.getCause() instanceof TimeoutFailure && 
               ((TimeoutFailure) ex.getCause()).getTimeoutType() == TimeoutType.TIMEOUT_TYPE_SCHEDULE_TO_START)
```

WDYT? Would that make sense?

</details>


---

<a id="796"></a>

### #796: Context propagation is not invoked when a workflow start and is configured using WorkflowClientOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/796 |
| **State** | CLOSED |
| **Author** | jrpedrianes (Jorge Rodr√≠guez Pedrianes) |
| **Created** | 2021-10-05 12:56:10.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-06 17:12:41.000 UTC |
| **Closed** | 2021-10-06 17:09:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

## Expected Behavior
When starting a workflow, context propagated configured at workflow client level must be used.

## Actual Behavior
Is not invoked and must be defined using `WorkflowOptions`

## Steps to Reproduce the Problem

In the following link, I created an example class in which we can see that the "serializeContext" method is not invoked before the workflow is started.

https://gist.github.com/jrpedrianes/2759391fa22311edf214932eeb3fd4b3

## Specifications

  - Version: sdk-java 1.3.1


#### Comments (6)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-05 15:54:18.000 UTC</summary>

Hi Jorge, 

It's like that by design.

Some clues why it's done this way:
1. Imagine your client and worker are not the same app and have different classes in their classpath. A context propagator that is registered on the client side could even not exist in a classpath of the worker. _There is theoretically a way to get over it by sending a bytecode, but this solution is full of drawbacks and limitations and not worth doing taking into account that it's not the only limitation._
2. Imagine we don't have the first problem and they do exist. ContextPropagator could have a non-default constructor, have external instances injected into it, etc. We don't require ContextPropagators to be serializable and this would impose serious limitations on them. So, it's not like we can safely serialize ContextPropagator and send it to the worker.
3. Think about a client that is implemented in Go and worker code is in java, how do we propagate Go context propagator implementation to JVM worker?

Temporal may one day consider adding functionality that a worker should not apply a worker propagator if the same type of propagator is not registered on the client. But we definitely can't just set up propagators on a client-side including our multi-lang nature and loose restrictions on ContextPropagators.

</details>

<details>
<summary><strong>jrpedrianes</strong> commented on 2021-10-05 17:58:10.000 UTC</summary>

Yes, I understand that we need to register the "same" ContextPropagators in all workers that are required, and must be implemented using different languages (Java, Go...)

But maybe my confusion was thinking that when I register a context propagator in a WorkflowClient instance, ie: 

```
        WorkflowClient client = WorkflowClient
            .newInstance(service, WorkflowClientOptions.newBuilder()
                .setContextPropagators(List.of(new DummyContextPropagator()))
                .validateAndBuildWithDefaults());
```

The context propagators register there, will be used in all the resources using that client, ie:
```
WorkerFactory factory = WorkerFactory.newInstance(client);
```
and:
```
        GreetingWorkflow workflow =
            client.newWorkflowStub(
                GreetingWorkflow.class,
                WorkflowOptions.newBuilder()
                    .setWorkflowId(WORKFLOW_ID)
                    .setTaskQueue(TASK_QUEUE)
                    .validateBuildWithDefaults());
```

Maybe it is useful to add a Javadoc documentation that the context propagator will not be applied when we are creating a client stub.


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-05 18:04:47.000 UTC</summary>

If in the snippets above context propagators are not promoted to the stubs created this way, it's a bug. Thank you for the clarification!

</details>

<details>
<summary><strong>jrpedrianes</strong> commented on 2021-10-05 18:19:49.000 UTC</summary>

I was debugging a workflow invocation and I could not see where the context propagation, defined using  WorkflowClientOptions, could be used.

Seems that should be used in: 

- [WorkflowStubImpl.java](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowStubImpl.java)
- [RootWorkflowClientInvoker.java](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/client/RootWorkflowClientInvoker.java)
- [RootWorkflowClientHelper.java](https://github.com/temporalio/sdk-java/blob/0fedb5438bac22445e0c3f660af3cd717b22665a/temporal-sdk/src/main/java/io/temporal/internal/client/RootWorkflowClientHelper.java)

But I could not see any reference to `clientOptions.getContextPropagators()`

Reactions: üëç 1

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-05 18:21:35.000 UTC</summary>

For now, as a workaround, set the propagators on the WorkflowOptions. It should be fixed in 1.4.0 or 1.5.0.
I believe the options are propagated to the worker through: https://github.com/temporalio/sdk-java/blob/1eededde098e213471e2ba60cd9b119c66b04c34/temporal-sdk/src/main/java/io/temporal/worker/WorkerFactory.java#L181


</details>

<details>
<summary><strong>jrpedrianes</strong> commented on 2021-10-05 18:37:06.000 UTC</summary>

Now, we are using an interceptor to add it to all the client stubs, so we only need to touch one class. 

Thank a lot!! 

</details>


---

<a id="707"></a>

### #707: DEADLINE_EXCEEDED: deadline exceeded after 69.999644732s

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/707 |
| **State** | CLOSED |
| **Author** | sergtitov (Sergey Titov) |
| **Created** | 2021-09-10 18:30:44.000 UTC (4y 4m ago) |
| **Updated** | 2021-09-13 20:07:04.000 UTC |
| **Closed** | 2021-09-13 17:20:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | v.1.3.1 |

#### Description

## Expected Behavior

When testing a long running workflow using in-memory Temporal, no exception is thrown and the tests succeeds.

## Actual Behavior

We are getting ‚ÄúDEADLINE_EXCEEDED: deadline exceeded after ~70s‚Äù error when testing a long-running workflow using in-memory Temporal (TestWorkflowExtension).

This happens if there is long running activity or if a workflow is executing several short activities but as long as total workflow running time exceeds 70 seconds, this exception gets thrown.

The issue does NOT happen with a locally running Temporal (tests configured via setUseExternalService(true) and .setTarget(‚Äú127.0.0.1:7233‚Äù)). It only happens with in-memory Temporal instance.

## Steps to Reproduce the Problem

  1. Create a long running workflow (that makes API calls or long running logic)
  1. Write a test using in-memory Temporal (TestWorkflowExtension)
  1. Run the test and wait for 70 seconds, DEADLINE_EXCEEDED exception is thrown

Below is stack trace and code of the repro (the actual code does not use sleeps, of course, it makes API calls, data transformation, etc.)

### Stack trace:

```
io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 69.999644732s. []
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.getWorkflowExecutionHistory(WorkflowServiceGrpc.java:2625)
	at io.temporal.internal.common.WorkflowExecutionUtils.lambda$getInstanceCloseEvent$1(WorkflowExecutionUtils.java:257)
	at io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:97)
	at io.temporal.internal.common.WorkflowExecutionUtils.getInstanceCloseEvent(WorkflowExecutionUtils.java:245)
	at io.temporal.internal.common.WorkflowExecutionUtils.getWorkflowExecutionResult(WorkflowExecutionUtils.java:133)
	at io.temporal.internal.client.RootWorkflowClientInvoker.getResult(RootWorkflowClientInvoker.java:94)
	at io.temporal.internal.sync.WorkflowStubImpl.getResult(WorkflowStubImpl.java:243)
	at io.temporal.internal.sync.WorkflowStubImpl.getResult(WorkflowStubImpl.java:225)
	at io.temporal.testing.TestWorkflowEnvironmentInternal$TimeLockingInterceptor$TimeLockingWorkflowStub.getResult(TestWorkflowEnvironmentInternal.java:295)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.startWorkflow(WorkflowInvocationHandler.java:315)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:270)
	at io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)
	at jdk.proxy3/jdk.proxy3.$Proxy202.run(Unknown Source)
```

### Code repro:

```
@WorkflowInterface
 public interface LongRunningWorkflow {
      @WorkflowMethod
     void run();
 }

public class LongRunningWorkflowImpl implements LongRunningWorkflow {
     private final ActivityOptions activityOptions = ActivityOptions.newBuilder()
             .setScheduleToCloseTimeout(Duration.ofHours(1))
             .build();

      private final SleepActivities activities = Workflow.newActivityStub(SleepActivities.class, activityOptions);

      @Override
     public void run() {
         activities.sleep(Duration.ofSeconds(30));
         activities.sleep(Duration.ofSeconds(30));
         activities.sleep(Duration.ofSeconds(30));
         activities.sleep(Duration.ofSeconds(30));
     }
 }

@ActivityInterface
 public interface SleepActivities {
     @ActivityMethod
     boolean sleep(Duration duration);
 }

public class SleepActivitiesImpl implements SleepActivities {
     private static final Logger logger = LoggerFactory.getLogger(SleepActivitiesImpl.class);

     @Override
     public boolean sleep(Duration duration) {
         try {
             logger.info("Sleeping for {} sec", duration.toSeconds());
             Thread.sleep(duration.toMillis());
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
         return true;
     }
 }

@ExtendWith(MockitoExtension.class)
 class LongRunningWorkflowImplTest {
      private static final SleepActivitiesImpl sleepActivities = new SleepActivitiesImpl();

     @RegisterExtension
     public static final TestWorkflowExtension testWorkflowExtension =
             TestWorkflowExtension.newBuilder()
                     .setWorkflowClientOptions(TemporalConfiguration.getWorkflowClientOptions("default"))
                     .setWorkflowTypes(LongRunningWorkflowImpl.class)
                     .setActivityImplementations(sleepActivities)
                     .build();

     @Test
     void test_run(LongRunningWorkflow workflow) {
         workflow.run();
     }
 }
```

## Specifications

  - Version: 1.3.0
  - Platform: JDK 16


#### Comments (6)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-10 19:29:51.000 UTC</summary>

Some initial investigation here:

The deadline that applies here is `WorkflowServiceStubsOptions#rpcLongPollTimeout` which by default is 70s

@sergtitov please set up `rpcLongPollTimeout` to an actual value that makes sense for you.

But. This deadline is for some reason is not enforced with an external docker service - I was able to confirm it. This is an actual problem we should be looking at.

Also, there is another problem with a strange logic here. We apply the same `rpcLongPollTimeout` for pollWorkflowTaskQueueMethod, pollActivityTaskQueueMethod and getWorkflowExecutionHistoryMethod (see GrpcDeadlineInterceptor and LongPollUtil#isLongPoll). Which doesn't make much sense. "client-side" long polls and "worker-side" long polls are very different. Probably worker long poll timeout shouldn't be exposed at all in configuration and should be setup into something reasonable. Or it should be exposed as a separate option.

Here is the reproduction: https://github.com/Spikhalskiy/java-sdk/commit/9470a71728e818b20de3da83b10a9139e6fd1983



</details>

<details>
<summary><strong>sergtitov</strong> commented on 2021-09-10 19:35:16.000 UTC</summary>

@Spikhalskiy Dima, can you please elaborate why we need to set `rpcLongPollTimeout`? It is not documented anywhere and seems to be an internal thing and it actually looks like a red herring. Internal method `getWorkflowExecutionHistoryMethod` should not take 70 seconds even if workflow takes minutes/hours. Maybe there is a deadlock somewhere?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-10 19:42:28.000 UTC</summary>

@sergtitov getWorkflowExecutionHistoryMethod is this case is a long poll method that returns only when workflow is completed. It's not really a get, it's a wait. So, it gets rpcLongPollTimeout applied.
Information about getWorkflowExecutionHistoryMethod is internal. You should care about rpcLongPollTimeout and this option is documented on WorkflowServiceStubsOptions#rpcLongPollTimeout

</details>

<details>
<summary><strong>sergtitov</strong> commented on 2021-09-10 19:53:17.000 UTC</summary>

I am confused. Based on documentation, Temporal workflows could be running for days/months and should be able to survive worker re-starts and even code updates. Nowhere in the docs it is mentioned that `rpcLongPollTimeout` should be changed. Should it be set in production as well not just in tests? What value should it be set to?

// CC @mfateev 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-10 20:55:39.000 UTC</summary>

> Based on documentation, Temporal workflows could be running for days/months and should be able to survive worker re-starts and even code updates.

It's, this timeout affects only client-side wait, the processing of the workflow continues.

@sergtitov disregard my earlier comments for now, it's a half-truth. You shouldn't worry about rpcLongPollTimeout much. I will compose the whole picture first and get back.

Reactions: üëç 1

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-13 16:19:30.000 UTC</summary>

This is going to be addressed by #709 and #713

</details>


---

<a id="671"></a>

### #671: Add an easy way to provide JWT tokens to java-sdk for server calls

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/671 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-26 15:10:45.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-31 17:50:06.000 UTC |
| **Closed** | 2021-08-31 17:50:05.000 UTC |
| **Upvotes** | 3 |
| **Comments** | 0 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | v1.3.0 |
| **Reactions** | üëç 3 |

#### Description

If we use JWT tokens authorization in Temporal and need to add Authorization header to the calls, the only way now to do that is:
Implement two Grpc Stubs interceptors that set the right header and specify them in WorkflowServiceStubsOptions#Builder#setBlockingStubInterceptor and WorkflowServiceStubsOptions#Builder#setFutureStubInterceptor

It's a painful way for one of the server's default features and we should come up with a better way.
- We can provide JWT specific GrpcInterceptors out of the box 
- We can allow setting up HeaderProviders on WorkflowClientOptions

Related to forum discussion: https://community.temporal.io/t/how-to-do-workflow-api-authentication-using-jwt-in-java-please-help-me-on-this-i-need-required-code-changes-for-client-ad-server-side-for-this/1459/13


---

<a id="626"></a>

### #626: Excessive retries in test workflow environment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/626 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2021-08-11 18:40:09.000 UTC (4y 5m ago) |
| **Updated** | 2024-12-17 21:19:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 6 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description


When testing an activity that constantly fails (cannot recover from the failure) and has a large scheduleToClose timeout set (like days/months), or does not have one set at all
the testing framework will keep retrying in some cases thousands of times. 

Asking to add a feature that in those edge cases to not retry, but skip time so the excessive retries are avoided in tests.


To reproduce you can have a workflow which calls a single activity with activity options setScheduleToCloseTimeout set to 5 days for example. Set the activity to fail with for example:
throw Activity.wrap(new Exception("oops"));

in test you will see that it performs over 4K retries before timing out.

#### Comments (6)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-11 20:03:09.000 UTC</summary>

Linking https://github.com/temporalio/sdk-java/issues/499 as a different, but very relevant request. We should discuss the behavior of retries with our testing framework / time skipping / debugging mode.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-11 20:11:32.000 UTC</summary>

@tsurdilo what is the definition of "excessive" retries? And how the framework should define which is excessive in each specific scenario?

From my point of view, the described situation is not a problem and is actually expected behavior. A workflow activity should be retried the same amount of times in tests with time-skipping as it actually would be executed in 5 days before failing the workflow. And a lot of users will not be happy if it's not like that, it will be quite misleading and error-prone.
We can't just randomly decide what is extensive. For example, if activity retries every second in a normal environment and we have 5 days timeout and we have no limits for max retries - the total amount of retries in tests SHOULD be 5 * 24 * 60 * 60 = 432000

There is a way to achieve what you want though:
We basically want different `ActivityOptions#RetryOptions` in tests. So, we can modify `RetryOptions` and add `maxRetries=10` or `maxRetries=100` to `RetryOptions` if the execution happens inside unit-test (using some env var for example to define it, like proposed in the linked issue #499).
Are you proposing to provide this functionality in an easier-to-use form as a part of our testing framework?

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2021-08-11 20:45:25.000 UTC</summary>

i think in a test its different as you dont in most cases fix the error on activity after a number of retries. maybe if use knows they are testing activity failure specifically then the number of retries can even be 0 . or some number in config as activity options can be specified in workflow tested so they cannot be changed in test

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2021-08-11 20:49:01.000 UTC</summary>

@mfateev wdyt?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-11 21:45:49.000 UTC</summary>

We shouldn't completely cut off activity retries in tests because a lot of users would want to test and verify the retries' count, behavior, or even potential side effects.
If we don't want to have retries in tests, we can specify ActivityOptions#RetryOptions#maxRetries=1 if we are executing in a unit test as I described before.
But I agree, that having such code OR some tricky options injection/override just to get this behavior in tests can be a little annoying for the application developers. So, your proposal is to provide this functionality (limiting the number of retries to 1 for all activities) as a part of our test framework to make it handier, correct?

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2021-08-11 21:59:25.000 UTC</summary>

Yes, I think that would be nice if possible:
Ability to overwrite whole/parts of the activity options in the test (when ActivityOptions are defined inside the tested workflow code).

I think this could help also with some scenarios where for example you have ActivityOptions that specify a different task queue and you have to create extra workers for it in your tests, so ability to default all task queues for tested workflow and all its activities to the one created automatically by TestWorkflowRule, but that might be asking too much, idk :) 

</details>


---

<a id="139"></a>

### #139: Need ability to modify ObjectMapper created by JacksonJsonPayloadConverter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/139 |
| **State** | CLOSED |
| **Author** | kelnos (Brian Tarricone) |
| **Created** | 2020-06-30 00:17:04.000 UTC (5y 6m ago) |
| **Updated** | 2020-08-23 19:32:44.000 UTC |
| **Closed** | 2020-08-23 19:32:43.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 2 |
| **Priority Score** | 6 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

**Is your feature request related to a problem? Please describe.**

When building a Temporal app using Scala, we need to add jackson-scala-module so it knows how to handle Scala types.  However, we need access to the `ObjectMapper` to do this.

This isn't useful for just Scala; for example, we also have a few other org-specific Jackson modules that we use to make using Twilio-internal JVM types easier with Jackson.

**Describe the solution you'd like**

Two options come to mind:

1. A new constructor for `JacksonJsonPayloadConverter` that allows us to pass our own `ObjectMapper`.
2. A `getObjectMapper()` method that returns the `ObjectMapper` that's already been created, which allows us to augment its configuration.

**Describe alternatives you've considered**

Right now I'm using fragile bits of reflection to fetch the private `ObjectMapper` field to make modifications to it.  Obviously, that's not sustainable.

**Additional context**

 n/a


#### Comments (2)

<details>
<summary><strong>michalbric</strong> commented on 2020-07-02 09:33:30.000 UTC</summary>

Same issue with Kotlin data classes.
To save time for anybody until the issue is resolved, the reflection based workaround for Kotlin is as follows:

```kotlin
val jacksonJsonPayloadConverter = JacksonJsonPayloadConverter()
val privateMapperField = JacksonJsonPayloadConverter::class.java.getDeclaredField("mapper");
privateMapperField.isAccessible = true
privateMapperField.set(
    jacksonJsonPayloadConverter,
    ObjectMapper().registerKotlinModule().findAndRegisterModules()
)

val defaultDataConverter =
        DefaultDataConverter(NullPayloadConverter(), ByteArrayPayloadConverter(), jacksonJsonPayloadConverter)
val workflowClientOptions = WorkflowClientOptions.newBuilder()
        .setDataConverter(defaultDataConverter)
        .build()

val client = WorkflowClient.newInstance(service, workflowClientOptions)
```

Reactions: üëç 1

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-08-23 19:32:43.000 UTC</summary>

Public constructor that takes ObjectMapper added to JacksonJsonPayloadConverter by https://github.com/temporalio/java-sdk/pull/150

</details>


---

<a id="2565"></a>

### #2565: Upgrade grpc version

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2565 |
| **State** | CLOSED |
| **Author** | gregor-rayman (Gregor Ra√Ωman) |
| **Created** | 2025-06-18 16:45:24.000 UTC (6 months ago) |
| **Updated** | 2025-06-18 17:50:28.000 UTC |
| **Closed** | 2025-06-18 17:14:37.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
The used version 1.58.1 is quite old and upgrading to 1.60.0 leads to a runtime error 

```
java.lang.NoClassDefFoundError: io/grpc/internal/AbstractManagedChannelImplBuilder
	at io.temporal.serviceclient.ChannelManager.prepareChannel(ChannelManager.java:206)
	at io.temporal.serviceclient.ChannelManager.<init>(ChannelManager.java:118)
	at io.temporal.serviceclient.ChannelManager.<init>(ChannelManager.java:98)
	at io.temporal.serviceclient.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:84)
	at io.temporal.serviceclient.WorkflowServiceStubs.newServiceStubs(WorkflowServiceStubs.java:66)
```

because the class io.grpc.internal.AbstractManagedChannelImplBuilder has been removed from grpc-services.

This means that the Java temporal-sdk cannot be used in an application that uses other GRPC functionality with a more current version.

**Describe the solution you'd like**
Change the dependency to a current grpc version (1.73.0 when submitting this issue)

**Describe alternatives you've considered**
In my specific use case  we have considering downgraded the grpc version to to 1.58.1, I consider that a temporary workaround, not really a solution.   The currently used version 1.58.1 is from 2023, so the word _temporary_ is questionable   ;) 



#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-18 17:14:37.000 UTC</summary>

>This means that the Java temporal-sdk cannot be used in an application that uses other GRPC functionality with a more current version.

This is not true, we actually test against grpc `1.72.0`in our CI so I can confirm it does work. 

The Java SDK builds against an older version of grpc since we are a library but you are encouraged to use a more recent version in your application.

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-18 17:19:24.000 UTC</summary>

A possible cause of your specific error is mixing different versions of gRPC, but I can't say without a reproduction. 

The Java SDK CI does explicitly validate that the SDK works with the latest version of gRPC Java so I am confident this is not an issue with the SDK itself

</details>

<details>
<summary><strong>gregor-rayman</strong> commented on 2025-06-18 17:50:28.000 UTC</summary>

Thanks for the clarification. It is indeed possible that in our case some grpc libraries have different versions that other ones. I will try to put the version of grpc all needed libraries explicitly.

</details>


---

<a id="2557"></a>

### #2557: Support fetching workflow id and workflow run id through ScheduleActionExecution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2557 |
| **State** | CLOSED |
| **Author** | madhav2302 (Madhav Sodhani) |
| **Created** | 2025-06-13 03:08:50.000 UTC (7 months ago) |
| **Updated** | 2025-06-13 04:31:33.000 UTC |
| **Closed** | 2025-06-13 03:18:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to fetch active running workflows through schedule describe call. 
The problem is `scheduleDescription.getInfo().getRunningActions();` returns list of [ScheduleActionExecution](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/schedules/ScheduleActionExecution.java) object, which doesn't have workflow id and workflow run id, so I need to cast it to [ScheduleActionExecutionStartWorkflow](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/schedules/ScheduleActionExecutionStartWorkflow.java#L6) to fetch these values. 
```
 ScheduleDescription scheduleDescription = scheduleClient.getHandle("scheduleId").describe();
        var runningActions = scheduleDescription.getInfo().getRunningActions();
        var workflowIds = new ArrayList<String>();
        for (var runningAction : runningActions) {
            if (runningAction instanceof ScheduleActionExecutionStartWorkflow execution) {
                workflowIds.add(execution.getWorkflowId());
            } else {
                throw new IllegalStateException("Unexpected runningAction : " + runningAction + "; type: " + runningAction.getClass());
            }
        }
        return workflowIds;
```

**Describe the solution you'd like**
We should add `getWorkflowId` and `getFirstExecutionRunId` abstract methods in `ScheduleActionExecution`, so we don't need to cast at all and it can be easily supported if some inheritance or something else changes with these 2 classes. 

**Describe alternatives you've considered**
We have tried to cast `ScheduleActionExecution` into `ScheduleActionExecutionStartWorkflow` to fetch the values, and use them. It's not cleaner though. 


#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-13 03:12:07.000 UTC</summary>

`ScheduleActionExecution ` is an interface to represent a generic action. It cannot contain logic for a specific action type. In the future schedules may be used for other actions like scheduling nexus operations or activities that do not have workflow id or workflow run id.

Casting is the right approach here

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-13 03:23:03.000 UTC</summary>

Closing since `ScheduleActionExecution ` is a variant type to contain multiple different types of `Schedule*Execution`. Currently we only have one (`ScheduleActionExecutionStartWorkflow `) , but that will not always be the case.

Unfortunately Java 8 doesn't have a better way to represent a variant type 

</details>

<details>
<summary><strong>madhav2302</strong> commented on 2025-06-13 03:37:34.000 UTC</summary>

I am not sure what other running actions can schedules have, as at top level they are meant to schedule workflows. 

Would it be possible to have a cleaner api in `describe` or `getInfo` to simply provide `runningWorkflows`? 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-13 03:45:58.000 UTC</summary>

Schedules are not just for scheduling workflows, they are for scheduling an action. In the future schedules may support other actions like nexus operations or activities.

</details>

<details>
<summary><strong>madhav2302</strong> commented on 2025-06-13 04:27:20.000 UTC</summary>

I believe every action will have an `id` which can be simply provided as abstract method in `ScheduleActionExecution`. 

Casting is a not a great idea, and people don't know about different actions unless they look into SDK implementation. 

It would be nice to provide `getActionType()` and `getId()` methods accordingly or `getActionMetadata()` with java generics which can simply have id and other action details. 

Just my 2 cents, as we will anyways need to cast them if nothing else is provided. 

</details>


---

<a id="2498"></a>

### #2498: [Feature] Make Jackson serialization an optional and separate module

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2498 |
| **State** | CLOSED |
| **Author** | rocketraman (Raman Gupta) |
| **Created** | 2025-05-01 19:08:56.000 UTC (8 months ago) |
| **Updated** | 2025-05-01 19:36:31.000 UTC |
| **Closed** | 2025-05-01 19:36:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
My system does not use Jackson serialization. Rather I have configured my own JSON data converter that uses kotlinx-serialization.

However, the temporal-sdk has a runtime dependency on Jackson, so Jackson gets pulled transitively in any case.

Many projects in the wild have hard dependencies on Jackson, and versioning of the Jackson dependencies pulled by Temporal can be an issue. Also, having Jackson in the classpath [affects the behavior](https://docs.spring.io/spring-framework/reference/languages/kotlin/web.html#kotlin-multiplatform-serialization) of libraries like Spring Boot.

**Describe the solution you'd like**
I'd like the Jackson dependencies to be optional. One way to do this is to create a separate artifact e.g. temporal-sdk-jackson which adds the required Jackson-based data converter to the SDK if it is present. This type of runtime detection of an implementation can be done via the Java Service Provider interface (just like how SLF4J discovers implementations at runtime).

**Describe alternatives you've considered**
I've tried excluding Jackson from the classpath via Gradle. However, this is not possible because `DefaultDataConverter loads the `JacksonJsonPayloadConverter` statically, and `PayloadAndFailureDataConverter` cannot be used directly because it is package-private.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-01 19:16:59.000 UTC</summary>

The Java SDK requires jackson (and protobuf) for basic functionality, it is not an optional dependency that could be removed from the SDK. I don't think this is something we could consider at this time. If the Java standard library ever had native support for json serialization we could resist requiring  jackson for those versions.

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2025-05-01 19:18:58.000 UTC</summary>

> The Java SDK requires jackson (and protobuf) for basic functionality,

The JSON serialization/deserialization could not be made pluggable via an interface?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-01 19:25:04.000 UTC</summary>

JSON serialization/deserialization for user types is already pluggable via the `DataConverter` interface. For SDK internal use it is not pluggable and would a significant effort and I don't think we would ever be able to support `kotlinx-serialization`.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-01 19:26:52.000 UTC</summary>

and removing the dependency on `Jackson` and requiring them to include a separate module would be breaking change and not something we would consider without a major version bump

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2025-05-01 19:30:11.000 UTC</summary>

> For SDK internal use it is not pluggable and would a significant effort and I don't think we would ever be able to support `kotlinx-serialization`.

I see. Thank you for explaining the limitations. I'll go ahead and close but can you give some brief explanation of what the SDK uses JSON serialization for internally? I thought the Temporal API used gRPC and Protobuf.

> and removing the dependency on `Jackson` and requiring them to include a separate module would be breaking change and not something we would consider without a major version bump

This wouldn't be an issue. It could be worked around by including it transitively for minor updates of the SDK. Users could exclude it themselves if they needed to. The next major bump could then require it to be included separately.

</details>


---

<a id="2203"></a>

### #2203: Async activity inputs potential memory leak

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2203 |
| **State** | CLOSED |
| **Author** | hansen-jake |
| **Created** | 2024-08-31 03:41:59.000 UTC (1y 4m ago) |
| **Updated** | 2024-10-15 15:05:31.000 UTC |
| **Closed** | 2024-10-15 15:05:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When starting multiple async activities within a workflow, references to the activity inputs are never null‚Äôd out so the inputs are never garbage collected, leading to a memory leak. This has caused our workers to run out of memory.

## Expected Behavior

The expectation/assumption is that as activities within a workflow complete, references to their inputs are null‚Äôd out, making them eligible for garbage collection.

## Actual Behavior

After running the below code for a while, a heap dump shows that a strong reference to each activity input is held by the class `WorkflowOutboundCallsInterceptor$ActivityInput`, even after each activity completes, causing a memory leak.

## Steps to Reproduce the Problem

See below code for reproduction.

## Specifications

  - Version: Java SDK 1.25.1

```java
// NOT A CONTRIBUTION

public class Main {
    public static void main(String[] args) {
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
        WorkflowClient client = WorkflowClient.newInstance(service);
        WorkerFactory factory = WorkerFactory.newInstance(client);
        Worker worker = factory.newWorker("task_queue");
        worker.registerWorkflowImplementationTypes(EventLoopWorkflowImpl.class);
        worker.registerActivitiesImplementations(new ProcessingActivityImpl(client));
        factory.start();

        EventLoopWorkflow workflow = client.newWorkflowStub(
                EventLoopWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setWorkflowId(UUID.randomUUID().toString())
                        .setTaskQueue("task_queue")
                        .build());

        workflow.startEventLoop();
    }

    @WorkflowInterface
    public interface EventLoopWorkflow {

        @WorkflowMethod
        void startEventLoop();

        @SignalMethod
        void addBatch(List<String> batch);
    }

    public static class EventLoopWorkflowImpl implements EventLoopWorkflow {

        private final ConcurrentLinkedQueue<Supplier<?>> eventQueue = new ConcurrentLinkedQueue<>();

        private final ProcessingActivity activity = Workflow.newActivityStub(
                ProcessingActivity.class,
                ActivityOptions.newBuilder()
                        .setStartToCloseTimeout(Duration.ofHours(24))
                        .build());

        @Override
        public void startEventLoop() {
            var getBatches = Async.procedure(activity::getBatches);

            do {
                Workflow.await(() -> getBatches.isCompleted() || !eventQueue.isEmpty());

                Supplier<?> event;
                while ((event = eventQueue.poll()) != null) {
                    event.get();
                }

            } while (!getBatches.isCompleted());
        }

        @Override
        public void addBatch(List<String> batch) {
            eventQueue.add(() -> Async.procedure(activity::processBatch, batch));
        }
    }

    @ActivityInterface
    public interface ProcessingActivity {

        void getBatches();

        void processBatch(List<String> items);
    }

    public static class ProcessingActivityImpl implements ProcessingActivity {

        private final WorkflowClient workflowClient;

        public ProcessingActivityImpl(WorkflowClient workflowClient) {
            this.workflowClient = workflowClient;
        }


        @Override
        public void getBatches() {
            var ctx = Activity.getExecutionContext();
            var workflow = workflowClient.newWorkflowStub(EventLoopWorkflow.class, ctx.getInfo().getWorkflowId());
            int batchId = 0;

            while (true) {
                try {
                    workflow.addBatch(List.of(String.valueOf(batchId++)));
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        @Override
        public void processBatch(List<String> items) {
            System.out.println("Processing batch " + items.get(0));
        }
    }
}
```


#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-01 23:30:08.000 UTC</summary>

Thank you for the detailed reproduction. Running the provided code and looking at a memory snapshot it looks like the activity input is being held because the internal `ActivityStateMachine` holds it and the state machine is being held by the cancellation callback in the `CancellationScope`. We could make the cancellation callback hold a weak reference to the state machine or remove the cancellation callback once the `ActivityStateMachine` is in an terminal state.

</details>

<details>
<summary><strong>hansen-jake</strong> commented on 2024-09-03 16:32:54.000 UTC</summary>

What are the tradeoffs of doing one over the other?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-03 22:49:47.000 UTC</summary>

From the user perspective very little. Either would remove the reference to the StateMachine and let the input be GC'd

</details>

<details>
<summary><strong>hansen-jake</strong> commented on 2024-09-04 17:20:06.000 UTC</summary>

Is there a target version where this fix can be included? 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-06 16:45:33.000 UTC</summary>

Yes I hope to have some improvements here for the next minor SDK release . 

</details>


---

<a id="2177"></a>

### #2177: Include Package Version Information in manifest 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2177 |
| **State** | CLOSED |
| **Author** | melloware (Melloware) |
| **Created** | 2024-08-09 18:43:19.000 UTC (1y 5m ago) |
| **Updated** | 2025-01-17 00:06:05.000 UTC |
| **Closed** | 2025-01-17 00:06:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Your Manifest is how JARS are identified.

For example:
`WorkflowClient.class.getPackage().getImplementationVersion()` returns `NULL` because your manifest is empty.

A proper manifest you can genereate with GRadle easily to look something like this... from Caffeine.

```
Manifest-Version: 1.0
Automatic-Module-Name: com.github.benmanes.caffeine
Build-Jdk-Spec: 11
Bundle-Description: A high performance caching library
Bundle-License: https://www.apache.org/licenses/LICENSE-2.0
Bundle-ManifestVersion: 2
Bundle-Name: com.github.ben-manes.caffeine
Bundle-SymbolicName: com.github.ben-manes.caffeine
Bundle-Version: 3.1.8
Export-Package: com.github.benmanes.caffeine.cache;uses:="com.github.b
 enmanes.caffeine.cache.stats";version="3.1.8",com.github.benmanes.caf
 feine.cache.stats;uses:="com.github.benmanes.caffeine.cache";version=
 "3.1.8",com.github.benmanes.caffeine;version="3.1.8"
Implementation-Title: A high performance caching library
Implementation-Version: 3.1.8
Require-Capability: osgi.ee;filter:="(&(osgi.ee=JavaSE)(version=11))"

```



#### Comments (5)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-09 19:04:15.000 UTC</summary>

The Java SDK does contain a manifest, however the manifest may not contain package version information. There is no strong reason we cannot add that though.

</details>

<details>
<summary><strong>melloware</strong> commented on 2024-08-09 19:06:05.000 UTC</summary>

Yes I apologize I meant  your Manifest is empty.

```
Manifest-Version: 1.0
```



Reactions: üëç 1

</details>

<details>
<summary><strong>melloware</strong> commented on 2024-08-09 19:18:31.000 UTC</summary>

thanks in advance @Quinn-With-Two-Ns we are trying to create a Quarkus Extension for Temporal: https://github.com/quarkiverse/quarkus-temporal

Reactions: üëÄ 1

</details>

<details>
<summary><strong>melloware</strong> commented on 2024-08-16 14:48:28.000 UTC</summary>

this can be done with some pseudo code below but I have no idea where to plug this into your Gradle build ecosystem.

```groovy
plugins {
    id 'java'
}

jar {
    manifest {
        attributes(
            'Implementation-Title': 'My Application',
            'Implementation-Version': version,
        )
    }
}
```

</details>

<details>
<summary><strong>melloware</strong> commented on 2024-09-26 18:08:17.000 UTC</summary>

Bump.  For our Quarkus Extension we would like to display the version of Temporal in use on the DevOps card but right now we display ? because we can't detect the version.

![image](https://github.com/user-attachments/assets/e79a21c4-1e69-42c7-acce-befd59d4bcfa)


</details>


---

<a id="1378"></a>

### #1378: Pass real WorkflowId for full replay exposed to users in Worker#replayWorkflowExecution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1378 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-19 05:18:19.000 UTC (3y 4m ago) |
| **Updated** | 2023-01-26 19:05:15.000 UTC |
| **Closed** | 2023-01-26 19:05:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

## Actual Behavior

[Currently](https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/internal/worker/QueryReplayHelper.java#L76) during a full replay that is explicitly exposed to users using `Worker#replayWorkflowExecution`, JavaSDK supplies [fake](https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/internal/common/WorkflowExecutionHistory.java#L115) WorkflowId which can break determinism if workflow code depends on these values.

## Expected Behavior

Actual values from the history should be taken and supplied to the Workflow in WorkflowInfo during replay.

## Additional context

https://community.temporal.io/t/recommended-approach-to-testing-backwards-compatibility/5511

Good catch from Max that the same shouldn't apply to RunID, because usage of runId in workflow code is non-deterministic (think of reset)

#### Comments (5)

<details>
<summary><strong>mfateev</strong> commented on 2022-08-19 17:03:47.000 UTC</summary>

 The workflow code must not depend on runId as reset operation changes it.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-19 17:24:05.000 UTC</summary>

@mfateev Fair, good catch on runId. I will add this comment on WorkflowInfo#getRunId javadoc, because I don't think we state this unobvious fact anywhere.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-08-19 18:41:30.000 UTC</summary>

We should consider putting run_id in unsafe (might be too late though), the only issue is that the current run_id isn't stored in history so we can't provide it to the replayer, we only have original_run_id in WorkflowExecutionStarted which is the closest thing.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2022-08-20 01:14:56.000 UTC</summary>

There is [originalRunId](https://github.com/temporalio/api/blob/79e9495c8f2c2518bb29cb72056c796b5b9fc26a/temporal/api/history/v1/message.proto#L77) that is preserved on reset.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-26 19:05:14.000 UTC</summary>

Addressed by #1497

</details>


---

<a id="1056"></a>

### #1056: ParameterizedTypeImpl class cast exception

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1056 |
| **State** | CLOSED |
| **Author** | geirhoe |
| **Created** | 2022-02-27 13:36:02.000 UTC (3y 10m ago) |
| **Updated** | 2024-12-23 13:01:10.000 UTC |
| **Closed** | 2024-12-23 13:01:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When starting a workflow, the worker using temporal-sdk 1.6.0 fails with the following error

13:34:33.608 [Workflow Executor taskQueue="test-queue", namespace="pmdi.o11n.test-namespace": 4] ERROR i.t.internal.worker.PollerOptions - uncaught exception
java.lang.RuntimeException: Failure processing workflow task. WorkflowId=3dfcaab2-7d2d-4b75-b013-abdea39bdf10, RunId=c5d10d3e-a77a-49dc-ae0d-1e09d25d842f, Attempt=3
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:297)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:195)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 6 of type 'EVENT_TYPE_WORKFLOW_TASK_STARTED' during execution. {PreviousStartedEventId=6, workflowTaskStartedEventId=6, Currently Processing StartedEventId=6}
	at io.temporal.internal.statemachines.WorkflowStateMachines.createEventProcessingException(WorkflowStateMachines.java:223)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:202)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:176)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:176)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:145)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:122)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:97)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:237)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:195)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 3 common frames omitted
Caused by: java.lang.RuntimeException: WorkflowTask: failure executing SCHEDULED->WORKFLOW_TASK_STARTED, transition history is [CREATED->WORKFLOW_TASK_SCHEDULED]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:151)
	at io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:101)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:67)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleSingleEvent(WorkflowStateMachines.java:236)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:200)
	... 11 common frames omitted
Caused by: java.lang.ClassCastException: class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl cannot be cast to class java.lang.Class (sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl and java.lang.Class are in module java.base of loader 'bootstrap')
	at io.temporal.common.converter.DataConverter.arrayFromPayloads(DataConverter.java:92)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:285)
	at io.temporal.internal.sync.WorkflowExecuteRunnable.run(WorkflowExecuteRunnable.java:72)
	at io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:137)
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:101)
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:111)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	... 3 common frames omitted


I have created a small sample project that shows the error, please give me an email adress I can send it to

#### Comments (5)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-02-27 17:56:24.000 UTC</summary>

@geirhoe feel free to send the reproduction to dmitry@temporal.io

</details>

<details>
<summary><strong>geirhoe</strong> commented on 2022-02-28 14:05:25.000 UTC</summary>

This is caused by user error.

The workflow expects a map, and none is provided by the start workflow command. Using this start command, the worker works without error:

tctl --namespace pmdi.o11n.test-namespace workflow start --taskqueue test-queue --workflow_type LogVarsWorkflow --input '{"test":"test"}'

Perhaps she sdk should report this a an error instead of causing this stack trace ?

Reactions: üëç 1

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-01 16:16:49.000 UTC</summary>

I agree that this stacktrace is cryptic and doesn't communicate the underlying reason clearly. I will take a look into improving this.

</details>

<details>
<summary><strong>josh-berry</strong> commented on 2023-12-26 22:49:19.000 UTC</summary>

Not sure if this is still an issue since this was reported quite some time ago. Sounds like the actual issue here is: when an invalid (non-map-shaped) input is provided to a workflow, the reported stack trace is confusing. Is that a fair summary?

Do we know if this is still an issue in recent Java SDKs?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 13:01:09.000 UTC</summary>

The error handling here is very different from when this issue was first open so the underlying user error should be more understandable.

</details>


---

<a id="849"></a>

### #849: Logging

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/849 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-28 19:06:58.000 UTC (4y 2m ago) |
| **Updated** | 2025-10-04 14:17:27.000 UTC |
| **Closed** | 2025-05-13 16:42:24.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 1 |
| **Priority Score** | 5 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

# Description

Decrease verbosity and levels of logs produced by Temporal SDK.
Provide flexibility for users to configure logging of errors and exceptions produced as a result of execution of users' code.

# Core Objectives

There are user complaints about general verbosity of logging in Temporal and misleading errors (like using ERROR level for something that doesn't affect and prevent future correct work of SDK).
This Epic tracks tasks related to improving logging situation and providing a framework allowing users to customize logs produced as a result of users' code execution.  

# Tasks

- [x] #704
- [ ] #631

# Related user requests / reports

- [x] #618

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:42:24.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="744"></a>

### #744: Some jobs are forever in 'Running' State with WorkflowTaskFailed Error 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/744 |
| **State** | CLOSED |
| **Author** | gosandhya (Sandhya Gopchandani) |
| **Created** | 2021-09-21 08:20:54.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-26 23:39:21.000 UTC |
| **Closed** | 2021-09-23 16:50:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

Some of the workflows remain in Running state while WorkFlowTask failed activity is triggered with the following error. This seems to happen only when I trigger multiple (20-100) instances of the workflow at the same time so it is a little sporadic in nature. The same workflow that works normally, hangs in ‚Äòrunning‚Äô mode with the error below:

## Expected Behavior
All runs finish with 'complete' status 

## Actual Behavior
Some runs fail with the following bug

```
15:25:20.731 [Workflow Executor taskQueue="Classify", namespace="default": 1568] ERROR i.t.internal.worker.PollerOptions - uncaught exception
java.lang.RuntimeException: Failure processing workflow task. WorkflowId=438cb389-3973-49cf-b298-64cee904ad44, RunId=6810e3eb-be56-4e3b-b810-3c12bf44f76e, Attempt=798
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:349)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:279)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 302 of 'EVENT_TYPE_WORKFLOW_TASK_STARTED' type. IsReplaying=false, PreviousStartedEventId=302, workflowTaskStartedEventId=302, Currently Processing StartedEventId=302
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:188)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleEvent(ReplayWorkflowRunTaskHandler.java:140)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:180)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:150)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:201)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:114)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:319)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:279)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 3 common frames omitted
Caused by: java.lang.RuntimeException: WorkflowTask: failure executing SCHEDULED->WORKFLOW_TASK_STARTED, transition history is [CREATED->WORKFLOW_TASK_SCHEDULED]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:140)
	at io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:91)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:63)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventImpl(WorkflowStateMachines.java:205)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:173)
	... 11 common frames omitted
Caused by: java.lang.ClassCastException: class scala.runtime.NonLocalReturnControl cannot be cast to class java.lang.Exception (scala.runtime.NonLocalReturnControl is in unnamed module of loader 'app'; java.lang.Exception is in module java.base of loader 'bootstrap')
	at io.temporal.serviceclient.CheckedExceptionWrapper.wrap(CheckedExceptionWrapper.java:56)
	at io.temporal.internal.sync.WorkflowInternal.wrap(WorkflowInternal.java:412)
	at io.temporal.internal.sync.DeterministicRunnerImpl.runUntilAllBlocked(DeterministicRunnerImpl.java:211)
	at io.temporal.internal.sync.SyncWorkflow.eventLoop(SyncWorkflow.java:148)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.eventLoop(ReplayWorkflowExecutor.java:74)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler$EntityManagerListenerImpl.eventLoop(ReplayWorkflowRunTaskHandler.java:329)
	at io.temporal.internal.statemachines.WorkflowStateMachines.eventLoop(WorkflowStateMachines.java:400)
	at io.temporal.internal.statemachines.WorkflowStateMachines.access$500(WorkflowStateMachines.java:71)
	at io.temporal.internal.statemachines.WorkflowStateMachines$WorkflowTaskCommandsListener.workflowTaskStarted(WorkflowStateMachines.java:820)
	at io.temporal.internal.statemachines.WorkflowTaskStateMachine.handleCompleted(WorkflowTaskStateMachine.java:121)
	at io.temporal.internal.statemachines.WorkflowTaskStateMachine.handleStarted(WorkflowTaskStateMachine.java:113)
	at io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:45)
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:137)
	... 15 common frames omitted
```

## Steps to Reproduce the Problem

  1. kick-off 20-100 jobs of a custom workflow
  2. Most of them would complete successfully while few (1-9) would be in forever running state with workflowTaskFailed Activity
  

## Specifications

  - Version: Temporal Client SDK version 1.3.1
  - Platform: IntelliJ


#### Comments (5)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-21 20:42:15.000 UTC</summary>

Hi @gosandhya 

> Failure handling event 302 of 'EVENT_TYPE_WORKFLOW_TASK_STARTED'

It looks like we at least have workflows with some pretty long histories here.

Any chance you can provide some isolation or reproduction of the problem?
If you can't, maybe you can provide some additional details or characteristics about the type of workflows you run. 

</details>

<details>
<summary><strong>gosandhya</strong> commented on 2021-09-22 08:28:24.000 UTC</summary>

Hello @Spikhalskiy 

We run a classification workflow that has multiple activities that perform fetching the data, disk operations, and finally interacting with various APIs to get back the results.

Maxim pointed out there might be an edge case unhandled in temporal Java SDK particularly NonLocalReturnControl exception extending Throwable directly in Scala which is not ideal. So was hoping this issue could be fixed.

```
Caused by: java.lang.ClassCastException: class scala.runtime.NonLocalReturnControl cannot be cast to class java.lang.Exception (scala.runtime.NonLocalReturnControl is in unnamed module of loader 'app'; java.lang.Exception is in module java.base of loader 'bootstrap')
	at io.temporal.serviceclient.CheckedExceptionWrapper.wrap(CheckedExceptionWrapper.java:56)
	at io.temporal.internal.sync.WorkflowInternal.wrap(WorkflowInternal.java:412)
```


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-22 23:55:36.000 UTC</summary>

Class cast exception will be fixed in 1.4.0 and the error message will be easier to read and will contain the original stacktrace, but the behavior itself (workflow "stuck" in Running) will not change.

Temporal treats only subclasses of TemporalFailure as workflow execution failure, other throwables are treated like workflow bugs, and Temporal continues to retry them.
In your case, workflows are not stuck, Temporal actually keeps retrying them and they will succeed if you fix the exception and redeploy the workers.
If you want the `scala.runtime.NonLocalReturnControl` Throwable be treated as a workflow execution failure, wrap it into TemporalFailure class or use WorkflowImplementationOptions#setFailWorkflowExceptionTypes https://github.com/temporalio/sdk-java/blob/657a392333e6d623fda91b1d7a0ea1f152f2eb9b/temporal-sdk/src/main/java/io/temporal/worker/WorkflowImplementationOptions.java#L68 to specify `scala.runtime.NonLocalReturnControl ` as a type that causes Workflow fail.

</details>

<details>
<summary><strong>gosandhya</strong> commented on 2021-09-26 18:34:03.000 UTC</summary>

Hi, thank you for responding to this promptly! Appreciate it.

Do you have any time estimate for when will version 1.4.0 be released?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-26 23:38:50.000 UTC</summary>

We are currently targeting October 5, but it's normal for Temporal to delay releases if we are unsure about safety.

</details>


---

<a id="706"></a>

### #706: Unable to remove`Workflow#getVersion` calls once added to a workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/706 |
| **State** | CLOSED |
| **Author** | jonsie (Chris Smalley) |
| **Created** | 2021-09-09 21:46:41.000 UTC (4y 4m ago) |
| **Updated** | 2021-10-27 18:24:27.000 UTC |
| **Closed** | 2021-10-27 18:24:27.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 1 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.5.0 |
| **Reactions** | üëç 2 |

#### Description

Not sure if this is a bug report or a feature request - I could see it being a feature request.  Additionally I'm not sure if this issue is isolated to the Java SDK.

## Expected Behavior

Once all workflows that are running on the old version are completed, one should be able to remove that code path (which is possible today) -- **including** the call to `Workflow#getVersion`.  This way, the codebase does not have to contain calls to `Workflow#getVersion` that signify nothing.

## Actual Behavior

Removing the call to `Workflow#getVersion` is not safe and breaks workflow replay.

If you have a workflow history that contains a version marker (just a call to `Workflow#getVersion`), and you remove that version marker from a workflow it breaks replay when running the history via `Worker#replayWorkflowExecution`.

This means that if you expect your workflows to replay (queried, activity retries, etc), you can never remove a call to `Workflow#getVersion` without breaking the replay.

The documentation recommends a two step process to remove the version code:  https://docs.temporal.io/docs/java/versioning/

It includes the comment:

```
// getVersion call is left here to ensure that any attempt to replay history
// for a different version fails. It can be removed later when there is no possibility
// of this happening.
``` 

However, I am not clear on what "different version" means here - any attempt to replay history with the version marker in the history (which all versions will have) but with the `Workflow#getVersion` call removed from the code will break replay-ability.

## Steps to Reproduce the Problem

  1.  Create a workflow with a call to `Workflow#getVersion`
  1.  Run the workflow and export the history
  1.  Remove the call to `Workflow#getVersion`
  1.  Replay the workflow history via  `Worker#replayWorkflowExecution`

## Specifications

  - Version:  v1.2.0
  - Platform:  MacOS


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-13 16:26:11.000 UTC</summary>

```
// getVersion call is left here to ensure that any attempt to replay history
// for a different version fails. It can be removed later when there is no possibility
// of this happening.
```

This is how it's designed, yes. 
Version marker should be ignored if `getVersion` call is removed and it's a supported behavior.
So it looks like java-sdk Version state machine bug for me.

</details>


---

<a id="621"></a>

### #621: Opentracing: "UnsupportedFormatException: Builtin.TEXT_MAP_INJECT" with Jaeger tracer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/621 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2021-08-05 19:19:44.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-11 01:44:20.000 UTC |
| **Closed** | 2021-08-10 20:18:56.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |
| **Reactions** | üëç 1 |

#### Description

Trying out to use Java SDK OpenTracing support with Jaeger client:

1. Add Jaeger client as depend:

           implementation group: 'io.jaegertracing', name: 'jaeger-client', version: '1.6.0'

2. Create a Tracer:

        JaegerTracer tracer =
        new Configuration("temporal-app")
          .withReporter(
              new Configuration.ReporterConfiguration()
                  .withSender(
                      new Configuration.SenderConfiguration()
                          .withEndpoint("http://localhost:14268/api/traces")))
          .withCodec(
              new Configuration.CodecConfiguration()
                  .withCodec(Format.Builtin.TEXT_MAP_INJECT, new TextMapCodec(false)))
          .getTracer();


(the .withCodec seems to do absolutely nothing, so can be removed in test even)

3. Set the tracer in OpenTracingOptions

Try tracing, you should get:
    
  Caused by: io.jaegertracing.internal.exceptions.UnsupportedFormatException: Builtin.TEXT_MAP_EXTRACT

## Specifications

  - Version: 1.1.0
  - Platform:


Note - to add Jaeger to your local docker compose yaml you can just add:


     jaeger:
     image: jaegertracing/all-in-one:latest
     ports:
       - "5775:5775/udp"
       - "6831:6831/udp"
       - "6832:6832/udp"
       - "5778:5778"
       - "16686:16686"
       - "14268:14268"
       - "9411:9411"

in the services section

#### Comments (3)

<details>
<summary><strong>tsurdilo</strong> commented on 2021-08-05 19:55:25.000 UTC</summary>

For a simple/local test just import the jaeger client lib (depends) and create a tracer with:

     Reporter reporter = new InMemoryReporter();
      Sampler sampler = new ConstSampler(true);
      Tracer tracer = new JaegerTracer.Builder("temporal-test")
              .withReporter(reporter)
              .withSampler(sampler)
              .build();
      GlobalTracer.registerIfAbsent(tracer);

Or add it to options instead of setting it to GlobalTracer.
The same error comes up this way as well.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-09 21:09:01.000 UTC</summary>

It looks like Jaeger OpenTracing java client doesn't support TEXT_MAP_INJECT and TEXT_MAP_EXTRACT strategies. I filed an issue regarding that into Jaeger java client repo: https://github.com/jaegertracing/jaeger-client-java/issues/789
Taking into account that Jaeger is a major OpenTracing/OpenTelementry solution, I implemented a workaround in temporal for this issue until it's addressed in Jaeger client: https://github.com/temporalio/sdk-java/pull/624 It includes an integration test for Jagger that checks that the setup works with the new encoding strategy: https://github.com/temporalio/sdk-java/pull/624/files#diff-223e2203835203c5115c3be51739372f23426ded63a3e0abf75a8d63d9ce8057R52

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-10 20:18:56.000 UTC</summary>

Closed by #624

</details>


---

<a id="481"></a>

### #481: Allow configuration of workers to back off completely if the server is not available

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/481 |
| **State** | CLOSED |
| **Author** | eminn (Emin Demirci) |
| **Created** | 2021-05-10 16:34:13.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-28 20:57:14.000 UTC |
| **Closed** | 2021-05-28 20:57:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 5 |
| **Priority Score** | 5 |
| **Labels** | enhancement |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I want the workers to stop trying to connecting to the server if the server is not available using `WorkflowServiceStubsOptions`

**Describe the solution you'd like**
I'd like to configure workers to stop polling/trying to connecting to the server if the server is not available after a specified time period.

**Describe alternatives you've considered**
N/A

**Additional context**
Slack discussion https://temporalio.slack.com/archives/CTT84KXK9/p1620663515093300

#### Comments (5)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-05-10 21:27:41.000 UTC</summary>

> workers to stop polling/trying

I don't think that "stopping" is the right semantic here. We still want them to reconnect when the network or the server is back. But it would be good to expose backoffCoefficient config value for workers to slow them down up to some MaximumInterval (basically, expose RetryOptions).

Also, it would be great to expose backoffCoefficient for client stubs too as we discussed here with Vitaly: 
https://github.com/temporalio/sdk-java/pull/472/files#r627959282

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-05-11 19:28:29.000 UTC</summary>

I think we may have both backoff and a parameter that specifies maximum retry period after which we give up and kill the worker. I can see situations where both types of behavior might be desirable based on the specifics of the deployment infrastructure being used.

Reactions: üëç 2

</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-05-12 02:15:04.000 UTC</summary>

Please take a look at [PollerOptions.java#L54](https://github.com/temporalio/sdk-java/blob/23bccf07d54982dd3048ab32f06c06c4811e74ce/temporal-sdk/src/main/java/io/temporal/internal/worker/PollerOptions.java#L54). We currently have default values for 
`pollBackoffCoefficient = 2`
`pollBackoffInitialInterval = 100ms`
`pollBackoffMaximumInterval = 1m`
In the end, the worker will keep polling the server every minute, which should be fine in most cases.
Does this work for you?

</details>

<details>
<summary><strong>eminn</strong> commented on 2021-05-15 17:37:24.000 UTC</summary>

@vkoby In my case I'd need to stop them to fail a k8s deployment as keeping the workers running and letting them try to connect non-existing server would create a lot of noise in terms of logging. This way I don't need to implement a custom health check logic (e.g. checking the namespace exists), the workers will die after configured time or attempt count passes.


</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-05-17 18:24:26.000 UTC</summary>

@eminn Will implement health check. This has already been done in Go SDK see [client.go#L417](https://github.com/temporalio/sdk-go/blob/cea0147023cc324a8adce606d608cb7298e6cfcb/internal/client.go#L417)

</details>


---

<a id="413"></a>

### #413: Workflow#newActivityStub(activityInterface) method produces broken activity stubs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/413 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-03-31 06:17:30.000 UTC (4y 9m ago) |
| **Updated** | 2021-07-16 01:04:19.000 UTC |
| **Closed** | 2021-05-07 04:47:34.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 3 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

ActivityOptions has a requirement that either `startToClose` or `scheduleToClose` has to be defined. ActivityOptions doesn't have any defaults for both of them at the same time. So default ActivityOptions is actually invalid. 

`Workflow#newActivityStub` has two versions: `Workflow#newActivityStub(activityInterface)` and `Workflow#newActivityStub(activityInterface, activityOptions)`. The first version without `activityOptions` param produces an Activity stub with default broken ActivityOptions, so this method never really can be used right now.

#### Comments (3)

<details>
<summary><strong>vitarb</strong> commented on 2021-04-01 04:36:13.000 UTC</summary>

On one hand, since activities are very use case specific, I imagine, it would be hard to pick the "right" value, but on on the other I agree that having invalid default options results in a bad experience. @mfateev what do you think? Should we set schedule to close to something like 10 seconds by default?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-04-01 22:15:05.000 UTC</summary>

Also probably if we enforce "`startToClose` or `scheduleToClose`" rule, ActivityOptions#Builder#validateAndBuildWithDefaults should throw an exception when both of them are not initialized. It's not happening now.

</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-04-28 19:28:00.000 UTC</summary>

There is no good default value for these timeouts and you can now set default activity options through WorkflowImplementationOptions. But good point about throwing an exception when they haven't been set.

</details>


---

<a id="79"></a>

### #79: Log activity failures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/79 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-05 03:17:04.000 UTC (5y 8m ago) |
| **Updated** | 2020-08-22 02:06:18.000 UTC |
| **Closed** | 2020-08-22 02:06:17.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 1 |
| **Priority Score** | 5 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

Currently activity failures are not logged which is very inconvenient  during unit tests that do automatic activity retries.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-22 02:06:17.000 UTC</summary>

Fixed by https://github.com/temporalio/java-sdk/pull/172

</details>


---

<a id="2642"></a>

### #2642: TestWorkflowEnvironment sleep incorrect behaviour

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2642 |
| **State** | OPEN |
| **Author** | oleg-kovrizhin-paradym |
| **Created** | 2025-08-26 14:06:07.000 UTC (4 months ago) |
| **Updated** | 2025-09-25 23:15:15.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

## Expected Behavior

Integration tests with Temporal should not actually sleep or wait when using `TestWorkflowEnvironment.sleep()`.  
The virtual time should advance instantly, regardless of other tests being executed before.

## Actual Behavior

In some cases, tests sleep and wait in real time instead of using virtual time.  
This happens when a test using `TestWorkflowEnvironment.sleep()` runs after another test that executed a child workflow.

## Steps to Reproduce the Problem

1. Use Temporal library 1.30.1 with io.temporal:temporal-spring-boot-starter.

2. Have a workflow with setStartDelay().
 
3. Write an integration test that relies on TestWorkflowEnvironment.sleep(Duration.ofDays(1)).

    When run in isolation, the test passes instantly (virtual time works).

4. Add another test that uses a child workflow, e.g.:

```
TestWorkflow transferWorkflow =
    Workflow.newChildWorkflowStub(
        TestWorkflow.class,
        ChildWorkflowOptions.newBuilder()
            .setWorkflowId("test-id")
            .setTaskQueue("test-task-queues")
            .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)
            .setWorkflowIdReusePolicy(WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)
            .setRetryOptions(RetryOptions.newBuilder()
                .setMaximumAttempts(MAXIMUM_ATTEMPTS)
                .build())
            .build()
    );


Async.procedure(() -> transferWorkflow.test(test.testId()));

Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(transferWorkflow);
childExecution.get();
```


5. Run the whole test suite.

The test with sleep(Duration.ofDays(1)) now sleeps in real time instead of advancing virtual time.

Notes

Behavior is consistent:

‚úÖ Works when the test with sleep is executed alone.

‚ùå Breaks when a test with a child workflow ran before it.

Looks like something in the child workflow test "switches" the TestWorkflowEnvironment from virtual time to real time.

Specifications

Version: 1.30.1

Platform: Java

Dependency: io.temporal:temporal-spring-boot-starter


---

<a id="2564"></a>

### #2564: Bug: workers-auto-discovery in Spring Boot scans packages not in specified list

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2564 |
| **State** | CLOSED |
| **Author** | kulikj01 |
| **Created** | 2025-06-18 10:05:21.000 UTC (6 months ago) |
| **Updated** | 2025-09-11 23:18:08.000 UTC |
| **Closed** | 2025-09-11 15:05:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When specifying a list of packages for workers-auto-discovery in the Temporal Spring Boot starter, only workflows and activities from the explicitly listed packages should be scanned and registered.

Example project structure:
```
src/main/java/com/example:
  migration -> contains workflow and activity definitions -> taskQueues = migration-queue
  publication -> contains workflow and activity definitions -> taskQueues = publication-queue
```

Example configuration:

```
spring:
  temporal:
    start-workers: true
    workers-auto-discovery:
      packages:
        - com.example.publication
```
Only classes under com.example.publication should be discovered and registered.

## Actual Behavior
`2025-06-18T11:05:29.610+02:00  INFO 21486 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Activity Poller taskQueue="migration-queue", namespace="default", identity=21486@PL-WAR-M2QWQ05P}
2025-06-18T11:05:29.617+02:00  INFO 21486 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Workflow Poller taskQueue="publication-queue", namespace="default", identity=21486@PL-WAR-M2QWQ05P}
2025-06-18T11:05:29.620+02:00  INFO 21486 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Activity Poller taskQueue="publication-queue", namespace="default", identity=21486@PL-WAR-M2QWQ05P}`

Even though "migration" package has not been specified in packages, worker is started.

## Side note
Same issue happens if extra namespaces are defined:
```
spring:
  temporal:
    namespaces:
      - namespace: migration
        alias: migration
        start-workers: true
        workers-auto-discovery:
          packages:
            - com.example.migration
    start-workers: true
    workers-auto-discovery:
      packages:
        - com.example.publication
```
All packages are registered in every namespace.
```
2025-04-02T13:45:26.601+02:00  INFO 27170 --- [           main] i.t.s.b.a.template.WorkersTemplate       : Registering auto-discovered activity bean 'publicationActivityImpl' of class class com.example.publication.PublicationActivityImpl on a worker  with a task queue 'publication-queue'
2025-04-02T13:45:26.991+02:00  INFO 27170 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Workflow Poller taskQueue="migration-queue", namespace="migration", identity=27170@EPHUSZEW003C}
2025-04-02T13:45:27.008+02:00  INFO 27170 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Activity Poller taskQueue="migration-queue", namespace="migration", identity=27170@EPHUSZEW003C}
2025-04-02T13:45:27.040+02:00  INFO 27170 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Activity Poller taskQueue="publication-queue", namespace="migration", identity=27170@EPHUSZEW003C}
2025-04-02T13:45:27.045+02:00  INFO 27170 --- [           main] .s.b.a.NonRootNamespaceAutoConfiguration : started workers for non-root namespace [migration]
2025-04-02T13:45:27.046+02:00  INFO 27170 --- [           main] c.stepstone.poc.TemporalMultiNamespace   : Started TemporalMultiNamespace in 8.119 seconds (process running for 10.491)
2025-04-02T13:45:27.069+02:00  INFO 27170 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Activity Poller taskQueue="migration-queue", namespace="default", identity=27170@EPHUSZEW003C}
2025-04-02T13:45:27.075+02:00  INFO 27170 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Workflow Poller taskQueue="publication-queue", namespace="default", identity=27170@EPHUSZEW003C}
2025-04-02T13:45:27.079+02:00  INFO 27170 --- [           main] io.temporal.internal.worker.Poller       : start: Poller{name=Activity Poller taskQueue="publication-queue", namespace="default", identity=27170@EPHUSZEW003C}
```
## Steps to Reproduce the Problem

  1. Create two packages with workflow/activity
  2. Reference only one package in workers-auto-discovery config
  3. See other package being registered

## Specifications

  - Version: 1.28.3/1.29.0
  - Platform: 21.0.4/MacOS


#### Comments (4)

<details>
<summary><strong>kunalvarpe</strong> commented on 2025-09-11 13:43:13.000 UTC</summary>

I would like to contribute over this issue fix.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-11 15:07:21.000 UTC</summary>

This is expected behaviour see the [documentation](https://docs.temporal.io/develop/java/spring-boot-integration#auto-discovery) for what is auto discovered . 

</details>

<details>
<summary><strong>kunalvarpe</strong> commented on 2025-09-11 19:16:52.000 UTC</summary>

> This is expected behaviour see the [documentation](https://docs.temporal.io/develop/java/spring-boot-integration#auto-discovery) for what is auto discovered .

@Quinn-With-Two-Ns 
As per documentation implementation is correct. But in multi namespace configuration the expectation would be that the mentioned  workflow implementation and activities under the namespaces configuration should take precedence rather that activities present in spring context. 

For e.g.,
```yaml
spring:
     temporal:
    connection:
      target: "127.0.0.1:7233"
    namespaces:
      - namespace: "demo"
        workers-auto-discovery:
          packages:
            - "com.example.demo.workflow"
            - "com.example.demo.activity"
      - namespace: "demo2"
        workers-auto-discovery:
          packages:
            - "com.example.demo1.workflow"
            - "com.example.demo1.activity"

```
With above configuration what is happening is worker is register for demo and demo1 namespace from respective package configuration. But activities within demo package will get register in demo1 namespace as well and vice versa. But here expectation would be only specific activities only registered. Spring context activities should be for a option where intention is to share the activities between namespaces.

I believe we should consider the scenario and spent some time to discuss this.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-11 23:18:08.000 UTC</summary>

All activities beans registered in the spring context are registered according to their task queue/worker. Have you looked at the options under `@ActivityImpl` there are ways to control what worker an auto discovered activity would register for.

Note, Spring Beans are objects they don't really have a "package" at all, that concept only applies to workflow implementations since we register workflow classes not Beans. 

</details>


---

<a id="2443"></a>

### #2443: 1.28.1 release - springboot config - apiKeys

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2443 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-03-13 03:12:56.000 UTC (10 months ago) |
| **Updated** | 2025-03-17 17:17:56.000 UTC |
| **Closed** | 2025-03-17 17:17:56.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

docs mention that "If an API key is specified, https will automatically be enabled."

after testing it seems that its not automatically set when defining apiKey or api-key, for example: https://github.com/tsurdilo/apikeysdemo/blob/main/src/main/resources/application.yaml

does not work if enable-https: true is not defined




---

<a id="2414"></a>

### #2414: Expose Workflow cancel cause/reason

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2414 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-02-11 20:44:21.000 UTC (11 months ago) |
| **Updated** | 2025-10-22 16:50:15.000 UTC |
| **Closed** | 2025-10-22 16:50:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

WorkflowExecutionCancelRequestedEventAttributes has a cause field that should be exposed when workflows receive cancels, and we should additionally expose this as an input when users are issuing cancels from clients or commands

#### Comments (4)

<details>
<summary><strong>madhav2302</strong> commented on 2025-03-05 21:31:13.000 UTC</summary>

@Sushisource does this reason also exposed to a running activity when it heartbeats and gets `ActivityCanceledException` execption? 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-10 14:24:11.000 UTC</summary>

@madhav2302 No, this information is not returned by the Server on heartbeat. The only information the Server [returns](https://github.com/temporalio/api/blob/9156239c8272003b6f228951602ca2b130a55876/temporal/api/workflowservice/v1/request_response.proto#L515) is if to cancel the activity.

</details>

<details>
<summary><strong>madhav2302</strong> commented on 2025-03-10 15:10:36.000 UTC</summary>

@Quinn-With-Two-Ns are there any plans to add it? or do we need to open a feature request? 

It would be nice to know the cancellation reason in activity as well, so it helps with easy debugging with each activity when something goes bad. 

</details>

<details>
<summary><strong>antmendoza</strong> commented on 2025-03-10 16:33:04.000 UTC</summary>

Hi @madhav2302 , we have already submitted a feature request for this to our product team.

Reactions: üëç 2

</details>


---

<a id="2412"></a>

### #2412: Marker Commands being sent with empty names in the wild

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2412 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-02-10 19:34:11.000 UTC (11 months ago) |
| **Updated** | 2025-02-13 19:27:45.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
Marker commands should never be sent to server with an empty marker name.

## Actual Behavior
That happened

## Steps to Reproduce the Problem
Unclear. Some user workflows were seen encountering this error on workflow completion:

```BadRecordMarkerAttributes: MarkerName is not set on RecordMarkerCommand.```

From what I could tell looking at the code briefly, the only way it seemed like this might happen is if the marker command was constructed while replaying was true, and then it later became false and sent off the command.

## Specifications
This was definitely Java SDK, which we determined by seeing the stack trace query. Not clear which version. Java needs to do https://github.com/temporalio/sdk-java/issues/1838

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-10 20:01:43.000 UTC</summary>

Commands aren't sent on replay, there was an old bug https://github.com/temporalio/sdk-java/issues/1558 can you confirm this happend with the latest SDK ?

</details>

<details>
<summary><strong>Sushisource</strong> commented on 2025-02-13 19:27:43.000 UTC</summary>

No info on the version unfortunately since it's not being written to the history yet. We could potentially go to the customer and try to ask them about it, this was just something @alexshtin discovered while scanning logs.

</details>


---

<a id="2394"></a>

### #2394: Pure opentelemetry based tracing support instead of using tracershim

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2394 |
| **State** | OPEN |
| **Author** | vijjayy81 (Vijayaraj Muthusamy) |
| **Created** | 2025-01-30 00:03:07.000 UTC (11 months ago) |
| **Updated** | 2025-01-30 00:03:07.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

Opentracing with opentelemetry shim produces the tracing capabilities as we expect.

Could we simply have a module using opentelemetry directly? 


---

<a id="2391"></a>

### #2391: [Bug] Cancelling an activity results in `FailedPrecondition: ACTIVITY_UNKNOWN` error on time skipping server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2391 |
| **State** | OPEN |
| **Author** | mjameswh (James Watkins-Harvey) |
| **Created** | 2023-02-17 15:28:02.000 UTC (2y 10m ago) |
| **Updated** | 2025-01-28 20:33:03.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

### Describe the bug

A user has a workflow that attempts to cancel an activity in the very same WFT where that activity completes (eg. it cancels the activity from a signal handler, so the activity promise has not yet been marked as completed).

Using the official server, the workflows continues execution without problem.

However, using the time skipping test server, the workflow get stuck, and the following error message is being displayed:

```
Network error while completing workflow activation error=status: FailedPrecondition, message: "ACTIVITY_UNKNOWN for scheduledEventId=41"
```

### Minimal Reproduction

A user provided [this repro](https://github.com/Irvenae/ts-temporal/blob/main/src/__tests__/networkError.test.ts).

Another user provided the following code:

```
try {
  await someActivity(); // someActivity works here
  await someActivityThatTriggersCancelation();
} catch (e: unknown) {
  if (isCancellation(e)) {
    await CancellationScope.nonCancellable(async () => {
      await someActivity(); // someActivity fails with "ACTIVITY_UNKNOWN" here
    });
  }
}
```

He also mentioned that he would encounter the same thing if he calls `handle.cancel()` outside of any activity, in the outer test context.

#### Comments (2)

<details>
<summary><strong>mjameswh</strong> commented on 2023-02-17 15:35:05.000 UTC</summary>

**Internal notes**

The error returned by [the Test server](https://github.com/temporalio/sdk-java/blob/ba838febd86bb7033346b075504158d65b81a3d0/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java#L790) is ‚Äúincorrect‚Äù with regards to the official server‚Ä¶

That explains the "Network error" message, but not why the workflow is able to continue forward with the official server, but not with the time skipping test server. In both case, the server should deny the WFT Completion anyway, and [core will evict the workflow in both cases](https://github.com/temporalio/sdk-core/blob/master/core/src/worker/workflow/mod.rs#L524-L535).

An hypothesis is that the test server might fail to send a subsequent WFT for some reason.

</details>

<details>
<summary><strong>josiah-roberts</strong> commented on 2023-02-22 01:19:24.000 UTC</summary>

Watching this issue; right now we're able to write tests for our no-sleep workflows, but not workflows that sleep.

</details>


---

<a id="2276"></a>

### #2276: Null pointer exception on passing empty search attribute in workflow options

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2276 |
| **State** | CLOSED |
| **Author** | lazy-ninja (Niraj) |
| **Created** | 2024-10-17 14:19:56.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-18 06:16:30.000 UTC |
| **Closed** | 2024-10-17 21:54:04.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
It shouldn't throw a null pointer exception.

```java 
//return null for empty search attributes. 
SearchAttributesUtil.encodeTyped(options.getTypedSearchAttributes()); 

//on setting null search attributes in the StartWorkflowExecutionRequest, it will throw NPE
request.setSearchAttributes(startParameters.getSearchAttributes());

//StartWorkflowExecutionRequest#setSearchAttributes
if (searchAttributesBuilder_ == null) {
  if (value == null) {
    throw new NullPointerException();
  }

```

## Actual Behavior
It throws null pointer exception



## Steps to Reproduce the Problem
  1. Create workflow options as 
  ```java 
WorkflowOptions workflowOptions = WorkflowOptions.newBuilder()
        .setTaskQueue("queue")
        .setWorkflowId("workflow-id-1")
        .setTypedSearchAttributes(SearchAttributes.EMPTY)
        .build();
  ```
 2. create workflow stub for any workflow
 ```java 
stub = workflowClient.newWorkflowStub(SampleWorkflow.class, workflowOptions);
```
3.  Submit for execution 
```java 
WorkflowClient.start(stub::execute, {});
```
## Specifications

  - Version: 1.22.3
  - Platform: MacOS



#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-17 15:11:52.000 UTC</summary>

Thanks for the bug report! will file a fix for this.

</details>

<details>
<summary><strong>lazy-ninja</strong> commented on 2024-10-18 06:16:29.000 UTC</summary>

@Quinn-With-Two-Ns thanks for fixing it. can you fix it in the `1.22.x` as well?

</details>


---

<a id="2189"></a>

### #2189: Schedules without a catch up window use the min catch up window instead of the default catch up window

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2189 |
| **State** | CLOSED |
| **Author** | dcohen8128 (David Cohen) |
| **Created** | 2024-08-15 21:41:42.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-18 00:35:26.000 UTC |
| **Closed** | 2024-08-18 00:35:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
It's indicated in a few places that the default catch up window on a schedule is 1 year:
1. [The documentation website](https://docs.temporal.io/workflows#catchup-window)
2. [The proto definition](https://github.com/temporalio/api/blob/v1.37.0/temporal/api/schedule/v1/message.proto#L239)
3. [The server code](https://github.com/temporalio/temporal/blob/v1.24.2/service/worker/scheduler/workflow.go#L208)

So I would expect that if I don't set a catch up window on my `SchedulePolicy` when creating the schedule it will use the default value of 1 year.

## Actual Behavior
If you don't set a catch up window on the `SchedulePolicy` the SDK will turn that into a duration of 0 when converting it into the proto `Duration` object [here](https://github.com/temporalio/sdk-java/blob/v1.24.3/temporal-sdk/src/main/java/io/temporal/internal/common/ProtobufTimeUtils.java#L76-L85). Then on the server the it will see that 0 is lower than the 10 second `minCatchupWindow` and use the min instead [here](https://github.com/temporalio/temporal/blob/v1.24.2/service/worker/scheduler/workflow.go#L1149).

## Steps to Reproduce the Problem
Create a schedule with a policy that does not contain a catch up window:

```java
var policy = SchedulePolicy.newBuilder()
        .setCatchupWindow(null) // Or, remove this line since null is the default
        .build();

var schedule = Schedule.newBuilder()
        /* set action and spec and whatever else you want */
        .setPolicy(policy)
        .build();

var handle = scheduleClient.createSchedule("ScheduleId", schedule, ScheduleOptions.newBuilder().build());
```

## Specifications

  - Version: As far as I can tell, all versions since Schedules were released (Server - 1.17.0+, Java SDK - 1.20.0+)
  - Platform:


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-15 21:44:36.000 UTC</summary>

This behaviour was changed in https://github.com/temporalio/sdk-java/commit/9a856f30 which is included in Java SDK 1.24.0+

</details>

<details>
<summary><strong>dcohen8128</strong> commented on 2024-08-15 21:45:31.000 UTC</summary>

Oh cool, we have a bunch of systems using older versions of the SDK so that's what I had dug through. My fault for not checking the whole data flow in the newer version.

</details>

<details>
<summary><strong>dcohen8128</strong> commented on 2024-08-15 21:48:04.000 UTC</summary>

For existing schedules can we do a no-op update to remove the 0 value from the policy?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-18 00:35:26.000 UTC</summary>

Yes you can update the schedule with new policy to remove to remove the value

</details>


---

<a id="2180"></a>

### #2180: Workflow.newExternalWorkflowStub

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2180 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2024-08-11 18:58:44.000 UTC (1y 5m ago) |
| **Updated** | 2025-05-26 17:06:29.000 UTC |
| **Closed** | 2025-05-26 17:06:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The following works when using Workflow Client:

```
public interface Retryable {
    @SignalMethod
    void retryNow();
}

@WorkflowInterface
public interface FileProcessingWorkflow extends Retryable {

    @WorkflowMethod
    String processFile(Arguments args);

    @QueryMethod(name="history")
    List<String> getHistory();

    @QueryMethod
    String getStatus();

    @SignalMethod
    void abandon();
}

@WorkflowInterface
public interface MediaProcessingWorkflow extends Retryable {

    @WorkflowMethod
    String processBlob(Arguments args);
}

Retryable r1 = client.newWorkflowStub(Retryable.class, firstWorkflowId);
Retryable r2 = client.newWorkflowStub(Retryable.class, secondWorkflowId);
r1.retryNow();
r2.retryNow();
```
The same should work when signaling workflow from an external workflow:
```
Workflow.newExternalWorkflowStub(Retryable.class, firstWorkflowId);

Retryable r1 = Workflow.newExternalWorkflowStub(Retryable.class, firstWorkflowId);
Retryable r2 = Workflow.newExternalWorkflowStub(Retryable.class, secondWorkflowId);
r1.retryNow();
r2.retryNow();
```

## Actual Behavior
The newExternalWorkflowStub fails with:
```
Caused by: java.lang.IllegalArgumentException: Missing required @WorkflowInterface annotation: interface ...Retryable
	at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newInstanceInternal(POJOWorkflowInterfaceMetadata.java:179)
	at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newInstance(POJOWorkflowInterfaceMetadata.java:108)
	at io.temporal.internal.sync.ExternalWorkflowInvocationHandler.<init>(ExternalWorkflowInvocationHandler.java:43)
	at io.temporal.internal.sync.WorkflowInternal.newExternalWorkflowStub(WorkflowInternal.java:412)
	at io.temporal.workflow.Workflow.newExternalWorkflowStub(Workflow.java:204)
```



#### Comments (4)

<details>
<summary><strong>cretz</strong> commented on 2024-08-12 15:06:18.000 UTC</summary>

Arguably it shouldn't even work on the client. It'd make one wonder why a `@WorkflowInterface` is even needed ever if we can just assume it's there. In Python and .NET at least, we require the client class passed in to have this (even if it's a base class, to signify user intent). But I can understand if Java we don't want that.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2024-08-13 23:57:54.000 UTC</summary>

@WorkflowInterface defines a workflow type. There is no "Retryable" workflow type to register.

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-08-14 14:14:33.000 UTC</summary>

I was under the impression the annotation is also meant to be required for caller use. I assume with this issue, we should accept basically any interface in Java including standard library ones (and that the client side already does)? I assume that it's at method call time on the proxy where we will fail for any non-signal/update/query-annotated method? It could be argued (and how we did it in .NET/Python) that if you're willing to define methods w/ Temporal annotations in an interface, you should mark that interface as one capable of being used as a workflow stub via the `@Workflow` annotation.

But I understand if in Java we expect methods at any level to have annotations but not classes. And of course there's value in consistency with client side. Can disregard my concern.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2024-08-14 22:02:02.000 UTC</summary>

The WorkflowClient.newWorkflowStub call [validates](https://github.com/temporalio/sdk-java/blob/201240a4f1075a48e23a3af17fd11a6d1c89bcd6/temporal-sdk/src/main/java/io/temporal/client/WorkflowClientInternalImpl.java#L175) that only methods that are annotated with signal/update/query are allowed at the interface.

</details>


---

<a id="2128"></a>

### #2128: NoClassDefFoundError: com/google/protobuf/GeneratedMessageV3 | Spring 3.3.1

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2128 |
| **State** | CLOSED |
| **Author** | Lavmee (Samuel Gagarin) |
| **Created** | 2024-06-26 12:59:14.000 UTC (1y 6m ago) |
| **Updated** | 2024-07-08 14:00:28.000 UTC |
| **Closed** | 2024-07-05 08:49:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
WorkflowServiceStubs Bean is created.

## Actual Behavior
Factory method 'workflowServiceStubs' threw exception with message: com/google/protobuf/GeneratedMessageV3
2024-06-26T12:51:09.185951139Z 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:177) ~[spring-beans-6.1.10.jar!/:6.1.10]
2024-06-26T12:51:09.185951972Z 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:644) ~[spring-beans-6.1.10.jar!/:6.1.10]
2024-06-26T12:51:09.185952764Z 	... 68 common frames omitted
2024-06-26T12:51:09.185953389Z Caused by: java.lang.NoClassDefFoundError: com/google/protobuf/GeneratedMessageV3

## Steps to Reproduce the Problem

  1. Spring version 3.3.1 & Temporal version 1.24.0
  2. Create workflowServiceStubs Bean
```kotlin
    @Bean
    fun workflowServiceStubs(): WorkflowServiceStubs = WorkflowServiceStubs.newServiceStubs(
        WorkflowServiceStubsOptions {
            setTarget(temporalProperties.connectionTarget)
        }
    )
```

## Specifications

  - Version: 1.24.0


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-26 13:48:01.000 UTC</summary>

What version of protobuf are you using?

</details>

<details>
<summary><strong>Lavmee</strong> commented on 2024-06-26 16:21:41.000 UTC</summary>

> What version of protobuf are you using?

I found the problem. I use Temporal SDK together with the [DGS](https://github.com/Netflix/dgs-framework) framework, which uses protobuf version 4.26.1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-26 16:41:06.000 UTC</summary>

Yes protobuf `4.26` is know to be [problematic](https://github.com/grpc/grpc-java/issues/11015) with `grpc-java`

</details>

<details>
<summary><strong>Lavmee</strong> commented on 2024-07-05 08:49:05.000 UTC</summary>

Now workaround for me: use shaded Temporal SDK, so I'm closing the issue. Thanks!

</details>


---

<a id="2121"></a>

### #2121: @Profile annotation is not working on @WorkflowImpl with `workers-auto-discovery`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2121 |
| **State** | CLOSED |
| **Author** | hedonihilist |
| **Created** | 2024-06-21 09:04:43.000 UTC (1y 6m ago) |
| **Updated** | 2025-05-05 16:08:02.000 UTC |
| **Closed** | 2025-05-05 16:08:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When `workers-auto-discovery` is configured and `@Profile` annotation is used on top of `@WorkflowImpl`, if the profile condition doesn't match, the workflow should not be used.

## Actual Behavior

Regardless of the condition in `@Profile` all classes annotated with `@WorkflowImpl` will be used.

## Steps to Reproduce the Problem

  1. Create a workflow and its implementation SomeWorkflowImpl
  1. Annotate SomeWorkflowImpl with `@WorkflowImpl` and `@Profile("!local")`
  1. Run the application with `local` spring profile. The SomeWorkflowImpl can still be discovered and workers will be created.

## Specifications

  - Version: temporal-spring-boot-autoconfigure-alpha-1.18.2.jar
  - Platform: mac

## Some investigations

ClassPathScanningCandidateComponentProvider is used to scan the package to find workflows.

```
  private Collection<Class<?>> autoDiscoverWorkflowImplementations() {
    ClassPathScanningCandidateComponentProvider scanner =
        new ClassPathScanningCandidateComponentProvider(false);
    scanner.addIncludeFilter(new AnnotationTypeFilter(WorkflowImpl.class));
    Set<Class<?>> implementations = new HashSet<>();
    for (String pckg : properties.getWorkersAutoDiscovery().getPackages()) {
      Set<BeanDefinition> candidateComponents = scanner.findCandidateComponents(pckg);
      for (BeanDefinition beanDefinition : candidateComponents) {
        try {
          implementations.add(Class.forName(beanDefinition.getBeanClassName()));
        } catch (ClassNotFoundException e) {
          throw new BeanDefinitionValidationException(
              "Fail loading class for bean definition " + beanDefinition, e);
        }
      }
    }
    return implementations;
  }
```

But it seems the Environment is not passed in. According to [spring doc](https://docs.spring.io/spring-framework/docs/4.0.0.M1_to_4.2.0.M2/Spring%20Framework%204.2.0.M2/org/springframework/context/annotation/ClassPathScanningCandidateComponentProvider.html)
The Environment is need to evaluate `@Conditional` annotations.
<img width="733" alt="image" src="https://github.com/temporalio/sdk-java/assets/76996792/4ad180c3-7df9-4cda-87b6-b61cbbda3790">


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-25 18:30:47.000 UTC</summary>

`Profile` effects what `beans` are included, technically workflow classes are not `beans` by intention, but I think it would be resonable here to respect `Profile`. Are you aware of any other spring boot projects that apply `Profile` to non beans?

</details>

<details>
<summary><strong>hedonihilist</strong> commented on 2024-06-27 08:46:01.000 UTC</summary>

> Are you aware of any other spring boot projects that apply Profile to non beans?

No I haven't know whether there're such projects. I am not saying we should do that but there seems to be missing some Spring-aware configurations to dynamically disable some task queue/workers. Maybe This can be achieved by some configuration beans before starting the workers?

What I am doing now is set the auto start worker to false, and manually register the conditional workers to worker factory. Maybe this kind of operations can be configured by some beans?

</details>

<details>
<summary><strong>hedonihilist</strong> commented on 2024-06-27 09:27:42.000 UTC</summary>

Or could you give me some advice here on what's the recommend way to conditionally enable/disable workflows?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-02 14:38:46.000 UTC</summary>

Your options currently are to use [explicit configuration](https://github.com/temporalio/sdk-java/tree/master/temporal-spring-boot-autoconfigure#explicit-configuration) or put them in separate packages

</details>


---

<a id="2103"></a>

### #2103: Java SDK is not reporting workflow_failures from the code path via the FailWorkflowExceptionTypes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2103 |
| **State** | CLOSED |
| **Author** | jlacefie (Jonathan Lacefield) |
| **Created** | 2024-06-10 13:45:45.000 UTC (1y 7m ago) |
| **Updated** | 2024-07-09 19:21:24.000 UTC |
| **Closed** | 2024-07-09 19:21:24.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
Workflow Failed Cloud Metrics and Java SDK Metrics should "closely" match each other

## Actual Behavior
Workflow Failed metrics differ between Temporal Cloud and SDK metrics. 

## Steps to Reproduce the Problem
- NDE should typically get retried through WFT, I'm not sure what exactly happened to there WFs, but I'm aware we can force the Workflow exec failure by setting WorkflowImplementationOptions with .setFailWorkflowExceptionTypes(NonDeterministicException.class)
- This allowed me to reproduce the metric discrepancy between SDK's [workflow_failed](https://docs.temporal.io/references/sdk-metrics#workflow_failed) vs server/cloud's temporal_cloud_v0_workflow_failed_count, which seems to be the main concern.
- it appears Java SDK is not reporting workflow_failures from the code path via the FailWorkflowExceptionTypes
- The only place that SDK reports workflow_failures is from: https://github.com/temporalio/sdk-java/blob/v1.23.2/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java#L97, which is not reachable when a workflow fails with WorkflowExecutionException from here: [https://github.com/temporalio/sdk-java/blob/v1.23.2/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowRunTaskHandler.java#L2[‚Ä¶]60](https://github.com/temporalio/sdk-java/blob/v1.23.2/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowRunTaskHandler.java#L256-L260)
## Specifications

  - Version:
  - Platform:
Temporal Cloud

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-10 14:01:24.000 UTC</summary>

Related to https://github.com/temporalio/sdk-java/issues/1590

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-07-08 23:16:32.000 UTC</summary>

Investigating this more the Java SDK does report `workflow_failures` correctly if the exception is throw in the user workflow code. The miss is when the exception is thrown by the SDK itself, which is often where `NonDeterministicException` are thrown. 

</details>


---

<a id="2097"></a>

### #2097: TestActivityEnvironment does not work with Asynchronous Activity Completion

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2097 |
| **State** | CLOSED |
| **Author** | bjab (Bartek Jablonski) |
| **Created** | 2024-06-06 13:28:43.000 UTC (1y 7m ago) |
| **Updated** | 2025-04-23 22:43:15.000 UTC |
| **Closed** | 2025-04-23 22:43:15.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description


We have activity, that is using "Asynchronous Activity Completion" and we want to test it. In our case, we just want to test, that activity will send proper kafka message, but still, we need to set up test environment, to obtain activity token, etc.

In shortest form, our test looks like this:

```     
var testActivityEnvironment = TestActivityEnvironment.newInstance(TestEnvironmentOptions.getDefaultInstance());
testActivityEnvironment.registerActivitiesImplementations(activityImpl);
var testActivity = testActivityEnvironment.newActivityStub(SomeActivities.class);

testActivity.execute();
```

Inside of `activityImpl` we use `context.doNotCompleteOnReturn();`

Problem is, that `TestActivityEnvironmentInternal` expects either cancelled, failed or completed activity.
In case of not async activity, all fields of `ActivityTaskHandler.Result`  are null and we get `NullPointerException`

Problematic block of code:
https://github.com/temporalio/sdk-java/blob/master/temporal-testing/src/main/java/io/temporal/testing/TestActivityEnvironmentInternal.java#L489-L496

## Expected Behavior

Calling mehod of async activity will do nothing.

## Actual Behavior

NullPointerException at https://github.com/temporalio/sdk-java/blob/master/temporal-testing/src/main/java/io/temporal/testing/TestActivityEnvironmentInternal.java#L496 (response.getTaskFailed() is null)

## Specifications

  - Version: 1.23.2
  - Platform: windows


#### Comments (2)

<details>
<summary><strong>esikgabi</strong> commented on 2024-09-06 14:17:18.000 UTC</summary>

Hi,
I found a similar open issue: https://github.com/temporalio/sdk-java/issues/460
They may be connected or reflect the same issue. 
There are not too many activities but maybe it is a good idea to link them. 

</details>

<details>
<summary><strong>mschirmacher</strong> commented on 2025-03-14 13:48:49.000 UTC</summary>

Hi, i added a very small fix for this issue - i wonder why this bug is open for so long.
Anyway, as a sidenote: testing async activities is should get more love, e.g. there is no TestWorkflowClient at the moment that would allow proper testing of the activity

</details>


---

<a id="2092"></a>

### #2092: activity_succeed_endtoend_latency not reported when completing the activity with ActivityCompletionClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2092 |
| **State** | OPEN |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2024-06-04 13:57:52.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-04 20:12:25.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior

The metric activity_succeed_endtoend_latency should be reported when activity is completed with `ActivityCompletionClient.complete`

I think it is missing in this method https://github.com/temporalio/sdk-java/blob/0c8073ee74984333f045b79a27da337097d7ae7a/temporal-sdk/src/main/java/io/temporal/internal/client/external/ManualActivityCompletionClientImpl.java#L101

## Actual Behavior

Metric is not reported, you can find a reproduction here https://github.com/antmendoza/my-temporal-pocs/tree/main/java/pocs/src/main/java/io/antmendoza/samples/_6442.  



## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2024-06-04 14:01:03.000 UTC</summary>

I don't believe any SDK records this metric when async activity is used. Async activity means "I will handle completion myself" and therefore it bypasses Temporal's completion mechanisms which includes this metric. Many users use async completion to complete activities on completely separate machines than where it was started which means it _can't_ set this value (it doesn't know the start time).

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-04 20:12:23.000 UTC</summary>

in the case of manual completion that is intended for in process activity completion so the activity start time could be known.

Reactions: üëç 1

</details>


---

<a id="2047"></a>

### #2047: Add toString method to WorkflowServiceStubsOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2047 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-04-29 17:35:36.000 UTC (1y 8m ago) |
| **Updated** | 2024-06-05 21:32:48.000 UTC |
| **Closed** | 2024-06-05 21:32:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

improvement request to add toString method to WorkflowServiceStubsOptions that would print out all options available. can be extended to any/all other options type of classes

#### Comments (4)

<details>
<summary><strong>dskarbek</strong> commented on 2024-04-29 17:39:23.000 UTC</summary>

Please make sure to add a toString method to the Builder sub-class as well so we can log what options we are building with.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-29 17:52:44.000 UTC</summary>

We should also include `equals` and `hashcode` like all other `*Options` in the Java SDK. The `Builder` can be converted to a `WorkflowServiceStubsOptions` to be logged so you will get an accurate log of what options are actually set logging the `Builder` does not. 


</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-29 17:56:31.000 UTC</summary>

We also need to do this for `OperatorServiceStubsOptions` though that is much less frequently used.

</details>

<details>
<summary><strong>dskarbek</strong> commented on 2024-04-29 18:36:07.000 UTC</summary>

> The `Builder` can be converted to a `WorkflowServiceStubsOptions` to be logged 

So long as there's no failures that the build method will trigger on a partially filled out Builder.


</details>


---

<a id="1994"></a>

### #1994: RunID is needed oftimes when relying on HasWorkflowSerializationContext in a PayloadCodec or Converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1994 |
| **State** | CLOSED |
| **Author** | mnichols (Mike Nichols) |
| **Created** | 2024-02-23 07:10:15.000 UTC (1y 10m ago) |
| **Updated** | 2024-03-08 20:11:40.000 UTC |
| **Closed** | 2024-03-08 20:11:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
RunId is not included in `HasWorkflowSerializationContext`. This makes it hard for PayloadCodec implementations that are caching payloads to disambiguate execution runs that have been ContinuedAsNew, Reset, etc.  

**Describe the solution you'd like**
Extend the implementations of HasWorkflowSerializationContext to accept RunId where possible. This is possible to set in all cases except ClientInterceptor concerns, so can be `null`. 

**Describe alternatives you've considered**
The concrete case this solves is where a user must set the TTL to expire payloads based on retention policy, but if an execution has been ContinuedAsNew only the payloads which correspond to the Runs which have been Completed/Canceled should be expired. Marking the entire payload history as expired by `WorkflowID` would be incorrect since the latest run might remain open for some time.

More broadly, having the RunID is so common across the execution `info` we expose elsewhere, it makes sense to pass this important identification of _which_ run we are dealing with all the way down here as well.

#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-23 14:59:28.000 UTC</summary>

>Extend the implementations of HasWorkflowSerializationContext to accept RunId where possible. This is possible to set in all cases except ClientInterceptor concerns,

It is true that a workflow context has a runID, but it will often not be the correct runID. For example in the continue as new case the SDK does not know the runID of the new workflow execution.

> The concrete case this solves is where a user must set the TTL to expire payloads based on retention policy

Based on this use case I am not sure this is an appropriate solution given the SDK does not always have visibility into a workflows lifecycle. This would require to have some server sent events to fully capture a workflow/activity lifecycle to make decisions on payloads 

https://github.com/temporalio/temporal/issues/3709

`SerializationContext` is meant to provide information needed to serialize a payload, if that information cannot be consistently provided then it can't be used to serialize the payload and I don't think it belongs in `SerializationContext` 



</details>

<details>
<summary><strong>mnichols</strong> commented on 2024-02-23 15:43:57.000 UTC</summary>

I actually implemented the changes last night to see if RunId was available and apart from the Client interceptor found it was always there, but is this an example of where the runId being passed in might `not be the correct runID`??: 

https://github.com/temporalio/sdk-java/blob/hasworkflowserialization-context-runid/temporal-sdk/src/main/java/io/temporal/internal/sync/SyncWorkflowContext.java#L140

Or is it in the POJO bit here: https://github.com/temporalio/sdk-java/blob/hasworkflowserialization-context-runid/temporal-sdk/src/main/java/io/temporal/internal/sync/POJOWorkflowImplementationFactory.java#L260 ?

I'm trying to learn where the wrong runID might be getting inserted into this instance.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-02-23 15:52:26.000 UTC</summary>

>I actually implemented the changes last night to see if RunId was available and apart from the Client interceptor found it was always there, but is this an example of where the runId being passed in might not be the correct runID??:

Yes, any case involving reset, continue as new, last workflow result or child workflows you will get the runID for the current execution not the new execution since the runID is generated on the server.

</details>

<details>
<summary><strong>mnichols</strong> commented on 2024-03-08 20:11:40.000 UTC</summary>

Closing this out as it is not a tenable solution

</details>


---

<a id="1980"></a>

### #1980: MDC Context not propogating

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1980 |
| **State** | CLOSED |
| **Author** | karunagoyal (Karuna Goyal) |
| **Created** | 2024-01-26 18:43:53.000 UTC (1y 11m ago) |
| **Updated** | 2024-12-23 20:55:23.000 UTC |
| **Closed** | 2024-12-23 20:55:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
MDC context should propogate to Temporal Threads with spring boot sdk

## Actual Behavior
MDC Context not getting propogated

## Steps to Reproduce the Problem

  1.Set up MDC Context Propogator in code
  1. Check logs from Temporal and no MDC context present
 

## Specifications

  - Version: temporal-spring-boot-starter-alpha, 1.20.1
  - Platform:


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-26 21:47:18.000 UTC</summary>

Modifying the SpringBoot sample to have a MDC context propagator I had no issue propagating a value from the client or workflow to an Activity.

https://github.com/Quinn-With-Two-Ns/samples-java/commit/c99e24af5f20d1965827c5e178f6541a9b5ddf12



</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-26 21:54:19.000 UTC</summary>

If you can share more details about your setup, ideally in a self contained example, I can try to help narrow down where the error is.

</details>

<details>
<summary><strong>karunagoyal</strong> commented on 2024-01-29 21:03:44.000 UTC</summary>

Thanks @Quinn-With-Two-Ns . I do have workflow client bean create like this 
` @Bean
    public WorkflowClient workflowClient(DataConverter dataConverter, MdcContextPropagator mdcContextPropagator) {
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
        WorkflowClientOptions workflowClientOptions = WorkflowClientOptions.newBuilder().setDataConverter(dataConverter).setContextPropagators(Collections.singletonList(mdcContextPropagator)).build();
        return WorkflowClient.newInstance(service, workflowClientOptions);
    }`
still I donot see MDC context getting propogated

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-30 01:13:51.000 UTC</summary>

@karunagoyal You need to also be setting the the context propagator on the client the worker uses. You can see how in `TemporalOptionsConfig.java` in the code I posted.

</details>


---

<a id="1969"></a>

### #1969: Provide WorkflowStatus in WorkflowNotFoundException when signing a workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1969 |
| **State** | OPEN |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2024-01-11 20:15:28.000 UTC (1y 12m ago) |
| **Updated** | 2024-01-16 19:04:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently signaling a closed workflow will throw this exception, but there are several cases:
* Workflow really doesn't exist (or deleted after retention)
* Workflow is completed/terminated/etc (closed)

As an application, we sometimes need to handle the two cases differently(error handling). 

**Describe the solution you'd like**
The exception should just return "WorkflowStatus" inside. 

**Describe alternatives you've considered**
Currently we have to make a DescribeWorkflowExecution API call to achieve this. This requires more code, more error handling, and higher latency . 

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-13 00:50:33.000 UTC</summary>

Currently the server does not send back this information on a signal to a not running workflow. So to clarify, is the ask that the Temporal server sends back the `WorkflowExecutionStatus` on a signal to a not running workflow?

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2024-01-13 01:15:13.000 UTC</summary>

Yes üëç it needs server support


Thanks,
Quanzheng


On Fri, Jan 12, 2024 at 4:50‚ÄØPM Quinn Klassen ***@***.***>
wrote:

> Currently the server does not send back this information on a signal to a
> not running workflow. So to clarify, is the ask that the Temporal server
> sends back the WorkflowExecutionStatus on a signal to a not running
> workflow?
>
> ‚Äî
> Reply to this email directly, view it on GitHub
> <https://github.com/temporalio/sdk-java/issues/1969#issuecomment-1890198939>,
> or unsubscribe
> <https://github.com/notifications/unsubscribe-auth/ABCQPM3DURANKBM4NOAMTLTYOHK6HAVCNFSM6AAAAABBXCIIUWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTQOJQGE4TQOJTHE>
> .
> You are receiving this because you authored the thread.Message ID:
> ***@***.***>
>


</details>

<details>
<summary><strong>cretz</strong> commented on 2024-01-16 14:07:06.000 UTC</summary>

I could transfer this issue to the https://github.com/temporalio/temporal repo, but its title and description are very Java SDK specific. Rather, can you open an issue there asking for this information to be present on the not-found details of workflow calls?

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2024-01-16 19:04:32.000 UTC</summary>

> I could transfer this issue to the https://github.com/temporalio/temporal repo, but its title and description are very Java SDK specific. Rather, can you open an issue there asking for this information to be present on the not-found details of workflow calls?

yeah: https://github.com/temporalio/temporal/issues/5303


</details>


---

<a id="1944"></a>

### #1944: If an update request continues-as-new the SDK should complete the request with a specific response

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1944 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-29 00:05:59.000 UTC (2y 1m ago) |
| **Updated** | 2023-11-29 22:38:52.000 UTC |
| **Closed** | 2023-11-29 22:38:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
If a users is using update to continue-as-new a workflow execution they probably want to know if the update request did successfully continue as new the workflow 

**Describe the solution you'd like**
Either fail or complete the workflow with a specific response




#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 00:14:53.000 UTC</summary>

Thinking about this more it should fail since the update can't succeeded because I can't force the update handles type to be the type of the success message.

</details>

<details>
<summary><strong>bergundy</strong> commented on 2023-11-29 01:12:56.000 UTC</summary>

I agree that ideally the failure would represent that the workflow continued as new, but IMHO, just dropping the update on the SDK and having the server take care of this makes sense. It would have to unblock any pending update, not just the one where the CAN call happened.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 14:46:50.000 UTC</summary>

@bergundy I don't believe the server will fail/complete any outstanding updates when a workflow completes today. Should we move this issue to https://github.com/temporalio/temporal?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 22:38:51.000 UTC</summary>

closing in favour of https://github.com/temporalio/temporal/issues/5174

</details>


---

<a id="1940"></a>

### #1940: Support Java Modules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1940 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-21 00:50:52.000 UTC (2y 1m ago) |
| **Updated** | 2025-08-07 18:03:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Support Java Modules

**Describe the solution you'd like**
Every relevant library should publish a `Automatic-Module-Name` in the manifest or a `module-info.java`. Currently the Java SDK cannot be used as a named Java module since some of modules implement the same packages.

```
error: the unnamed module reads package io.temporal.internal.common from both temporal.sdk and temporal.serviceclient
error: the unnamed module reads package io.temporal.internal from both temporal.sdk and temporal.serviceclient
```

Java modules do not allow this, it is called a split package.

**Describe alternatives you've considered**
Don't support Jave modules



#### Comments (4)

<details>
<summary><strong>Riva2006</strong> commented on 2023-12-18 12:55:58.000 UTC</summary>

It is important fix to all Java developers ,  Currently we using shadow to repack the packages , It is important to get basic support of module-info

</details>

<details>
<summary><strong>dbiere</strong> commented on 2024-10-22 13:48:16.000 UTC</summary>

This issue was opened nearly a year ago and is still a problem as of Temporal Java SDK 1.24.1. Is this on the roadmap to resolve? Thank you.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-22 14:01:06.000 UTC</summary>

Yes we are aware of this issue, but I have no timeline on when this will be resolved.

</details>

<details>
<summary><strong>inphoenitic</strong> commented on 2025-08-07 18:03:16.000 UTC</summary>

The first step should be in this journey to stop sharing/splitting packages in different modules/jars. At this moment, there are classes spread out in multiple jars from `io.temporal.internal` and `io.temporal.internal.common.` This is an easy fix, takes no more that 10 minutes for an experienced coder. If this is solved, java's automatic module resolution does                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           most the remaining work and lets us use these as modules.
What I identified, is that in the `temporal-sdk` module, the package io.temporal.interna                                             l.common should be renamed to something el, like `io.temporal.internal.utils`, and the classes `io.temporal.internal.WorkflowThreadMarker` and io.temporal.internal.BackoffThrottler should be moved to a different package (the easiest is to move them to the previous io.temporal.internal.utils. This would allow the build process to create two jars that do not share/split the two packages.
I have tested this in my environment, but I do not want to contribute here, because I'm terrible with gradle and have no kotlin experience. Of course, I'm ready to help, if you think it is the quickest way... 

</details>


---

<a id="1931"></a>

### #1931: sdk-java 1.22.3 breaks queries after testEnv.sleep

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1931 |
| **State** | CLOSED |
| **Author** | karneyli (Karney Li) |
| **Created** | 2023-11-09 14:13:29.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-09 16:47:22.000 UTC |
| **Closed** | 2023-11-09 16:47:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It used to be possible to issue a `testEnv.sleep(Duration)` in a test and subsequently query the execution in v1.22.2 but this seems to have been broken in v1.22.3, this may be related to the changes in https://github.com/temporalio/sdk-java/pull/1916

Here's an example workflow:

```
@WorkflowInterface
interface HelloWorkflow {
    @WorkflowMethod(name = "HelloWorkflow")
    fun execute(name: String): String

    @QueryMethod(name = "GetName")
    fun getName(): String?
}

@WorkflowImpl(taskQueues = ["default"])
@Component
class HelloWorkflowImpl : HelloWorkflow {
    private var name: String? = null
    override fun execute(name: String): String {
        this.name = name
        Workflow.await { name == "Joel" }
        return "Hello $name!"
    }

    override fun getName() = name
}
```


Then in my test

```
@ActiveProfiles(profiles = ["test"])
@SpringBootTest
@ComponentScan(
    basePackages = [
        "io.temporal",
        "com.wealthsimple.workflows"
    ],
    basePackageClasses = [
        HelloWorkflow::class,
    ],
)
class HelloWorkflowImplTest(
    @Autowired val applicationContext: ConfigurableApplicationContext,
    @Autowired val testEnv: TestWorkflowEnvironment,
    @Autowired val workflowClient: WorkflowClient,
) {

    @BeforeEach
    fun setUp() {
        applicationContext.start()
    }

    @Test
    fun `execute workflow`() {
        val workflowStub = workflowClient.newUntypedWorkflowStub(
            "HelloWorkflow",
            WorkflowOptions { setTaskQueue("default") },
        )
        workflowStub.start("Bob")
        testEnv.sleep(Duration.ofHours(1)) // <--- this should be allowed...
        workflowStub.query("GetName", String::class.java) shouldBe "Bob"
    }
}
```

I've verified that without the `testEnv.sleep` call, I'm able to query but with it I get the following stack trace.  

```

io.temporal.client.WorkflowQueryException: workflowId='f37b5007-44f3-43f0-bc80-1d242a349209', runId='', workflowType='HelloWorkflow'}

	at io.temporal.client.WorkflowStubImpl.throwAsWorkflowFailureExceptionForQuery(WorkflowStubImpl.java:477)
	at io.temporal.client.WorkflowStubImpl.query(WorkflowStubImpl.java:280)
	at io.temporal.client.WorkflowStubImpl.query(WorkflowStubImpl.java:266)
	at io.temporal.testing.TimeLockingInterceptor$TimeLockingWorkflowStub.query(TimeLockingInterceptor.java:165)
	at com.wealthsimple.workflows.HelloWorkflowImplTest.execute workflow(HelloWorkflowImplTest.kt:46)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:86)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:147)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:127)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:90)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:55)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:102)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:57)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
Caused by: io.grpc.StatusRuntimeException: INVALID_ARGUMENT: java.lang.IllegalStateException: Premature end of stream, expectedLastEventID=3 but no more events after eventID=0
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.verifyAllEventsProcessed(ReplayWorkflowRunTaskHandler.java:284)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.applyServerHistory(ReplayWorkflowRunTaskHandler.java:269)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:231)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleDirectQueryWorkflowTask(ReplayWorkflowRunTaskHandler.java:204)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:127)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:98)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:413)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:320)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:261)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:105)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
```

Of course, downgrading to 1.22.2 fixes the issue as well.  

#### Comments (4)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-09 15:36:01.000 UTC</summary>

Hm I am not able to reproduce your issue. I translated your reproduction into something I can run locally, but my test ran fine on `1.22.3`.

```
public class WaitingWorkflowQueryTest {
  @Rule
  public SDKTestWorkflowRule testWorkflowRule =
      SDKTestWorkflowRule.newBuilder()
          .setWorkflowTypes(TestLocalActivityAndQueryWorkflow.class)
          .build();

  @Test
  public void query() throws ExecutionException, InterruptedException {
    WorkflowOptions options =
        WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build();
    TestWorkflows.TestWorkflowWithQuery workflowStub =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.TestWorkflowWithQuery.class, options);
    WorkflowClient.start(workflowStub::execute);

    testWorkflowRule.sleep(Duration.ofHours(1));
    assertEquals("started", workflowStub.query());
  }

  public static final class TestLocalActivityAndQueryWorkflow
      implements TestWorkflows.TestWorkflowWithQuery {

    private String queryResult = "";

    @Override
    public String execute() {
      queryResult = "started";
      Workflow.await(() -> false);
      return "done";
    }

    @Override
    public String query() {
      return queryResult;
    }
  }
}
```

The only way I could replicate your behaviour was to also use an old version of the `temporal-test-server`, which is not supported. Can you confirm your all your temporal dependencies are up to date?

</details>

<details>
<summary><strong>karneyli</strong> commented on 2023-11-09 15:45:40.000 UTC</summary>

Try using an untypedWorkflowStub, when I use newWorkflowStub it works.  

If you can't reproduce, I can create a small app.  Yes my dependencies are upto date. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-09 16:00:10.000 UTC</summary>

Using `untypedWorkflowStub` makes no difference, the test still runs fine 

</details>

<details>
<summary><strong>karneyli</strong> commented on 2023-11-09 16:47:22.000 UTC</summary>

Apologies. It looks like this is indeed due to an old version of the `temporal-test-server`, it was picking up `1.22.2`, forcing it to resolve to `1.22.3` resolves the issue.  

Reactions: üëç 1

</details>


---

<a id="1783"></a>

### #1783: Test server for linux_arm64 target

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1783 |
| **State** | CLOSED |
| **Author** | wojked (Wojciech Kedzierski) |
| **Created** | 2023-06-09 13:59:51.000 UTC (2y 7m ago) |
| **Updated** | 2023-10-10 16:57:14.000 UTC |
| **Closed** | 2023-10-10 16:57:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I have a M1/M2 Mac and run my apps in docker containers.

When developing in python on my mac directly, tests automatically download the `temporal-test-server` by hitting this endpoint first:
https://temporal.download/temporal-test-server/default?arch=arm64&platform=darwin&sdk-name=sdk-python&sdk-version=1.2.0

that returns the following content
```{"archiveUrl":"https://temporal.download/assets/temporalio/sdk-java/releases/download/v1.17.0/temporal-test-server_1.17.0_macOS_amd64.tar.gz","fileToExtract":"temporal-test-server_1.17.0_macOS_amd64/temporal-test-server"}```

**I am able to run tests "directly" on my local machine with pytest**

But when I try to test my app inside of a docker container that uses linux arm64 it fails because of two reasons:
* RuntimeError: Failed starting test server: Permission denied (os error 13) if just run `pytest`
* or `qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory` if I provide pointer to a manually downloaded amd64 binary

This leads me to a quite obvious conclusion, that amd64 test server is not going to run within arm64.

**I am unable to run temporal tests in docker on M1/M2 Macs**


**Describe the solution you'd like**
Could you provide builds for linux_arm64 target? This way tests would execute within a dockerised arm64 linux.

**Describe alternatives you've considered**
- I could use `WorkflowEnvironment.start_local()` instead of `WorkflowEnvironment.start_time_skipping()`
- I could skip tests in docker, but is far from perfect.



#### Comments (4)

<details>
<summary><strong>wojked</strong> commented on 2023-06-09 15:48:21.000 UTC</summary>

I am just starting to use temporal and followed the example project:
https://github.com/temporalio/hello-world-project-template-python/blob/main/tests/test_run_worker.py

Right now I am unsure why `.start_time_skipping()` was used instead of `.start_local()` in tests.
`.start_local()` will run `temporalite` which seems like a good idea, so maybe it should be the way to test.

</details>

<details>
<summary><strong>cretz</strong> commented on 2023-06-09 16:24:35.000 UTC</summary>

Duplicate of #1407, but will leave open for a bit in case there are other questions.

Reactions: üëç 1

</details>

<details>
<summary><strong>wojked</strong> commented on 2023-06-14 10:33:06.000 UTC</summary>

Hey @cretz,

I switched into `WorkflowEnvironment.start_local()` in my tests (instead of `WorkflowEnvironment.start_time_skipping()`) as I described in the "considered alternatives" without any negative effects (yet).

I hope I will be able to deal with the lack of "automatic time skipping" by placing any "sleeps" in separated activities or individual functions that I will selectively mock in tests so do not see anything blocking me after all (for now).

Thank you for leaving it open, I feel we might close it as duplicate, but let's wait, maybe there are questions from other people too.


Reactions: üëç 1

</details>

<details>
<summary><strong>mjameswh</strong> commented on 2023-10-10 16:57:13.000 UTC</summary>

There no longer seems to be any reason to keep this one open.

Closing as duplicate of #1407.

</details>


---

<a id="1666"></a>

### #1666: Schedule API example with Spring boot

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1666 |
| **State** | CLOSED |
| **Author** | smaldored |
| **Created** | 2023-02-20 21:53:41.000 UTC (2y 10m ago) |
| **Updated** | 2023-11-29 15:28:14.000 UTC |
| **Closed** | 2023-11-29 15:28:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hey there. I was looking to start using the new schedule API as talked about here https://docs.temporal.io/workflows#schedule
and was wondering if there are any examples using spring-boot? I saw a commit from last July that implemented a high-level schedule API, is that what I'm to use?

If there are any starting points or examples I could look at for the new Temporal schedule API with Spring boot,  that would be much appreciated! 


#### Comments (4)

<details>
<summary><strong>mjameswh</strong> commented on 2023-02-20 22:14:39.000 UTC</summary>

The Java SDK does not yet provide a high level Schedule API. Maybe you saw [this ticket](https://github.com/temporalio/sdk-java/issues/1333), dated from last July, which tracks this as a feature to be implemented. This is on our road map.

</details>

<details>
<summary><strong>smaldored</strong> commented on 2023-02-20 22:26:25.000 UTC</summary>

@mjameswh Yes that is exactly what I saw. Thank you for the insight. Do you have any estimate as to when this may be available?

If not, are there any examples of the older way of doing it via temporal cron job?

Thanks for the quick response!

</details>

<details>
<summary><strong>mjameswh</strong> commented on 2023-02-20 22:44:28.000 UTC</summary>

> Do you have any estimate as to when this may be available?

We don't have an ETA for this, but it is on our short term list.

> If not, are there any examples of the older way of doing it via temporal cron job?

We have an example of using cron workflows [here](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/hello/HelloCron.java).

Alternatively, you may use the new Schedule feature right now, using the raw gRPC API. For the kind of things that can be accomplished using cron workflows, the raw gRPC API should not be difficult to master. We don't have a Schedule-specific example, but you may have a look at this [example](https://github.com/temporalio/samples-java/blob/27469ab52a4aa011a4927343aec4db34448c0008/src/main/java/io/temporal/samples/terminateworkflow/Starter.java#L107-L108) showing how to use the raw gRPC API. The API would want to call is `WorkflowService/CreateSchedule`.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 15:28:14.000 UTC</summary>

A schedule sample is available in our [samples repo ](https://github.com/temporalio/samples-java/blob/main/core/src/main/java/io/temporal/samples/hello/HelloSchedules.java)

Springboot does not effect schedules so a spring  boot specific example wouldn't provide much value

</details>


---

<a id="1626"></a>

### #1626: Allow WorkflowImplementationOptions to be passed in TestWorkflowExtension->setWorkflowTypes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1626 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-01-27 15:26:22.000 UTC (2y 11m ago) |
| **Updated** | 2023-12-06 21:17:32.000 UTC |
| **Closed** | 2023-12-06 21:17:32.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | tsurdilo |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

TestWorkflowRule:

       public Builder setWorkflowTypes(
           WorkflowImplementationOptions implementationOptions, Class<?>... workflowTypes) { ... }

TestWorkflowExtention:

       public Builder setWorkflowTypes(Class<?>... workflowTypes) { ... }

Allow WorkflowImplementationOptions to also be passed in setWorkflowTypes in TestWorkflowExtention. 

#### Comments (2)

<details>
<summary><strong>picpromusic</strong> commented on 2023-11-26 18:55:47.000 UTC</summary>

@tsurdilo is there a workaround when working with TestWorkflowExtension?
I only found: 

```
TestWorkflowExtension.newBuilder().setDoNotStart(true)
```

in combination with 

```
@BeforeEach
 public void setupWorkflowOptions(TestWorkflowEnvironment testEnv, Worker worker) {
         worker.registerWorkflowImplementationTypes(
                         WorkflowImplementationOptions.newBuilder()
                                         .setDefaultActivityOptions(ActivityOptions.newBuilder()
                                                         .setStartToCloseTimeout(Duration.ofHours(1))
                                                         .build())
                                         .build(),
                         CUT.class);
         testEnv.start();
}
```

instead of setting 

```
TestWorkflowExtension.newBuilder().setWorkflowTypes(CUT.class)
```

directly

</details>

<details>
<summary><strong>picpromusic</strong> commented on 2023-11-26 21:14:54.000 UTC</summary>

I had a look at the implementation. It might be as easy as https://github.com/picpromusic/temporal-io-sdk-java/commit/a3d85bcaec4b705e9f50801418474c828548e975. But i am totally unsure how to write a proper unit-test for this. 

</details>


---

<a id="1558"></a>

### #1558: Issue with ReplayAwareLogger and CanceledFailure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1558 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-12-05 22:12:20.000 UTC (3y 1m ago) |
| **Updated** | 2023-03-16 04:01:29.000 UTC |
| **Closed** | 2023-03-16 04:01:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.19.0 |
| **Reactions** | üëÄ 1 |

#### Description

When catching ActivityFailure with cause io.temporal.failure.CanceledFailure it seems ReplayAwareLogger thinks workflow is in replay mode, looks like issue with setting WorkflowUnsafe.isReplaying() in this case. 

Full repro (could run in within java samples) [here](https://gist.github.com/tsurdilo/4eb48c5f87fe8797b4a7a4399375ee85). 
Relevant lines where issue happens (only system outs get printed) [here](https://gist.github.com/tsurdilo/4eb48c5f87fe8797b4a7a4399375ee85#file-gistfile1-txt-L77-L82). 

#### Comments (4)

<details>
<summary><strong>dano</strong> commented on 2023-03-02 17:16:36.000 UTC</summary>

I want to add that this issue actually does more than just screw up `ReplayAwareLogger`. If you try to use a `mutableSideEffect` in a detached `CancellationScope` when the Workflow mistakenly thinks it is replaying, when it is actually just cancelled, the `mutableSideEffect` call will fail with this error:
```
023-03-02 12:10:23.856 [WARN ] [io.temporal.internal.worker.WorkflowWorker|Workflow Executor taskQueue="myQueue", namespace="default": 2] Failure while reporting workflow progress to the server. If seen continuously the workflow might be stuck. WorkflowId=799e5987-65a9-4c1d-bd4e-bc96301ae825, RunId=839fbc5c-9c5c-4a7d-be4d-085b296bc883, startedEventId=19
io.grpc.StatusRuntimeException: INVALID_ARGUMENT: BadRecordMarkerAttributes: MarkerName is not set on command.
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:271) ~[grpc-stub-1.48.1.jar:1.48.1]
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:252) ~[grpc-stub-1.48.1.jar:1.48.1]
```

You can reproduce it by taking @tsurdilo's original gist, and replacing the call inside the `CancellationScope` on line 71 with a `Workflow.mutableSideEffect` call. It looks like the `MutableSideEffectStateMachine` ends up sending a "fake" `RecordMarkerCommandAttrivutes` instance to the server because it thinks it's replaying.

It's possible that other behavior will be broken by this as well.


</details>

<details>
<summary><strong>dano</strong> commented on 2023-03-02 18:54:24.000 UTC</summary>

It seems like something about the `ActivityTaskCanceled` event screws up the logic `WorkflowStateMachines` uses to determine if we're replaying. We end up making progress executing the Workflow while it still thinks it should be replaying the event history.

</details>

<details>
<summary><strong>dano</strong> commented on 2023-03-06 23:06:32.000 UTC</summary>

Ok, I've figured out the root cause for the bad behavior. It's because of this logic in `WorkflowStateMachines.scheduleActivityTask`:

``` java
              callback.apply(p, f);
              if (f != null && f.hasCause() && f.getCause().hasCanceledFailureInfo()) {
                eventLoop();
              }
```
When that `if` statement evaluates to true (meaning the activity has thrown a `CanceledFailure`), and the event loop is allowed to run, it causes the Workflow to make progress while it is still in the replaying state, which causes all the bad behavior reported in this issue. With any non-cancellation failure, the event loop doesn't run until all events in the event history get processed (specifically the `WorkflowTaskScheduled` and `WorkflowTaskStarted` events that are waiting behind the `ActivityTaskFailed`/`ActivityTaskCanceled` event, which sets replaying back to `false` inside `WorkflowStateMachines.handleSingleEvent`).

It looks like this code has been there for several years, though, so I imagine it is there for a reason. I will experiment with code changes tomorrow to see if I can find one that fixes the issue I'm seeing, without breaking any tests, but probably I will need @Spikhalskiy to weigh in here.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-07 03:57:06.000 UTC</summary>

@dano Thanks for your thoughts. I see what you are saying, but I don't have immediate thoughts right now how it should be fixed. State machines are not trivial to reason about without some digging. If you can provide a unit test reproducing your specific problem, it will be helpful.

</details>


---

<a id="1550"></a>

### #1550: Dynamic & interpolated taskQueues 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1550 |
| **State** | CLOSED |
| **Author** | karneyli (Karney Li) |
| **Created** | 2022-11-30 21:35:30.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-29 22:00:02.000 UTC |
| **Closed** | 2023-01-29 22:00:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

The spring boot auto discovery doesn't allow taskQueues to be set programmatically or through property interpolation/resolution.  

In the java-samples, the [FileProcessingWorker](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/fileprocessing/FileProcessingWorker.java#L57) registers the `StoreActivitiesImpl` to two different task queues, one shared and one host name specific.  There's no way to do this currently if we go the spring boot autoconfigured route.  The `WorkersTemplate` doesn't have a way to delegate `taskQueues` to a resolver function.  Ideally, it would work similar to how JUnit's @ParameterizedTest + @MethodSource works.

The `WorkersTemplate` also doesn't do property value interpolation, so all the taskQueues end up having just being a list of hardcoded strings in the @ActivityImpl annotation, it would be nice if some of the values could come from application properties config.  



#### Comments (4)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-01 00:24:32.000 UTC</summary>

> The spring boot auto discovery doesn't allow taskQueues to be set programmatically or through property interpolation/resolution.
> The WorkersTemplate also doesn't do property value interpolation, so all the taskQueues end up having just being a list of hardcoded strings in the @ActivityImpl annotation, it would be nice if some of the values could come from application properties config.

Please take a look at the Spring-Boot Readme:
https://github.com/temporalio/sdk-java/tree/master/temporal-spring-boot-autoconfigure-alpha#explicit-configuration

</details>

<details>
<summary><strong>karneyli</strong> commented on 2022-12-01 00:45:52.000 UTC</summary>

The explicit configuration is an option and would address at least the
taskQueues through properties but not the programmatic / dynamic use case.
Auto-configuration by package is far less toil than listing out all classes
and beans.  Mixing the two styles according to the documentation is not
well-defined in terms of behaviour.

On Wed, Nov 30, 2022, 7:24 p.m. Dmitry Spikhalskiy ***@***.***>
wrote:

> The spring boot auto discovery doesn't allow taskQueues to be set
> programmatically or through property interpolation/resolution.
>
> Please take a look at the Readme:
>
> https://github.com/temporalio/sdk-java/tree/master/temporal-spring-boot-autoconfigure-alpha#explicit-configuration
>
> ‚Äî
> Reply to this email directly, view it on GitHub
> <https://github.com/temporalio/sdk-java/issues/1550#issuecomment-1332933862>,
> or unsubscribe
> <https://github.com/notifications/unsubscribe-auth/AACM7NZJ4U6DKTSNOR5KYLTWK7V4XANCNFSM6AAAAAASQCVF64>
> .
> You are receiving this because you authored the thread.Message ID:
> ***@***.***>
>


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-02 20:16:28.000 UTC</summary>

Spring Boot is a framework for config-driven simplified setup. For programmatic-driven setups, Spring Boot is not needed. Users that need unlimited flexible or programmatic configuration should just configure the WorkerFactory from their code not using any Spring Boot module at all. Spring Boot doesn't bring much value here.

Our Spring Boot doesn't have a goal of unlimited extensibility, it will be opinionated to keep things easy for most typical usages. It's impossible to keep things simple for all usages with config-driven approach.

I may consider introducing a concept of "Worker Name or ID" at some point and make a taskQueue just a property and don't use it to bind properties together, but not at this moment. 


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-29 22:00:02.000 UTC</summary>

Closed by #1623 

</details>


---

<a id="1518"></a>

### #1518: Multiple tests launched from test class with mocked activity method fail, but each when launch separately passes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1518 |
| **State** | CLOSED |
| **Author** | idkomarov (Mikhail Komarov) |
| **Created** | 2022-11-16 13:23:48.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-29 15:51:52.000 UTC |
| **Closed** | 2022-11-18 16:08:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Description
I am trying to test my Temporal Workflow using temporal java-sdk, temporal-testing, JUnit and Mockito. This workflow has single workflow method including single activity method execution. As activity method uses external service, in unit test I use its mock. I've written multiple tests which check multiple workflow behaviors. Each test passes when launches separately, but if I run whole test class only first test passes and all next tests fail: **my mocking declarations in** `when` **construction don't work in failed tests, workflows fall because they couldn't connect to external service**. Tried to launch tests using different constructions and different Temporal sdk version but have the same behavior.

## Expected Behavior
All tests pass when they launch together.

## Actual Behavior
Only first test passes and all other fail when they launch together.

## Steps to Reproduce the Problem
1. Write Workflow & Activity according to description above
2. Run test like this (`ActivityInterface` - `ExternalServiceHelper`, `WorflowInterface` - `SomeFeatureDeactivator`)
```
@SpringBootTest
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class SomeFeatureDeactivatorImplTest {

    private TestWorkflowEnvironment testEnv;
    private Worker worker;
    private WorkflowClient client;

    private static final String ID = "123";

    @MockBean
    ExternalServiceHelperImpl externalServiceHelper;

    @BeforeEach
    public void setUp() {
        testEnv = TestWorkflowEnvironment.newInstance();
        worker = testEnv.newWorker(QUEUE);
        worker.registerWorkflowImplementationTypes(SomeFeatureDeactivatorImpl.class);
        worker.registerActivitiesImplementations(externalServiceHelper);
        client = testEnv.getWorkflowClient();
        testEnv.start();
    }

    @AfterEach
    public void tearDown() {
        testEnv.close();
    }

    @Test
    @Timeout(10)
    @Order(0)
    void processEntityWithIdTest_givenIdIsNull() {
        // given, when
        WorkflowOptions workflowOptions = WorkflowOptions.newBuilder()
                .setTaskQueue(QUEUE)
                .build();
        SomeFeatureDeactivator someFeatureDeactivator =
                client.newWorkflowStub(SomeFeatureDeactivator.class, workflowOptions);

        someFeatureDeactivator.processEntityWithId(null);

        // then
        verify(externalServiceHelper, never()).sendMessageToDeactivateFeature(null);
    }

    @Test
    @Timeout(10)
    @Order(1)
    void processEntityWithIdTest() {
        // given
        doNothing().when(externalServiceHelper).sendMessageToDeactivateFeature(anyString());

        // when
        WorkflowOptions workflowOptions = WorkflowOptions.newBuilder()
                .setTaskQueue(QUEUE)
                .build();
        SomeFeatureDeactivator someFeatureDeactivator =
                client.newWorkflowStub(SomeFeatureDeactivator.class, workflowOptions);

        someFeatureDeactivator.processEntityWithId(ID);

        // then
        verify(externalServiceHelper, only()).sendMessageToDeactivateFeature(ID);
    }

    @Test
    @Timeout(10)
    @Order(2)
    void processEntityWithIdTest_retrySendToMessageToExternalService() {
        // given
        doThrow(new RuntimeException())
                .doThrow(new RuntimeException())
                .doThrow(new RuntimeException())
                .doNothing()
                .when(externalServiceHelper).sendMessageToDeactivateFeature(anyString());

        // when
        WorkflowOptions workflowOptions = WorkflowOptions.newBuilder()
                .setTaskQueue(QUEUE)
                .build();
        SomeFeatureDeactivator someFeatureDeactivator =
                client.newWorkflowStub(SomeFeatureDeactivator.class, workflowOptions);

        someFeatureDeactivator.processEntityWithId(ID);

        // then
        verify(externalServiceHelper, times(4)).sendMessageToDeactivateFeature(ID);
    }
}

```
3. Get tests with order numbers 1 and 2 failed because `%test_name% timed out after 10 seconds`

Got his log on failed `processEntityWithIdTest`
```
2022-11-16 15:28:18.165  INFO 11416 --- [    Test worker] io.temporal.internal.worker.Poller       : start: Poller{name=Workflow Poller taskQueue="UPDATE_DP_ATTRS_QUEUE;", namespace="default", identity=MY-PC-NAME}
2022-11-16 15:28:18.165  INFO 11416 --- [    Test worker] io.temporal.internal.worker.Poller       : start: Poller{name=Local Activity Poller taskQueue="UPDATE_DP_ATTRS_QUEUE;", namespace="default", identity=MY-PC-NAME}
2022-11-16 15:28:18.166  INFO 11416 --- [    Test worker] io.temporal.internal.worker.Poller       : start: Poller{name=Activity Poller taskQueue="UPDATE_DP_ATTRS_QUEUE;", namespace="default", identity=MY-PC-NAME}
2022-11-16 15:28:18.169  INFO 11416 --- [    Test worker] io.temporal.internal.worker.Poller       : start: Poller{name=Sticky Workflow Poller taskQueue="MY-PC-NAME:91c759e5-3a72-41da-b740-6a1208cdc07b", namespace="default", identity=MY-PC-NAME}
2022-11-16 15:28:18.239  WARN 11416 --- [ce="default": 1] i.t.i.replay.ReplayWorkflowTaskHandler   : Workflow task processing failure. startedEventId=3, WorkflowId=160396d9-ad8d-4cab-9f69-c770278e6a7a, RunId=92e9b27d-72d4-470b-b74c-fdc4c4d87991. If seen continuously the workflow might be stuck.

io.temporal.internal.statemachines.InternalWorkflowTaskException: Failure handling event 3 of type 'EVENT_TYPE_WORKFLOW_TASK_STARTED' during execution. {PreviousStartedEventId=0, WorkflowTaskStartedEventId=3, CurrentStartedEventId=3}
	at io.temporal.internal.statemachines.WorkflowStateMachines.createEventProcessingException(WorkflowStateMachines.java:263) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:242) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:216) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:190) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:137) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:129) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:98) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:293) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:237) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:178) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93) ~[temporal-sdk-1.14.0.jar:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
Caused by: java.lang.RuntimeException: WorkflowTask: failure executing SCHEDULED->WORKFLOW_TASK_STARTED, transition history is [CREATED->WORKFLOW_TASK_SCHEDULED]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:152) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:102) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:68) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleSingleEvent(WorkflowStateMachines.java:276) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:240) ~[temporal-sdk-1.14.0.jar:na]
	... 12 common frames omitted
Caused by: java.lang.IllegalStateException: Operation allowed only while eventLoop is running
	at io.temporal.internal.statemachines.WorkflowStateMachines.checkEventLoopExecuting(WorkflowStateMachines.java:1061) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.statemachines.WorkflowStateMachines.randomUUID(WorkflowStateMachines.java:717) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.replay.ReplayWorkflowContextImpl.scheduleActivityTask(ReplayWorkflowContextImpl.java:212) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.SyncWorkflowContext.executeActivityOnce(SyncWorkflowContext.java:251) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.SyncWorkflowContext.executeActivity(SyncWorkflowContext.java:236) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.ActivityStubImpl.executeAsync(ActivityStubImpl.java:50) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.ActivityStubBase.execute(ActivityStubBase.java:39) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.ActivityInvocationHandler.lambda$getActivityFunc$0(ActivityInvocationHandler.java:78) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:71) ~[temporal-sdk-1.14.0.jar:na]
	at com.sun.proxy.$Proxy173.sendMessageToDeactivateFeature(Unknown Source) ~[na:na]
	at my.service.SomeFeatureDeactivatorImpl.processEntityWithId(SomeFeatureDeactivatorImpl.java:26) ~[main/:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.execute(POJOWorkflowImplementationFactory.java:310) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:285) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.WorkflowExecuteRunnable.run(WorkflowExecuteRunnable.java:68) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:135) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:102) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:107) ~[temporal-sdk-1.14.0.jar:na]
	at io.temporal.worker.WorkerFactory.lambda$newWorkflowThreadExecutor$7(WorkerFactory.java:392) ~[temporal-sdk-1.14.0.jar:na]
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) ~[na:na]
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na]
	... 3 common frames omitted
```

## Additional attempts
I tried to launch tests in various ways: using tutorials from documentation & java-samples
This variant
```
@SpringBootTest
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class SomeFeatureDeactivatorImplTest {

    @MockBean
    ExternalServiceHelperImpl externalServiceHelper;

    @RegisterExtension
    public static final TestWorkflowExtension testWorkflowExtension =
        TestWorkflowExtension.newBuilder()
                .setWorkflowTypes(SomeFeatureDeactivatorImpl.class)
                .setDoNotStart(true)
                .build();

    @Test
    @Timeout(10)
    @Order(0)
    void processEntityWithIdTest_givenIdIsNull(TestWorkflowEnvironment testEnv, Worker worker, SomeFeatureDeactivator someFeatureDeactivator) {
        worker.registerActivitiesImplementations(externalServiceHelper);
        testEnv.start();

        // given, when
        someFeatureDeactivator.processEntityWithId(null);

        // then
        verify(externalServiceHelper, never()).sendMessageToDeactivateFeature(null);
    }
    ... // same way for other tests
```
and this
```
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class SomeFeatureDeactivatorImplTest {

    @BeforeEach
    public void setUp() {
        testEnv = TestWorkflowEnvironment.newInstance();
        worker = testEnv.newWorker(QUEUE);
        worker.registerWorkflowImplementationTypes(SomeFeatureDeactivatorImpl.class);
        client = testEnv.getWorkflowClient();
    }

    @AfterEach
    public void tearDown() {
        testEnv.close();
    }

    @Test
    @Timeout(10)
    @Order(0)
    void processEntityWithIdTest_givenIdIsNull() {
        // given, when
        ExternalServiceHelper externalServiceHelper = mock(ExternalServiceHelper.class, withSettings().withoutAnnotations());
        worker.registerActivitiesImplementations(externalServiceHelper);
        testEnv.start();

        WorkflowOptions workflowOptions = WorkflowOptions.newBuilder()
                .setTaskQueue(QUEUE)
                .build();
        SomeFeatureDeactivator someFeatureDeactivator =
                client.newWorkflowStub(SomeFeatureDeactivator.class, workflowOptions);

        someFeatureDeactivator.processEntityWithId(null);

        // then
        verify(externalServiceHelper, never()).sendMessageToDeactivateFeature(null);
    }
    ... // same way for other tests
```
don't work too
## Specifications

  - Version: 1.14 or 1.17
  - Platform: Java


#### Comments (4)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-16 14:16:44.000 UTC</summary>

Please provide a full reproduction that can be launched locally.

> Write Workflow & Activity according to description above

Not enough information without looking at actual implementations.

But I'm pretty sure that what is going on here is ActivityStubs are shared between workflow instances, which is not allowed.



</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-18 16:08:30.000 UTC</summary>

Please feel free to reopen with a reproduction

</details>

<details>
<summary><strong>idkomarov</strong> commented on 2022-11-29 11:29:20.000 UTC</summary>

> Please provide a full reproduction that can be launched locally.

Hello again. I'm back with a reproduction that can be run locally along with tests above. All classes stored as separate files as `public` modificator hints :)
```
@ActivityInterface
public interface ExternalServiceHelper {
    void sendMessageToDeactivateFeature(String id);
}

@Component
public class ExternalServiceHelperImpl implements ExternalServiceHelper {
    private final Random random = new Random();

    @Override
    public void sendMessageToDeactivateFeature(String id) {
        // this is actually a kafka producer invokation
        if (random.nextDouble() <= 0.5D) {
            throw new RuntimeException();
        }
    }
}

@WorkflowInterface
public interface SomeFeatureDeactivator {
    @WorkflowMethod
    void processEntityWithId(String id);
}

public class SomeFeatureDeactivatorImpl implements SomeFeatureDeactivator {
    public static final RetryOptions DEFAULT_RETRY_OPTIONS = RetryOptions.newBuilder()
            .setInitialInterval(Duration.ofSeconds(1))
            .setMaximumInterval(Duration.ofSeconds(10))
            .setBackoffCoefficient(2)
            .setMaximumAttempts(100)
            .build();

    public static final ActivityOptions DEFAULT_ACTIVITY_OPTIONS = ActivityOptions.newBuilder()
            .setStartToCloseTimeout(Duration.ofSeconds(5))
            .setRetryOptions(DEFAULT_RETRY_OPTIONS)
            .build();

    private static final ExternalServiceHelper externalServiceHelper =
            Workflow.newActivityStub(ExternalServiceHelper.class, DEFAULT_ACTIVITY_OPTIONS);

    @Override
    public void processEntityWithId(String id) {
        if (Objects.isNull(id)) {
            return;
        }

        // this is actually some preparations

        externalServiceHelper.sendMessageToDeactivateFeature(id);
    }
}
```

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-29 15:50:39.000 UTC</summary>

@idkomarov 
```
    private static final ExternalServiceHelper externalServiceHelper =
            Workflow.newActivityStub(ExternalServiceHelper.class, DEFAULT_ACTIVITY_OPTIONS);
```

As I pointed out earlier, stubs can't be shared between workflow instances. They need to be created during workflow instance initialization in a workflow code. Either removing `static` or moving the creation of the stub inside the workflow code will solve your problem.
Related issue: https://github.com/temporalio/sdk-java/issues/746

Reactions: üëç 1

</details>


---

<a id="1424"></a>

### #1424: Test server should not require task queue on continue as new

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1424 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-14 13:35:06.000 UTC (3y 3m ago) |
| **Updated** | 2024-06-21 16:22:47.000 UTC |
| **Closed** | 2024-06-21 16:22:47.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

## Expected Behavior

Actual server does not require task queue on continue as new

## Actual Behavior

Test server does not require task queue on continue as new


---

<a id="1200"></a>

### #1200: Search attributes are not carried forward on ContinueAsNew

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1200 |
| **State** | CLOSED |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2022-05-11 01:13:49.000 UTC (3y 8m ago) |
| **Updated** | 2023-05-23 17:40:56.000 UTC |
| **Closed** | 2023-05-23 17:40:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Search attributes to be carried-forward during `Workflow.continueAsNew()`

## Actual Behavior

Continued-as-new workflows are missing the search attributes from the original run.

## Steps to Reproduce the Problem

  1. Create a workflow with search attributes
  1. Call `continueAsNew`
  1. Verify via tctl that search attributes are missing from new run ID.

## Specifications

  - Version: 1.10.0
  - Platform: 1.15.2


#### Comments (4)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-11 01:23:57.000 UTC</summary>

Use `ContinueAsNewOptions.Builder#setSearchAttributes` to pass search attributes into `continueAsNew` for now.

Reactions: üëç 1

</details>

<details>
<summary><strong>patte</strong> commented on 2022-08-09 19:30:32.000 UTC</summary>

> Use `ContinueAsNewOptions.Builder#setSearchAttributes` to pass search attributes into `continueAsNew` for now.

Is there a similar possibility in the python SDK for `retry_policy`? I don't see `retry_policy` as a param in `continue_as_new`.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-09 19:34:39.000 UTC</summary>

> Is there a similar possibility in the python SDK for retry_policy? I don't see retry_policy as a param in continue_as_new.

@patte Please post as a question in `#python-sdk` channel of our [Community Slack](https://temporal.io/community) or as a feature request in https://github.com/temporalio/sdk-python/issues. Our Python SDK is still in beta, but this should be available there one day.

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 17:40:56.000 UTC</summary>

closing in favor of https://github.com/temporalio/sdk-java/issues/1201 since there are more attributes not passed then just SA.

</details>


---

<a id="1120"></a>

### #1120: Cannot return value of WorkflowLocal var from query method

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1120 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-04-04 19:44:01.000 UTC (3y 9m ago) |
| **Updated** | 2025-06-02 15:32:00.000 UTC |
| **Closed** | 2025-06-02 15:32:00.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

Query method:

         @Override
         public String queryGreeting() {
             return greeting.get();
         }

where greeting is 

        private WorkflowLocal<String> greeting = WorkflowLocal.withInitial(() -> "hello");

When a client calls queryGreeting SDK fails with:

         Caused by: io.grpc.StatusRuntimeException: INVALID_ARGUMENT: java.lang.Error: Called from non workflow or workflow callback thread



---

<a id="1025"></a>

### #1025: In case of existing workflow both sync and async executions should have an option to error out or return an existing execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1025 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-02 18:19:27.000 UTC (3y 11m ago) |
| **Updated** | 2023-01-12 00:04:26.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

In addition to WorkflowReusePolicy, GoSDK has a flag

https://github.com/temporalio/sdk-go/blob/57736850f55b2b3e17cffa0e3493c4e0d6de831f/internal/client.go#L529
```
// When WorkflowExecutionErrorWhenAlreadyStarted is true, Client.ExecuteWorkflow will return an error if the
// workflow id has already been used and WorkflowIDReusePolicy would disallow a re-run. If it is set to false,
// rather than erroring a WorkflowRun instance representing the current or last run will be returned.
//
// Optional: defaults to false
WorkflowExecutionErrorWhenAlreadyStarted bool
```

That enabled an explicit failing of the workflow start if WorkflowReusePolicy disallowed an execution instead of returning the old execution.

This has to be added to JavaSDK, otherwise, there is no way for users to get the fact that the start request was disallowed and the returned execution is an old execution.

One of the discussions on this topic:
[C02E8TQA01G-1673406348.075879.txt](https://github.com/temporalio/sdk-java/files/10396892/C02E8TQA01G-1673406348.075879.txt)


#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2022-02-03 05:15:54.000 UTC</summary>

No need for such flag in Java. The solution is to make two API calls:
1. StartWorkflow which is going to throw "already running"
2. Wait for workflow result

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-05 19:48:33.000 UTC</summary>

@mfateev This makes users use exceptions as a part of their normal code flow. It is bad practice especially when we already have all the underlying APIs to make it possible without exceptions.
Also, it's messy and counterintuitive that sync API in case of a duplicate returns an existing execution, while async execution throws an exception.
It looks like we have to preserve backward compatibility, but we need to give users a choice in both APIs to error out or just to attach to existing execution if there is one.

</details>


---

<a id="995"></a>

### #995: Inheritance of workflow interfaces is not supported

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/995 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-21 20:53:43.000 UTC (3y 11m ago) |
| **Updated** | 2024-12-17 21:26:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

```
  @WorkflowInterface
  public interface CustomerWorkflow {

    @WorkflowMethod
    void execute(Customer customer);

  }

  @WorkflowInterface
  public interface CustomerWorkflowWithSignal extends CustomerWorkflow {

    @SignalMethod(name = "setCustomer")
    void setCustomer(Customer customer);
  }
```

Registering two classes that implement the interfaces above should be possible, the second implementation should have a CustomerWorkflowWithSignal name.

Instead, it causes "java.lang.IllegalStateException: CustomerWorkflow workflow type is already registered with the worker".

Special consideration should be put into maintaining compatibility during the fix as it may change the workflow names for some users.

#### Comments (4)

<details>
<summary><strong>mfateev</strong> commented on 2022-01-23 21:45:47.000 UTC</summary>

This is supported:
```
  public interface CustomerWorkflow {

    @WorkflowMethod
    void execute(Customer customer);

  }

  @WorkflowInterface
  public interface CustomerWorkflowWithSignal extends CustomerWorkflow {

    @SignalMethod(name = "setCustomer")
    void setCustomer(Customer customer);
  }
```

</details>

<details>
<summary><strong>mfateev</strong> commented on 2022-01-23 21:47:26.000 UTC</summary>

Currently any interface annotated with @WorkflowInterface defines a workflow type. I don't think a user would really want to have two separate workflow types CustomerWorkflow and CustomerWorkflowWithSignal in this case.

See https://docs.temporal.io/docs/java/workflows#workflow-interface-inheritance

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-23 21:51:43.000 UTC</summary>

> This is supported:
> 
> ```
>   public interface CustomerWorkflow {
> 
>     @WorkflowMethod
>     void execute(Customer customer);
> 
>   }
> 
>   @WorkflowInterface
>   public interface CustomerWorkflowWithSignal extends CustomerWorkflow {
> 
>     @SignalMethod(name = "setCustomer")
>     void setCustomer(Customer customer);
>   }
> ```

The objective of the issue is "Inheritance of workflow interfaces is not supported". In your snippet, CustomerWorkflow is not a WorkflowInterface.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-23 21:55:50.000 UTC</summary>

> I don't think a user would really want to have two separate workflow types CustomerWorkflow and CustomerWorkflowWithSignal in this case.

^ This is how I would expect it to behave.

This should be either supported or explicitly non-supported. So, this either should work as described in the description of the issue OR it should throw an exception like "Inheritance of workflow interfaces is not supported". 

What definitely shouldn't happen and it happens now, when a user registers CustomerWorkflowWithSignal workflow, actually a workflow CustomerWorkflow gets registered. It's confusing, non-obiovus and error-prone.

</details>


---

<a id="940"></a>

### #940: Header support for signals and queries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/940 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-12-28 19:39:16.000 UTC (4 years ago) |
| **Updated** | 2024-09-17 15:17:07.000 UTC |
| **Closed** | 2024-09-17 15:17:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Headers were added to signals and queries in https://github.com/temporalio/temporal/pull/2149. 

**Describe the solution you'd like**

Add to SDK

**Additional context**

* Go SDK: https://github.com/temporalio/sdk-go/pull/631
* TypeScript SDK: https://github.com/temporalio/sdk-typescript/issues/438


#### Comments (4)

<details>
<summary><strong>pooja-fyndna</strong> commented on 2023-03-02 04:42:27.000 UTC</summary>

I am also waiting for this feature. Any updates on this?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-02 17:32:07.000 UTC</summary>

@pooja-fyndna There is no updates. If there was work done - there would be linked PRs.
We don‚Äôt provide time estimates for feature requests.
We happily accept contributions.


Reactions: üëç 1

</details>

<details>
<summary><strong>bhagya05</strong> commented on 2024-09-17 10:04:47.000 UTC</summary>

@Spikhalskiy We are extending WorkflowClientCallsInterceptorBase and OpenTracingWorkflowInboundCallsInterceptor
to add tracing for signal in temporal 1.25.1 java sdk.
Is this a valid approach ?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-17 15:17:07.000 UTC</summary>

This issue was already resolved by https://github.com/temporalio/sdk-java/pull/1819

</details>


---

<a id="928"></a>

### #928: TestActivityExtension lifecycle problems with more than a single test case

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/928 |
| **State** | CLOSED |
| **Author** | mreardonx |
| **Created** | 2021-12-10 17:45:50.000 UTC (4y 1m ago) |
| **Updated** | 2023-03-22 00:40:42.000 UTC |
| **Closed** | 2022-07-28 17:35:31.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
The Junit 5 TestActivityExtension lifecycle should support multiple test methods in a single test class.

## Actual Behavior
With two test methods, the first test method completes as expected, but the second test method throws an exception when an activity task is submitted.

```
Task java.util.concurrent.FutureTask@39b85002 rejected from java.util.concurrent.ThreadPoolExecutor@377fb945[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]
java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@39b85002 rejected from java.util.concurrent.ThreadPoolExecutor@377fb945[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
	at java.util.concurrent.Executors$DelegatedExecutorService.submit(Executors.java:681)
	at io.temporal.testing.TestActivityEnvironmentInternal$TestActivityExecutor.executeActivity(TestActivityEnvironmentInternal.java:345)
	at io.temporal.testing.TestActivityEnvironmentInternal$TestActivityExecutor.executeActivity(TestActivityEnvironmentInternal.java:298)
	at io.temporal.internal.sync.ActivityStubImpl.executeAsync(ActivityStubImpl.java:49)
	at io.temporal.internal.sync.ActivityStubBase.execute(ActivityStubBase.java:38)
	at io.temporal.internal.sync.ActivityInvocationHandler.lambda$getActivityFunc$0(ActivityInvocationHandler.java:77)
	at io.temporal.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:70)
	at io.temporal.internal.sync.DeterministicRunnerWrapper.lambda$invoke$0(DeterministicRunnerWrapper.java:43)
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:101)
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:107)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
```

## Steps to Reproduce the Problem

  1. Modifiy the io.temporal.samples.hello.HelloDynamicActivityJUnit5Test test to have two test methods by making of copy of `testDynamicActivity` method and renaming it.
  2. Run the unit test.  Both test cases should have passed, but only one will.

## Specifications

  - Version:  1.6.0
  - Platform: Java 17, Junit 5


#### Comments (2)

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-07-27 01:27:50.000 UTC</summary>

Possible root cause explained in https://github.com/temporalio/sdk-java/issues/1133#issuecomment-1197088838

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-05 01:43:49.000 UTC</summary>

@eeshvardasikcm 

> I didn't get a response and noticed my comments were deleted. That's not very honorable of the gift I gave. Did I violate some commenting rules? I may not have read all of your rules.

We don't guarantee responses on community activity and preservation of all the comments. 
I found the comments irrelevant to the discussion and the issue, all 4 of them.
Taking into account that there was a valuable up-to-the-point contribution from another community member later, I decided to trim these comments to keep the history and context of this issue clean for the next reader. One of the goals that I have maintaining this repo is to empower users to easily trace changes back to the issues and allow them to effectively grasp the context and reason for the changes that are made in Pull Requests.

You can always fork the repo and apply all the suggestions that you consider right, our license allows that.

> So it appears you are going with a single solution instead of the architectural improvement that I indicated. 

Correct, this issue doesn't need any architectural changes, it's a pretty trivial local mistake of the original implementers.

> It's not my money your spending so I'm not losing money on this fix.

Sounds great.

I attach the screenshots of the gift to this message for future readers that may want to evaluate it's value and relevance to this issue themselves.
<img width="1067" alt="Screen Shot 2022-08-05 at 12 30 06 AM" src="https://user-images.githubusercontent.com/532108/183001803-0b2365d1-d04c-4766-955e-f62db052e23c.png">




</details>


---

<a id="915"></a>

### #915: Improve signalWithStart usability

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/915 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-12-04 23:07:18.000 UTC (4y 1m ago) |
| **Updated** | 2024-12-23 10:21:09.000 UTC |
| **Closed** | 2024-12-23 10:21:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement, good first issue |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`Workflow#signalWithStart` method interface is overcomplicated and hard to use without checking with samples first.
We should improve the classes structure and provide more conventional builders and factory methods around this method and functionality.



#### Comments (4)

<details>
<summary><strong>mfateev</strong> commented on 2022-01-23 21:57:00.000 UTC</summary>

Such refactoring should keep the strongly typed way to call this method the current implementation provides.

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2022-02-11 18:42:47.000 UTC</summary>

Wanted to suggest one possible improvement. 
Currently with signalWithStart we can do for example:

    WorkflowStub untyped = WorkflowStub.fromTyped(typedStub);
    untyped.signalWithStart(...);

( or just create an untyped stub to start with ) so this works off just WorkflowStub (untyped)

WorkflowClient.signalWithStart only works off typed stubs, for example:

     BatchRequest request = client.newSignalWithStartRequest();
     request.add(myWorkflowStub::exec, input); // exec is workflow method
     request.add(myWorkflowStub::handleSignal, signalData); // handleSignal is a signal method
     client.signalWithStart(request);

It would be nice to add an "untyped" option for WorkflowClient.signalWithStart that takes in signalName, signalData, inputData. 

Bonus question, whats the use for WorkflowClient.signalWithStart? When would you use it instead of WorkflowStub.signalWithStart?

</details>

<details>
<summary><strong>drewhoskins-temporal</strong> commented on 2024-10-09 18:43:03.000 UTC</summary>

We've recently shipped [updateWithStart](https://github.com/temporalio/sdk-java/blob/d1dc2e186ae4c23097de2bb52c3cd6e0ebeb8676/temporal-sdk/src/main/java/io/temporal/client/WorkflowStub.java#L161) in pre-release, and we hope it has better usability.
If it goes well, we'd like to make `signalWithStart` adopt this pattern for better usability and consistency, so please take a look.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 10:21:08.000 UTC</summary>

Closing as a duplicate of https://github.com/temporalio/sdk-java/issues/2213

</details>


---

<a id="811"></a>

### #811: Add test framework for partial json history replay and continuing of execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/811 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-11 16:25:16.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-11 16:25:16.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

**Is your feature request related to a problem? Please describe.**
We have a framework that allows launching workflows from scratch.
We also have a way to make a full history replay using query functionality. See `WorkflowReplayer` that falls back to     `worker.queryWorkflowExecution(history, WorkflowClient.QUERY_TYPE_REPLAY_ONLY, ...)`
We don't have a way to make a replay of a partial json history and continue the execution (aka restoring from a failure).
It's supported for our state machines testing framework, but not for workflow integration testing framework.
Which limits what kind of state machines permutation we can cover with functional tests and limits our ability to test replayability by itself.

**Describe the solution you'd like**
Add an ability for our TestService to load a partial workflow history from a json, restore a workflow mutable state from it and dispatch workflow tasks to continue execution on a worker simulating restoring after a failure or after a worker cache eviction.

**Describe alternatives you've considered**
Alternatively, to get the same result in the test, we can simulate a failure the first time at the place in a workflow we want to get a replay to. But this is a hacky way to achieve to goal and also it doesn't allow us to test compatibility with histories produced in older versions of SDKs.
Alternatively, we can continue to don't have tests covering continue execution after a partial replay.


---

<a id="761"></a>

### #761: Add an ability to create WorkflowStub from workflowInterface

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/761 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-23 21:37:05.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-27 17:09:19.000 UTC |
| **Closed** | 2021-10-27 17:09:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

Right now if we have a workflow interface, the way to create an untyped WorkflowStub is to first create a regular stub and after that convert it into an untyped stub in the following manner:

```
    WorkflowInterface workflow = WorkflowClient.newWorkflowStub(workflowInterface, workflowId)
    WorkflowStub untypedStub = WorkflowStub.fromTyped(workflow);
```

JavaSDK should have a version of `WorkflowClient.newUntypedWorkflowStub` that is be able to create WorkflowStub from a pair `workflowInterface, workflowId` directly like:

```
    WorkflowStub untypedStub = WorkflowClient.newUntypedWorkflowStub(workflowInterface, workflowId)
```

#### Comments (4)

<details>
<summary><strong>vkoby</strong> commented on 2021-10-25 22:05:04.000 UTC</summary>

Just curious, if there a bigger reason for this enhancement:

- We already have a few API to create an untyped WF stub from the client: 
<img width="868" alt="Screen Shot 2021-10-25 at 3 01 08 PM" src="https://user-images.githubusercontent.com/20527999/138777205-58564b8e-f342-4362-b9f0-afe44d24a870.png">

- What use cases did you have in mind that justify creating a new API method vs writing 2 lines of code?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-25 22:14:52.000 UTC</summary>

> We already have a few API to create an untyped WF stub from the client

They don't cover the described usecase. And the described usecase is probably one of the most common. We have an interface and a workflowId, we want to get an untyped stub to send a signal or query.

> What use cases did you have in mind that justify creating a new API method vs writing 2 lines of code?

We have an interface and a workflowId, we want to get an untyped stub to send a signal for example.
Creating of a new API method is justified by the fact that WorkflowClient already has methods to create untyped stubs for all kinds of cases directly from all kinds of parameters combination, there is no reason why we shouldn't handle this case too without needed to create a typed stub first. Otherwise, users may never find `WorkflowStub.fromTyped` at all.

Reactions: üëç 1

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-25 23:20:42.000 UTC</summary>

@vkoby I discussed with @mfateev and actually, you are right.
I missed the fact that in
```
  WorkflowStub newUntypedWorkflowStub(
      String workflowId, Optional<String> runId, Optional<String> workflowType)
```
workflowType can be empty or absolutely any value, it's not really used for anything other than producing error messages.


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-25 23:21:52.000 UTC</summary>

Let's instead of the original method from this task just add a trivial 
`newUntypedWorkflowStub(String workflowId)`
that is just implemented as `newUntypedWorkflowStub(workflowId, Optional.empty(), Optional.empty())` inside.

Reactions: üëç 1

</details>


---

<a id="701"></a>

### #701: Async activity completion with primitive return value converts null to zero

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/701 |
| **State** | CLOSED |
| **Author** | osi (peter royal) |
| **Created** | 2021-09-08 16:49:03.000 UTC (4y 4m ago) |
| **Updated** | 2025-06-02 14:29:25.000 UTC |
| **Closed** | 2025-06-02 14:29:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | bug, good first issue |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When using async completion of an activity returning a primitive value and completing with `null`, a `NullPointerException` should be generated in either the Workflow or when completing the Activity. (Similar to how auto-unboxing behaves)

## Actual Behavior

The workflow has a return value of zero.

## Steps to Reproduce the Problem

  1. Create an activity method that returns a primitive, eg `long`. 
  1. Use `useLocalManualCompletion` to get a completion client
  1. Complete the activity with null, eg `complete(null)`
  2. Inspect the returned value of the activity in the workflow. It will be zero. 

## Specifications

  - Version: 0.11.0
  - Platform: using `TestWorkflowEnvironment`


#### Comments (4)

<details>
<summary><strong>vkoby</strong> commented on 2021-10-27 16:28:30.000 UTC</summary>

Hi @osi 
Would you mind sending a code sample? I couldn't reproduce your issue (see my attempt [here](https://github.com/temporalio/sdk-java/pull/846))
Also, I noticed that your version of SDK is super outdated, I would highly recommend to update.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-27 16:37:32.000 UTC</summary>

@vkoby So, the test in https://github.com/temporalio/sdk-java/pull/846 passes. According to the build status.
It shouldn't. This is exactly the problem that is reported in this issue.

</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-10-27 17:26:52.000 UTC</summary>

@Spikhalskiy @osi , Sorry, I wasn't clear:
The reported issue is that null is converted to zero, and the repro step 4 says it's converted to zero. That doesn't reproduce - we are seeing null propagated instead, which if converted to `int` will result in NPE.
There is a separate question whether we want null propagated in these cases, but that's not what that issue is about.

</details>

<details>
<summary><strong>osi</strong> commented on 2021-10-27 17:41:42.000 UTC</summary>

Yes, I was on an older SDK. The missing detail in the reproduction steps is to invoke the activity synchronously from the workflow, so that there's unboxing required from the `null` completion value to the local primitive variable.

(yes, this is a programming error in the activity to return null)

Reactions: üëç 1

</details>


---

<a id="631"></a>

### #631: DeterministicRunner is noisy about not accessed cancelled scopes and timers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/631 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-15 16:57:32.000 UTC (4y 4m ago) |
| **Updated** | 2024-12-17 21:26:56.000 UTC |
| **Upvotes** | 2 |
| **Comments** | 0 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 2 |

#### Description

## Expected Behavior
We have logic in Deterministic Runner detecting the fact that a promise failed, but the exception or reason of the cancellation was never accessed.
If the cancellation scope is canceled, it should be normal and expected to don't access the promises created in this scope and the logic above shouldn't be noisy about it.

## Actual Behavior

If cancel a cancellation scope and never read its Promises, Deterministic Runner will make a noisy log about it, while it's an expected pattern:
```
12:46:38.400 [...] WARN  i.t.i.sync.DeterministicRunnerImpl - Promise completed with exception and was never accessed. The ignored exception:
io.temporal.failure.CanceledFailure: Canceled by request
	at java.base/java.lang.Thread.getStackTrace(Thread.java:1596)
	at io.temporal.internal.sync.CompletablePromiseImpl.throwFailure(CompletablePromiseImpl.java:136)
	at io.temporal.internal.sync.CompletablePromiseImpl.getImpl(CompletablePromiseImpl.java:95)
	at io.temporal.internal.sync.CompletablePromiseImpl.get(CompletablePromiseImpl.java:74)
	at io.temporal.internal.sync.DeterministicRunnerImpl.close(DeterministicRunnerImpl.java:309)
	at io.temporal.internal.sync.SyncWorkflow.close(SyncWorkflow.java:165)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.close(ReplayWorkflowExecutor.java:145)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.close(ReplayWorkflowRunTaskHandler.java:242)
	at io.temporal.internal.replay.WorkflowExecutorCache.lambda$new$0(WorkflowExecutorCache.java:56)
	at com.google.common.cache.LocalCache.processPendingNotifications(LocalCache.java:1810)
	at com.google.common.cache.LocalCache$Segment.runUnlockedCleanup(LocalCache.java:3463)
	at com.google.common.cache.LocalCache$Segment.postWriteCleanup(LocalCache.java:3439)
	at com.google.common.cache.LocalCache$Segment.remove(LocalCache.java:3073)
	at com.google.common.cache.LocalCache.remove(LocalCache.java:4247)
	at com.google.common.cache.LocalCache$LocalManualCache.invalidate(LocalCache.java:4887)
	at io.temporal.internal.replay.WorkflowExecutorCache.invalidate(WorkflowExecutorCache.java:140)
	at io.temporal.internal.replay.WorkflowExecutorCache.getOrCreate(WorkflowExecutorCache.java:75)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.getOrCreateWorkflowExecutor(ReplayWorkflowTaskHandler.java:182)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:200)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:114)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:319)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:279)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
```

## Steps to Reproduce the Problem


---

<a id="618"></a>

### #618: a load balancer with an idle timeout causes java sdk to log UNAVAILABLE errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/618 |
| **State** | CLOSED |
| **Author** | thewmo |
| **Created** | 2021-08-04 14:58:47.000 UTC (4y 5m ago) |
| **Updated** | 2023-12-27 01:10:54.000 UTC |
| **Closed** | 2023-12-27 01:10:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

If the Temporal front-end server is behind a load balancer, and that load balancer should close an idle connection that is polling for tasks, if anything is logged it should be at a debug or info level, and the SDK should immediately create a new connection to resume the poll.

## Actual Behavior

sdk-java logs the following exception at level ERROR:

`io.grpc.StatusRuntimeException: UNAVAILABLE: unavailable\n	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262) ~[grpc-stub-1.39.0.jar!/:1.39.0
at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243) ~[grpc-stub-1.39.0.jar!/:1.39.0
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156) ~[grpc-stub-1.39.0.jar!/:1.39.0`

These clutter the logs and the only way to squelch them is to basically turn off all logging from the Poller logger. I have observed no functionality problems with this application, and the Poller appears to immediately resume a poll after this happens, so I don't think there are any functional problems here beyond the log spam.

## Steps to Reproduce the Problem

These steps correspond to the configuration in which I am observing the issue.

  1. Deploy temporal in AWS, in my case it is on ECS using the all-in-one docker image but the deployment method shouldn't matter.
  2. Configure an AWS ALB with http/2 GRPC support enabled pointing at the Temporal front-end endpoint. Set the idle-timeout of the ALB to some specific value in the range of several minutes.
  3. Deploy a java application using sdk-java using the AWS ALB as the target. Create at least one worker.
  4. Observe that polling for tasks logs these exceptions, and the frequency of the exceptions scales inversely with the value of the ALB idle-timeout.

## Specifications

  - Version: 1.1.0
  - Platform: Java 11

Note that I debugged into the exceptions and can observe them coming out of the GRPC layer and bubbling up to the Poller's error handler, which is treating all errors in the same manner. Probably this error could be recognized as harmless and logged at a lower logging level?


#### Comments (4)

<details>
<summary><strong>vitarb</strong> commented on 2021-09-17 06:19:46.000 UTC</summary>

I've tried to reproduce this and the only exception that I see logged is at WARN level from the [grpc retrier](https://github.com/temporalio/sdk-java/blob/0da3149c8eb16454c30fb7bda32d28f2539f3f3c/temporal-serviceclient/src/main/java/io/temporal/internal/retryer/GrpcSyncRetryer.java#L56). I don't see anything logged at the ERROR level.
I think that WARN level is too high and we should change it to DEBUG, since these errors can happen pretty rapidly (at the request level) and we should log only actual failures after we run out of retries at INFO+ level.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-09-17 21:36:48.000 UTC</summary>

I made a change that allows making log level for rpc retries configurable, but I don't like this approach as it restricts us to a single level in the entire retry layer, so we are not going to land this change. Instead I'm going to adjust the default log level from WARN to DEBUG for they sync retrier.

Reactions: üëç 1

</details>

<details>
<summary><strong>bergundy</strong> commented on 2021-10-28 13:42:09.000 UTC</summary>

@Spikhalskiy please triage

</details>

<details>
<summary><strong>josh-berry</strong> commented on 2023-12-27 01:10:54.000 UTC</summary>

Should already be addressed as part of other work; closing.

</details>


---

<a id="588"></a>

### #588: Make `TEMPORAL_DEBUG` definable via code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/588 |
| **State** | CLOSED |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2021-07-12 22:46:55.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-20 22:20:01.000 UTC |
| **Closed** | 2021-07-20 22:20:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Java does not let you modify environment variables from code like many other languages do (without doing a ton of reflection). This makes debugging workflows from tests annoying using editors like IntelliJ, as you need to create custom run configurations for each test that you want to debug. This is disruptive, and quickly clutters up the project's run configurations.

**Describe the solution you'd like**
Make `TEMPORAL_DEBUG` definable via code while setting up either the workflow client (or whatever), or optionally, via the Junit4/5 extensions. Something like:

```kotlin
val workflowExtension = TestWorkflowExtension.newBuilder()
  .setDebug(true)
  // ...
  .build()
```

**Describe alternatives you've considered**

1. Create a new `Run Configuration` for each test you want to debug. Outlined why this isn't desirable above.
2. Add `TEMPORAL_DEBUG=1` to the Gradle's `test` task. This is undesirable because then `TEMPORAL_DEBUG=1` will be set for all tests all of the time, opening up the potential for the deadlock detector to not catch obvious errors during tests.


#### Comments (4)

<details>
<summary><strong>vitarb</strong> commented on 2021-07-15 06:46:29.000 UTC</summary>

Have you tried setting this env var for all test configurations by default?
For example in intellij you can do it for the entire junit template:
![Screenshot from 2021-07-14 23-44-02](https://user-images.githubusercontent.com/1311694/125741635-d99b8513-1d3e-4176-ab31-e6c389a1f7f1.png)


</details>

<details>
<summary><strong>robzienert</strong> commented on 2021-07-15 20:56:14.000 UTC</summary>

Yeah, that's possible, but then we'd have to wait for CI to get feedback of whether or not the deadlock detector gets hit, which has potential for wasted productivity cycles.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-07-19 18:45:30.000 UTC</summary>

Have you tried using `WorkerOptions.Builder#setDefaultDeadlockDetectionTimeout`? If you change that value in tests, it would override default timeout for the deadlock detector. Would that be sufficient for you?

</details>

<details>
<summary><strong>robzienert</strong> commented on 2021-07-20 22:20:00.000 UTC</summary>

Oh, I totally missed that config option - yes, that would suit our needs fine. Thanks!

</details>


---

<a id="535"></a>

### #535: Add pollExecutor thread pool metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/535 |
| **State** | CLOSED |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2021-06-09 23:15:46.000 UTC (4y 7m ago) |
| **Updated** | 2021-09-28 15:52:22.000 UTC |
| **Closed** | 2021-09-28 15:52:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
It's currently unclear the SDK's thread usage, as no thread pools are reporting their metrics. This makes it more difficult to tune workers.

**Describe the solution you'd like**
Adding a scheduled thread to get snapshot metrics on the thread pool's core, active, and max sizes would help. A synthetic "blocked" tasks metric may also be useful via subtracting `taskCount - completedTaskCount`.

What I'm unclear about is how to correctly tag these metrics. `Poller` has an `identity`, but as best as I can tell this is going to be different per-process so tracking how thread pool usage changes through application deployments would be impossible. Is there a good option here where pollers could get a deterministic name to reference them by for use in metric tags?


#### Comments (4)

<details>
<summary><strong>robzienert</strong> commented on 2021-07-20 22:25:20.000 UTC</summary>

@vitarb I could use your opinion on implementation here...

I believe I need to introduce either: A) An `identity` naming scheme, or B) A new `identityGroup` property for `WorkflowClientOptions`. Right now the `identity` defaults to `ManagementFactory.getRuntimeMXBean().getName()`, which make sense since we want all pollers to have unique identifiers. However, for the purposes of tracking metrics, we want an identifier that will stay consistent across processes and new worker deployments to correlate metrics.

Do you have a preference on which path to take? I think adding a new property (such as `identityGroup`) would be the most unobtrusive path forward for existing SDK users. This property would be nullable and default to `null`. This value, when nonnull, would be added as a `group` tag to the metric scope.

Thoughts?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-07-20 22:32:48.000 UTC</summary>

@robzienert as we discussed, you can use ```WorkflowClientOptions#identity``` to set a worker identity, it's exposed and allowed to be overridden specifically for this purpose.

</details>

<details>
<summary><strong>robzienert</strong> commented on 2021-07-20 23:01:15.000 UTC</summary>

My question is not about identifying a single worker, which `identity` is perfectly suited for. My question is identifying a group of like-workers, across processes. Here's an example:

Let's say we have an autoscaling group of workers, named `myworker-v000`. There are 3 EC2 instances inside of it, all of them using the same AMI, and so also configured exactly the same. In this case, there will be 3 unique `identity` values for each worker: This is desirable.

Now let's say I deploy a new version of my workers, named `myworker-v001`. These workers will still be doing the same thing, but with potentially new workflow / activity code. These will also all get new `identity` values: This is also desirable.

What is missing is a metric scope tag that will allow me to correlate the thread pools of these worker pollers between processes within the same ASG, as well as correlate the thread pools _across_ ASGs as the software changes. For this, I'm proposing that a new field called `identityGroup` is added, this field is _not unique_ and would be static across all processes and autoscaling groups. It would provide SDK users a means of understanding thread pool usage changes as code changes. Without such a tag, what I'm describing is impossible if there is more than 1 poller in the process. Defining a static `identity` value would provide us this capability, but then we would lose the ability to identify pollers uniquely, which would be a regression.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-28 15:52:16.000 UTC</summary>

Rob was able to solve the problem with the APIs and abilities Temporal provides now.
Feel free to reopen any time if something is lacking.

</details>


---

<a id="525"></a>

### #525: Allow context propagators & interceptors to populate ActivityExecutionContext

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/525 |
| **State** | OPEN |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2021-06-03 16:51:51.000 UTC (4y 7m ago) |
| **Updated** | 2024-12-17 21:27:53.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | robzienert, vitarb |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
I'm trying to access information from a context propagator in an Activity. The current strategy is that the context propagator should create a `ThreadLocal` to make this data accessible from an Activity, but the ergonomics of this could be improved.

**Describe the solution you'd like**
Being able to access propagated context via `Activity.getExecutionContext()` would be have better ergonomics. In this scenario, it seems like the responsibility would still be on the `ContextPropagator` or interceptor to populate these values, but accessing this information from activities would be cleaner.

**Describe alternatives you've considered**
The existing `ThreadLocal` pattern works.


#### Comments (2)

<details>
<summary><strong>robzienert</strong> commented on 2021-06-03 17:04:08.000 UTC</summary>

I would be interested in taking this on, provided a little bit of advise on how you think it would be best implemented.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-06-07 16:59:55.000 UTC</summary>

Sure, you can ping me in temporal [slack](https://join.slack.com/t/temporalio/shared_invite/zt-onhti57l-J0bl~Tr7MqSUnIc1upjRkw) if you need any help.

</details>


---

<a id="468"></a>

### #468: DataConverter is (surprisingly?) used for custom search attributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/468 |
| **State** | CLOSED |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2021-05-05 19:03:13.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-24 17:21:58.000 UTC |
| **Closed** | 2021-05-24 17:21:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

We were putting some custom serialization / deserialization in place to handle our workflow/activity arguments and noticed that the DataConverter (including our custom one). Expected behavior was that this change would only apply to the workflow/activity arguments.

## Actual Behavior

This change also applies to the to the custom search attributes that are set on the workflow options, which would cause errors when these encoded values were being sent to ElasticSearch.

The workaround we are using is to be more selective on which class types we apply the custom data converter to and we make sure that the primitive java types use the default converter. 


## Specifications

  - Version: sdk 1.0.7
  - Platform: java / temporal 1.6.3


#### Comments (4)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-06 17:51:49.000 UTC</summary>

Steve, thanks for the question. Data converter is used to serialize/deserialize all parameters that need to be sent over the wire. Your work-around sounds reasonable to me, I can see why it feels a bit hacky though. Did you expect that search attributes shouldn't be encoded at all? Do you have any proposals here or did you just want to have a discussion? If it's for the discussion then perhaps we should move the topic to our [community forum](community.temporal.io/).

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-05-07 17:24:42.000 UTC</summary>

DataConverter is pluggable. But the format of the search attribute serialization is fixed by the service. So using DataConverter (at least one provided by the user) for search attributes is not correct. We should be careful here though as it can break backwards compatibility if we just stop using the provided DC.

Reactions: üëç 1

</details>

<details>
<summary><strong>skrul</strong> commented on 2021-05-10 18:05:20.000 UTC</summary>

So I talked to manu a bit about this and it turns out we were doing this slightly wrong (but the basic problem remains). We had implemented a `PayloadConverter` and added it as one of the converters in the list supplied to the default data converter. What we've been advised to do is to implement our own DataConverter instead.

However, this is where things are a bit confusing as it seems that `toPayload` is used for stuff like search attributes and memo, where `toPayloads` (note the singular vs plural) is used for workflow/activity input/output. Our solution will be to use our custom serde for `toPayloads` but then delegate to the default data converter for `toPayload`.

And I agree with maxim, stuff like search attributes and memo should be passed verbatim since these values ultimately need to be indexed by ES / read by humans so encoding them would be incorrect.



</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-05-11 05:36:32.000 UTC</summary>

Since search attributes are a `Map<String, Object>` we would need to use some data converter in order to transform it into `Map<String, Payload>`. Should we just replace custom converter with default one like I've done in [this proposal](https://github.com/temporalio/sdk-java/pull/483)?

</details>


---

<a id="467"></a>

### #467: Register multiple activity names for an activity

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/467 |
| **State** | OPEN |
| **Author** | jonsie (Chris Smalley) |
| **Created** | 2021-05-03 23:44:31.000 UTC (4y 8m ago) |
| **Updated** | 2023-04-19 20:17:39.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

In the event of a refactor wherein activity names are changed (prefix added, method name changed, etc) there is no clean way to migrate from one activity name to another --> if a worker picks up an activity with a name that is not registered with that worker it will throw an `ApplicationFailure`.

**Describe the solution you'd like**

I would like to have the ability to register multiple activity names for an activity - this way one could deploy the activity name change and then on the next deploy delete the previous activity name.

Ideally there would be a mechanism to mark one activity name as deprecated.

Thanks!

#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-06 17:58:31.000 UTC</summary>

@jonsie are you asking to add name aliases into [`@ActivityMethod`](https://github.com/vitarb/java-sdk/blob/f0bbf84c496454d9909caefe6ca2784f76b8e592/temporal-sdk/src/main/java/io/temporal/activity/ActivityMethod.java#L33) annotation?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-19 20:17:38.000 UTC</summary>

Design of this feature should be approached together with https://github.com/temporalio/sdk-java/issues/396

</details>


---

<a id="460"></a>

### #460: Please add ActivityCompletionClient support in TestActivityEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/460 |
| **State** | CLOSED |
| **Author** | wxing1292 (Wenquan Xing) |
| **Created** | 2021-02-11 01:11:08.000 UTC (4y 11m ago) |
| **Updated** | 2024-12-23 20:08:39.000 UTC |
| **Closed** | 2024-12-23 20:08:38.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 üëÄ 2 |

#### Description

See issue created on server side: https://github.com/temporalio/temporal/issues/1185

#### Comments (2)

<details>
<summary><strong>CalPeterWu</strong> commented on 2021-06-25 20:47:40.000 UTC</summary>

Hi Temporal Team, any update on this issue? Thanks!

Reactions: üëç 2

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 20:08:39.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-java/issues/2097

</details>


---

<a id="357"></a>

### #357: [Bug] Query page broken after upgrading to 1.6.3 server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/357 |
| **State** | CLOSED |
| **Author** | madhukkc (Madhusudanan K K C (makk)) |
| **Created** | 2021-02-18 10:28:14.000 UTC (4y 10m ago) |
| **Updated** | 2021-02-26 00:59:46.000 UTC |
| **Closed** | 2021-02-26 00:59:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

**Describe the bug**
When i go to query page i see blank  page with "no querires registered" message
but my workfow as Query methods

**To Reproduce**
Steps to reproduce the behavior:
1. use 1.6.3 server and 1.6.1/1.6,2/1.7.0 ui and use temporal hava sdk 1.0.5/1.0.5-snapshot
2. submit a qorklfow and go to query tab

**Expected behavior**
queries should be shown
**Actual behavior**
i see no queries registerd message
**Screenshots**



**Additional context**
The query names are pased by triggering an expception and  parsing exception log , refer [enhancment request](https://github.com/temporalio/sdk-java/issues/335) and [forum thread](https://community.temporal.io/t/io-temporal-internal-sync-syncworkflowcontext-query-uncategorized-exception-often-seen-in-server-log/1454?u=madhu)

between 1.6.1 and 1.6.3 the excption logging has possibly changed and hence the queries are appearing blank

Previously ,i used to see this exception in server side when i go to query tab

"level":"error","ts":"2021-02-06T14:01:06.842Z","msg":"Uncategorized error","service":"history","wf-namespace-id":"493f72d9-4de5-4e0f-b113-3e37449990fa","wf-id":"feb20210607-worflow","error":"java.lang.IllegalArgumentException: Unknown query type: __cadence_web_list, knownTypes=**[getData, getState]**

Now i see

"level":"error","ts":"2021-02-18T07:42:13.879Z","msg":"query directly though matching on sticky failed, will not attempt query on non-sticky","service":"history","shard-id":4,"address":"x.y.0.z:7234","shard-item":"0xc0008db680","component":"history-engine","wf-namespace":"dev-cloud","wf-id":"feb20210607-worflow","wf-run-id":"f6786da3-086a-4945-b5c2-f76934731516","wf-query-type":"__cadence_web_list","error":"java.lang.IllegalStateException: Unknown query type: __cadence_web_list\n\tat io.temporal.internal.sync.QueryDispatcher.handleQuery(QueryDispatcher.java:78)\n\tat io.temporal.internal.sync.SyncWorkflowContext.handleQuery(SyncWorkflowContext.java:181)\n\tat io.temporal.internal.sync.WorkflowExecuteRunnable.handleQuery(WorkflowExecuteRunnable.java:76)\n\tat io.temporal.internal.sync.SyncWorkflow.query(SyncWorkflow.java:175)\n\tat io.temporal.internal.replay.ReplayWorkflowExecutor.query(ReplayWorkflowExecutor.java:137)\n\tat io.temporal.internal.replay.ReplayWorkflow

Possibly thats why my query page is broken this is happening in 1.6.3


refer https://github.com/temporalio/web/issues/258


#### Comments (4)

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-22 20:53:18.000 UTC</summary>

Likely was caused by changes in `sdk-java`. Working with the sdk team to pinpoint to the issue and address it

</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-22 20:57:42.000 UTC</summary>

As per discussion with SDK team, moving this to `sdk-java` and assigning to @vkoby 

</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-22 21:17:26.000 UTC</summary>

@vkoby `sdk-java` used to return an error message that would contain registered queries. For example `sdk-go` may return the following error message `'3 INVALID_ARGUMENT: unknown queryType __cadence_web_list. KnownQueryTypes=[__stack_trace __open_sessions state]'`

`sdk-java` was returning a similar error. Please see an example in this old issue https://github.com/temporalio/web/issues/54 .
Please find what caused the change and make it return the old error message again

</details>

<details>
<summary><strong>feedmeapples</strong> commented on 2021-02-22 21:35:00.000 UTC</summary>

p.s this is also tracked to be added into the frontend API

</details>


---

<a id="332"></a>

### #332: Test with mock activity doesn't work with Mockito version 2

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/332 |
| **State** | CLOSED |
| **Author** | frank-le (Frank) |
| **Created** | 2021-02-04 06:21:08.000 UTC (4y 11m ago) |
| **Updated** | 2023-04-19 20:07:25.000 UTC |
| **Closed** | 2023-04-19 20:07:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior
Error: `This annotation can be used only on the interface method it implements.`

## Steps to Reproduce the Problem
Change Temporal-samples with the followings and just execute any test, e.g., HelloActivityTest
```
    testImplementation group: 'org.mockito', name: 'mockito-core', version: '2.28.2'
    testImplementation group: 'org.powermock', name: 'powermock-api-mockito2', version: '2.0.5'
```

## Specifications

  - Version: 10.3
  - Platform: MacOS


#### Comments (4)

<details>
<summary><strong>GreyTeardrop</strong> commented on 2021-02-04 09:34:33.000 UTC</summary>

I've faced the same issue with Mockito 2.x/3.x. As of version 2.0.0, Mockito has switched to annotating mock with all the annotations it can find on the source class or interface, which, in turn, makes Temporal's `POJOActivityImplMetadata` unhappy.

The workaround I've found is to create all activity mocks with a flag to disable annotation copying

```java
Mockito.mock(ActivityInterface.class, Mockito.withSettings().withoutAnnotations())
```

I wonder what would be the proper solution. Perhaps instead of making Temporal's SDK more lenient, upgrading examples repo to recent Mockito to display how `withoutAnnotations()` has to be used for all mocks would be enough?

**Update**: `withoutAnnotation()` was implemented in Mockito 2.11.2, https://github.com/mockito/mockito/issues/1206#issuecomment-336579095 has a workaround for older Mockito versions in case it's needed.

Reactions: üëç 1

</details>

<details>
<summary><strong>robzienert</strong> commented on 2021-02-04 18:33:30.000 UTC</summary>

This is also a problem with [mockk](https://mockk.io/), but I haven't taken the time to investigate yet.

</details>

<details>
<summary><strong>GreyTeardrop</strong> commented on 2021-02-05 00:09:00.000 UTC</summary>

I've opened up a [PR](https://github.com/temporalio/samples-java/pull/73) to the `samples-java` repository showing how Mockito 3 could be used to mock activities.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-19 20:07:25.000 UTC</summary>

Closing until more information is provided. Mockito 2 and 3 are used both in our own samples/ tests and by our users to mock activities from what I know. Feel free to reopen with a reproduction.

</details>


---

<a id="317"></a>

### #317: Published artifacts do not include sources for the generated code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/317 |
| **State** | OPEN |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2021-01-20 21:24:21.000 UTC (4y 11m ago) |
| **Updated** | 2024-12-17 21:27:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Published artifacts should include sources and javadoc.


## Actual Behavior

Only compiled class artifacts are published.

## Steps to Reproduce the Problem

  1. Use java SDK as dependency in any project.

## Specifications

  - Version: 1.0.4

## Notes

I see that the Gradle project is using `withJavadocJar()` and `withSourcesJar()`, and a sufficient Gradle version for these to work, however no sources or javadoc are included anyway. I was going to open a PR to do this the pre-6.x way, but wanted to verify with you folks first in case you see a more correct fix.

#### Comments (4)

<details>
<summary><strong>vitarb</strong> commented on 2021-01-20 22:01:04.000 UTC</summary>

Interesting, maven central has all those files:
https://repo1.maven.org/maven2/io/temporal/temporal-sdk/1.0.4/

Can you double check if your IDE is downloading sources/javadocs?
You may need to explicitly press the button to fetch them.

</details>

<details>
<summary><strong>GreyTeardrop</strong> commented on 2021-01-20 22:11:03.000 UTC</summary>

I was able to partially reproduce this issue. All the "proper" source code is present, however, the generated sources seem to be missing from the `temporal-serviceclient`:
```
~/Downloads/temporal-serviceclient-1.0.4-sources
‚ùØ ls -lR .
total 0
drwxr-xr-x@ 3 mrybak  staff  96 Dec 23 21:35 META-INF
drwxr-xr-x@ 3 mrybak  staff  96 Dec 23 19:55 io

./META-INF:
total 8
-rw-r--r--@ 1 mrybak  staff  25 Dec 23 21:35 MANIFEST.MF

./io:
total 0
drwxr-xr-x@ 3 mrybak  staff  96 Dec 23 19:55 temporal

./io/temporal:
total 0
drwxr-xr-x@ 12 mrybak  staff  384 Dec 23 19:55 serviceclient

./io/temporal/serviceclient:
total 128
-rw-r--r--@ 1 mrybak  staff   2519 Dec 23 19:55 GrpcDeadlineInterceptor.java
-rw-r--r--@ 1 mrybak  staff   4900 Dec 23 19:55 GrpcMetricsInterceptor.java
-rw-r--r--@ 1 mrybak  staff   3695 Dec 23 19:55 GrpcTracingInterceptor.java
-rw-r--r--@ 1 mrybak  staff   1495 Dec 23 19:55 LongPollUtil.java
-rw-r--r--@ 1 mrybak  staff   2830 Dec 23 19:55 MetricsTag.java
-rw-r--r--@ 1 mrybak  staff   1415 Dec 23 19:55 MetricsType.java
-rw-r--r--@ 1 mrybak  staff   2404 Dec 23 19:55 Version.java
-rw-r--r--@ 1 mrybak  staff   2390 Dec 23 19:55 WorkflowServiceStubs.java
-rw-r--r--@ 1 mrybak  staff  10979 Dec 23 19:55 WorkflowServiceStubsImpl.java
-rw-r--r--@ 1 mrybak  staff  12903 Dec 23 19:55 WorkflowServiceStubsOptions.java
```

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-20 22:35:30.000 UTC</summary>

You are right, I don't see sources for the generated code. Let me update task description to be more precise.

Reactions: üëç 1

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-20 23:30:00.000 UTC</summary>

There seem to be a couple gradle plugin issues here, I was able to make generated source publishing work by adding `sourceSets.main.java.srcDirs = ["$buildDir/generated/main/java","src/main/java"]`, but it breaks license check and I couldn't exclude that directory in the license plugin.
I think the root cause is a bug in the license checker reported [here](https://github.com/hierynomus/license-gradle-plugin/issues/145) and [here](https://github.com/hierynomus/license-gradle-plugin/issues/57). 
On the other hand we have a similar configuration as metioned [here](https://github.com/tbroyer/gradle-apt-plugin/issues/78#issuecomment-370219011) but for some reason doesn't work (another gradle bug?...).

To summarize our options are:
1. Figure out why license plugin exclude is not working. In which case we can add generated sources to the main sourceSet and they will be published automatically.
2. Debug sourceJar task and find out why it doesn't publish additional files that we've specified.

</details>


---

<a id="315"></a>

### #315: inconsistent tag names between server and sdk

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/315 |
| **State** | CLOSED |
| **Author** | kkcmadhu |
| **Created** | 2021-01-15 14:20:30.000 UTC (4y 12m ago) |
| **Updated** | 2021-01-22 06:44:03.000 UTC |
| **Closed** | 2021-01-21 20:16:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
Expect to see sdk metrics in the [sdk dahboard ](https://github.com/temporalio/dashboards/blob/master/dashboards/sdk.json)

## Actual Behavior
The sdk metrics do not get populated in this dashboard

## Steps to Reproduce the Problem

  1. enable metrics in client
  2. setup graphana/promethus
  3. import [sdk dashboard](https://github.com/temporalio/dashboards/blob/master/dashboards/sdk.json) in graphana

## Additional Info
The graphana dashboard use names like namespace, workerType etc which seems to  be in consistent with tags originated from server (frontend, matcher etc)  .i.e  https://github.com/temporalio/temporal/blob/master/common/metrics/tags.go (the canary tests which i presumes runs from the worker and the temporal namespace which is only in server shows info here)

But however real namespaces do not endup showing data here because the tag names mismatch  (see [java sdk ](https://github.com/temporalio/sdk-java/blob/2bef04f638eeedbde9766bc00f81cae414b58579/temporal-sdk/src/main/java/io/temporal/internal/logging/LoggerTag.java#L22)and  [go sdk ](https://github.com/temporalio/sdk-go/blob/master/internal/internal_logging_tags.go) tags

these do not appear in grafana as the tag names are little different e.g Namespace in sdk and namespace in server, WorkflowType in server etc.

Now should the namespace tag not be same every where.

Now what iam confused is is this discrepancy between server and sdk code , or is it bug in the graphana dashoard json file!



#### Comments (4)

<details>
<summary><strong>madhukkc</strong> commented on 2021-01-19 04:23:36.000 UTC</summary>

i think the metric tags in java sdk are [here](https://github.com/temporalio/sdk-java/blob/master/temporal-serviceclient/src/main/java/io/temporal/serviceclient/MetricsTag.java)

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-19 18:51:03.000 UTC</summary>

Madhu, thanks for reporting, we are aware of this issue and will address it soon.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-21 20:16:28.000 UTC</summary>

Following changes should address this issue:
https://github.com/temporalio/sdk-java/pull/318
https://github.com/temporalio/sdk-go/pull/345
https://github.com/temporalio/dashboards/pull/8

</details>

<details>
<summary><strong>kkcmadhu</strong> commented on 2021-01-22 06:44:03.000 UTC</summary>

hi is there a new sdk release for this or should i take latest of 1.04 sdk?

</details>


---

<a id="308"></a>

### #308: ActivityCompletionClient's completeExceptionally doesn't work with ApplicationFailure 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/308 |
| **State** | CLOSED |
| **Author** | rubyhfu |
| **Created** | 2021-01-14 03:44:01.000 UTC (4y 12m ago) |
| **Updated** | 2021-01-15 19:02:30.000 UTC |
| **Closed** | 2021-01-15 19:02:30.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
Expected no error logs using completionClient.completeExceptionally with any exception but it throws errors when used with ApplicationFailure.newNonRetryableFailure and ApplicationFailure.newFailure.

## Actual Behavior
[reactor-http-nio-1] ERROR reactor.core.publisher.Operators - Operator called default onErrorDropped
java.lang.IllegalStateException: converter not set
	at io.temporal.common.converter.EncodedValues.toPayloads(EncodedValues.java:48) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.failure.FailureConverter.exceptionToFailureNoUnwrapping(FailureConverter.java:210) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.failure.FailureConverter.exceptionToFailure(FailureConverter.java:184) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.external.ManualActivityCompletionClientImpl.fail(ManualActivityCompletionClientImpl.java:163) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.sync.ActivityCompletionClientImpl.completeExceptionally(ActivityCompletionClientImpl.java:49) ~[temporal-sdk-1.0.0.jar:?]


## Steps to Reproduce the Problem

  1. Create a workflow with a simple activity, inject an ActivityCompletionClient into the activity
  2. Inside the activity's async process, add:
  completionClient.completeExceptionally(taskToken, ApplicationFailure.newNonRetryableFailure("xxx", "xxx", "xxx"));
  3. Invoke the workflow using TestWorkflowEnv, the above error logs should be printed


## Specifications

  - Version: temporal-sdk-1.0.0
  - Platform: macOS Big Sur


#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2021-01-14 05:04:19.000 UTC</summary>

I was able to reproduce the problem. Thanks a lot for reporting!

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-15 19:02:30.000 UTC</summary>

This issue should be addressed by #307 

</details>


---

<a id="256"></a>

### #256: Unexpected Heartbeat errors when activities are queued up

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/256 |
| **State** | CLOSED |
| **Author** | cmlenius (Cameron Lenius) |
| **Created** | 2020-11-16 17:26:09.000 UTC (5y 1m ago) |
| **Updated** | 2022-01-20 00:57:22.000 UTC |
| **Closed** | 2021-09-23 17:34:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

While evaluating temporal for our use cases, we ran into something that seemed like a bug. To isolate any issues that could be happening with our possibly buggy implementation, we reproduced the issue by modifying one of the Java SDK examples.

Our setup is simple:
1. We have a bunch of workflows being started in one process. The workflows get started much faster than they finish.
1. Each activity task gets completed in a different process.
1. Each process can only work on one activity task at a time.
1. We set a heartbeat timeout of 15s, and send heartbeats every 5s.
1. We run just one activity worker, so one activity at a time.

## Expected Behaviour

When the worker or workers pick up the activity, they run the activities to completion with no errors.

## Actual Behaviour

Sometimes, but at least once in our reproduction, the workers fail to heartbeat because the workflow was already completed. See the stack trace below.

In the Temporal web UI, their history shows multiple attempts at starting an ActivityTask with "activity timeout" failures.

It seems like something about the activity expired before any worker has had a chance to start it, hence the attempts going up. Our startToClose timeout is long enough to not be relevant here. We are setting `.setMaxConcurrentActivityExecutionSize(1)` and `.setActivityPollThreadCount(1)`. 

```
11:53:25.025 [Activity Executor taskQueue="MONEY_TRANSFER_TASK_QUEUE", namespace="default": 1] ERROR i.t.internal.worker.PollerOptions - uncaught exception
java.lang.RuntimeException: Failure processing activity task. WorkflowId=25c41288-f9a3-4587-9f42-a0df2d811c51, RunId=e2ecab8d-30b0-4060-b61e-a82eedeb4d16, ActivityType=Deposit, ActivityId=2345852d-742f-3007-8b4d-c4fc51486faa
        at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.wrapFailure(ActivityWorker.java:254)
        at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.wrapFailure(ActivityWorker.java:154)
        at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)
        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
        at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: io.grpc.StatusRuntimeException: NOT_FOUND: invalid activityID or activity already timed out or invoking workflow is completed
        at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
        at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
        at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.respondActivityTaskCompleted(WorkflowServiceGrpc.java:2746)
        at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.lambda$sendReply$0(ActivityWorker.java:278)
        at io.temporal.internal.common.GrpcRetryer.lambda$retry$0(GrpcRetryer.java:109)
        at io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:127)
        at io.temporal.internal.common.GrpcRetryer.retry(GrpcRetryer.java:106)
        at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.sendReply(ActivityWorker.java:272)
        at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:198)
        at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:154)
        at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
        ... 3 common frames omitted 
```


## Steps to Reproduce the Problem

  1. Clone/Download my fork https://github.com/cmlenius/money-transfer-project-template-java (has a single commit with the changes to reproduce the bug)
  1. Run `./gradlew startWorker`
  1. Run `./gradlew initiateTransfer` and wait

## Specifications

  - Version: 1.03
  - Platform: OSX - 10.14.6 


#### Comments (4)

<details>
<summary><strong>mfateev</strong> commented on 2020-11-17 17:05:47.000 UTC</summary>

What does the workflow history for the WorkflowId=25c41288-f9a3-4587-9f42-a0df2d811c51, RunId=e2ecab8d-30b0-4060-b61e-a82eedeb4d16 says about the Deposit activity? Or just post the whole history of this workflow here.

</details>

<details>
<summary><strong>cmlenius</strong> commented on 2020-11-17 17:35:02.000 UTC</summary>

Here is the whole history exported as JSON. I had to reproduce the error so the workflowID and RunID are different.

* WorkflowId=1f6be884-69c5-4336-8a73-dbae380331a3
* RunId=380f5dd3-afbe-43c9-9dbc-048887e35fea, 
* ActivityId=7efb95eb-c445-3929-a78f-97d95482588b

<details><summary>Workflow History</summary>
<pre>
[
  {
    "eventTime": "2020-11-17T17:26:13.000Z",
    "eventType": "WorkflowExecutionStarted",
    "eventId": "1",
    "details": {
      "workflowType": {
        "name": "MoneyTransferWorkflow"
      },
      "parentWorkflowNamespace": "",
      "parentWorkflowExecution": null,
      "parentInitiatedEventId": "0",
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "input": {
        "payloads": [
          "001-001",
          "002-002",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "workflowExecutionTimeout": {
        "duration": 315360000
      },
      "workflowRunTimeout": {
        "duration": 315360000
      },
      "workflowTaskTimeout": {
        "duration": 10
      },
      "continuedExecutionRunId": "",
      "initiator": "Unspecified",
      "continuedFailure": null,
      "lastCompletionResult": null,
      "originalExecutionRunId": "380f5dd3-afbe-43c9-9dbc-048887e35fea",
      "identity": "82797@Cameron-Lenius",
      "firstExecutionRunId": "380f5dd3-afbe-43c9-9dbc-048887e35fea",
      "retryPolicy": null,
      "attempt": 1,
      "workflowExecutionExpirationTime": "2030-11-15T17:26:13.000Z",
      "cronSchedule": "",
      "firstWorkflowTaskBackoff": {
        "duration": 0
      },
      "memo": null,
      "searchAttributes": null,
      "prevAutoResetPoints": null,
      "header": null,
      "eventId": "1",
      "eventType": "WorkflowExecutionStarted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:13 pm"
        },
        {
          "key": "eventId",
          "value": "1"
        },
        {
          "key": "workflowType.name",
          "value": "MoneyTransferWorkflow"
        },
        {
          "key": "parentWorkflowNamespace",
          "value": ""
        },
        {
          "key": "parentInitiatedEventId",
          "value": "0"
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "input",
          "value": [
            "001-001",
            "002-002",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "workflowExecutionTimeout",
          "value": "87600h"
        },
        {
          "key": "workflowRunTimeout",
          "value": "87600h"
        },
        {
          "key": "workflowTaskTimeout",
          "value": "10s"
        },
        {
          "key": "continuedExecutionRunId",
          "value": ""
        },
        {
          "key": "initiator",
          "value": "Unspecified"
        },
        {
          "key": "originalExecutionRunId",
          "value": "380f5dd3-afbe-43c9-9dbc-048887e35fea"
        },
        {
          "key": "identity",
          "value": "82797@Cameron-Lenius"
        },
        {
          "key": "firstExecutionRunId",
          "value": "380f5dd3-afbe-43c9-9dbc-048887e35fea"
        },
        {
          "key": "attempt",
          "value": 1
        },
        {
          "key": "workflowExecutionExpirationTime",
          "value": "2030-11-15T17:26:13.000Z"
        },
        {
          "key": "cronSchedule",
          "value": ""
        },
        {
          "key": "firstWorkflowTaskBackoff",
          "value": ""
        }
      ],
      "eventTime": "Nov 17th 12:26:13 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:13 pm",
    "timeElapsedDisplay": "Nov 17th 12:26:13 pm",
    "eventSummary": {
      "Close Timeout": "87600h",
      "identity": "82797@Cameron-Lenius",
      "input": {
        "payloads": [
          "001-001",
          "002-002",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "Workflow": "MoneyTransferWorkflow",
      "eventId": "1",
      "eventType": "WorkflowExecutionStarted",
      "kvps": [
        {
          "key": "Close Timeout",
          "value": "87600h"
        },
        {
          "key": "identity",
          "value": "82797@Cameron-Lenius"
        },
        {
          "key": "input",
          "value": [
            "001-001",
            "002-002",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "Workflow",
          "value": "MoneyTransferWorkflow"
        }
      ]
    },
    "eventFullDetails": {
      "workflowType": {
        "name": "MoneyTransferWorkflow"
      },
      "parentWorkflowNamespace": "",
      "parentWorkflowExecution": null,
      "parentInitiatedEventId": "0",
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "input": {
        "payloads": [
          "001-001",
          "002-002",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "workflowExecutionTimeout": {
        "duration": 315360000
      },
      "workflowRunTimeout": {
        "duration": 315360000
      },
      "workflowTaskTimeout": {
        "duration": 10
      },
      "continuedExecutionRunId": "",
      "initiator": "Unspecified",
      "continuedFailure": null,
      "lastCompletionResult": null,
      "originalExecutionRunId": "380f5dd3-afbe-43c9-9dbc-048887e35fea",
      "identity": "82797@Cameron-Lenius",
      "firstExecutionRunId": "380f5dd3-afbe-43c9-9dbc-048887e35fea",
      "retryPolicy": null,
      "attempt": 1,
      "workflowExecutionExpirationTime": "2030-11-15T17:26:13.000Z",
      "cronSchedule": "",
      "firstWorkflowTaskBackoff": {
        "duration": 0
      },
      "memo": null,
      "searchAttributes": null,
      "prevAutoResetPoints": null,
      "header": null,
      "eventId": "1",
      "eventType": "WorkflowExecutionStarted",
      "kvps": [
        {
          "key": "workflowType.name",
          "value": "MoneyTransferWorkflow"
        },
        {
          "key": "parentWorkflowNamespace",
          "value": ""
        },
        {
          "key": "parentInitiatedEventId",
          "value": "0"
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "input",
          "value": [
            "001-001",
            "002-002",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "workflowExecutionTimeout",
          "value": "87600h"
        },
        {
          "key": "workflowRunTimeout",
          "value": "87600h"
        },
        {
          "key": "workflowTaskTimeout",
          "value": "10s"
        },
        {
          "key": "continuedExecutionRunId",
          "value": ""
        },
        {
          "key": "initiator",
          "value": "Unspecified"
        },
        {
          "key": "originalExecutionRunId",
          "value": "380f5dd3-afbe-43c9-9dbc-048887e35fea"
        },
        {
          "key": "identity",
          "value": "82797@Cameron-Lenius"
        },
        {
          "key": "firstExecutionRunId",
          "value": "380f5dd3-afbe-43c9-9dbc-048887e35fea"
        },
        {
          "key": "attempt",
          "value": 1
        },
        {
          "key": "workflowExecutionExpirationTime",
          "value": "2030-11-15T17:26:13.000Z"
        },
        {
          "key": "cronSchedule",
          "value": ""
        },
        {
          "key": "firstWorkflowTaskBackoff",
          "value": ""
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:13.000Z",
    "eventType": "WorkflowTaskScheduled",
    "eventId": "2",
    "details": {
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "startToCloseTimeout": {
        "duration": 10
      },
      "attempt": 1,
      "eventId": "2",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:13 pm"
        },
        {
          "key": "eventId",
          "value": "2"
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10s"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ],
      "eventTime": "Nov 17th 12:26:13 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:13 pm",
    "timeElapsedDisplay": "",
    "eventSummary": {
      "Taskqueue": "MONEY_TRANSFER_TASK_QUEUE",
      "Timeout": "10s",
      "eventId": "2",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "Taskqueue",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "Timeout",
          "value": "10s"
        }
      ]
    },
    "eventFullDetails": {
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "startToCloseTimeout": {
        "duration": 10
      },
      "attempt": 1,
      "eventId": "2",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10s"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:13.000Z",
    "eventType": "WorkflowTaskStarted",
    "eventId": "3",
    "details": {
      "scheduledEventId": "2",
      "identity": "82785@Cameron-Lenius",
      "requestId": "21d36a1d-5a2b-4eb4-a883-7bba422127d7",
      "eventId": "3",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:13 pm"
        },
        {
          "key": "eventId",
          "value": "3"
        },
        {
          "key": "scheduledEventId",
          "value": "2"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "21d36a1d-5a2b-4eb4-a883-7bba422127d7"
        }
      ],
      "eventTime": "Nov 17th 12:26:13 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:13 pm",
    "timeElapsedDisplay": "",
    "eventSummary": {
      "requestId": "21d36a1d-5a2b-4eb4-a883-7bba422127d7",
      "eventId": "3",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "requestId",
          "value": "21d36a1d-5a2b-4eb4-a883-7bba422127d7"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "2",
      "identity": "82785@Cameron-Lenius",
      "requestId": "21d36a1d-5a2b-4eb4-a883-7bba422127d7",
      "eventId": "3",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "2"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "21d36a1d-5a2b-4eb4-a883-7bba422127d7"
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:14.000Z",
    "eventType": "WorkflowTaskCompleted",
    "eventId": "4",
    "details": {
      "scheduledEventId": "2",
      "startedEventId": "3",
      "identity": "82785@Cameron-Lenius",
      "binaryChecksum": "",
      "eventId": "4",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:14 pm"
        },
        {
          "key": "eventId",
          "value": "4"
        },
        {
          "key": "scheduledEventId",
          "value": "2"
        },
        {
          "key": "startedEventId",
          "value": "3"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "binaryChecksum",
          "value": ""
        }
      ],
      "eventTime": "Nov 17th 12:26:14 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:14 pm",
    "timeElapsedDisplay": "1s (+1s)",
    "eventSummary": {
      "identity": "82785@Cameron-Lenius",
      "eventId": "4",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "2",
      "startedEventId": "3",
      "identity": "82785@Cameron-Lenius",
      "binaryChecksum": "",
      "eventId": "4",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "2"
        },
        {
          "key": "startedEventId",
          "value": "3"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "binaryChecksum",
          "value": ""
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:14.000Z",
    "eventType": "ActivityTaskScheduled",
    "eventId": "5",
    "details": {
      "activityId": "7efb95eb-c445-3929-a78f-97d95482588b",
      "activityType": {
        "name": "Withdraw"
      },
      "namespace": "",
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "header": null,
      "input": {
        "payloads": [
          "001-001",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "scheduleToCloseTimeout": {
        "duration": 315360000
      },
      "scheduleToStartTimeout": {
        "duration": 315360000
      },
      "startToCloseTimeout": {
        "duration": 600
      },
      "heartbeatTimeout": {
        "duration": 15
      },
      "workflowTaskCompletedEventId": "4",
      "retryPolicy": {
        "nonRetryableErrorTypes": [],
        "initialInterval": {
          "duration": 1
        },
        "backoffCoefficient": 2,
        "maximumInterval": {
          "duration": 100
        },
        "maximumAttempts": 500
      },
      "eventId": "5",
      "eventType": "ActivityTaskScheduled",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:14 pm"
        },
        {
          "key": "eventId",
          "value": "5"
        },
        {
          "key": "activityId",
          "value": "7efb95eb-c445-3929-a78f-97d95482588b"
        },
        {
          "key": "activityType.name",
          "value": "Withdraw"
        },
        {
          "key": "namespace",
          "value": ""
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "input",
          "value": [
            "001-001",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "scheduleToCloseTimeout",
          "value": "87600h"
        },
        {
          "key": "scheduleToStartTimeout",
          "value": "87600h"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10m"
        },
        {
          "key": "heartbeatTimeout",
          "value": "15s"
        },
        {
          "key": "workflowTaskCompletedEventId",
          "value": "4"
        },
        {
          "key": "retryPolicy.initialInterval",
          "value": "1s"
        },
        {
          "key": "retryPolicy.backoffCoefficient",
          "value": 2
        },
        {
          "key": "retryPolicy.maximumInterval",
          "value": "1m 40s"
        },
        {
          "key": "retryPolicy.maximumAttempts",
          "value": 500
        }
      ],
      "eventTime": "Nov 17th 12:26:14 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:14 pm",
    "timeElapsedDisplay": "1s",
    "eventSummary": {
      "Close Timeout": "87600h",
      "Id": "7efb95eb-c445-3929-a78f-97d95482588b",
      "input": {
        "payloads": [
          "001-001",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "Name": "Withdraw",
      "eventId": "5",
      "eventType": "ActivityTaskScheduled",
      "kvps": [
        {
          "key": "Close Timeout",
          "value": "87600h"
        },
        {
          "key": "Id",
          "value": "7efb95eb-c445-3929-a78f-97d95482588b"
        },
        {
          "key": "input",
          "value": [
            "001-001",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "Name",
          "value": "Withdraw"
        }
      ]
    },
    "eventFullDetails": {
      "activityId": "7efb95eb-c445-3929-a78f-97d95482588b",
      "activityType": {
        "name": "Withdraw"
      },
      "namespace": "",
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "header": null,
      "input": {
        "payloads": [
          "001-001",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "scheduleToCloseTimeout": {
        "duration": 315360000
      },
      "scheduleToStartTimeout": {
        "duration": 315360000
      },
      "startToCloseTimeout": {
        "duration": 600
      },
      "heartbeatTimeout": {
        "duration": 15
      },
      "workflowTaskCompletedEventId": "4",
      "retryPolicy": {
        "nonRetryableErrorTypes": [],
        "initialInterval": {
          "duration": 1
        },
        "backoffCoefficient": 2,
        "maximumInterval": {
          "duration": 100
        },
        "maximumAttempts": 500
      },
      "eventId": "5",
      "eventType": "ActivityTaskScheduled",
      "kvps": [
        {
          "key": "activityId",
          "value": "7efb95eb-c445-3929-a78f-97d95482588b"
        },
        {
          "key": "activityType.name",
          "value": "Withdraw"
        },
        {
          "key": "namespace",
          "value": ""
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "input",
          "value": [
            "001-001",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "scheduleToCloseTimeout",
          "value": "87600h"
        },
        {
          "key": "scheduleToStartTimeout",
          "value": "87600h"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10m"
        },
        {
          "key": "heartbeatTimeout",
          "value": "15s"
        },
        {
          "key": "workflowTaskCompletedEventId",
          "value": "4"
        },
        {
          "key": "retryPolicy.initialInterval",
          "value": "1s"
        },
        {
          "key": "retryPolicy.backoffCoefficient",
          "value": 2
        },
        {
          "key": "retryPolicy.maximumInterval",
          "value": "1m 40s"
        },
        {
          "key": "retryPolicy.maximumAttempts",
          "value": 500
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:30.000Z",
    "eventType": "ActivityTaskStarted",
    "eventId": "6",
    "details": {
      "scheduledEventId": "5",
      "identity": "82785@Cameron-Lenius",
      "requestId": "cdc20ac8-8db3-4b82-99b5-0dd0a07a9c67",
      "attempt": 2,
      "lastFailure": {
        "message": "activity timeout",
        "source": "Server",
        "stackTrace": "",
        "cause": null,
        "timeoutFailureInfo": {
          "timeoutType": "Heartbeat",
          "lastHeartbeatDetails": null
        },
        "failureInfo": "timeoutFailureInfo"
      },
      "eventId": "6",
      "eventType": "ActivityTaskStarted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:30 pm"
        },
        {
          "key": "eventId",
          "value": "6"
        },
        {
          "key": "scheduledEventId",
          "value": "5"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "cdc20ac8-8db3-4b82-99b5-0dd0a07a9c67"
        },
        {
          "key": "attempt",
          "value": 2
        },
        {
          "key": "lastFailure",
          "value": "activity timeout"
        }
      ],
      "eventTime": "Nov 17th 12:26:30 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:30 pm",
    "timeElapsedDisplay": "17s (+16s)",
    "eventSummary": {
      "attempt": 2,
      "identity": "82785@Cameron-Lenius",
      "requestId": "cdc20ac8-8db3-4b82-99b5-0dd0a07a9c67",
      "eventId": "6",
      "eventType": "ActivityTaskStarted",
      "kvps": [
        {
          "key": "attempt",
          "value": 2
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "cdc20ac8-8db3-4b82-99b5-0dd0a07a9c67"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "5",
      "identity": "82785@Cameron-Lenius",
      "requestId": "cdc20ac8-8db3-4b82-99b5-0dd0a07a9c67",
      "attempt": 2,
      "lastFailure": {
        "message": "activity timeout",
        "source": "Server",
        "stackTrace": "",
        "cause": null,
        "timeoutFailureInfo": {
          "timeoutType": "Heartbeat",
          "lastHeartbeatDetails": null
        },
        "failureInfo": "timeoutFailureInfo"
      },
      "eventId": "6",
      "eventType": "ActivityTaskStarted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "5"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "cdc20ac8-8db3-4b82-99b5-0dd0a07a9c67"
        },
        {
          "key": "attempt",
          "value": 2
        },
        {
          "key": "lastFailure",
          "value": "activity timeout"
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "ActivityTaskCompleted",
    "eventId": "7",
    "details": {
      "result": null,
      "scheduledEventId": "5",
      "startedEventId": "6",
      "identity": "82785@Cameron-Lenius",
      "eventId": "7",
      "eventType": "ActivityTaskCompleted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "7"
        },
        {
          "key": "scheduledEventId",
          "value": "5"
        },
        {
          "key": "startedEventId",
          "value": "6"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s (+24s)",
    "eventSummary": {
      "result": null,
      "eventId": "7",
      "eventType": "ActivityTaskCompleted",
      "kvps": []
    },
    "eventFullDetails": {
      "result": null,
      "scheduledEventId": "5",
      "startedEventId": "6",
      "identity": "82785@Cameron-Lenius",
      "eventId": "7",
      "eventType": "ActivityTaskCompleted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "5"
        },
        {
          "key": "startedEventId",
          "value": "6"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "WorkflowTaskScheduled",
    "eventId": "8",
    "details": {
      "taskQueue": {
        "name": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
        "kind": "Sticky"
      },
      "startToCloseTimeout": {
        "duration": 10
      },
      "attempt": 1,
      "eventId": "8",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "8"
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
            }
          },
          "value": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "taskQueue.kind",
          "value": "Sticky"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10s"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "Taskqueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
      "Timeout": "10s",
      "eventId": "8",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "Taskqueue",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
            }
          },
          "value": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "Timeout",
          "value": "10s"
        }
      ]
    },
    "eventFullDetails": {
      "taskQueue": {
        "name": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
        "kind": "Sticky"
      },
      "startToCloseTimeout": {
        "duration": 10
      },
      "attempt": 1,
      "eventId": "8",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
            }
          },
          "value": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "taskQueue.kind",
          "value": "Sticky"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10s"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "WorkflowTaskStarted",
    "eventId": "9",
    "details": {
      "scheduledEventId": "8",
      "identity": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
      "requestId": "1c1b24a0-5aed-44bf-9043-07867e39864b",
      "eventId": "9",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "9"
        },
        {
          "key": "scheduledEventId",
          "value": "8"
        },
        {
          "key": "identity",
          "value": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "requestId",
          "value": "1c1b24a0-5aed-44bf-9043-07867e39864b"
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "requestId": "1c1b24a0-5aed-44bf-9043-07867e39864b",
      "eventId": "9",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "requestId",
          "value": "1c1b24a0-5aed-44bf-9043-07867e39864b"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "8",
      "identity": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
      "requestId": "1c1b24a0-5aed-44bf-9043-07867e39864b",
      "eventId": "9",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "8"
        },
        {
          "key": "identity",
          "value": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "requestId",
          "value": "1c1b24a0-5aed-44bf-9043-07867e39864b"
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "WorkflowTaskCompleted",
    "eventId": "10",
    "details": {
      "scheduledEventId": "8",
      "startedEventId": "9",
      "identity": "82785@Cameron-Lenius",
      "binaryChecksum": "",
      "eventId": "10",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "10"
        },
        {
          "key": "scheduledEventId",
          "value": "8"
        },
        {
          "key": "startedEventId",
          "value": "9"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "binaryChecksum",
          "value": ""
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "identity": "82785@Cameron-Lenius",
      "eventId": "10",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "8",
      "startedEventId": "9",
      "identity": "82785@Cameron-Lenius",
      "binaryChecksum": "",
      "eventId": "10",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "8"
        },
        {
          "key": "startedEventId",
          "value": "9"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "binaryChecksum",
          "value": ""
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "ActivityTaskScheduled",
    "eventId": "11",
    "details": {
      "activityId": "44ac5f09-da56-30f6-bdf1-6c1ddc158d1d",
      "activityType": {
        "name": "Deposit"
      },
      "namespace": "",
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "header": null,
      "input": {
        "payloads": [
          "002-002",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "scheduleToCloseTimeout": {
        "duration": 315360000
      },
      "scheduleToStartTimeout": {
        "duration": 315360000
      },
      "startToCloseTimeout": {
        "duration": 600
      },
      "heartbeatTimeout": {
        "duration": 15
      },
      "workflowTaskCompletedEventId": "10",
      "retryPolicy": {
        "nonRetryableErrorTypes": [],
        "initialInterval": {
          "duration": 1
        },
        "backoffCoefficient": 2,
        "maximumInterval": {
          "duration": 100
        },
        "maximumAttempts": 500
      },
      "eventId": "11",
      "eventType": "ActivityTaskScheduled",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "11"
        },
        {
          "key": "activityId",
          "value": "44ac5f09-da56-30f6-bdf1-6c1ddc158d1d"
        },
        {
          "key": "activityType.name",
          "value": "Deposit"
        },
        {
          "key": "namespace",
          "value": ""
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "input",
          "value": [
            "002-002",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "scheduleToCloseTimeout",
          "value": "87600h"
        },
        {
          "key": "scheduleToStartTimeout",
          "value": "87600h"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10m"
        },
        {
          "key": "heartbeatTimeout",
          "value": "15s"
        },
        {
          "key": "workflowTaskCompletedEventId",
          "value": "10"
        },
        {
          "key": "retryPolicy.initialInterval",
          "value": "1s"
        },
        {
          "key": "retryPolicy.backoffCoefficient",
          "value": 2
        },
        {
          "key": "retryPolicy.maximumInterval",
          "value": "1m 40s"
        },
        {
          "key": "retryPolicy.maximumAttempts",
          "value": 500
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "Close Timeout": "87600h",
      "Id": "44ac5f09-da56-30f6-bdf1-6c1ddc158d1d",
      "input": {
        "payloads": [
          "002-002",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "Name": "Deposit",
      "eventId": "11",
      "eventType": "ActivityTaskScheduled",
      "kvps": [
        {
          "key": "Close Timeout",
          "value": "87600h"
        },
        {
          "key": "Id",
          "value": "44ac5f09-da56-30f6-bdf1-6c1ddc158d1d"
        },
        {
          "key": "input",
          "value": [
            "002-002",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "Name",
          "value": "Deposit"
        }
      ]
    },
    "eventFullDetails": {
      "activityId": "44ac5f09-da56-30f6-bdf1-6c1ddc158d1d",
      "activityType": {
        "name": "Deposit"
      },
      "namespace": "",
      "taskQueue": {
        "name": "MONEY_TRANSFER_TASK_QUEUE",
        "kind": "Normal"
      },
      "header": null,
      "input": {
        "payloads": [
          "002-002",
          "532ee256-d095-4e40-b53e-c5e9e972c8a5",
          "18.74"
        ]
      },
      "scheduleToCloseTimeout": {
        "duration": 315360000
      },
      "scheduleToStartTimeout": {
        "duration": 315360000
      },
      "startToCloseTimeout": {
        "duration": 600
      },
      "heartbeatTimeout": {
        "duration": 15
      },
      "workflowTaskCompletedEventId": "10",
      "retryPolicy": {
        "nonRetryableErrorTypes": [],
        "initialInterval": {
          "duration": 1
        },
        "backoffCoefficient": 2,
        "maximumInterval": {
          "duration": 100
        },
        "maximumAttempts": 500
      },
      "eventId": "11",
      "eventType": "ActivityTaskScheduled",
      "kvps": [
        {
          "key": "activityId",
          "value": "44ac5f09-da56-30f6-bdf1-6c1ddc158d1d"
        },
        {
          "key": "activityType.name",
          "value": "Deposit"
        },
        {
          "key": "namespace",
          "value": ""
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "MONEY_TRANSFER_TASK_QUEUE"
            }
          },
          "value": "MONEY_TRANSFER_TASK_QUEUE"
        },
        {
          "key": "taskQueue.kind",
          "value": "Normal"
        },
        {
          "key": "input",
          "value": [
            "002-002",
            "532ee256-d095-4e40-b53e-c5e9e972c8a5",
            "18.74"
          ]
        },
        {
          "key": "scheduleToCloseTimeout",
          "value": "87600h"
        },
        {
          "key": "scheduleToStartTimeout",
          "value": "87600h"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10m"
        },
        {
          "key": "heartbeatTimeout",
          "value": "15s"
        },
        {
          "key": "workflowTaskCompletedEventId",
          "value": "10"
        },
        {
          "key": "retryPolicy.initialInterval",
          "value": "1s"
        },
        {
          "key": "retryPolicy.backoffCoefficient",
          "value": 2
        },
        {
          "key": "retryPolicy.maximumInterval",
          "value": "1m 40s"
        },
        {
          "key": "retryPolicy.maximumAttempts",
          "value": 500
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "ActivityTaskStarted",
    "eventId": "12",
    "details": {
      "scheduledEventId": "11",
      "identity": "82785@Cameron-Lenius",
      "requestId": "2b83adcb-8ae3-4ae4-b3c8-5cf1169530c3",
      "attempt": 1,
      "lastFailure": null,
      "eventId": "12",
      "eventType": "ActivityTaskStarted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "12"
        },
        {
          "key": "scheduledEventId",
          "value": "11"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "2b83adcb-8ae3-4ae4-b3c8-5cf1169530c3"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "attempt": 1,
      "identity": "82785@Cameron-Lenius",
      "requestId": "2b83adcb-8ae3-4ae4-b3c8-5cf1169530c3",
      "eventId": "12",
      "eventType": "ActivityTaskStarted",
      "kvps": [
        {
          "key": "attempt",
          "value": 1
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "2b83adcb-8ae3-4ae4-b3c8-5cf1169530c3"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "11",
      "identity": "82785@Cameron-Lenius",
      "requestId": "2b83adcb-8ae3-4ae4-b3c8-5cf1169530c3",
      "attempt": 1,
      "lastFailure": null,
      "eventId": "12",
      "eventType": "ActivityTaskStarted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "11"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "requestId",
          "value": "2b83adcb-8ae3-4ae4-b3c8-5cf1169530c3"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "ActivityTaskCompleted",
    "eventId": "13",
    "details": {
      "result": null,
      "scheduledEventId": "11",
      "startedEventId": "12",
      "identity": "82785@Cameron-Lenius",
      "eventId": "13",
      "eventType": "ActivityTaskCompleted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "13"
        },
        {
          "key": "scheduledEventId",
          "value": "11"
        },
        {
          "key": "startedEventId",
          "value": "12"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "result": null,
      "eventId": "13",
      "eventType": "ActivityTaskCompleted",
      "kvps": []
    },
    "eventFullDetails": {
      "result": null,
      "scheduledEventId": "11",
      "startedEventId": "12",
      "identity": "82785@Cameron-Lenius",
      "eventId": "13",
      "eventType": "ActivityTaskCompleted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "11"
        },
        {
          "key": "startedEventId",
          "value": "12"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "WorkflowTaskScheduled",
    "eventId": "14",
    "details": {
      "taskQueue": {
        "name": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
        "kind": "Sticky"
      },
      "startToCloseTimeout": {
        "duration": 10
      },
      "attempt": 1,
      "eventId": "14",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "14"
        },
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
            }
          },
          "value": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "taskQueue.kind",
          "value": "Sticky"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10s"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "Taskqueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
      "Timeout": "10s",
      "eventId": "14",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "Taskqueue",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
            }
          },
          "value": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "Timeout",
          "value": "10s"
        }
      ]
    },
    "eventFullDetails": {
      "taskQueue": {
        "name": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
        "kind": "Sticky"
      },
      "startToCloseTimeout": {
        "duration": 10
      },
      "attempt": 1,
      "eventId": "14",
      "eventType": "WorkflowTaskScheduled",
      "kvps": [
        {
          "key": "taskQueue.name",
          "routeLink": {
            "name": "task-queue",
            "params": {
              "taskQueue": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
            }
          },
          "value": "82785@Cameron-Lenius:b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "taskQueue.kind",
          "value": "Sticky"
        },
        {
          "key": "startToCloseTimeout",
          "value": "10s"
        },
        {
          "key": "attempt",
          "value": 1
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "WorkflowTaskStarted",
    "eventId": "15",
    "details": {
      "scheduledEventId": "14",
      "identity": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
      "requestId": "c3ee6e90-1bac-4798-896a-7b5038e3a1c8",
      "eventId": "15",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "15"
        },
        {
          "key": "scheduledEventId",
          "value": "14"
        },
        {
          "key": "identity",
          "value": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "requestId",
          "value": "c3ee6e90-1bac-4798-896a-7b5038e3a1c8"
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "requestId": "c3ee6e90-1bac-4798-896a-7b5038e3a1c8",
      "eventId": "15",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "requestId",
          "value": "c3ee6e90-1bac-4798-896a-7b5038e3a1c8"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "14",
      "identity": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b",
      "requestId": "c3ee6e90-1bac-4798-896a-7b5038e3a1c8",
      "eventId": "15",
      "eventType": "WorkflowTaskStarted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "14"
        },
        {
          "key": "identity",
          "value": "b3a64b03-a93b-4c0c-a2f8-9b49ef931f8b"
        },
        {
          "key": "requestId",
          "value": "c3ee6e90-1bac-4798-896a-7b5038e3a1c8"
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "WorkflowTaskCompleted",
    "eventId": "16",
    "details": {
      "scheduledEventId": "14",
      "startedEventId": "15",
      "identity": "82785@Cameron-Lenius",
      "binaryChecksum": "",
      "eventId": "16",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "16"
        },
        {
          "key": "scheduledEventId",
          "value": "14"
        },
        {
          "key": "startedEventId",
          "value": "15"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "binaryChecksum",
          "value": ""
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "identity": "82785@Cameron-Lenius",
      "eventId": "16",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        }
      ]
    },
    "eventFullDetails": {
      "scheduledEventId": "14",
      "startedEventId": "15",
      "identity": "82785@Cameron-Lenius",
      "binaryChecksum": "",
      "eventId": "16",
      "eventType": "WorkflowTaskCompleted",
      "kvps": [
        {
          "key": "scheduledEventId",
          "value": "14"
        },
        {
          "key": "startedEventId",
          "value": "15"
        },
        {
          "key": "identity",
          "value": "82785@Cameron-Lenius"
        },
        {
          "key": "binaryChecksum",
          "value": ""
        }
      ]
    }
  },
  {
    "eventTime": "2020-11-17T17:26:54.000Z",
    "eventType": "WorkflowExecutionCompleted",
    "eventId": "17",
    "details": {
      "result": null,
      "workflowTaskCompletedEventId": "16",
      "eventId": "17",
      "eventType": "WorkflowExecutionCompleted",
      "kvps": [
        {
          "key": "eventTime",
          "value": "Nov 17th 12:26:54 pm"
        },
        {
          "key": "eventId",
          "value": "17"
        },
        {
          "key": "workflowTaskCompletedEventId",
          "value": "16"
        }
      ],
      "eventTime": "Nov 17th 12:26:54 pm"
    },
    "eventTimeDisplay": "Nov 17th 12:26:54 pm",
    "timeElapsedDisplay": "41s",
    "eventSummary": {
      "result": null,
      "workflowTaskCompletedEventId": "16",
      "eventId": "17",
      "eventType": "WorkflowExecutionCompleted",
      "kvps": [
        {
          "key": "workflowTaskCompletedEventId",
          "value": "16"
        }
      ]
    },
    "eventFullDetails": {
      "result": null,
      "workflowTaskCompletedEventId": "16",
      "eventId": "17",
      "eventType": "WorkflowExecutionCompleted",
      "kvps": [
        {
          "key": "workflowTaskCompletedEventId",
          "value": "16"
        }
      ]
    }
  }
]
</pre>
</details>

</details>

<details>
<summary><strong>Gibstick</strong> commented on 2020-11-20 16:40:50.000 UTC</summary>

We did some more digging (I work with @cmlenius) and we found this issue which seems to describe what we're seeing: https://github.com/uber/cadence/issues/3475, particularly this comment: https://github.com/uber/cadence/issues/3475#issuecomment-696930088

> Since activity is considered "started" when activity poller polls the task from Cadence, activities with shorter start to close timeouts will timeout in the buffer when task executor finishes working on long running activities. This issue amplifies especially when: ... Task execution thread pool is more likely to be blocked (e.g. due to max concurrency limit)

Cadence is tracking the issue in their java client now in https://github.com/uber/cadence-java-client/issues/554, but the original ticket describes the issue in good detail.

If Cadence provides a fix for their java client will Temporal be able to pick up the fix as well?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-20 00:52:14.000 UTC</summary>

Temporal activity pollers don't prefetch activities if there is no executors available. It was implemented in #286 

</details>


---

<a id="205"></a>

### #205: WARNING: An illegal reflective access operation has occurred

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/205 |
| **State** | CLOSED |
| **Author** | ilmn-aeolus |
| **Created** | 2020-09-11 21:45:45.000 UTC (5y 4m ago) |
| **Updated** | 2020-11-25 01:55:11.000 UTC |
| **Closed** | 2020-11-25 01:55:11.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 2 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
No warnings should be printed.

## Actual Behavior
When running a workflow I see:
```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by io.temporal.internal.common.CheckedExceptionWrapper (file:/C:/Users/user/.m2/repository/io/temporal/temporal-sdk/0.28.0/temporal-sdk-0.28.0.jar) to field java.lang.Throwable.cause
WARNING: Please consider reporting this to the maintainers of io.temporal.internal.common.CheckedExceptionWrapper
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
```

## Steps to Reproduce the Problem

I believe the exception that is getting wrapped comes from a mis-configuration of a workflow, but that is a separate issue from the warning above.

## Specifications

  - Version: 0.28.0
  - Platform: Windows


#### Comments (2)

<details>
<summary><strong>ilmn-aeolus</strong> commented on 2020-11-12 23:27:32.000 UTC</summary>

Present in 1.0.3
```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by io.temporal.internal.common.CheckedExceptionWrapper (file:/C:/Users/gbean/.m2/repository/io/temporal/temporal-sdk/1.0.3/temporal-sdk-1.0.3.jar) to field java.lang.Throwable.cause
WARNING: Please consider reporting this to the maintainers of io.temporal.internal.common.CheckedExceptionWrapper
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
```

</details>

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:55:07.000 UTC</summary>

https://github.com/temporalio/sdk-java/pull/251

</details>


---

<a id="175"></a>

### #175: The constraint about activity's scheduleToClose or scheduleToStart & startToClose should be defined is not enforced

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/175 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2020-08-12 20:42:46.000 UTC (5y 5m ago) |
| **Updated** | 2020-08-24 15:57:39.000 UTC |
| **Closed** | 2020-08-24 15:57:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

An attempt to configure an Activity with `LocalActivityOptions.newBuilder().build()` should fail, because according to javadoc `scheduleToCloseTimeout` or both `scheduleToStartTimeout` and `startToCloseTimeout` should be defined and there is no default values for these parameters.

## Actual Behavior

We are able to configure an activity stub with `LocalActivityOptions.newBuilder().build()` without any exceptions.

## Specifications

  - Version: current master (https://github.com/temporalio/java-sdk/commit/35abfd425c13e86f16b81e26c85c07b17ee3448f) and 0.28.0


#### Comments (4)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-21 04:41:54.000 UTC</summary>

This is by design. We moved all activity options validation logic to the service. 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2020-08-21 05:49:32.000 UTC</summary>

@mfateev 
1. Should a temporal implementation for tests also support the validation in that case? Because right now such configuration passes everything in the test environment.
2. Does temporal service enforce the validation of **Local** activity options?

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-08-21 16:34:19.000 UTC</summary>

1. Yes, I believe it does for activities.
2. Sorry, I missed that you are talking about local activity. These indeed should be done in the SDK.

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-08-24 15:57:39.000 UTC</summary>

Fixed by #194 

</details>


---

<a id="86"></a>

### #86: Support passing activityId to an activity invocation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/86 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-12 18:31:34.000 UTC (5y 8m ago) |
| **Updated** | 2025-05-15 07:55:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 4 |
| **Priority Score** | 4 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
It is not possible to specify a business level ID for an activity during its invocation. This is a problem for completing activities asynchronously by ID.

**Describe the solution you'd like**
Provide a way to specify the ID when invoking an activity.



#### Comments (4)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:33:42.000 UTC</summary>

Right now we tell people to create a new stub every time, we should think if we can provide per-activity invocation options.

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2021-11-17 15:26:15.000 UTC</summary>

I think the idea is to specify business level activity id via ActivityOptions as it can be done via other SDKs currently. 

Here is a forum reference for a user that needs this feature implemented:  https://community.temporal.io/t/possible-to-set-activityid/3406

Reactions: üëç 2

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-18 17:55:03.000 UTC</summary>

Related: https://github.com/temporalio/sdk-java/issues/1009

</details>

<details>
<summary><strong>Hassib-Maslah</strong> commented on 2025-05-14 14:09:58.000 UTC</summary>

Hello @mfateev, I was wondering if there are any updates regarding this issue. Do you have an estimated release date ?



</details>


---

<a id="2679"></a>

### #2679: WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE does not throw WorkflowExecutionAlreadyStarted

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2679 |
| **State** | CLOSED |
| **Author** | denvernyaw (Nikita) |
| **Created** | 2025-10-09 16:15:40.000 UTC (3 months ago) |
| **Updated** | 2025-10-17 15:49:33.000 UTC |
| **Closed** | 2025-10-17 15:49:22.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior
According to [javadoc](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowExecutionAlreadyStarted.html):

> _There is a closed workflow with the same ID and the [WorkflowOptions.getWorkflowIdReusePolicy()](https://javadoc.io/static/io.temporal/temporal-sdk/1.31.0/io/temporal/client/WorkflowOptions.html#getWorkflowIdReusePolicy()) is WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE._

So we expect that second and further attempts to run workflow with the same workflowId will throw WorkflowExecutionAlreadyStarted exception.

## Actual Behavior
When running code from [this snippet](https://docs.temporal.io/develop/java/set-up-your-local-java#6-execute-the-workflow), but adding `.setWorkflowIdReusePolicy(WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)` to WorkflowOptions ‚Äì second run of workflow with the same workflowId does not throw exception.

## Steps to Reproduce the Problem
Run this code twice and observe that there is no exception, and the single workflow run displayed in Temporal UI:
 `
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
        WorkflowClient client = WorkflowClient.newInstance(service);

        SayHelloWorkflow workflow = client.newWorkflowStub(
                SayHelloWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue("my-task-queue")
                        .setWorkflowId("say-hello-workflow-id")
                        .setWorkflowIdReusePolicy(WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)
                        .build()
        );

        String result = workflow.sayHello("Temporal");
        System.out.println("Workflow result: " + result);
`

Probably, javadoc out of sync with code.
We also debug the library and found that exception actually fired, but caught here: io.temporal.client.WorkflowInvocationHandler#startWorkflow#189

## Specifications

  - Version: 1.31.0
  - Platform: temporal version 1.4.1 (Server 1.28.0, UI 2.39.0)

<img width="904" height="408" alt="Image" src="https://github.com/user-attachments/assets/ab6f8340-e4f7-4c95-9da1-7724561b4b0b" />

<img width="1980" height="585" alt="Image" src="https://github.com/user-attachments/assets/607259de-691b-49f4-8235-1b0a0ceb727a" />

<img width="916" height="411" alt="Image" src="https://github.com/user-attachments/assets/29913505-ddeb-4315-a2cb-e16ccbf12baa" />


#### Comments (1)

<details>
<summary><strong>maciejdudko</strong> commented on 2025-10-17 15:49:22.000 UTC</summary>

Hi @denvernyaw, this behavior is by design. When the workflow is started by calling the stub's workflow method, or by calling `WorkflowClient::execute`, it waits for the result of the workflow. If `WorkflowIdReusePolicy` is set to something other than `ALLOW_DUPLICATE`, then instead of throwing `WorkflowExecutionAlreadyStarted` on conflict, it will attach to the existing workflow execution and wait for its result (if the workflow already completed, it will return its result immediately). This behavior is called out in [WorkflowClient documentation](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClient.html).

On the other hand, if the workflow is started by calling `WorkflowClient::start`, it will not wait for the workflow result, and will throw `WorkflowExecutionAlreadyStarted` on conflict.

</details>


---

<a id="2652"></a>

### #2652: UNKNOWN GRPC error on describe in TestWorkflowEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2652 |
| **State** | CLOSED |
| **Author** | jeffschoner-stripe |
| **Created** | 2025-09-05 20:01:05.000 UTC (4 months ago) |
| **Updated** | 2025-09-26 17:12:23.000 UTC |
| **Closed** | 2025-09-26 17:12:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Calling describe on the workflow should return a valid result.

## Actual Behavior

Calling describe on the workflow sometimes results in a GRPC exception being thrown.

```
io.grpc.StatusRuntimeException: UNKNOWN
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:271)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:252)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:165)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.describeWorkflowExecution(WorkflowServiceGrpc.java:5523)
```

## Steps to Reproduce the Problem

There are not reliable repro steps. The issue is intermittent.

In a JUnit test, 
  1. Set up a `TestWorkflowEnvironment`. This is being done in a `@BeforeClass` method in a base class for the unit test class. All instances are stored in class variables for the life of the test. It's not clear to me if the static/class methods/variables are playing a role here or not.
  2. In a `@Before` method on the class with the unit tests,
    - Start a workflow. This is done indirectly in that our test is calling a GRPC endpoint that is also running inside the test which starts a workflow. However, the starting of the workflow is done synchronously back to the caller. It's not clear to me that the indirection here matters.
    - Call DescribeWorkflowExecution using the workflow ID that was used in the previous step

## Specifications

  - Version: 1.27.1
  - Platform: Linux


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-08 22:11:51.000 UTC</summary>

Thanks for the report we will investigate 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-15 17:27:33.000 UTC</summary>

So likely this error means some exception (that is not a `StatusRuntimeException`) was thrown while running [describeWorkflowExecution](https://github.com/temporalio/sdk-java/blob/bf0b196ce00143edcc39de80cb2fc0ad93ce80ea/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java#L3153). Since that is the most common way the client would receive an `UNKNOWN ` status. I was also able to manually confirm by adding a `throw new IllegalArgumentException("test")` to the top of the above function. The SDK would log the exception so can you share any logs from these failed tests? The exception would look like this based on my test I described above.

```
Sep 15, 2025 10:19:50 A.M. io.grpc.internal.SerializingExecutor run
SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed@72a7e903
java.lang.IllegalArgumentException: test
	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.describeWorkflowExecution(TestWorkflowMutableStateImpl.java:3154)
	at io.temporal.internal.testservice.TestWorkflowService.describeWorkflowExecution(TestWorkflowService.java:1691)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$MethodHandlers.invoke(WorkflowServiceGrpc.java:8975)
	at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
	at io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)
	at io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)
	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:351)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:860)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
```

</details>

<details>
<summary><strong>jeffschoner-stripe</strong> commented on 2025-09-15 22:56:04.000 UTC</summary>

@Quinn-With-Two-Ns Thanks for the pointer on what to look for. Here's the stack trace of one of the failures. Looks like it may be some sort race condition with child workflows

```
00:12:24.820	SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed@77c3bde9
00:12:24.820	java.lang.NullPointerException: Cannot invoke "io.temporal.api.common.v1.WorkflowExecution.getWorkflowId()" because "data.execution" is null
00:12:24.820		at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.constructPendingChildExecutionInfo(TestWorkflowMutableStateImpl.java:3115)
00:12:24.820		at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
00:12:24.820		at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)
00:12:24.820		at java.base/java.util.HashMap$ValueSpliterator.forEachRemaining(HashMap.java:1779)
00:12:24.820		at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
00:12:24.820		at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
00:12:24.820		at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
00:12:24.820		at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
00:12:24.820		at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
00:12:24.820		at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.describeWorkflowExecutionInsideLock(TestWorkflowMutableStateImpl.java:3099)
00:12:24.820		at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.describeWorkflowExecution(TestWorkflowMutableStateImpl.java:3030)
00:12:24.820		at io.temporal.internal.testservice.TestWorkflowService.describeWorkflowExecution(TestWorkflowService.java:1584)
00:12:24.820		at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$MethodHandlers.invoke(WorkflowServiceGrpc.java:7312)
00:12:24.820		at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
00:12:24.820		at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:354)
00:12:24.820		at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:866)
00:12:24.820		at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
00:12:24.820		at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
00:12:24.820		at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
00:12:24.820		at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
00:12:24.820		at java.base/java.lang.Thread.run(Thread.java:840)
```

In the older version of the code we're running, it's in this function in `TestWorkflowMutableStateImpl.java`:
```
  private static PendingChildExecutionInfo constructPendingChildExecutionInfo(
      StateMachine<ChildWorkflowData> sm) {
    ChildWorkflowData data = sm.getData();
    return PendingChildExecutionInfo.newBuilder()
        .setWorkflowId(data.execution.getWorkflowId())
        .setRunId(data.execution.getRunId())
        .setWorkflowTypeName(data.initiatedEvent.getWorkflowType().getName())
        .setInitiatedId(data.initiatedEventId)
        .setParentClosePolicy(data.initiatedEvent.getParentClosePolicy())
        .build();
  }
```

</details>


---

<a id="2647"></a>

### #2647: Activity Type not registered error when using RetryOptions with maxAttempts(1)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2647 |
| **State** | CLOSED |
| **Author** | mmirzaeyan (Mohammad Mirzaeyan) |
| **Created** | 2025-08-30 06:03:11.000 UTC (4 months ago) |
| **Updated** | 2025-09-03 04:40:00.000 UTC |
| **Closed** | 2025-09-03 04:40:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Activities should work the same way with or without RetryOptions configuration.


## Actual Behavior
When configuring ActivityOptions with RetryOptions.maxAttempts(1), the workflow throws an error saying the activity type is not registered, even though the same activity works perfectly without RetryOptions.
Caused by: io.temporal.failure.ApplicationFailure: message=‚ÄòActivity Type ‚ÄúreserveInventory‚Äù is not registered with a worker. Known types are: chargeCustomer, refundCustomer‚Äô, type=‚Äòjava.lang.IllegalArgumentException‚Äô, nonRetryable=false

## Steps to Reproduce the Problem
1.Create a workflow with multiple activity stubs
2.Configure ActivityOptions with RetryOptions.maxAttempts(1)
3.Register all activities in the worker
4.Run the workflow
5.Observe that some activities are reported as ‚Äúnot registered‚Äù

## Specifications

  -Temporal Version: 1.26.3.0


### Code Example
```java
// This FAILS with the above error
private final InventoryActivities inventory =
    Workflow.newActivityStub(InventoryActivities.class,
        ActivityOptions.newBuilder()
            .setTaskQueue("ORDER_TASK_QUEUE")
            .setStartToCloseTimeout(Duration.ofSeconds(10))
            .setRetryOptions(RetryOptions.newBuilder()
                .setMaximumAttempts(1)
                .build())
            .build());

// This WORKS without any issues
private final InventoryActivities inventory =
    Workflow.newActivityStub(InventoryActivities.class,
        ActivityOptions.newBuilder()
            .setTaskQueue("ORDER_TASK_QUEUE")
            .setStartToCloseTimeout(Duration.ofSeconds(10))
            // No RetryOptions
            .build());

#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-02 14:44:05.000 UTC</summary>

`maxAttempts(1)` should have no impact on the activities registered. Testing I am not able to reproduce this with the code provided. Please provide a minimal stand alone, runnable, replication of the issue if you would like us to investigate further.

</details>

<details>
<summary><strong>mmirzaeyan</strong> commented on 2025-09-03 04:26:38.000 UTC</summary>

this is my sample repository https://github.com/mmirzaeyan/temporal-sample , docker compose beside the project is using for running temporal , postgress and temporal ui 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-03 04:40:00.000 UTC</summary>

In your example you create two workers listening on the same task queue with different activities registered:
* Your [PaymentWorker](https://github.com/mmirzaeyan/temporal-sample/blob/main/payment-service/src/main/java/com/example/payment/PaymentWorker.java) has `PaymentActivitiesImpl` registered
* Your [InventoryWorker](https://github.com/mmirzaeyan/temporal-sample/blob/main/inventory-service/src/main/java/com/example/inventory/InventoryWorker.java) has `InventoryActivitiesImpl` registered

In Temporal workers listening on the same task queue need to have the same activities registered, or they need to use different task queues. Otherwise you will get errors because the activity is not registered on some workers.

I would recommend looking at our [courses](https://learn.temporal.io/courses/temporal_101/java/) as they cover this in more detail

</details>


---

<a id="2504"></a>

### #2504: Temporal versions 1.28.3 1.29.0 compatibility with Springboot spring-boot-starter-parent 3.3.11

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2504 |
| **State** | CLOSED |
| **Author** | DanielASAndrews (Daniel Andrews) |
| **Created** | 2025-05-02 18:10:17.000 UTC (8 months ago) |
| **Updated** | 2025-06-06 15:19:56.000 UTC |
| **Closed** | 2025-06-03 14:04:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Temporal latest release 1.29.0 works with Spring Boot 3.3.11

## Actual Behavior

Upgrading spring-boot-starter-parent from 3.3.4 to 3.3.11 causes bean instantiation issue on application startup

We upgraded spring version because of security scan vulnerability CVE-2025-22235 (https://spring.io/security/cve-2025-22235)

```
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'temporalWorkerService': Invocation of init method failed
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:222)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:755)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335)
	at com.procore.mlasyncadapter.MLAsyncAdapterApplication.main(MLAsyncAdapterApplication.java:20)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.boot.loader.launch.Launcher.launch(Launcher.java:102)
	at org.springframework.boot.loader.launch.Launcher.launch(Launcher.java:64)
	at org.springframework.boot.loader.launch.JarLauncher.main(JarLauncher.java:40)
Caused by: io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: Deadline CallOptions will be exceeded in 3.398807440s.
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:275)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:256)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:169)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.getSystemInfo(WorkflowServiceGrpc.java:6065)
	at io.temporal.serviceclient.SystemInfoInterceptor.getServerCapabilitiesOrThrow(SystemInfoInterceptor.java:132)
	at io.temporal.serviceclient.SystemInfoInterceptor.lambda$getServerCapabilitiesWithRetryOrThrow$0(SystemInfoInterceptor.java:118)
	at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:69)
	at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:60)
	at io.temporal.serviceclient.SystemInfoInterceptor.getServerCapabilitiesWithRetryOrThrow(SystemInfoInterceptor.java:117)
	at io.temporal.serviceclient.ChannelManager.lambda$getServerCapabilities$3(ChannelManager.java:344)
	at io.temporal.internal.worker.WorkflowPollTask.<init>(WorkflowPollTask.java:88)
	at io.temporal.internal.worker.WorkflowWorker.start(WorkflowWorker.java:143)
	at io.temporal.internal.worker.SyncWorkflowWorker.start(SyncWorkflowWorker.java:177)
	at io.temporal.worker.Worker.start(Worker.java:418)
	at io.temporal.worker.WorkerFactory.start(WorkerFactory.java:224)
	at com.procore.mlasyncadapter.workflow.TemporalWorkerService.startWorker(TemporalWorkerService.java:46)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	... 23 common frames omitted
```

## Steps to Reproduce the Problem

  1. Temporal 1.28.3, Springboot 3.3.4 -> update -> 3.3.11 => Issue appears 
  1. Temporal 1.28 -> 1.29.0 => Issue persists
  1. Springboot 3.3.11 -> downgrade -> 3.3.4 => Issue disappears

## Specifications

  - Version: 1.28.3, 1.29.0
  - Platform: maven:3.8.1-openjdk-17-slim


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-02 18:17:45.000 UTC</summary>

@DanielASAndrews can you please provide a stand alone replication of your issue, then we will take a look . Thanks

on the surface it looks like a your worker couldn't connect to your Temporal cluster

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-03 14:04:34.000 UTC</summary>

Closing due to lack or reproduction, we can re open if a reproduction is provided.

</details>

<details>
<summary><strong>DanielASAndrews</strong> commented on 2025-06-06 15:19:55.000 UTC</summary>

@Quinn-With-Two-Ns Sorry for the delay - we ended up working with the Temporal Cloud Support team and the issue ended up being this one:

> On your WorkflowServiceStubsOptions, can you please set the GetSystemInfo timeout to 5 or 10 seconds, as shown here:
WorkflowServiceStubsOptions.newBuilder()
.setSystemInfoTimeout(Duration.ofSeconds(10))
See [these release notes](https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_temporalio_sdk-2Djava_releases_tag_v1.25.2&d=DwMFaQ&c=jNOZMG6z2EeG3kPzO0VzH_g0oOA2ndrpb3OIHbfUmfw&r=CmUPOYFJkKa9MKxidC7KEEo-UrgvPFezDyA92vFo244&m=1dfkSRa7Pi37pBt0zgR7QlUoMofs6pLCM3wvhr4vF0n2BulTJTt6bGxd8Xh8oQgI&s=OG8_5Z9ZPdWU_4T-SXQdU9myFK6KMJsDeKNLVV1LtE4&e=)

Reactions: üëç 1

</details>


---

<a id="2350"></a>

### #2350: WorkflowLock.tryLock should not create a timer if the lock is available

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2350 |
| **State** | CLOSED |
| **Author** | smax48 (Maxim Chuvilyaev) |
| **Created** | 2024-12-18 01:01:19.000 UTC (1 years ago) |
| **Updated** | 2024-12-23 09:32:10.000 UTC |
| **Closed** | 2024-12-23 09:32:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When there's a call to `WorkflowLock.tryLock(timeout, condition)` , even if the lock is available - a new timer is created and saved to WF history (which can potentially affect performance and probably costs in temporal cloud)

Is there any particular reason that this method doesn't try to short-circuit execution (i.e. do not call `Workflow.await`) if the lock is already available (so unblock condition is already true)?...

This is actually a general question for `Workflow.await` as well ...

#### Comments (3)

<details>
<summary><strong>mfateev</strong> commented on 2024-12-18 03:09:32.000 UTC</summary>

I agree that `Workflow.await` shouldn't create a timer ifthe  condition is immediately satisfied. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 09:30:56.000 UTC</summary>

> I agree that Workflow.await shouldn't create a timer if the condition is immediately satisfied.

Second, there is already another open [issue](https://github.com/temporalio/sdk-java/issues/2312) that will cover this change. 



</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 09:32:06.000 UTC</summary>

Closing as a duplicate because there is already an issue to track the change to `Workflow.await`

</details>


---

<a id="2312"></a>

### #2312: `Workflow.await(duration, condition)` does not automatically cancel the timer if the condition is resolved

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2312 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-11-08 23:46:05.000 UTC (1y 2m ago) |
| **Updated** | 2024-12-23 09:31:57.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
`Workflow.await(duration, condition)` should automatically cancel the timer when the condition is resolved

**Describe alternatives you've considered**
User can currently do this manually with a cancellation scope around the `await`

**Additional context**
This will need to be versioned with SDK flags to avoid breaking determinism.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 09:31:55.000 UTC</summary>

Implementer should also verify that if the condition is immediately satisfied no timer is created

Reactions: üëç 2

</details>


---

<a id="2194"></a>

### #2194: Thread `LocalActivitySlotSupplierQueue` prevent JVM from termination

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2194 |
| **State** | CLOSED |
| **Author** | nikoncode (Mikita Karaliou) |
| **Created** | 2024-08-20 13:55:46.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-20 20:13:05.000 UTC |
| **Closed** | 2024-08-20 20:13:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Steps to reproduce 

* use `spring.temporal.start-workers = false` or just don't start worker
* terminate application (`io.temporal.worker.WorkerFactory#shutdown`)  - `LocalActivitySlotSupplierQueue` remains working and blocks jvm from exiting

Reproduced on last available temporal version 1.25.0

# Possible explanation

* `io.temporal.internal.worker.LocalActivitySlotSupplierQueue#LocalActivitySlotSupplierQueue` created during initialization of `io.temporal.internal.worker.LocalActivityWorker#LocalActivityWorker`
* `io.temporal.internal.worker.LocalActivityWorker#activityAttemptTaskExecutor` became null until `start` called - we don't do this
* `io.temporal.internal.worker.LocalActivityWorker#shutdown` expect `activityAttemptTaskExecutor` to be not null and doesn't call  `slotQueue.shutdown()`

# Possible fix
* Since this thread created in constructor we should probably move `slotQueue.shutdown()` one line higher to stop this thread indepenendly of worker start call.
* Or initialize it in start, not in the constructor.

# Use cases 

We want to have support of "management commands" inside our applications. This is separate run mode, which requires disable of all external services (kafka, Temporal, grpc, etc).

#### Comments (3)

<details>
<summary><strong>nikoncode</strong> commented on 2024-08-20 14:03:44.000 UTC</summary>

Snippet to reproduce:

```
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
        WorkflowClient client = WorkflowClient.newInstance(service);
        WorkerFactory factory = WorkerFactory.newInstance(client);
        Worker worker = factory.newWorker("test");

        factory.shutdown();
```

</details>

<details>
<summary><strong>nikoncode</strong> commented on 2024-08-20 14:06:48.000 UTC</summary>

It's also strange that `io.temporal.internal.worker.LocalActivityWorker#shutdown` call interrupt for this thread conditionally, but `io.temporal.internal.worker.LocalActivityWorker#awaitTermination` not.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-20 14:46:59.000 UTC</summary>

Thank you for the detailed bug report:
* `LocalActivitySlotSupplierQueue` should only create a thread if the worker is started
* `awaitTermination` should not call `slotQueue.shutdown()`, but should verify the shutdown has finished. If the queue was never started it can return immediately 

</details>


---

<a id="2076"></a>

### #2076: Querying a running workflow makes it spam previously logged messages

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2076 |
| **State** | CLOSED |
| **Author** | rorueda |
| **Created** | 2024-05-24 14:17:08.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-31 17:01:11.000 UTC |
| **Closed** | 2024-05-31 17:01:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Querying a workflow doesn't generate additional logs.

## Actual Behavior
Querying a workflow generates additional logs.

## Steps to Reproduce the Problem

I added an additional test to `DirectQueryReplaysDontSpamLogWithWorkflowExecutionExceptionsTest.java` to reproduce the issue. 

```java
@Rule
public SDKTestWorkflowRule testWorkflowRule =
    SDKTestWorkflowRule.newBuilder()
        .setWorkflowTypes(TestWorkflowNonRetryableFlag.class, LogAndKeepRunningWorkflow.class)
        .setActivityImplementations(new TestActivities.TestActivitiesImpl())
        .build();

@Test
public void queriedWorkflowFailureDoesntProduceAdditionalLogsWhenWorkflowIsNotCompleted()
    throws InterruptedException {
  TestWorkflows.QueryableWorkflow workflow =
      testWorkflowRule.newWorkflowStub(TestWorkflows.QueryableWorkflow.class);

  WorkflowExecution execution = WorkflowClient.start(workflow::execute);
  Thread.sleep(500);
  assertEquals(
      "Workflow execution exception should be logged",
      1,
      workflowExecuteRunnableLoggerAppender.list.size());

  TestWorkflows.QueryableWorkflow queryStub =
      testWorkflowRule
          .getWorkflowClient()
          .newWorkflowStub(TestWorkflows.QueryableWorkflow.class, execution.getWorkflowId());
  assertEquals("my-state", queryStub.getState());
  assertEquals("There was only one execution.", 1, workflowCodeExecutionCount.get());
  assertEquals(
      "Only the original exception should be logged.",
      1,
      workflowExecuteRunnableLoggerAppender.list.size());

  testWorkflowRule.invalidateWorkflowCache();
  assertEquals("my-state", queryStub.getState());
  assertEquals(
      "There was two executions - one original and one full replay for query.",
      2,
      workflowCodeExecutionCount.get());
  assertEquals(
      "Only the original exception should be logged.",
      1,
      workflowExecuteRunnableLoggerAppender.list.size());

  queryStub.mySignal("exit");
  assertEquals("my-state", queryStub.getState());
  assertEquals(
      "There was three executions - one original and two full replays for query.",
      3,
      workflowCodeExecutionCount.get());
  assertEquals(
      "Only the original exception should be logged.",
      1,
      workflowExecuteRunnableLoggerAppender.list.size());
}

public static class LogAndKeepRunningWorkflow implements TestWorkflows.QueryableWorkflow {
  private final org.slf4j.Logger logger;
  private final TestActivities.VariousTestActivities activities;
  private boolean exit;

  public LogAndKeepRunningWorkflow() {
    activities =
        Workflow.newActivityStub(
            TestActivities.VariousTestActivities.class,
            ActivityOptions.newBuilder()
                .setStartToCloseTimeout(Duration.ofSeconds(10))
                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())
                .build());
    logger = Workflow.getLogger("io.temporal.internal.sync.WorkflowExecutionHandler");
  }

  @Override
  public String execute() {
    workflowCodeExecutionCount.incrementAndGet();
    while (true) {
      try {
        activities.throwIO();
      } catch (ActivityFailure e) {
        logger.error("Unexpected error on activity", e);
        Workflow.await(() -> exit);
        if (exit) {
          return "exit";
        }
      }
    }
  }

  @Override
  public String getState() {
    return "my-state";
  }

  @Override
  public void mySignal(String value) {
    exit = true;
  }
}
```

I found that the logs are generated because replaying is being set to false here:
https://github.com/temporalio/sdk-java/blob/5e5cf0bf2db695cba46d1855959e02b4cdfa3cff/temporal-sdk/src/main/java/io/temporal/internal/statemachines/WorkflowStateMachines.java#L456-L462

I saw that there were changes to those lines recently, but I've tested with 1.23.1, 1.23.2 and master and the issue is present in all of them. I first noticed the issue in production when upgrading from 1.19.1 to 1.23.1.


## Specifications

  - Version: 1.23.1 / 1.23.2 / master
  - Platform: Ubuntu 22


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-24 15:13:22.000 UTC</summary>

This  is already fixed by https://github.com/temporalio/sdk-java/commit/a41c64ece3876f584ebde70903668b817c5455d8 and will be included in the next SDK release

</details>

<details>
<summary><strong>rorueda</strong> commented on 2024-05-24 17:31:18.000 UTC</summary>

I can't rule out my test being wrong, but I have just tested on top of the current last commit https://github.com/temporalio/sdk-java/commit/5e5cf0bf2db695cba46d1855959e02b4cdfa3cff and it still fails. Any idea why?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-24 22:59:03.000 UTC</summary>

hm let me try to get your test running on my machine

</details>


---

<a id="2056"></a>

### #2056: Allow users to implement update asynchronously in Java natively

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2056 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-05-08 18:25:12.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-08 18:37:02.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently update handlers in Java are all run in their own threads. This means that if the update handler takes a long time and multiple updates are sent the workflow execution can consume lots of threads just waiting in update handlers. 

**Describe the solution you'd like**
Support the ability to transform an update call into a `Promise` that can be completed later in another thread like the main workflow method .

**Additional context**
We have a similar feature to support async activities https://javadoc.io/doc/io.temporal/temporal-sdk/1.0.6/io/temporal/activity/ActivityExecutionContext.html#isUseLocalManualCompletion--

Currently users can do this with the existing SDK API, but it will still consume a thread waiting for the result to return in the handle. If the SDK had a native API for this we wouldn't need to wait in the thread.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2024-05-08 18:37:01.000 UTC</summary>

Ideally, the same API can be reused to complete the workflow asynchronously. This would allow workflows to be implemented fully async without tying up a thread when a workflow is cached.

</details>


---

<a id="2049"></a>

### #2049: Async Activity support for Java async API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2049 |
| **State** | CLOSED |
| **Author** | qinghui-xu (wineandcheeze) |
| **Created** | 2024-05-02 14:46:35.000 UTC (1y 8m ago) |
| **Updated** | 2025-06-02 15:28:41.000 UTC |
| **Closed** | 2025-06-02 15:28:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
In activity implementations, we often deal with Java async APIs (for example, the new `java.net.http` api in Java 11). And such APIs usually return a `Future` or `CompletionStage` (less often), or even better `CompletableFuture`. Currently Activity invocation is not aware of these types and does not wait until the completion of them, which means we have to block and wait in client activity implementations (aka. `ActivityMethod`).
This is not very convenient:
- Developers may forget to call on `Future#get` in an `ActivityMethod`, and this will cause a bug such that temporal considers an activity as done while it is not. (This is more likely to happen if the activity ends up in calling some service that returns a `CompletableFuture<Void>` as we usually don't expect to deal with the result specifically.)
- On workflow side we can not code it fluently using `CompletionStage`'s compose APIs to combine activities in order (we have to use Temporal's `Async` static APIs for the purpose)
- This means an activity execution thread has to block and wait for the completion of a nonblocking / async task, which is not very efficient. 

**Describe the solution you'd like**
To keep consistency with current behaviour and also make it explicit about (enabling) support of the java `CompletableFuture`, I propose to provide `AsyncActivityMethod` annotation to be used on methods that are returning a `java.util.concurrent.CompletableFuture` and we expect the result to be completed before activity is done. More precisely:
- A method annotated with `AsyncActivityMethod` should return `java.util.concurrent.CompletableFuture` as an requirement.
- A mtheod returning `java.util.concurrent.CompletableFuture` but annotated with `ActivityMethod` will continue to behave current way which is launching some async task and complete the activity without waiting for it (activity is just to launch something and does not care about the result).
- `AsyncActivityMethod` activity is considered done only when the `CompletableFuture` is completed.

**Describe alternatives you've considered**
I am open to other propositions.

**Additional context**



#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-02 15:27:06.000 UTC</summary>

Given how the Java SDK uses stubs for type safety and how the Java SDK cannot use Java's native concurrent primitives I don't think this proposal is feasible as describe.

>On workflow side we can not code it fluently using CompletionStage's compose APIs to combine activities in order (we have to use Temporal's Async static APIs for the purpose)

The Java SDK cannot support Java's native concurrent primitives like `CompletableFuture` or `CompletionStage` in a workflow since they are not suitable for our execution requirements, specifically around determinism so you must always use Temporals `Async` code. 

If an activity is invoked in a synchronous or asynchronous manner is determined by the caller (workflow), not the activity so a `Future` should not be in the return type of the activity less you end up with a `Promise` of a `Future` of the actual response (which would be invalid anyway since `Futures` cannot be used in workflow code).


> This means an activity execution thread has to block and wait for the completion of a nonblocking / async task, which is not very efficient.

So if this is a concern the Java SDK support async activities without blocking a thread using
https://javadoc.io/static/io.temporal/temporal-sdk/1.23.2/io/temporal/activity/ActivityExecutionContext.html#doNotCompleteOnReturn() you can see an example https://github.com/temporalio/sdk-java/blob/ed211fa611112288b576a2c979be9284e17fec89/temporal-sdk/src/test/java/io/temporal/workflow/activityTests/AsyncActivityCompleteWithErrorTest.java#L39

We also plan to support virtual threads in the near future that would also make this easier.


</details>

<details>
<summary><strong>qinghui-xu</strong> commented on 2024-05-03 09:03:41.000 UTC</summary>

Hello Quinn,
Thanks for your comments. Based on what you said, the main issue with my proposition is around the concurrent primitives for which Temporal SDK has to use its own. Thus I adapt my proposition a little bit to address your concerns with the following:
- A method annotated with `AsyncActivityMethod` should return ~~`java.util.concurrent.CompletableFuture`~~ `io.temporal.workflow.CompletablePromise` as an requirement (users have to convert their concurrent primitives such as Java `CompletableFuture` or Scala `Future` etc in their code).
- A mtheod returning ~~`java.util.concurrent.CompletableFuture`~~ `io.temporal.workflow.CompletablePromise` but annotated with `ActivityMethod` will continue to behave current way which is launching some async task and complete the activity without waiting for it (activity is just to launch something and does not care about the result), or this simply should be forbidden by raising exceptions when registering activities.
- [Activity side]`AsyncActivityMethod` activity is considered done only when the returned `io.temporal.workflow.CompletablePromise` is completed. This could be implemented in a similar way as what `ManualActivityCompletionClient` does currently, but avoids boilerplates in user code.
- [Workflow side] Activitiy stubbing for `AsyncActivityMethod` will now need to handle the boilerplates for concurrent execution management in the same way as what `Async.function` does today

Though what you said sounds good sense to me, there's still something I don't fully understand yet.

> The Java SDK cannot support Java's native concurrent primitives like `CompletableFuture` or `CompletionStage` in a workflow since they are not suitable for our execution requirements, specifically around determinism so you must always use Temporals `Async` code.

IIUC (proposition is based on my understanding), the main issue is from the workflow side as composing `CompletableFuture` will probably end up executing activity stubs in any thread which is not a `WorkflowThread`, such that Temporal lost track of the "workflow tasks". Is my understanding correct or there's something I don't see through?

> So if this is a concern the Java SDK support async activities without blocking a thread using
https://javadoc.io/static/io.temporal/temporal-sdk/1.23.2/io/temporal/activity/ActivityExecutionContext.html#doNotCompleteOnReturn() you can see an example

Thanks for this example, and I pick some ideas from it as well to adapt my proposition. The issue with the current mechanism is that it's somehow intrusive to user code, and activity developers have to think about doing it. In fact this mechanism is [documented](https://docs.temporal.io/dev-guide/java/features#asynchronous-activity-completion), I read it quickly when I saw it for the first time, and I forgot about it quickly because I did not fully grasp the reason why it is proposed.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-02 15:28:40.000 UTC</summary>

Closing as not planned as this case is already covered by the [ManualActivityCompletionClient](https://javadoc.io/static/io.temporal/temporal-sdk/1.23.2/io/temporal/activity/ManualActivityCompletionClient.html)

</details>


---

<a id="1988"></a>

### #1988: Have a built-in way to override activityOptions in tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1988 |
| **State** | OPEN |
| **Author** | yunmanger1 (German Ilin) |
| **Created** | 2024-02-13 15:50:14.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-13 18:14:34.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Request: Make it possible for test setup to override ActivityOptions set for activities in workflow. 

Problem:
In production code I have high retry count on activities, but in testing I want to override that to have maxAttempts=1 so that workflow gets it‚Äôs failure right away. Or in case I didn‚Äôt mock some activity properly the test will fail right away with NullPointerException instead of hanging indefinitely.

Another thing is that, when stubbing activities in workflow I hardcode the queue name, because it might not be the same the workflow is on. And in tests I need to override it to make things run, without reproducing all the queue-worker combinations in prod.

**Describe the solution you'd like**

Sth like `overrideAllActivityOptions` or `overrideActivityOptions` in example below.

```
import io.temporal.activity.ActivityOptions
import io.temporal.client.WorkflowException
import io.temporal.client.WorkflowOptions
import io.temporal.common.RetryOptions
import io.temporal.failure.ActivityFailure
import io.temporal.failure.ApplicationFailure
import io.temporal.testing.TestWorkflowEnvironment
import io.temporal.worker.WorkflowImplementationOptions
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.mockito.ArgumentMatchers.anyString
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever


class HelloWorldWorkflowImplTest {

    private val taskQueue = "TASK_QUEUE"
    private val testEnv = TestWorkflowEnvironment.newInstance();
    private val testActivityOptions = ActivityOptions.newBuilder()
        .setTaskQueue(taskQueue)
        .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).validateBuildWithDefaults())
        .validateAndBuildWithDefaults()
    private val opts = WorkflowImplementationOptions.newBuilder()
        .setFailWorkflowExceptionTypes(
            Throwable::class.java,
        )
        .setDefaultActivityOptions(
            testActivityOptions
        )
        .overrideAllActivityOptions(
            testActivityOptions
        )
        .overrideActivityOptions(
            mapOf(HelloWorldActivities::class.java to testActivityOptions)
        )
        .build()!!
    private val worker = testEnv.newWorker(taskQueue).also {
        it.registerWorkflowImplementationTypes(
            opts,
            HelloWorldWorkflowImpl::class.java
        )
    }

    @Test
    fun `activity error should fail workflow`() {
        val formatActivities = mock<HelloWorldActivities>()
        var count = 1
        whenever(formatActivities.composeGreeting(anyString())).then {
            println("CALL $count")
            count += 1
            error("test error")
        }
        worker.registerActivitiesImplementations(formatActivities)
        testEnv.start()

        val workflow = testEnv.workflowClient.newWorkflowStub(
            HelloWorldWorkflow::class.java,
            WorkflowOptions.newBuilder().setTaskQueue(taskQueue).build()!!
        )
        try {
            workflow.getGreeting("Mock")
            error("unreachable")
        } catch (e: WorkflowException) {
            assertTrue(e.cause is ActivityFailure)
            assertTrue(e.cause?.cause is ApplicationFailure)
            assertEquals(
                "test error",
                (e.cause?.cause as ApplicationFailure).originalMessage
            )
        }
    }
}
```

**Describe alternatives you've considered**
Right now I am flagging to code directly to use testActivityOptions when executed from test.

```
    @BeforeEach
    fun `setup overrides`() {
        GlobalWorkflowOptions.set(testActivityOptions)
    }

    @AfterEach
    fun `reset overrides`() {
        GlobalWorkflowOptions.clear()
    }
```

and in code

```
class HelloWorldWorkflowImpl : HelloWorldWorkflow {

    private val activityOptions = ActivityOptions.newBuilder()
        .setTaskQueue(HELLO_WORLD_TASK_QUEUE)
        .setStartToCloseTimeout(Duration.ofSeconds(60))
        .validateAndBuildWithDefaults()!!

    private val activity = Workflow.newActivityStub(
        HelloWorldActivities::class.java,
        GlobalWorkflowOptions.activityOptions(activityOptions)
    )

    override fun getGreeting(name: String): String {
        return activity.composeGreeting(name)
    }

}
```

**Additional context**
https://community.temporal.io/t/throwing-exception-in-mocked-activity-hangs-the-test/10932

Related issues: #499 #626 

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-02-13 18:14:33.000 UTC</summary>

In the meantime, can you consider having your mock activity throw a non-retryable exception?

</details>


---

<a id="1933"></a>

### #1933: `No PayloadConverter is registered for an encoding: binary/null`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1933 |
| **State** | CLOSED |
| **Author** | jocho-here (Joseph) |
| **Created** | 2023-11-16 23:13:34.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-04 17:51:25.000 UTC |
| **Closed** | 2023-12-04 17:51:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
- `BinaryNullPayloadConverter` should be picked up to convert the payload that's `binary/null`

## Actual Behavior
- This is probably caused when we had a binary `null` in the payload, but rather threw an error without directly converting. I saw there is a `BinaryNullPayloadConverter` for Python SDK but not for Java SDK. Is this possibly a feature request?
- Our workflow threw `DataConverterException: No PayloadConverter is registered for an encoding: binary/null`
- the error:
```
Caused by: io.temporal.common.converter.DataConverterException: No PayloadConverter is registered for an encoding: binary/null
	at io.temporal.common.converter.PayloadAndFailureDataConverter.fromPayload(PayloadAndFailureDataConverter.java:89)
	at io.temporal.common.converter.PayloadAndFailureDataConverter.fromPayloads(PayloadAndFailureDataConverter.java:133)
	at io.temporal.internal.client.RootWorkflowClientInvoker.convertResultPayloads(RootWorkflowClientInvoker.java:500)
	at io.temporal.internal.client.RootWorkflowClientInvoker.getResult(RootWorkflowClientInvoker.java:220)
	at io.temporal.common.interceptors.WorkflowClientCallsInterceptorBase.getResult(WorkflowClientCallsInterceptorBase.java:51)
	at io.temporal.client.WorkflowStubImpl.getResult(WorkflowStubImpl.java:218)
```

## Steps to Reproduce the Problem

## Specifications
  - Version: TemporalSDK: 1.22.0, Temporal-shaded:1.21.1
  - Platform: K8s


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-16 23:18:05.000 UTC</summary>

The [NullPayloadConverter](https://github.com/temporalio/sdk-java/blob/499593f4150b00c28f0694bc48837f36ab6e47a6/temporal-sdk/src/main/java/io/temporal/common/converter/NullPayloadConverter.java#L30C1-L30C1) and is part of the [default ](https://github.com/temporalio/sdk-java/blob/499593f4150b00c28f0694bc48837f36ab6e47a6/temporal-sdk/src/main/java/io/temporal/common/converter/DefaultDataConverter.java#L39C20-L39C20) data converter for Java does register itself for `binary/null` 

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-16 23:27:39.000 UTC</summary>

If you are not using the default data converter you need to  make sure `NullPayloadConverter` is registered.

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-04 17:51:24.000 UTC</summary>

Closing since Java does implement a `binary/null` data converter

</details>


---

<a id="1921"></a>

### #1921: Workflow executions frozen after Temporal exception

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1921 |
| **State** | CLOSED |
| **Author** | brunomascijp |
| **Created** | 2023-11-01 15:57:25.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-29 14:56:47.000 UTC |
| **Closed** | 2023-11-29 14:56:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
**Workflow executions should make progress, retrying, failing or successfully completing steps.**

## Actual Behavior
**I have some executions that got stuck for hours after the following exception, and the state was _Running_ on all of them.
We restarted all the workers and the orchestrator seemed to be working good.**


`[Workflow Executor taskQueue="prod", namespace="ns": 77] [] i.temporal.internal.worker.PollerOptions: uncaught exception
java.lang.RuntimeException: Failure processing workflow task. WorkflowId=5b38, RunId=5c9cbad8-8a64-4a84-81bd-64d02474a560, Attempt=473
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:327)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:188)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:98)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: io.temporal.internal.statemachines.InternalWorkflowTaskException: Failure handling event 28 of type 'EVENT_TYPE_WORKFLOW_TASK_STARTED' during execution. {WorkflowTaskStartedEventId=28, CurrentStartedEventId=28}
	at io.temporal.internal.statemachines.WorkflowStateMachines.createEventProcessingException(WorkflowStateMachines.java:257)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:236)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:208)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.applyServerHistory(ReplayWorkflowRunTaskHandler.java:208)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:192)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:147)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:132)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:97)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:336)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:246)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:188)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)
	... 3 common frames omitted
Caused by: java.lang.RuntimeException: WorkflowTask: failure executing SCHEDULED->WORKFLOW_TASK_STARTED, transition history is [CREATED->WORKFLOW_TASK_SCHEDULED]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:152)
	at io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:102)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:68)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleSingleEvent(WorkflowStateMachines.java:277)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:234)
	... 13 common frames omitted
Caused by: java.lang.NullPointerException: stackTrace[15]
	at java.base/java.lang.Throwable.setStackTrace(Throwable.java:879)
	at io.temporal.failure.FailureConverter.failureToException(FailureConverter.java:85)
	at io.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)
	at io.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)
	at io.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)
	at io.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)
	at io.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)
	at io.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)
	at io.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)
	at io.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)
	at io.temporal.internal.sync.SyncWorkflowContext$ActivityCallback.lambda$invoke$0(SyncWorkflowContext.java:292)
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:102)
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:106)
	at io.temporal.worker.ActiveThreadReportingExecutor.lambda$submit$0(ActiveThreadReportingExecutor.java:53)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	... 3 common frames omitted `



**Particularly, all stuck executions are on _WorkflowTaskFailed_ state and, after a few hours waiting, we decided to terminate them:**


`{
  "message": "Failure handling event 25 of type 'EVENT_TYPE_WORKFLOW_TASK_STARTED' during execution. {WorkflowTaskStartedEventId=25, CurrentStartedEventId=25}",
  "source": "JavaSDK",
  "stackTrace": "io.temporal.internal.statemachines.WorkflowStateMachines.createEventProcessingException(WorkflowStateMachines.java:257)\nio.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:236)\nio.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:208)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.applyServerHistory(ReplayWorkflowRunTaskHandler.java:208)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:192)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:147)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:132)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:97)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:336)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:246)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:188)\nio.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)\njava.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\njava.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\njava.base/java.lang.Thread.run(Thread.java:833)\n",
  "cause": {
    "message": "WorkflowTask: failure executing SCHEDULED->WORKFLOW_TASK_STARTED, transition history is [CREATED->WORKFLOW_TASK_SCHEDULED]",
    "source": "JavaSDK",
    "stackTrace": "io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:152)\nio.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:102)\nio.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:68)\nio.temporal.internal.statemachines.WorkflowStateMachines.handleSingleEvent(WorkflowStateMachines.java:277)\nio.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:234)\nio.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:208)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.applyServerHistory(ReplayWorkflowRunTaskHandler.java:208)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:192)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:147)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:132)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:97)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:336)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:246)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:188)\nio.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)\njava.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\njava.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\njava.base/java.lang.Thread.run(Thread.java:833)\n",
    "cause": {
      "message": "stackTrace[15]",
      "source": "JavaSDK",
      "stackTrace": "java.base/java.lang.Throwable.setStackTrace(Throwable.java:879)\nio.temporal.failure.FailureConverter.failureToException(FailureConverter.java:85)\nio.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)\nio.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)\nio.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)\nio.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)\nio.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)\nio.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)\nio.temporal.failure.FailureConverter.failureToExceptionImpl(FailureConverter.java:93)\nio.temporal.failure.FailureConverter.failureToException(FailureConverter.java:79)\nio.temporal.internal.sync.SyncWorkflowContext$ActivityCallback.lambda$invoke$0(SyncWorkflowContext.java:292)\nio.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:102)\nio.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:106)\nio.temporal.worker.ActiveThreadReportingExecutor.lambda$submit$0(ActiveThreadReportingExecutor.java:53)\njava.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)\njava.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\njava.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\njava.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\njava.base/java.lang.Thread.run(Thread.java:833)\n",
      "cause": null,
      "applicationFailureInfo": {
        "type": "java.lang.NullPointerException",
        "nonRetryable": false,
        "details": null
      }
    },
    "applicationFailureInfo": {
      "type": "java.lang.RuntimeException",
      "nonRetryable": false,
      "details": null
    }
  },
  "applicationFailureInfo": {
    "type": "io.temporal.internal.statemachines.InternalWorkflowTaskException",
    "nonRetryable": false,
    "details": null
  }
}`

## Steps to Reproduce the Problem

Not enough information

## Specifications

  - SDK Version: 1.17.0
  - Temporal Server Version: 1.22.0
  - Platform: k8s


#### Comments (3)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-01 16:49:58.000 UTC</summary>

You're running on an older SDK version. I believe this issue was fixed in this PR https://github.com/temporalio/sdk-java/pull/1795. Can you please upgrade to the latest Java SDK release `v1.22.0`

</details>

<details>
<summary><strong>brunomascijp</strong> commented on 2023-11-01 16:57:17.000 UTC</summary>

Will try, thanks!

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 14:56:46.000 UTC</summary>

Closing since this is not an SDK issue, feel free to ask general questions on our [forum](https://community.temporal.io/) or [community slack ](https://app.slack.com/client/TNWA8QCGZ/CNWA8QH09)

</details>


---

<a id="1866"></a>

### #1866: Allow to get the retry policy set for execution from client via WorkflowInfo

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1866 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-09-21 15:33:46.000 UTC (2y 3m ago) |
| **Updated** | 2025-05-15 02:47:20.000 UTC |
| **Closed** | 2025-05-15 02:47:19.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement, good first issue |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

It's not advised to set workflow retry policy in almost all cases, but if client does set it for some reason it would be good to 
be able to check it in workflow code via Workflow.getInfo()



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-15 02:47:19.000 UTC</summary>

https://github.com/temporalio/sdk-java/pull/1961

</details>


---

<a id="1799"></a>

### #1799: [Springboot] add support for multiple namespaces

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1799 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-06-27 20:57:59.000 UTC (2y 6m ago) |
| **Updated** | 2025-05-02 20:38:28.000 UTC |
| **Closed** | 2025-05-02 20:38:27.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Add support in springboot integration to create clients and workers with different options including different namespaces

**Describe alternatives you've considered**
Create a springboot application per namespace, doesn't help with cross namespace calls or different client options for different workers in the same namespace

**Additional context**



#### Comments (1)

<details>
<summary><strong>gvsandeep2647</strong> commented on 2025-02-13 05:40:27.000 UTC</summary>

We need this support as well! Thanks for taking this up. 

</details>


---

<a id="1736"></a>

### #1736: Workflow Task Exception eats up the exception sent by code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1736 |
| **State** | CLOSED |
| **Author** | hrishirc (Hrishikesh) |
| **Created** | 2023-03-31 18:51:12.000 UTC (2y 9m ago) |
| **Updated** | 2024-12-23 10:13:12.000 UTC |
| **Closed** | 2024-12-23 10:13:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
After getVersion call, the same workflow task eats up a business logic exception

## Actual Behavior
The exception should not be eaten up. Instead the business logic exception should come in the Temporal UI

## Steps to Reproduce the Problem

  1. Version a piece of code
  1. Send an exception immediately after that line

## Specifications

  - Version: 1.16
  - Platform: Java SDK

https://gist.github.com/hrishirc/68c6fcc23b7c943f858d91fe451f689a

#### Comments (3)

<details>
<summary><strong>hrishirc</strong> commented on 2023-04-18 06:15:27.000 UTC</summary>

any update on this?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-18 23:41:03.000 UTC</summary>

This issue needs a reproduction or more information about the specific code structure causing it.
I wrote [a test verifying the behavior of a simple getVersion + exception right after](https://github.com/temporalio/sdk-java/blob/d1ad622e243501d7c435deda4fe34e60c1be41c7/temporal-sdk/src/test/java/io/temporal/workflow/versionTests/GetVersionFollowedByRandomExceptionTest.java#L54) and verified that it passes against the current master and 1.16.0.

@hrishirc please provide more info on your specific conditions. Unit test demonstrating the behavior is the best.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 10:13:12.000 UTC</summary>

Closing for now as not enough information is here, if more is provided we can reopen

</details>


---

<a id="1684"></a>

### #1684: Closing metric subscopes surprisingly closes the parent scope as well

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1684 |
| **State** | CLOSED |
| **Author** | tylercunnion (Tyler Cunnion) |
| **Created** | 2023-03-03 00:02:13.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-03 00:21:49.000 UTC |
| **Closed** | 2023-03-03 00:08:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Creating a subscope using code such as:
```java
Scope taggedScope = Workflow.getMetricsScope().tagged(
    Map.of("tag", "value")
);
```
produces a new instance of ReplayAwareScope including the tag. Since this is an instance of `Scope` and thus `AutoCloseable`, the IDE is going to suggest it be wrapped in a `try-by-resources` (or at least raise some kind of warning that the object should be closed). 

My **expected behavior** is that invoking `close()` on this object should only close this object itself, ie the subscope would no longer be available for use. 

## Actual Behavior

Closing the subscope invokes the `close()` method of `ReplayAwareScope`, which in turn closes its contained instance of `Scope`; the effect is that the metrics scope for the _entire worker_ is silently closed, and no more metrics will be reported.

## Steps to Reproduce the Problem

  1. Create a subscope using `.tagged()` or `.subscope()`. 
  1. Call the `close()` method, either explicitly or implicitly using `try-with-resources`. 

## Specifications

  - Version: 1.18.2
  - Platform: linux


#### Comments (3)

<details>
<summary><strong>tylercunnion</strong> commented on 2023-03-03 00:04:04.000 UTC</summary>

This may just need to be a documentation enhancement honestly, but it's bitten me twice now (after I completely forgot about the problem between the first and second) so I figured it was worth raising.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-03 00:08:09.000 UTC</summary>

Scope abstraction, contracts and implementation is not Temporal Java SDK abstraction, it‚Äôs uber-tally, our transitive dependency. 
If and when we create our own Scope abstraction, it will be one of the things that we will do differently.
So, while I agree with you on your points in terms of user friendliness, we don‚Äôt control tally‚Äôs abstractions, we use them.

</details>

<details>
<summary><strong>tylercunnion</strong> commented on 2023-03-03 00:21:49.000 UTC</summary>

Got it - I was thinking the issue was specifically ReplayAwareScope closing its inner Scope but I see that tally's subscopes close their reporter as well so it's really moot. Thanks for the quick response!

</details>


---

<a id="1647"></a>

### #1647: Allow WorkflowImplementationOptions to be set via config for Spring Boot 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1647 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-02-11 00:48:20.000 UTC (2y 11m ago) |
| **Updated** | 2025-05-01 23:12:00.000 UTC |
| **Closed** | 2025-05-01 23:11:42.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

Currently its not possible to set WorkflowImplementationOptions via config in Spring Boot integration

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-01 23:11:33.000 UTC</summary>

Folding into https://github.com/temporalio/sdk-java/issues/1984

</details>


---

<a id="1540"></a>

### #1540: Test service time skipping broken in a child workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1540 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-11-26 20:32:01.000 UTC (3y 1m ago) |
| **Updated** | 2025-05-15 02:20:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Workflow.sleep in a child workflow uses time skipping with a test service.

## Actual Behavior
When a parent calls continue-as-new time skipping in a child is not happening.

## Steps to Reproduce the Problem

See https://github.com/temporalio/sdk-java/pull/1539 for reproduction.


#### Comments (3)

<details>
<summary><strong>pompalive</strong> commented on 2023-01-30 09:48:37.000 UTC</summary>

@Spikhalskiy Would you please suggest on the plan to fix this issue and #1618?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-01 18:45:12.000 UTC</summary>

@pompalive We don't typically provide timelines, especially for issues related to the testing framework. Temporal is open source and we do accept contributions. 

</details>

<details>
<summary><strong>pompalive</strong> commented on 2023-02-03 01:52:36.000 UTC</summary>

Thanks for the reply. I will wait for fix.

</details>


---

<a id="1516"></a>

### #1516: spring-boot-dependencies-2.7.5.pom: 7 vulnerabilities (highest severity is: 9.8) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1516 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-11-15 16:25:50.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-09 02:40:29.000 UTC |
| **Closed** | 2022-12-09 02:40:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-dependencies-2.7.5.pom</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-autoconfigure-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-dependencies version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-1471](https://www.mend.io/vulnerability-database/CVE-2022-1471) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 9.8 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-25857](https://www.mend.io/vulnerability-database/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-41854](https://www.mend.io/vulnerability-database/CVE-2022-41854) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38749](https://www.mend.io/vulnerability-database/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38752](https://www.mend.io/vulnerability-database/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38751](https://www.mend.io/vulnerability-database/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38750](https://www.mend.io/vulnerability-database/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the section "Details" below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-1471</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.5.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content to restrict deserialization.

<p>Publish Date: 2022-12-01
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-1471>CVE-2022-1471</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>9.8</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-1471">https://nvd.nist.gov/vuln/detail/CVE-2022-1471</a></p>
<p>Release Date: 2022-12-01</p>
<p>Fix Resolution: org.yaml:snakeyaml - 1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.5.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-41854</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.5.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Those using Snakeyaml to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack overflow. This effect may support a denial of service attack.

<p>Publish Date: 2022-11-11
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-41854>CVE-2022-41854</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/531/">https://bitbucket.org/snakeyaml/snakeyaml/issues/531/</a></p>
<p>Release Date: 2022-11-11</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.32</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.5.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.5.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.32
</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.5.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.5.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details>

#### Comments (3)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-11-24 04:47:15.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-12-06 05:54:53.000 UTC</summary>

:information_source: This issue was automatically re-opened by Mend because the vulnerable library in the specific branch(es) has been detected in the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-12-09 02:40:29.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1504"></a>

### #1504: Don't request eager activities when worker started with no activities configured

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1504 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-11-04 00:49:10.000 UTC (3y 2m ago) |
| **Updated** | 2023-01-26 21:38:20.000 UTC |
| **Closed** | 2023-01-26 20:21:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

When worker is configured without any registered activity implementations, activity worker is not getting started.
Such workers should never request eager activity dispatch, as there is no activity worker to handle them.
See for the related change in Core: https://github.com/temporalio/sdk-core/pull/431#pullrequestreview-1167798728

#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-26 20:21:34.000 UTC</summary>

This is already implemented correctly:
https://github.com/temporalio/sdk-java/blob/f389bd8e9cd8956213466e705d5e2a36978aea65/temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java#L382
https://github.com/temporalio/sdk-java/blob/f389bd8e9cd8956213466e705d5e2a36978aea65/temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java#L94

</details>

<details>
<summary><strong>bergundy</strong> commented on 2023-01-26 21:33:50.000 UTC</summary>

Can you please re-enable the features test?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-26 21:37:33.000 UTC</summary>

@bergundy actually this was implemented when that test was failing, there is nothing new here... Most likely a problem is with the test itself. I will take a look.

</details>


---

<a id="1493"></a>

### #1493: spring-boot-starter-2.7.5.jar: 7 vulnerabilities (highest severity is: 8.3) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1493 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-10-24 17:05:43.000 UTC (3y 2m ago) |
| **Updated** | 2022-12-06 05:55:00.000 UTC |
| **Closed** | 2022-12-06 05:54:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-starter-2.7.5.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-starter version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-1471](https://www.mend.io/vulnerability-database/CVE-2022-1471) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 8.3 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-25857](https://www.mend.io/vulnerability-database/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-41854](https://www.mend.io/vulnerability-database/CVE-2022-41854) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38749](https://www.mend.io/vulnerability-database/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38752](https://www.mend.io/vulnerability-database/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38751](https://www.mend.io/vulnerability-database/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38750](https://www.mend.io/vulnerability-database/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-1471</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.5.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content to restrict deserialization.

<p>Publish Date: 2022-12-01
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-1471>CVE-2022-1471</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>8.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: Low
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-1471">https://nvd.nist.gov/vuln/detail/CVE-2022-1471</a></p>
<p>Release Date: 2022-12-01</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.5.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-41854</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.5.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Those using Snakeyaml to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack overflow. This effect may support a denial of service attack.

<p>Publish Date: 2022-11-11
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-41854>CVE-2022-41854</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/531/">https://bitbucket.org/snakeyaml/snakeyaml/issues/531/</a></p>
<p>Release Date: 2022-11-11</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.5.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.5.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.5.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.5.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/d16649895e8e76cc3cbc5d8c30b94df45af0d493">d16649895e8e76cc3cbc5d8c30b94df45af0d493</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (3)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-11-15 16:25:53.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-11-24 04:47:13.000 UTC</summary>

:information_source: This issue was automatically re-opened by Mend because the vulnerable library in the specific branch(es) has been detected in the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-12-06 05:55:00.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1488"></a>

### #1488: Spring Boot - add config options for WorkerFactory and Workers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1488 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-10-19 15:38:04.000 UTC (3y 2m ago) |
| **Updated** | 2023-01-31 01:06:06.000 UTC |
| **Closed** | 2023-01-31 01:06:05.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |
| **Reactions** | üëç 1 |

#### Description

Currently it's not possible to define worker factory and worker options via properties/yaml config.

Seems only way is to autowire WorkerFactory and create own workers that then can be configured as needed.

Please add this feature if possible. Thanks.

#### Comments (1)

<details>
<summary><strong>dominicmevin</strong> commented on 2022-10-19 16:07:29.000 UTC</summary>

+1

The doc for the spring-boot autoconfigure module says the below
>  '# start-workers: false # disable starting WorkersFactory if you want to make any custom changes before the start'

But this flag just defers the `factory.start()` call as can be seen [here](https://github.com/temporalio/sdk-java/blob/a927dd45ac2e6e0cd98deedc2f3952df58f33ff2/temporal-spring-boot-autoconfigure-alpha/src/main/java/io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.java#L145), but can't override or make custom changes to the workers already created by the module [here](https://github.com/temporalio/sdk-java/blob/a927dd45ac2e6e0cd98deedc2f3952df58f33ff2/temporal-spring-boot-autoconfigure-alpha/src/main/java/io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.java#L135), say in terms of passing in `WorkerOptions` for tuning them.

Defining  worker options via properties/yaml config allows to mitigate the above constraint.


</details>


---

<a id="1411"></a>

### #1411: temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT: 5 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1411 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-09-08 15:50:00.000 UTC (3y 4m ago) |
| **Updated** | 2022-10-13 21:08:27.000 UTC |
| **Closed** | 2022-10-13 21:08:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT</b></p></summary>

<p></p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/2c29eda4558f4063804c816481a9f9acf132f65c">2c29eda4558f4063804c816481a9f9acf132f65c</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-25857](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38749](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38752](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38751](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38750](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT (Root Library)
    - spring-boot-dependencies-2.7.4.pom
      - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/2c29eda4558f4063804c816481a9f9acf132f65c">2c29eda4558f4063804c816481a9f9acf132f65c</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT (Root Library)
    - spring-boot-dependencies-2.7.4.pom
      - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/2c29eda4558f4063804c816481a9f9acf132f65c">2c29eda4558f4063804c816481a9f9acf132f65c</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT (Root Library)
    - spring-boot-dependencies-2.7.4.pom
      - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/2c29eda4558f4063804c816481a9f9acf132f65c">2c29eda4558f4063804c816481a9f9acf132f65c</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.32
</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT (Root Library)
    - spring-boot-dependencies-2.7.4.pom
      - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/2c29eda4558f4063804c816481a9f9acf132f65c">2c29eda4558f4063804c816481a9f9acf132f65c</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - temporal-spring-boot-autoconfigure-alpha-1.17.0-SNAPSHOT (Root Library)
    - spring-boot-dependencies-2.7.4.pom
      - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/2c29eda4558f4063804c816481a9f9acf132f65c">2c29eda4558f4063804c816481a9f9acf132f65c</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details>

#### Comments (3)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-09-20 13:48:50.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-09-26 17:22:49.000 UTC</summary>

:information_source: This issue was automatically re-opened by Mend because the vulnerable library in the specific branch(es) has been detected in the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-10-13 21:08:27.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1400"></a>

### #1400: spring-boot-starter-2.7.3.jar: 5 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1400 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-08-31 01:15:36.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-26 17:22:52.000 UTC |
| **Closed** | 2022-09-26 17:22:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-starter-2.7.3.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-25857](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38749](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38752](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38751](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38750](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.3.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.3.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.3.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.32
</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.3.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.3.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details>

#### Comments (3)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-09-08 15:50:06.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-09-20 13:48:47.000 UTC</summary>

:information_source: This issue was automatically re-opened by Mend because the vulnerable library in the specific branch(es) has been detected in the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-09-26 17:22:52.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1395"></a>

### #1395: Workflow failed by Worker after DEADLINE_EXCEEDED is thrown by WorkflowHistoryIterator

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1395 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-30 02:03:22.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-07 19:20:29.000 UTC |
| **Closed** | 2022-08-30 15:55:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

## Expected Behavior

If WorkflowHistoryIterator throws StatusRuntimeException with DEADLINE_EXCEEDED code during reading from the remote Service, the Worker should be failing Workflow Task, not a Workflow Execution. This will allow the workers to retry the task and recover.

## Actual Behavior

One user reports a Workflow failure:

```
"workflowExecutionFailedEventAttributes": {
  "failure": {
    "message": "io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 9.999730494s. [closed=[], open=[[remote_addr=temporal-server.prod-grpc.uni.club/10.10.106.219:80]]]",
    "source": "JavaSDK",
    "stackTrace": "io.temporal.internal.replay.WorkflowHistoryIterator.queryWorkflowExecutionHistory(WorkflowHistoryIterator.java:130)\nio.temporal.internal.replay.WorkflowHistoryIterator.hasNext(WorkflowHistoryIterator.java:84)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:190)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:137)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:129)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:98)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:293)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:237)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:178)\nio.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)\nco.elastic.apm.agent.concurrent.JavaConcurrent$RunnableLambdaWrapper.run(JavaConcurrent.java:237)\njava.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\njava.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\njava.base/java.lang.Thread.run(Thread.java:834)\n",
    "cause": {
      "message": "DEADLINE_EXCEEDED: deadline exceeded after 9.999730494s. [closed=[], open=[[remote_addr=temporal-server.prod-grpc.uni.club/10.10.106.219:80]]]",
      "source": "JavaSDK",
      "stackTrace": "io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:271)\nio.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:252)\nio.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:165)\nio.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.getWorkflowExecutionHistory(WorkflowServiceGrpc.java:3222)\nio.temporal.internal.replay.WorkflowHistoryIterator.lambda$queryWorkflowExecutionHistory$0(WorkflowHistoryIterator.java:127)\nio.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:60)\nio.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:66)\nio.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:60)\nio.temporal.internal.replay.WorkflowHistoryIterator.queryWorkflowExecutionHistory(WorkflowHistoryIterator.java:122)\nio.temporal.internal.replay.WorkflowHistoryIterator.hasNext(WorkflowHistoryIterator.java:84)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:190)\nio.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:137)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:129)\nio.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:98)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:293)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:237)\nio.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:178)\nio.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)\nco.elastic.apm.agent.concurrent.JavaConcurrent$RunnableLambdaWrapper.run(JavaConcurrent.java:237)\njava.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\njava.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\njava.base/java.lang.Thread.run(Thread.java:834)\n",
      "cause": null,
      "applicationFailureInfo": {
        "type": "io.grpc.StatusRuntimeException",
        "nonRetryable": false,
        "details": null
      }
    },
    "applicationFailureInfo": {
      "type": "java.lang.Error",
      "nonRetryable": false,
      "details": null
    }
  },
  "retryState": "RetryPolicyNotSet",
  "workflowTaskCompletedEventId": "2748",
  "newExecutionRunId": ""
}
```

The user claims that `WorkflowImplementationOptions.setFailWorkflowExceptionTypes` is not set.

## Specifications

Java SDK Version: 1.14.0

## Additional context

Investigation and fix of this bug should be paired together with https://github.com/temporalio/sdk-java/issues/1242


#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-30 15:50:46.000 UTC</summary>

I don‚Äôt confirm it is a problem with JavaSDK. 
How I was trying to reproduce it: I mocked the iterator to return an Error in different scenarios trying to reproduce it.

the only way to get this behavior (failure of Workflow Execution on this failure) is to have `failWorkflowExceptionTypes` set with Throwable or Error.
If this is the case, [the Error](https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java#L130)
is [getting checked](https://github.com/temporalio/sdk-java/blob/9e78e8a278005d8e0c85d788af8040b058c0622d/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowRunTaskHandler.java#L201) against `failWorkflowExceptionTypes` and if it matches and is wrapped into `WorkflowExecutionException`, the workflow execution is [getting failed](https://github.com/temporalio/sdk-java/blob/5079086e065adc64aa3d17e505482785f0f51dfe/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowTaskHandler.java#L244).

There is no code path that may lead to workflow execution failure on this Error if `failWorkflowExceptionTypes` is not set.


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-30 15:55:49.000 UTC</summary>

Feel free to reopen if there is a reproduction.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-07 19:20:28.000 UTC</summary>

An actual reason for this problem: https://github.com/temporalio/sdk-java/issues/1408
Also a relevant change: https://github.com/temporalio/sdk-java/pull/1404

</details>


---

<a id="1369"></a>

### #1369: Calling synchronous workflow stub should propagate workflow exceptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1369 |
| **State** | CLOSED |
| **Author** | Bennett-Lynch (Bennett Lynch) |
| **Created** | 2022-08-16 00:04:12.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-16 02:36:14.000 UTC |
| **Closed** | 2022-08-16 00:08:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | documentation, invalid |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Steps to repro:
1. Create a trivial workflow impl that only throws an exception
2. Create a standard unit test with `TestWorkflowExtension` and register the workflow type
3. Call the workflow stub synchronously
4. Workflow method will forever-block, although the exception is logged in the Temporal workers

So far I've only encountered this in unit tests. Unsure if the same behavior applies to a real Temporal server.

Version: 1.14.0

#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-16 00:08:35.000 UTC</summary>

Throw ApplicationFailure to fail a workflow. Any other exception other than subclasses of TemporalFailure lead to failure of a workflow task, not a whole workflow.
This is a design choice that was made to allow users to fix unexpected exceptions, redeploy the fix and continue execution instead of failing the workflow.
If you check the history of the workflow in question, you will find that workflow is not in a failed state.

Close as it works as designed. 

</details>

<details>
<summary><strong>Bennett-Lynch</strong> commented on 2022-08-16 00:10:19.000 UTC</summary>

I see. Thank you @Spikhalskiy. Apologies for not better reading the docs.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-16 00:11:55.000 UTC</summary>

@Bennett-Lynch No worries. We are planning to release a separate doc page covering failures and exceptions handling. We are not doing a great job explaining intricacies like that right now. 

</details>


---

<a id="1291"></a>

### #1291: Workflow execution with Workflow.await(condition) times out in unit tests with enabled time skipping

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1291 |
| **State** | OPEN |
| **Author** | ddavidyuk |
| **Created** | 2022-06-28 20:04:01.000 UTC (3y 6m ago) |
| **Updated** | 2024-11-19 19:05:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëÄ 1 |

#### Description

## Expected Behavior
The unit test below should always pass

## Actual Behavior
Sometimes the test fails with io.temporal.client.WorkflowNotFoundException. Changing `Workflow.await(condition)` to `Workflow.await(Duration.ofSeconds(100), condition)` in `TestWorkflowImpl` seems to fix the problem, but not sure why.
Attached are the TRACE logs for io.temporal for when the issue reproduces: [bug.log](https://github.com/temporalio/sdk-java/files/9004428/bug.log)


## Steps to Reproduce the Problem
Run the following test:
```java
import io.temporal.activity.ActivityOptions;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowOptions;
import io.temporal.client.WorkflowStub;
import io.temporal.testing.TestWorkflowEnvironment;
import io.temporal.testing.TestWorkflowExtension;
import io.temporal.worker.Worker;
import io.temporal.worker.WorkflowImplementationOptions;
import io.temporal.workflow.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import java.time.Duration;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class WorkflowExecutionTimeoutTest {
    @RegisterExtension
    public static final TestWorkflowExtension TEST_WORKFLOW_EXTENSION =
            TestWorkflowExtension.newBuilder()
                    .setDoNotStart(true)
                    .build();

    private ProcessEventsWorkflow processWorkflowStub;
    private TestWorkflow testWorkflowStub;

    @BeforeEach
    public void setUpTemporal(TestWorkflowEnvironment testEnv,
                              Worker worker,
                              WorkflowClient workflowClient,
                              WorkflowOptions workflowOptions) {
        worker.registerWorkflowImplementationTypes(
                WorkflowImplementationOptions.newBuilder()
                        .setDefaultActivityOptions(ActivityOptions.newBuilder()
                                .setStartToCloseTimeout(Duration.ofSeconds(10))
                                .build())
                        .build(),
                ProcessEventsWorkflowImpl.class,
                TestWorkflowImpl.class);

        testEnv.start();

        processWorkflowStub = workflowClient.newWorkflowStub(ProcessEventsWorkflow.class,
                WorkflowOptions.newBuilder(workflowOptions)
                        .setWorkflowId("ProcessEventsWorkflow")
                        .build());
        testWorkflowStub = workflowClient.newWorkflowStub(TestWorkflow.class,
                WorkflowOptions.newBuilder(workflowOptions)
                        .setWorkflowId("TestWorkflow")
                        .build());
    }

    @Test
    public void testBug() throws TimeoutException {
        // create artificial load to reproduce the bug - seems to help, but still the bug does not always reproduce
        IntStream.range(0, 20).forEach(index -> new Thread(this::busyWork).start());

        WorkflowClient.start(testWorkflowStub::execute);

        WorkflowStub.fromTyped(processWorkflowStub).signalWithStart("addEvent",
                new Object[]{"testEvent"},
                new Object[]{"TestWorkflow", Duration.ofSeconds(1)});
        WorkflowStub.fromTyped(processWorkflowStub).getResult(10, TimeUnit.SECONDS, Object.class);

        testWorkflowStub.stop(); // <----- fails here
        WorkflowStub.fromTyped(testWorkflowStub).getResult(10, TimeUnit.SECONDS, Object.class);

        assertEquals(Arrays.asList("testEvent"), testWorkflowStub.getEvents());
    }

    private void busyWork() {
        int count = 100000000;
        int sleepIndex = (int) (Math.random() * count);
        while(count-- > 0) {
            if (sleepIndex == count) { // yield at random intervals
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }

            Math.sqrt(count);
        }
    }


    @WorkflowInterface
    public interface ProcessEventsWorkflow {
        @WorkflowMethod
        void execute(String targetWorkflowId, Duration keepAliveTimeout);
        @SignalMethod
        void addEvent(String event);
    }

    public static class ProcessEventsWorkflowImpl implements ProcessEventsWorkflow {
        private final Queue<String> events = new LinkedList<>();

        @Override
        public void execute(String targetWorkflowId, Duration keepAliveTimeout) {
            while (true) {
                while (!events.isEmpty()) {
                    String event = events.poll();
                    Workflow.newExternalWorkflowStub(TestWorkflow.class, targetWorkflowId).onEvent(event);
                }

                Workflow.await(keepAliveTimeout, () -> !events.isEmpty());
                if (events.isEmpty()) {
                    return;
                }
            }
        }

        @Override
        public void addEvent(String event) {
            events.add(event);
        }
    }

    @WorkflowInterface
    public interface TestWorkflow {
        @WorkflowMethod
        void execute();

        @SignalMethod
        void stop();

        @SignalMethod
        void onEvent(String event);

        @QueryMethod
        List<String> getEvents();
    }

    public static class TestWorkflowImpl implements TestWorkflow {
        private boolean stop = false;
        private final List<String> events = new ArrayList<>();

        @Override
        public void execute() {
            Workflow.await(() -> stop);
        }

        @Override
        public void stop() {
            stop = true;
        }

        @Override
        public void onEvent(String event) {
            events.add(event);
        }

        @Override
        public List<String> getEvents() {
            return events;
        }
    }
}

```

## Specifications

  - Version: Temporal Java SDK 1.11.0, 1.12.0, 1.13.0 (reproduces on all of these), Temporal Server 1.16.2
  - Platform: Java


#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-06-29 04:25:42.000 UTC</summary>

Confirm the issue. It's related to the peculiarities of time skipping, how it's implemented, and an absence of total order between some operations in Temporal.
When you create a load, the client code doesn't stop time skipping soon enough and the time gets advanced A LOT to the workflow task timeout which completed the workflow and doesn't allow the signal to pass through. And there is no way for the server to make sure that the code that is supposed to be executed by the client after a long poll is returned is actually finished executing.

The fix here is not trivial. It's also related only to the test framework and not the core functionality.
I will think about the best fix here, but I have to temporarily deprioritize it behind some other tasks affecting an actual production functionality.

</details>

<details>
<summary><strong>ddavidyuk</strong> commented on 2022-06-29 06:02:58.000 UTC</summary>

Thank you! Could you confirm if the suggested workaround should work? If I change Workflow.await(condition) to Workflow.await(timeout, condition), the issue seems to stop reproducing at least locally. Is this a reliable workaround?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-06-29 14:16:18.000 UTC</summary>

No, it's not. The same "bug" or... limitation will trigger your `Workflow.await(timeout, condition)` earlier than you expect it, like its triggering workflow timeout now. I think the only gentle workaround here is not to set Workflow Timeout of any kind or don't use time skipping for such a test.

</details>


---

<a id="1281"></a>

### #1281: Local Activity asynchronously started at the end of the workflow implementation leads to failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1281 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-25 01:19:00.000 UTC (3y 6m ago) |
| **Updated** | 2024-09-18 23:36:04.000 UTC |
| **Closed** | 2024-09-18 23:36:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

```
    @Override
    public void wofklowMethod() {
      Async.procedure(activity::execute);
    }
```

An activity scheduled at the end of the workflow code asynchronously without waiting on the promise should be ignored.
Alternatively, it may be executed. 
Such a code shouldn't block workflow completion, it's not an invalid workflow implementation.

## Actual Behavior

It leads to
`io.grpc.StatusRuntimeException: NOT_FOUND: workflow execution already completed` exception on worker with workflow never completing.

## Steps to Reproduce the Problem
Unit test: https://github.com/Spikhalskiy/java-sdk/commit/718fe8e794a50188c639e79a6ee47576960ae353



#### Comments (3)

<details>
<summary><strong>bergundy</strong> commented on 2022-06-25 03:39:52.000 UTC</summary>

@Spikhalskiy please add to sdk features. Not 100% sure we put it there

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-20 18:07:48.000 UTC</summary>

Related to #1722

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-18 23:36:04.000 UTC</summary>

https://github.com/temporalio/sdk-java/commit/8b3be3bb521f7ab62b7d384ee417d053286a95d5

</details>


---

<a id="1260"></a>

### #1260: Multiple workers reporting workflow gauges

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1260 |
| **State** | CLOSED |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2022-06-13 23:41:34.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-14 03:09:18.000 UTC |
| **Closed** | 2022-06-14 02:48:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | invalid, wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I would expect that when using `Workflow.getMetricScope().gauge("foo")` within a long-lived workflow execution, only a single worker would report this metric.

## Actual Behavior
If the workflow that emits a gauge is scheduled across multiple nodes, then each node is emitting a gauge value but all nodes except the latest one to report gauge are continuing to report outdated gauge values.

It's possible that this is an issue in [spectator](https://github.com/Netflix/spectator). If that is indeed the case, it would be great if the Java SDK could add a listener interface around workflow scheduling (e.g. being able to to listen for when workflows stop running on a worker) so we can evict metric gauges from the registry.

## Steps to Reproduce the Problem

  1. Define a gauge, set a value in a `Workflow.await`
  1. Reschedule the workflow to a different worker

## Specifications

  - Version: 1.12.0
  - Platform: 1.16.2 


#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-06-14 02:22:02.000 UTC</summary>

We don't really implement metrics. The gauge that you access is just a standard direct micrometer gauge.

> If the workflow that emits a gauge is scheduled across multiple nodes, then each node is emitting a gauge value but all nodes except the latest one to report gauge are continuing to report outdated gauge values.

This does sound like the correct behavior of a gauge. Each of these nodes has its own gauge and it's reporting its node's last value.
What is a typical example of a gauge? It's an amount of available ram for example. Each node emits its own metric. Or for Temporal workers, an example of a gauge is the number of available executor threads. This gauge is also host-specific.

> I would expect that when using Workflow.getMetricScope().gauge("foo") within a long-lived workflow execution, only a single worker would report this metric.

It's not expected behavior. If workflow moves to another worker, that worker will be reporting its own gauge with the same name that is created for that worker.
This gauge is not some magic Temporal Workflow aware Gauge. It's a standard gauge in this host's metrics set. The only additional functionality that we have in JavaSDK is deduping metrics during replay. https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java#L946

> I would expect that when using Workflow.getMetricScope().gauge("foo") within a long-lived workflow execution, only a single worker would report this metric.

The text of this issue looks like you are emitting a unique gauge for each workflow. This is a bad idea and an antipattern. You will kill your metric system if you have any decent amount of workflows. You will also get a memory leak in tally / java-sdk. See https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L52
The set of metrics should be static and limited per worker / JVM process, not per workflow.

You should approach these gauges as a per-worker construct.

I never heard about global gauges that synchronize value across nodes, it's not how metric systems work to my knowledge. 
In Prometheus (let's say) metrics are collected per reporting process, including gauges. Temporal has no intention to go into redesigning this part, it's way too far from our business. If you want to aggregate/process the gauges values across worker nodes - you need to write your own logic/query for your metric system.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-06-14 02:48:59.000 UTC</summary>

Described behavior is aligned with expected behavior of a worker gauge. 
`Workflow.getMetricScope().gauge()` returns a gauge of a current WORKER. The described behavior is aligned with the normal behavior of a host metric's gauge.
`Workflow.getMetricScope().gauge()` doesn't return a gauge isolated to a specific workflow. This abstraction doesn't exist and it's not a goal of this method. 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-06-14 02:59:42.000 UTC</summary>

@robzienert feel free to reach out to me on the community Slack to discuss it if you disagree and it looks off.

</details>


---

<a id="1246"></a>

### #1246: Query is not picked up by the worker executing local activity for more than a minute

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1246 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-06-02 22:49:30.000 UTC (3y 7m ago) |
| **Updated** | 2022-08-10 22:14:17.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

Currently client query calls that "hang" (don't return a result) do that for 60 seconds (max workflow task timeout?) at which point client gets delivered WorkflowServiceException that includes StatusRuntimeException (context deadline exceeded). 
The client call should instead fail with WorkflowServiceException according to rpcTimeout (default 10s). 

Not a proper sdk sample, but https://gist.github.com/tsurdilo/57282199bc8534c3838252f1c4bf58fc
shows this (query hangs for 60 seconds while local activity is retrying).



#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-10 22:14:17.000 UTC</summary>

Most likely directly related to #1346 and the structure of the current workflow task execution flow

</details>


---

<a id="1093"></a>

### #1093: Add ResetWorkflowExecution support in Test Server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1093 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-03-22 22:19:05.000 UTC (3y 9m ago) |
| **Updated** | 2024-12-17 21:26:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently when you try to use ResetWorkflowExecution with the client from TestWorkflowEnvironment with in-memory Test Server you get:

```
       io.grpc.StatusRuntimeException: UNIMPLEMENTED: Method temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution is unimplemented
```

Would be nice to add support for it in the future. Thanks.

#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-22 22:22:52.000 UTC</summary>

You can use dockerized temporal for tests that have to cover reset of the workflow. 
We may consider implementing some simplified version of a reset in the test server in the future.

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2022-03-22 22:37:56.000 UTC</summary>

Yeah, forgot to mention this is when setUseExternalService is not set to true

</details>

<details>
<summary><strong>parth-kulkarni-db</strong> commented on 2023-04-13 05:58:09.000 UTC</summary>

Is there any update if this is added in Test Server in Apr 23?

</details>


---

<a id="1010"></a>

### #1010: Workflow should have an access to an activity id of the activity it scheduled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1010 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-30 07:40:42.000 UTC (3y 11m ago) |
| **Updated** | 2024-12-17 21:26:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
There is a scenario when a workflow needs to cancel an activity if it gets an external signal.

For example, an activity sends its own id to some external code and this code has a need to cancel the activity if something happens or finishes before the activity is done. 
Right now the only way for an external code to cancel an activity in progress is to send a signal to the workflow that scheduled the activity and the workflow cancels the activity using a cancelation scope after that.

To do that, the activity can't use an `activityId`, the user needs to create some new correlation id and pass it from the workflow into the activity because an activity code has no way to know an `activityId` of the activity it just scheduled. 

**Describe the solution you'd like**
1. We create some kind of `ActivityInvocationStub` for each invocation of an activity. This stub may bind an activityType and any kind of additional parameters we need to set per each invocation. This stub can also expose the `activityId`.  User may not be required to work with such stubs all the time if they don't need them, but they should be available if the user needs them (the same way as untyped `WorkflowStub`s are implemented)
1. Workflow should be able to generate and pass an `activityId` into such kind of stub. We should be careful with that, because `activityId`s in JavaSDK are used to ensure determinism and identify a state machine, so duplicates should be prohibited.

Such a stub should also potentially be able to override `ActivityOptions` for the specific activity call.

**Describe alternatives you've considered**
Change nothing and make users pass their own additional ids (and maintain a mapping between these ids to the cancelation scopes or the activities) if they need the workflow to be able to address and cancel an activity later. But there are other reasons to have such stubs: #1009

**Additional context**
What about timers for example? Should the same apply to timers and their ids?


#### Comments (3)

<details>
<summary><strong>longquanzheng</strong> commented on 2022-02-02 19:19:05.000 UTC</summary>

This is also really important for using async activity completion. On server side, activity can be completed with tasktoken or activityID. But JavaSDK only expose tasktoken.

The task token approach is problematic in some cases ‚Äî
By nature user needs to set a long timeout(startToClose) because they don‚Äôt know when the external system will complete the activity.
The tasktoken can only be retrieved within the activity(for determinism) and send to the external system, before calling ctx.doNotCompleteOnReturn();
However, there could be errors(e.g. timeout) and retry when sending the tasktoken, and then the activity worker can get restarted.
As a result, the activity will be stuck until the timeout‚Ä¶

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-02-02 21:49:12.000 UTC</summary>

External code that uses async activity completion should always be triggered by the activity itself. When this happens, an activity should pass activityId/taskToken to that code.
There should be no code that uses some predefined activityId, but is not triggered by this activity itself. Activity (and its ID) is an internal entity of a workflow and not it's public API.
Workflow and its ID is a business-level entity, Activity and ActivityId is a workflow implementation detail. This implementation detail may be known by, in turn, it's own implementation detail (code that is triggered by it), but it shouldn't be known by some external code not directly triggered by the activity itself. 
For that purpose, there are signals. Signals have predefined names and are exposed on the business level entity - workflow.

An activity execution already has its own id now and can pass it to the code performing the completion. Thus, this task is not a prerequisite for an activity completion in a way how it's intended to be used.


</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2022-02-03 00:56:25.000 UTC</summary>

> An activity execution already has its own id now and can pass it to the code performing the completion.

Passing the ID within the activity is not reliable. We should redesign this part for async activity completion. 

What if activity worker restarted when the RPC of sending ID/token timeout and retry?
This will cause the activity stuck forever, unless we require the activity to implement heartbeat.Implementing heartbeat will be tedious and extremely inefficient -- will cost lots of API requests to server. 

</details>


---

<a id="835"></a>

### #835: Workflow search queries APIs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/835 |
| **State** | CLOSED |
| **Author** | akdoan1 (Alex Doan) |
| **Created** | 2021-10-22 19:09:49.000 UTC (4y 2m ago) |
| **Updated** | 2024-09-18 23:30:18.000 UTC |
| **Closed** | 2024-09-18 23:30:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**
* I would like to use the Java SDK to query [elasticsearch] for open workflow executions like in Go: https://pkg.go.dev/go.temporal.io/sdk/client#Client.ListOpenWorkflow.
* I'm sure that other workflow search queries would be useful here too. 

**Describe alternatives you've considered**
* query elasticsearch directly

**Additional context**
Add any other context or screenshots about the feature request here.

---

Edit: Apologies, found updates right after posting: https://github.com/temporalio/samples-java/blob/16982c43266d4ae3abfa7009fb3a188d1fa11c1a/src/test/java/io/temporal/samples/listworkflows/ListWorkflowsTest.java

#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-22 19:29:13.000 UTC</summary>

This sample (https://github.com/temporalio/samples-java/blob/16982c43266d4ae3abfa7009fb3a188d1fa11c1a/src/test/java/io/temporal/samples/listworkflows/ListWorkflowsTest.java) uses grpc stubs directly and raw protobuf entities, which not an ideal experience that we want to expose for users for any function officially supported by our SDK.
I will leave this ticket open for now until we discuss it from a product perspective.
I think the question that we should be asking here is if SDK should expose each and every server API and if `listWorkflows` is something that even should be a part of SDK. Because from some point of view, it's an admin/cluster operator API and functionality that probably shouldn't be used by the application code at all. 
If this is our officially supported feature of SDK, we should provide an access that doesn't require digging into gRPC stubs and photo Request/Responses. It should be either a call on `WorkflowClient` or another user-facing class like that.

</details>

<details>
<summary><strong>akdoan1</strong> commented on 2021-10-22 19:40:59.000 UTC</summary>

In that case, I'd also wonder if these types of operations should live on a "Workflow"Client or some dedicated admin client to interface with the server or es. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-18 23:30:18.000 UTC</summary>

Closing as duplicate https://github.com/temporalio/sdk-java/issues/1552

</details>


---

<a id="630"></a>

### #630: Flaky testShouldReturnQueryResultAfterWorkflowTimeout

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/630 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-15 03:11:07.000 UTC (4y 4m ago) |
| **Updated** | 2024-12-17 21:20:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior

java-sdk builds in buildkite started to fail often on flaky `TerminatedWorkflowQueryTest#testShouldReturnQueryResultAfterWorkflowTimeout`

## Stacktrace from a locally reproduced failure:

```
io.temporal.client.WorkflowQueryException: workflowId='fa83465b-18c6-424c-a959-0259996b2876', runId='72baee4f-8b00-4914-aace-db0d505606ed', workflowType='testActivity'}
	at io.temporal.internal.sync.WorkflowStubImpl.query(WorkflowStubImpl.java:349)
	at io.temporal.testing.TestWorkflowEnvironmentInternal$TimeLockingInterceptor$TimeLockingWorkflowStub.query(TestWorkflowEnvironmentInternal.java:369)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.queryWorkflow(WorkflowInvocationHandler.java:309)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:272)
	at io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)
	at com.sun.proxy.$Proxy20.getTrace(Unknown Source)
	at io.temporal.workflow.TerminatedWorkflowQueryTest.testShouldReturnQueryResultAfterWorkflowTimeout(TerminatedWorkflowQueryTest.java:64)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at io.temporal.testing.TestWorkflowRule$2.evaluate(TestWorkflowRule.java:273)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:299)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:293)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: io.grpc.StatusRuntimeException: INVALID_ARGUMENT: java.lang.IllegalArgumentException: Unknown query type: getTrace, knownTypes=[]
	at io.temporal.internal.sync.QueryDispatcher.handleQuery(QueryDispatcher.java:79)
	at io.temporal.internal.sync.SyncWorkflowContext.handleQuery(SyncWorkflowContext.java:244)
	at io.temporal.internal.sync.WorkflowExecuteRunnable.handleQuery(WorkflowExecuteRunnable.java:76)
	at io.temporal.internal.sync.SyncWorkflow.query(SyncWorkflow.java:179)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.query(ReplayWorkflowExecutor.java:137)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleQueryWorkflowTask(ReplayWorkflowRunTaskHandler.java:255)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleQueryOnlyWorkflowTask(ReplayWorkflowTaskHandler.java:257)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:112)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:319)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:279)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.queryWorkflow(WorkflowServiceGrpc.java:2970)
	at io.temporal.internal.external.GenericWorkflowClientExternalImpl.lambda$query$5(GenericWorkflowClientExternalImpl.java:216)
	at io.temporal.serviceclient.GrpcRetryer.retryWithResult(GrpcRetryer.java:95)
	at io.temporal.internal.external.GenericWorkflowClientExternalImpl.query(GenericWorkflowClientExternalImpl.java:209)
	at io.temporal.internal.client.RootWorkflowClientInvoker.query(RootWorkflowClientInvoker.java:142)
	at io.temporal.internal.sync.WorkflowStubImpl.query(WorkflowStubImpl.java:342)
	... 19 more
```

#### Comments (3)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-08 18:47:23.000 UTC</summary>

Related to #391 and shows that the #391 issue wasn't addressed by #531

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-09-16 04:46:29.000 UTC</summary>

After some investigation, I've found that the issue is happening because when workflow task times out and we replay the history
```
EVENT_TYPE_WORKFLOW_EXECUTION_STARTED
EVENT_TYPE_WORKFLOW_TASK_SCHEDULED
EVENT_TYPE_WORKFLOW_TASK_STARTED
EVENT_TYPE_WORKFLOW_TASK_FAILED
EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT
```

It creates a brand new QueryDispatcher object that doesn't have query handlers by default, and because we never run event loop [during replay](https://github.com/temporalio/sdk-java/blob/30420212a26283cf7cbe6339512058a3186074e8/temporal-sdk/src/main/java/io/temporal/internal/statemachines/WorkflowTaskStateMachine.java#L112) workflow doesn't get a chance to initialize query handlers again.
Hence when we run a query after workflow timed out we see no query handlers available.
Proposed fix is to trigger event loop somewhere during replay. Alternatively we could move out query handler initialization and call it earlier so that it gets triggered during the replay.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-23 04:40:48.000 UTC</summary>

The result depends on if workflow run times out before workflow task heartbeat (local activity is used in that test) is received by the server or after.

</details>


---

<a id="578"></a>

### #578: TestEnv: WorkflowStub.getResult seems to skip timer 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/578 |
| **State** | CLOSED |
| **Author** | rubyhfu |
| **Created** | 2021-07-07 03:55:31.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-19 04:49:27.000 UTC |
| **Closed** | 2021-07-19 04:49:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | invalid |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

## Expected Behavior
workflowStub.getResult should be waiting for workflow to complete synchronously and shouldn't skip timer without using testEnv.sleep()

## Actual Behavior
Skips timer and returns result immediately

## Steps to Reproduce the Problem

  1. WorkflowInterface

```
import io.temporal.workflow.SignalMethod;
import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;

@WorkflowInterface
public interface ExampleWorkflow {

    @WorkflowMethod
    public String execute(String s);

    @SignalMethod
    public void signal(boolean s);
}

```
  2. WorkflowImpl1
 
```
import java.time.Duration;
import io.temporal.workflow.Workflow;

public class ExampleWorkflowImpl implements ExampleWorkflow{
    private boolean signal = false;

    @Override
    public String execute(String s) {
        Workflow.await(Duration.ofMinutes(5L), () -> signal);
        Workflow.sleep(Duration.ofMinutes(10L));
        return s;
    }

    @Override
    public void signal(boolean signal) {
        this.signal = signal;
    }
}
```
  3. Run third test in test class
 
```
public class ExampleWorkflowImplTest {
    private TestWorkflowEnvironment testEnv;
    private Worker worker1, worker2;
    private WorkflowClient client;

    @BeforeEach
    public void setUp() {
        testEnv = TestWorkflowEnvironment.newInstance();
        worker1 = testEnv.newWorker("TEST_QUEUE1");
        worker2 = testEnv.newWorker("TEST_QUEUE2");
        worker1.registerWorkflowImplementationTypes(ExampleWorkflowImpl.class);
        worker2.registerWorkflowImplementationTypes(ExampleWorkflow2Impl.class);
        client = testEnv.getWorkflowClient();
        testEnv.start();
    }

    @Test
    public void testTerminateWorkflowSignalError() {
        ExampleWorkflow workflow1 = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setWorkflowId("abc123")
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        ExampleWorkflow workflow2 = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue("TEST_QUEUE2")
                        .build());

        WorkflowExecution workflow1Execution = WorkflowClient.start(workflow1::execute, "test");

        testEnv.sleep(Duration.ofMinutes(6L));

        WorkflowExecution workflow2Execution = WorkflowClient.start(workflow2::execute, "test");
        WorkflowStub workflowStub1 = WorkflowStub.fromTyped(workflow1);
        workflowStub1.terminate("Mock terminating workflow");

        WorkflowStub workflowStub2 = WorkflowStub.fromTyped(workflow2);
        workflowStub2.getResult(String.class);
    }

    @Test
    public void testSetWorkflowExecutionTimeoutHangs() {
        ExampleWorkflow workflow = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        // setting this makes the test hang... this normally works outside of TestWorkflowEnv
                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10))
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        WorkflowExecution workflowExecution = WorkflowClient.start(workflow::execute, "test");

        // workflow execution timeout seems to clash with testEnv.sleep
        testEnv.sleep(Duration.ofMinutes(5L));

        WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);
        String result = workflowStub.getResult(String.class);
    }

    @Test
    public void testTestEnvSecondTimerSkipped() {
        ExampleWorkflow workflow = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        WorkflowExecution workflowExecution = WorkflowClient.start(workflow::execute, "test");

        testEnv.sleep(Duration.ofMinutes(5L));

        WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);
        String result = workflowStub.getResult(String.class);
        // why is this able to get past 2nd 10min-timer immediately without moving testEnv time further?
        System.out.println(result);
    }
}

```
## Specifications

  - Version: sdk 1.0.0, junit 5
  - Platform: MacOS BigSur


#### Comments (3)

<details>
<summary><strong>vkoby</strong> commented on 2021-07-07 20:39:03.000 UTC</summary>

Hi @rubyhfu ,
For clarity, you're probably using sdk 1.1.0, not 1.0.0 right?

</details>

<details>
<summary><strong>rubyhfu</strong> commented on 2021-07-07 21:52:25.000 UTC</summary>

@vkoby we are stuck using 1.0.0 due to some dependencies issue right now.... let me know if you don't see these reported issues in newer version. thanks!

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-07-19 04:45:57.000 UTC</summary>

This is actually not a bug, but a feature. It's implemented in `TimeLockingInterceptor` that is used by default in the test environment: https://github.com/temporalio/sdk-java/blob/a25cafa5d363342e77af9cb4719ad7dce4dbfe43/temporal-testing/src/main/java/io/temporal/testing/TestWorkflowEnvironmentInternal.java#L304
We trigger unlimited time skipping after `getResult` is called and disable it after the workflow result is ready to be returned.
This is done to remove frustration from unit tests writers. When a unit test triggers `#getResult`, we think that the test authors are not interested in waiting for the time to pass at a regular pace.
I close this issue right now because it's not a bug. But I assume that there could be some type of tests we didn't think of that this feature makes trickier to implement than it should be. Please reopen this issue if you see a reason why this behavior should be made optional. Also, feel free to ping me on Slack to discuss.

</details>


---

<a id="502"></a>

### #502: OpenTracing: support pluggable strategy for span naming/tagging

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/502 |
| **State** | CLOSED |
| **Author** | sdwr98 (Scott Rankin) |
| **Created** | 2021-05-19 14:36:40.000 UTC (4y 7m ago) |
| **Updated** | 2021-06-11 16:09:58.000 UTC |
| **Closed** | 2021-06-11 16:09:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We use DataDog for APM and tracing, and they do support integration with OpenTracing.  However, they expect span naming and tagging to be in a particular format that does not align with the current Temporal OT implementation

Currently the Temporal OT implementation names the spans like `RunWorkflow_<WorkflowName>` and `RunActivity_<ActivityName>`, and adds tags for Workflow/Run ID.   However, DataDog expects a span name like `RunWorkflow` or `RunActivity` and a tag with the workflow/activity name. 

It would be great if the `OpenTracingOptions` provided the ability to completely override the strategy for naming/tagging spans.  

#### Comments (3)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-24 17:30:31.000 UTC</summary>

I agree, @Spikhalskiy I remember we've discussed this in your PR when you were adding tracing support, do you have strong opinions here?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-05-24 17:51:42.000 UTC</summary>

We discussed with Max during the implementation of the initial open tracing support that it's a good idea to support custom strategies and add an interface that gives full freedom on span names/tags creation. JaxRS/Jersey implementation has an alternative strategy similar to what described in this feature request: https://github.com/opentracing-contrib/java-jaxrs/blob/master/opentracing-jaxrs2/src/main/java/io/opentracing/contrib/jaxrs2/server/OperationNameProvider.java#L25
We just decided to postpone this until somebody actually asks for the alternative implementations. 
So, I support the idea of creating an `OperationNameAndTagsProvider` that provides a span name and tags based on some context and adding more standard implementations of this provider. 

I have a strong opinion only that the strategy that we have already implemented (RunWorkflow_<WorkflowName> and RunActivity_<ActivityName>) should be provided and most likely should be considered default based on my evaluation of other opentracing/opentelemetry implementations. See JaxRS/Jersey: https://github.com/opentracing-contrib/java-jaxrs/blob/master/opentracing-jaxrs2/src/main/java/io/opentracing/contrib/jaxrs2/server/OperationNameProvider.java#L46  

</details>

<details>
<summary><strong>sdwr98</strong> commented on 2021-05-24 17:56:00.000 UTC</summary>

That sounds great.  I actually have an implementation that follows that pattern that's about 75% done.  I'll PR it when I'm done later this week if you'd be interested in taking a look

Reactions: üëç 1

</details>


---

<a id="482"></a>

### #482: Unable to replay a workflow after adding workflow versioning

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/482 |
| **State** | CLOSED |
| **Author** | srekapalli (Sairam Rekapalli) |
| **Created** | 2021-05-11 01:06:49.000 UTC (4y 8m ago) |
| **Updated** | 2021-07-09 18:15:36.000 UTC |
| **Closed** | 2021-07-09 18:15:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior

After adding conditional logic based on the version , workflow replay should be able to process event history .

```
// Before
localActivityStub.process()

// After
int version = Workflow.getVersion("noLocalActivity", Workflow.DEFAULT_VERSION, 1)
if (version == Workflow.DEFAULT_VERSION) {
    // call Local activity
   localActivityStub.process()
} else {
    // directly set properties on the workflow result
}
```

## Actual Behavior

Receiving an error 

```
Caused by: java.lang.IllegalStateException: Unexpected local activity id: 7f5f265e-9487-3fa6-8bf1-37d3d70222ea
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleLocalActivityMarker(WorkflowStateMachines.java:369)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleCommandEvent(WorkflowStateMachines.java:231)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventImpl(WorkflowStateMachines.java:199)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:178)
```


## Specifications

  - Version: 1.0.7 ( Java SDK)
  - Platform:


#### Comments (3)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-11 07:34:17.000 UTC</summary>

Thanks for reporting an issue, we are going to investigate it soon.

</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-06-16 18:22:27.000 UTC</summary>

@srekapalli, I attempted to reproduce this scenario but everything seems to behave correctly for me. Could you please look at the draft PR above and let me know if this test accurately describes your case?

</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-07-09 18:15:36.000 UTC</summary>

Going to close, but please feel free to reopen with a reproduction.

</details>


---

<a id="459"></a>

### #459: testEnv.sleep doesn't work as expected and hangs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/459 |
| **State** | CLOSED |
| **Author** | rubyhfu |
| **Created** | 2021-04-29 17:42:46.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-03 17:56:15.000 UTC |
| **Closed** | 2021-05-03 17:56:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | mfateev |
| **Milestone** | None |

#### Description

## Expected Behavior
testEnv.sleep() should skip workflow's internal timer without actually sleeping.

## Actual Behavior
It seems that the timer is actually sleeping or just hangs. All tests that use testEnv.sleep in a similar fashion as below have similar behavior, however, sometimes when ran as a class, it'll pass. 

## Steps to Reproduce the Problem

Workflow Interface:
```
import io.temporal.workflow.QueryMethod;
import io.temporal.workflow.SignalMethod;
import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;

@WorkflowInterface
public interface ExampleWorkflow {
    @WorkflowMethod
    String execute();

    @SignalMethod
    void updateState(String state);

    @QueryMethod
    String queryState();
}

```

Workflow Implementation:
```
import java.time.Duration;
import io.temporal.workflow.Workflow;
import org.slf4j.Logger;

public class ExampleWorkflowImpl implements ExampleWorkflow {
    Logger logger =  Workflow.getLogger(ExampleWorkflowImpl.class);
    private String state;
    private boolean completed;
    private boolean terminated;
    private boolean error;

    public ExampleWorkflowImpl() {
        this.state = "INITIALIZED";
        this.completed = false;
        this.terminated = false;
        this.error = false;
    }

    @Override
    public String execute() {
        state = "WAITING_FOR_SIGNAL";
        while (state.equals("WAITING_FOR_SIGNAL")) {
            Workflow.await(Duration.ofMinutes(20L), () -> (completed || terminated || error));
            if (terminated) {
                state = "TERMINATED";
                return state;
            } else if (error) {
                state = "ERROR";
                return state;
            } else if (completed) {
                state = "PRELIM_COMPLETED";
            }
        }
        state = "WAITING_FOR_MORE_SIGNAL_OR_TIMER_TO_END";
        Workflow.await(Duration.ofMinutes(20L), () -> (error));
        if (error) {
            state = "ERROR";
            return state;
        } else {
            state = "COMPLETED";
        }
        return state;
    }

    @Override
    public void updateState(String newState) {
        switch(newState) {
            case "PRELIM_COMPLETED":
                completed = true;
                break;
            case "TERMINATED":
                terminated = true;
                break;
            case "ERROR":
                error = true;
                break;
            default:
                logger.error("Unknown state: {}", newState);
                break;
        }
    }

    @Override
    public String queryState() {
        return state;
    }
}
```

Unit Tests:
```
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.time.Duration;
import static java.util.concurrent.TimeUnit.SECONDS;

import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowOptions;
import io.temporal.testing.TestWorkflowEnvironment;
import io.temporal.worker.Worker;
import org.junit.Rule;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.rules.TestWatcher;
import org.junit.runner.Description;

public class ExampleWorkflowImplTest {

    /**
     * Prints a history of the workflow under test in case of a test failure.
     */
    @Rule
    public TestWatcher watchman =
            new TestWatcher() {
                @Override
                protected void failed(Throwable e, Description description) {
                    if (testEnv != null) {
                        System.err.println(testEnv.getDiagnostics());
                        testEnv.close();
                    }
                }
            };

    private TestWorkflowEnvironment testEnv;
    private Worker worker;
    private WorkflowClient client;
    private ExampleWorkflow workflow;
    private static final String WORKFLOW_TASK_QUEUE = "EXAMPLE";

    @BeforeEach
    public void setUp() {
        testEnv = TestWorkflowEnvironment.newInstance();
        worker = testEnv.newWorker(WORKFLOW_TASK_QUEUE);
        client = testEnv.getWorkflowClient();
        worker.registerWorkflowImplementationTypes(ExampleWorkflowImpl.class);
        workflow = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setWorkflowExecutionTimeout(Duration.ofDays(2))
                        .setTaskQueue(WORKFLOW_TASK_QUEUE)
                        .build());
        testEnv.start();
    }

    @Test
    public void testTerminatedUpdateStatus() {
        WorkflowClient.start(workflow::execute);
        workflow.updateState("TERMINATED");
        assertEquals("TERMINATED", workflow.queryState());
    }

    @Test
    @Timeout(value = 10, unit = SECONDS)
    public void testCompletedThenTimerCompletes() throws InterruptedException {
        WorkflowClient.start(workflow::execute);
        workflow.updateState("PRELIM_COMPLETED");
        while (!workflow.queryState().equals("WAITING_FOR_MORE_SIGNAL_OR_TIMER_TO_END")) {
            Thread.sleep(2000);
        }
        // this line hangs without the @Timeout rule
        testEnv.sleep(Duration.ofMinutes(20L));
        assertEquals("COMPLETED", workflow.queryState());
    }

    @AfterEach
    public void tearDown() {
        testEnv.close();
    }
}

```


## Specifications

  - Version: JUnit5, Mockito 1.10.19, Temporal SDK 1.0.0
  - Platform: macOS Big Sur


#### Comments (3)

<details>
<summary><strong>mfateev</strong> commented on 2021-05-01 02:22:04.000 UTC</summary>

I really appreciate the reproduction! I was looking around for exactly this when saw the issue. I'll update you when the fix is ready.

Reactions: üëç 1

</details>

<details>
<summary><strong>mfateev</strong> commented on 2021-05-01 20:06:06.000 UTC</summary>

Found the bug. The fix is in PR. Thanks a lot for your help!

</details>

<details>
<summary><strong>rubyhfu</strong> commented on 2021-05-01 20:22:21.000 UTC</summary>

Wonderful. Thank you! 

</details>


---

<a id="402"></a>

### #402: Prohibit use of WorkflowClient and Activity interfaces in workflow code.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/402 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-03-27 20:59:46.000 UTC (4y 9m ago) |
| **Updated** | 2021-07-08 00:17:15.000 UTC |
| **Closed** | 2021-07-08 00:12:08.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
New users might not be aware of nondeterministic requirements and might use WorkflowClient and Activity interfaces from the workflow code.

**Describe the solution you'd like**
Add explicit checks that throw exceptions from WorkflowClient and Activity APIs if they are called from workflow threads.


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-07-08 00:17:15.000 UTC</summary>

Usage of `WorkflowClient`, `ActivityCompletionClient`, and `WorkflowServiceStubs` was prohibited from workflow thread and code.
If some of the application developers encounter backward compatibilities problems with this change they can disable this check by setting environment variable `TEMPORAL_DISABLE_NON_WORKFLOW_CODE_ENFORCEMENTS` to "true". This option shouldn't be used by any new code and left only to provide backward compatibility for INCORRECTLY implemented legacy workflow implementations.

</details>


---

<a id="391"></a>

### #391: Query failure on terminated workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/391 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-03-18 17:30:29.000 UTC (4y 9m ago) |
| **Updated** | 2022-04-23 04:38:28.000 UTC |
| **Closed** | 2022-04-23 04:38:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

## Expected Behavior
The query works for terminated workflows.

## Actual Behavior
```
Exception in thread "main" io.temporal.client.WorkflowQueryException: workflowId='7fc3ceac-eeb3-4468-983d-28716b21e858', runId='ea297429-0663-4c07-96db-e89cad466a09', workflowType='GreetingWorkflow'}
	at io.temporal.internal.sync.WorkflowStubImpl.query(WorkflowStubImpl.java:475)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.queryWorkflow(WorkflowInvocationHandler.java:309)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:272)
	at io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)
	at com.sun.proxy.$Proxy4.queryGreeting(Unknown Source)
	at io.temporal.samples.hello.HelloQuery.main(HelloQuery.java:95)
Caused by: io.grpc.StatusRuntimeException: INVALID_ARGUMENT: io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 6 of 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED' type. IsReplaying=false, PreviousStartedEventId=3, workflowTaskStartedEventId=0, Currently Processing StartedEventId=3
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:193)
Caused by: io.grpc.StatusRuntimeException: INVALID_ARGUMENT: io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 6 of 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED' type. IsReplaying=false, PreviousStartedEventId=3, workflowTaskStartedEventId=0, Currently Processing StartedEventId=3

	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleEvent(ReplayWorkflowRunTaskHandler.java:140)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:180)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleQueryWorkflowTask(ReplayWorkflowRunTaskHandler.java:254)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleQueryOnlyWorkflowTask(ReplayWorkflowTaskHandler.java:257)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:112)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:314)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:280)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.IllegalArgumentException: Unexpected event:event_id: 6
```

## Steps to Reproduce the Problem
Terminate a workflow and run a query against it.



#### Comments (3)

<details>
<summary><strong>bfugas</strong> commented on 2021-06-08 08:25:27.000 UTC</summary>

I encountered the issue, reproduced it and posted a fix proposal.
I'm not sure if all the cases have been covered here. But I didn't want to make a big change to ignore all unknown events (go-sdk does it this way).

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-08 18:45:45.000 UTC</summary>

This flake report actually shows that the issue wasn't fixed or was fixed partially: https://github.com/temporalio/sdk-java/issues/630

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-23 04:38:28.000 UTC</summary>

This issue is fixed. The flake https://github.com/temporalio/sdk-java/issues/630 has a different nature. The result depends on if workflow run times out before WFT heartbeat (local activity is used in that test) is received or after. 

</details>


---

<a id="228"></a>

### #228: Expose activity start and completion information to the workflow code.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/228 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-10-08 22:53:30.000 UTC (5y 3m ago) |
| **Updated** | 2023-04-18 17:54:44.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 1 |
| **Priority Score** | 3 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
The workflow history contains information about the time and identity of the activity worker that started and completed an activity. But this information is not available to the workflow code.

**Describe the solution you'd like**
Some API to get full information about an activity execution.

**Additional context**
Here is a slack message that outlines one possible usage of this feature:

> Hi, I am running workflows with activities and would like to track in real time when some activity types started and completed exactly and be able from other activities in my workflow to log these start and complete time (because I don't want to introduce the logging capability to all my microservices that are also written in different languages).
> Right now I can tell from the workflow about the time my activity was scheduled (which is not the time it was started) and also the time it scheduled back to workflow after activity completion (which is not the actual time activity was completed).

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-18 17:54:44.000 UTC</summary>

Related to: https://github.com/temporalio/sdk-java/issues/1009

</details>


---

<a id="203"></a>

### #203: ensureDefaultFieldsForActivityRetryPolicy in testService don't rewrite nonRetryableErrorTypes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/203 |
| **State** | CLOSED |
| **Author** | filipmigdalski (Filip Migdalski) |
| **Created** | 2020-09-07 06:29:01.000 UTC (5y 4m ago) |
| **Updated** | 2021-09-23 17:38:33.000 UTC |
| **Closed** | 2021-09-23 17:38:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior


## Actual Behavior
It seems that `io.temporal.internal.testservice.StateMachines.ensureDefaultFieldsForActivityRetryPolicy(RetryPolicy originalPolicy)` don't rewrite nonRetryableErrorTypes. There are no corresponding instructions in the method. 


#### Comments (3)

<details>
<summary><strong>filipmigdalski</strong> commented on 2020-09-07 06:32:37.000 UTC</summary>

I've made a quickfix (it's one-liner + tests), but i can't push it into a new branch

</details>

<details>
<summary><strong>skrul</strong> commented on 2020-09-28 20:45:57.000 UTC</summary>

Hey @filipmigdalski I believe this issue is currently blocking me from upgrading to v0.29.1 as my code has a unit test that checks if the `setDoNotRetry` retry policy is respected.


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-23 17:38:33.000 UTC</summary>

Closed by #223

</details>


---

<a id="173"></a>

### #173: ArithmeticException in ReplayWorkflowExecutor after some amount of requests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/173 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2020-08-08 03:55:58.000 UTC (5y 5m ago) |
| **Updated** | 2023-04-18 17:48:05.000 UTC |
| **Closed** | 2023-04-18 17:48:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Test to reproduce

```
public class LocalActivityLongTest {
  ....
  @WorkflowInterface
  public interface TestWorkflow {
    @WorkflowMethod
    String workflow(String input);
  }

  public static class ActivityWorkflow implements TestWorkflow {
    private final TestActivity activity = Workflow.newLocalActivityStub(TestActivity.class, LocalActivityOptions.newBuilder().build());
    @Override
    public String workflow(String input) {return activity.activity(input + "3");}
  }

  @ActivityInterface
  public interface TestActivity {
    String activity(String input);
  }

  private static class ActivityImpl implements TestActivity {
    @Override
    public String activity(String input) {return "1";}
  }

  @Test
  public void trivialTest() {
    Worker worker = testEnvironment.newWorker(TASK_QUEUE);
    worker.registerWorkflowImplementationTypes(ActivityWorkflow.class);
    worker.registerActivitiesImplementations(new ActivityImpl());

    testEnvironment.start();
    WorkflowClient client = testEnvironment.getWorkflowClient();
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            // uncomment this to fix the test
            // .setWorkflowExecutionTimeout(Duration.ofHours(1))
            .setTaskQueue(TASK_QUEUE)
            .build();

    for (int reqCount = 1; reqCount < 1000; reqCount++) {
      log.info("Request {}", reqCount);
      TestWorkflow workflow = client.newWorkflowStub(TestWorkflow.class, options);
      String result = workflow.workflow(UUID.randomUUID().toString());
    }
  }
}
```

## Expected Behavior

Either to:
1. fail with a meaningful message on the configuration stage 
2. or fail with a meaningful message on the first request
3. or successfully execute all 1000 requests.

## Actual Behavior

Executes the first ~30 requests successfully.
Hangs and fails after that with:
```
23:49:49.698 [Workflow Executor taskQueue="test-workflow", namespace="default": 1] ERROR i.t.internal.worker.PollerOptions - uncaught exception
java.lang.RuntimeException: Failure processing workflow task. WorkflowId=304a033c-e0e6-49ec-9c2d-024c01d533a7, RunId=c63116f5-330a-4e35-9f04-6cdd344acea8
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:324)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:273)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.ArithmeticException: Duration of this magnitude not supported
	at com.uber.m3.util.Duration.checkMultiplicationLongOverflow(Duration.java:340)
	at com.uber.m3.util.Duration.ofMillis(Duration.java:109)
	at io.temporal.internal.common.ProtobufTimeUtils.ToM3Duration(ProtobufTimeUtils.java:49)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.completeWorkflow(ReplayWorkflowExecutor.java:329)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.mayBeCompleteWorkflow(ReplayWorkflowExecutor.java:302)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.handleWorkflowTaskImpl(ReplayWorkflowExecutor.java:468)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.handleWorkflowTask(ReplayWorkflowExecutor.java:403)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:168)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowTaskHandler.java:145)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:104)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:301)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:273)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
```


## Steps to Reproduce the Problem

Please find the full unit test here: https://github.com/Spikhalskiy/java-sdk/commit/821f735afa696d9abc350cc9fb1b12eef1e16ae7. Which hangs after about 30-35 requests with the exception in logs.
Also, note that uncommenting https://github.com/Spikhalskiy/java-sdk/commit/821f735afa696d9abc350cc9fb1b12eef1e16ae7#diff-1661ff603d3c1aaff5d01537e8f938b7R79 fixes the unit test.


## Specifications

  - Version: at least 0.28 and current master [https://github.com/temporalio/java-sdk/commit/35abfd425c13e86f16b81e26c85c07b17ee3448f] is affected


#### Comments (3)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-21 19:53:21.000 UTC</summary>

The root cause is the unit test time skipping logic together with a large workflow timeout. The time skipping automatically moves time to the next task in a timer queue. The problem is that it does it for the workflow timeout after workflow completion. When running 1k workflows it jumps 10 years ahead after every execution. And apparently M3 metrics are not ready to deal with 10k year durations.

I'm looking into the fix. Probably we should ignore time skipping for tasks that belong to completed workflows.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-02-11 23:12:46.000 UTC</summary>

There is a report that the similar exception appears in java-sdk 1.8.0 using test-server.

```
java.lang.ArithmeticException: Duration of this magnitude not supported
	at com.uber.m3.util.Duration.checkMultiplicationLongOverflow(Duration.java:340)
	at com.uber.m3.util.Duration.ofMillis(Duration.java:109)
	at io.temporal.internal.common.ProtobufTimeUtils.toM3Duration(ProtobufTimeUtils.java:49)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.completeWorkflow(ReplayWorkflowExecutor.java:109)
	at io.temporal.internal.replay.ReplayWorkflowExecutor.eventLoop(ReplayWorkflowExecutor.java:84)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler$StatesMachinesCallbackImpl.eventLoop(ReplayWorkflowRunTaskHandler.java:321)
	at io.temporal.internal.statemachines.WorkflowStateMachines.eventLoop(WorkflowStateMachines.java:463)
	at io.temporal.internal.statemachines.WorkflowStateMachines.lambda$scheduleLocalActivityTask$8d414bd$1(WorkflowStateMachines.java:790)
	at io.temporal.internal.statemachines.LocalActivityStateMachine.notifyResultFromResponse(LocalActivityStateMachine.java:326)
	at io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:45)
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:147)
	... 17 common frames omitted
Wrapped by: java.lang.RuntimeException: LocalActivity: failure executing MARKER_COMMAND_CREATED->RECORD_MARKER, transition history is [CREATED->CHECK_EXECUTION_STATE, EXECUTING->SCHEDULE, REQUEST_PREPARED->MARK_AS_SENT, REQUEST_SENT->HANDLE_RESULT]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:151)
	at io.temporal.internal.statemachines.StateMachine.handleCommand(StateMachine.java:111)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleCommand(EntityStateMachineBase.java:55)
	at io.temporal.internal.statemachines.CancellableCommand.handleCommand(CancellableCommand.java:63)
	at io.temporal.internal.statemachines.WorkflowStateMachines.prepareImpl(WorkflowStateMachines.java:413)
	at io.temporal.internal.statemachines.WorkflowStateMachines.prepareCommands(WorkflowStateMachines.java:396)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleLocalActivityCompletion(WorkflowStateMachines.java:768)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.waitAndProcessLocalActivityCompletion(ReplayWorkflowRunTaskHandler.java:307)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.processLocalActivityRequests(ReplayWorkflowRunTaskHandler.java:282)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:146)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:122)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:97)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:241)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:199)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
```

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-18 17:48:04.000 UTC</summary>

No known reproduction of this issue for more than a year. Reopen if there is a new report.

</details>


---

<a id="43"></a>

### #43: Require explicit annotation for Workflow and Activity interfaces.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/43 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-03-26 19:47:57.000 UTC (5y 9m ago) |
| **Updated** | 2020-04-25 16:28:18.000 UTC |
| **Closed** | 2020-04-25 16:28:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 3 |
| **Priority Score** | 3 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

> We've run into this issue when trying to use Spring beans as activity implementations - if they're proxied with transactional support or other Spring stuff, Cadence gets upset.  Would be great to have an @Activity or @ActivityMethod annotation that controlled activity discovery

So it looks like having explicit @ActivityInterface and @WorkflowInterface would resolve these issues. It would also help with issue when two activity interfaces extend the same interface.

#### Comments (3)

<details>
<summary><strong>mfateev</strong> commented on 2020-03-27 04:00:46.000 UTC</summary>

Thinking about it I believe we should solve this with another common requirement to support multiple implementations of the same interface for activities.

So it looks like there is a need to implement many to many relationship between interfaces and activity implementations and use only some of the interfaces for workflow->activity implementation calls.

Currently an activity interface is used to define two distinct properties of an activity. It defines a strongly typed interface for calling and implementing activities and it defines activity type name string. This string is used to convert calls on the activity stub to ScheduleActivityTask <activityName, input> decision. And then by an activity worker to locate an appropriate implementation. The implementation is found by registering it with the name of activities extracted from the interfaces the implementation implements.

As an activity interface by design defines only one activity type for each method it is not possible to have multiple implementations of this interface to share the same activity worker listening on a common task list. Also as currently there is no @ActivityInterface annotation then every interface a class implements becomes an activity interface when registered with an activity worker. This is known problem when the same mixin interface is implemented by multiple activity implementations.

Let's look at the possible solutions. 

1. Keep one interface to one activity type per method mapping, but introduce @ActivityInterface annotation to mark interfaces that are used to define activity types. 
Code example:

```java
public interface Base {
    void foo();
}

// Defines MyActivity1_bar and MyActivity1_foo activity types
@ActivityInterface
public interface MyActivity1 extends Base {
    void bar();
}

// Defines MyActivity2_foo activity type
@ActivityInterface
public interface MyActivity2 extends Base {
}

public class MyActivityImpl1 implements MyActivity1, Runnable {
    public void foo() {
        // activity impl
    }
    
    public void bar() {
        // activity impl
    }
    
    public void run() {
        // this is not activity method as Runnable is not an activity
    }
}

public class MyActivityImpl2 implements MyActivity2 {
    public void foo() {
        // activity impl
    }
}

worker.registerActivitiesImplementations(new MyActivityImpl1(), new MyActivityImpl2());


public interface MyWorkflow {
    @WorkflowMethod
    void execute();
}

public class MyWorkflowImpl implements MyWorklfow {
    MyActivity1 a = Workflow.newActivityStub(MyActivity1.class);
    MyActivity2 b = Workflow.newActivityStub(MyActivity2.class);
    // The following is going to fail at runtime as Runnable is not annotated with @ActivityInterface
    Runnable invalid = Workflow.newActivityStub(Runnable.class); 
    // The following is going to fail at runtime as Base is not annotated with @ActivityInterface
    Base invalid2 = Workflow.newActivityStub(Base.class); 

    // This is fine as both MyActivity1 and MyActivity2 extend Base
    Base[] all = new Base[] {a, b};
    
    public void execute() {
        a.bar(); 
        for(Base b:all) {
            b.foo();
        }
    }
}
```

</details>

<details>
<summary><strong>mfateev</strong> commented on 2020-03-27 04:13:40.000 UTC</summary>

2. Another option is to allow multiple implementations of an activity interface and use additional qualifier (which defaults to implementation class name) to distinguish between multiple implementations when necessary. 
Example:

```java
@ActivityInterface
public interface MyActivity {
    void foo();
}

public class MyActivityImpl1 implements MyActivity, Runnable {
    // This is registered as MyActivity_foo activity name with the worker
    // This is exactly the current behavior
    public void foo() {
        // whatever
    }
    // This is not an activity method
    public void run() {
        //whatever
    }
}

@ActivityImplementation(type="MyActivity2")
public class MyActivityImpl2 implements MyActivity {
    // This is registered as MyActivity2_foo activity name with the worker
    public void foo() {
        // whatever
    }

}

worker.registerActivitiesImplementations(new MyActivityImpl1(), new MyActivityImpl2());


@WorkflowInterface
public interface MyWorkflow {
    @WorkflowMethod
    void execute();
}

public class MyWorkflowImpl implements MyWorklfow {

    MyActivity a1 = Workflow.newActivityStub(MyActivity.class);
    MyActivity a2 = Workflow.newActivityStub(MyActivity.class, "MyActivity2");
    // This is not valid as Runnable is not annotated with @ActivityInterface
    Runnable invalid = Workflow.newActivityStub(Runnable.class, "foo");
    MyActivity[] activities = new MyActivity[] {a1, a2};
    
    public void execute() {
        a1.foo(); // calls MyActivity_foo
        a2.foo(); // calls MyActivity2_foo
        for(MyActivity a: activities) {
           a.foo();  // Ends up calling MyActivity_foo and MyActivity2_foo activity names.
        }
    }
}
```

Note that both of the approaches are almost backwards compatible with the current implementation. The only incompatible change is requirement to annotate all activity definition interfaces with @ActivityInterface.

</details>

<details>
<summary><strong>sdwr98</strong> commented on 2020-03-30 16:27:30.000 UTC</summary>

Is there a reason that you're looking solely at putting `@ActivityImplementation` at the class level rather than having an `@ActivityMethod` interface?  I ask because for people coming to Cadence with existing code that they might be refactoring it might be helpful to mark just some of the methods in an interface as an available activity. 

Regarding the qualifier for different activity implementations - we don't have a need for that, but it seems like a good idea for those who do. 

</details>


---

<a id="2741"></a>

### #2741: Support non-workflow activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2741 |
| **State** | OPEN |
| **Author** | maciejdudko (Maciej Dudkowski) |
| **Created** | 2025-12-02 17:20:21.000 UTC (1 months ago) |
| **Updated** | 2025-12-02 17:20:21.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Describe the solution you'd like**

Allow executing activities without a workflow. The clients must support the new (upcoming) server APIs for starting, managing and getting results of activities. The workers must support running activities outside of workflow context.

**Additional context**

Server API PR (WIP): https://github.com/temporalio/api/pull/640


---

<a id="2730"></a>

### #2730: INTERNAL: Panic! This is a bug! in wrapStartException

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2730 |
| **State** | CLOSED |
| **Author** | FelixSanthanasekar |
| **Created** | 2025-11-19 01:30:25.000 UTC (1 months ago) |
| **Updated** | 2025-11-24 18:05:48.000 UTC |
| **Closed** | 2025-11-24 18:05:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description


## Actual Behavior
cause: io.grpc.StatusRuntimeException: INTERNAL: Panic! This is a bug!

exception: [io.temporal.client.WorkflowStubImpl.wrapStartException(WorkflowStubImpl.java:455), io.temporal.client.WorkflowStubImpl.startWithOptions(WorkflowStubImpl.java:111), io.temporal.client.WorkflowStubImpl.start(WorkflowStubImpl.java:129), io.temporal.client.WorkflowInvocationHandler$StartWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:239), io.temporal.client.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:175), jdk.proxy2/jdk.proxy2.$Proxy280.execute(Unknown Source), io.temporal.client.WorkflowClientInternalImpl.lambda$start$eaf97fa$1(WorkflowClientInternalImpl.java:433), io.temporal.client.WorkflowClientInternalImpl.start(WorkflowClientInternalImpl.java:361), io.temporal.client.WorkflowClientInternalImpl.start(WorkflowClientInternalImpl.java:404), io.temporal.client.WorkflowClientInternalImpl.start(WorkflowClientInternalImpl.java:433), io.temporal.client.WorkflowClient.start(WorkflowClient.java:544), 

## Specifications

  - Version:  temporal-sdk:jar:1.23.0,grpc-stub:jar:1.66.0
  - Platform: 


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-11-19 03:21:56.000 UTC</summary>

Java SDK v1.23.0 is very old, can you produce this bug on the latest release [v1.32.0](https://github.com/temporalio/sdk-java/releases/tag/v1.32.0)?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-11-24 18:05:48.000 UTC</summary>

Closing due to no response, if there is some reproduction on the latest Java SDK then we can reopen

</details>


---

<a id="2680"></a>

### #2680: Spring Boot application startup failure - DEADLINE_EXCEEDED

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2680 |
| **State** | CLOSED |
| **Author** | brempusz (Bartosz Rempuszewski) |
| **Created** | 2025-10-10 09:28:31.000 UTC (3 months ago) |
| **Updated** | 2025-10-13 09:30:02.000 UTC |
| **Closed** | 2025-10-13 06:02:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I introduced activity worker to an existing application (rest service) to expose some logic as activity instead of another rest endpoint.
Spring boot application fails to start if there is a problem with connection to temporal service.
I observed this on a server under heavy load.

## Expected Behavior
Application should start and report problems with temporal connection as health check.
Application should try to reconnect to temporal service and update health check.

Maybe such behavior should be optional, enabled with a configuration property.


## Actual Behavior

Application fails to start

```
2025-10-10 10:18:47.988 ERROR [,,] 7 --- [main] o.s.boot.SpringApplication               : Application run failed

io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: ClientCall started after CallOptions deadline was exceeded .9-0,089095 seconds ago
        at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:268)
        at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:249)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:167)
        at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.getSystemInfo(WorkflowServiceGrpc.java:6740)
        at io.temporal.serviceclient.SystemInfoInterceptor.getServerCapabilitiesOrThrow(SystemInfoInterceptor.java:112)
        at io.temporal.serviceclient.SystemInfoInterceptor.lambda$getServerCapabilitiesWithRetryOrThrow$0(SystemInfoInterceptor.java:98)
        at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:49)
        at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:40)
        at io.temporal.serviceclient.SystemInfoInterceptor.getServerCapabilitiesWithRetryOrThrow(SystemInfoInterceptor.java:97)
        at io.temporal.serviceclient.ChannelManager.lambda$getServerCapabilities$3(ChannelManager.java:324)
        at io.temporal.internal.worker.WorkflowPollTask.<init>(WorkflowPollTask.java:78)
        at io.temporal.internal.worker.WorkflowWorker.start(WorkflowWorker.java:178)
        at io.temporal.internal.worker.SyncWorkflowWorker.start(SyncWorkflowWorker.java:164)
        at io.temporal.worker.Worker.start(Worker.java:408)
        at io.temporal.worker.WorkerFactory.start(WorkerFactory.java:204)
        at io.temporal.spring.boot.autoconfigure.RootNamespaceAutoConfiguration$WorkerFactoryStarter.onApplicationEvent(RootNamespaceAutoConfiguration.java:205)
        at io.temporal.spring.boot.autoconfigure.RootNamespaceAutoConfiguration$WorkerFactoryStarter.onApplicationEvent(RootNamespaceAutoConfiguration.java:195)
        at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185)
        at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178)
        at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156)
        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:454)
        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:387)
        at org.springframework.boot.context.event.EventPublishingRunListener.ready(EventPublishingRunListener.java:109)
        at org.springframework.boot.SpringApplicationRunListeners.lambda$ready$6(SpringApplicationRunListeners.java:80)
        at java.base/java.lang.Iterable.forEach(Iterable.java:75)
        at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:118)
        at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:112)
        at org.springframework.boot.SpringApplicationRunListeners.ready(SpringApplicationRunListeners.java:80)
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:332)
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1361)
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1350)
        at ... snip ...
        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
        at java.base/java.lang.reflect.Method.invoke(Method.java:580)
        at org.springframework.boot.loader.launch.Launcher.launch(Launcher.java:102)
        at org.springframework.boot.loader.launch.Launcher.launch(Launcher.java:64)
        at org.springframework.boot.loader.launch.JarLauncher.main(JarLauncher.java:40)
```

## Specifications

temporal java sdk 1.31
temporal server version 1.28.0


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-13 06:04:56.000 UTC</summary>

There are multiple options to address this in the linked issue, but I would not recommend following any of them unless absolutely necessary as they are all band-aids over the real problem. The root problem is your Temporal sever is overloaded and needs to be scaled up, taking over 10s for a simple RPC is too long and will cause a poor experience. 

</details>

<details>
<summary><strong>brempusz</strong> commented on 2025-10-13 07:09:21.000 UTC</summary>

Thanks for the explanation.

I hit this issue only during development (so far) when I do rollout of all services (there is a high cpu usage peek in such scenario - all services starting at once).

I will follow hints from https://github.com/temporalio/sdk-java/issues/2466 and try manual start and `WorkflowServiceStubsOptions.Builder.setSystemInfoTimeout`.

Still, I think it would be more "spring-booty" to report problems with connection as healthcheck.



</details>


---

<a id="2637"></a>

### #2637: strange behaviour when registrating activities with worker in java sdk

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2637 |
| **State** | CLOSED |
| **Author** | SvetlozarMihaylov |
| **Created** | 2025-07-21 09:33:49.000 UTC (5 months ago) |
| **Updated** | 2025-08-21 23:04:44.000 UTC |
| **Closed** | 2025-08-21 22:56:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When registrating  two Activity class with a worker and both Activities have a method with the same name that is Not @ActivityMethod the activities are registrated and working.

## Actual Behavior
I get 
Exception in thread "main" io.temporal.worker.TypeAlreadyRegisteredException: "CommonName" activity type is already registered with the worker
	at io.temporal.internal.activity.ActivityTaskHandlerImpl.registerActivityImplementation(ActivityTaskHandlerImpl.java:168)
	at io.temporal.internal.activity.ActivityTaskHandlerImpl.registerActivityImplementations(ActivityTaskHandlerImpl.java:107)
	at io.temporal.internal.worker.SyncActivityWorker.registerActivityImplementations(SyncActivityWorker.java:90)
	at io.temporal.worker.Worker.registerActivitiesImplementations(Worker.java:364)
## Steps to Reproduce the Problem
Create interface CommonActivity with method void method called '**common**' 
Have two @ActivityInterface interfaces ActivityA with @ActivityMethod  called doActivityA() and ActivityB with @ActivityMethod  called doActivityB().
Both of those inherit CommonActivity, so both have the **common** method. When I register the activities to a worker 
  yourWorker.registerActivitiesImplementations(new ActivityAImpl(), new ActivityBImpl() ); 
I get error 
Exception in thread "main" io.temporal.worker.TypeAlreadyRegisteredException: "Common" activity type is already registered with the worker
	at io.temporal.internal.activity.ActivityTaskHandlerImpl.registerActivityImplementation(ActivityTaskHandlerImpl.java:168)
	at io.temporal.internal.activity.ActivityTaskHandlerImpl.registerActivityImplementations(ActivityTaskHandlerImpl.java:107)
	at io.temporal.internal.worker.SyncActivityWorker.registerActivityImplementations(SyncActivityWorker.java:90)
	at io.temporal.worker.Worker.registerActivitiesImplementations(Worker.java:364)

## Specifications

  - Version:
  - 1.24.1
  - Platform:
  - Java


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-21 22:56:22.000 UTC</summary>

This is expected behaviour, duplicate activity methods cannot be registered. In the future please use our[ community forum](https://community.temporal.io/) or slack for support questions.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-21 23:04:44.000 UTC</summary>

You can consider using `namePrefix` in `ActivityInterface` so each method has a unique activity type

</details>


---

<a id="2595"></a>

### #2595: Request: Support for Kotlin 2.0 and Newer Versions of gRPC, Netty, and Related Dependencies

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2595 |
| **State** | CLOSED |
| **Author** | andelgdo (andelgdo) |
| **Created** | 2025-07-11 15:56:02.000 UTC (6 months ago) |
| **Updated** | 2025-07-11 16:00:21.000 UTC |
| **Closed** | 2025-07-11 15:58:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hello Temporal Team,
 
Is there a plan to support newer versions of Kotlin and grpc libraries? From my research it seems that these are the current highest versions supported:
 
grpc-bom - 1.61.x

Netty (via grpc-bom) - ~4.1.101.Final

Kotlin (compiler/api - 1.9.20

kotlinx-coroutines - 1.7.4+

grpc-inprocess - 1.60.0
 
**Would it be possible to prioritize support for newer versions in upcoming releases?**  
 
Thank you for your consideration and for all your work on Temporal!


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-07-11 15:58:43.000 UTC</summary>

I think this is a duplicate of https://github.com/temporalio/sdk-java/issues/2594?

</details>

<details>
<summary><strong>andelgdo</strong> commented on 2025-07-11 16:00:21.000 UTC</summary>

> I think this is a duplicate of [#2594](https://github.com/temporalio/sdk-java/issues/2594)?

Yes, this was my mistake.

</details>


---

<a id="2594"></a>

### #2594: Request: Support for Kotlin 2.0 and Newer Versions of gRPC, Netty, and Related Dependencies

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2594 |
| **State** | CLOSED |
| **Author** | andelgdo (andelgdo) |
| **Created** | 2025-07-11 15:31:54.000 UTC (6 months ago) |
| **Updated** | 2025-07-11 16:53:03.000 UTC |
| **Closed** | 2025-07-11 15:45:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hello Temporal Team,

Is there a plan to support newer versions of Kotlin and grpc libraries? From my research it seems that these are the current highest versions supported:

grpc-bom - 1.61.x
Netty (via grpc-bom) - ~4.1.101.Final
Kotlin (compiler/api - 1.9.20
kotlinx-coroutines - 1.7.4+
grpc-inprocess - 1.60.0

**Would it be possible to prioritize support for newer versions in upcoming releases?**  

Thank you for your consideration and for all your work on Temporal!

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-07-11 15:45:47.000 UTC</summary>

Hi,

Temporal Java SDK supports the lates grpc (We run CI with `1.72.0` but will update to `1.73.0` soon). 

As for Kotlin, though we do currently **do not** offer an official Kotlin SDK, lots of Temporal users use the Java SDK in production from Kotlin  , or other JVM languages like Clojure.

</details>

<details>
<summary><strong>andelgdo</strong> commented on 2025-07-11 16:53:03.000 UTC</summary>

> Hi,
> 
> Temporal Java SDK supports the lates grpc (We run CI with `1.72.0` but will update to `1.73.0` soon).
> 
> As for Kotlin, though we do currently **do not** offer an official Kotlin SDK, lots of Temporal users use the Java SDK in production from Kotlin , or other JVM languages like Clojure.

Ah, I see. Thank you for the quick response. 

</details>


---

<a id="2579"></a>

### #2579: Non-root namespace Spring dependencies fail on app startup

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2579 |
| **State** | OPEN |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2025-06-30 22:46:26.000 UTC (6 months ago) |
| **Updated** | 2025-06-30 22:47:35.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior

Defining non-root namespaces in the Spring Starter should allow beans to be injected. 

## Actual Behavior

The documentation calls out that this is supported, yet the `BeanPostProcessor` that creates these beans run after bean initialization, so application startup will fail.

In order to work around this, one must use an `ObjectProvider` to decouple component autowiring from Temporal bean creation, deferring bean finalization to either `PostConstruct` or app runtime.

## Steps to Reproduce the Problem

  1. Create a non-root namespace configuration 
  1. Create a `@Component` that injects a non-root `WorkflowClient` (using `@Resource`, per docs)
  1. Start the application: The app should fail to start due to the non-root namespace WorkflowClient being unavailable.

## Specifications

  - Version: 1.29.0, 1.30.1
  - Platform: N/A



---

<a id="2473"></a>

### #2473: Cancellation scopes and async procedures are canceled in non-deterministic order when workflow is canceled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2473 |
| **State** | CLOSED |
| **Author** | sajkol |
| **Created** | 2025-04-07 12:22:46.000 UTC (9 months ago) |
| **Updated** | 2025-05-09 18:12:49.000 UTC |
| **Closed** | 2025-05-09 18:09:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Description of problem
I have a workflow that uses cancellation scopes and a timer to handle expiration, which can be reduced to something like this (using Java SDK):
```
var scope = Workflow.newCancellationScope(() -> {
    activity.doActivity();
});

Async.procedure(() -> {
    Workflow.sleep(Duration.ofMinutes(5));
    scope.cancel();
});

scope.run();
```
However, when this workflow is canceled during activity execution, it seems that the order in which the pending activity and the timer are canceled is not deterministic, which sometimes causes `NonDeterministicException` when replaying.

## Steps to Reproduce the Problem
Here's the issue reproduced in a unit test. Test is repeated because the result is random - sometimes the history generated in the replay happens to match the one resulting from initial execution.

```
package com.example;

import io.temporal.activity.ActivityInterface;
import io.temporal.activity.ActivityOptions;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowOptions;
import io.temporal.client.WorkflowStub;
import io.temporal.testing.TestWorkflowEnvironment;
import io.temporal.testing.WorkflowReplayer;
import io.temporal.worker.Worker;
import io.temporal.workflow.Async;
import io.temporal.workflow.Workflow;
import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;
import java.time.Duration;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;

@Slf4j
public class WorkflowCanceledTimerTest {

    @WorkflowInterface
    public interface TestWorkflow {
        @WorkflowMethod
        void start();
    }

    @ActivityInterface
    public interface TestActivity {
        void doActivity();
    }

    public static class TestActivityImpl implements TestActivity {
        @Override
        public void doActivity() {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    public static class TestWorkflowImpl implements TestWorkflow {

        TestActivity activity = Workflow.newActivityStub(TestActivity.class,
                ActivityOptions.newBuilder().setScheduleToCloseTimeout(Duration.ofSeconds(60)).build());

        @Override
        public void start() {
            var scope = Workflow.newCancellationScope(() -> {
                activity.doActivity();
            });

            Async.procedure(() -> {
                Workflow.sleep(Duration.ofMinutes(5));
                scope.cancel();
            });

            scope.run();
        }
    }

    private TestWorkflowEnvironment testEnv;
    private Worker worker;
    private WorkflowClient client;

    @BeforeEach
    public void setUp() {
        testEnv = TestWorkflowEnvironment.newInstance();
        worker = testEnv.newWorker("test");
        worker.registerWorkflowImplementationTypes(TestWorkflowImpl.class);
        worker.registerActivitiesImplementations(new TestActivityImpl());

        client = testEnv.getWorkflowClient();
        testEnv.start();
    }

    @RepeatedTest(20)
    void replayCanceledWorkflow() throws Exception {
        var testWorkflow = client.newWorkflowStub(TestWorkflow.class, WorkflowOptions.newBuilder()
                .setWorkflowId("test-workflow-id")
                .setTaskQueue("test")
                .build());

        WorkflowClient.start(testWorkflow::start);

        var stub = WorkflowStub.fromTyped(testWorkflow);
        stub.cancel();
        try {
            stub.getResult(Void.class);
        } catch (Exception e) {
            // ignore; just blocking to make sure workflow is actually finished
        }

        var history = client.fetchHistory("test-workflow-id");
        WorkflowReplayer.replayWorkflowExecution(history, worker);
    }
}

```

The two history variants that this generates are:
```
1.	EVENT_TYPE_WORKFLOW_EXECUTION_STARTED
2.	EVENT_TYPE_WORKFLOW_TASK_SCHEDULED
3.	EVENT_TYPE_WORKFLOW_TASK_STARTED
4.	EVENT_TYPE_WORKFLOW_TASK_COMPLETED
5.	EVENT_TYPE_ACTIVITY_TASK_SCHEDULED
6.	EVENT_TYPE_TIMER_STARTED
7.	EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED
8.	EVENT_TYPE_WORKFLOW_TASK_SCHEDULED
9.	EVENT_TYPE_WORKFLOW_TASK_STARTED
10.	EVENT_TYPE_WORKFLOW_TASK_COMPLETED
11.	EVENT_TYPE_TIMER_CANCELED
12.	EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED
13.	EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED
```

```
1.	EVENT_TYPE_WORKFLOW_EXECUTION_STARTED
2.	EVENT_TYPE_WORKFLOW_TASK_SCHEDULED
3.	EVENT_TYPE_WORKFLOW_TASK_STARTED
4.	EVENT_TYPE_WORKFLOW_TASK_COMPLETED
5.	EVENT_TYPE_ACTIVITY_TASK_SCHEDULED
6.	EVENT_TYPE_TIMER_STARTED
7.	EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED
8.	EVENT_TYPE_WORKFLOW_TASK_SCHEDULED
9.	EVENT_TYPE_WORKFLOW_TASK_STARTED
10.	EVENT_TYPE_WORKFLOW_TASK_COMPLETED
11.	EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED
12.	EVENT_TYPE_TIMER_CANCELED
13.	EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED
```

Note events 11 and 12 which are swapped between runs.

## Specifications

  - Temporal server version: 1.27.1
  - Java SDK version 1.28.4


#### Comments (2)

<details>
<summary><strong>sajkol</strong> commented on 2025-04-08 08:15:07.000 UTC</summary>

For this particular case a workaround is possible by moving the async procedure inside the cancellation scope:
```
var scope = Workflow.newCancellationScope(s -> {
    Async.procedure(() -> {
        Workflow.sleep(Duration.ofMinutes(5));
        s.cancel();
    });

    activity.doActivity();
});

scope.run();
```
This results in the timer being consistently canceled before the activity. But it's very likely that there are other cases where mixing cancelation scopes causes non-determinism due to the same underlying issue.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-09 18:12:47.000 UTC</summary>

Thanks for filing this! confirmed this is an SDK issue due to the SDK iterating over a `HashSet` which is not deterministic. Due to some backwards compatibility concerns this fix won't be enabled until 2 minor releases.

</details>


---

<a id="2449"></a>

### #2449: SpringBoot - create ScheduleClient per namespace that has namespace pre-configured in its ScheduleClientOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2449 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-03-17 21:49:21.000 UTC (9 months ago) |
| **Updated** | 2025-03-19 22:21:02.000 UTC |
| **Closed** | 2025-03-19 22:21:02.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

Currently have to inject specific WorkflowClient and then create ScheduleClient for its namespace:

     scheduleClient customClient = ScheduleClient.newInstance(workflowClient.getWorkflowServiceStubs(), ScheduleClientOptions.newBuilder()
                        .setNamespace(workflowClient.getOptions().getNamespace())


Ask is to configure this based on configured namespace (or namespaces if possible)
so can just do similar to WorkflowClient: 

    @Resource(name = "assignScheduleClient")
    private ScheduleClient assignScheduleClient;

    @Resource(name = "unassignScheduleClient")
    private ScheduleClient unassignScheduleClient;


---

<a id="2329"></a>

### #2329: Mock Workflow.currentTimeMillis() return value in test environment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2329 |
| **State** | CLOSED |
| **Author** | IgorMaj |
| **Created** | 2024-11-26 09:38:37.000 UTC (1y 1m ago) |
| **Updated** | 2024-11-26 16:16:41.000 UTC |
| **Closed** | 2024-11-26 16:00:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We're using Temporal and have several workflows. Some of these workflows rely on `Workflow.currentTimeMillis()` to get the current time.  We're having trouble injecting mocked time into it. While Mockito can mock static methods of classes like Workflow or WorkflowInternal, it fails silently because the test environment spawns another thread.  Java ignores mocked classes/methods if they are called from another thread. 

A simple setter inside `TestWorkflowEnvironment` could allow us to set the desired time, before starting a workflow.  The setter's name is not that important.  It could be added to the `WorkflowOptions` class?

I've skimmed the library implementation and found various interfaces which could potentially be implemented and injected to achieve the desired behavior.  `WorkflowOutboundCallsInterceptor` looks like a candidate, although it seems to be buried deep in the system internals. 

Thank you for your help and for taking the time to read this. 

P.S Does writing a wrapper, and using it instead make sense?

`
 public static long currentTimeMillis() {
        return testMode ?  MockableTime.toEpochMilli() : Workflow.currentTimeMillis();
    }
`


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-26 16:00:08.000 UTC</summary>

To control the initial in the test environment use `setInitialTime`.

```
    TestEnvironmentOptions testEnvOptions =
        TestEnvironmentOptions.newBuilder().setInitialTime(WORKFLOW_START_TIME).build();
    testEnv = TestWorkflowEnvironment.newInstance(testEnvOptions);
```

Reactions: üëç 1

</details>

<details>
<summary><strong>IgorMaj</strong> commented on 2024-11-26 16:16:40.000 UTC</summary>

Thank you for the answer.  Don't know How I missed that. 

</details>


---

<a id="2308"></a>

### #2308: Add WorkflowIdConflictPolicy in child workflow options 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2308 |
| **State** | OPEN |
| **Author** | AndresBena19 (Andres Benavides) |
| **Created** | 2024-11-05 03:00:29.000 UTC (1y 2m ago) |
| **Updated** | 2024-11-05 16:00:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
No

**Describe the solution you'd like**
`.setWorkflowIdConflictPolicy` were already added to `WorkflowOptions` but is not available for `ChildWorkflowOptions`

Reference:
* https://github.com/temporalio/sdk-java/pull/2055



#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-05 03:06:28.000 UTC</summary>

`WorkflowIdConflictPolicy` is not supported on Child workflows by the Temporal Server. The option would need to be supported by the Temporal Server before it could be exposed on the SDK.

https://github.com/temporalio/api/blob/5862ec7755d8c30577d76c335622b0147590e3fe/temporal/api/command/v1/message.proto#L203

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-05 16:00:31.000 UTC</summary>

I created a feature issue to track this work https://github.com/temporalio/features/issues/558.


</details>


---

<a id="2290"></a>

### #2290: Support workflow init in our spring boot integration 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2290 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-10-22 18:43:43.000 UTC (1y 2m ago) |
| **Updated** | 2025-04-07 21:48:02.000 UTC |
| **Closed** | 2025-04-07 21:48:02.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Support workflow init in our spring boot integration.

**Describe the solution you'd like**
Users of the Java SDK directly are able to specify `@WorkflowInit` on constructors of their workflow class constructors that take workflow args as a parameter. Currently this is not possible in our spring boot integration because workflow instances are created as beans which uses the constructor by default.




---

<a id="2287"></a>

### #2287: metric not exposed without workersAutoDiscovery property when using spring boot actuator.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2287 |
| **State** | CLOSED |
| **Author** | GwiYeong (gwiyeong) |
| **Created** | 2024-10-22 02:22:44.000 UTC (1y 2m ago) |
| **Updated** | 2025-05-01 22:48:39.000 UTC |
| **Closed** | 2025-05-01 22:48:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I'm using temporal spring boot `io.temporal:temporal-spring-boot-starter:1.25.1` and try to scrape metric from the temporal client.
I have two application, one is worker and other is api. Worker application was successfully showing metric(I can get metric from `http://localhost:8080/metrics/prometheus` but api application could not. After I'm trying to resolve this problem, finally I found one thing.
This is my api application properties
```
spring:
  temporal:
    namespace: local
    connection:
      target: 127.0.0.1:7233
```
There is no `workersAutoDiscovery` property that the worker has, because api doesn't need to start the worker, only use workflowClient, so I didn't put the property.
After putting the `workersAutoDiscovery` as dummy, the api application is showing metric (still worker is not started because package is dummy)
```
spring:
  temporal:
    namespace: local
    connection:
      target: 127.0.0.1:7233
    workersAutoDiscovery:
      packages: dummy
```
## Actual Behavior
Shows the temporal metric to the actuator without the `workersAutoDiscovery` property.


## Steps to Reproduce the Problem

  1. As written above.

## Specifications

  - Version: io.temporal:temporal-spring-boot-starter:1.25.1
  - Platform: Java 18


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-22 14:37:14.000 UTC</summary>

just to confirm are you using the client bean to make requests and still not seeing metrics?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-01 22:48:37.000 UTC</summary>

I was not able to replicate this issue using the client bean. Closing due to lack of replication, if you can provide a self contained replication we can reopen this issue to investigate.

</details>


---

<a id="2139"></a>

### #2139: Support "query" when listing schedules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2139 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-08 14:23:05.000 UTC (1y 6m ago) |
| **Updated** | 2024-07-31 16:22:43.000 UTC |
| **Closed** | 2024-07-31 16:22:43.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Describe the solution you'd like**

Need to support the query option when listing schedules same as we do when listing workflows.



---

<a id="2122"></a>

### #2122: Java SDK does not have option to register workflow name statically

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2122 |
| **State** | OPEN |
| **Author** | ftkurt (Fatih Kurt) |
| **Created** | 2024-06-24 11:19:00.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-27 11:44:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I'm always frustrated when trying to register a Java workflow with a static name. The current option using annotations does not work for our use case. We define proto enums and share them across different apps so they can trigger workflows across apps. For instance, we have:
```java
public interface MyWorkflow {
    @WorkflowMethod(name = "MyStaticWorkflowName")
    void execute();
}
```
We need a way to set a default workflow implementation type name during registration.

**Describe the solution you'd like**
A method to register a workflow with a static name during registration using something like:
```java
WorkflowImplementationOptions options = WorkflowImplementationOptions.newBuilder()
        .setDefaultWorkflowImplementationTypeName(Workflows.WORKFLOWS_SEND_SUBMISSION.name())
        .build();

worker.registerWorkflowImplementationTypes(options, SendSubmissionWorkflowImpl.class);
```
This would allow us to define workflows that can be triggered across different apps with a shared static name.

**Describe alternatives you've considered**
Currently, the alternative is to use the short name of the workflow interface by default. However, this does not meet our needs as we cannot share interfaces across apps written in different languages (Golang, Python). Using annotations alone is insufficient for our scenario.

**Additional context**
Our apps in Golang and Python cannot share Java interfaces, hence the need for a static name registration method. We currently share these names through protobuf-defined enums which can be built for all apps and envs. 


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-25 18:28:44.000 UTC</summary>

Would you also need the same functionality for activity names?

</details>

<details>
<summary><strong>ftkurt</strong> commented on 2024-06-27 11:44:14.000 UTC</summary>

@Quinn-With-Two-Ns yes, that will be useful as well. We are running some activities cross platform as well. 

</details>


---

<a id="2119"></a>

### #2119: Missing metric reporting in local activity execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2119 |
| **State** | OPEN |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2024-06-20 20:43:07.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-26 23:16:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
* `temporal_activity_succeed_endtoend_latency`
* `temporal_local_activity_execution_failed`
are emitted correctly

## Actual Behavior
They are missing in our production
<img width="806" alt="Screenshot 2024-06-20 at 1 44 16‚ÄØPM" src="https://github.com/temporalio/sdk-java/assets/4523955/d165081c-68d0-4168-a013-323886e9472e">

You can see in the graph that the LA execution metrics are reported but not end to end. In fact, this is happening most of the time. 
We also pretty sure there are many cases of LA execution failure but not reported based on our workflow history. 

## Steps to Reproduce the Problem
NA

## Specifications

  - Version: `1.22.3`
  - Platform:


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-24 20:48:10.000 UTC</summary>

>We also pretty sure there are many cases of LA execution failure but not reported based on our workflow history.

Can you provide a reproduction on this scenario? Do you see the same behaviour for normal activities? We have tests for these metrics and their implementation is identical to normal activity metrics.

</details>

<details>
<summary><strong>longquanzheng</strong> commented on 2024-06-26 23:16:18.000 UTC</summary>

> Do you see the same behaviour for normal activities?

No regular activity is fine. It is happening in production right now but I don't know how I can produce a sample for you. 

</details>


---

<a id="2090"></a>

### #2090: Warn or error when update handlers dangle across CAN or workflow exit

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2090 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-04 04:21:55.000 UTC (1y 7m ago) |
| **Updated** | 2024-08-13 15:09:17.000 UTC |
| **Closed** | 2024-08-13 15:09:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We can recommend the await-all-handlers or drop-all-handlers methods.  TBD whether error or warning. 

#### Comments (2)

<details>
<summary><strong>dandavison</strong> commented on 2024-06-28 12:21:16.000 UTC</summary>

I've merged the first PR, for Python: https://github.com/temporalio/sdk-python/pull/556

The basic spec that that PR's proposing for other SDKs is

- Workflow code can wait on a method named similarly to `workflow.all_handlers_finished()`

- By default, the worker will emit `workflow.UnfinishedUpdateHandlersWarning` and `workflow.UnfinishedSignalHandlersWarning` if any handlers of those types are unfinished when the workflow completes (cancellation, failure, success). See PR for wording of message.

- These warnings are controlled by a policy whose default value is `workflow.HandlerUnfinishedPolicy.WARN_AND_ABANDON`

- Users can silence the warning on a per-handler basis by setting unfinished_policy to `workflow.HandlerUnfinishedPolicy.ABANDON`

- Tests should verify the above for worker-side workflow exit via cancellation, failure, and success

</details>

<details>
<summary><strong>dandavison</strong> commented on 2024-07-29 17:18:53.000 UTC</summary>

Please add the [TMPRL1102](https://github.com/temporalio/rules/blob/main/rules/TMPRL1102.md) rule identifier to the warning message.

</details>


---

<a id="2064"></a>

### #2064: Native image descriptor for GraalVM in the temporal-spring-boot-starter-alpha

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2064 |
| **State** | OPEN |
| **Author** | Hnoianko |
| **Created** | 2024-05-14 20:27:58.000 UTC (1y 7m ago) |
| **Updated** | 2024-12-14 12:23:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
It would be nice to have native image descriptors as part of the temporal-spring-boot-starter-alphao

Similar to what already exists in the test-server
https://github.com/temporalio/sdk-java/tree/15df866f9c91219f6cf61533aee8fc2139ad7c93/temporal-test-server/src/main/resources/META-INF/native-image/io.temporal/temporal-test-server

Currently I am experiencing different build issues when trying to build a spring boot app native image.

Error example:
`Error: Classes that should be initialized at run time got initialized during image building:
[INFO]     [creator]      ch.qos.logback.core.util.StatusPrinter was unintentionally initialized at build time. To see why ch.qos.logback.core.util.StatusPrinter got initialized use --trace-class-initialization=ch.qos.logback.core.util.StatusPrinter
[INFO]     [creator]     io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder the class was requested to be initialized at run time (from 'META-INF/native-image/native-image.properties' in 'file:///workspace/' with 'io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder' and from 'META-INF/native-image/io/temporal/temporal-serviceclient/native-image.properties' in 'file:///workspace/BOOT-INF/lib/temporal-serviceclient-1.23.2.jar' with 'io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder'). To see why io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder
[INFO]     [creator]     ch.qos.logback.core.util.Loader was unintentionally initialized at build time. To see why ch.qos.logback.core.util.Loader got initialized use --trace-class-initialization=ch.qos.logback.core.util.Loader
[INFO]     [creator]     ch.qos.logback.classic.Level was unintentionally initialized at build time. To see why ch.qos.logback.classic.Level got initialized use --trace-class-initialization=ch.qos.logback.classic.Level
[INFO]     [creator]     io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator the class was requested to be initialized at run time (subtype of io.grpc.netty.shaded.io.netty.buffer.AbstractByteBufAllocator). To see why io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator
[INFO]     [creator]     io.grpc.netty.shaded.io.netty.buffer.AbstractByteBufAllocator the class was requested to be initialized at run time (from 'META-INF/native-image/native-image.properties' in 'file:///workspace/' with 'io.grpc.netty.shaded.io.netty.buffer.AbstractByteBufAllocator'). To see why io.grpc.netty.shaded.io.netty.buffer.AbstractByteBufAllocator got initialized use --trace-class-initialization=io.grpc.netty.shaded.io.netty.buffer.AbstractByteBufAllocator
[INFO]     [creator]     ch.qos.logback.classic.Logger was unintentionally initialized at build time. To see why ch.qos.logback.classic.Logger got initialized use --trace-class-initialization=ch.qos.logback.classic.Logger
[INFO]     [creator]     To see how the classes got initialized, use --trace-class-initialization=ch.qos.logback.core.util.StatusPrinter,io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder,ch.qos.logback.core.util.Loader,ch.qos.logback.classic.Level,io.grpc.netty.shaded.io.netty.buffer.UnpooledByteBufAllocator,io.grpc.netty.shaded.io.netty.buffer.AbstractByteBufAllocator,ch.qos.logback.classic.Logger
[INFO]     [creator`


#### Comments (2)

<details>
<summary><strong>Hnoianko</strong> commented on 2024-05-17 21:23:02.000 UTC</summary>

seems like the issue is coming from the erroneous native configs in the grpc-netty-shaded

https://github.com/grpc/grpc-java/issues/10601#issuecomment-1909221668 

</details>

<details>
<summary><strong>paramadeep</strong> commented on 2024-12-14 12:21:48.000 UTC</summary>

We are also facing  the same issue. Can someone help on how to resolve this. Or point to relevant material to understand this better to fix it. 
```
temporal-serviceclient/src/main/resources/META-INF/native-image/io/temporal/temporal-serviceclient/native-image.properties
```
file marks, 
```
--initialize-at-run-time=io.grpc.netty.shaded.io.netty.util.internal.logging.Slf4JLoggerFactory$NopInstanceHolder
```
On compilation we are getting the following error
```
ScriptCompilationException(scriptCompilationErrors=
[ScriptCompilationError(message=Unresolved reference: NopInstanceHolder, 
```

Could this be because it is a private class?


</details>


---

<a id="2063"></a>

### #2063: Extend TestWorkflowExtension to support specifying a custom task queue name

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2063 |
| **State** | OPEN |
| **Author** | Hnoianko |
| **Created** | 2024-05-14 12:23:52.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-15 03:15:01.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
As discussed in the following conversation https://community.temporal.io/t/integration-testing-for-java-sdk/7047/4?u=bohdan
it would be nice to have possibility to specify custom name for a worker queue when using TestWorkflowExtension.

**Describe the solution you'd like**
TestWorkflowExtension builder to have a setter for the worker taskQueueName. e.g. .setWorkerTaskQueue(TASK_QUEUE)

**Describe alternatives you've considered**

**Additional context**
[Add any other context or screenshots about the feature request here.](https://community.temporal.io/t/integration-testing-for-java-sdk/7047/4?u=bohdan)



---

<a id="2034"></a>

### #2034: Provide way to populate activity execution context for activity unit tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2034 |
| **State** | OPEN |
| **Author** | madhav2302 (Madhav Sodhani) |
| **Created** | 2024-04-11 19:32:21.000 UTC (1y 9m ago) |
| **Updated** | 2024-09-23 12:49:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I am writing unit tests for activity with `TestActivityEnvironment`, and using `var workflowType = Activity.getExecutionContext().getInfo().getWorkflowType();` in my activity. 

There is no way to populate this execution context for as of now other then creating a temporary workflow using `TestWorkflowEnvironment` and creating a sample workflow. 

Ideally, I should be able to setup execution context for tests without any interactions with workflows.

**Describe the solution you'd like**
Something like below would be nice.
```
TestActivityEnvironment.newInstance(TestEnvironmentOptions.newBuilder().setActivityExecutionContext(...).build())
```

**Describe alternatives you've considered**
Setting up test environment workflow, which is very tedious for unit tests.

**Additional context**
See https://temporalio.slack.com/archives/CTT84KXK9/p1712848268603179


#### Comments (2)

<details>
<summary><strong>madhav2302</strong> commented on 2024-09-20 20:18:00.000 UTC</summary>

@mfateev @cretz are there any plans to work on this? it will help with making tests easier. 

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-09-23 12:48:22.000 UTC</summary>

Hrmm, yes, it is common in other SDKs to be able to populate activity info for tests. So I believe that this will be done, but no concrete timeline currently. We will look to prioritize.

</details>


---

<a id="2018"></a>

### #2018: Kotlin `ActivityStubExt.execute*` extension functions wrap arguments in list

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2018 |
| **State** | CLOSED |
| **Author** | rgrochowicz (Rob Grochowicz) |
| **Created** | 2024-03-26 19:24:43.000 UTC (1y 9m ago) |
| **Updated** | 2025-05-16 00:24:17.000 UTC |
| **Closed** | 2025-05-16 00:24:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When I use the `ActivityStubExt.execute` extension function, I expect the `args` parameter to be given as-is to the underlying `ActivityStub.execute` method (keeping the varargs intact).

## Actual Behavior

The varargs `args` parameters to `ActivityStubExt.execute` is wrapped in a list rather than provided as a varargs parameter to `ActivityStub.execute`.

## Steps to Reproduce the Problem

  1. Create a new ActivityStub via `Workflow.newUntypedActivityStub`
  1. Import the Kotlin extension method via `import io.temporal.workflow.execute`
  1. Call `activityStub.execute<Void>("activityName", object { val foo = 1 })`
  1. Observe that the arguments were wrapped in a list rather than given directly to `ActivityStub.execute`

More complete example:

```kotlin
import io.temporal.workflow.execute
import io.temporal.activity.ActivityOptions

// ... within workflow ...

val activityStub = Workflow.newUntypedActivityStub(ActivityOptions {})
activityStub.execute("activityName", object { val foo = 1 })

```

The `ActivityTaskScheduled` event has an input of:

```json
[
  [
    {
      "foo": 1
    }
  ]
]
```

Rather than:

```json
[
  {
    "foo": 1
  }
]
```

The incorrect input is wrapped in an extra list.

To fix, I suspect that the call to `ActivityStub.execute` with varargs in [ActivityStubExt.kt](https://github.com/temporalio/sdk-java/blob/master/temporal-kotlin/src/main/kotlin/io/temporal/workflow/ActivityStubExt.kt#L36) needs to use the spread operator (`*`).

## Specifications

  - Version: Java SDK v1.23.0
  - Platform: macOS / Linux


#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-03-26 22:57:50.000 UTC</summary>

Yes I think we are missing a spread operator, thank you for reporting this. I will follow up with my team and consider if there are any backwards compatibility issues with fixing this. 

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-16 00:24:16.000 UTC</summary>

https://github.com/temporalio/sdk-java/pull/2395/files

</details>


---

<a id="2006"></a>

### #2006: ‚¨ÜÔ∏è Bump Protobuf Plugin

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2006 |
| **State** | CLOSED |
| **Author** | flaxel (Falk Puschner) |
| **Created** | 2024-03-14 08:00:30.000 UTC (1y 10m ago) |
| **Updated** | 2025-01-28 15:29:40.000 UTC |
| **Closed** | 2025-01-28 15:29:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

There is [a new major version for the proto plugin](https://github.com/protocolbuffers/protobuf/releases/tag/v26.0) and it would be nice to bump it in this repo, so we are able to bump our version too. There are breaking changes.

**Describe the solution you'd like**

Merge the protobuf PR with the new major version. Wanted to update [this PR](https://github.com/temporalio/sdk-java/pull/1752) but I was not able to do this. 

**Describe alternatives you've considered**
Just do it.


#### Comments (2)

<details>
<summary><strong>webchick</strong> commented on 2024-09-04 18:23:47.000 UTC</summary>

Just an update on this issue from @Quinn-With-Two-Ns in a conversation from Slack: 

Proto 4 has some issues with grpc-java. We're waiting for https://github.com/grpc/grpc-java/issues/11015 to resolve and plan to follow their recommendations for the widest compatibility.

Reactions: üëç 2

</details>

<details>
<summary><strong>edudar-chwy</strong> commented on 2024-12-30 18:13:44.000 UTC</summary>

If bumping the plugin is not an option yet, SDK should be made compatible with 3.x and 4.x. 

grpc recommends:
- [If one of your dependencies isn't compatible with 4.x, please file an issue with them](https://github.com/grpc/grpc-java/issues/11015#issuecomment-2470827638)
- [Everyone: Replace all references of GeneratedMessage and GeneratedMessageV3 outside of protoc-generated code with Message and Use protoc 25.x for your generated cod](https://github.com/grpc/grpc-java/issues/11015#issuecomment-2560196695)

More details on protobuf upgrade at https://github.com/googleapis/java-cloud-bom/releases/tag/v26.50.0

</details>


---

<a id="1997"></a>

### #1997: API key client option

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1997 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-02-27 15:21:07.000 UTC (1y 10m ago) |
| **Updated** | 2024-05-23 21:01:30.000 UTC |
| **Closed** | 2024-05-23 21:01:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/426

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-02 21:23:48.000 UTC</summary>

Is `AuthorizationGrpcMetadataProvider` sufficient or do we need to add another way to set the API key?

example:
```
    // Create the Workflow service stub.
    WorkflowServiceStubsOptions.Builder stubOptions =
        WorkflowServiceStubsOptions.newBuilder()
            .setChannelInitializer(
                (channel) -> {
                  channel.overrideAuthority(SERVER_NAME);
                  channel.intercept(MetadataUtils.newAttachHeadersInterceptor(metadata));
                })
            .addGrpcMetadataProvider(
                new AuthorizationGrpcMetadataProvider(() -> "Bearer " + API_KEY))
            .setTarget(ENDPOINT);
```

</details>

<details>
<summary><strong>cretz</strong> commented on 2024-05-03 12:42:32.000 UTC</summary>

I was hoping to have a literal `setApiKey` even if it's sugar, but can be convinced otherwise if we don't think it's needed here. I do think there may be a time soon where `setCloudApiKey` would default the target too, but that's for later.

</details>


---

<a id="1984"></a>

### #1984: [Temporal Spring-boot Starter] customizing workflow options by workflow type

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1984 |
| **State** | CLOSED |
| **Author** | sva02 |
| **Created** | 2024-02-05 09:51:50.000 UTC (1y 11m ago) |
| **Updated** | 2025-05-05 15:23:03.000 UTC |
| **Closed** | 2025-05-05 15:23:03.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**[Temporal Spring-boot Starter] cannot customize workflow options by workflow type**
The temporal spring boot starter doesn't provide the capability of customizing workflow implementations by workflow type.
Although there is `WorkflowImplementationOptions.Builder` option to use in `TemporalOptionsCustomizer`, it doesn't provide the flexibility to apply these options by workflow type.

When using the java-sdk, however, this is possible to do so when registering workflow implementations by:
`registerWorkflowImplementationTypes(WorkflowImplementationOptions options, Class<?>... workflowImplementationClasses)`

**Support customizing workflow implementation options by workflow type**
Add the capability to customize workflow options by workflow type when using the spring boot starter, as we might not want to apply these options to all workflow types.

** Context / Use Case **
For scheduled workflows, we want to fail the workflow on `NonDeterministicException.class`.
For the rest of the workflows, this behavior is not desired.

Thank you.


---

<a id="1959"></a>

### #1959: Missing Retry Policy on Continue-As-New

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1959 |
| **State** | CLOSED |
| **Author** | MatthewHou (Matthew Hou) |
| **Created** | 2023-12-28 06:13:28.000 UTC (2 years ago) |
| **Updated** | 2024-01-18 16:08:38.000 UTC |
| **Closed** | 2024-01-18 16:08:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
RetryPolicy should either be propagated or accepted as part of the `ContinueAsNewOptions` for Contine-As-New

## Actual Behavior
RetryPolicy is not set in the new workflow execution when `contineAsNew` is called. 
And we are not able to explicitly set `RetryOptions` when calling `contineAsNew`  since it is not included in the `ContinueAsNewOptions`. 

## Steps to Reproduce the Problem

  1. Start a workflow with a retry policy
  2. Workflow continued as new
  3. The retry policy is not set for the new workflow execution

## Specifications

  - Version: Java SDK 1.22.3
  - Platform: Java SDK


#### Comments (2)

<details>
<summary><strong>MatthewHou</strong> commented on 2023-12-28 08:24:15.000 UTC</summary>

Retry Options and other attributes are propagated by default in Go SDK and Python/TS SDK. This should help Java SDK to align the behaviour on continue-as-new. Please see the following issues

- https://github.com/temporalio/sdk-go/issues/695 
- https://github.com/temporalio/sdk-core/issues/372

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-18 16:08:38.000 UTC</summary>

closed by https://github.com/temporalio/sdk-java/pull/1961

</details>


---

<a id="1954"></a>

### #1954: TemporalTestServer add support to test schedules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1954 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2023-12-11 16:24:53.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-11 18:46:50.000 UTC |
| **Closed** | 2023-12-11 18:46:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to have the possibility to use the [temporal-test-server](https://github.com/temporalio/sdk-java/tree/master/temporal-test-server) to test [schedules](https://docs.temporal.io/workflows#schedule) 

**Describe the solution you'd like**

**Describe alternatives you've considered**
Run schedule test using a real/local server for now.

**Additional context**


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-12-11 18:36:34.000 UTC</summary>

The test server isn't really built well to be a multi-workflow server. You'd never be able to properly test multiple schedules or an overlapping schedule because they test server doesn't support concurrent, independent workflow runs (time skipping is server-wide not per workflow). We can hack it, but arguably it'd just be more confusing explaining all the ways it isn't the same as a real server.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-11 18:46:49.000 UTC</summary>

The time skipping test server is meant to cover testing individual workflow not features like schedules, it would require a complete re do of schedules in Java for little gain vs using a real server.

Going to close since we have no plans to do this.

</details>


---

<a id="1937"></a>

### #1937: Support a promise-based await

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1937 |
| **State** | OPEN |
| **Author** | ghaskins (Gregory Haskins) |
| **Created** | 2023-11-19 17:43:10.000 UTC (2y 1m ago) |
| **Updated** | 2024-11-22 05:42:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

An SDK function that works similarly to [await](https://javadoc.io/doc/io.temporal/temporal-sdk/1.0.0/io/temporal/workflow/Workflow.html#await-java.time.Duration-java.util.function.Supplier-) but is based on promises rather than blocking could be useful to expand developer options for coordinating mixed event classes.  For instance, coordinating an .all() on an invoked activity and receiving a signal.

This interface could be designed in several different ways.  As an example:

```
Promise until(java.time.Duration timeout, java.util.function.Supplier<java.lang.Boolean> predicate)
```

This function would take a timeout and predicate, and return a promise.  Temporal will evaluate the predicate on each state transition (similar to .await), and will resolve the promise with "true" if the predicate returns true. and "false" if the timeout expires.



#### Comments (2)

<details>
<summary><strong>ghaskins</strong> commented on 2023-11-19 17:45:28.000 UTC</summary>

Slack reference: https://temporalio.slack.com/archives/CTT84KXK9/p1700311804161219

</details>

<details>
<summary><strong>mfateev</strong> commented on 2023-11-19 17:53:01.000 UTC</summary>

To be consistent with existing APIs, my proposal is as follows:
```
class Async {
...
     static Promise<Boolean> await(Duration timeout, Supplier<Boolean> unblockCondition);
}
```

Reactions: üëç 1

</details>


---

<a id="1889"></a>

### #1889: spring-boot-starter-2.7.12.jar: 7 vulnerabilities (highest severity is: 9.8) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1889 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-10-10 17:07:38.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-10 17:07:48.000 UTC |
| **Closed** | 2023-10-10 17:07:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-starter-2.7.12.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-starter version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-1471](https://www.mend.io/vulnerability-database/CVE-2022-1471) | <img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20> Critical | 9.8 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-25857](https://www.mend.io/vulnerability-database/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-41854](https://www.mend.io/vulnerability-database/CVE-2022-41854) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38749](https://www.mend.io/vulnerability-database/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38752](https://www.mend.io/vulnerability-database/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38751](https://www.mend.io/vulnerability-database/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38750](https://www.mend.io/vulnerability-database/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p><p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20> CVE-2022-1471</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization.¬†Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content to restrict deserialization. We recommend upgrading to version 2.0 and beyond.


<p>Publish Date: 2022-12-01
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-1471>CVE-2022-1471</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>9.8</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374">https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374</a></p>
<p>Release Date: 2022-12-01</p>
<p>Fix Resolution: org.yaml:snakeyaml:2.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-41854</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Those using Snakeyaml to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack overflow. This effect may support a denial of service attack.

<p>Publish Date: 2022-11-11
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-41854>CVE-2022-41854</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/531/">https://bitbucket.org/snakeyaml/snakeyaml/issues/531/</a></p>
<p>Release Date: 2022-11-11</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>

#### Comments (2)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-10-10 17:07:47.000 UTC</summary>

:information_source: This issue was automatically closed by Mend because it is a duplicate of an existing issue: #1890

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-10-10 17:07:47.000 UTC</summary>

:information_source: This issue was automatically closed by Mend because it is a duplicate of an existing issue: #1890

</details>


---

<a id="1867"></a>

### #1867: use spring boot sdk, how to run workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1867 |
| **State** | CLOSED |
| **Author** | starboyate (Yate Zheng) |
| **Created** | 2023-09-22 09:20:21.000 UTC (2y 3m ago) |
| **Updated** | 2023-11-29 14:56:22.000 UTC |
| **Closed** | 2023-11-29 14:56:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

when I use temporal-spring-boot-starter-alpha,I hava a question, how to run workflow?

#### Comments (2)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-09-25 16:25:56.000 UTC</summary>

There are a number of ways to start a workflow, we have a guide here https://docs.temporal.io/dev-guide/java/foundations#start-workflow-execution

Reactions: üëç 1

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 14:56:21.000 UTC</summary>

Closing since this is not an SDK issue, feel free to ask general questions on our [forum](https://community.temporal.io/) or [community slack ](https://app.slack.com/client/TNWA8QCGZ/CNWA8QH09)

</details>


---

<a id="1824"></a>

### #1824: Make ProtobufPayloadConverter and ProtobufJsonPayloadConverter not final

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1824 |
| **State** | CLOSED |
| **Author** | stephenchen-humane |
| **Created** | 2023-07-21 20:03:41.000 UTC (2y 5m ago) |
| **Updated** | 2023-07-24 16:45:32.000 UTC |
| **Closed** | 2023-07-24 16:44:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

As part of writing our custom protobuf payload converters, we would like to extend the default ones for `json/protobuf` and `binary/protobuf` directly rather than extending the AbstractProtobufPayloadConverter and copying code from each impl. We cannot because the implementing classes are marked with `final`.




#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-07-24 13:56:47.000 UTC</summary>

I think it may be best if you just make a new payload converter and delegate to the one you want instead of using inheritance. The interfaces are quite small.

Reactions: üëç 1

</details>

<details>
<summary><strong>stephenchen-humane</strong> commented on 2023-07-24 16:44:33.000 UTC</summary>

sounds good, it is simple enough to not use inheritance.

</details>


---

<a id="1811"></a>

### #1811: SpringBoot - add @Primary to temporalWorkflowClient WorkflowClient Bean

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1811 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-07-11 13:35:42.000 UTC (2y 6m ago) |
| **Updated** | 2025-05-02 20:38:36.000 UTC |
| **Closed** | 2025-05-02 20:38:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Springboot autoconfig defines the primary WorkflowClient bean thats generated from config as:

      @Bean(name = "temporalWorkflowClient")
      public WorkflowClient client(ClientTemplate clientTemplate) {
        return clientTemplate.getWorkflowClient();
      }

For client app use case sometimes we need to create additional WorkflowClient beans (for example one for a different namespace thats part of the use case). Its not possible to do this via config so
to do this currently once a custom WorkflowClient bean is created, for example:

       @Bean(name = "customWorkflowClient")
       public WorkflowClient secondClient() {
         WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
         return WorkflowClient.newInstance(
        service, WorkflowClientOptions.newBuilder().setNamespace("xyz").build());
      }

There are two issues with this:
1. you cannot autowire the default WorkflowServiceStubs here because of cyclic dependency on the default template. user has to create a new WorkflowServiceStubs which seems unnecessary. 
2. Once you define this you no longer can resolve autowiring default WorkflowClient generated from config unless you use its name Qualifier, for example you have to do:

        @Autowired
        @Qualifier("temporalWorkflowClient") // gotta do this even if you don't autowire the custom one
        WorkflowClient client;
      
        @Autowired
        @Qualifier("customWorkflowClient")
        WorkflowClient customClient;

I think it would help if we annotate the default WorkflowClient bean with @Primary in order to allow autowiring the default
one without having to use Qualifier directly everywhere in your code. 
Another idea could be to allow config of multiple clients from config directly, but not sure this is best approach maybe.

Wdyt?


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-07-11 16:06:33.000 UTC</summary>

> For client app use case sometimes we need to create additional WorkflowClient beans

May need multiple clients for for worker apps too not just client apps.

This is similar to #1799 but more generic. There was internal discussion with myself and @Quinn-With-Two-Ns about how to possibly support multiple clients on multiple workers.

> annotate the default WorkflowClient bean with @primary in order to allow autowiring the default
one without having to use Qualifier directly everywhere in your code.

Concur on `@Primary` for the default, though we might need `@Qualifier` to support multiple clients on multiple workers, but maybe that's a separate issue.

</details>

<details>
<summary><strong>robzienert</strong> commented on 2023-08-14 19:10:31.000 UTC</summary>

FWIW, this would work so `@Qualifier` is unnecessary; perhaps already known:

```
@Autowired
WorkflowClient temporalWorkflowClient; // property named after the bean name
```

</details>


---

<a id="1803"></a>

### #1803: guava-31.1-jre.jar: 1 vulnerabilities (highest severity is: 7.1)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1803 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-06-29 20:54:32.000 UTC (2y 6m ago) |
| **Updated** | 2024-02-16 18:02:17.000 UTC |
| **Closed** | 2024-02-16 18:02:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>guava-31.1-jre.jar</b></p></summary>

<p>Guava is a suite of core and expanded libraries that include
    utility classes, Google's collections, I/O classes, and
    much more.</p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (guava version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-2976](https://www.mend.io/vulnerability-database/CVE-2023-2976) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.1 | guava-31.1-jre.jar | Direct | 32.0.1-android | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-2976</summary>


###  Vulnerable Library - <b>guava-31.1-jre.jar</b></p>

<p>Guava is a suite of core and expanded libraries that include
    utility classes, Google's collections, I/O classes, and
    much more.</p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar</p>
<p>

Dependency Hierarchy:
  - :x: **guava-31.1-jre.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Use of Java's default temporary directory for file creation in `FileBackedOutputStream` in Google Guava versions 1.0 to 31.1 on Unix systems and Android Ice Cream Sandwich allows other users and apps on the machine with access to the default Java temporary directory to be able to access the files created by the class.

Even though the security vulnerability is fixed in version 32.0.0, we recommend using version 32.0.1 as version 32.0.0 breaks some functionality under Windows.


 Mend Note: Even though the security vulnerability is fixed in version 32.0.0, maintainers recommend using version 32.0.1 as version 32.0.0 breaks some functionality under Windows.

<p>Publish Date: 2023-06-14
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-2976>CVE-2023-2976</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-7g45-4rm6-3mm3">https://github.com/advisories/GHSA-7g45-4rm6-3mm3</a></p>
<p>Release Date: 2023-06-14</p>
<p>Fix Resolution: 32.0.1-android</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>

#### Comments (2)

<details>
<summary><strong>CameronWard301</strong> commented on 2024-01-10 10:17:33.000 UTC</summary>

will this be fixed in the next temporal java sdk release?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-26 17:14:52.000 UTC</summary>

Generally we don't update dependencies if the issue doesn't effect the SDK to avoid forcing users to upgrade. Users are always free to use a newer version of a dependency then the SDK. That being said given the small diff between `31.1` and `32.0.1` it is probably fine to upgrade to silence vulnerability tools.

</details>


---

<a id="1802"></a>

### #1802: [Test server] ConcurrentModificationException on Workflow.upsertSearchAttributes in tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1802 |
| **State** | CLOSED |
| **Author** | sfc-gh-pjagielski (Piotr Jagielski) |
| **Created** | 2023-06-29 13:26:29.000 UTC (2y 6m ago) |
| **Updated** | 2023-10-23 14:24:54.000 UTC |
| **Closed** | 2023-10-23 14:24:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`Workflow.upsertTypedSearchAttributes` calls are successful in tests

## Actual Behavior
```
    Caused by: java.util.ConcurrentModificationException: null
    	at java.base/java.util.HashMap.compute(HashMap.java:1317)
    	at io.temporal.internal.testservice.TestVisibilityStoreImpl.upsertSearchAttributesForExecution(TestVisibilityStoreImpl.java:97)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.processUpsertWorkflowSearchAttributes(TestWorkflowMutableStateImpl.java:1542)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.processCommand(TestWorkflowMutableStateImpl.java:686)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.lambda$completeWorkflowTask$4(TestWorkflowMutableStateImpl.java:488)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.update(TestWorkflowMutableStateImpl.java:317)
    	... 12 common frames omitted
```

## Steps to Reproduce the Problem

See https://github.com/sfc-gh-pjagielski/temporal-playground/blob/main/src/main/kotlin/com/snowflake/HelloWorkflow.kt#L37
Failing build: https://github.com/sfc-gh-pjagielski/temporal-playground/actions/runs/5412424059/jobs/9836504936#step:5:837

## Specifications

  - Version: 1.20


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2023-06-29 13:55:59.000 UTC</summary>

Thanks for the report. Note, the time-skipping test server (and therefore TestWorkflowExtension using default built-in test server) is not built to run multiple top-level workflows concurrently. Time skipping is applied globally. So if one workflow is waiting on an activity (which disables time-skipping so it runs in real time) but another workflow is expected to time-skip until a timer, the latter won't happen immediately like it would if it were tested on its own.

@Quinn-With-Two-Ns and/or @mjameswh - while our test service isn't really built for concurrent top-level workflows, the map at https://github.com/temporalio/sdk-java/blob/57cb086f7df02c54e6952f46855eb9118c4b77ca/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestVisibilityStoreImpl.java#L58 should be concurrent map because technically child workflows can run concurrently too. I guess this was just missed in #1067. It seems other non-thread-safe constructs are used in `TestWorkflowMutableStateImpl` but that is per workflow execution so none of that code will run concurrently, and `TestWorkflowStoreImpl` locks things it uses, so it's just this field in `TestVisibilityStoreImpl` we need to fix.

</details>

<details>
<summary><strong>sfc-gh-pjagielski</strong> commented on 2023-06-30 07:07:41.000 UTC</summary>

@cretz thanks for the analysis! 
Currently we have some tests with concurrent workflows and this is the only issue that we're facing. Commenting out the code with `upsertSearchAttributes` helps, so I guess the change to `ConcurrentHashMap` should resolve the issue for us

</details>


---

<a id="1785"></a>

### #1785: Detailed message for exceptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1785 |
| **State** | CLOSED |
| **Author** | yashwantakashlal (Yashwant) |
| **Created** | 2023-06-12 17:05:21.000 UTC (2y 7m ago) |
| **Updated** | 2024-12-23 10:31:16.000 UTC |
| **Closed** | 2024-12-23 10:31:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When a workflow is already started and we try to start one more workflow with the same workflowId - we get io.temporal.client.WorkflowExecutionAlreadyStarted exception with message containing workflow details - workflowId='xxxxx', runId='yyy' - basically this - 
io.temporal.client.WorkflowExecutionAlreadyStarted: workflowId='xxxxx', runId='yyyyy'

**Describe the solution you'd like**
A clear and concise message should be thrown along with workflow details which denotes that workflow has already started with this id along with the workflow details.

**Additional context**
Screenshot of temporal slack discussion for context.
<img width="735" alt="Screenshot 2023-06-12 at 10 34 45 PM" src="https://github.com/temporalio/sdk-java/assets/65457583/0102bc44-b587-4eec-b922-8b7164b23c90">


#### Comments (2)

<details>
<summary><strong>yashwantakashlal</strong> commented on 2023-10-04 18:01:50.000 UTC</summary>

hi @tsurdilo / @Spikhalskiy , is this being worked upon by someone ? just wanted to understand if this is being taken forward, if not I might give it a try as well.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-04 18:30:39.000 UTC</summary>

Unlikely this would be taken forward, the intention is users deduce the message from the exception type and  changing the message would be a backwards incompatible change to `WorkflowExecutionAlreadyStarted`.

</details>


---

<a id="1738"></a>

### #1738: spring-boot-dependencies-2.7.9.pom: 2 vulnerabilities (highest severity is: 6.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1738 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-04-14 12:01:46.000 UTC (2y 9m ago) |
| **Updated** | 2023-10-10 17:07:44.000 UTC |
| **Closed** | 2023-10-10 17:07:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-dependencies-2.7.9.pom</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/5.3.25/d681cdb86611f03d8ef29654edde219fe5afef1d/spring-expression-5.3.25.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/5.3.25/d681cdb86611f03d8ef29654edde219fe5afef1d/spring-expression-5.3.25.jar</p>
<p>

</details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-dependencies version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-20861](https://www.mend.io/vulnerability-database/CVE-2023-20861) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | spring-expression-5.3.25.jar | Transitive | N/A* | &#10060; |
| [CVE-2023-20863](https://www.mend.io/vulnerability-database/CVE-2023-20863) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | spring-expression-5.3.25.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p><p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2023-20861</summary>


###  Vulnerable Library - <b>spring-expression-5.3.25.jar</b></p>

<p>Spring Expression Language (SpEL)</p>
<p>Library home page: <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/5.3.25/d681cdb86611f03d8ef29654edde219fe5afef1d/spring-expression-5.3.25.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/5.3.25/d681cdb86611f03d8ef29654edde219fe5afef1d/spring-expression-5.3.25.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.9.pom (Root Library)
    - :x: **spring-expression-5.3.25.jar** (Vulnerable Library)
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In Spring Framework versions 6.0.0 - 6.0.6, 5.3.0 - 5.3.25, 5.2.0.RELEASE - 5.2.22.RELEASE, and older unsupported versions, it is possible for a user to provide a specially crafted SpEL expression that may cause a denial-of-service (DoS) condition.

<p>Publish Date: 2023-03-23
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-20861>CVE-2023-20861</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://spring.io/security/cve-2023-20861">https://spring.io/security/cve-2023-20861</a></p>
<p>Release Date: 2023-03-23</p>
<p>Fix Resolution: org.springframework:spring-expression:x5.2.23.RELEASE,5.3.26,6.0.7</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2023-20863</summary>


###  Vulnerable Library - <b>spring-expression-5.3.25.jar</b></p>

<p>Spring Expression Language (SpEL)</p>
<p>Library home page: <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/5.3.25/d681cdb86611f03d8ef29654edde219fe5afef1d/spring-expression-5.3.25.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/5.3.25/d681cdb86611f03d8ef29654edde219fe5afef1d/spring-expression-5.3.25.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.9.pom (Root Library)
    - :x: **spring-expression-5.3.25.jar** (Vulnerable Library)
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In spring framework versions prior to 5.2.24 release+ ,5.3.27+ and 6.0.8+ , it is possible for a user to provide a specially crafted SpEL expression that may cause a denial-of-service (DoS) condition.

<p>Publish Date: 2023-04-13
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-20863>CVE-2023-20863</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://spring.io/security/cve-2023-20863">https://spring.io/security/cve-2023-20863</a></p>
<p>Release Date: 2023-04-13</p>
<p>Fix Resolution: org.springframework:spring-expression - 5.2.24.RELEASE,5.3.27,6.0.8</p>

</p>

<p></p>

</details>

#### Comments (2)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-10-10 17:07:44.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-10-10 17:07:44.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1722"></a>

### #1722: Signal with a local activity in the last Workflow Task hangs the workflow execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1722 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-28 02:18:11.000 UTC (2y 9m ago) |
| **Updated** | 2023-10-25 17:05:57.000 UTC |
| **Closed** | 2023-10-25 17:05:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

"last workflow task of the workflow" in this ticket means the WFT that will complete workflow method execution and will lead to `CompleteWorkflowExecution` command. 

## Expected Behavior

If the workflow receives a signal in the last workflow task, this signal should be successfully processed first and the workflow should complete after that.

## Actual Behavior

If workflow receives a signal with the last workflow task and this signal starts a local activity and the workflow method is not explicitly waiting for the signal completion, it leads to 

```
io.grpc.StatusRuntimeException: INVALID_ARGUMENT: invalid command sequence: [CompleteWorkflowExecution, RecordMarker], command CompleteWorkflowExecution must be the last command.
```

See https://github.com/Spikhalskiy/java-sdk/commit/c0a397ec4e5e0101b70f417ff4d244df7c291c26 for a test reproducing the problem.

## Proposed solutions

One of:

1. Completion of the workflow method shouldn't lead to an immediate `CompleteWorkflowExecution` command. Instead, `CompleteWorkflowExecution` should be issued at the end of that workflow task.
2. Completion of the workflow method shouldn't lead to an immediate `CompleteWorkflowExecution` command. Instead, `CompleteWorkflowExecution` should be issued at the end of all workflow threads (including Async and Signal)
3. If the first two are hard to implement and maintain backward compatibility, CompleteWorkflowExecution` should be the last command written. All commands after it should be discarded. This is the least graceful way of handling this situation.

#### Comments (2)

<details>
<summary><strong>longquanzheng</strong> commented on 2023-04-03 16:18:17.000 UTC</summary>

Hey @Spikhalskiy , probably just ciruous, is that only an issue with local activity? What about other commands like activity scheduled or childWF or upsert search attributes?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-03 16:46:40.000 UTC</summary>

It's true for any command happening in a signal after a yield if the workflow method doesn't wait for the signal method completion.

</details>


---

<a id="1715"></a>

### #1715: WorkerOptions should enforce an amount of executors to be not less than an amount of pollers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1715 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-24 00:03:01.000 UTC (2y 9m ago) |
| **Updated** | 2023-05-23 18:20:24.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | 1.20.0 |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior

WorkerOptions should enforce an amount of executors to be not less than an amount of pollers.

## Actual Behavior

Currently, users can create WorkerOptions with maxConcurrentWorkflowTaskExecutionSize = 1 which is effectively an invalid configuration with the worker not being able to open at least one sticky and 1 normal queue poll. Every worker needs at least 2 executors: one to be reserved and allow polling on the main task queue and another to be reserved and allow polling on a sticky task queue.


---

<a id="1709"></a>

### #1709: Cancellation of external workflow needs test coverage

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1709 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-22 15:56:02.000 UTC (2y 9m ago) |
| **Updated** | 2025-05-14 14:51:58.000 UTC |
| **Closed** | 2025-05-14 14:51:58.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**

User-facing "external" workflow cancelation API and implementation that are not covered by any unit test.

See
```
ExternalWorkflowStub#cancel
SyncWorkflowContext#cancelWorkflow
```

https://coveralls.io/builds/57953701/source?filename=temporal-sdk%2Fsrc%2Fmain%2Fjava%2Fio%2Ftemporal%2Finternal%2Fsync%2FSyncWorkflowContext.java#L1037


---

<a id="1703"></a>

### #1703: WorkerFactoryOptions getDefaultInstance() does not return the default instance

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1703 |
| **State** | CLOSED |
| **Author** | cherry-lim |
| **Created** | 2023-03-17 21:22:49.000 UTC (2y 9m ago) |
| **Updated** | 2023-03-17 23:04:56.000 UTC |
| **Closed** | 2023-03-17 21:26:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
WorkerFactoryOptions getDefaultInstance() should return the default instance where the max cache size, max thread count etc. are set to the default values

## Actual Behavior
WorkerFactoryOptions getDefaultInstance() does not return the instance with default values

## Steps to Reproduce the Problem

  1. call WorkerFactoryOptions.getDefaultInstance() and look at the fields


## Specifications

  - Version: 1.17.0
  - Platform: 


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-17 21:26:45.000 UTC</summary>

The instance returned by WorkerFactoryOptions#getDefaultInstance will lead to the default configuration if it's used to create WorkerFactory.
We don't publish fields that were not overriden to support merging of properties from different sources.


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-17 23:04:55.000 UTC</summary>

If you want to read the default values for whatever purposes, you may use ```WorkerFactoryOptions.newBuilder().validateAndBuildWithDefaults()```

</details>


---

<a id="1700"></a>

### #1700: spring-boot-starter-2.7.9.jar: 7 vulnerabilities (highest severity is: 9.8) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1700 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-03-16 04:03:40.000 UTC (2y 10m ago) |
| **Updated** | 2023-10-10 17:07:42.000 UTC |
| **Closed** | 2023-10-10 17:07:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-starter-2.7.9.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-starter version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-1471](https://www.mend.io/vulnerability-database/CVE-2022-1471) | <img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20> Critical | 9.8 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-25857](https://www.mend.io/vulnerability-database/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-41854](https://www.mend.io/vulnerability-database/CVE-2022-41854) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38749](https://www.mend.io/vulnerability-database/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38752](https://www.mend.io/vulnerability-database/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38751](https://www.mend.io/vulnerability-database/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38750](https://www.mend.io/vulnerability-database/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p><p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20> CVE-2022-1471</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.9.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization.¬†Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content to restrict deserialization. We recommend upgrading to version 2.0 and beyond.


<p>Publish Date: 2022-12-01
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-1471>CVE-2022-1471</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>9.8</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374">https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374</a></p>
<p>Release Date: 2022-12-01</p>
<p>Fix Resolution: org.yaml:snakeyaml:2.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.9.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-41854</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.9.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Those using Snakeyaml to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack overflow. This effect may support a denial of service attack.

<p>Publish Date: 2022-11-11
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-41854>CVE-2022-41854</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/531/">https://bitbucket.org/snakeyaml/snakeyaml/issues/531/</a></p>
<p>Release Date: 2022-11-11</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.9.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.9.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.9.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.9.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/6156036f9d07be7480b350b3b0a5c632579778c7">6156036f9d07be7480b350b3b0a5c632579778c7</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>

#### Comments (2)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-10-10 17:07:41.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-10-10 17:07:42.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1681"></a>

### #1681: Exceptions thrown from workflow executor code shouldn't be subject to failWorkflowExceptionTypes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1681 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-28 20:50:53.000 UTC (2y 10m ago) |
| **Updated** | 2024-12-17 21:19:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently, if our workflow executor / control code throws an exception, it's a subject for `WorkflowImplementationOptions#failWorkflowExceptionTypes` logic and users can set up their system in a way that such exceptions may fail the workflow execution.

An example:
Workflow Executor throws `java.lang.IllegalStateException: History is out of order` if it received a sticky task and its cached instance is outdated. Our expectation is that this exception will fail WFT and cause a full replay and an execution on another (or the same) worker.

In reality, users may set `failWorkflowExceptionTypes` into a broad category like `Exception` and such an internal exception will start to fail workflow executions. Doing this, users expect `failWorkflowExceptionTypes` to be applied only to the workflow exceptions, but it's also applied to the workflow executor exception.

Proposed solution:

Don't apply `WorkflowImplementationOptions#failWorkflowExceptionTypes` to the exceptions from the control code.
Exceptions thrown by the control code should always fail Workflow Task, not a Workflow Execution.
There needs to be one (?at least one?) exception from this new rule - `io.temporal.worker.NonDeterministicException`. We have users that explicitly want to fail executions if a non-deterministic error happens.

#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2023-02-28 21:31:48.000 UTC</summary>

I think we should keep the current logic of applying `failWorkflowExceptionTypes` to any unexpected error from the control code. But for situations that we know are intermittent we should try to retry. 

Another option is to apply `failWorkflowExceptionTypes` on a second or (Nth) task attempt. This way, intermittent failures would not lead to workflow failures.  

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-20 18:43:56.000 UTC</summary>

We should be throwing an explicit FailWorkflowTaskException of something like this from the SDK internals if we expect that this exception should always be failing the WFT only and never follow the user-specified criteria.

</details>


---

<a id="1676"></a>

### #1676: Child WF fails on signaling a 'not found' WF although the signal was handled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1676 |
| **State** | CLOSED |
| **Author** | shaharco (shahar cohen) |
| **Created** | 2023-02-26 21:42:33.000 UTC (2y 10m ago) |
| **Updated** | 2023-05-23 18:17:45.000 UTC |
| **Closed** | 2023-05-23 18:17:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The child WF should be completed successfully after signaling

## Actual Behavior
As was explained in:  https://temporalio.slack.com/archives/CTT84KXK9/p1677446296370919
We have some weird case with signals:
We have a 'manager' WF that queues and start child WFs. When a child WF ends, it sends a signal back to the manager (in a detached cancellation scope on finally block), and when the manager has nothing in its queue, it exists.
Sometimes we see a case where a child WF signals on end, the signal gets to the manager which handles and exists, but the child WF eventually fails on:
io.temporal.failure.ApplicationFailure: message='SignalExternalWorkflowExecution failed with NOT_FOUND. WorkflowId=<XYZ>, runId=', type='SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND', nonRetryable=false
Can it be that the parent WF manage to complete but somehow the child still didn't handle the signal, although the signal got to the parent? 

## Steps to Reproduce the Problem
See attached parent and child WF histories

## Specifications

  - Version: 1.18.1
  
[histories.zip](https://github.com/temporalio/sdk-java/files/10834791/histories.zip)



#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2023-04-11 15:22:44.000 UTC</summary>

Looking at the history I believe workflow completes before the last child signal is sent. If you can create a reproduction of the issue then we can look futher.



</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 18:17:45.000 UTC</summary>

Closing due to lack of activity.

</details>


---

<a id="1597"></a>

### #1597: issue - when   @Autowired spring cloud open feign client bean into  bean with @ActivityImpl @Component, this.workerFactory.start(); gonna start workers so that could not auto register other workers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1597 |
| **State** | CLOSED |
| **Author** | jack-yu-matrix (Jack Yu) |
| **Created** | 2023-01-10 08:44:10.000 UTC (3 years ago) |
| **Updated** | 2023-01-25 00:59:45.000 UTC |
| **Closed** | 2023-01-25 00:59:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

https://github.com/temporalio/sdk-java/blob/71bc122eff4af3a1f53d98fab27d5d7a7f231d92/temporal-spring-boot-autoconfigure-alpha/src/main/java/io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.java#L152

#### Comments (2)

<details>
<summary><strong>jack-yu-matrix</strong> commented on 2023-01-10 08:47:35.000 UTC</summary>

this situation happened when I auto-waire a spring cloud open feign client into activitiesImpl, if ActivitiesImpl bean need autowire spring cloud open feign bean managed by spring, spring  will trigger ContextRefreshedEvent and then, WorkerFactory.State.Started which resulting in no other new workers can be auto registered , Preconditions.checkState(this.state == WorkerFactory.State.Initial, String.format("attempted to %s while in %s state. Acceptable States: %s", "create new worker", this.state.name(), WorkerFactory.State.Initial.name()));

</details>

<details>
<summary><strong>jack-yu-matrix</strong> commented on 2023-01-10 09:00:46.000 UTC</summary>

I use 
    @Lazy
    @Autowired
    private FeignClient feignClient; 
to workaround this issue temporarily 

</details>


---

<a id="1584"></a>

### #1584: ExternalWorkflowStub query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1584 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-01-05 05:22:44.000 UTC (3 years ago) |
| **Updated** | 2024-10-25 19:46:44.000 UTC |
| **Closed** | 2023-01-05 07:17:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Feature request is to please add ability to query via ExternalWorkflowStub. Currently signal is only possible.

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-05 07:17:28.000 UTC</summary>

This is not an SDK issue. ExternalWorkflowStub has an underlying implementation in state machines and produces commands. There is no command and no underlying workflow history baked implementation for query currently.
So, this needs a new command and Server support first.
Workaround: use an activity to query an external workflow.

</details>

<details>
<summary><strong>rocketraman</strong> commented on 2024-10-25 19:46:43.000 UTC</summary>

Do we have a tracking issue for the new command and server support for this? I also can't do `@Update` from a parent workflow, and it is quite an annoyance to have to delegate the call to an activity.

</details>


---

<a id="1557"></a>

### #1557: Return not-found with `NamespaceNotFoundFailure` when namespace not found (and other errordetails)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1557 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-12-05 17:13:32.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-05 17:41:37.000 UTC |
| **Closed** | 2022-12-05 17:41:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

When calling `DescribeNamespace` for unknown namespace, no error raised

**Describe the solution you'd like**

Return not found error with `temporal.api.errordetails.v1.NamespaceNotFoundFailure` in the gRPC status details. Also support any missing error details from https://github.com/temporalio/api/blob/master/temporal/api/errordetails/v1/message.proto on other calls.

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-05 17:15:24.000 UTC</summary>

Right now Test Server supports all namespaces as registered for user convenience. It's a design choice.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-12-05 17:41:37.000 UTC</summary>

Ok, I will close this as intentional deviation from regular server and for my test that confirms behavior on unregistered namespace, I'll just skip the test server for now

Reactions: üëç 1

</details>


---

<a id="1551"></a>

### #1551: Error while implementing Inheritance | Java SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1551 |
| **State** | CLOSED |
| **Author** | jeenadeepak |
| **Created** | 2022-12-01 04:06:36.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-08 00:33:51.000 UTC |
| **Closed** | 2022-12-08 00:33:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

class P2PProcessRequest {}
class IMPSProcessRequest {}

interface TranslationWorkflow<R> {
	void process(R request);
}

interface P2PWorkflow extends TranslationWorkflow <P2PProcessRequest>{
    @Override
    @WorkflowMethod(name = "P2P")
    void process(P2PProcessRequest request);
    
}
interface IMPSWorkflow extends OrderWorkflow <IMPSProcessRequest>{
    @Override
    @WorkflowMethod(name = "IMPS")
    void process(IMPSProcessRequest request);
    
}
class P2PWorkflowImpl implements P2PWorkflow {
    @Override
    public void process(P2PProcessRequest request) {
    	System.out.println("P2P transation done");
    }
}
class IMPSWorkflowImpl implements IMPSWorkflow {
    @Override
    public void process(IMPSProcessRequest request) {
    	System.out.println("IMPS transation done");
    }
}

I am trying to implement 2 different flow for transition.

## Expected Behavior
Code should execute successfully for above show scenario.

## Actual Behaviour
Thowing error multiple signal method found P2PWorkflow:process and TranslationWorkflow:process, while creating P2PWorkflow/IMPSWorkflow workflow stub.
 @WorkflowMethod is only define one time for TranslationWorkflow.

  - Version: v1.17.0
  - Platform: java


#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2022-12-08 00:14:16.000 UTC</summary>

Generics are not supported. What is the R type?


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-12-08 00:33:51.000 UTC</summary>

Duplicate of #1106

</details>


---

<a id="1541"></a>

### #1541: TLS server for java sdk connection option.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1541 |
| **State** | CLOSED |
| **Author** | XingLiu0923 |
| **Created** | 2022-11-27 14:02:29.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-27 23:46:51.000 UTC |
| **Closed** | 2022-11-27 17:13:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Before I connect to my Temporal cluster, I need to connect to the TLS server to get certificate then I could connect to the Temporal cluster. In go language, I could do like below:
```
var connOptions client.ConnectionOptions
	if cfg.Temporal.TLSServer != "" {
		connOptions = client.ConnectionOptions{
			TLS: &tls.Config{
				ServerName: cfg.Temporal.TLSServer,
			},
		}
	}

c, err := client.NewClient(client.Options{
	HostPort:          cfg.Temporal.HostPort,
	Namespace:         cfg.Temporal.Namespace,
	ConnectionOptions: connOptions,
})
```
But in java, i did not find way to do this.

**Describe the solution you'd like**
Got a way to set TLS server in java.

**Describe alternatives you've considered**
I did not find alternatives ...


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-27 17:13:19.000 UTC</summary>

Use `ServiceStubsOptions#setChannelInitializer` to intercept the creation of gRPC's `ManagedChannelBuilder`. On gRPC's `ManagedChannelBuilder` you can set a custom tls server name in `ManagedChannelBuilder#overrideAuthority`.

Please use Temporal forum or Slack community to ask questions: 
https://community.temporal.io
https://t.mp/slack

</details>

<details>
<summary><strong>XingLiu0923</strong> commented on 2022-11-27 23:45:26.000 UTC</summary>

> Use `ServiceStubsOptions#setChannelInitializer` to intercept the creation of grpc's `ManagedChannelBuilder`. On grpc `ManagedChannelBuilder` you can set a custom tls server name in `ManagedChannelBuilder#overrideAuthority`.
> 
> Please use Temporal forum or Slack community to ask questions: https://community.temporal.io https://t.mp/slack

Got it. Thanks for the reply! Sorry for asking in wrong place. now i know where to ask, thanks!

Reactions: üëç 1

</details>


---

<a id="1531"></a>

### #1531: Declaring ActivityStub using annotation instead of newActivityStub

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1531 |
| **State** | OPEN |
| **Author** | s-aliasgar |
| **Created** | 2022-11-23 06:47:55.000 UTC (3y 1m ago) |
| **Updated** | 2024-07-16 10:19:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

temporal-sdk: 1.17.0
temporal-spring-boot-starter-alpha: 1.17.0

When using Temporal-Springboot-alpha since the workers are created by Temporal-Springboot-alpha 
Can we declare ActivityStub using an annotation?
Something like

@ActivityStub(
      taskQueue = SOME_QUEUE,
      retryOptions =
          @RetryActivityOptions(
              maximumAttempts = 1,
              doNotRetry = {"SomeException"}))
  private ISomeActivity someActivity;


Instead of defining it as "Workflow.newActivityStub(ISomeActivity.class, activityOptions)"



#### Comments (2)

<details>
<summary><strong>s-aliasgar</strong> commented on 2022-11-24 04:41:10.000 UTC</summary>

https://community.temporal.io/t/declaring-activitystub-using-annotation-instead-of-newactivitystub/6553

</details>

<details>
<summary><strong>yurenji</strong> commented on 2024-07-16 10:19:15.000 UTC</summary>

+1 

</details>


---

<a id="1519"></a>

### #1519: Add num_pollers metric

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1519 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-11-16 22:21:36.000 UTC (3y 1m ago) |
| **Updated** | 2025-05-13 14:49:42.000 UTC |
| **Closed** | 2025-05-13 14:49:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

A gauge of concurrent active pollers as emitted by Core SDK.

#### Comments (2)

<details>
<summary><strong>yiminc</strong> commented on 2022-11-17 00:25:05.000 UTC</summary>

Need to be able to tell how many activity pollers and how many workflow pollers. 

</details>

<details>
<summary><strong>bergundy</strong> commented on 2022-11-17 00:51:18.000 UTC</summary>

See the docs for reference: https://docs.temporal.io/references/sdk-metrics#num_pollers

</details>


---

<a id="1479"></a>

### #1479: Spring Boot Starter dependency problem when using Maven

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1479 |
| **State** | CLOSED |
| **Author** | jrogers (Jeff Rogers) |
| **Created** | 2022-10-13 17:22:00.000 UTC (3y 2m ago) |
| **Updated** | 2022-10-13 21:06:26.000 UTC |
| **Closed** | 2022-10-13 21:06:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.17.0 |

#### Description

## Expected Behavior

Including the `temporal-spring-boot-starter-alpha` dependency in a spring boot project fails with a maven validation error.

## Actual Behavior

Get the following error. It looks to be caused by the missing version on the `org.springframework.boot:spring-boot-starter` dependency in the output POM file.

```
[WARNING] The POM for io.temporal:temporal-spring-boot-starter-alpha:jar:1.16.0 is invalid, transitive dependencies (if any) will not be available: 1 problem was encountered while building the effective model for io.temporal:temporal-spring-boot-starter-alpha:1.16.0
[ERROR] 'dependencies.dependency.version' for org.springframework.boot:spring-boot-starter:jar is missing. @ 
```

## Steps to Reproduce the Problem

  1. Include spring boot starter dependency in project:
  ```
          <dependency>
            <groupId>io.temporal</groupId>
            <artifactId>temporal-spring-boot-starter-alpha</artifactId>
            <version>${temporal.version}</version>
        </dependency>
  ```

## Specifications

  - Version: 1.16.0
  - Platform: Mac/Linux


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-10-13 17:34:21.000 UTC</summary>

This is quite strange.

https://repo1.maven.org/maven2/io/temporal/temporal-spring-boot-autoconfigure-alpha/1.16.0/temporal-spring-boot-autoconfigure-alpha-1.16.0.pom
contains
```
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>2.7.3</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
```
which should be picked up by temporal-spring-boot-starter-alpha transitively and be enough. Probably some problem in Gradle->Maven exporter plugin.
I will try to add the BOM explicitly to temporal-spring-boot-starter-alpha.

Meanwhile, you can try to add
```
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>2.7.3</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
```

explicitly in your project to try mitigate the issue.

</details>

<details>
<summary><strong>jrogers</strong> commented on 2022-10-13 17:39:43.000 UTC</summary>

So if I include the `autoconfigure-alpha` dependency it works, however the `starter-alpha` does not - note the documentation in the autoconfigure readme says to use the starter-alpha as the dependency in a project.
Now that I look at it closer, the starter doesn't actually seen to do anything beyond the autoconfigure, the autoconfigure itself seems to be the standard spring boot starter setup.
Note you can see the dependency is not resolved in the starter module if you look at the maven pom - https://search.maven.org/artifact/io.temporal/temporal-spring-boot-starter-alpha/1.16.0/jar

</details>


---

<a id="1449"></a>

### #1449: Spring Boot - add support for dynamic worklows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1449 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-09-21 13:30:58.000 UTC (3y 3m ago) |
| **Updated** | 2025-05-03 06:15:17.000 UTC |
| **Closed** | 2025-05-03 06:15:17.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

      @WorkflowImpl(taskQueues = "MyTaskQueueName")
      public class MyWorkflow implements DynamicWorkflow { ... }

currently raises:

     Class doesn't implement any non empty public interface annotated with @WorkflowInterface:

If possible please add support for DynamicWorkflow 


---

<a id="1358"></a>

### #1358: Add CI testing for the native test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1358 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-10 14:31:23.000 UTC (3y 5m ago) |
| **Updated** | 2024-12-17 21:20:28.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
We don't have CI testing for the native test server. As a result of that, we can release a version of SDK with a broken native test server build that affects users as it happened here: https://github.com/temporalio/sdk-java/issues/1357

**Describe the solution you'd like**
Test Server should have some integration tests for the native test server image.


---

<a id="1346"></a>

### #1346: Await on Local Activities shouldn't occupy workflow executor thread

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1346 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-04 20:45:06.000 UTC (3y 5m ago) |
| **Updated** | 2023-05-23 17:49:58.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Right now when workflow performs local activities, the workflow executor thread is retained and idling.
This is a simple solution, but it puts users in a tricky situation when they need to take into account the specific profile of their local activities when they set a number of workflow executor threads.
It also leads to a potentially uneven load and wasted resources. 

**Describe the solution you'd like**
Workflow executor thread shouldn't actively wait for local activities completion and release the thread.

**Describe alternatives you've considered**

**Additional context**
The solution requires significant restructuring of workflow executor worker code.
Implementation should implement backpressure correctly. If Worker has a lot of workflow executor threads, but no free local activity worker threads, workflow can't make a progress and will be snowballing errors in the system.



---

<a id="1306"></a>

### #1306: Use client OpenTracing/OpenTelemetry spans for signal and queries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1306 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-07-14 02:43:41.000 UTC (3y 6m ago) |
| **Updated** | 2024-09-18 23:34:55.000 UTC |
| **Closed** | 2024-09-18 23:34:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Signal and query handlers and threads inherit the client span as a parent span and form a solid spans chain with spans of the clients calling a signal or a query method.

## Actual Behavior

Historically Temporal server signal and query APIs didn't have headers and it wasn't possible to transfer additional payloads like spanId from the caller. Signal and queries currently don't inherit the client's span.


#### Comments (2)

<details>
<summary><strong>deepakjeena</strong> commented on 2023-06-29 05:09:40.000 UTC</summary>

Hi Team, any update on this

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-18 23:34:54.000 UTC</summary>

Closed by https://github.com/temporalio/sdk-java/pull/1819

</details>


---

<a id="1303"></a>

### #1303: Cancelation of Local Activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1303 |
| **State** | OPEN |
| **Author** | GeekNickson (Sadboi) |
| **Created** | 2022-07-11 07:56:55.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-11 14:52:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

I have a bunch of local activities with retry options configured that are being ran inside a cancellation scope like so:
```
val scope = Workflow.newCancellationScope { _ -> 
  activity1.execute()
  ....
  activityN.execute()
}
Workflow.newTimer(Duration.ofSeconds(10))
  .thenApply { scope.cancel() }

scope.run()
```
I expected that when **scope.cancel()** method is called that would close the scope with the running activities just as it works with normal activities.
## Actual Behavior

Activities proceed to retry, the code after scope.run() doesn't execute

## Specifications

  - Version: 1.13.0
  - Platform: Java


#### Comments (2)

<details>
<summary><strong>GeekNickson</strong> commented on 2022-07-11 09:12:48.000 UTC</summary>

The problem persists in version 1.14.0 as well

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-11 14:50:58.000 UTC</summary>

Heartbeats and cancelations are not supported for Local Activities in JavaSDK. It's a missing feature of Local Activities. It may be coming in the future at some point.

Reactions: üëç 1

</details>


---

<a id="1300"></a>

### #1300: Provide WorkflowInfo#getHistoryLength()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1300 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-07-06 17:40:48.000 UTC (3y 6m ago) |
| **Updated** | 2022-10-27 16:32:46.000 UTC |
| **Closed** | 2022-10-27 16:32:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Users should be able to have a more direct way to check if it's time to call continue-as-new than guessing how many events their code produces and counting the loops.

**Describe the solution you'd like**
`WorkflowInfo#getHistoryLength()` should be exposed that would allow a direct comparison with a threshold length of the history

**Context**
The implementor needs to be careful with the deterministic behavior of this value, as it has to be exactly the same during a replay. Also, it should be noted that custom metrics and determining if continue-as-new is needed are probably the only valid usages of this method in user code.


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-07-06 17:41:38.000 UTC</summary>

I think we should call this `getHistoryLength()` since there will be a way to get byte size of history soon. TypeScript calls it length at https://typescript.temporal.io/api/interfaces/workflow.TaskInfo#historylength.

Reactions: üëç 1

</details>

<details>
<summary><strong>gtorrance-bw</strong> commented on 2022-07-27 16:41:23.000 UTC</summary>

For what it's worth, I anticipate needing a feature like this, too. Hope it gets prioritized in the near future. Thanks.

</details>


---

<a id="1219"></a>

### #1219: Disabled time skipping becomes re-enabled when calling `WorkflowStub.getResult`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1219 |
| **State** | CLOSED |
| **Author** | joshchoo (Josh) |
| **Created** | 2022-05-17 10:53:28.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-18 20:53:58.000 UTC |
| **Closed** | 2022-05-17 13:47:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

## Expected Behavior

When time skipping is disabled in the `TestEnvironmentOptions`, calling `WorkflowStub.getResult` should not re-enable it.

## Actual Behavior

Calling `WorkflowStub.getResult` appears to call the `temporal.api.testservice.v1.TestService/UnlockTimeSkipping` API, which fast-forwards the workflow execution and causes the workflow to time-out. When asynchronous operations (CompletableFuture, Kafka, etc) attempt to interact (e.g. execute workflow signals) with the workflow they would fail because the workflow has already timed out.

**`temporal.api.testservice.v1.TestService/UnlockTimeSkipping` logs:**
```
18:39:00.875 [Test worker] TRACE i.t.s.GrpcDeadlineInterceptor - method=temporal.api.testservice.v1.TestService/UnlockTimeSkipping, timeoutMs=9223372036854775807
18:39:00.876 [Test worker] TRACE i.t.s.GrpcTracingInterceptor - Invoking "temporal.api.testservice.v1.TestService/UnlockTimeSkipping" with input: 
```

This problem was introduced in Temporal Java SDK version **1.9.0**. For info, this issue is not present in **1.8.1**.

## Steps to Reproduce the Problem

I have created a reproduction of the issue in this repo: [temporal-bug-reproduction](https://github.com/joshchoo/temporal-bug-reproduction)

Here is the commit with the failing test case: https://github.com/joshchoo/temporal-bug-reproduction/commit/3abe213cd4ec5e8818508e9b0ed8bb46276b6fa7

1. Run the `HelloSignalTest.testSignal` test case. It will fail and the logs show that `temporal.api.testservice.v1.TestService/UnlockTimeSkipping` is called.

## Issue not present in v1.8.1

Here's the same test with sdk-java v1.8.1, which passes: https://github.com/joshchoo/temporal-bug-reproduction/tree/disable-time-skip-works-1.8.1

## Specifications

  - Version: sdk-java v1.9.0+
  - Platform: MacOS - local development


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-17 13:47:01.000 UTC</summary>

This problem should be already fixed by https://github.com/temporalio/sdk-java/pull/1210 and be a part of the next release.

</details>

<details>
<summary><strong>joshchoo</strong> commented on 2022-05-17 23:41:02.000 UTC</summary>

Gotcha @Spikhalskiy, thanks for the fix and heads-up!

</details>


---

<a id="1211"></a>

### #1211: MDC context logging properties not propagating inside promise.handle

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1211 |
| **State** | OPEN |
| **Author** | ju-stin |
| **Created** | 2022-05-12 21:58:22.000 UTC (3y 8m ago) |
| **Updated** | 2022-08-10 22:26:35.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

The MDC markers placed before a promise handler do not appear in the log within the handler. 
Related [temporal community post](https://community.temporal.io/t/mdc-context-logging-properties-not-propagating-inside-promise-handle/4668/2?u=justin)




---

<a id="1135"></a>

### #1135: jaeger-client-1.8.0.jar: 1 vulnerabilities (highest severity is: 7.7) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1135 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-04-12 17:28:12.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-12 18:12:04.000 UTC |
| **Closed** | 2022-04-12 18:05:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>jaeger-client-1.8.0.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.8.6/9180733b7df8542621dc12e21e87557e8c99b8cb/gson-2.8.6.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/eb70ea6c1b4ff449de583d446b3446b5a1bf7c6e">eb70ea6c1b4ff449de583d446b3446b5a1bf7c6e</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [WS-2021-0419](https://github.com/google/gson/pull/1991) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.7 | gson-2.8.6.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> WS-2021-0419</summary>


###  Vulnerable Library - <b>gson-2.8.6.jar</b></p>

<p>Gson JSON library</p>
<p>Library home page: <a href="https://github.com/google/gson">https://github.com/google/gson</a></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.8.6/9180733b7df8542621dc12e21e87557e8c99b8cb/gson-2.8.6.jar</p>
<p>

Dependency Hierarchy:
  - jaeger-client-1.8.0.jar (Root Library)
    - jaeger-core-1.8.0.jar
      - :x: **gson-2.8.6.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/eb70ea6c1b4ff449de583d446b3446b5a1bf7c6e">eb70ea6c1b4ff449de583d446b3446b5a1bf7c6e</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Denial of Service vulnerability was discovered in gson before 2.8.9 via the writeReplace() method.

<p>Publish Date: 2021-10-11
<p>URL: <a href=https://github.com/google/gson/pull/1991>WS-2021-0419</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.7</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: High
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/google/gson/releases/tag/gson-parent-2.8.9">https://github.com/google/gson/releases/tag/gson-parent-2.8.9</a></p>
<p>Release Date: 2021-10-11</p>
<p>Fix Resolution: com.google.code.gson:gson:2.8.9</p>

</p>

<p></p>

</details>
<!-- <REMEDIATE>[{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"Java","groupId":"com.google.code.gson","packageName":"gson","packageVersion":"2.8.6","packageFilePaths":["/temporal-opentracing/build.gradle"],"isTransitiveDependency":true,"dependencyTree":"io.jaegertracing:jaeger-client:1.8.0;io.jaegertracing:jaeger-core:1.8.0;com.google.code.gson:gson:2.8.6","isMinimumFixVersionAvailable":true,"minimumFixVersion":"com.google.code.gson:gson:2.8.9","isBinary":false}],"baseBranches":["master"],"vulnerabilityIdentifier":"WS-2021-0419","vulnerabilityDetails":"Denial of Service vulnerability was discovered in gson before 2.8.9 via the writeReplace() method.","vulnerabilityUrl":"https://github.com/google/gson/pull/1991","cvss3Severity":"high","cvss3Score":"7.7","cvss3Metrics":{"A":"High","AC":"High","PR":"None","S":"Unchanged","C":"Low","UI":"None","AV":"Network","I":"High"},"extraData":{}}]</REMEDIATE> -->

#### Comments (2)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-04-12 18:05:47.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by WhiteSource because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the WhiteSource inventory.

</details>

<details>
<summary><strong>mcbryde</strong> commented on 2022-04-12 18:12:03.000 UTC</summary>

For reference, this Jaeger library is only used in Gradle test scopes, which should have been explicitly excluded from the scan.  This PR fixes the config issue that made it pop up: https://github.com/temporalio/sdk-java/pull/1136

</details>


---

<a id="1094"></a>

### #1094: üö≤ Test Server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1094 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-03-22 22:34:42.000 UTC (3y 9m ago) |
| **Updated** | 2025-05-13 16:42:18.000 UTC |
| **Closed** | 2025-05-13 16:42:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | epic, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Description

Improve Test Server usability improvements and bugs

# Core objectives

Test Server provides a simplified fast im-memory implementation of Temporal Server API with additional features provided for testing only like time-skipping. This Epic tracks the tasks related to the improvement of the Test Server itself that don't affect Java SDK.

# Tasks

- [ ] temporalio/sdk-java#1079
- [ ] temporalio/sdk-java#1093
- [ ] temporalio/sdk-java#1069
- [x] temporalio/sdk-java#84
- [ ] temporalio/sdk-java#1139
- [x] temporalio/sdk-java#1158
- [x] temporalio/sdk-java#1220
- [x] temporalio/sdk-java#1221
- [x] temporalio/sdk-java#1223 
- [ ] temporalio/sdk-java#262
- [ ] temporalio/sdk-java#1403
- [ ] #1642
- [x] #1682 
- [x] #1746
- [x] #1742
- [x] #1692
- [ ] #1693

# Bugs

- [ ] temporalio/sdk-java#1291
- [x] temporalio/sdk-java#1288
- [x] temporalio/sdk-java#1289 
- [x] temporalio/sdk-java#1319
- [x] temporalio/sdk-java#1398
- [x] temporalio/sdk-java#1401 
- [ ] temporalio/sdk-java#1138
- [x] temporalio/sdk-java#1424
- [x] temporalio/sdk-java#1425
- [ ] temporalio/sdk-java#1426
- [x] temporalio/sdk-java#1427 
- [ ] temporalio/sdk-java#1429 
- [ ] #1618
- [x] #1903

# Add implementation for endpoints

**WorkflowService**

- [ ] registerNamespace
- [x] describeNamespace
- [ ] listNamespaces
- [ ] updateNamespace
- [ ] deprecateNamespace
- [ ] getWorkflowExecutionHistoryReverse
- [ ] resetWorkflowExecution
- [ ] #1693
- [ ] listArchivedWorkflowExecutions
- [ ] scanWorkflowExecutions
- [ ] countWorkflowExecutions
- [ ] getSearchAttributes
- [ ] resetStickyTaskQueue
- [ ] describeTaskQueue
- [ ] getClusterInfo
- [x] getSystemInfo
- [ ] listTaskQueuePartitions

**OperatorService**

- [ ] listSearchAttributes

#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-11-02 15:59:54.000 UTC</summary>

Edited description to remove https://github.com/temporalio/sdk-core/issues/426, but it also qualified the names of all issues too, sorry!

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:42:17.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="1046"></a>

### #1046: Worker warning messages: DEADLINE_EXCEEDED: deadline exceeded after 69.999

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1046 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-02-20 05:39:07.000 UTC (3y 10m ago) |
| **Updated** | 2024-12-23 13:03:38.000 UTC |
| **Closed** | 2024-12-23 13:03:38.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

1. Set sslContext on WorkflowServiceStubs

             WorkflowServiceStubs.newInstance(
                    WorkflowServiceStubsOptions.newBuilder()
                            .setSslContext(SimpleSslContextBuilder.forPKCS8(CLIENT_CERT, CLIENT_KEY).build())
                            .setTarget(TARGET_ENDPOINT)
                            .build());

2. Create client and workflowFactory, create worker and start factory

3. Let the worker run for some time, no need to run workflows

Getting following two warnings about every 1 minute with no workflows running:

```
io.grpc.StatusRuntimeException: UNAVAILABLE: Subchannel shutdown invoked
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2702)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:262)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:227)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
```

and 

```
io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 69.999671598s. [closed=[], open=[[remote_addr=tihomir.temporal-dev.tmprl.cloud/34.228.207.69:7233]]]
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2702)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:262)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:227)
```

Worker still picks up workflow tasks, and you can run your workflows. Just these warnings keep popping up when worker is running but idle. 
Used sdk verion 1.7.1 (cant test on 1.8.0 yet because of the maven issue, will test on 1.9.0)

Similar issue that was resolved: https://github.com/temporalio/sdk-java/issues/707
This is not related to test env (not using it)

#### Comments (2)

<details>
<summary><strong>josh-berry</strong> commented on 2023-12-26 22:33:24.000 UTC</summary>

@tsurdilo Have you seen this one recently? Wondering if it's still an issue or if it can just be closed.

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 13:03:38.000 UTC</summary>

Closing because we cannot reproduce this on the latest SDK 

</details>


---

<a id="1036"></a>

### #1036: Add describeWorkflowExecution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1036 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-10 00:41:31.000 UTC (3y 11m ago) |
| **Updated** | 2024-12-23 10:20:33.000 UTC |
| **Closed** | 2024-12-23 10:20:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`describeWorkflowExecution` is an API that is used regularly for a large range of checks by the users, Temporal SDK should expose it as a part of the official WorkflowStub API.

Typical usages of `describeWorkflowExecutions` include checking the status of a workflow.

Related: #1028 https://github.com/temporalio/sdk-features/issues/17


#### Comments (2)

<details>
<summary><strong>cretz</strong> commented on 2022-02-10 15:41:49.000 UTC</summary>

Also related to https://github.com/temporalio/sdk-features/issues/17.

Whatever this is named, I think the result just needs to make sure it's wrapped in a friendly Java class that exposes the status and the underlying gRPC response. (can add more than just status though if you want)

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 10:20:33.000 UTC</summary>

duplicate of https://github.com/temporalio/sdk-java/issues/2265

</details>


---

<a id="1012"></a>

### #1012: OpenTracing interceptor should be able to ignore certain failures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1012 |
| **State** | CLOSED |
| **Author** | tylercunnion (Tyler Cunnion) |
| **Created** | 2022-01-31 08:29:36.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-22 18:42:35.000 UTC |
| **Closed** | 2022-02-22 18:42:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Our workflow involves a lot of polling external services, following the pattern whereby we check for a result and throw an exception if it's not ready yet. As a result, we produce a lot of OpenTracing spans with errors that are actually normal, expected behavior. We also show an artificially inflated error % as a result.

**Describe the solution you'd like**
I'd like to be able to exclude certain exception types from being logged as errors in the OpenTracing interceptor.

**Describe alternatives you've considered**
I'm not sure if there's another use case for this beside the specific one I'm dealing with, so if it doesn't seem generally-applicable enough I could always just implement a new interceptor for this project's use. And of course the optimal way would be to simply not have to poll (but setting up the external services to send signals is outside of our current scope).


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-02-18 21:07:24.000 UTC</summary>

We can add a configurable `java.util.function.Predicate` that accepts an exception into `OpenTracingOptions#isErrorPredicate`. The default implementation should just return `true`.

@tylercunnion will you be interested in contributing? It should be a pretty local change into temporal-opentracing.

</details>

<details>
<summary><strong>tylercunnion</strong> commented on 2022-02-18 22:37:15.000 UTC</summary>

Thanks for having a look @Spikhalskiy - I'll definitely take a spin at the implementation; I was actually playing around with it a little after I reported this so I've got a fairly decent idea of what's going on in there

</details>


---

<a id="966"></a>

### #966: Provide a way to recreate workers on a started WorkerFactory

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/966 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-12 01:03:09.000 UTC (3y 12m ago) |
| **Updated** | 2025-05-13 22:07:20.000 UTC |
| **Closed** | 2025-05-13 22:07:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | Next |

#### Description

**Is your feature request related to a problem? Please describe.**
Worker is created with an immutable `WorkerOptions`.
If there is a need to change some minor parameter of a Worker, the only solution is to stop the whole `WorkflowFactory` and recreate the workers from scratch.
This is unnecessarily expensive for any frequent usage because it causes disruptions in in-flight activities, and also it evicts the existing workflow cache because the cache belongs to a worker factory.

**Describe the solution you'd like**
Temporal SDK should provide a way to gracefully replace an existing Worker with a new worker with new WorkerOptions without stopping the factory.
It can be something like
```java
WorkerFactory {
  ...
  Worker shutdownAndRecreateWorker(Worker existingWorker, @Nullable WorkerOptions newOptions)
}
```
that would stop pulling on the existing worker, replace it with a new one, and would allow an old worker to gracefully finish all the processing and stop after that.

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-20 17:59:28.000 UTC</summary>

Subtask of #1230

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 22:07:19.000 UTC</summary>

Closing as this is currently not supported in any other SDK and not currently planned

</details>


---

<a id="950"></a>

### #950: Opentelemetry tracing support for java 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/950 |
| **State** | CLOSED |
| **Author** | sidhu-sb |
| **Created** | 2022-01-04 10:13:18.000 UTC (4 years ago) |
| **Updated** | 2022-01-04 16:54:50.000 UTC |
| **Closed** | 2022-01-04 14:44:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | invalid, wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

can you provide an example of how to use opentelemetry tracing in temporal.

Go-SDK has an otel tracing interceptor so was looking for something similar in java.


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-04 14:44:45.000 UTC</summary>

Here is a configuration for opentracing:
https://github.com/temporalio/sdk-java/tree/master/temporal-opentracing#usage
here is how is can be used with opentelemetry:
https://github.com/temporalio/sdk-java/tree/master/temporal-opentracing#opentelemetry

Please use Temporal 
forum: https://community.temporal.io/
slack: https://temporalio.slack.com/join/shared_invite/zt-onhti57l-J0bl~Tr7MqSUnIc1upjRkw#/shared-invite/email
or StackOverflow: https://stackoverflow.com/questions/tagged/temporal-workflow
for questions.

You can find me as `@Dmtiry` in the Temporal Slack.

Reactions: üëç 1

</details>

<details>
<summary><strong>tsurdilo</strong> commented on 2022-01-04 16:54:49.000 UTC</summary>

Java samples issue: https://github.com/temporalio/samples-java/issues/207

</details>


---

<a id="947"></a>

### #947: Rework HeartbeatContext to use GrpcRetryer with exponential backoff for network issues

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/947 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-03 17:41:30.000 UTC (4 years ago) |
| **Updated** | 2024-12-23 10:00:19.000 UTC |
| **Closed** | 2024-12-23 10:00:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement, good first issue |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
HeartbeatContext should have an exponential backoff in case of network issues

## Actual Behavior
HeartbeatContext uses a constant delay in case of network issues


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-20 18:06:30.000 UTC</summary>

Subtask (duplicate?) of #1258

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 10:00:19.000 UTC</summary>

Marking as duplicate of https://github.com/temporalio/sdk-java/issues/1258

</details>


---

<a id="918"></a>

### #918: Update gRPC to 1.42.1

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/918 |
| **State** | CLOSED |
| **Author** | natalie-zamani (Natalie Zamani) |
| **Created** | 2021-12-06 15:21:50.000 UTC (4y 1m ago) |
| **Updated** | 2022-01-10 22:47:42.000 UTC |
| **Closed** | 2021-12-06 21:40:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |

#### Description

We‚Äôre trying to upgrade our gRPC usages to 1.42.1 (for our own clients/servers), but are running into a Temporal dep constraint conflict:
`io.grpc:grpc-stub:{strictly 1.41.0}`

Any plans to update?

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-12-06 16:11:08.000 UTC</summary>

Hi Nataly, 
When I inspect our 1.5.0 release with
`./gradlew :temporal-sdk:dependencies --configuration runtimeClasspath | grep "grpc-stub" -B 12`
I get 
```
+--- project :temporal-serviceclient
|    +--- io.grpc:grpc-api:{strictly [1.34.0,); prefer 1.41.0} -> 1.41.0
|    |    +--- io.grpc:grpc-context:1.41.0
|    |    +--- com.google.code.findbugs:jsr305:3.0.2
|    |    +--- com.google.guava:guava:30.1-android -> 31.0.1-jre
|    |    |    +--- com.google.guava:failureaccess:1.0.1
|    |    |    +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
|    |    |    +--- com.google.code.findbugs:jsr305:3.0.2
|    |    |    +--- org.checkerframework:checker-qual:3.12.0
|    |    |    +--- com.google.errorprone:error_prone_annotations:2.7.1 -> 2.9.0
|    |    |    \--- com.google.j2objc:j2objc-annotations:1.3
|    |    \--- com.google.errorprone:error_prone_annotations:2.9.0
|    +--- io.grpc:grpc-stub:{strictly [1.34.0,); prefer 1.41.0} -> 1.41.0
--
|    +--- io.grpc:grpc-services:{strictly [1.34.0,); prefer 1.41.0} -> 1.41.0
|    |    +--- io.grpc:grpc-protobuf:1.41.0
|    |    |    +--- io.grpc:grpc-api:1.41.0 (*)
|    |    |    +--- com.google.code.findbugs:jsr305:3.0.2
|    |    |    +--- com.google.protobuf:protobuf-java:3.17.2 -> 3.18.1
|    |    |    +--- com.google.api.grpc:proto-google-common-protos:2.0.1
|    |    |    |    \--- com.google.protobuf:protobuf-java:3.13.0 -> 3.18.1
|    |    |    +--- io.grpc:grpc-protobuf-lite:1.41.0
|    |    |    |    +--- io.grpc:grpc-api:1.41.0 (*)
|    |    |    |    +--- com.google.code.findbugs:jsr305:3.0.2
|    |    |    |    \--- com.google.guava:guava:30.1-android -> 31.0.1-jre (*)
|    |    |    \--- com.google.guava:guava:30.1-android -> 31.0.1-jre (*)
|    |    +--- io.grpc:grpc-stub:1.41.0 (*)
```
which is aligned with our declaration of `grpcVersion = '[1.34.0,)!!1.41.0'`
So, we "prefer" `1.41.0`, but don't "strictly" enforce it.
Are you sure that `io.grpc:grpc-stub:{strictly 1.41.0}` comes from temporal-sdk?

We will update the preferred version to 1.42.1 for the next release though.

</details>

<details>
<summary><strong>natalie-zamani</strong> commented on 2021-12-06 16:54:10.000 UTC</summary>

So it is failing due to that Temporal grpc constraint (which is odd, given that it's not a strict range). It seems like it may be some weirdness around how Gradle Platforms interoperable with dependency ranges, and less of an issue with Temporal's usage of a version range. 

Anyways, we'll try 1.6 later today when that's released! Thanks!

</details>


---

<a id="914"></a>

### #914: Shutdown of the workers doesn't destroy in-flight cached workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/914 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-12-04 22:26:40.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-08 20:04:49.000 UTC |
| **Closed** | 2021-12-08 20:04:49.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

## Expected Behavior

If we shut down worker factory, which shuts down workers, it cleans all the resources of the workers.

## Actual Behavior

If there are non-completed workflows in the workflow cache and thread pool, these workflows are not getting destroyed.
It creates a leak if a user recreated the worker factory for any reason (for example, to create a worker factory with new options).
It also blocks a clean shutdown of the JVM and the app, because workflow threads are not daemon processes.



---

<a id="900"></a>

### #900: Worker doesn't log failure during sending workflow task completion request

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/900 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-24 21:47:16.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-06 06:02:13.000 UTC |
| **Closed** | 2021-11-29 22:17:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |

#### Description

## Actual Behavior

A worker already logs when Workflow Task Processing fails with an unexpected exception.
But if reporting of the workflow task result to the server fails, the worker log is silent.
At the same time, both situations reach `UncaughtExceptionHandler` in the same manner.

## Expected Behavior

If a worker logs a problem during workflow task processing, the worker should log a problem during reporting the workflow task processing result to the server. Especially because it potentially can be related to misformed commands.

## Steps to Reproduce the Problem

Create an invalid Command (for example, schedule an activity with invalid retry parameters).
`WorkflowWorker.TaskHandlerImpl#handle` gets an `INVALID_ARGUMENT` exception from the server inside `sendReply`.
Worker log is clean and doesn't show the issue anyhow.

## Notes

There is also a related problem that because `WorkflowWorker.TaskHandlerImpl#handle/sendReply` happens outside of WorkflowTaskHandler, exception there doesn't lead to a workflow thread destroy and cache invalidation, while it should. This points out that a larger refactoring here may be needed to keep things clean and easy to maintain.

#### Comments (2)

<details>
<summary><strong>akdoan1</strong> commented on 2021-11-24 22:48:04.000 UTC</summary>

I'm assuming that the worker's reporting of the task processing result a blocking/synchronous call to the server. I don't think there are any metrics around interaction between the worker and the server based on the list in [workflow metrics](https://github.com/temporalio/sdk-java/blob/3deccf2c50b1bdb9f41cd2b385ee4dce402acf82/temporal-sdk/src/main/java/io/temporal/internal/metrics/MetricsType.java#L48). 

Can we add metrics to indicate success/failure and latency of this reporting call? 

Edit: I guess that's already covered with `WORKFLOW_TASK_EXECUTION_FAILURE_COUNTER` actually? 

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-11-24 22:56:52.000 UTC</summary>

@akdoan1 There is `failed_workflow_tasks` metric on the Temporal server to monitor the volume of failed workflow tasks. There is also `service_errors_invalid_argument` for example.

I don't think we are going to implement SDK metrics for pure server return codes, we already have them on server side. Our SDK metrics are formulated around concepts that make sense from "business logic" level. Workflows, Workflow tasks, Activities and their executions. 

If you really want that, we expose WorkflowServiceStubsOptions#grpcClientInterceptors.

Reactions: üëç 1

</details>


---

<a id="896"></a>

### #896: Workflow should be able to ignore CancellationFailure and finish successfully

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/896 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-23 19:30:23.000 UTC (4y 1m ago) |
| **Updated** | 2024-12-17 21:19:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | wontfix, next-gen |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Workflow code should be able to catch `CancellationFailure`, handle or ignore it and be able to finish executing successfully.
Test https://github.com/Spikhalskiy/java-sdk/commit/eada50399b6d24c77d4b6e37cd500907594a189a#diff-a2baafb2fd6213bafb49077bd60c8efeedc6c15df86437e9c8e2ef87ce23625cR58
expected to pass

## Actual Behavior

Test fails. Workflow doesn't get a chance to fully swallow and ignore `CancellationFailure` and is forced to finish with `EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED`

#### Comments (2)

<details>
<summary><strong>bergundy</strong> commented on 2021-11-23 20:35:14.000 UTC</summary>

We did the exact thing in TypeScript a while ago.
We only complete with cancelled if cancellation of the Workflow was requested and the workflow propagates an exception that is considered cancellation.
https://github.com/temporalio/sdk-typescript/blob/733b01ee9913c255cea8913222c1232bf1bda3a4/packages/workflow/src/errors.ts#L38

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-22 22:42:42.000 UTC</summary>

After discussion with @mfateev we decided that it's too much of the breaking change to the current concept of scopes. It's not a bug, it's designed this way right now. Once the scope is requested to be canceled, it's considered canceled new commands have to be scheduled in the detached scope. We may reconsider this decision and design in the future, but when we design JavaSDK 2.x which will not strive to maintain compatibility and will revisit all the existing concepts and APIs. 

</details>


---

<a id="883"></a>

### #883: Workers don't reset sticky queue when workflow execution is evicted from the cache

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/883 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-17 19:47:58.000 UTC (4y 1m ago) |
| **Updated** | 2024-12-17 21:18:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Right now we reset the sticky queue if an exception happens during workflow execution. 
While this is not an event that is needed, there is nothing bad in reexecuting on the same worker.
At the same time, we are missing resetting the sticky queue when a workflow gets evicted from the cache because SDK is at the workflow threads limit. This creates pressure on already overloaded workers and can lead to incremented delays.

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-11-30 00:54:27.000 UTC</summary>

It was implemented like this by design in #236. The original intentions need to be revisited though because not resetting the sticky queue on evictions from already overwhelmed workers doesn't make much sense.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-11 23:41:10.000 UTC</summary>

This matter improved with this Server change: https://github.com/temporalio/temporal/pull/2811
Now if the sticky queue is obviously abandoned, Server will not wait 5 seconds trying to dispatch the workflow task into a sticky queue.

</details>


---

<a id="790"></a>

### #790: DescribeTest#testSuccessfulActivity fails with Docker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/790 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-10-04 17:12:03.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-05 00:16:01.000 UTC |
| **Closed** | 2021-10-05 00:16:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

        at org.junit.Assert.fail(Assert.java:89)
        at org.junit.Assert.failNotEquals(Assert.java:835)
        at org.junit.Assert.assertEquals(Assert.java:120)
        at io.temporal.workflow.DescribeTest.testSuccessfulActivity(DescribeTest.java:165)

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-04 17:53:34.000 UTC</summary>

It's most likely a result of merging https://github.com/temporalio/temporal/pull/2007
So, changes in the Test Service and `testSuccessfulActivity` test for https://github.com/temporalio/sdk-java/issues/766 should be implemented to make it fixed.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-05 00:16:01.000 UTC</summary>

Closed by #782

</details>


---

<a id="766"></a>

### #766: Worker identity should be reported and recorded when worker picks up an Activity task

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/766 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-25 00:44:42.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-05 00:13:46.000 UTC |
| **Closed** | 2021-10-05 00:13:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | vkoby |
| **Milestone** | 1.4.0 |

#### Description

This report is related to https://github.com/temporalio/sdk-java/issues/590

While we implemented sending worker identity in a heartbeat in JavaSDK, `lastWorkerIdentity` in `PendingActivityTask` with the real temporal server is still empty as reported here: https://github.com/temporalio/sdk-java/issues/765

It's because `lastWorkerIdentity` returned by the Temporal server is an identity reported when the Worker picks up the activity task, not when it heartbeats. 
See: https://github.com/temporalio/temporal/blob/ff069578a44dac7f39d7454771e88a989f62fe61/service/history/historyEngine.go#L1296

JavaSDK should report worker identity when Worker picks up the activity task for `lastWorkerIdentity` to be correctly populated.

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-01 16:31:30.000 UTC</summary>

Blocked by https://github.com/temporalio/temporal/issues/1999

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-04 17:50:27.000 UTC</summary>

https://github.com/temporalio/temporal/issues/1999 is done, this task should be unblocked now. See https://github.com/temporalio/temporal/pull/2007/files for more details about how to port into the Test Server implementation.

</details>


---

<a id="752"></a>

### #752: Revisit ActivityExecutionContext and ActivityCompletion clients

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/752 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-22 16:57:30.000 UTC (4y 3m ago) |
| **Updated** | 2025-05-13 16:50:00.000 UTC |
| **Closed** | 2025-05-13 16:49:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Code quality and readability around `ActivityExecutionContext`, `ActivityCompletionClient`, `ManualActivityCompletionClient` requires refactoring to make code more maintainable. 




- [x] #943 
- [x] Manual Completion Client is a public user-facing interface that is undocumented. #1181
- [ ] Errors handling around heartbeating in ActivityExecutionContext and ManualActivityCompletionClient are different without apparent reasons.
- [x] #1233
- [ ] In case of some exceptions, ActivityExecutionContext stops heartbeating.
- [ ] ActivityExecutionContext#heartbeat and other methods like that should have a short explanation about the heartbeat throttling
- [ ] #1354

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-10 21:52:58.000 UTC</summary>

`ActivityExecutionContext` is done

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:49:59.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="749"></a>

### #749: TestEnvironmentOptions.Builder.validateAndBuildWithDefaults fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/749 |
| **State** | CLOSED |
| **Author** | smax48 (Maxim Chuvilyaev) |
| **Created** | 2021-09-22 00:32:47.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-22 06:36:27.000 UTC |
| **Closed** | 2021-09-22 06:36:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
It was working fine in SDK v1.1

## Actual Behavior
When upgraded to v1.3.1, I get this error:

```
Only one of the target and channel options can be set at a time
java.lang.IllegalStateException: Only one of the target and channel options can be set at a time
	at io.temporal.serviceclient.WorkflowServiceStubsOptions.<init>(WorkflowServiceStubsOptions.java:179)
	at io.temporal.serviceclient.WorkflowServiceStubsOptions.<init>(WorkflowServiceStubsOptions.java:34)
	at io.temporal.serviceclient.WorkflowServiceStubsOptions$Builder.validateAndBuildWithDefaults(WorkflowServiceStubsOptions.java:657)
	at io.temporal.serviceclient.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:111)
	at io.temporal.serviceclient.WorkflowServiceStubs.newInstance(WorkflowServiceStubs.java:51)
	at io.temporal.testing.TestWorkflowEnvironmentInternal.<init>(TestWorkflowEnvironmentInternal.java:80)
	at io.temporal.testing.TestWorkflowEnvironment.newInstance(TestWorkflowEnvironment.java:99)
```

## Steps to Reproduce the Problem

This code crashes:

```
    private val testEnv: TestWorkflowEnvironment = TestWorkflowEnvironment.newInstance(
        TestEnvironmentOptions.newBuilder()
            .setWorkflowClientOptions(
                WorkflowClientOptions.newBuilder()
                    .validateAndBuildWithDefaults()
            ).setWorkerFactoryOptions(
                WorkerFactoryOptions.newBuilder()
                    .validateAndBuildWithDefaults()
            ).validateAndBuildWithDefaults()
    )
```

PS 
When I use just build() - it works OK

## Specifications

  - Version: Java SDK 1.3.1



#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-09-22 06:14:18.000 UTC</summary>

Looks like the problem is that when you call validateAndBuildWithDefaults on TestEnvironmentOptions builder it creates default service options with default target address, which then gets passed to the WorkflowServiceStubsImpl that also adds a channel for the in-memory service, which causes the error you are seeing (both target and channel set). The fix is rather simple, we should remove target when we are populating the channel. PR linked above should fix the issue.

</details>

<details>
<summary><strong>smax48</strong> commented on 2021-09-22 06:16:01.000 UTC</summary>

yeah, I debugged this a bit and was thinking something similar. Just strange that I was first to pick this up :)
Thanks for quick response!

</details>


---

<a id="724"></a>

### #724: TEMPORAL_DEBUG flag is ignored by deadlock detector in eventLoop 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/724 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-14 03:01:15.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-14 18:03:44.000 UTC |
| **Closed** | 2021-09-14 03:02:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

Bug report:
https://community.temporal.io/t/testing-temporal-workflows/2918/4

`SyncWorkflow#eventLoop` lacks a check for `TEMPORAL_DEBUG` flag

#### Comments (2)

<details>
<summary><strong>rootusercop</strong> commented on 2021-09-14 17:15:02.000 UTC</summary>

Thanks for fixing this @Spikhalskiy Is there an approximate ETA when the fix would be released ?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-14 18:03:15.000 UTC</summary>

@nkatre We just recently had a release, so the next release will be in about a month. You can use our snapshot builds if you don't have your own fork/don't want to build your own artifacts.

</details>


---

<a id="718"></a>

### #718: Support Spring Proxy classes marked with @Component for activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/718 |
| **State** | CLOSED |
| **Author** | ginachen-netflix (Gina Chen) |
| **Created** | 2021-09-13 21:05:54.000 UTC (4y 3m ago) |
| **Updated** | 2022-07-06 14:22:53.000 UTC |
| **Closed** | 2022-07-06 14:22:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Right now when i try to registerActivitiesImplementations with a Spring Proxy bean, it failed with error 

```
Caused by: java.lang.IllegalArgumentException: Class doesn't implement any non empty interface annotated with @ActivityInterface: 
xxx.xxx.xxx.ActivityImpl$$EnhancerBySpringCGLIB$$40723738
	at io.temporal.common.metadata.POJOActivityImplMetadata.<init>(POJOActivityImplMetadata.java:109) ~[temporal-sdk-0.11.0+1-0-7.jar:0.11.0+1-0-7]
	at io.temporal.common.metadata.POJOActivityImplMetadata.newInstance(POJOActivityImplMetadata.java:53) ~[temporal-sdk-0.11.0+1-0-7.jar:0.11.0+1-0-7]
	at io.temporal.internal.sync.POJOActivityTaskHandler.registerActivityImplementation(POJOActivityTaskHandler.java:110) ~[temporal-sdk-0.11.0+1-0-7.jar:0.11.0+1-0-7]
	at io.temporal.internal.sync.POJOActivityTaskHandler.registerActivityImplementations(POJOActivityTaskHandler.java:179) ~[temporal-sdk-0.11.0+1-0-7.jar:0.11.0+1-0-7]
	at io.temporal.internal.sync.SyncActivityWorker.registerActivityImplementations(SyncActivityWorker.java:55) ~[temporal-sdk-0.11.0+1-0-7.jar:0.11.0+1-0-7]
	at io.temporal.worker.Worker.registerActivitiesImplementations(Worker.java:326) ~[temporal-sdk-0.11.0+1-0-7.jar:0.11.0+1-0-7]
```

Looking through the code, the `ActivityInterface` was not recognized as an interface in Proxy class.

**Describe the solution you'd like**
We want to make this activity class recognizable.

**Describe alternatives you've considered**
N/A.

**Additional context**
How to attach a screenshot? lol


#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-14 06:00:48.000 UTC</summary>

Hi Gina,

Any chance you can provide an example of your wiring or at least how do you specifically make the injection?
If you inject (or request from the Spring container) specific Activity interfaces - Spring proxies should implement the right Activity interfaces.

My guess is that your wiring is probably organized in a way that all activities are implementing some marker interface in addition to the actual activity interfaces and you ask Spring to give a collection of all instances implementing this marker interface. This doesn't work because Spring wraps the activity instances into proxies that implement the marker interface only, but not actual Activity interfaces.

Let me know if you can share more information here. Also, feel free to ping me on Slack with the details.


</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-06 14:22:53.000 UTC</summary>

No reproduction is provided. I verified in a toy Spring Boot app that an activity can be initialized as a spring bean and this bean object can be used in `registerActivityImplementations`.

</details>


---

<a id="696"></a>

### #696: Port fix for following execution chain from Go SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/696 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2021-09-03 18:37:07.000 UTC (4y 4m ago) |
| **Updated** | 2023-05-23 06:58:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | Next |

#### Description

See https://github.com/temporalio/sdk-go/pull/527
See details from :point_up:. Fix should be straightforward.


#### Comments (2)

<details>
<summary><strong>bergundy</strong> commented on 2022-04-26 19:01:40.000 UTC</summary>

We also have a way to opt-out of following runs when waiting for the result in Python, TS, and now Go.
See relevant code here:
https://github.com/temporalio/sdk-typescript/blob/cb6151fcaa29e9cda4a1ae90dda31ae007a6dd10/packages/client/src/workflow-client.ts#L403
https://github.com/temporalio/sdk-typescript/blob/cb6151fcaa29e9cda4a1ae90dda31ae007a6dd10/packages/client/src/workflow-client.ts#L509

The `followRuns` option can be set on `execute` and `result` in TS client and handle objects.

</details>

<details>
<summary><strong>cretz</strong> commented on 2022-04-26 19:15:40.000 UTC</summary>

Here's the Go change to support opting out of following runs: https://github.com/temporalio/sdk-go/pull/791

</details>


---

<a id="613"></a>

### #613: Calling workflow method on the workflow stub should always wait for the workflow completion.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/613 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-07-31 18:46:12.000 UTC (4y 5m ago) |
| **Updated** | 2021-07-31 18:46:12.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
When a workflow is started synchronously using a typed stub it reconnects to an already running instance if `WorkflowIdReusePolicy` is not `AllowDuplicate`.

When a workflow method is called on a stub that was created using a workflowId (see [newWorkflowStub(Class<T> workflowInterface, String workflowId)](https://github.com/temporalio/sdk-java/blob/1813f6a3f5c80196bc0c7167e1708e0dcaee217b/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java#L155)) an exception is returned. 

**Describe the solution you'd like**
When a workflow stub is created by a workflowId and the workflow method is invoked then the call should block waiting for a workflow result if a workflow with the given id is already running. The exception should be returned if no workflow with such id exists.



---

<a id="553"></a>

### #553: Fix workflow event JSON to work with Java SDK WorkflowReplayer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/553 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2021-06-22 20:44:22.000 UTC (4y 6m ago) |
| **Updated** | 2021-09-17 00:09:45.000 UTC |
| **Closed** | 2021-09-17 00:09:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

Currently the workflow history JSON that can be retried via tctl, for example

tctl wf show -wid <workflow_id> --output_filename <file.json>

cannot be used for the Java SDK WorkflowReplayer:
https://github.com/temporalio/sdk-java/blob/master/temporal-testing/src/main/java/io/temporal/testing/WorkflowReplayer.java

Here https://raw.githubusercontent.com/tsurdilo/temporal-patient-onboarding/main/onboarding-app/src/test/resources/onboardingrunhistory.json
you can find a working JSON,
main difference are the event names, for example:

"eventType": "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",

instead of

"eventType": "WORKFLOW_EXECUTION_STARTED",

which creates errors with WorkflowReplayer

#### Comments (2)

<details>
<summary><strong>wxing1292</strong> commented on 2021-06-22 20:53:35.000 UTC</summary>

@tsurdilo 
go SDK works with json generated by tctl, should this issue be transfered to java SDK?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-17 00:09:44.000 UTC</summary>

Closed by #729

</details>


---

<a id="501"></a>

### #501: Child workflow signal / cancellation should not use run ID

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/501 |
| **State** | CLOSED |
| **Author** | wxing1292 (Wenquan Xing) |
| **Created** | 2021-05-19 00:36:51.000 UTC (4y 7m ago) |
| **Updated** | 2021-07-16 01:06:07.000 UTC |
| **Closed** | 2021-06-21 16:54:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

Existing behavior:
When signal / cancel child workflow, `RunId` is set, `ChildWorkflowOnly` is set to false

Correct behavior:
Signal / cancel child workflow should be `RunId` not set, `ChildWorkflowOnly` is set to true

Reasoning:
What if child workflow does continue as new, or child workflow is reseted.

#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-06-07 17:17:53.000 UTC</summary>

We should also verify that his is not an issue in Go SDK before closing.

</details>

<details>
<summary><strong>vkoby</strong> commented on 2021-06-16 18:39:24.000 UTC</summary>

Per conversation with @wxing1292 this is hard to reproduce because the bug happens when the timing is just right. For example:
t = 0 child workflow finish
t = 1 child workflow has not report to parent yet (there can be few hundreds ms delay)
t = 2 since child workflow finished, some random guy start a workflow reusing the child workflow‚Äôs workflow ID
t = 3 parent try to cancel child, sending command with workflow ID set, run ID not set, child only == false
t = 4  some random guy‚Äôs workflow is request cancelled, since child only == false
‚Ä¶
After discussing with @wxing1292 and @vitarb the consensus is to implement the fix without testing. We will ensure that the existing tests pass to make sure that there are no regressions.

</details>


---

<a id="466"></a>

### #466: Allow passing proxy objects to registerActivitiesImplementations 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/466 |
| **State** | CLOSED |
| **Author** | mostafacs (Mostafa) |
| **Created** | 2021-05-03 16:36:43.000 UTC (4y 8m ago) |
| **Updated** | 2022-07-06 14:26:13.000 UTC |
| **Closed** | 2022-07-06 14:26:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'm implementing a quarkus extension for temporal and it's about 90% completed. I want to support quarkus interceptors in Activities. quarkus handle interceptor interceptions with Proxy and Invocation Handler

I think supporting a factory method and passing the activity interface too is the solution

This is the link for my extension: https://github.com/mostafacs/quarkus-temporal-extension

#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2021-05-03 20:53:43.000 UTC</summary>

Have you considered using [DynamicActivity](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/activity/DynamicActivity.java)?

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-06 14:26:13.000 UTC</summary>

I believe you should be able to provide Proxy objects to registerActivitiesImplementations just fine if these Proxies are implementing an ActivityInterface.

</details>


---

<a id="446"></a>

### #446: Change log level from ERROR to INFO for failed workflow task caused by signal race condition

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/446 |
| **State** | CLOSED |
| **Author** | sunshineo (Gordon Sun) |
| **Created** | 2021-03-26 01:05:59.000 UTC (4y 9m ago) |
| **Updated** | 2021-04-30 23:17:37.000 UTC |
| **Closed** | 2021-04-30 23:17:37.000 UTC |
| **Upvotes** | 1 |
| **Comments** | 0 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |
| **Reactions** | üëç 1 |

#### Description

Details in https://community.temporal.io/t/how-to-identify-what-was-failing-when-failure-processing-workflow-task-happens/1811
In my word:
Worker received a task to close the workflow from the service, while the worker is working on it, the service received a signal to the workflow. When the worker tries to close the workflow, the service will reject the request to close the workflow. The worker receives this rejection and logging it as ERROR. But everything will be fine after the signal is processed and workflow will be closed.


---

<a id="401"></a>

### #401: Activity retry not happening in cron workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/401 |
| **State** | CLOSED |
| **Author** | arjunacharya10 (Arjun Acharya) |
| **Created** | 2021-03-25 06:01:09.000 UTC (4y 9m ago) |
| **Updated** | 2021-05-26 00:18:42.000 UTC |
| **Closed** | 2021-05-26 00:18:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

A Cron workflow which is triggered once every 30 days, if an activity throws error twice before returning the expected value. If we forward the testEnv to 90 days, then:

## Expected Behavior
The activity is called 3(number of times workflow is triggered in 90 days) * 3(number of times activity is called per workflow trigger) times = 9 times

## Actual Behavior
The activity is called 3 times, i.e not retried

## Steps to Reproduce the Problem

  1. In a test case, Start a workflow as a cron job, which runs once every 30 days
  2. Use a mock activity to throw IllegalStateException twice before returning the expected value
  3. Assert how many times the activity was called

## Specifications

  - Version: temporal-sdk:1.0.6, temporal-testing:1.0.6, temporal-testing-junit4:1.0.6
  - Platform:


#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2021-04-01 05:20:20.000 UTC</summary>

Hey Arjun, thanks for reporting this issue, I'm not sure if I understand your issue correctly, but I've tried to reproduce it, slightly modifying CronSample (see [here](https://github.com/vitarb/samples-java/commit/387d87f1817a6866e28554fb91939a0f6b699dad)) to throw exception 2 times in the activity before succeeding.
As expected I've seen 3 attempts for each workflow run:
```
Started workflow_id: "HelloCron"
run_id: "b378177e-cfa4-49d2-b975-b8367b8a68af"

21:58:00.441 [Activity Executor taskQueue="HelloCron", namespace="default": 1] WARN  i.t.i.sync.POJOActivityTaskHandler - Activity failure. ActivityId=cddb2eb7-c7b6-39b5-96d6-ab1edf74bb26, activityType=Greet, attempt=1
java.lang.IllegalStateException: Failing activity for HelloCron because execution attempt was 1
	at io.temporal.samples.hello.HelloCron$GreetingActivitiesImpl.greet(HelloCron.java:83)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:293)
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOActivityImplementation.execute(POJOActivityTaskHandler.java:252)
	at io.temporal.internal.sync.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:211)
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:192)
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:154)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
21:58:01.458 [Activity Executor taskQueue="HelloCron", namespace="default": 2] WARN  i.t.i.sync.POJOActivityTaskHandler - Activity failure. ActivityId=cddb2eb7-c7b6-39b5-96d6-ab1edf74bb26, activityType=Greet, attempt=2
java.lang.IllegalStateException: Failing activity for HelloCron because execution attempt was 2
	at io.temporal.samples.hello.HelloCron$GreetingActivitiesImpl.greet(HelloCron.java:83)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:293)
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOActivityImplementation.execute(POJOActivityTaskHandler.java:252)
	at io.temporal.internal.sync.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:211)
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:192)
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:154)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
From HelloCron: Hello World!
```

It would help if you could provide a minimal sample that reproduces the issue you are talking about or a unit test.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-05-26 00:18:42.000 UTC</summary>

Resolving as there was no response.

</details>


---

<a id="353"></a>

### #353: Log messages emitted by POJOActivityTaskHandler should include workflow ID and run ID

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/353 |
| **State** | CLOSED |
| **Author** | rfwagner (Richard Wagner) |
| **Created** | 2021-02-17 23:39:34.000 UTC (4y 10m ago) |
| **Updated** | 2021-09-20 00:29:28.000 UTC |
| **Closed** | 2021-09-20 00:29:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | invalid |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We are seeing logs emitted by this line in POJOActivityTaskHandler:

      log.warn(
          "Activity failure. ActivityId="
              + info.getActivityId()
              + ", activityType="
              + info.getActivityType()
              + ", attempt="
              + info.getAttempt(),
          e);

Unfortunately there is no out-of-the-box way to search for a workflow by activity ID - neither in the UI or via the CLI.

It would be ideal if all messages emitted by POJOActivityTaskHandler included the workflow ID and run ID. Since these fields are members of the ActivityInfo interface, I assume this would be very easy to add in this particular case.

Perhaps it would be worth taking a pass through the entire SDK and add workflow ID and run ID to all log lines where it is easy to do so?


#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2021-02-18 00:01:55.000 UTC</summary>

The workflowID and runID are already part of [MDC](https://github.com/temporalio/sdk-java/blob/f7bc07dfe69441cbdaf3a4697ab3fab713324d45/temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java#L183). Change your log format to include MDC fields.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-02-18 02:49:09.000 UTC</summary>

@rfwagner look [here](https://www.baeldung.com/mdc-in-log4j-2-logback) for examples of how to configure MDC fields for different loggers.

</details>


---

<a id="343"></a>

### #343: Don't perform a long poll of the execution result if nobody waits on it

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/343 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2019-11-21 07:03:19.000 UTC (6y 1m ago) |
| **Updated** | 2024-12-23 09:58:39.000 UTC |
| **Closed** | 2024-12-23 09:58:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently WorkflowClient.execute returns CompletableFuture. The problem is that the GetWorkflowExecutionHistory is initiated as soon as the execute is called, not when future.get is called. So if future.get is not ever called the long poll GetWorkflowExecutionHistory is still done.

#### Comments (2)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-20 17:57:41.000 UTC</summary>

Related (duplicate?) to #1212

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 09:58:39.000 UTC</summary>

Closing as duplicate of https://github.com/temporalio/sdk-java/issues/1212

</details>


---

<a id="334"></a>

### #334: Was io.temporal.testing.TestWorkflowEnvironment removed with 1.0.4?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/334 |
| **State** | CLOSED |
| **Author** | darewreck54 (Derek) |
| **Created** | 2021-02-05 10:43:08.000 UTC (4y 11m ago) |
| **Updated** | 2021-06-02 18:30:03.000 UTC |
| **Closed** | 2021-06-02 18:30:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I upgraded the java sdk to 1.0.5via `implementation('io.temporal:temporal-sdk:1.0.5');` and I got the following error:

```
error: package io.temporal.testing does not exist
import io.temporal.testing.TestWorkflowEnvironment;
```

Did it get removed?

## Expected Behavior
Update to 1.0.5 without my test breaking

## Actual Behavior
an exception get thrown
```
error: package io.temporal.testing does not exist
import io.temporal.testing.TestWorkflowEnvironment;
```

If i revert back to 1.0.4 I don't have the issue.

THanks,
Derek

#### Comments (2)

<details>
<summary><strong>GreyTeardrop</strong> commented on 2021-02-05 14:31:43.000 UTC</summary>

All test support code including `TestWorkflowEnvironment` was moved to the `temporal-testing` module in the 1.0.5 release (see PR: https://github.com/temporalio/sdk-java/pull/292).

</details>

<details>
<summary><strong>darewreck54</strong> commented on 2021-02-05 17:57:30.000 UTC</summary>

k thanks.  What might be helpful is have a change log that points out "Breaking Change" and then point out that users need to include a new package.

</details>


---

<a id="324"></a>

### #324: Better handling of WorkflowFailedException exception

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/324 |
| **State** | CLOSED |
| **Author** | mobiletoly (Toly Pochkin) |
| **Created** | 2021-01-28 22:48:59.000 UTC (4y 11m ago) |
| **Updated** | 2024-12-23 21:09:16.000 UTC |
| **Closed** | 2024-12-23 21:09:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Let me quickly explain my current situation. I have a system with few microservices, just for a simplicity let's make it two microservices - (1) API Gateway and (2) Listing Service. My Account Service has workflows related to managing Listings (e.g. create a new listing). While API Gateway is a REST service.
When I call Account Service from API Gateway - I obviously want to translate errors I receive from Account Service to some meaningful HTTP response code and response payload. It is easy to do with analyzing WorkflowFailedException's getCause() method but here is a gotcha. In workflow I can throw an exception (e.g. non-retriable exception) via `ApplicationFailure.newNonRetryableFailure` with some error type (e.g. "LISTING_NOT_FOUND") but this call may generate different exception types. E.g. if it is called from Activity - then exception thrown is ActivityFailure while if exception is thrown from workflow then exception will be ApplicationFailure. It forces me to add more boilerplate to my caller code, because now I have to check what type of exception if thrown, is it ActivityFailure or ApplicationFailure. For example if it is ApplicationType - I can check type directly, while if it is ActivityFailure, then I have to type a look even deeper inside ActivityFailure, find it cause, convert it to ApplicationFailure and check type.
And it makes caller to be aware of internal logic of workflow, while caller does not really need to know if error happened in Activity or Application, it just needs to know error type, because this logic can change, today I call ApplicationFailure with LISTING_NOT_FOUND error type from Workflow, tomorrow I decide to do some optimization and move this throw into Activity.

**Describe the solution you'd like**
Two options:
1. WorkflowFailedException need to have some common fields from ApplicationFailure/ActivityFailure, e.g. getType()
or
2. Both  ApplicationFailure and ActivityFailure derive from TemporalFailure, so some common fields can be added there.




#### Comments (2)

<details>
<summary><strong>mobiletoly</strong> commented on 2021-01-28 23:05:21.000 UTC</summary>

Actually third option could that if ApplicationFailure exception is thrown from Activity - it should not be converted to ActivityFailure and should remain ApplicationFailure, because that is what we explicitly tell to our code to do when throw exception in Activity via let's say `throw ApplicationFailure.newNonRetryableFailure` - we want application-level exception. But I don't know what would be the implications of this solution for existing code.
Otherwise it is all very confusing (unless we have a really good documentation outlining this kind of issues) - should we even allow something like ApplicationFailure.newNonRetryableFailure from Activity code? should we introduce some sort of ActivityFailure.newNonRetryableFailure instead if we want to signal Activity-level errors and keep ApplicationFailure.newNonRetryableFailure for clearly application-level issues (e.g. business logic) that can be throws from Activity without being treated as Activity error?

</details>

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 21:09:16.000 UTC</summary>

The intention is to unwrap exceptions if you are not interested in the wrappers details. You can also do this in your workflow to standardize the exception a client would see. Changing the exception structure is a breaking change and not something we can consider at this point.

</details>


---

<a id="323"></a>

### #323: Throwing non-retriable failure ignored by local activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/323 |
| **State** | CLOSED |
| **Author** | mobiletoly (Toly Pochkin) |
| **Created** | 2021-01-28 18:48:27.000 UTC (4y 11m ago) |
| **Updated** | 2021-08-17 00:17:37.000 UTC |
| **Closed** | 2021-08-17 00:17:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | v1.3.0 |

#### Description

## Expected Behavior

In local activities throwing exception returned by ApplicationFailure.newNonRetryableFailure should result for workflow NOT to retry it. 


## Actual Behavior

throwing with ApplicationFailure.newNonRetryableFailure in Activity (launched via `Workflow.newLocalActivityStub`) results for workflow to keep retrying, which is incorrect behavior. Regular activities (launched via `Workflow.newActivityStub`) are working as expected.

## Steps to Reproduce the Problem

  1. Create new activity A with method m() calling `throw ApplicationFailure.newNonRetryableFailure(...)`
  2. Create workflow and register A as local activity via `Workflow.newLocalActivityStub` with `LocalActivityOptions` setup for some retries and duration.
  3. Call method m() from workflow and ensure that m() is keep retrying.

## Specifications

  - Version: Temporal Java SDK 1.0.4
  - Platform: Temporal Server 1.5.x
  

#### Comments (2)

<details>
<summary><strong>yibo-yolabs</strong> commented on 2021-08-06 23:26:12.000 UTC</summary>

Hi, is there any update on this bug? We are facing this bug too, and want to know when it will be addressed. Thanks!

</details>

<details>
<summary><strong>yibo-yolabs</strong> commented on 2021-08-06 23:51:09.000 UTC</summary>

To walk around this bug, I have to do setDoNotRetry() with the extensive list of exceptions in the LocalActivityOptions.RetryOptions. 

</details>


---

<a id="309"></a>

### #309: WorkflowServiceStubs (sdk 1.0.4) instantiation fails within spring service

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/309 |
| **State** | CLOSED |
| **Author** | bhaskara-illumina (Ganesha Bhaskara) |
| **Created** | 2021-01-15 17:44:27.000 UTC (4y 11m ago) |
| **Updated** | 2021-01-25 06:18:39.000 UTC |
| **Closed** | 2021-01-25 06:16:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior

WorkflowServiceStub class should be successfully instantiated


    public SchedulerService(ApplicationProperties applicationProperties) {
        WorkflowServiceStubsOptions options =
                WorkflowServiceStubsOptions.newBuilder().setTarget(applicationProperties.getTemporalHostPort()).build();
        WorkflowServiceStubs stubs = WorkflowServiceStubs.newInstance(options);


## Actual Behavior


***************************
APPLICATION FAILED TO START
***************************

Description:

An attempt was made to call a method that does not exist. The attempt was made from the following location:

    io.temporal.serviceclient.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:115)

The following method did not exist:

    io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder.maxInboundMessageSize(int)

The method's class, io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder, is available from the following locations:

    jar:file:/home/xxx/.m2/repository/io/grpc/grpc-netty-shaded/1.30.2/grpc-netty-shaded-1.30.2.jar!/io/grpc/netty/shaded/io/grpc/netty/NettyChannelBuilder.class

The class hierarchy was loaded from the following locations:

    io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder: file:/home/xxx/.m2/repository/io/grpc/grpc-netty-shaded/1.30.2/grpc-netty-shaded-1.30.2.jar
    io.grpc.internal.AbstractManagedChannelImplBuilder: file:/home/xxx/.m2/repository/io/grpc/grpc-core/1.30.2/grpc-core-1.30.2.jar
    io.grpc.ManagedChannelBuilder: file:/home/xxx/.m2/repository/io/grpc/grpc-api/1.30.2/grpc-api-1.30.2.jar


Action:

Correct the classpath of your application so that it contains a single, compatible version of io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder


Here is the dependency tree.


[INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ name-api ---
[INFO] com.company.project:name-api:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.boot:spring-boot-starter-actuator:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.3.7.RELEASE:compile
[INFO] |  |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile
[INFO] |  |  |  |  \- ch.qos.logback:logback-core:jar:1.2.3:compile
[INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile
[INFO] |  |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.13.3:compile
[INFO] |  |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.30:compile
[INFO] |  |  +- jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile
[INFO] |  |  \- org.yaml:snakeyaml:jar:1.26:compile
[INFO] |  +- org.springframework.boot:spring-boot-actuator-autoconfigure:jar:2.3.7.RELEASE:compile
[INFO] |  |  \- org.springframework.boot:spring-boot-actuator:jar:2.3.7.RELEASE:compile
[INFO] |  \- io.micrometer:micrometer-core:jar:1.5.9:compile
[INFO] |     +- org.hdrhistogram:HdrHistogram:jar:2.1.12:compile
[INFO] |     \- org.latencyutils:LatencyUtils:jar:2.0.3:runtime
[INFO] +- org.springframework.boot:spring-boot-starter-security:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework:spring-aop:jar:5.2.12.RELEASE:compile
[INFO] |  |  \- org.springframework:spring-beans:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework.security:spring-security-config:jar:5.3.6.RELEASE:compile
[INFO] |  \- org.springframework.security:spring-security-web:jar:5.3.6.RELEASE:compile
[INFO] |     \- org.springframework:spring-expression:jar:5.2.12.RELEASE:compile
[INFO] +- org.springframework.boot:spring-boot-starter-validation:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.glassfish:jakarta.el:jar:3.0.3:compile
[INFO] |  \- org.hibernate.validator:hibernate-validator:jar:6.1.6.Final:compile
[INFO] |     +- jakarta.validation:jakarta.validation-api:jar:2.0.2:compile
[INFO] |     \- org.jboss.logging:jboss-logging:jar:3.4.1.Final:compile
[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-json:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compile
[INFO] |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.41:compile
[INFO] |  |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.41:compile
[INFO] |  +- org.springframework:spring-web:jar:5.2.12.RELEASE:compile
[INFO] |  \- org.springframework:spring-webmvc:jar:5.2.12.RELEASE:compile
[INFO] +- org.springframework.boot:spring-boot-starter-cache:jar:2.3.7.RELEASE:compile
[INFO] |  \- org.springframework:spring-context-support:jar:5.2.12.RELEASE:compile
[INFO] +- com.github.ben-manes.caffeine:caffeine:jar:2.8.8:compile
[INFO] |  +- org.checkerframework:checker-qual:jar:3.8.0:compile
[INFO] |  \- com.google.errorprone:error_prone_annotations:jar:2.4.0:compile
[INFO] +- org.springframework.kafka:spring-kafka:jar:2.5.10.RELEASE:compile
[INFO] |  +- org.springframework:spring-context:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework:spring-messaging:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework:spring-tx:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework.retry:spring-retry:jar:1.2.5.RELEASE:compile
[INFO] |  \- org.apache.kafka:kafka-clients:jar:2.5.1:compile
[INFO] |     +- com.github.luben:zstd-jni:jar:1.4.4-7:compile
[INFO] |     +- org.lz4:lz4-java:jar:1.7.1:compile
[INFO] |     \- org.xerial.snappy:snappy-java:jar:1.1.7.3:compile
[INFO] +- org.springframework.boot:spring-boot-devtools:jar:2.3.7.RELEASE:runtime (optional) 
[INFO] |  +- org.springframework.boot:spring-boot:jar:2.3.7.RELEASE:compile
[INFO] |  \- org.springframework.boot:spring-boot-autoconfigure:jar:2.3.7.RELEASE:compile
[INFO] +- io.micrometer:micrometer-registry-datadog:jar:1.5.9:runtime
[INFO] |  \- org.slf4j:slf4j-api:jar:1.7.30:compile
[INFO] +- org.springframework.boot:spring-boot-configuration-processor:jar:2.3.7.RELEASE:compile (optional) 
[INFO] +- org.projectlombok:lombok:jar:1.18.16:compile (optional) 
[INFO] +- io.springfox:springfox-boot-starter:jar:3.0.0:compile
[INFO] |  +- io.springfox:springfox-oas:jar:3.0.0:compile
[INFO] |  |  +- io.swagger.core.v3:swagger-annotations:jar:2.1.2:compile
[INFO] |  |  +- io.swagger.core.v3:swagger-models:jar:2.1.2:compile
[INFO] |  |  +- io.springfox:springfox-spi:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-schema:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-core:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-spring-webmvc:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-spring-webflux:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-swagger-common:jar:3.0.0:compile
[INFO] |  |  \- org.mapstruct:mapstruct:jar:1.3.1.Final:runtime
[INFO] |  +- io.springfox:springfox-data-rest:jar:3.0.0:compile
[INFO] |  +- io.springfox:springfox-swagger2:jar:3.0.0:compile
[INFO] |  |  +- io.swagger:swagger-annotations:jar:1.5.20:compile
[INFO] |  |  \- io.swagger:swagger-models:jar:1.5.20:compile
[INFO] |  +- io.springfox:springfox-swagger-ui:jar:3.0.0:compile
[INFO] |  +- com.fasterxml:classmate:jar:1.5.1:compile
[INFO] |  +- org.springframework.plugin:spring-plugin-core:jar:2.0.0.RELEASE:compile
[INFO] |  \- org.springframework.plugin:spring-plugin-metadata:jar:2.0.0.RELEASE:compile
[INFO] +- io.springfox:springfox-bean-validators:jar:3.0.0:compile
[INFO] |  \- io.springfox:springfox-spring-web:jar:3.0.0:compile
[INFO] |     \- io.github.classgraph:classgraph:jar:4.8.83:compile
[INFO] +- org.springframework.boot:spring-boot-starter-test:jar:2.3.7.RELEASE:test
[INFO] |  +- org.springframework.boot:spring-boot-test:jar:2.3.7.RELEASE:test
[INFO] |  +- org.springframework.boot:spring-boot-test-autoconfigure:jar:2.3.7.RELEASE:test
[INFO] |  +- com.jayway.jsonpath:json-path:jar:2.4.0:test
[INFO] |  |  \- net.minidev:json-smart:jar:2.3:test
[INFO] |  |     \- net.minidev:accessors-smart:jar:1.2:test
[INFO] |  |        \- org.ow2.asm:asm:jar:5.0.4:test
[INFO] |  +- org.assertj:assertj-core:jar:3.16.1:test
[INFO] |  +- org.hamcrest:hamcrest:jar:2.2:test
[INFO] |  +- org.junit.jupiter:junit-jupiter:jar:5.6.3:test
[INFO] |  |  +- org.junit.jupiter:junit-jupiter-params:jar:5.6.3:test
[INFO] |  |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.6.3:test
[INFO] |  +- org.junit.vintage:junit-vintage-engine:jar:5.6.3:test
[INFO] |  |  +- org.apiguardian:apiguardian-api:jar:1.1.0:test
[INFO] |  |  +- org.junit.platform:junit-platform-engine:jar:1.6.3:test
[INFO] |  |  \- junit:junit:jar:4.13.1:test
[INFO] |  +- org.mockito:mockito-core:jar:3.3.3:test
[INFO] |  |  +- net.bytebuddy:byte-buddy:jar:1.10.18:compile
[INFO] |  |  +- net.bytebuddy:byte-buddy-agent:jar:1.10.18:test
[INFO] |  |  \- org.objenesis:objenesis:jar:2.6:test
[INFO] |  +- org.mockito:mockito-junit-jupiter:jar:3.3.3:test
[INFO] |  +- org.skyscreamer:jsonassert:jar:1.5.0:test
[INFO] |  |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test
[INFO] |  +- org.springframework:spring-core:jar:5.2.12.RELEASE:compile
[INFO] |  |  \- org.springframework:spring-jcl:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework:spring-test:jar:5.2.12.RELEASE:test
[INFO] |  \- org.xmlunit:xmlunit-core:jar:2.7.0:test
[INFO] +- io.rest-assured:rest-assured:jar:3.3.0:test
[INFO] |  +- org.codehaus.groovy:groovy:jar:2.5.14:test
[INFO] |  +- org.codehaus.groovy:groovy-xml:jar:2.5.14:test
[INFO] |  +- org.apache.httpcomponents:httpclient:jar:4.5.13:compile
[INFO] |  |  +- org.apache.httpcomponents:httpcore:jar:4.4.14:compile
[INFO] |  |  \- commons-codec:commons-codec:jar:1.14:compile
[INFO] |  +- org.apache.httpcomponents:httpmime:jar:4.5.13:test
[INFO] |  +- org.hamcrest:hamcrest-core:jar:2.2:test
[INFO] |  +- org.ccil.cowan.tagsoup:tagsoup:jar:1.2.1:test
[INFO] |  +- io.rest-assured:json-path:jar:3.3.0:test
[INFO] |  |  +- org.codehaus.groovy:groovy-json:jar:2.5.14:test
[INFO] |  |  \- io.rest-assured:rest-assured-common:jar:3.3.0:test
[INFO] |  \- io.rest-assured:xml-path:jar:3.3.0:test
[INFO] |     +- org.apache.commons:commons-lang3:jar:3.10:runtime
[INFO] |     +- javax.xml.bind:jaxb-api:jar:2.3.1:test
[INFO] |     |  \- javax.activation:javax.activation-api:jar:1.2.0:test
[INFO] |     +- com.sun.xml.bind:jaxb-osgi:jar:2.2.10:test
[INFO] |     \- org.apache.sling:org.apache.sling.javax.activation:jar:0.1.0:test
[INFO] |        \- javax.activation:activation:jar:1.1.1:test
[INFO] +- org.springframework.cloud:spring-cloud-starter-contract-stub-runner:jar:2.2.4.RELEASE:test
[INFO] |  +- org.springframework.cloud:spring-cloud-contract-stub-runner:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-verifier:jar:2.2.4.RELEASE:test
[INFO] |  |  |  +- javax.inject:javax.inject:jar:1:test
[INFO] |  |  |  +- com.toomuchcoding.jsonassert:jsonassert:jar:0.4.14:test
[INFO] |  |  |  +- com.rackspace.eclipse.webtools.sourceediting:org.eclipse.wst.xml.xpath2.processor:jar:2.1.100:test
[INFO] |  |  |  |  +- edu.princeton.cup:java-cup:jar:10k:test
[INFO] |  |  |  |  \- com.ibm.icu:icu4j:jar:4.6:test
[INFO] |  |  |  +- org.codehaus.groovy:groovy-nio:jar:2.5.14:test
[INFO] |  |  |  +- com.github.jknack:handlebars:jar:4.1.2:test
[INFO] |  |  |  +- commons-beanutils:commons-beanutils:jar:1.9.4:test
[INFO] |  |  |  |  +- commons-logging:commons-logging:jar:1.2:test
[INFO] |  |  |  |  \- commons-collections:commons-collections:jar:3.2.2:test
[INFO] |  |  |  +- com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:jar:2.11.3:test
[INFO] |  |  |  \- org.springframework.cloud:spring-cloud-function-compiler:jar:3.0.9.RELEASE:test
[INFO] |  |  |     +- io.projectreactor:reactor-core:jar:3.3.12.RELEASE:test
[INFO] |  |  |     |  \- org.reactivestreams:reactive-streams:jar:1.0.3:test
[INFO] |  |  |     +- org.eclipse.jdt.core.compiler:ecj:jar:4.4.2:test
[INFO] |  |  |     +- org.springframework.cloud:spring-cloud-function-core:jar:3.0.9.RELEASE:test
[INFO] |  |  |     \- javax.annotation:javax.annotation-api:jar:1.3.2:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-shade:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-converters:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-spec:jar:2.2.4.RELEASE:test
[INFO] |  |  |  +- org.springframework.cloud:spring-cloud-contract-spec-java:jar:2.2.4.RELEASE:test
[INFO] |  |  |  |  +- dk.brics.automaton:automaton:jar:1.11-8:test
[INFO] |  |  |  |  \- org.apache.commons:commons-text:jar:1.7:test
[INFO] |  |  |  \- org.springframework.cloud:spring-cloud-contract-spec-groovy:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.eclipse.jgit:org.eclipse.jgit:jar:5.1.3.201810200350-r:test
[INFO] |  |  |  +- com.jcraft:jsch:jar:0.1.54:test
[INFO] |  |  |  +- com.jcraft:jzlib:jar:1.1.1:test
[INFO] |  |  |  \- com.googlecode.javaewah:JavaEWAH:jar:1.1.6:test
[INFO] |  |  +- com.jcraft:jsch.agentproxy.sshagent:jar:0.0.9:test
[INFO] |  |  |  \- com.jcraft:jsch.agentproxy.core:jar:0.0.9:test
[INFO] |  |  +- com.jcraft:jsch.agentproxy.jsch:jar:0.0.9:test
[INFO] |  |  \- com.jcraft:jsch.agentproxy.usocket-jna:jar:0.0.9:test
[INFO] |  |     +- net.java.dev.jna:jna:jar:4.1.0:test
[INFO] |  |     \- net.java.dev.jna:jna-platform:jar:4.1.0:test
[INFO] |  +- org.springframework.cloud:spring-cloud-contract-wiremock:jar:2.2.4.RELEASE:test
[INFO] |  |  \- com.github.tomakehurst:wiremock-jre8-standalone:jar:2.26.2:test
[INFO] |  \- org.apache.maven.resolver:maven-resolver-api:jar:1.3.3:test
[INFO] +- org.hamcrest:hamcrest-library:jar:2.2:test
[INFO] +- commons-io:commons-io:jar:2.6:compile
[INFO] +- org.springframework.security:spring-security-test:jar:5.3.6.RELEASE:test
[INFO] |  \- org.springframework.security:spring-security-core:jar:5.3.6.RELEASE:compile
[INFO] +- org.springframework.kafka:spring-kafka-test:jar:2.5.10.RELEASE:test
[INFO] |  +- org.apache.kafka:kafka-clients:jar:test:2.5.1:test
[INFO] |  +- org.apache.kafka:kafka-streams:jar:2.5.1:test
[INFO] |  |  +- org.apache.kafka:connect-json:jar:2.5.1:test
[INFO] |  |  |  \- org.apache.kafka:connect-api:jar:2.5.1:test
[INFO] |  |  \- org.rocksdb:rocksdbjni:jar:5.18.3:test
[INFO] |  +- org.apache.kafka:kafka-streams-test-utils:jar:2.5.1:test
[INFO] |  +- org.apache.kafka:kafka_2.12:jar:2.5.1:test
[INFO] |  |  +- com.fasterxml.jackson.module:jackson-module-scala_2.12:jar:2.11.3:test
[INFO] |  |  |  \- com.fasterxml.jackson.module:jackson-module-paranamer:jar:2.11.3:test
[INFO] |  |  |     \- com.thoughtworks.paranamer:paranamer:jar:2.8:test
[INFO] |  |  +- com.fasterxml.jackson.dataformat:jackson-dataformat-csv:jar:2.11.3:test
[INFO] |  |  +- net.sf.jopt-simple:jopt-simple:jar:5.0.4:test
[INFO] |  |  +- com.yammer.metrics:metrics-core:jar:2.2.0:test
[INFO] |  |  +- org.scala-lang.modules:scala-collection-compat_2.12:jar:2.1.3:test
[INFO] |  |  +- org.scala-lang.modules:scala-java8-compat_2.12:jar:0.9.0:test
[INFO] |  |  +- com.typesafe.scala-logging:scala-logging_2.12:jar:3.9.2:test
[INFO] |  |  +- org.apache.zookeeper:zookeeper:jar:3.5.8:test
[INFO] |  |  |  +- org.apache.zookeeper:zookeeper-jute:jar:3.5.8:test
[INFO] |  |  |  +- org.apache.yetus:audience-annotations:jar:0.5.0:test
[INFO] |  |  |  +- io.netty:netty-handler:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-common:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-resolver:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-buffer:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-transport:jar:4.1.55.Final:test
[INFO] |  |  |  |  \- io.netty:netty-codec:jar:4.1.55.Final:test
[INFO] |  |  |  \- io.netty:netty-transport-native-epoll:jar:4.1.55.Final:test
[INFO] |  |  |     \- io.netty:netty-transport-native-unix-common:jar:4.1.55.Final:test
[INFO] |  |  \- commons-cli:commons-cli:jar:1.4:test
[INFO] |  +- org.apache.kafka:kafka_2.12:jar:test:2.5.1:test
[INFO] |  +- org.scala-lang:scala-library:jar:2.12.11:test
[INFO] |  +- org.scala-lang:scala-reflect:jar:2.12.11:test
[INFO] |  \- org.junit.jupiter:junit-jupiter-api:jar:5.6.3:test
[INFO] |     +- org.opentest4j:opentest4j:jar:1.2.0:test
[INFO] |     \- org.junit.platform:junit-platform-commons:jar:1.6.3:test
[INFO] +- com.illumina.prs.common.security:common-userservices-client-spring-boot2-starter:jar:3.7.2:compile
[INFO] |  +- com.illumina.prs.common.security:common-userservices-client-spring-boot2-autoconfigure:jar:3.7.2:compile
[INFO] |  +- com.illumina.prs.common.security:common-user-service:jar:3.7.2:compile
[INFO] |  |  +- com.illumina.prs.common.security:platform-auth-api-client:jar:3.7.2:compile
[INFO] |  |  +- com.illumina.prs.common.security:common-utils:jar:3.7.2:compile
[INFO] |  |  \- com.auth0:java-jwt:jar:3.5.0:compile
[INFO] |  +- com.illumina.prs.common.security:feature-flag-utils:jar:3.7.2:compile
[INFO] |  \- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compile
[INFO] |     +- com.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compile
[INFO] |     \- com.fasterxml.jackson.core:jackson-core:jar:2.11.3:compile
[INFO] +- jakarta.xml.bind:jakarta.xml.bind-api:jar:2.3.3:compile
[INFO] |  \- jakarta.activation:jakarta.activation-api:jar:1.2.2:compile
[INFO] +- org.springframework.boot:spring-boot-starter-data-jpa:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-aop:jar:2.3.7.RELEASE:compile
[INFO] |  |  \- org.aspectj:aspectjweaver:jar:1.9.6:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-jdbc:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- com.zaxxer:HikariCP:jar:3.4.5:compile
[INFO] |  |  \- org.springframework:spring-jdbc:jar:5.2.12.RELEASE:compile
[INFO] |  +- jakarta.transaction:jakarta.transaction-api:jar:1.3.3:compile
[INFO] |  +- jakarta.persistence:jakarta.persistence-api:jar:2.2.3:compile
[INFO] |  +- org.hibernate:hibernate-core:jar:5.4.25.Final:compile
[INFO] |  |  +- org.javassist:javassist:jar:3.27.0-GA:compile
[INFO] |  |  +- antlr:antlr:jar:2.7.7:compile
[INFO] |  |  +- org.jboss:jandex:jar:2.1.3.Final:compile
[INFO] |  |  +- org.dom4j:dom4j:jar:2.1.3:compile
[INFO] |  |  +- org.hibernate.common:hibernate-commons-annotations:jar:5.1.2.Final:compile
[INFO] |  |  \- org.glassfish.jaxb:jaxb-runtime:jar:2.3.3:compile
[INFO] |  |     +- org.glassfish.jaxb:txw2:jar:2.3.3:compile
[INFO] |  |     +- com.sun.istack:istack-commons-runtime:jar:3.0.11:compile
[INFO] |  |     \- com.sun.activation:jakarta.activation:jar:1.2.2:runtime
[INFO] |  +- org.springframework.data:spring-data-jpa:jar:2.3.6.RELEASE:compile
[INFO] |  |  +- org.springframework.data:spring-data-commons:jar:2.3.6.RELEASE:compile
[INFO] |  |  \- org.springframework:spring-orm:jar:5.2.12.RELEASE:compile
[INFO] |  \- org.springframework:spring-aspects:jar:5.2.12.RELEASE:compile
[INFO] +- org.flywaydb:flyway-core:jar:6.4.4:compile
[INFO] +- org.postgresql:postgresql:jar:42.2.18:runtime
[INFO] +- org.hsqldb:hsqldb:jar:2.5.1:runtime
[INFO] \- io.temporal:temporal-sdk:jar:1.0.4:compile
[INFO]    +- io.temporal:temporal-serviceclient:jar:1.0.4:compile
[INFO]    |  +- io.grpc:grpc-protobuf:jar:1.30.2:compile
[INFO]    |  |  +- io.grpc:grpc-api:jar:1.30.2:compile
[INFO]    |  |  |  \- io.grpc:grpc-context:jar:1.30.2:compile
[INFO]    |  |  +- com.google.protobuf:protobuf-java:jar:3.12.2:compile
[INFO]    |  |  +- com.google.api.grpc:proto-google-common-protos:jar:1.18.0:compile
[INFO]    |  |  +- io.grpc:grpc-protobuf-lite:jar:1.30.2:compile
[INFO]    |  |  \- org.codehaus.mojo:animal-sniffer-annotations:jar:1.18:runtime
[INFO]    |  +- io.grpc:grpc-stub:jar:1.30.2:compile
[INFO]    |  +- io.grpc:grpc-core:jar:1.30.2:compile
[INFO]    |  |  +- com.google.android:annotations:jar:4.1.1.4:runtime
[INFO]    |  |  \- io.perfmark:perfmark-api:jar:0.19.0:runtime
[INFO]    |  +- com.google.protobuf:protobuf-java-util:jar:3.12.2:compile
[INFO]    |  +- com.uber.m3:tally-core:jar:0.6.1:compile
[INFO]    |  \- io.grpc:grpc-netty-shaded:jar:1.30.2:runtime
[INFO]    +- com.google.code.gson:gson:jar:2.8.6:compile
[INFO]    +- com.google.guava:guava:jar:29.0-jre:compile
[INFO]    |  +- com.google.guava:failureaccess:jar:1.0.1:compile
[INFO]    |  +- com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile
[INFO]    |  +- com.google.code.findbugs:jsr305:jar:3.0.2:compile
[INFO]    |  \- com.google.j2objc:j2objc-annotations:jar:1.3:compile
[INFO]    +- com.cronutils:cron-utils:jar:9.1.3:runtime
[INFO]    |  \- org.glassfish:javax.el:jar:3.0.0:runtime
[INFO]    \- com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.973 s
[INFO] Finished at: 2021-01-15T09:17:09-08:00
[INFO] ------------------------------------------------------------------------


## Steps to Reproduce the Problem

  1. create sample api app in spring framework   
  2. add java-sdk 1.0.4 as dependency
  3. try to instantiate WorkflowServiceStubs in a service constructor

## Specifications

  - Version: 1.0.4, 1.0.3
  - Platform: OpenJDK 64-Bit Server VM (build 14.0.2+12-Ubuntu-1, mixed mode, sharing)

## Notes: 

Same code works with sdk-java 1.0.2 and here is the dependency tree with 1.0.2

[INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ name-api ---
[INFO] com.company.project:name-api:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.boot:spring-boot-starter-actuator:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.3.7.RELEASE:compile
[INFO] |  |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile
[INFO] |  |  |  |  \- ch.qos.logback:logback-core:jar:1.2.3:compile
[INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile
[INFO] |  |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.13.3:compile
[INFO] |  |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.30:compile
[INFO] |  |  +- jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile
[INFO] |  |  \- org.yaml:snakeyaml:jar:1.26:compile
[INFO] |  +- org.springframework.boot:spring-boot-actuator-autoconfigure:jar:2.3.7.RELEASE:compile
[INFO] |  |  \- org.springframework.boot:spring-boot-actuator:jar:2.3.7.RELEASE:compile
[INFO] |  \- io.micrometer:micrometer-core:jar:1.5.9:compile
[INFO] |     +- org.hdrhistogram:HdrHistogram:jar:2.1.12:compile
[INFO] |     \- org.latencyutils:LatencyUtils:jar:2.0.3:runtime
[INFO] +- org.springframework.boot:spring-boot-starter-security:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework:spring-aop:jar:5.2.12.RELEASE:compile
[INFO] |  |  \- org.springframework:spring-beans:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework.security:spring-security-config:jar:5.3.6.RELEASE:compile
[INFO] |  \- org.springframework.security:spring-security-web:jar:5.3.6.RELEASE:compile
[INFO] |     \- org.springframework:spring-expression:jar:5.2.12.RELEASE:compile
[INFO] +- org.springframework.boot:spring-boot-starter-validation:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.glassfish:jakarta.el:jar:3.0.3:compile
[INFO] |  \- org.hibernate.validator:hibernate-validator:jar:6.1.6.Final:compile
[INFO] |     +- jakarta.validation:jakarta.validation-api:jar:2.0.2:compile
[INFO] |     \- org.jboss.logging:jboss-logging:jar:3.4.1.Final:compile
[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-json:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compile
[INFO] |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.41:compile
[INFO] |  |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.41:compile
[INFO] |  +- org.springframework:spring-web:jar:5.2.12.RELEASE:compile
[INFO] |  \- org.springframework:spring-webmvc:jar:5.2.12.RELEASE:compile
[INFO] +- org.springframework.boot:spring-boot-starter-cache:jar:2.3.7.RELEASE:compile
[INFO] |  \- org.springframework:spring-context-support:jar:5.2.12.RELEASE:compile
[INFO] +- com.github.ben-manes.caffeine:caffeine:jar:2.8.8:compile
[INFO] |  +- org.checkerframework:checker-qual:jar:3.8.0:compile
[INFO] |  \- com.google.errorprone:error_prone_annotations:jar:2.4.0:compile
[INFO] +- org.springframework.kafka:spring-kafka:jar:2.5.10.RELEASE:compile
[INFO] |  +- org.springframework:spring-context:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework:spring-messaging:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework:spring-tx:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework.retry:spring-retry:jar:1.2.5.RELEASE:compile
[INFO] |  \- org.apache.kafka:kafka-clients:jar:2.5.1:compile
[INFO] |     +- com.github.luben:zstd-jni:jar:1.4.4-7:compile
[INFO] |     +- org.lz4:lz4-java:jar:1.7.1:compile
[INFO] |     \- org.xerial.snappy:snappy-java:jar:1.1.7.3:compile
[INFO] +- org.springframework.boot:spring-boot-devtools:jar:2.3.7.RELEASE:runtime (optional) 
[INFO] |  +- org.springframework.boot:spring-boot:jar:2.3.7.RELEASE:compile
[INFO] |  \- org.springframework.boot:spring-boot-autoconfigure:jar:2.3.7.RELEASE:compile
[INFO] +- io.micrometer:micrometer-registry-datadog:jar:1.5.9:runtime
[INFO] |  \- org.slf4j:slf4j-api:jar:1.7.30:compile
[INFO] +- org.springframework.boot:spring-boot-configuration-processor:jar:2.3.7.RELEASE:compile (optional) 
[INFO] +- org.projectlombok:lombok:jar:1.18.16:compile (optional) 
[INFO] +- io.springfox:springfox-boot-starter:jar:3.0.0:compile
[INFO] |  +- io.springfox:springfox-oas:jar:3.0.0:compile
[INFO] |  |  +- io.swagger.core.v3:swagger-annotations:jar:2.1.2:compile
[INFO] |  |  +- io.swagger.core.v3:swagger-models:jar:2.1.2:compile
[INFO] |  |  +- io.springfox:springfox-spi:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-schema:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-core:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-spring-webmvc:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-spring-webflux:jar:3.0.0:compile
[INFO] |  |  +- io.springfox:springfox-swagger-common:jar:3.0.0:compile
[INFO] |  |  \- org.mapstruct:mapstruct:jar:1.3.1.Final:runtime
[INFO] |  +- io.springfox:springfox-data-rest:jar:3.0.0:compile
[INFO] |  +- io.springfox:springfox-swagger2:jar:3.0.0:compile
[INFO] |  |  +- io.swagger:swagger-annotations:jar:1.5.20:compile
[INFO] |  |  \- io.swagger:swagger-models:jar:1.5.20:compile
[INFO] |  +- io.springfox:springfox-swagger-ui:jar:3.0.0:compile
[INFO] |  +- com.fasterxml:classmate:jar:1.5.1:compile
[INFO] |  +- org.springframework.plugin:spring-plugin-core:jar:2.0.0.RELEASE:compile
[INFO] |  \- org.springframework.plugin:spring-plugin-metadata:jar:2.0.0.RELEASE:compile
[INFO] +- io.springfox:springfox-bean-validators:jar:3.0.0:compile
[INFO] |  \- io.springfox:springfox-spring-web:jar:3.0.0:compile
[INFO] |     \- io.github.classgraph:classgraph:jar:4.8.83:compile
[INFO] +- org.springframework.boot:spring-boot-starter-test:jar:2.3.7.RELEASE:test
[INFO] |  +- org.springframework.boot:spring-boot-test:jar:2.3.7.RELEASE:test
[INFO] |  +- org.springframework.boot:spring-boot-test-autoconfigure:jar:2.3.7.RELEASE:test
[INFO] |  +- com.jayway.jsonpath:json-path:jar:2.4.0:test
[INFO] |  |  \- net.minidev:json-smart:jar:2.3:test
[INFO] |  |     \- net.minidev:accessors-smart:jar:1.2:test
[INFO] |  |        \- org.ow2.asm:asm:jar:5.0.4:test
[INFO] |  +- org.assertj:assertj-core:jar:3.16.1:test
[INFO] |  +- org.hamcrest:hamcrest:jar:2.2:test
[INFO] |  +- org.junit.jupiter:junit-jupiter:jar:5.6.3:test
[INFO] |  |  +- org.junit.jupiter:junit-jupiter-params:jar:5.6.3:test
[INFO] |  |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.6.3:test
[INFO] |  +- org.junit.vintage:junit-vintage-engine:jar:5.6.3:test
[INFO] |  |  +- org.apiguardian:apiguardian-api:jar:1.1.0:test
[INFO] |  |  +- org.junit.platform:junit-platform-engine:jar:1.6.3:test
[INFO] |  |  \- junit:junit:jar:4.13.1:test
[INFO] |  +- org.mockito:mockito-core:jar:3.3.3:test
[INFO] |  |  +- net.bytebuddy:byte-buddy:jar:1.10.18:compile
[INFO] |  |  +- net.bytebuddy:byte-buddy-agent:jar:1.10.18:test
[INFO] |  |  \- org.objenesis:objenesis:jar:2.6:test
[INFO] |  +- org.mockito:mockito-junit-jupiter:jar:3.3.3:test
[INFO] |  +- org.skyscreamer:jsonassert:jar:1.5.0:test
[INFO] |  |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test
[INFO] |  +- org.springframework:spring-core:jar:5.2.12.RELEASE:compile
[INFO] |  |  \- org.springframework:spring-jcl:jar:5.2.12.RELEASE:compile
[INFO] |  +- org.springframework:spring-test:jar:5.2.12.RELEASE:test
[INFO] |  \- org.xmlunit:xmlunit-core:jar:2.7.0:test
[INFO] +- io.rest-assured:rest-assured:jar:3.3.0:test
[INFO] |  +- org.codehaus.groovy:groovy:jar:2.5.14:test
[INFO] |  +- org.codehaus.groovy:groovy-xml:jar:2.5.14:test
[INFO] |  +- org.apache.httpcomponents:httpclient:jar:4.5.13:compile
[INFO] |  |  +- org.apache.httpcomponents:httpcore:jar:4.4.14:compile
[INFO] |  |  \- commons-codec:commons-codec:jar:1.14:compile
[INFO] |  +- org.apache.httpcomponents:httpmime:jar:4.5.13:test
[INFO] |  +- org.hamcrest:hamcrest-core:jar:2.2:test
[INFO] |  +- org.ccil.cowan.tagsoup:tagsoup:jar:1.2.1:test
[INFO] |  +- io.rest-assured:json-path:jar:3.3.0:test
[INFO] |  |  +- org.codehaus.groovy:groovy-json:jar:2.5.14:test
[INFO] |  |  \- io.rest-assured:rest-assured-common:jar:3.3.0:test
[INFO] |  \- io.rest-assured:xml-path:jar:3.3.0:test
[INFO] |     +- org.apache.commons:commons-lang3:jar:3.10:runtime
[INFO] |     +- javax.xml.bind:jaxb-api:jar:2.3.1:test
[INFO] |     |  \- javax.activation:javax.activation-api:jar:1.2.0:test
[INFO] |     +- com.sun.xml.bind:jaxb-osgi:jar:2.2.10:test
[INFO] |     \- org.apache.sling:org.apache.sling.javax.activation:jar:0.1.0:test
[INFO] |        \- javax.activation:activation:jar:1.1.1:test
[INFO] +- org.springframework.cloud:spring-cloud-starter-contract-stub-runner:jar:2.2.4.RELEASE:test
[INFO] |  +- org.springframework.cloud:spring-cloud-contract-stub-runner:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-verifier:jar:2.2.4.RELEASE:test
[INFO] |  |  |  +- javax.inject:javax.inject:jar:1:test
[INFO] |  |  |  +- com.toomuchcoding.jsonassert:jsonassert:jar:0.4.14:test
[INFO] |  |  |  +- com.rackspace.eclipse.webtools.sourceediting:org.eclipse.wst.xml.xpath2.processor:jar:2.1.100:test
[INFO] |  |  |  |  +- edu.princeton.cup:java-cup:jar:10k:test
[INFO] |  |  |  |  \- com.ibm.icu:icu4j:jar:4.6:test
[INFO] |  |  |  +- org.codehaus.groovy:groovy-nio:jar:2.5.14:test
[INFO] |  |  |  +- com.github.jknack:handlebars:jar:4.1.2:test
[INFO] |  |  |  +- commons-beanutils:commons-beanutils:jar:1.9.4:test
[INFO] |  |  |  |  +- commons-logging:commons-logging:jar:1.2:test
[INFO] |  |  |  |  \- commons-collections:commons-collections:jar:3.2.2:test
[INFO] |  |  |  +- com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:jar:2.11.3:test
[INFO] |  |  |  \- org.springframework.cloud:spring-cloud-function-compiler:jar:3.0.9.RELEASE:test
[INFO] |  |  |     +- io.projectreactor:reactor-core:jar:3.3.12.RELEASE:test
[INFO] |  |  |     |  \- org.reactivestreams:reactive-streams:jar:1.0.3:test
[INFO] |  |  |     +- org.eclipse.jdt.core.compiler:ecj:jar:4.4.2:test
[INFO] |  |  |     +- org.springframework.cloud:spring-cloud-function-core:jar:3.0.9.RELEASE:test
[INFO] |  |  |     \- javax.annotation:javax.annotation-api:jar:1.3.2:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-shade:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-converters:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.springframework.cloud:spring-cloud-contract-spec:jar:2.2.4.RELEASE:test
[INFO] |  |  |  +- org.springframework.cloud:spring-cloud-contract-spec-java:jar:2.2.4.RELEASE:test
[INFO] |  |  |  |  +- dk.brics.automaton:automaton:jar:1.11-8:test
[INFO] |  |  |  |  \- org.apache.commons:commons-text:jar:1.7:test
[INFO] |  |  |  \- org.springframework.cloud:spring-cloud-contract-spec-groovy:jar:2.2.4.RELEASE:test
[INFO] |  |  +- org.eclipse.jgit:org.eclipse.jgit:jar:5.1.3.201810200350-r:test
[INFO] |  |  |  +- com.jcraft:jsch:jar:0.1.54:test
[INFO] |  |  |  +- com.jcraft:jzlib:jar:1.1.1:test
[INFO] |  |  |  \- com.googlecode.javaewah:JavaEWAH:jar:1.1.6:test
[INFO] |  |  +- com.jcraft:jsch.agentproxy.sshagent:jar:0.0.9:test
[INFO] |  |  |  \- com.jcraft:jsch.agentproxy.core:jar:0.0.9:test
[INFO] |  |  +- com.jcraft:jsch.agentproxy.jsch:jar:0.0.9:test
[INFO] |  |  \- com.jcraft:jsch.agentproxy.usocket-jna:jar:0.0.9:test
[INFO] |  |     +- net.java.dev.jna:jna:jar:4.1.0:test
[INFO] |  |     \- net.java.dev.jna:jna-platform:jar:4.1.0:test
[INFO] |  +- org.springframework.cloud:spring-cloud-contract-wiremock:jar:2.2.4.RELEASE:test
[INFO] |  |  \- com.github.tomakehurst:wiremock-jre8-standalone:jar:2.26.2:test
[INFO] |  \- org.apache.maven.resolver:maven-resolver-api:jar:1.3.3:test
[INFO] +- org.hamcrest:hamcrest-library:jar:2.2:test
[INFO] +- commons-io:commons-io:jar:2.6:compile
[INFO] +- org.springframework.security:spring-security-test:jar:5.3.6.RELEASE:test
[INFO] |  \- org.springframework.security:spring-security-core:jar:5.3.6.RELEASE:compile
[INFO] +- org.springframework.kafka:spring-kafka-test:jar:2.5.10.RELEASE:test
[INFO] |  +- org.apache.kafka:kafka-clients:jar:test:2.5.1:test
[INFO] |  +- org.apache.kafka:kafka-streams:jar:2.5.1:test
[INFO] |  |  +- org.apache.kafka:connect-json:jar:2.5.1:test
[INFO] |  |  |  \- org.apache.kafka:connect-api:jar:2.5.1:test
[INFO] |  |  \- org.rocksdb:rocksdbjni:jar:5.18.3:test
[INFO] |  +- org.apache.kafka:kafka-streams-test-utils:jar:2.5.1:test
[INFO] |  +- org.apache.kafka:kafka_2.12:jar:2.5.1:test
[INFO] |  |  +- com.fasterxml.jackson.module:jackson-module-scala_2.12:jar:2.11.3:test
[INFO] |  |  |  \- com.fasterxml.jackson.module:jackson-module-paranamer:jar:2.11.3:test
[INFO] |  |  |     \- com.thoughtworks.paranamer:paranamer:jar:2.8:test
[INFO] |  |  +- com.fasterxml.jackson.dataformat:jackson-dataformat-csv:jar:2.11.3:test
[INFO] |  |  +- net.sf.jopt-simple:jopt-simple:jar:5.0.4:test
[INFO] |  |  +- com.yammer.metrics:metrics-core:jar:2.2.0:test
[INFO] |  |  +- org.scala-lang.modules:scala-collection-compat_2.12:jar:2.1.3:test
[INFO] |  |  +- org.scala-lang.modules:scala-java8-compat_2.12:jar:0.9.0:test
[INFO] |  |  +- com.typesafe.scala-logging:scala-logging_2.12:jar:3.9.2:test
[INFO] |  |  +- org.apache.zookeeper:zookeeper:jar:3.5.8:test
[INFO] |  |  |  +- org.apache.zookeeper:zookeeper-jute:jar:3.5.8:test
[INFO] |  |  |  +- org.apache.yetus:audience-annotations:jar:0.5.0:test
[INFO] |  |  |  +- io.netty:netty-handler:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-common:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-resolver:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-buffer:jar:4.1.55.Final:test
[INFO] |  |  |  |  +- io.netty:netty-transport:jar:4.1.55.Final:test
[INFO] |  |  |  |  \- io.netty:netty-codec:jar:4.1.55.Final:test
[INFO] |  |  |  \- io.netty:netty-transport-native-epoll:jar:4.1.55.Final:test
[INFO] |  |  |     \- io.netty:netty-transport-native-unix-common:jar:4.1.55.Final:test
[INFO] |  |  \- commons-cli:commons-cli:jar:1.4:test
[INFO] |  +- org.apache.kafka:kafka_2.12:jar:test:2.5.1:test
[INFO] |  +- org.scala-lang:scala-library:jar:2.12.11:test
[INFO] |  +- org.scala-lang:scala-reflect:jar:2.12.11:test
[INFO] |  \- org.junit.jupiter:junit-jupiter-api:jar:5.6.3:test
[INFO] |     +- org.opentest4j:opentest4j:jar:1.2.0:test
[INFO] |     \- org.junit.platform:junit-platform-commons:jar:1.6.3:test
[INFO] +- com.illumina.prs.common.security:common-userservices-client-spring-boot2-starter:jar:3.7.2:compile
[INFO] |  +- com.illumina.prs.common.security:common-userservices-client-spring-boot2-autoconfigure:jar:3.7.2:compile
[INFO] |  +- com.illumina.prs.common.security:common-user-service:jar:3.7.2:compile
[INFO] |  |  +- com.illumina.prs.common.security:platform-auth-api-client:jar:3.7.2:compile
[INFO] |  |  +- com.illumina.prs.common.security:common-utils:jar:3.7.2:compile
[INFO] |  |  \- com.auth0:java-jwt:jar:3.5.0:compile
[INFO] |  +- com.illumina.prs.common.security:feature-flag-utils:jar:3.7.2:compile
[INFO] |  \- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compile
[INFO] |     +- com.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compile
[INFO] |     \- com.fasterxml.jackson.core:jackson-core:jar:2.11.3:compile
[INFO] +- jakarta.xml.bind:jakarta.xml.bind-api:jar:2.3.3:compile
[INFO] |  \- jakarta.activation:jakarta.activation-api:jar:1.2.2:compile
[INFO] +- org.springframework.boot:spring-boot-starter-data-jpa:jar:2.3.7.RELEASE:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-aop:jar:2.3.7.RELEASE:compile
[INFO] |  |  \- org.aspectj:aspectjweaver:jar:1.9.6:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-jdbc:jar:2.3.7.RELEASE:compile
[INFO] |  |  +- com.zaxxer:HikariCP:jar:3.4.5:compile
[INFO] |  |  \- org.springframework:spring-jdbc:jar:5.2.12.RELEASE:compile
[INFO] |  +- jakarta.transaction:jakarta.transaction-api:jar:1.3.3:compile
[INFO] |  +- jakarta.persistence:jakarta.persistence-api:jar:2.2.3:compile
[INFO] |  +- org.hibernate:hibernate-core:jar:5.4.25.Final:compile
[INFO] |  |  +- org.javassist:javassist:jar:3.27.0-GA:compile
[INFO] |  |  +- antlr:antlr:jar:2.7.7:compile
[INFO] |  |  +- org.jboss:jandex:jar:2.1.3.Final:compile
[INFO] |  |  +- org.dom4j:dom4j:jar:2.1.3:compile
[INFO] |  |  +- org.hibernate.common:hibernate-commons-annotations:jar:5.1.2.Final:compile
[INFO] |  |  \- org.glassfish.jaxb:jaxb-runtime:jar:2.3.3:compile
[INFO] |  |     +- org.glassfish.jaxb:txw2:jar:2.3.3:compile
[INFO] |  |     +- com.sun.istack:istack-commons-runtime:jar:3.0.11:compile
[INFO] |  |     \- com.sun.activation:jakarta.activation:jar:1.2.2:runtime
[INFO] |  +- org.springframework.data:spring-data-jpa:jar:2.3.6.RELEASE:compile
[INFO] |  |  +- org.springframework.data:spring-data-commons:jar:2.3.6.RELEASE:compile
[INFO] |  |  \- org.springframework:spring-orm:jar:5.2.12.RELEASE:compile
[INFO] |  \- org.springframework:spring-aspects:jar:5.2.12.RELEASE:compile
[INFO] +- org.flywaydb:flyway-core:jar:6.4.4:compile
[INFO] +- org.postgresql:postgresql:jar:42.2.18:runtime
[INFO] +- org.hsqldb:hsqldb:jar:2.5.1:runtime
[INFO] \- io.temporal:temporal-sdk:jar:1.0.2:compile
[INFO]    +- io.temporal:temporal-serviceclient:jar:1.0.2:compile
[INFO]    |  +- io.grpc:grpc-protobuf:jar:1.30.2:compile
[INFO]    |  |  +- io.grpc:grpc-api:jar:1.30.2:compile
[INFO]    |  |  |  \- io.grpc:grpc-context:jar:1.30.2:compile
[INFO]    |  |  +- com.google.protobuf:protobuf-java:jar:3.12.2:compile
[INFO]    |  |  +- com.google.api.grpc:proto-google-common-protos:jar:1.18.0:compile
[INFO]    |  |  +- io.grpc:grpc-protobuf-lite:jar:1.30.2:compile
[INFO]    |  |  \- org.codehaus.mojo:animal-sniffer-annotations:jar:1.18:runtime
[INFO]    |  +- io.grpc:grpc-stub:jar:1.30.2:compile
[INFO]    |  +- io.grpc:grpc-core:jar:1.30.2:compile
[INFO]    |  |  +- com.google.android:annotations:jar:4.1.1.4:runtime
[INFO]    |  |  \- io.perfmark:perfmark-api:jar:0.19.0:runtime
[INFO]    |  +- com.google.protobuf:protobuf-java-util:jar:3.12.2:compile
[INFO]    |  +- com.uber.m3:tally-core:jar:0.6.1:compile
[INFO]    |  \- io.grpc:grpc-netty-shaded:jar:1.30.2:runtime
[INFO]    +- com.google.code.gson:gson:jar:2.8.6:compile
[INFO]    +- com.google.guava:guava:jar:29.0-jre:compile
[INFO]    |  +- com.google.guava:failureaccess:jar:1.0.1:compile
[INFO]    |  +- com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile
[INFO]    |  +- com.google.code.findbugs:jsr305:jar:3.0.2:compile
[INFO]    |  \- com.google.j2objc:j2objc-annotations:jar:1.3:compile
[INFO]    +- com.cronutils:cron-utils:jar:9.1.1:runtime
[INFO]    \- com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile



#### Comments (2)

<details>
<summary><strong>bhaskara-illumina</strong> commented on 2021-01-15 17:47:08.000 UTC</summary>



shows the diff between [1.0.2 and 1.0.3 ](https://github.com/temporalio/sdk-java/compare/v1.0.2...v1.0.3#diff-34494be07c33eef74f25da863192979140f27e3aa09c8ff465021b3753782412) where grpc-netty-shaded version is changed

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-25 06:16:27.000 UTC</summary>

It looks like your dependency tree for some reason is still using older version:
` [INFO] | - io.grpc:grpc-netty-shaded:jar:1.30.2:runtime`
Despite the fact that diff that you've posted above confirmed that you should be using `1.33.1` if you are on temporal `1.0.3`. You must be overriding netty-shadded version in your configuration somewhere.

We are trying to keep all grpc packages, including grpc-netty-shaded, up to date and will continue upgrading to the most recent versions released by Google. Currently master is on 1.35.0.

I'm going to close this issue as there is no code change that is required on our side, if you continue having issues please create a thread on our [community channel](https://community.temporal.io/).

</details>


---

<a id="259"></a>

### #259: Add WorkflowTest Rule

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/259 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-11-18 19:55:43.000 UTC (5y 1m ago) |
| **Updated** | 2021-01-04 22:25:19.000 UTC |
| **Closed** | 2021-01-04 22:25:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
WorkflowTestEnvironment requires setup and tear down as well as `globalTimeout` and `watchman` setup in each tested class to support troubleshooting.

**Describe the solution you'd like**
Create `@WorkflowTest` rule that would encapsulate all of these to simplify code.

**Additional context**
[HelloAsyncLambdaTest](https://github.com/temporalio/samples-java/blob/76713f24490a0cec2a0ead458f3c5a4a0a56bf83/src/test/java/io/temporal/samples/hello/HelloAsyncLambdaTest.java) that sets both timeout and watchman.

#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 02:05:24.000 UTC</summary>

We need to make test workflow environment that works with docker service.
There is a lot of setup code that we can simplify.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-04 22:25:14.000 UTC</summary>

Addressed as part of https://github.com/temporalio/sdk-java/pull/286

</details>


---

<a id="258"></a>

### #258: Add opentracing context propagator

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/258 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-11-18 17:34:32.000 UTC (5y 1m ago) |
| **Updated** | 2021-08-10 20:32:33.000 UTC |
| **Closed** | 2021-08-10 20:32:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

https://github.com/uber/cadence-java-client/pull/478

#### Comments (2)

<details>
<summary><strong>bowsersenior</strong> commented on 2020-11-18 18:03:36.000 UTC</summary>

Since opentracing is now part of [opentelemetry](https://opentelemetry.io), it would be great if you could check that the new context propagator will work with opentelemetry as well.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-04-06 23:27:47.000 UTC</summary>

This can be closed. It's addressed in https://github.com/temporalio/sdk-java/pull/418

</details>


---

<a id="200"></a>

### #200: Java SDK metrics don't work correctly with PrometheusRegistry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/200 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2020-08-26 15:00:46.000 UTC (5y 4m ago) |
| **Updated** | 2020-11-25 01:53:34.000 UTC |
| **Closed** | 2020-11-25 01:53:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
PrometheusMeterRegistry + MicrometerClientStatsReporter should successfully emit metrics to Prometheus.

## Actual Behavior
Metric Registration fails:
```
java.lang.IllegalArgumentException: Prometheus requires that all meters with the same name have the same set of tag keys. There is already an existing meter named 'temporal_request_latency_seconds' containing tag keys [Operation]. The meter you are attempting to register has keys [Namespace, Operation, TaskQueue, WorkflowType].
	at io.micrometer.prometheus.PrometheusMeterRegistry.lambda$applyToCollector$16(PrometheusMeterRegistry.java:419)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1932)
	at io.micrometer.prometheus.PrometheusMeterRegistry.applyToCollector(PrometheusMeterRegistry.java:403)
	at io.micrometer.prometheus.PrometheusMeterRegistry.newTimer(PrometheusMeterRegistry.java:197)
	at io.micrometer.core.instrument.MeterRegistry.lambda$timer$2(MeterRegistry.java:308)
	at io.micrometer.core.instrument.MeterRegistry.getOrCreateMeter(MeterRegistry.java:612)
	at io.micrometer.core.instrument.MeterRegistry.registerMeterIfNecessary(MeterRegistry.java:566)
	at io.micrometer.core.instrument.MeterRegistry.timer(MeterRegistry.java:306)
	at io.micrometer.core.instrument.Timer$Builder.register(Timer.java:539)
	at io.micrometer.core.instrument.MeterRegistry.timer(MeterRegistry.java:433)
	at io.temporal.common.reporter.MicrometerClientStatsReporter.reportTimer(MicrometerClientStatsReporter.java:69)
	at com.uber.m3.tally.TimerImpl.record(TimerImpl.java:55)
	at com.uber.m3.tally.TimerImpl.recordStopwatch(TimerImpl.java:69)
	at com.uber.m3.tally.Stopwatch.stop(Stopwatch.java:48)
	at io.temporal.internal.grpc.GrpcMetricsInterceptor$MetricsClientCall$1.onClose(GrpcMetricsInterceptor.java:126)
	at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:434)
	at io.grpc.internal.ClientCallImpl.access$500(ClientCallImpl.java:66)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:763)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:742)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:123)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:740)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.respondWorkflowTaskCompleted(WorkflowServiceGrpc.java:2673)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.lambda$sendReply$0(WorkflowWorker.java:369)
	at io.temporal.internal.common.GrpcRetryer.lambda$retry$0(GrpcRetryer.java:109)
	at io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:127)
	at io.temporal.internal.common.GrpcRetryer.retry(GrpcRetryer.java:106)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.sendReply(WorkflowWorker.java:362)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:313)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:275)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:835)
```


## Steps to Reproduce the Problem

 ```
 PrometheusMeterRegistry registry = new PrometheusMeterRegistry(prometheusConfig);
 StatsReporter reporter = new MicrometerClientStatsReporter(registry);
      Scope scope =
          new RootScopeBuilder()
              .reporter(reporter)
              .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));
      service =
          WorkflowServiceStubs.newInstance(
              WorkflowServiceStubsOptions.newBuilder()
                  .setTarget(target)
                  .setMetricsScope(scope)
                  .build());
```

## Specifications

  - Version: 0.29 SDK


#### Comments (2)

<details>
<summary><strong>kkcmadhu</strong> commented on 2020-08-27 05:00:54.000 UTC</summary>

thanks Manu, i was actually able to publish the metrics to another prometheus server which did not have any temporal related metrics reported already.
apart from the issue  that there is inconsistency in what tags are getting added by various components, i also see that the custom  tags are completely missing. more info here
https://community.temporal.io/t/attaching-custom-tags-workflow-metrics/526

</details>

<details>
<summary><strong>vitarb</strong> commented on 2020-09-22 06:40:11.000 UTC</summary>

@kkcmadhu

Prometheus requires each unique metric key to be always reported with the same set of tags.

Unfortunately our SDK does not respect this constraint and tries to maximize amount of useful data that it publishes. The price of this is that there are code paths that may lead to partially filled tags for some operations, which results in errors during metric publishing like the one that you see in the description.

While we don't have a proper fix yet, I can suggest a client-side work-around that may unblock you for now.
You could try adding default dummy values for common parameters in the root metric scope.

For example:
```
Scope scope = new RootScopeBuilder()
		.reporter(reporter)
		.tags(new HashMap<>() {
				{
					put(MetricsTag.NAMESPACE, environment.getNamespace());
					put(MetricsTag.ACTIVITY_TYPE, NONE);
					put(MetricsTag.OPERATION_NAME, NONE);
					put(MetricsTag.SIGNAL_NAME, NONE);
					put(MetricsTag.QUERY_TYPE, NONE);
					put(MetricsTag.TASK_QUEUE, NONE);
					put(MetricsTag.STATUS_CODE, NONE);
					put(MetricsTag.EXCEPTION, NONE);
					put(MetricsTag.WORKFLOW_TYPE, NONE);
				}
			})
		.reportEvery(com.uber.m3.util.Duration.ofSeconds(10));
}
```
This should result in something like this being published instead of the error mentioned above:
```
# TYPE temporal_request_latency_seconds_max gauge
temporal_request_latency_seconds_max{ActivityType="ExecuteRemoteTestStep",Namespace="java-bench",Operation="RespondActivityTaskCompleted",TaskQueue="temporal-bench",WorkflowType="config-driven-workflow",} 0.067643565
temporal_request_latency_seconds_max{ActivityType="RunDriver",Namespace="java-bench",Operation="RespondActivityTaskCompleted",TaskQueue="temporal-bench",WorkflowType="bench-driver",} 0.004640764
temporal_request_latency_seconds_max{ActivityType="None",Namespace="java-bench",Operation="ResetStickyTaskQueue",TaskQueue="None",WorkflowType="None",} 0.062871658
temporal_request_latency_seconds_max{ActivityType="None",Namespace="java-bench",Operation="StartWorkflowExecution",TaskQueue="temporal-bench",WorkflowType="config-driven-workflow",} 0.006228311
temporal_request_latency_seconds_max{ActivityType="None",Namespace="java-bench",Operation="RespondWorkflowTaskCompleted",TaskQueue="temporal-bench",WorkflowType="bench-driver",} 0.005130324
temporal_request_latency_seconds_max{ActivityType="RunDriver",Namespace="java-bench",Operation="RecordActivityTaskHeartbeat",TaskQueue="temporal-bench",WorkflowType="bench-driver",} 0.003844159
temporal_request_latency_seconds_max{ActivityType="RunMonitor",Namespace="java-bench",Operation="RecordActivityTaskHeartbeat",TaskQueue="temporal-bench",WorkflowType="bench-driver",} 0.003414754
temporal_request_latency_seconds_max{ActivityType="ExecuteRemoteTestStep",Namespace="java-bench",Operation="RecordActivityTaskHeartbeat",TaskQueue="temporal-bench",WorkflowType="config-driven-workflow",} 0.049534959
temporal_request_latency_seconds_max{ActivityType="None",Namespace="java-bench",Operation="RespondWorkflowTaskCompleted",TaskQueue="temporal-bench",WorkflowType="config-driven-workflow",} 0.073708412
temporal_request_latency_seconds_max{ActivityType="RunCleaner",Namespace="java-bench",Operation="RespondActivityTaskCompleted",TaskQueue="temporal-bench",WorkflowType="bench-driver",} 0.002968035
temporal_request_latency_seconds_max{ActivityType="RunMonitor",Namespace="java-bench",Operation="RespondActivityTaskCompleted",TaskQueue="temporal-bench",WorkflowType="bench-driver",} 0.003083715
temporal_request_latency_seconds_max{ActivityType="None",Namespace="java-bench",Operation="DescribeWorkflowExecution",TaskQueue="None",WorkflowType="None",} 0.010100332
temporal_request_latency_seconds_max{ActivityType="None",Namespace="java-bench",Operation="GetWorkflowExecutionHistory",TaskQueue="None",WorkflowType="None",} 0.011132755
```

Hope this helps you, meanwhile we'll be looking at our options for a better solution on the SDK side.


</details>


---

<a id="70"></a>

### #70: Add support for MaxConcurrentActivityExecutionSize for async activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/70 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-21 17:35:02.000 UTC (5y 8m ago) |
| **Updated** | 2021-01-04 18:50:55.000 UTC |
| **Closed** | 2021-01-04 18:50:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

Customer reported:

`We are noticing that .setMaxConcurrentWorkflowExecutionSize(2) and  .setMaxConcurrentActivityExecutionSize(2) on WorkerOptions don‚Äôt seem to work if we do asynchronous activity completion. Have you guys experienced this/have a good way around this? We use the async activity completion to be able to use Kotlin coroutines in parts of our code. I am trying to get some logs from the team that reported it, but wanted to see if you guys had seen something similar`

The proposed solution is to have a special API for async activity completion from the same process, which is different from the current API which was intended for completion from any process. This new API would perform counting correctly.

#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:24:32.000 UTC</summary>

Make sure that when we implement https://github.com/temporalio/sdk-java/issues/14 we obey the limit set here.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-04 18:50:54.000 UTC</summary>

Resolved in https://github.com/temporalio/sdk-java/pull/291

</details>


---

<a id="14"></a>

### #14: Simplify async activity implementation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/14 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-07 13:56:52.000 UTC (5y 11m ago) |
| **Updated** | 2021-01-04 18:51:48.000 UTC |
| **Closed** | 2021-01-04 18:51:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

To not tie up threads users requested support for activity implementations that return CompletableFuture. As we don't want to have Future in the activity API the strawman proposal is to add adapter methods that can be called from activity (similar to Async class from workflow package)

```
class ActivityAsync {
  public static <A1, R> R function(Functions.Func1<A1, CompletableFuture<R>> function, A1 arg1) { ... }
  // similar methods for procedures and argument counts
}
```
Then an activity implementation could look like:

```
String myActivity(String foo) {
   return ActivityAsync.function(myActivityReturningFuture, foo);
}

CompletableFuture<String> myActivityReturningFuture(String foo) {
   ...
}
```

where only `myActivity` method is part of the interface. Then a dynamic proxy adapter can be written to convert from a class that has methods that return ComletableFutures to the activity interface that returns values:

```
interface MyActivities {
   String foo();
   void bar();
}

@ActivitiesImplementation(implements=MyActivities.class)
class MyActivitiesImpl {
   CompletableFuture<String> foo();
   ComletableFuture<Void> bar();
}

```
Then the Worker would just accept `MyActivitiesImpl` instance and internally create the dynamic proxy.

#### Comments (2)

<details>
<summary><strong>mfateev</strong> commented on 2020-02-07 22:14:19.000 UTC</summary>

The same approach can be used for workflows implemented asynchronously with workflow implementation returning Promise.

</details>

<details>
<summary><strong>vitarb</strong> commented on 2021-01-04 18:51:47.000 UTC</summary>

Resolved in https://github.com/temporalio/sdk-java/pull/291
We now provide ability to get a completion client easily thus simplifying user experience.

</details>


---

<a id="2"></a>

### #2: Refactor ReplayWorkflowContext out of WorkflowThread

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2019-12-29 20:13:02.000 UTC (6 years ago) |
| **Updated** | 2021-08-15 22:34:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 2 |
| **Priority Score** | 2 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

There should be some sort of a generic interceptor that is invoked upon thread initialization instead of the hardcoded dependencies like:

https://github.com/uber/cadence-java-client/blob/cbe3706e2094e0abe4855b9afad1d58c86d7adfe/src/main/java/com/uber/cadence/internal/sync/WorkflowThreadImpl.java#L80

#### Comments (2)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:06:28.000 UTC</summary>

The question here is whether or not we can move this to interceptors. If no we need to have a design discussion and make interceptors powerful enough to support use cases like this.

</details>

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-15 22:34:12.000 UTC</summary>

Revisiting this issue after some work on interceptors had been done and class structure changed significantly.

We should refactor out MDC initialization logic from `WorkflowThreadImpl`: https://github.com/Spikhalskiy/java-sdk/blob/15ca5083059e0bb27ff44f03addce2ecdd554404/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowThreadImpl.java#L94
into a new Interceptor. Interceptors already allow intercepting creation of WorkflowThreads. If interceptors are lacking anything to support this, we can add the lacking functionality.

</details>


---

<a id="2753"></a>

### #2753: Unexpected Activity Timeout Behavior After Worker Crash & Need for CancellationScope Status Check

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2753 |
| **State** | CLOSED |
| **Author** | 40lsgy1 (40lsgy1) |
| **Created** | 2025-12-31 08:23:53.000 UTC (9 days ago) |
| **Updated** | 2026-01-08 16:44:52.000 UTC |
| **Closed** | 2026-01-08 16:44:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'm encountering an issue while using Temporal to build a DSL system. In my implementation, each Activity is wrapped in a CancellationScope to enable individual cancellation handling (with retry/skip options after cancellation). The CancellationType is set to WAIT_CANCELLATION_COMPLETED. I have two related problems:

1. Worker Crash During Activity Execution: I recently observed that if a worker crashes during an Activity's business logic execution and fails to recover within the StartToCloseTimeout period, the Activity does not retry its business logic after the worker recovers. According to the documentation, StartToCloseTimeout should only limit the duration of a single Activity attempt. My expectation is that after worker recovery, the Activity should retry (allowing cancellation cleanup logic to execute) rather than terminating due to timeout.

2. Detecting CancellationScope Status After Exit: My Activities nest CancellationScope within Async.procedure Promises. When a CanceledFailure occurs, the WAIT_CANCELLATION_COMPLETED policy ensures the Activity's logic completes successfully before exiting the scope. After exiting the CancellationScope, I need to execute state update logic (via other Activities). Is there a way to determine whether the CancellationScope was canceled immediately after exiting it? This would allow me to conditionally execute state updates using newDetachedCancellationScope.



#### Comments (1)

<details>
<summary><strong>maciejdudko</strong> commented on 2026-01-08 16:44:47.000 UTC</summary>

1. When an activity is requested to cancel, then it will not be retried anymore. This is by design. Activities are non-durable and there are no guarantees that any cleanup logic will execute in case of failure or worker crash. If the workflow needs to ensure cleanup is done, it needs to catch the activity failure and run the cleanup logic as a separate activity. One common way is the saga design pattern, where every activity is paired with a compensation activity that undoes its work and in case of failure, the workflow executes a list of compensations for all activities run up to this point. You can learn more about it from this blog post: https://temporal.io/blog/saga-pattern-made-easy You can also find more resources on sagas in [Temporal documentation](https://docs.temporal.io/evaluate/use-cases-design-patterns#saga).

2. If you still have a reference to the `CancellationScope`, you can call the `isCancelRequested` method to check if it was canceled even after it finishes running. However, this is not a perfect representation of whether the activities inside have completed successfully or not. It's always better to memorize the result of activity execution itself, e.g. by storing the potential exception in a variable and later checking if it's null or not.

If you have more questions or need assistance, always feel free to post on `#java-sdk` channel in [Temporal Community Slack](https://t.mp/slack). I will close this issue as there's nothing to be fixed here.

</details>


---

<a id="2737"></a>

### #2737: Returning custom RuntimeException from FailureConverter leads to stuck workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2737 |
| **State** | CLOSED |
| **Author** | djivko (Zhivko Donev) |
| **Created** | 2025-11-24 19:18:53.000 UTC (1 months ago) |
| **Updated** | 2025-11-25 02:55:02.000 UTC |
| **Closed** | 2025-11-25 02:55:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Description
I want to implement a custom FailureConverter which serializes custom application exception into ApplicationFailure and deserializes Failures back to the custom application exception. The goal is to make the temporal RPC communication transparent to the application logic and have better cross-language compatibility.  


## Expected Behavior
1. Activity throws exception -> FailureConverter.exceptionToFailure -> SDK internal logic and failure wrapping as needed -> Temporal Server
2. Temporal Server -> Worker processing -> FailureConverter.failureToException -> Workflow code
3. Workflow throws exception -> FailureConverter.exceptionToFailure -> SDK internal logic and failure wrapping as needed -> Temporal Server
4. Temporal Server -> Client processing -> FailureConverter.failureToException -> Client raises exception

## Actual Behavior
1 to 3 work as expected.
The control is never returned to the calling code and the workflow gets stuck in never ending loop

## Steps to Reproduce the Problem

Attaching a simple test file that reproduces the issue
[FailureConverterTest.java](https://github.com/user-attachments/files/23730477/FailureConverterTest.java)
## Specifications

  - Version: Java-SDK 1.32.0

Note: Prior to SDK 1.28 failureToException required to return TemporalFailure. However with the change of the signature to RuntimeException the expectation is that any runtime exception returned from that method are supported.

Note 2: GO-SDK seems to properly handle the same use case. There the result of failureToError method will be attached as the cause of either WorkflowExecutionError or ActivityFailureError and due to error unwrapping in GO you will be able to get the original error.

Note 3: The documentation about FailureConverter is really poor and there are literary 0 examples (in any language) about proper implementation of custom converter. The only external source I managed to find that touches on error handling with temporal was [this blog post](https://www.flightcontrol.dev/blog/temporal-error-handling-in-practice) which again stress out the lack of documentation and examples and instead implements custom logic with interceptors. 


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-11-25 02:55:02.000 UTC</summary>

Looking at your reproduction everything is operating correctly. Your custom `FailureConverter` is throwing a runtime exception inside a workflow which will cause a workflow task failure. If you want your exception to fail the workflow then you need to tell the SDK. 

example:
```
  @Rule
  public TestWorkflowRule testWorkflowRule =
      TestWorkflowRule.newBuilder()
          .setWorkflowTypes(
              WorkflowImplementationOptions.newBuilder()
                  .setFailWorkflowExceptionTypes(CustomException.class)
                  .build(),
              TestWorkflowImpl.class)
          .setDoNotStart(true)
          .setWorkflowClientOptions(
              WorkflowClientOptions.newBuilder()
                  .setDataConverter(
                      DefaultDataConverter.newDefaultInstance().withFailureConverter(new FC()))
                  .build())
          .build();
```

I will say this use of failure converter is not recommend or really supported. Per the SDK docs

```
   * <p>WARNING: Most users should _never_ need to override the default failure converter. To
   * encrypt the content of failures, see {@link CodecDataConverter} instead.
```

The intended use case of failure converters is to help with encryption of potentially sensitive data inside exceptions. I would recommend you stick with normal Temporal failures then trying to hack serialization.

>The goal is to make the temporal RPC communication transparent to the application logic and have better cross-language compatibility.

Temporal application failures are fully compatible across languages and the recommend error format to pass errors across Temporal. For more details on handling errors in Temporal I would recommend you take a look at our course https://temporal.io/blog/error-handling-strategy-free-hands-on-training 




</details>


---

<a id="2733"></a>

### #2733: activity_schedule_to_start_latency reports activity_type unexpectedly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2733 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-11-19 14:42:25.000 UTC (1 months ago) |
| **Updated** | 2025-12-08 19:53:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

How to repro - run the java sdk samples metrics sample: https://github.com/temporalio/samples-java/tree/main/core/src/main/java/io/temporal/samples/metrics

Sample starts only 2 activities, PerformA and PerformB. Metrics report activity_schedule_to_start_latency for 3 activities, PerformA, PerformB and "none" which is the default. 
Per docs this metric should not be reporting activity_type at all, but it is, and its also confusing why its reporting it for "none", I believe this is done on activity failure since in sample activities are being retried couple times. 

Request is to either fix activity_schedule_to_start_latency to always report activity_type (which would be pretty useful if possible) or to not report it at all, and leave task_queue as lowest granularity for this metric.

#### Comments (1)

<details>
<summary><strong>robzienert</strong> commented on 2025-12-08 19:53:06.000 UTC</summary>

The metric has always (as far as I can remember) reported `activity_type`, but now it reports `activity_type` _and_ also includes a `none` value for that tag, which is incorrect: There's no scenario where an activity schedule to start would not have an associated activity type (from a user perspective, not sure about the internals).

</details>


---

<a id="2728"></a>

### #2728: ScheduleRange to check end

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2728 |
| **State** | OPEN |
| **Author** | eye-dee (Igor) |
| **Created** | 2025-11-18 09:24:40.000 UTC (1 months ago) |
| **Updated** | 2025-11-25 02:55:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

```
  public ScheduleRange(int start, int end, int step) {
    Preconditions.checkState(start >= 0 && step >= 0 && step >= 0);
``` 

Why do we need to check step twice?

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-11-25 02:55:41.000 UTC</summary>

Yes that is a typo, feel free to open a PR to fix if you are inclined 

</details>


---

<a id="2687"></a>

### #2687: How to Register a Custom ContextPropagator for Multiple Temporal Namespaces in Spring Boot

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2687 |
| **State** | CLOSED |
| **Author** | sivakumarpalakurthi |
| **Created** | 2025-10-15 17:46:55.000 UTC (2 months ago) |
| **Updated** | 2025-10-16 14:22:51.000 UTC |
| **Closed** | 2025-10-16 14:22:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I am implementing a custom ContextPropagator named TenantIdContextPropagator to propagate MDC attributes such as tenant_id across the logs generated by Temporal workflows. My goal is to ensure that the tenant context flows seamlessly throughout the entire Temporal workflow execution.

To enable this propagation, I need to register my custom ContextPropagator with the WorkflowClientOptions so that the context is correctly applied in the workers.

My understanding is that the WorkflowClient instances used to create workers for workflows must be configured with this propagator to ensure the context is propagated properly.

I created a class implementing TemporalOptionsCustomizer<WorkflowClientOptions.Builder> and overridden the customize method to include my custom ContextPropagator. This approach works correctly with default namespace.

However, my Spring Boot application is configured with three different namespaces using the Temporal Spring Boot autoconfiguration via application.yaml. I am unsure how to register the custom ContextPropagator across all these namespaces in this multi-namespace setup.

Could you please advise on the best approach to register my custom ContextPropagator for all configured namespaces in a Spring Boot application?
BTW, I was referring to this https://docs.temporal.io/develop/java/spring-boot-integration#customize-options
Thanks in advance.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-10-16 14:22:51.000 UTC</summary>

You can configure a different [customizer](https://github.com/temporalio/sdk-java/tree/master/temporal-spring-boot-autoconfigure#customization) per namespace. So in your customizer you can set a `ContextPropagator`

</details>


---

<a id="2674"></a>

### #2674: TestEnvironment with external service - failing tests throws IllegalStateException errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2674 |
| **State** | OPEN |
| **Author** | gauravthadani (Gaurav Thadani) |
| **Created** | 2025-09-29 00:19:01.000 UTC (3 months ago) |
| **Updated** | 2025-10-01 15:19:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description


TestWorkflowExtension throws diagnostics error when
- using `useExternalService`
- and tests Fail

https://github.com/temporalio/sdk-java/blob/master/temporal-testing/src/main/java/io/temporal/testing/TestWorkflowEnvironmentInternal.java#L262

## Expected Behavior

```

Failed tests
.
.
.

```


## Actual Behavior

```
java.lang.IllegalStateException: getDiagnostics is not supported with the external service
	at com.google.common.base.Preconditions.checkState(Preconditions.java:512)
```

## Steps to Reproduce the Problem

```
class SampleTest {

  @RegisterExtension
  public static final TestWorkflowExtension workflowExtension =
      TestWorkflowExtension.newBuilder().setDoNotStart(true).useExternalService().build();

  @Test
  void sampleTest(TestWorkflowEnvironment environment) {
    Assert.assertEquals(1, 2);
  }
}
```

## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>maciejdudko</strong> commented on 2025-10-01 15:19:54.000 UTC</summary>

Hi @gauravthadani, thank you for opening this issue. We'll discuss it on our next triage meeting.

Reactions: üëç 1

</details>


---

<a id="2670"></a>

### #2670: TestWorkflowEnvironment#sleep hangs indefinitely

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2670 |
| **State** | OPEN |
| **Author** | rpost (Radek Posto≈Çowicz) |
| **Created** | 2025-09-25 11:42:26.000 UTC (3 months ago) |
| **Updated** | 2025-09-29 08:11:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior

Under certain execution path `io.temporal.testing.TestWorkflowEnvironment#sleep` hangs indefinitely. 

## Steps to Reproduce the Problem

Please have a look at https://github.com/rpost/temporal-java-sdk-bug-2670/blob/main/src/test/java/com/example/temporalsleepbug/TemporalSleepBugApplicationTests.java

Execution stops at https://github.com/rpost/temporal-java-sdk-bug-2670/blob/main/src/test/java/com/example/temporalsleepbug/TemporalSleepBugApplicationTests.java#L52 and never finishes.

Thread dump shows:

```
"main" #1 [1711914] prio=5 os_prio=0 cpu=2324,38ms elapsed=23,31s tid=0x00007cac5c033e30 nid=1711914 waiting on condition  [0x00007cac60512000]
   java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@21.0.7/Native Method)
	- parking to wait for  <0x00000002b9220bc8> (a io.grpc.stub.ClientCalls$ThreadlessExecutor)
	at java.util.concurrent.locks.LockSupport.park(java.base@21.0.7/LockSupport.java:221)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:717)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:159)
	at io.temporal.api.testservice.v1.TestServiceGrpc$TestServiceBlockingStub.unlockTimeSkippingWithSleep(TestServiceGrpc.java:586)
	at io.temporal.testing.TestWorkflowEnvironmentInternal.sleep(TestWorkflowEnvironmentInternal.java:165)
	at com.example.temporalsleepbug.TemporalSleepBugApplicationTests.shouldExecuteWorkflow(TemporalSleepBugApplicationTests.java:52)
	at java.lang.invoke.LambdaForm$DMH/0x00007cabc8170800.invokeVirtual(java.base@21.0.7/LambdaForm$DMH)
	at java.lang.invoke.LambdaForm$MH/0x00007cabc86b8000.invoke(java.base@21.0.7/LambdaForm$MH)
	at java.lang.invoke.Invokers$Holder.invokeExact_MT(java.base@21.0.7/Invokers$Holder)
	at jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(java.base@21.0.7/DirectMethodHandleAccessor.java:153)
	at jdk.internal.reflect.DirectMethodHandleAccessor.invoke(java.base@21.0.7/DirectMethodHandleAccessor.java:103)
	at java.lang.reflect.Method.invoke(java.base@21.0.7/Method.java:580)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:775)
	....
```

```
"workflow-method-SubscriberTerminationWorkflow-1234-84b7b4fc-bea0-42f3-a168-fb8ebac7c408" #71 [1712086] prio=5 os_prio=0 cpu=4,69ms elapsed=20,45s tid=0x00007caaf80059f0 nid=1712086 waiting on condition  [0x00007cac14629000]
   java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@21.0.7/Native Method)
	- parking to wait for  <0x00000007ffd017e8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(java.base@21.0.7/LockSupport.java:371)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(java.base@21.0.7/AbstractQueuedSynchronizer.java:519)
	at java.util.concurrent.ForkJoinPool.unmanagedBlock(java.base@21.0.7/ForkJoinPool.java:3780)
	at java.util.concurrent.ForkJoinPool.managedBlock(java.base@21.0.7/ForkJoinPool.java:3725)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(java.base@21.0.7/AbstractQueuedSynchronizer.java:1712)
	at io.temporal.internal.sync.WorkflowThreadScheduler.yieldLocked(WorkflowThreadScheduler.java:37)
	at io.temporal.internal.sync.WorkflowThreadContext.yield(WorkflowThreadContext.java:70)
	at io.temporal.internal.sync.WorkflowThreadImpl.yield(WorkflowThreadImpl.java:378)
	at io.temporal.internal.sync.WorkflowThread.await(WorkflowThread.java:27)
	at io.temporal.internal.sync.SyncWorkflowContext.await(SyncWorkflowContext.java:1290)
	at io.temporal.internal.sync.WorkflowInternal.await(WorkflowInternal.java:510)
	at io.temporal.workflow.Workflow.await(Workflow.java:611)
	at com.example.temporalsleepbug.SubscriberTerminationWorkflow$SubscriberTerminationWorkflowImpl.execute(SubscriberTerminationWorkflow.java:25)
	at java.lang.invoke.LambdaForm$DMH/0x00007cabc8778000.invokeInterface(java.base@21.0.7/LambdaForm$DMH)
	at java.lang.invoke.LambdaForm$MH/0x00007cabc8778c00.invoke(java.base@21.0.7/LambdaForm$MH)
	at java.lang.invoke.Invokers$Holder.invokeExact_MT(java.base@21.0.7/Invokers$Holder)
	at jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(java.base@21.0.7/DirectMethodHandleAccessor.java:154)
	at jdk.internal.reflect.DirectMethodHandleAccessor.invoke(java.base@21.0.7/DirectMethodHandleAccessor.java:103)
	at java.lang.reflect.Method.invoke(java.base@21.0.7/Method.java:580)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.execute(POJOWorkflowImplementationFactory.java:406)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:354)
	at io.temporal.internal.sync.WorkflowExecutionHandler.runWorkflowMethod(WorkflowExecutionHandler.java:51)
	at io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:122)
	at io.temporal.internal.sync.SyncWorkflow$$Lambda/0x00007cabc8743860.run(Unknown Source)
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:99)
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:92)
	at io.temporal.worker.ActiveThreadReportingExecutor.lambda$submit$0(ActiveThreadReportingExecutor.java:34)
	at io.temporal.worker.ActiveThreadReportingExecutor$$Lambda/0x00007cabc8741dc0.run(Unknown Source)
	at java.util.concurrent.Executors$RunnableAdapter.call(java.base@21.0.7/Executors.java:572)
	at java.util.concurrent.FutureTask.run$$$capture(java.base@21.0.7/FutureTask.java:317)
	at java.util.concurrent.FutureTask.run(java.base@21.0.7/FutureTask.java)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@21.0.7/ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@21.0.7/ThreadPoolExecutor.java:642)
	at java.lang.Thread.runWith(java.base@21.0.7/Thread.java:1596)
	at java.lang.Thread.run(java.base@21.0.7/Thread.java:1583)
```


```
"grpc-default-executor-5" #63 [1712078] daemon prio=5 os_prio=0 cpu=134,75ms elapsed=20,72s tid=0x00007cac5fec8ce0 nid=1712078 waiting on condition  [0x00007cac14e2a000]
   java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@21.0.7/Native Method)
	- parking to wait for  <0x00000002b9358e08> (a java.util.concurrent.CompletableFuture$Signaller)
	at java.util.concurrent.locks.LockSupport.park(java.base@21.0.7/LockSupport.java:221)
	at java.util.concurrent.CompletableFuture$Signaller.block(java.base@21.0.7/CompletableFuture.java:1864)
	at java.util.concurrent.ForkJoinPool.unmanagedBlock(java.base@21.0.7/ForkJoinPool.java:3780)
	at java.util.concurrent.ForkJoinPool.managedBlock(java.base@21.0.7/ForkJoinPool.java:3725)
	at java.util.concurrent.CompletableFuture.waitingGet(java.base@21.0.7/CompletableFuture.java:1898)
	at java.util.concurrent.CompletableFuture.get(java.base@21.0.7/CompletableFuture.java:2072)
	at io.temporal.internal.testservice.TestService.unlockTimeSkippingWhileSleep(TestService.java:126)
	at io.temporal.internal.testservice.TestService.unlockTimeSkippingWithSleep(TestService.java:95)
	at io.temporal.api.testservice.v1.TestServiceGrpc$MethodHandlers.invoke(TestServiceGrpc.java:747)
	at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
	at io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)
	at io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)
	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:351)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:860)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@21.0.7/ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@21.0.7/ThreadPoolExecutor.java:642)
	at java.lang.Thread.runWith(java.base@21.0.7/Thread.java:1596)
	at java.lang.Thread.run(java.base@21.0.7/Thread.java:1583)
```


What is interesting is when I comment:

```java
        CreateCustomerWorkflow createCustomerWorkflow = workflowClient.newWorkflowStub(
                CreateCustomerWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setWorkflowId(CreateCustomerWorkflow.class.getSimpleName() + "-" + 1234L)
                        .setTaskQueue(TemporalSleepBugApplication.TASK_QUEUE)
                        .build()
        );
        WorkflowClient.execute(createCustomerWorkflow::execute, 1234L);

        Thread.sleep(5000); // let previous workflow complete
```

out and leave only `SubscriberTerminationWorkflow` in test then everything runs fine, without deadlocks.

## Specifications

  - Version: 1.31.0
  - Platform: n/a


#### Comments (1)

<details>
<summary><strong>oleg-kovrizhin-paradym</strong> commented on 2025-09-29 08:11:43.000 UTC</summary>

Looks like the same issue: https://github.com/temporalio/sdk-java/issues/2642

</details>


---

<a id="2638"></a>

### #2638: Spring Boot: Allow multiple TemporalOptionsCustomizer per namespace ordered by Springboot convention 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2638 |
| **State** | CLOSED |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2025-08-25 16:52:48.000 UTC (4 months ago) |
| **Updated** | 2025-09-23 16:50:28.000 UTC |
| **Closed** | 2025-09-23 16:50:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

It's great that the Spring starter exists, but it has deviated from standard Spring autoconfiguration practices that make it more difficult to extend and use in an enterprise setting.

There are two major areas of non-standard behaviors that come immediately to mind:

1. Using bean names to resolve `TemporalOptionsCustomizer<T>` implementations for root / non-root namespaces. This is against Spring conventions, which would normally encourage using an annotation or interface method for filtered selection.
2. Related, forcing a single `TemporalOptionsCustomizer<T>` per-namespace, and not allowing use of Spring bean precedence or ordering semantics.

Some concrete examples of how this manifests:

At Netflix, we have our own Spring Boot Netflix library suite that extends Spring Boot for our purposes, often customizing behavior of upstream starters and libraries as well as our own. Similarly, we have a Netflix Temporal starter that everyone in Netflix uses. It handles stuff like wiring up the SDK with our tracing, metrics, and configuring mTLS for our clients on behalf of our users.

Due to the first issue, we needed to write a `BeanPostProcessor` that iterates `TemporalProperties` to register bean definitions implementing `TemporalOptionsCustomizer<WorkflowServiceOptions.Builder>` to use our custom `SslContext` implementation such that every root and non-root namespace is able to connect to our proxy.

Due to the second issue, if we wanted to say - for example - customize the `SpanBuilderProvider` from `temporal-opentracing` to fix #2117, we'd implement `TemporalOptionsCustomizer<WorkerClientOptions.Builder>` and `TemporalOptionsCustomizer<WorkerFactoryOptions.Builder>` to first remove the `OpenTracingInterceptor` provided by the SDK and replace it with one using our custom `SpanBuilderProvider`. Because the starter forces 1 customizer per-namespace, it would take away the freedom from our users to customize either of these options builders. Though, due to how `AutoConfigurationUtils.chooseTemporalCustomizerBean` is implemented, there's no guarantee that the platform-provided customizer would even be chosen because it doesn't respect Spring bean precedence nor ordering, so if one of our users were to implement either interface, there is a random chance their customizer would be applied or ours. Because bean precedence is not respected, creating a composite customizer with `@Primary` is also not possible.

I haven't reviewed the rest of the starter very closely, but a spot-check does show the same issue also exists with `DataConverter` selection as well.


**Describe the solution you'd like**

The starter should approach integrating with Spring in a more standard/idiomatic Spring way. 

A couple suggestions:

1. `TemporalOptionsCustomizer<T>` could add a new filter method to provide what namespace(s) it pertains to (read: supporting individual or global customizers).
2. Always accept `List<TemporalOptionsCustomizer<T>>` and if there are more than 1 after filtering, apply them in order, rather than `findFirst` on a map that leads to non-determinstic configuration and loss of desired configuration.

**Describe alternatives you've considered**

1. Implement concrete singletons of `TemporalOptionsCustomizer<T>` for each `T`, and introduce a new interface for our users to implement. We'd need to add some validation to assert no one else implements this interface. Discarded as we already have users who implement `TOC<T>`, and its an unobvious contract.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-09-08 22:18:43.000 UTC</summary>

Note, since there are a couple great suggestions here pulling them out into a [separate issue](https://github.com/temporalio/sdk-java/issues/2656) so each issue can focus on a concrete deliverable 

</details>


---

<a id="2611"></a>

### #2611: Spring Boot Autoconfigure README link invalid

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2611 |
| **State** | CLOSED |
| **Author** | C-Deck (Clint Decker) |
| **Created** | 2025-08-06 17:13:08.000 UTC (5 months ago) |
| **Updated** | 2025-08-08 05:29:40.000 UTC |
| **Closed** | 2025-08-08 05:29:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The `README` properly points to a correct manual. 

## Actual Behavior
Linked manual does not exist and URL redirects to another page.

## Steps to Reproduce the Problem

  1. Go to Spring Boot Autoconfigure [Metrics](https://github.com/temporalio/sdk-java/blob/master/temporal-spring-boot-autoconfigure/README.md#metrics)
  2. Follow the link in the section.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-08-08 05:29:39.000 UTC</summary>

We are going to be removing the documentation in the readme and adding it to our main docs https://docs.temporal.io/ so we will address that there

</details>


---

<a id="2608"></a>

### #2608: NonRootBeanPostProcessor causes meter-registry eager init

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2608 |
| **State** | CLOSED |
| **Author** | bikeholik (krzysztof) |
| **Created** | 2025-07-30 14:42:41.000 UTC (5 months ago) |
| **Updated** | 2025-07-30 15:55:50.000 UTC |
| **Closed** | 2025-07-30 15:55:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
meter-registry should have all customizers applied

## Actual Behavior
customizers are not applied as NonRootBeanPostProcessor requests meter-registry from application context at bean-post-processor creation stage

## Steps to Reproduce the Problem

  1. Create a meter-registry-customer, e.g. adding tags:
```
@Configuration
public class CustomMetricsConfiguration {

  @Value("${spring.application.name}")
  private String applicationName;

  @Bean
  public <T extends MeterRegistry> MeterRegistryCustomizer<T> metricsCommonTags() {
    return registry -> registry.config().commonTags(
        "application", applicationName
    );
  }
}
```

  2. See that custom tags won't be present in metrics, e.g. by going to /actuator/metrics endpoint

## Specifications

  - Version: 1.28.4
  - Platform: temporal-spring-boot


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-07-30 15:55:50.000 UTC</summary>

This is already been fixed in `1.30.0` please make sure you are using the latest SDK 

Reactions: üëç 1

</details>


---

<a id="2580"></a>

### #2580: Add Summary to LocalActivityOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2580 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-07-02 17:52:13.000 UTC (6 months ago) |
| **Updated** | 2025-07-03 16:22:08.000 UTC |
| **Closed** | 2025-07-03 16:22:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See parent for details https://github.com/temporalio/features/issues/637

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-07-03 16:22:08.000 UTC</summary>

This is already done https://github.com/temporalio/sdk-java/blob/4afe41b6ca638775e4e6ecaa3a5171b32670f9d4/temporal-sdk/src/main/java/io/temporal/activity/LocalActivityOptions.java#L171

Reactions: üëç 1

</details>


---

<a id="2578"></a>

### #2578: `startUpdate` JavaDoc says "asynchronously" when it may not be

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2578 |
| **State** | OPEN |
| **Author** | rgrochowicz (Rob Grochowicz) |
| **Created** | 2025-06-30 21:10:59.000 UTC (6 months ago) |
| **Updated** | 2025-07-02 17:23:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

The JavaDoc for `startUpdate` should indicate that when it's called with a `waitForStage` of `WorkflowUpdateStage.COMPLETED`, it's synchronous and blocks until the update is completed.

## Actual Behavior

The JavaDoc for `startUpdate` says the following:

```text
Start a zero argument update workflow request asynchronously.
```

However, the following code will block until the update is completed:

```kotlin
val updateOptions =
  UpdateOptions.newBuilder<UpdateResult>()
    .setResultClass(UpdateResult::class.java)
    .setWaitForStage(WorkflowUpdateStage.COMPLETED)
    .setUpdateId(updateId)
    .build()
val update = WorkflowClient.startUpdate(stub::doUpdate, updateOptions) // <-- blocks here
val result = update.getResult(5, TimeUnit.SECONDS)
```

The JavaDoc implies that `startUpdate` would ignore the `waitForStage`, always be asynchronous, and block on the `update.getResult`.

## Steps to Reproduce the Problem

  1. Look at JavaDoc for `startUpdate`
  2. Assume `startUpdate` is always asynchronous 
  1. Call `startUpdate` with a `waitForStage` of `WorkflowUpdateStage.COMPLETED`
  1. See that the `startUpdate` call was actually synchronous

## Specifications

  - Version: latest [master](https://github.com/temporalio/sdk-java/blob/4afe41b6ca638775e4e6ecaa3a5171b32670f9d4/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java#L704)
  - Platform: n/a

---

Requesting that either the word `asynchronously` is removed from the JavaDoc for the `startUpdate` methods or it's clear that the function isn't asynchronous in a normal sense.

Thanks!

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2025-07-02 17:23:14.000 UTC</summary>

This is the sort of small change we'd be more than happy to accept a PR for if you're interested!

</details>


---

<a id="2573"></a>

### #2573: Support for ManualCompletion in TestActivity Env

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2573 |
| **State** | OPEN |
| **Author** | gauravthadani (Gaurav Thadani) |
| **Created** | 2025-06-26 06:37:03.000 UTC (6 months ago) |
| **Updated** | 2025-07-01 16:58:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Testing an Activity in isolation is feasible with the TestActivityEnvironment. However is a challenge when using `ManualActivityCompletionClient`

```
var manualActivityCompletionClient =
          Activity.getExecutionContext().useLocalManualCompletion();
```

1. Error: Method temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted is unimplemented'
2. Alternatively, I still couldn't test it with a Test Interceptor based approach. Down the `useLocalManualCompletion` implementation, it returns new clients, so unable to mock.


**Describe the solution you'd like**
Either
- support to test with ManualCompletionClient (or)
- ability to return a mock of `ManualActivityCompletionClient` in `useLocalManualCompletion()`.  Maybe a client supplier? (or)


**Describe alternatives you've considered**
- tried interceptor approach to test and with `TestEnvironment` 

**Additional context**
- or should we discourage usage of ManualCompletionClient in java docs .


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-27 23:55:55.000 UTC</summary>

If you want to perform an end to end test with manual completion you can use the `TestWorkflowEnviorment`, if you just want to unit test the system that uses the `ManualCompletionClient ` you should pass that system a mocked `ManualCompletionClient`

> or should we discourage usage of ManualCompletionClient in java docs .

I am not sure there is anything in the Java docs that encourage the use of `ManualCompletionClient `, it is a niche feature for very specific use cases. Its use case is when separate system in the same process wants to complete activities. If you want to unit test that system then you can pass a mocked `ManualCompletionClient ` through the same channel your activity worker is using

</details>


---

<a id="2537"></a>

### #2537: Support for Custom Client Identity on Schedule Trigger

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2537 |
| **State** | CLOSED |
| **Author** | deepika-awasthi |
| **Created** | 2025-05-27 17:17:15.000 UTC (7 months ago) |
| **Updated** | 2025-05-27 20:32:12.000 UTC |
| **Closed** | 2025-05-27 20:32:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We want to differentiate between workflows triggered by a schedule automatically vs manually (e.g., from a dashboard or API). While `TemporalScheduledStartTime` helps distinguish scheduled vs manual triggers in some cases, there‚Äôs currently no way to know **who** or **what service** triggered a manual run via `ScheduleHandle.trigger()` or via interceptor `ScheduleClientCallsInterceptor.CreateScheduleInput`

**Describe the solution you'd like**
Adding a metadata field like `trigger_source`, `client_identity`, or similar

**Describe alternatives you've considered**
We currently plan to compare `nextActionTime` with actual workflow start time and set a `trigger_type` search attribute manually. 

**Additional context**
Attaching slack thread :- https://temporaltechnologies.slack.com/archives/C076CB0E075/p1747790772423569

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-27 20:32:10.000 UTC</summary>

To can set the identity for the schedule client in the [ScheduleClientOptions.Builder](https://github.com/temporalio/sdk-java/blob/0b885071ba07bebf9b53adccd0f8e9d7b1c9d42a/temporal-sdk/src/main/java/io/temporal/client/schedules/ScheduleClientOptions.java#L79). This identity will be passed for every client call made including Trigger 

</details>


---

<a id="2534"></a>

### #2534: [SpringBoot] Add option to fail worker autodiscovery on TypeAlreadyRegisteredException on activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2534 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-05-22 14:48:50.000 UTC (7 months ago) |
| **Updated** | 2025-05-22 14:59:02.000 UTC |
| **Closed** | 2025-05-22 14:59:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently if multiple discovered activity impls (their interfaces) define same activity type and are registered on same task queue worker does not register the activity bean, logs, and continues: 
https://github.com/temporalio/sdk-java/blob/master/temporal-spring-boot-autoconfigure/src/main/java/io/temporal/spring/boot/autoconfigure/template/WorkersTemplate.java#L424-L434

Feature request is to add config option to not continue at this point but throw exception that stops worker start (and if possible start of springboot app)

#### Comments (1)

<details>
<summary><strong>tsurdilo</strong> commented on 2025-05-22 14:58:58.000 UTC</summary>

didnt see 
namespaceProperties.isIgnoreDuplicateDefinitions

</details>


---

<a id="2499"></a>

### #2499: Support pluggable workflow caches

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2499 |
| **State** | OPEN |
| **Author** | ghaskins (Gregory Haskins) |
| **Created** | 2025-05-01 21:34:25.000 UTC (8 months ago) |
| **Updated** | 2025-05-01 22:03:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

There are cases where the current integrated LRU cache for workflow threads may not sufficiently capture the optimal strategy for all workloads.  

For example, some high-volume workloads allow the cache to fill with workflows that are effectively abandoned because a remote worker completed them without any invalidation signal to clear the defunct task within the current worker. These abandoned workflows add extra eviction overhead for new, unrelated workflows, and the system may sometimes benefit from alternate eviction strategies that differ from the current synchronous LRU algorithm.  Examples include augmenting the LRU with a TTL model, or adding an asynchronous/background eviction mechanism.

The proposal is to add a mechanism allowing a pluggable cache that defaults to the current LRU design, allowing SDK end-users to supply their own implementations when desired.


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-05-01 22:03:59.000 UTC</summary>

This is similar to the general cross-SDK request at https://github.com/temporalio/features/issues/573 (we would look into supporting cache customization across SDKs, not just Java). There is no timeline for the effort however.

</details>


---

<a id="2484"></a>

### #2484: Warn when the server-provided task start time is fairly different than time SDK begins processing the task

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2484 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-22 12:20:01.000 UTC (8 months ago) |
| **Updated** | 2025-09-23 20:07:52.000 UTC |
| **Closed** | 2025-09-23 20:07:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/616

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2025-09-23 20:07:52.000 UTC</summary>

We're not gonna do this. Too niche.

</details>


---

<a id="2482"></a>

### #2482: Merging ActivityOptions fails with UnsupportedOperationException when using immutable lists for context propagators

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2482 |
| **State** | OPEN |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2025-04-18 08:05:51.000 UTC (8 months ago) |
| **Updated** | 2025-04-18 13:22:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Merging ActivityOptions fails  [here](https://github.com/temporalio/sdk-java/blob/d326d7ff59cd4ec9f4e422633133283707a57d2d/temporal-sdk/src/main/java/io/temporal/activity/ActivityOptions.java#L272) with UnsupportedOperationException when using immutable lists for context propagators



### Steps to Reproduce the Problem

Create a worker with WorkflowImplementationOptions and set setContextPropagators as an immutable list for one of the activities. 

````
 WorkflowImplementationOptions options =
        WorkflowImplementationOptions.newBuilder()
            .setActivityOptions(
                ImmutableMap.of(
                    "ActivityTypeB",
                    ActivityOptions.newBuilder()
                        // Set activity exec timeout (single run)
                        .setStartToCloseTimeout(Duration.ofSeconds(2))
                        .setRetryOptions(
                            RetryOptions.newBuilder()
                                // ActivityTypeB activity type shouldn't retry on NPE
                                .setDoNotRetry(NullPointerException.class.getName())
                                .build())
                        .setContextPropagators(List.of(new MDCContextPropagator()))
                        .build()))
            .build();

````

for the same activity, set the context propagator as an immutable list in the activityStub
```

  private FailingActivities activities =
      Workflow.newActivityStub(
          FailingActivities.class,
          ActivityOptions.newBuilder()
              .setContextPropagators(List.of(new MDCContextPropagator2()))
              .build());
```


The worker throws an `UnsupportedOperationException` [here](https://github.com/temporalio/sdk-java/blob/d326d7ff59cd4ec9f4e422633133283707a57d2d/temporal-sdk/src/main/java/io/temporal/activity/ActivityOptions.java#L272) when it tries to schedule the activity. 



**Describe the solution you'd like**

Create a new list that combines both instead of modifying one of them. 



#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-04-18 13:21:20.000 UTC</summary>

> Describe the solution you'd like
> Create a new list that combines both instead of modifying one of them.

Alternatively, copy the list on `setContextPropagators`. Both are options are _technically_ backwards incompatible, because _technically_ today we allow a user to mutate the list they passed to `setContextPropagators` _after_ they set it (and after any merge calls), but before build. So we just have to decide if we're ok breaking that or not.

Reactions: üëç 1

</details>


---

<a id="2461"></a>

### #2461: [Feature Request] Utility to detect when deadlock detector triggers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2461 |
| **State** | OPEN |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2025-03-27 11:47:00.000 UTC (9 months ago) |
| **Updated** | 2025-03-27 12:55:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

### Is your feature request related to a problem? Please describe.

Users would like the ability to programmatically detect when the deadlock detector has triggered (and caused the workflow task to fail), so they can instruct their code to stop processing. This would be used to write defensive logic to prevent zombie threads or loops from running after the workflow task has failed. This typically happens when there‚Äôs a bug in user code, such as a spinning loop that runs indefinitely.

<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->

### Describe the solution you'd like

Currently, the SDK throws a DestroyWorkflowThreadError when a workflow API (e.g., sleep, scheduleActivity) is used after the deadlock detector has been triggered.

It would be great to have a method similar to `Thread.currentThread().isInterrupted()` that returns true (or an exception). This would allow developers to break out of loops or take alternate actions. 

<!-- A clear and concise description of what you want to happen. SCREENSHOTS OR CODE SAMPLES ARE VERY HELPFUL -->

### Additional context

<!-- Add any other context or screenshots about the feature request here. -->


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-03-27 12:55:45.000 UTC</summary>

Alternatively we should consider an interruption point they can put in their loops (e.g. `CancellationScope.current().throwCanceled()` or equivalent). A boolean may not be good enough, we may prefer that the thrown error be bubbled out.

</details>


---

<a id="2451"></a>

### #2451: Worfklow StartDelay not working with TestWorkflowEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2451 |
| **State** | CLOSED |
| **Author** | gauravthadani (Gaurav Thadani) |
| **Created** | 2025-03-18 22:39:37.000 UTC (9 months ago) |
| **Updated** | 2025-03-19 14:55:12.000 UTC |
| **Closed** | 2025-03-19 14:55:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Expect to see a delay in starting a Workflow when
- useTimeSkipping is `false`
- and see a Timer create and advance (in TRACE logs, not Workflow Execution) when useTimeSkipping is `true`

## Actual Behavior
Don't see any delay in Workflow starting

## Steps to Reproduce the Problem

  1. Simple Activity Workflow 
  
with time skipping disabled `.setUseTimeskipping(false)`
and StartDelay in workflowOptions

## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-03-19 14:55:11.000 UTC</summary>

Hi Gaurav, there is already an issue to track [this](https://github.com/temporalio/sdk-java/issues/1692). Please follow that issue for any updates

Reactions: üëç 1

</details>


---

<a id="2434"></a>

### #2434: Spring boot initialization should fail if activity names (per worker) are duplicated

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2434 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2025-02-28 16:07:01.000 UTC (10 months ago) |
| **Updated** | 2025-05-07 17:42:04.000 UTC |
| **Closed** | 2025-05-07 17:42:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When registering duplicated activity names in "normal" workers, the worker initialization fail with 
 

`"xyz" activity type is already registered with the worker `

Users expect the same when they use Spring Boot. 

Spring Boot does not fail, it currently prints 

`Skipping auto-discovered activity bean 'xyzImpl' of class class `abc` on a worker  with a task queue 'taskqueueName123' as activity type 'activityWithNameX' is already registered on the worker`


I think the worker initialization should fail

## Actual Behavior


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>dspitzer</strong> commented on 2025-04-24 08:45:13.000 UTC</summary>

This bit us as well and can lead to dangerous behavior. 

</details>


---

<a id="2423"></a>

### #2423: Remove old workflow run operation token format

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2423 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-02-20 22:12:51.000 UTC (10 months ago) |
| **Updated** | 2025-04-23 15:03:14.000 UTC |
| **Closed** | 2025-04-23 15:03:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Remove old workflow run operation token format

**Describe the solution you'd like**
Remove old workflow run operation token format support, treat all un-parsable tokens as a handler error 


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-24 06:42:28.000 UTC</summary>

We should also remove any support for operation ID

</details>


---

<a id="2420"></a>

### #2420: `temporal-serviceclient` library is incompatible with `protobuf-java` 4.x

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2420 |
| **State** | CLOSED |
| **Author** | RomanVlasenko (Roman Vlasenko) |
| **Created** | 2025-02-19 10:21:26.000 UTC (10 months ago) |
| **Updated** | 2025-02-19 15:16:45.000 UTC |
| **Closed** | 2025-02-19 15:16:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

All classes in the `io.temporal.api` package of `io.temporal:temporal-serviceclient` seem to extend `GeneratedMessageV3`, which is deprecated and removed in protobuf-java 4.x. The Temporal SDK documentation states that it is compatible with protobuf-java 4.x, but in practice, it fails at runtime.

## Expected Behavior
Temporal Java SDK is compatible with protobuf-java 4.x and higher, or the documentation is updated accordingly.

## Actual Behavior
```
io.temporal.payload.codec.PayloadCodecException: java.lang.NoSuchMethodError: 'void io.temporal.api.common.v1.Payload.makeExtensionsImmutable()'
--
¬† | at com.fivetran.temporal.api.CryptoCodec.decodePayload(CryptoCodec.java:113)
¬† | at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
¬† | at java.base/java.util.AbstractList$RandomAccessSpliterator.forEachRemaining(AbstractList.java:720)
¬† | at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
¬† | at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
¬† | at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
¬† | at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
¬† | at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
¬† | at com.fivetran.temporal.api.CryptoCodec.decode(CryptoCodec.java:76)
¬† | at com.fivetran.temporal.api.CryptoCodecSpec.cryptoCodec_shouldEncryptAndDecrypt(CryptoCodecSpec.java:28)
¬† | at java.base/java.lang.reflect.Method.invoke(Method.java:568)
¬† | at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
¬† | at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
¬† | at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
¬† | at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
¬† | at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
¬† | Caused by: java.lang.NoSuchMethodError: 'void io.temporal.api.common.v1.Payload.makeExtensionsImmutable()'
¬† | at io.temporal.api.common.v1.Payload.<init>(Payload.java:94)
¬† | at io.temporal.api.common.v1.Payload.<init>(Payload.java:16)
¬† | at io.temporal.api.common.v1.Payload$1.parsePartialFrom(Payload.java:755)
¬† | at io.temporal.api.common.v1.Payload$1.parsePartialFrom(Payload.java:749)
¬† | at com.google.protobuf.AbstractParser.parsePartialFrom(AbstractParser.java:135)
¬† | at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:168)
¬† | at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:180)
¬† | at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:185)
¬† | at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:25)
¬† | at io.temporal.api.common.v1.Payload.parseFrom(Payload.java:319)
¬† | at com.fivetran.temporal.api.CryptoCodec.decodePayload(CryptoCodec.java:111)
¬† | ... 15 more
```

## Steps to Reproduce the Problem

  1. Configure a project that uses `io.temporal:temporal-serviceclient:1.27.1` and `com.google.protobuf:protobuf-java:4.29.3`
  1. Call `Payload.parseFrom` on an arbitrary value (e.g. `Payload.parseFrom("".getBytes(StandardCharsets.UTF_8))`)
  1. As a result, an exception will be thrown: `java.lang.NoSuchMethodError: 'void io.temporal.api.common.v1.Payload.makeExtensionsImmutable()'`

## Specifications

  - Version: 1.27.1
  - Platform: Ubuntu Linux, MacOS


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-19 15:16:44.000 UTC</summary>

The head of master is compatible with protobuf v4, `v1.27.1` is not. The next release `v1.28.0` will be compatible as is our [snapshot release](https://github.com/temporalio/sdk-java?tab=readme-ov-file#snapshot-release)

Reactions: üëç 1

</details>


---

<a id="2418"></a>

### #2418: workflow_task_execution_failed metric sometime doesn't have `failure_reason` tag

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2418 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-02-18 04:50:51.000 UTC (10 months ago) |
| **Updated** | 2025-02-18 15:11:30.000 UTC |
| **Closed** | 2025-02-18 15:11:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

`workflow_task_execution_failed` metric should always have `failure_reason` tag

## Actual Behavior

`workflow_task_execution_failed` metric sometimes doesn't have `failure_reason` tag



#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-02-18 14:55:15.000 UTC</summary>

What is the situation where this exception happens in that PR? Am just curious because I can't see where it reports a task failure in that catch clause.

</details>


---

<a id="2404"></a>

### #2404: temporal-test-server for ARM64

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2404 |
| **State** | CLOSED |
| **Author** | kmeelu (K. Bobby Meelu) |
| **Created** | 2025-02-07 20:05:37.000 UTC (11 months ago) |
| **Updated** | 2025-02-08 05:15:57.000 UTC |
| **Closed** | 2025-02-08 05:15:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We would like to access the Temporal [`start_time_skipping`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#start_time_skipping) test environment to better validate that `wait_condition`s are working properly.

We run on ARM64-based Macs and are wondering if you could support that. I see the `temporal-test-server`, which we need for time-skipping, only runs on AMD54 right now: https://github.com/temporalio/sdk-java/releases

**Describe the solution you'd like**
Add a ARM64 Linux & Mac distribution for the temporal-test-server release: https://github.com/temporalio/sdk-java/releases

**Describe alternatives you've considered**
I've considered running linux with the amd64 platform, but this leads to (1) issues with other container packages and python packages that we have running that depend on arm64.

**Additional context**
N/A

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-08 05:15:56.000 UTC</summary>

Yes this is something we would like to support, hopefully in the very near future. Currently working on changing the test server build to support this.

Reactions: üëç 1

</details>


---

<a id="2392"></a>

### #2392: [Bug] Test environment sleep hangs on child workflows 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2392 |
| **State** | OPEN |
| **Author** | ksapchuk (Kirill) |
| **Created** | 2023-04-17 21:48:22.000 UTC (2y 8m ago) |
| **Updated** | 2025-01-28 20:40:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

### What are you really trying to do?
We have a workflow that starts async child workflows with `startChild` that we want to test. The child workflows have delays in place and we want to sleep in the test environment to check intermediate workflow state. 

### Describe the bug
After starting the workflow with `execute` calling sleep on the time skipping TestWorkflowEnvironment seems to hang despite the child workflow having finished. The same test passes if starting the workflow with `start`. 

### Minimal Reproduction
Activities
```
export const createActivities = () => ({
  async runActivity(): Promise<void> {},
});
```
Workflows
```
const { runActivity } = proxyActivities<ReturnType<typeof createActivities>>({
  startToCloseTimeout: '5m',
});

export async function childWorkflow(): Promise<void> {
  await runActivity();
}

export async function parentWorkflow(): Promise<void> {
  await startChild(childWorkflow, { args: [], parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON });
}
```

Test
```
  it('sleeps correctly', async () => {
    const mockActivities: ReturnType<typeof createActivities> = {
      async runActivity() {
        console.log('running activity');
      },
    };
    const worker = await Worker.create({
      connection: env.nativeConnection,
      taskQueue: 'test',
      workflowsPath: require.resolve('../workflows'),
      activities: mockActivities,
    });
    await worker.runUntil(async () => {
      await env.client.workflow.execute(parentWorkflow, {
        workflowId: uuid(),
        taskQueue: 'test',
        args: [],
      });
      await env.sleep('5 minutes');
    });
  });
```

### Environment/Versions

<!-- Please complete the following information where relevant. -->

- OS and processor: M1 Mac,
- Temporal Version: typescript sdk 1.7.2
- Are you using Docker or Kubernetes or building Temporal from source?
No



#### Comments (1)

<details>
<summary><strong>mjameswh</strong> commented on 2025-01-28 20:39:36.000 UTC</summary>

Moving to sdk-java, as this is an issue in the Time Skipping Test Server.

</details>


---

<a id="2364"></a>

### #2364: TestWorkflowEnvironment issue with setting search attributes in ContinueAsNewOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2364 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-01-09 11:14:25.000 UTC (1 years ago) |
| **Updated** | 2025-05-16 22:41:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When using TestWorkflowEnvironment setting search attributes in ContinueAsNewOptions does not set them with the continued exec:

    ContinueAsNewOptions.newBuilder()
        .setTypedSearchAttributes(
            SearchAttributes.newBuilder()
                .set(CustomTextAttrib, "someValue")
                .build())
            .build());

same issue for setting typed search attributes as well as the deprecated (setSearchAttributes) too

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-01-09 14:05:55.000 UTC</summary>

(related to #2178 but not the same, but should solve both at the same time)

</details>


---

<a id="2346"></a>

### #2346: Manual completion client does unlimited retries for non-retryable error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2346 |
| **State** | CLOSED |
| **Author** | lazy-ninja (Niraj) |
| **Created** | 2024-12-11 12:15:48.000 UTC (1 years ago) |
| **Updated** | 2024-12-17 11:43:04.000 UTC |
| **Closed** | 2024-12-17 11:43:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
- ManualActivityCompletionClient shouldn't retry the non-retryable errors
```java
Error: GRPC: received message larger than max (5243998 vs. 4194304)
```

## Actual Behavior
- It's being retried
- 


## Steps to Reproduce the Problem

  1. Create an async activity
  2. Complete exceptionally with payload size >4MB.


## Specifications

  - Version: 1.22.3
  - Platform: 


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-17 11:43:03.000 UTC</summary>

This is a duplicate of https://github.com/temporalio/temporal/issues/6806

</details>


---

<a id="2340"></a>

### #2340: Consider renaming WorkflowStub.update => WorkflowStub.executeUpdate

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2340 |
| **State** | CLOSED |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2024-12-02 14:28:00.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-02 15:16:31.000 UTC |
| **Closed** | 2024-12-02 15:05:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Across all SDKs our naming pattern for workflow and update APIs is

- "startXXX" => start it asynchronously and return a handle
- "executeXXX" => start it and return the result

As the table below shows, almost the only exception is Java's untyped stub method `WorkflowStub.update`, which returns the update result. If we renamed this to `executeUpdate` it would increase consistency within the Java SDK as well as across SDKs.

<img width="1184" alt="image" src="https://github.com/user-attachments/assets/6d9566b4-9517-4903-8eb6-a0f77f348869">


#### Comments (1)

<details>
<summary><strong>dandavison</strong> commented on 2024-12-02 15:05:57.000 UTC</summary>

We think it's too late.

</details>


---

<a id="2321"></a>

### #2321: TestWorkflowEnvironment does not allow signalWithStart when workflow already exists

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2321 |
| **State** | OPEN |
| **Author** | rpost (Radek Posto≈Çowicz) |
| **Created** | 2024-11-14 22:52:54.000 UTC (1y 1m ago) |
| **Updated** | 2024-11-19 18:57:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

TestWorkflowEnvironment does not allow signalWithStart when workflow already exists - see exception below.

## Actual Behavior

TestWorkflowEnvironment should work the same as standalone server in this matter.


## Steps to Reproduce the Problem

Reproducer: SimpleWorkflowTest in https://github.com/rpost/temporal-test-bug - when test is run it fails with

```
Workflow execution {workflowId='my-workflow-2', runId='', workflowType='SampleWorkflow'} failed. Metadata: {closeEventType='EVENT_TYPE_WORKFLOW_EXECUTION_FAILED', retryState='RETRY_STATE_UNSPECIFIED', workflowTaskCompletedEventId=3'}
io.temporal.client.WorkflowFailedException: Workflow execution {workflowId='my-workflow-2', runId='', workflowType='SampleWorkflow'} failed. Metadata: {closeEventType='EVENT_TYPE_WORKFLOW_EXECUTION_FAILED', retryState='RETRY_STATE_UNSPECIFIED', workflowTaskCompletedEventId=3'}
	at io.temporal.internal.common.WorkflowExecutionUtils.getResultFromCloseEvent(WorkflowExecutionUtils.java:101)
	at io.temporal.internal.client.WorkflowClientLongPollHelper.getWorkflowExecutionResult(WorkflowClientLongPollHelper.java:70)
	at io.temporal.internal.client.RootWorkflowClientInvoker.getResult(RootWorkflowClientInvoker.java:353)
	at io.temporal.client.WorkflowStubImpl.getResult(WorkflowStubImpl.java:259)
	at io.temporal.client.WorkflowStubImpl.getResult(WorkflowStubImpl.java:240)
	at io.temporal.client.WorkflowStubImpl.getResult(WorkflowStubImpl.java:233)
	at io.temporal.testing.TimeLockingInterceptor$TimeLockingWorkflowStub.getResult(TimeLockingInterceptor.java:113)
	at rpost.SimpleWorkflowTest.shouldSignalWithStart(SimpleWorkflowTest.java:70)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:728)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:86)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:218)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:214)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:139)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:69)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:119)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:94)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:89)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:62)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
	at jdk.proxy1/jdk.proxy1.$Proxy2.stop(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60)
	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:119)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:66)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74)
Caused by: io.temporal.failure.ActivityFailure: Activity with activityType='SignalWithStart' failed: 'Local Activity task failed'. scheduledEventId=0, startedEventId=0, activityId=a2731aa9-d29c-3699-b58f-73097f7cd4ea, identity='', retryState=RETRY_STATE_RETRY_POLICY_NOT_SET
	at io.temporal.failure.DefaultFailureConverter.failureToExceptionImpl(DefaultFailureConverter.java:163)
	at io.temporal.failure.DefaultFailureConverter.failureToException(DefaultFailureConverter.java:79)
	at io.temporal.common.converter.PayloadAndFailureDataConverter.failureToException(PayloadAndFailureDataConverter.java:143)
	... 88 more
Caused by: io.temporal.failure.ApplicationFailure: message='workflowId='mutexId', runId='37e667cc-b775-4a6a-a404-8798b7d217a3', workflowType='MutexWorkflow'', type='io.temporal.client.WorkflowExecutionAlreadyStarted', nonRetryable=false
	at io.temporal.client.WorkflowStubImpl.wrapStartException(WorkflowStubImpl.java:484)
	at io.temporal.client.WorkflowStubImpl.signalWithStartWithOptions(WorkflowStubImpl.java:190)
	at io.temporal.client.WorkflowStubImpl.signalWithStart(WorkflowStubImpl.java:217)
	at io.temporal.testing.TimeLockingInterceptor$TimeLockingWorkflowStub.signalWithStart(TimeLockingInterceptor.java:86)
	at rpost.SampleWorkflow$SignalWithStartActivityImpl.signalWithStart(SampleWorkflow.java:61)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at io.temporal.internal.activity.RootActivityInboundCallsInterceptor$POJOActivityInboundCallsInterceptor.executeActivity(RootActivityInboundCallsInterceptor.java:64)
	at io.temporal.internal.activity.RootActivityInboundCallsInterceptor.execute(RootActivityInboundCallsInterceptor.java:43)
	at io.temporal.internal.activity.ActivityTaskExecutors$BaseActivityTaskExecutor.execute(ActivityTaskExecutors.java:107)
	at io.temporal.internal.activity.ActivityTaskHandlerImpl.handle(ActivityTaskHandlerImpl.java:124)
	at io.temporal.internal.worker.LocalActivityWorker$AttemptTaskHandlerImpl.handle(LocalActivityWorker.java:472)
	at io.temporal.internal.worker.LocalActivityWorker$AttemptTaskHandlerImpl.handle(LocalActivityWorker.java:399)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: io.temporal.failure.ApplicationFailure: message='ALREADY_EXISTS: WorkflowId: mutexId, RunId: 37e667cc-b775-4a6a-a404-8798b7d217a3', type='io.grpc.StatusRuntimeException', nonRetryable=false
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:271)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:252)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:165)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.signalWithStartWorkflowExecution(WorkflowServiceGrpc.java:4639)
	at io.temporal.internal.client.external.GenericWorkflowClientImpl.lambda$signalWithStart$3(GenericWorkflowClientImpl.java:113)
	at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:69)
	at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:60)
	at io.temporal.internal.client.external.GenericWorkflowClientImpl.signalWithStart(GenericWorkflowClientImpl.java:108)
	at io.temporal.internal.client.RootWorkflowClientInvoker.signalWithStart(RootWorkflowClientInvoker.java:164)
	at io.temporal.client.WorkflowStubImpl.signalWithStartWithOptions(WorkflowStubImpl.java:180)
	... 15 more
```

whereas when main method is run (with `temporal server start-dev` in background) it finishes fine.


## Specifications

 - sdk version: 1.26.1
 - `temporal server start-dev`: CLI 1.1.0 (Server 1.25.0, UI 2.30.3)



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-11-18 19:00:31.000 UTC</summary>

Hm I tried to translate your reproduction into an SDK test and was not able to reproduce any bug. I will try to run your reproduction directly. 

</details>


---

<a id="2263"></a>

### #2263: TestWorkflowEnvironment does not support workflows with start delay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2263 |
| **State** | CLOSED |
| **Author** | imalao (Ivy Malao) |
| **Created** | 2024-10-09 18:53:50.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-09 19:23:50.000 UTC |
| **Closed** | 2024-10-09 19:23:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

I expect to be able to start a workflow with a start delay and have it start at the expected time using TestWorkflowEnvironment.sleep()

## Actual Behavior

The workflow starts immediately.

## Specifications

  - Version: Java SDK 1.25.2
  - Platform: MacOS 


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-09 19:23:49.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-java/issues/1692

Reactions: üëç 1

</details>


---

<a id="2256"></a>

### #2256: Support actual versions of spring boot

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2256 |
| **State** | CLOSED |
| **Author** | mvkirillov (Miki) |
| **Created** | 2024-10-05 19:12:28.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-05 21:29:51.000 UTC |
| **Closed** | 2024-10-05 19:20:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Good afternoon, tell me, will you support compatibility with current versions of Spring Boot, for example 3.2.x, 3.3.x?

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-05 19:20:23.000 UTC</summary>

The Springboot integration supports 3.x, see our springboot [sample](https://github.com/temporalio/samples-java/blob/main/gradle.properties#L3). 

For user support questions please use our [forum](https://community.temporal.io/) or [slack](https://t.mp/slack). We use github for bugs and feature requests.



</details>


---

<a id="2254"></a>

### #2254: RetryOption.setMaximumAttempts(0) seems broken for LocalActivities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2254 |
| **State** | CLOSED |
| **Author** | ghaskins (Gregory Haskins) |
| **Created** | 2024-10-05 02:47:22.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-05 02:54:28.000 UTC |
| **Closed** | 2024-10-05 02:54:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

The default RetryOptions or explicitly setting RetryOption.setMaximumAttempts(0) for a local activity is suggested to mean "unlimited retries"

## Actual Behavior

Local activities will not retry with default RetryOptions or explicitly setting RetryOptions.setMaxiumAttempts(0).  Instead, they will error out after 0 retry attempts.  This is inconsistent with the documentation, and I believe it is also inconsistent with normal activitiy behavior

## Steps to Reproduce the Problem

 Run the following code snippet modified from the HelloActivity sample.  The primary changes are
 
 1) We now explicitly set RetryOption.setMaximumAttempts(0)
 2) We are calling a LocalActivity instead of a normal activity
 3) The activity intentionally sleeps as to trigger the StartToClose timeout
 
 If you run this code as is, it will fail after 1 second.  The expected behavior is that it would run indefinitely due to "unlimited" retries.
 
 You can confirm that the general test structure is suited to reproduction by changing the setMaximumAttempts to a positive integer (e.g. 10) and confirming that it does retry N times when it is positive.  However, the default/0 case for unlimited does not seem to work.
 
 ```
 /*
 *  Copyright (c) 2020 Temporal Technologies, Inc. All Rights Reserved
 *
 *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Modifications copyright (C) 2017 Uber Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not
 *  use this file except in compliance with the License. A copy of the License is
 *  located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 *  or in the "license" file accompanying this file. This file is distributed on
 *  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *  express or implied. See the License for the specific language governing
 *  permissions and limitations under the License.
 */

package org.example;

import io.temporal.activity.ActivityInterface;
import io.temporal.activity.ActivityMethod;
import io.temporal.activity.ActivityOptions;
import io.temporal.activity.LocalActivityOptions;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowOptions;
import io.temporal.common.RetryOptions;
import io.temporal.serviceclient.WorkflowServiceStubs;
import io.temporal.worker.Worker;
import io.temporal.worker.WorkerFactory;
import io.temporal.workflow.Workflow;
import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;
import java.time.Duration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** Sample Temporal Workflow Definition that executes a single Activity. */
public class HelloActivity {

    // Define the task queue name
    static final String TASK_QUEUE = "HelloActivityTaskQueue";

    // Define our workflow unique id
    static final String WORKFLOW_ID = "HelloActivityWorkflow";

    /**
     * The Workflow Definition's Interface must contain one method annotated with @WorkflowMethod.
     *
     * <p>Workflow Definitions should not contain any heavyweight computations, non-deterministic
     * code, network calls, database operations, etc. Those things should be handled by the
     * Activities.
     *
     * @see io.temporal.workflow.WorkflowInterface
     * @see io.temporal.workflow.WorkflowMethod
     */
    @WorkflowInterface
    public interface GreetingWorkflow {

        /**
         * This is the method that is executed when the Workflow Execution is started. The Workflow
         * Execution completes when this method finishes execution.
         */
        @WorkflowMethod
        String getGreeting(String name);
    }

    /**
     * This is the Activity Definition's Interface. Activities are building blocks of any Temporal
     * Workflow and contain any business logic that could perform long running computation, network
     * calls, etc.
     *
     * <p>Annotating Activity Definition methods with @ActivityMethod is optional.
     *
     * @see io.temporal.activity.ActivityInterface
     * @see io.temporal.activity.ActivityMethod
     */
    @ActivityInterface
    public interface GreetingActivities {

        // Define your activity method which can be called during workflow execution
        @ActivityMethod(name = "greet")
        String composeGreeting(String greeting, String name);
    }

    // Define the workflow implementation which implements our getGreeting workflow method.
    public static class GreetingWorkflowImpl implements GreetingWorkflow {

        /**
         * Define the GreetingActivities stub. Activity stubs are proxies for activity invocations that
         * are executed outside of the workflow thread on the activity worker, that can be on a
         * different host. Temporal is going to dispatch the activity results back to the workflow and
         * unblock the stub as soon as activity is completed on the activity worker.
         *
         * <p>In the {@link ActivityOptions} definition the "setStartToCloseTimeout" option sets the
         * overall timeout that our workflow is willing to wait for activity to complete. For this
         * example it is set to 2 seconds.
         */
        private final GreetingActivities activities =
                Workflow.newLocalActivityStub(
                        GreetingActivities.class,
                        LocalActivityOptions.newBuilder()
                                .setStartToCloseTimeout(Duration.ofSeconds(1))
                                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(0).build())
                                .build());

        @Override
        public String getGreeting(String name) {
            return activities.composeGreeting("Hello", name);
        }
    }

    /** Simple activity implementation, that concatenates two strings. */
    static class GreetingActivitiesImpl implements GreetingActivities {
        private static final Logger log = LoggerFactory.getLogger(GreetingActivitiesImpl.class);

        @Override
        public String composeGreeting(String greeting, String name) {
            log.info("Composing greeting...");

            System.out.println("getGreeting");
            try {
                Thread.sleep(1000000000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            return greeting + " " + name + "!";
        }
    }

    /**
     * With our Workflow and Activities defined, we can now start execution. The main method starts
     * the worker and then the workflow.
     */
    public static void main(String[] args) {

        // Get a Workflow service stub.
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();

        /*
         * Get a Workflow service client which can be used to start, Signal, and Query Workflow Executions.
         */
        WorkflowClient client = WorkflowClient.newInstance(service);

        /*
         * Define the workflow factory. It is used to create workflow workers for a specific task queue.
         */
        WorkerFactory factory = WorkerFactory.newInstance(client);

        /*
         * Define the workflow worker. Workflow workers listen to a defined task queue and process
         * workflows and activities.
         */
        Worker worker = factory.newWorker(TASK_QUEUE);

        /*
         * Register our workflow implementation with the worker.
         * Workflow implementations must be known to the worker at runtime in
         * order to dispatch workflow tasks.
         */
        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);

        /*
         * Register our Activity Types with the Worker. Since Activities are stateless and thread-safe,
         * the Activity Type is a shared instance.
         */
        worker.registerActivitiesImplementations(new GreetingActivitiesImpl());

        /*
         * Start all the workers registered for a specific task queue.
         * The started workers then start polling for workflows and activities.
         */
        factory.start();

        // Create the workflow client stub. It is used to start our workflow execution.
        GreetingWorkflow workflow =
                client.newWorkflowStub(
                        GreetingWorkflow.class,
                        WorkflowOptions.newBuilder()
                                .setWorkflowId(WORKFLOW_ID)
                                .setTaskQueue(TASK_QUEUE)
                                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())
                                .build());

        /*
         * Execute our workflow and wait for it to complete. The call to our getGreeting method is
         * synchronous.
         *
         * See {@link io.temporal.samples.hello.HelloSignal} for an example of starting workflow
         * without waiting synchronously for its result.
         */
        String greeting = workflow.getGreeting("World");

        // Display workflow execution results
        System.out.println(greeting);
        System.exit(0);
    }
}
```



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-05 02:54:28.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-java/issues/1727

</details>


---

<a id="2247"></a>

### #2247: Implement Nexus operation cancellation type

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2247 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-10-01 21:42:59.000 UTC (1y 3m ago) |
| **Updated** | 2025-06-12 18:46:21.000 UTC |
| **Closed** | 2025-06-12 18:46:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Similar to [ChildWorkflowCancellationType](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/ChildWorkflowCancellationType.html).

Waiting for "cancel requested" requires the server to record the NexusOperationCancelDelivered (name TBD) history event (not implemented at the time of writing).

#### Comments (1)

<details>
<summary><strong>bergundy</strong> commented on 2024-10-01 21:46:21.000 UTC</summary>

See [server issue](https://github.com/temporalio/temporal/issues/6585) to record the event.

</details>


---

<a id="2245"></a>

### #2245: Handle Nexus links

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2245 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-10-01 17:23:26.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-16 15:13:48.000 UTC |
| **Closed** | 2024-10-16 15:13:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Support Nexus bi-directional links.


See also: https://github.com/temporalio/sdk-go/pull/1605


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-10-16 15:13:48.000 UTC</summary>

https://github.com/temporalio/sdk-java/commit/eff3ca20fcf8579f6fe38d8345d588425c0034b6

</details>


---

<a id="2236"></a>

### #2236: Call ShutdownWorker API on worker shutdown

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2236 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-09-24 14:26:15.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-10 17:57:55.000 UTC |
| **Closed** | 2024-10-10 17:57:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/542

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-28 21:14:12.000 UTC</summary>

We will also need to add test server support here IMO

</details>


---

<a id="2217"></a>

### #2217: workflow metadata query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2217 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-15 06:37:38.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-18 23:22:02.000 UTC |
| **Closed** | 2024-09-18 23:22:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add support for workflow metadata query as described [here](https://github.com/temporalio/features/issues/486) and implemented in the Go SDK [here](https://github.com/temporalio/sdk-go/issues/1565).



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-18 23:22:02.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-java/issues/335

</details>


---

<a id="2213"></a>

### #2213: Signal w/ Start API Improvements - Java

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2213 |
| **State** | OPEN |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-09-12 21:22:00.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-09 18:46:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
BatchRequest is [hard to use](https://github.com/temporalio/samples-java/blob/ec1c615074eaf63d6b09caabff80e374ab507841/core/src/main/java/io/temporal/samples/moneybatch/TransferRequester.java#L51-L54), i.e. it has some affordances that would be illegal.
* First item must be the workflow start
* Second must be signal
We've never added support for other operations to it, such as Update, which means it might mislead people into thinking it could be used for an Update.

**Describe the solution you'd like**
Suggest deprecating it and replacing it with something 
* easier to use
* more consistent with `updateWithStart`.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (1)

<details>
<summary><strong>drewhoskins-temporal</strong> commented on 2024-10-09 18:46:06.000 UTC</summary>

Related: https://github.com/temporalio/sdk-java/issues/915

</details>


---

<a id="2200"></a>

### #2200: `Workflow.newUntypedActivityStub` does not inherit default options the same way `Workflow.newActivityStub` does

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2200 |
| **State** | CLOSED |
| **Author** | idubrov (Ivan Dubrov) |
| **Created** | 2024-08-27 23:16:40.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-27 23:40:09.000 UTC |
| **Closed** | 2024-08-27 23:40:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Expected both of the following stubs to use the same default options configured via Spring Boot bean implementing `TemporalOptionsCustomizer<WorkflowImplementationOptions.Builder>`.

```
var stub = Workflow.newActivityStub(Whatever.class, null); // no explicit options provided
var untypedStub = Workflow.newUntypedActivityStub(null); // no explicit options provided
```

## Actual Behavior

The first one does use the default options, via this line: https://github.com/temporalio/sdk-java/blob/1a054bb93401ec921b5a0ac0be3b2fd2c387db51/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowInternal.java#L316

However, the second one does not. Not sure if this is intentional or not (I noted that I _have_ to pass `options` argument to the `newUntypedActivityStub`), but this was a bit surprising behavior -- I configure default options so I can override them via Spring properties, and my untyped stub was not picking them (I was able to retrieve them via `WorkflowInternal.getRootWorkflowContext().getDefaultActivityOptions()`, but with some package-hacking as this API is internal).

## Specifications

  - Version: 1.25.1


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-27 23:39:01.000 UTC</summary>

Yes this is intentional `setDefaultActivityOptions` specifies it only applies to `newActivityStub` in general the activity interface is required to construct the final default activities options .

</details>


---

<a id="2179"></a>

### #2179: Interceptor Configurations - exclusions based on workflow/activity type and task queue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2179 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-08-10 16:57:42.000 UTC (1y 5m ago) |
| **Updated** | 2024-12-23 10:51:28.000 UTC |
| **Closed** | 2024-12-23 10:51:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Feature request is to be able to add configuration-based approach to exclude certain workflows and/or activities 
from being intercepted based on their type or task queue they run on.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-08-12 15:08:27.000 UTC</summary>

I am not sure there is value in "configuration" in this case when it can be done in a conditional. There are theoretically infinite number of configurations to exclude things (I can think of dozens) instead of simple conditionals in an interceptor, so I think we should encourage programmatic exclusion when using programmatic interceptors. If someone wants to write an interceptor wrapper that does does exclusion check before applying inner interceptor, they can.

</details>


---

<a id="2166"></a>

### #2166: Workflow-init support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2166 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-08-02 04:06:09.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-06 17:16:04.000 UTC |
| **Closed** | 2024-08-06 17:16:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We should have a method that's guaranteed to initialize before signals and updates come in so handlers can use initialized values.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-06 17:16:04.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-java/issues/865

</details>


---

<a id="2142"></a>

### #2142: Test server should treat update/poll-update as long-poll

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2142 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-09 15:06:07.000 UTC (1y 6m ago) |
| **Updated** | 2024-07-30 15:22:00.000 UTC |
| **Closed** | 2024-07-30 15:22:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Start/poll update long poll timeout should return empty response. This could be updated to just match the get-history call which is hardcoded to 20s or could just be set to 10s before the user-set deadline.

## Actual Behavior

Seems at first glance that a timeout exception may occur.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-07-09 15:06:26.000 UTC</summary>

This may relate to https://github.com/temporalio/sdk-java/issues/1903

</details>


---

<a id="2124"></a>

### #2124: MDC custom naming convention

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2124 |
| **State** | OPEN |
| **Author** | nikoncode (Mikita Karaliou) |
| **Created** | 2024-06-25 12:09:23.000 UTC (1y 6m ago) |
| **Updated** | 2024-08-27 08:58:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We want to have an ability (extension point) to control default MDC keys. Now they are statically defined in workers.

Why it's important:
* we have multiple stacks: Java + Python and trying to unite our services logs/metrics/traces with single naming conventions.
* we have logging based integration: sentry, metrics from logs, etc.



#### Comments (1)

<details>
<summary><strong>nikoncode</strong> commented on 2024-08-27 08:58:38.000 UTC</summary>

Guys, because of this we are implemented a lot of custom code in logging.

</details>


---

<a id="2117"></a>

### #2117: Allow customization of OTel span tags

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2117 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-06-18 18:48:27.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-18 18:55:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Go and Python and .NET and others use `temporalWorkflowID`, `temporalRunID`, `temporalActivityID`, etc but Java uses `workflowId` and `runId` Cannot change Java's defaults for compatibility reasons, but we should allow these to be customized so users can make them the same. Some SDKs like .NET already allow these to be customized.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-18 18:54:59.000 UTC</summary>

Note Java right now has an open tracing interceptor, not a open telemetry interceptor. If we create a first class open telemetry interceptor we can probably change the default name.

https://github.com/temporalio/sdk-java/tree/master/temporal-opentracing

Reactions: ‚ù§Ô∏è 1

</details>


---

<a id="2109"></a>

### #2109: WorkflowHistoryLoader fails to load decoded event history

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2109 |
| **State** | CLOSED |
| **Author** | ddavidyuk |
| **Created** | 2024-06-13 11:45:58.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-13 15:55:27.000 UTC |
| **Closed** | 2024-06-13 15:55:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`WorkflowHistoryLoader` should be able to load history from a file downloaded via Temporal UI / Temporal Cloud UI with "Decode History" option.

## Actual Behavior
`WorkflowHistoryLoader` fails when loading a file downloaded via Temporal UI / Temporal Cloud UI with "Decode History" option.

## Steps to Reproduce the Problem

1. Open any completed workflow execution in Temporal UI or Temporal Cloud UI
2. Click Download History with checked "Decode History" option.
3. Try to load the history from the downloaded file via `WorkflowHistoryLoader` API: `WorkflowHistoryLoader.readHistory(<path to the history JSON file>)`
4. `WorkflowHistoryLoader` fails with this exception (the actual payload replaced with ..., cannot provide it here):
```
io.temporal.common.converter.DataConverterException: com.google.protobuf.InvalidProtocolBufferException: Invalid value: {...} for expected type: BYTES
	at io.temporal.common.WorkflowExecutionHistory.fromJson(WorkflowExecutionHistory.java:79)
	at io.temporal.common.WorkflowExecutionHistory.fromJson(WorkflowExecutionHistory.java:63)
	at io.temporal.testing.WorkflowHistoryLoader.readHistory(WorkflowHistoryLoader.java:60)
...
Caused by: com.google.protobuf.InvalidProtocolBufferException: Invalid value: {...} for expected type: BYTES
	at com.google.protobuf.util.JsonFormat$ParserImpl.parseFieldValue(JsonFormat.java:1971)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeField(JsonFormat.java:1669)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeMessage(JsonFormat.java:1500)
	at com.google.protobuf.util.JsonFormat$ParserImpl.merge(JsonFormat.java:1458)
	at com.google.protobuf.util.JsonFormat$ParserImpl.parseFieldValue(JsonFormat.java:2018)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeRepeatedField(JsonFormat.java:1733)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeField(JsonFormat.java:1665)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeMessage(JsonFormat.java:1500)
	at com.google.protobuf.util.JsonFormat$ParserImpl.merge(JsonFormat.java:1458)
	at com.google.protobuf.util.JsonFormat$ParserImpl.parseFieldValue(JsonFormat.java:2018)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeField(JsonFormat.java:1669)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeMessage(JsonFormat.java:1500)
	at com.google.protobuf.util.JsonFormat$ParserImpl.merge(JsonFormat.java:1458)
	at com.google.protobuf.util.JsonFormat$ParserImpl.parseFieldValue(JsonFormat.java:2018)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeOneofField(JsonFormat.java:1708)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeField(JsonFormat.java:1667)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeMessage(JsonFormat.java:1500)
	at com.google.protobuf.util.JsonFormat$ParserImpl.merge(JsonFormat.java:1458)
	at com.google.protobuf.util.JsonFormat$ParserImpl.parseFieldValue(JsonFormat.java:2018)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeRepeatedField(JsonFormat.java:1733)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeField(JsonFormat.java:1665)
	at com.google.protobuf.util.JsonFormat$ParserImpl.mergeMessage(JsonFormat.java:1500)
	at com.google.protobuf.util.JsonFormat$ParserImpl.merge(JsonFormat.java:1458)
	at com.google.protobuf.util.JsonFormat$ParserImpl.merge(JsonFormat.java:1340)
	at com.google.protobuf.util.JsonFormat$Parser.merge(JsonFormat.java:472)
	at io.temporal.common.WorkflowExecutionHistory.fromJson(WorkflowExecutionHistory.java:77)
```

## Specifications

  - Version: Temporal Java SDK 1.23.2
  - Platform: Temporal Cloud UI, same issue with Temporal UI

## Additional details

We are testing our encrypting / compressing DataConverter, and would like to be able to download decoded event history for local testing with WorkflowReplayer class (to make sure the changes we make to our workflows are compatible with prior event histories).

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-13 15:55:27.000 UTC</summary>

The UI "Decode History" is designed for human consumption not SDK consumption and is not intended to be compatible with SDKs so it is not expected to work. Our docs generally recommend downloading history from the CLI or SDK to replay https://docs.temporal.io/develop/java/testing-suite#replay. 

We do also plan to add utilities inside the SDK to make it easier to decode encrypted payloads in history to make replay easier as well.

https://github.com/temporalio/features/issues/468

</details>


---

<a id="2106"></a>

### #2106: Confirm non-utf8 proto string behavior

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2106 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-06-11 17:41:09.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-12 21:38:55.000 UTC |
| **Closed** | 2024-06-12 21:38:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

In Go when we switched from gogoproto to common proto, we recognized that the former allowed invalid utf8 but not the latter. We have seen a potential case where a user _may_ have set invalid utf-8 in a proto `Failure` `message`. We need to confirm whether Java proto library even allows this (in either direction if possible, but especially at marshal time), and then assess our options.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-12 21:38:55.000 UTC</summary>

Confirmed the java proto library does not allow non-utf8 proto string

</details>


---

<a id="2086"></a>

### #2086: Upgrade grpc version , version 1.54.0 crashes JVM on Alpine

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2086 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2024-05-31 13:31:52.000 UTC (1y 7m ago) |
| **Updated** | 2025-02-26 19:21:12.000 UTC |
| **Closed** | 2025-02-26 19:20:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description


<img width="748" alt="image" src="https://github.com/temporalio/sdk-java/assets/514932/a6a5ecd6-1662-4f0b-b17f-5c21bc994874">

https://github.com/grpc/grpc-java/issues/10096#issuecomment-1521958350




#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-02-26 19:21:10.000 UTC</summary>

Java SDK `v1.28.0` updated `grpc`

</details>


---

<a id="2071"></a>

### #2071: KotlinObjectMapperFactory is not forwards compatible

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2071 |
| **State** | OPEN |
| **Author** | Sineaggi (Clayton Walker) |
| **Created** | 2024-05-20 19:33:38.000 UTC (1y 7m ago) |
| **Updated** | 2025-11-12 15:15:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
KotlinObjectMapperFactory works

## Actual Behavior
KotlinObjectMapperFactory crashes with MethodNotFoundError

## Steps to Reproduce the Problem

  1. Use temporal kotlin
  1. Upgrade jackson kotlin library
  1. Crash

## Specifications

  - Version:
  - Platform:

Instead of using a deprecated method, it would have been best to try using the builder first, then fall back to the deprecated KotlinModule constructor. Alternatively, we should just use the builder as we can't even pick which KotlinModule constructor we compile against.

#### Comments (1)

<details>
<summary><strong>ivanmartinvalle</strong> commented on 2025-11-12 15:15:39.000 UTC</summary>

Note the workaround:
```kotlin
val mapper = JacksonJsonPayloadConverter.newDefaultObjectMapper()
mapper.registerModule(KotlinModule.Builder().build())
return DefaultDataConverter.newDefaultInstance()
    .withPayloadConverterOverrides(JacksonJsonPayloadConverter(mapper))
```

Note that I did expect temporal-kotlin to automatically configure the kotlin module, as did [this user here](https://github.com/temporalio/sdk-java/issues/1387), but unfortunately that was marked as wont-fix. The referenced issue includes the same workaround but with the `KotlinObjectMapperFactory` issue.

</details>


---

<a id="2069"></a>

### #2069: Wrap GRPC::CANCELED and DEADLINE_EXCEEDED in an SDK Timeout exception for Update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2069 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-05-18 00:43:04.000 UTC (1y 7m ago) |
| **Updated** | 2024-08-06 21:52:24.000 UTC |
| **Closed** | 2024-08-06 21:52:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

So that users only have to catch one predictable exception

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-06-05 20:01:23.000 UTC</summary>

See https://github.com/temporalio/features/issues/483#issuecomment-2150832036 for implementation details

</details>


---

<a id="2065"></a>

### #2065: It's impossible to send unset duration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2065 |
| **State** | CLOSED |
| **Author** | Duzhinsky (Dmitrii Duzhinskii) |
| **Created** | 2024-05-16 19:44:46.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-21 14:35:31.000 UTC |
| **Closed** | 2024-05-21 14:35:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When `java.util.Duration` is `null` in an options class like `SchedulePolicy` it is treated as an unset value in a protobuf message _in some cases_

## Actual Behavior

`null` values are sent as zero duration. There was a TODO in the appropriate method about refactoring this behaviour, but was removed in #1950

https://github.com/temporalio/sdk-java/blob/ec18bc86d52f23add2dc97682d94c629e6282bf1/temporal-sdk/src/main/java/io/temporal/internal/common/ProtobufTimeUtils.java#L43-L48

## A problem 

I'm creating schedules using the following code:
```java
...
var policy = SchedulePolicy.newBuilder()
                .setOverlap(ScheduleOverlapPolicy.SCHEDULE_OVERLAP_POLICY_BUFFER_ONE)
                .build();
var schedule Schedule.newBuilder()
                .setAction(actionStartWorkflow)
                .setSpec(spec)
                .setPolicy(policy)
                .build();
```
Which causes sending `0` in the `catchupWindow` property of `SchedulePolicy`. Hence, server side treats it as `0` and uses `MinCatchupWindow` (=10 sec) instead of expected `DefaultCatchupWindow` (=1yr)

https://github.com/temporalio/temporal/blob/aca0d911a908b2584f4cffcc73425c5119dbe722/service/worker/scheduler/workflow.go#L750-L759

## Steps to Reproduce the Problem

  1. Create a schedule using the code above
  2. Check its catchupWindow




#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-05-17 02:51:05.000 UTC</summary>

Most of time the Temporal server treats zero and unset durations the same, unfortunately it seems like schedules makes a distinction. Probably need to add conversion functions for that preserve null for time conversion.

</details>


---

<a id="2058"></a>

### #2058: Set Temporal-Namespace header on every namespace-specific gRPC request

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2058 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-09 13:08:39.000 UTC (1y 8m ago) |
| **Updated** | 2025-02-04 17:43:30.000 UTC |
| **Closed** | 2025-02-04 17:43:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/475. It needs to be an interceptor surely, but unsure how the implementation will do this generically. One way is via reflection to call `getNamespace() string` assuming it's not deemed too expensive (probably not), but this is left up to the implementer. All that matters is that new RPCs that come in with namespaces automatically have the header set.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-02-03 15:32:06.000 UTC</summary>

Note, once this is released, any samples/docs that reference explicit namespace setting we can probably alter

Reactions: üëç 1

</details>


---

<a id="2054"></a>

### #2054: Local activity support for next-retry-delay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2054 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-06 16:33:14.000 UTC (1y 8m ago) |
| **Updated** | 2024-06-01 00:48:34.000 UTC |
| **Closed** | 2024-06-01 00:48:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Re https://github.com/temporalio/features/issues/419, it was decided we need to support next retry delay in application failures from local activity too. Implementation details are still pending.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-06-01 00:48:33.000 UTC</summary>

closed by https://github.com/temporalio/sdk-java/pull/2081

</details>


---

<a id="2016"></a>

### #2016: Investigate bad `isReplaying` value on direct query when workflow is not in cache

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2016 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-03-26 17:48:01.000 UTC (1y 9m ago) |
| **Updated** | 2024-05-08 14:59:40.000 UTC |
| **Closed** | 2024-05-08 14:59:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`isReplaying()`  is true when replaying and false when not replaying

## Actual Behavior
`isReplaying()`  is false when the workflow is replaying for a query


## Steps to Reproduce the Problem

  1.Start a workflow that immediately waits for a signal
  2.Restart the worker running the above workflow
  3.Send a query to the workflow

## Specifications

  - Version: v1.23.0
  - Platform: mac 


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-04-02 21:47:33.000 UTC</summary>

Auditing the replay code 

```
    if (replaying
        && !hasNextEvent
        && (event.getEventType() == EventType.EVENT_TYPE_WORKFLOW_TASK_STARTED
            || WorkflowExecutionUtils.isWorkflowTaskClosedEvent(event))) {
      replaying = false;
    }
```

https://github.com/temporalio/sdk-java/blob/bc726c9ad4646fc5d14e91bcea11190ff7537ca0/temporal-sdk/src/main/java/io/temporal/internal/statemachines/WorkflowStateMachines.java#L427

This check is flawed since if we receive a query after a workflow task that didn't generate a command will cause the Java SDK to incorrectly assume the workflow is no longer replaying.  



</details>


---

<a id="1996"></a>

### #1996: SpringBoot - add "server-name" property to connection options

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1996 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-02-27 03:41:02.000 UTC (1y 10m ago) |
| **Updated** | 2024-02-29 16:19:23.000 UTC |
| **Closed** | 2024-02-29 16:19:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | tsurdilo |
| **Milestone** | None |

#### Description

Feature request to add "server-name" to connection options. This can be useful for users going through PrivateLink or similar.
This would use ManagedChannelBuilder#overrideAuthority to set the server name directly rather than getting it from target.

Note this is currently possible to configure via TemporalOptionsCustomizer, but is useful for convenience. 

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-02-27 13:47:00.000 UTC</summary>

This is a TLS-specific option I believe, can we make sure it is presented the same way as other TLS options?

</details>


---

<a id="1965"></a>

### #1965: Heartbeat activity retries first heartbeat data instead of last

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1965 |
| **State** | CLOSED |
| **Author** | rburgst |
| **Created** | 2024-01-06 19:36:16.000 UTC (2 years ago) |
| **Updated** | 2025-01-06 23:45:17.000 UTC |
| **Closed** | 2025-01-06 23:45:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I have a workflow that schedules activities with 5 elements to process, on every iteration of the 5 elements, I remove the currently processed row and update the heartbeat with the remaining elements, therefore, we call heartbeat with

1. hearbeat (remaining = 4)
2. hearbeat(remaining = 3)
3. heartbeat(remaining=2)
4. heartbeat(remaining=1)

If I throw an exception in the 4th iteration, then I would expect a retry that calls me with the remaining 1 elements

## Actual Behavior

however, I am called with remaining 4)

## Steps to Reproduce the Problem

  1. define an activity as follows

```java
package io.temporal.samples.springboot.propagation;

import io.temporal.activity.Activity;
import io.temporal.activity.ActivityExecutionContext;
import io.temporal.spring.boot.ActivityImpl;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.*;

import static io.temporal.samples.springboot.propagation.ChunkedWorkflow.*;

@Component
@ActivityImpl(taskQueues = "RowTaskQueue")
public class ChunkProcessingActivityImpl implements ChunkProcessingActivity {
    private static final Logger log = LoggerFactory.getLogger(ChunkProcessingActivityImpl.class);

    @AllArgsConstructor
    @NoArgsConstructor
    public static final class HeartbeatData {
        List<String> remaining;
        ProcessingResult progressSoFar;
    }

    @Override
    public ProcessingResult processRows(List<String> rowId) {

        ActivityExecutionContext context = Activity.getExecutionContext();
        Optional<HeartbeatData> heartbeatDetails = context.getHeartbeatDetails(HeartbeatData.class);

        ProcessingResult result =
                new ProcessingResult();
        result.rowsRead = 0;
        result.rowsWritten = 0;

        HeartbeatData heartbeatData = heartbeatDetails.orElse(new HeartbeatData(rowId, result));
        List<String> remainingUuids = heartbeatData.remaining;
        result = heartbeatData.progressSoFar;
        log.info("propagating {}, heartbeat {}, rows {}", remainingUuids.size(), heartbeatDetails, remainingUuids);

        int index = 0;

        List<String> newRemaining = new ArrayList<>(remainingUuids);
        for (String uuid : remainingUuids) {
            if (index == 4) {
                throw new RuntimeException("foo error for uuid " + uuid);
            }
            newRemaining.remove(uuid);
            ProcessingResult innerResult = processSingleRow(UUID.fromString(uuid));
            log.info("   sending heartbeat with remaining {}, {}", newRemaining.size(), newRemaining);
            result.rowsRead += innerResult.rowsRead;
            result.rowsWritten += innerResult.rowsWritten;
            result.rowsProcessed.addAll(innerResult.rowsProcessed);
            context.heartbeat(new HeartbeatData(newRemaining, result));
            index++;
        }
        log.info("processing {} rows {} ‚Ä¶ done", remainingUuids.size(), remainingUuids);
        log.info("processing result {}", result);


        return result;
    }

    private ProcessingResult processSingleRow(UUID uuid) {

        ProcessingResult result =
                new ProcessingResult();
        result.rowsRead = 1;
        result.rowsWritten = 1;
        log.info("processing single row {}", uuid);
        result.addRowId(uuid.toString());
        return result;
    }
}
```

  2. start the server with `gradle bootRun`
  3. on the hello world page, start the job
  4. watch the spring boot log

```
2024-01-06T20:17:15.028+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : propagating 5, heartbeat Optional.empty, rows [4ab57ee9-0daf-4e46-a6de-1e0643daeec1, 557d0cb6-e9a9-4a57-a8d7-d261a2bc90fd, 1350507c-4126-4a0a-868d-d0a96e90c744, b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:15.028+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row 4ab57ee9-0daf-4e46-a6de-1e0643daeec1
2024-01-06T20:17:15.028+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 4, [557d0cb6-e9a9-4a57-a8d7-d261a2bc90fd, 1350507c-4126-4a0a-868d-d0a96e90c744, b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:15.049+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row 557d0cb6-e9a9-4a57-a8d7-d261a2bc90fd
2024-01-06T20:17:15.049+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 3, [1350507c-4126-4a0a-868d-d0a96e90c744, b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:15.049+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row 1350507c-4126-4a0a-868d-d0a96e90c744
2024-01-06T20:17:15.049+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 2, [b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:15.049+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row b61a2443-5b5a-4888-bc37-f3e504340e77
2024-01-06T20:17:15.049+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 1, [56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:15.049+01:00  WARN 4593 --- [temporal-samples] [ce="default": 1] tivityTaskExecutors$ActivityTaskExecutor : Activity failure. ActivityId=646434e9-72c7-313a-8301-214499ef42ea, activityType=ProcessRows, attempt=1

java.lang.RuntimeException: foo error for uuid 56115510-3c5c-4bc8-ae77-e206bdf9f4fb
	at io.temporal.samples.springboot.propagation.ChunkProcessingActivityImpl.processRows(ChunkProcessingActivityImpl.java:68) ~[main/:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]
	at io.temporal.internal.activity.RootActivityInboundCallsInterceptor$POJOActivityInboundCallsInterceptor.executeActivity(RootActivityInboundCallsInterceptor.java:64) ~[temporal-sdk-1.22.2.jar:na]
	at io.temporal.internal.activity.RootActivityInboundCallsInterceptor.execute(RootActivityInboundCallsInterceptor.java:43) ~[temporal-sdk-1.22.2.jar:na]
	at io.temporal.internal.activity.ActivityTaskExecutors$BaseActivityTaskExecutor.execute(ActivityTaskExecutors.java:107) ~[temporal-sdk-1.22.2.jar:na]
	at io.temporal.internal.activity.ActivityTaskHandlerImpl.handle(ActivityTaskHandlerImpl.java:124) ~[temporal-sdk-1.22.2.jar:na]
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handleActivity(ActivityWorker.java:278) ~[temporal-sdk-1.22.2.jar:na]
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:243) ~[temporal-sdk-1.22.2.jar:na]
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:216) ~[temporal-sdk-1.22.2.jar:na]
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:105) ~[temporal-sdk-1.22.2.jar:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) ~[na:na]
	at java.base/java.lang.Thread.run(Thread.java:840) ~[na:na]


>>>>> here we are back with the first heartbeat details rather than only the single one

2024-01-06T20:17:16.092+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : propagating 4, heartbeat Optional[io.temporal.samples.springboot.propagation.ChunkProcessingActivityImpl$HeartbeatData@7d0ec774], rows [557d0cb6-e9a9-4a57-a8d7-d261a2bc90fd, 1350507c-4126-4a0a-868d-d0a96e90c744, b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:16.093+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row 557d0cb6-e9a9-4a57-a8d7-d261a2bc90fd
2024-01-06T20:17:16.093+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 3, [1350507c-4126-4a0a-868d-d0a96e90c744, b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:16.096+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row 1350507c-4126-4a0a-868d-d0a96e90c744
2024-01-06T20:17:16.096+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 2, [b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:16.096+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row b61a2443-5b5a-4888-bc37-f3e504340e77
2024-01-06T20:17:16.096+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 1, [56115510-3c5c-4bc8-ae77-e206bdf9f4fb]
2024-01-06T20:17:16.096+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing single row 56115510-3c5c-4bc8-ae77-e206bdf9f4fb
2024-01-06T20:17:16.096+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    :    sending heartbeat with remaining 0, []
2024-01-06T20:17:16.096+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing 4 rows [557d0cb6-e9a9-4a57-a8d7-d261a2bc90fd, 1350507c-4126-4a0a-868d-d0a96e90c744, b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb] ‚Ä¶ done
2024-01-06T20:17:16.097+01:00  INFO 4593 --- [temporal-samples] [ce="default": 1] i.t.s.s.p.ChunkProcessingActivityImpl    : processing result ChunkedWorkflow.ProcessingResult(rowsRead=5, rowsWritten=5, rowsProcessed=[4ab57ee9-0daf-4e46-a6de-1e0643daeec1, 557d0cb6-e9a9-4a57-a8d7-d261a2bc90fd, 1350507c-4126-4a0a-868d-d0a96e90c744, b61a2443-5b5a-4888-bc37-f3e504340e77, 56115510-3c5c-4bc8-ae77-e206bdf9f4fb])
```
## Specifications

  - Version:1.22.2
  - Platform: mac / java 17 / spring boot 3.2

Sample repo: https://github.com/rburgst/temporal-java-heartbeat-problem
( the springboot sample)


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-08 18:06:17.000 UTC</summary>

~Heartbeats may not always be sent to the Cluster‚Äîthey may be throttled by the Worker.~

~see more details here https://docs.temporal.io/activities#throttling~

Edit: On review in this particular case the heartbeat details should be propagated as the Java SDK should be setting 

https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/request_response.proto#L504



</details>


---

<a id="1963"></a>

### #1963: Schedule creation should create tracing span by default

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1963 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-01-03 21:12:07.000 UTC (2 years ago) |
| **Updated** | 2024-03-05 18:29:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

### Describe the solution you'd like

When the tracing interceptor is in use, by default creating a schedule should create a span for the schedule and set it on the workflow header if the action is starting a workflow. Users need to be able to opt-out in their tracing interceptor options.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-03-05 18:29:58.000 UTC</summary>

(do not blindly implement as is, see discussion starting with comment https://github.com/temporalio/features/issues/394#issuecomment-1966551344 before proceeding)

</details>


---

<a id="1960"></a>

### #1960: json-path-2.8.0.jar: 1 vulnerabilities (highest severity is: 5.3)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1960 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-12-28 18:16:38.000 UTC (2 years ago) |
| **Updated** | 2025-06-03 14:53:37.000 UTC |
| **Closed** | 2025-06-03 14:53:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>json-path-2.8.0.jar</b></p></summary>

<p>A library to query and verify JSON</p>
<p>Library home page: <a href="https://github.com/jayway/JsonPath">https://github.com/jayway/JsonPath</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.jayway.jsonpath/json-path/2.8.0/b4ab3b7a9e425655a0ca65487bbbd6d7ddb75160/json-path-2.8.0.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (json-path version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-51074](https://www.mend.io/vulnerability-database/CVE-2023-51074) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 5.3 | json-path-2.8.0.jar | Direct | com.jayway.jsonpath:json-path:2.9.0 | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2023-51074</summary>


###  Vulnerable Library - <b>json-path-2.8.0.jar</b></p>

<p>A library to query and verify JSON</p>
<p>Library home page: <a href="https://github.com/jayway/JsonPath">https://github.com/jayway/JsonPath</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.jayway.jsonpath/json-path/2.8.0/b4ab3b7a9e425655a0ca65487bbbd6d7ddb75160/json-path-2.8.0.jar</p>
<p>

Dependency Hierarchy:
  - :x: **json-path-2.8.0.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
json-path v2.8.0 was discovered to contain a stack overflow via the Criteria.parse() method.

<p>Publish Date: 2023-12-27
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-51074>CVE-2023-51074</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: Low
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://www.cve.org/CVERecord?id=CVE-2023-51074">https://www.cve.org/CVERecord?id=CVE-2023-51074</a></p>
<p>Release Date: 2023-12-27</p>
<p>Fix Resolution: com.jayway.jsonpath:json-path:2.9.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-03 14:53:36.000 UTC</summary>

Resolved in master

</details>


---

<a id="1955"></a>

### #1955: Worker dynamic config

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1955 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-12-15 15:59:53.000 UTC (2 years ago) |
| **Updated** | 2025-02-04 19:00:13.000 UTC |
| **Closed** | 2025-02-04 19:00:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/388


#### Comments (1)

<details>
<summary><strong>josh-berry</strong> commented on 2025-02-04 19:00:11.000 UTC</summary>

Unclear what/how we want to do this, and a lot has changed since this was opened (e.g. we are building Nexus now, which could be a transport for config changes). Closing for now.

</details>


---

<a id="1953"></a>

### #1953: Add WorkflowImplementationOptions to TestWorkflowExtension

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1953 |
| **State** | CLOSED |
| **Author** | mmccawley-chegg (Matthew McCawley) |
| **Created** | 2023-12-06 19:21:24.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-06 22:00:06.000 UTC |
| **Closed** | 2023-12-06 22:00:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

If a TestWorkflowExtension contains `workflowTypes`, those types are registered with the worker using the default WorkflowImplementationOptions. One option that is commonly used is to set the `failWorkflowExceptionTypes` in order to throw an exception from the workflow that will not be retried. In this case, there is not an easy way to configure this same behavior for testing.

This can be fixed by adding a WorkflowImplementationOptions property to TestWorkflowExtension and its builder to be used in `beforeEach` when calling `worker.registerWorkflowImplementationTypes`. Using a default value of `WorkflowImplementationOptions.newBuilder().build()` will preserve the existing behavior if no value is provided.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-12-06 22:00:05.000 UTC</summary>

This is already implemented and will be included in the next Java SDK release

https://github.com/temporalio/sdk-java/commit/bb43d3757fa50c32547da6d26d7f557390ed877d

Reactions: üëç 1

</details>


---

<a id="1927"></a>

### #1927: io.grpc:grpc-core:1.59.0 Has a breaking ABI change requiring us to update our grpc dependency

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1927 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-07 15:55:37.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-09 15:43:24.000 UTC |
| **Closed** | 2023-11-09 15:43:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

From `grpc-java` https://github.com/grpc/grpc-java/releases/tag/v1.59.0

>PLANNED ABI BREAKAGE!
This breaks the ABI of the @ExperimentalApi classes listed below.
This does not impact source code (API); it only impacts code compiled with a different version of gRPC than it runs with (ABI).
Users that recompiled their code using grpc-java [v1.36.0](https://github.com/grpc/grpc-java/releases/tag/v1.36.0) (released on Feb 23, 2021) and later, ARE NOT AFFECTED.
Users that compiled their source using grpc-java earlier than v1.36.0 may need to recompile when upgrading to grpc-java v1.59.0.


we will need to upgrade out grpc generator to at least [v1.36.0](https://github.com/grpc/grpc-java/releases/tag/v1.36.0) and possibly or protoc compiler as well since our current one uses deprecated methods 


Slack thread:
https://temporalio.slack.com/archives/CTRCR8RBP/p1699282239526229


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-09 15:43:24.000 UTC</summary>

No work needed. Root cause was the user was not also updating all the transitive dependencies as well causing some to be on `1.58.0` and some '1.59.0'  causing the issue.

</details>


---

<a id="1914"></a>

### #1914: Support cancellation of long client calls

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1914 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-10-27 19:42:37.000 UTC (2y 2m ago) |
| **Updated** | 2023-10-27 19:55:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Provide some way for users to _cancel_ a long client call such as getting workflow result or getting update result. Also consider providing a timeout utility on this that cancels after a certain amount of time. Try to follow common Java practices here if possible.

(sorry if an issue exists for this already)

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-27 19:55:09.000 UTC</summary>

related (duplicate) of https://github.com/temporalio/sdk-java/issues/1212

Reactions: üëç 1

</details>


---

<a id="1913"></a>

### #1913: Remove WorkflowClientCallsInterceptor.pollWorkflowUpdate

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1913 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-10-27 19:38:42.000 UTC (2y 2m ago) |
| **Updated** | 2023-10-30 23:12:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

This does not need to be interceptable any more than getting a workflow result does

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-30 23:11:50.000 UTC</summary>

Getting the workflow result in an async manner is intercept-able in Java so this is inconsistent with the rest of the Java SDK

</details>


---

<a id="1903"></a>

### #1903: Test Server hanging or reporting completed on start update requests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1903 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2023-10-20 23:58:53.000 UTC (2y 2m ago) |
| **Updated** | 2024-07-30 15:22:03.000 UTC |
| **Closed** | 2024-07-30 15:22:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

While testing update for Python SDK against the Test server, the server was either hanging (when downloaded from the CDN) or reporting the workflow was complete when it wasn't/shouldn't be (running locally from this repo) after one successful update call.

Not much to go on here since there are no logs really and I haven't had time to dig in with a debugger yet. Opening this so I have an issue to reference in skipped tests in Python.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-01-22 13:57:30.000 UTC</summary>

This same issue is happening in .NET: https://github.com/temporalio/sdk-dotnet/issues/179. Updates are accepted but then nothing happens. I too have not debugged this.

</details>


---

<a id="1901"></a>

### #1901: Failed Read-Only check should cause a WFT failure in an update validator, not fail the update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1901 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-18 14:12:39.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-29 15:06:44.000 UTC |
| **Closed** | 2023-11-29 15:06:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Failed read-Only check should cause a WFT failure 

## Actual Behavior
Failed read-Only check fails the update



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-29 15:06:44.000 UTC</summary>

closed by https://github.com/temporalio/sdk-java/pull/1918

</details>


---

<a id="1883"></a>

### #1883: Unable to build on Ubuntu Linux for aarch64 (ARM)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1883 |
| **State** | CLOSED |
| **Author** | uromahn (Ulrich Romahn) |
| **Created** | 2023-10-04 21:44:26.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-10 20:54:32.000 UTC |
| **Closed** | 2023-10-10 20:54:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I am trying to build the sdk-java from source on my Ubuntu Linux running on aarch64 (ARM) HW architecture. I am unable to do that since the protoc executable being pulled in is for Mac OS X.
See `build.gradle` in `temporal-serviceclient`:
```
    protoc {
        artifact = 'com.google.protobuf:protoc:3.10.1' + (System.getProperty("os.arch") == 'aarch64' ? ':osx-x86_64' : '')
    }

```

**Describe the solution you'd like**
The gradle.build file needs to also consider the OS and pull in the correct protoc executable.
For Linux aarch it should be [protoc-3.10.1-linux-aarch_64.exe](https://repo1.maven.org/maven2/com/google/protobuf/protoc/3.10.1/protoc-3.10.1-linux-aarch_64.exe)

**Describe alternatives you've considered**
Building from source on OSK

**Additional context**
- none -


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-10-06 16:06:47.000 UTC</summary>

Yeah makes sense, looks like an oversight.

</details>


---

<a id="1855"></a>

### #1855: Typed Search Attributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1855 |
| **State** | CLOSED |
| **Author** | lorensr (Loren ‚ò∫Ô∏è) |
| **Created** | 2023-08-31 22:17:36.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-31 22:19:52.000 UTC |
| **Closed** | 2023-08-31 22:19:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Implementation of [typed search attributes](https://github.com/temporalio/proposals/blob/master/sdk-typed-search-attributes.md).

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-31 22:19:52.000 UTC</summary>

Typed search attributes is already implemented in Java https://github.com/temporalio/sdk-java/pull/1782

</details>


---

<a id="1850"></a>

### #1850: Exponential backoff for all server requests (including/especially poll)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1850 |
| **State** | CLOSED |
| **Author** | josh-berry (Josh Berry) |
| **Created** | 2023-08-27 22:05:19.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-29 13:41:47.000 UTC |
| **Closed** | 2023-08-29 13:41:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I did some digging in the sdk-java codebase, and it seems we retry polling on a fixed interval, rather than doing exponential backoff. (Is this actually true or am I misreading the code? I'm looking at, for example, src/main/java/io/temporal/serviceclient/GrpcDeadlineInterceptor.java)

We should be doing exponential backoff for anything talking to the server (including activity and workflow polling), because if the server is under high load, _not_ doing backoff means that clients cannot react to reduce load.

I think this is a superset of #1258 and #947.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-08-27 22:19:34.000 UTC</summary>

>Is this actually true or am I misreading the code?

I believe you are misreading the code. The Java SDK does do exponential backoff if you look at [GrpcSyncRetier](https://github.com/temporalio/sdk-java/blob/c0123572192a57c1cfdcf870363f1471840dc7fd/temporal-serviceclient/src/main/java/io/temporal/internal/retryer/GrpcSyncRetryer.java#L34) and the BackoffThrottler you will see it is exponential.

</details>


---

<a id="1842"></a>

### #1842: okhttp-4.10.0.jar: 1 vulnerabilities (highest severity is: 7.5)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1842 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-08-16 14:17:49.000 UTC (2y 4m ago) |
| **Updated** | 2025-06-03 14:53:03.000 UTC |
| **Closed** | 2025-06-03 14:53:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>okhttp-4.10.0.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-remote-data-encoder/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.squareup.okio/okio-jvm/3.0.0/ab5a73fa2ccb4a36b0b5c69fe10b16d0255bcf8/okio-jvm-3.0.0.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f922c0655c0b78898f87c4225edd5b94e3b57530">f922c0655c0b78898f87c4225edd5b94e3b57530</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (okhttp version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-3635](https://www.mend.io/vulnerability-database/CVE-2023-3635) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | okio-jvm-3.0.0.jar | Transitive | 4.11.0 | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-3635</summary>


###  Vulnerable Library - <b>okio-jvm-3.0.0.jar</b></p>

<p>A modern I/O API for Java</p>
<p>Path to dependency file: /temporal-remote-data-encoder/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.squareup.okio/okio-jvm/3.0.0/ab5a73fa2ccb4a36b0b5c69fe10b16d0255bcf8/okio-jvm-3.0.0.jar</p>
<p>

Dependency Hierarchy:
  - okhttp-4.10.0.jar (Root Library)
    - okio-3.0.0.jar
      - :x: **okio-jvm-3.0.0.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f922c0655c0b78898f87c4225edd5b94e3b57530">f922c0655c0b78898f87c4225edd5b94e3b57530</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
GzipSource does not handle an exception that might be raised when parsing a malformed gzip buffer. This may lead to denial of service of the Okio client when handling a crafted GZIP archive, by using the GzipSource class.



<p>Publish Date: 2023-07-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-3635>CVE-2023-3635</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://www.cve.org/CVERecord?id=CVE-2023-3635">https://www.cve.org/CVERecord?id=CVE-2023-3635</a></p>
<p>Release Date: 2023-07-12</p>
<p>Fix Resolution (com.squareup.okio:okio-jvm): 3.4.0</p>
<p>Direct dependency fix Resolution (com.squareup.okhttp3:okhttp): 4.11.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-03 14:53:01.000 UTC</summary>

Fixed is master

</details>


---

<a id="1840"></a>

### #1840: Spring Boot 3 native image support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1840 |
| **State** | CLOSED |
| **Author** | zhxnlai (Zhixuan Lai) |
| **Created** | 2023-08-14 17:43:55.000 UTC (2y 4m ago) |
| **Updated** | 2024-01-20 06:15:07.000 UTC |
| **Closed** | 2024-01-20 06:15:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

During native image build, Spring Boot auto-configuration fails with the following error message:
```
[           main] ocalVariableTableParameterNameDiscoverer : Using deprecated '-debug' fallback for parameter name resolution. Compile the affected code with '-parameters' instead or avoid its introspection: io.temporal.spring.boot.autoconfigure.properties.WorkerProperties
Exception in thread "main" org.springframework.boot.context.properties.bind.MissingParametersCompilerArgumentException: Constructor binding in a native image requires compilation with -parameters but the following classes were compiled without it:
	io.temporal.spring.boot.autoconfigure.properties.WorkerProperties
	io.temporal.spring.boot.autoconfigure.properties.WorkerProperties$CapacityConfigurationProperties
	io.temporal.spring.boot.autoconfigure.properties.TemporalProperties
	io.temporal.spring.boot.autoconfigure.properties.WorkerProperties$RateLimitsConfigurationProperties
	io.temporal.spring.boot.autoconfigure.properties.NamespaceProperties$WorkflowCacheProperties

	at org.springframework.boot.context.properties.bind.BindableRuntimeHintsRegistrar.registerHints(BindableRuntimeHintsRegistrar.java:100)
	at org.springframework.boot.context.properties.ConfigurationPropertiesBeanFactoryInitializationAotProcessor$ConfigurationPropertiesReflectionHintsContribution.applyTo(ConfigurationPropertiesBeanFactoryInitializationAotProcessor.java:74)
	at org.springframework.context.aot.BeanFactoryInitializationAotContributions.applyTo(BeanFactoryInitializationAotContributions.java:78)
	at org.springframework.context.aot.ApplicationContextAotGenerator.lambda$processAheadOfTime$0(ApplicationContextAotGenerator.java:58)
	at org.springframework.context.aot.ApplicationContextAotGenerator.withCglibClassHandler(ApplicationContextAotGenerator.java:67)
	at org.springframework.context.aot.ApplicationContextAotGenerator.processAheadOfTime(ApplicationContextAotGenerator.java:53)
	at org.springframework.context.aot.ContextAotProcessor.performAotProcessing(ContextAotProcessor.java:106)
	at org.springframework.context.aot.ContextAotProcessor.doProcess(ContextAotProcessor.java:84)
	at org.springframework.context.aot.ContextAotProcessor.doProcess(ContextAotProcessor.java:49)
	at org.springframework.context.aot.AbstractAotProcessor.process(AbstractAotProcessor.java:82)
	at org.springframework.boot.SpringApplicationAotProcessor.main(SpringApplicationAotProcessor.java:80)

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':processAot'.
```

**Describe the solution you'd like**
Add the following to `temporal-spring-boot-autoconfigure-alpha/build.gradle`
```
// build.gradle
tasks.withType<JavaCompile> { options.compilerArgs = options.compilerArgs + "-parameters" }
```



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-01-20 06:15:06.000 UTC</summary>

closed by https://github.com/temporalio/sdk-java/pull/1877

</details>


---

<a id="1788"></a>

### #1788: Add build id versioning feature support to test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1788 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2023-06-15 18:14:49.000 UTC (2y 6m ago) |
| **Updated** | 2025-05-07 00:26:47.000 UTC |
| **Closed** | 2025-05-07 00:26:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The new APIs we added for build id / worker versioning should be implemented on test server... assuming we keep going with it.

This means implementing the workflow service RPCs:
* `UpdateWorkerBuildIdCompatibility`
* `GetWorkerBuildIdCompatibility`
* `GetWorkerTaskReachability`

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-07 00:26:46.000 UTC</summary>

Closing since we are no longer keeping these APIs

</details>


---

<a id="1768"></a>

### #1768: spring-boot-autoconfigure-2.7.9.jar: 1 vulnerabilities (highest severity is: 7.5)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1768 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-05-19 13:48:00.000 UTC (2y 7m ago) |
| **Updated** | 2023-10-10 17:05:20.000 UTC |
| **Closed** | 2023-10-10 17:05:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-autoconfigure-2.7.9.jar</b></p></summary>

<p>Spring Boot AutoConfigure</p>
<p>Library home page: <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p>
<p>Path to dependency file: /temporal-spring-boot-autoconfigure-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-autoconfigure/2.7.9/849b238dd024101cad8d107b4a8b0906f75003d5/spring-boot-autoconfigure-2.7.9.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-autoconfigure/2.7.9/849b238dd024101cad8d107b4a8b0906f75003d5/spring-boot-autoconfigure-2.7.9.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-autoconfigure version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-20883](https://www.mend.io/vulnerability-database/CVE-2023-20883) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | spring-boot-autoconfigure-2.7.9.jar | Direct | 2.7.12 | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-20883</summary>


###  Vulnerable Library - <b>spring-boot-autoconfigure-2.7.9.jar</b></p>

<p>Spring Boot AutoConfigure</p>
<p>Library home page: <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p>
<p>Path to dependency file: /temporal-spring-boot-autoconfigure-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-autoconfigure/2.7.9/849b238dd024101cad8d107b4a8b0906f75003d5/spring-boot-autoconfigure-2.7.9.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-autoconfigure/2.7.9/849b238dd024101cad8d107b4a8b0906f75003d5/spring-boot-autoconfigure-2.7.9.jar</p>
<p>

Dependency Hierarchy:
  - :x: **spring-boot-autoconfigure-2.7.9.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In Spring Boot versions 3.0.0 - 3.0.6, 2.7.0 - 2.7.11, 2.6.0 - 2.6.14, 2.5.0 - 2.5.14 and older unsupported versions, there is potential for a denial-of-service (DoS) attack if Spring MVC is used together with a reverse proxy cache.

<p>Publish Date: 2023-05-26
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-20883>CVE-2023-20883</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://spring.io/security/cve-2023-20883">https://spring.io/security/cve-2023-20883</a></p>
<p>Release Date: 2023-05-26</p>
<p>Fix Resolution: 2.7.12</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>

#### Comments (1)

<details>
<summary><strong>skurlow-bigw</strong> commented on 2023-10-04 22:39:41.000 UTC</summary>

Can you pls fix this by upgrading spring boot as it is flagged by Snyk as a High risk issue? Thanks.

</details>


---

<a id="1763"></a>

### #1763: Register Same Interface Multiple Times

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1763 |
| **State** | CLOSED |
| **Author** | MrThreepwood |
| **Created** | 2023-05-11 22:58:08.000 UTC (2y 8m ago) |
| **Updated** | 2024-12-23 10:35:31.000 UTC |
| **Closed** | 2024-12-23 10:35:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Firstly, this may just be a question, it's likely that I'm missing/misunderstanding something.

**Is your feature request related to a problem? Please describe.**
We would like to use temporal as a testing framework. Each workflow needs to be wrapped in some logic to best handle creating traces (we're using Data Dog for trace information and error reporting) and reporting errors. We don't mind (and even prefer) all the test entry points having the same signature. So, from a language standpoint this is very simple, we have a single abstract class that handles the initial signal and has all the trace creation logic. It then calls a set function on the actual implementation to handle the workflow. The problem I'm running into is that I'm not sure how to register this with the java sdk. It's expecting an interface declared in the top level class, and has no way to register the same interface/abstract class multiple times with different names (other SDK look like they allow registering a workflow name with workflow options)

**Describe the solution you'd like**
Preferably I'd like something like the Go api that allows you to register a function (or class/factory) and override its name in the registration to allow registering multiple workflows with the same worker. Ideally I'd like to not require an interface either.

**Describe alternatives you've considered**
We could simply create a new worker for each test, but that's likely to end up with hundreds of workers all long-polling temporal for work, which doesn't seem ideal.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 10:35:31.000 UTC</summary>

A workflow interface represents a workflow type, a worker can only have one implementation for each workflow type. This situation sounds like they each are different workflow type's so they should each have their own interface. Alternatively you could use a [dynamic workflow](https://github.com/temporalio/samples-java/blob/69db54524cccd94634cd81a551c724312e74c471/core/src/main/java/io/temporal/samples/hello/HelloDynamic.java#L38) and switch in the workflow.

</details>


---

<a id="1751"></a>

### #1751: Making activity prefix and name generation pluggable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1751 |
| **State** | CLOSED |
| **Author** | osi (peter royal) |
| **Created** | 2023-04-22 00:45:05.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-23 06:12:20.000 UTC |
| **Closed** | 2023-05-23 06:12:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

I am repeating the same logic in my `@ActivityInterface(namePrefix = "...")` annotations. I would like to have this expressed in code, rather than a manually-applied pattern.

In the code, I saw a [TODO for this](https://github.com/temporalio/sdk-java/blob/c1cff1c5d9ef6e3ef23301fd5ff5260545d83125/temporal-sdk/src/main/java/io/temporal/common/metadata/POJOActivityMethodMetadata.java#L47).

I am interested in helping develop a PR for this and would like to understand any existing thoughts. 


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 06:12:19.000 UTC</summary>

Hi @osi We already have an issue open for this [here](https://github.com/temporalio/sdk-java/issues/396#issuecomment-1558567608) so closing this issue in favor of that one. We'd welcome a contribution in this area so feel  free to propose a design if you'd like.

</details>


---

<a id="1746"></a>

### #1746: Add capability and SDK metadata field for test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1746 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-04-19 12:25:08.000 UTC (2y 8m ago) |
| **Updated** | 2023-06-28 03:20:26.000 UTC |
| **Closed** | 2023-06-28 03:20:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Need support for https://github.com/temporalio/api/pull/259 and https://github.com/temporalio/api/pull/263

#### Comments (1)

<details>
<summary><strong>edmondop</strong> commented on 2023-06-20 16:21:17.000 UTC</summary>

@cretz once the schema is correct, how does the TestServer return sensible values? Should it return values that are coherent with the current version of sdk-java?

</details>


---

<a id="1744"></a>

### #1744: Write ProtocolMessageCommand along with protocol messages

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1744 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-04-18 21:37:02.000 UTC (2y 8m ago) |
| **Updated** | 2023-06-16 18:42:10.000 UTC |
| **Closed** | 2023-06-16 18:42:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When the SDK sends a protocol message on `WorkflowTaskComplete` also write a `ProtocolMessageCommand`


**Additional context**
This is blocked on server support for `ProtocolMessageCommand`. Without `ProtocolMessageCommand` implementing non determinism validation for updates in Java is difficult.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-06-16 18:42:09.000 UTC</summary>

Closed as part of https://github.com/temporalio/sdk-java/commit/ee2f5d0974bb9fabae71f97f7b2bb4c67c098608

</details>


---

<a id="1741"></a>

### #1741: Workflow Update: Java

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1741 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-04-18 20:53:33.000 UTC (2y 8m ago) |
| **Updated** | 2024-09-24 19:25:09.000 UTC |
| **Closed** | 2024-01-30 23:59:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

# Description

Add support for workflow update to Java SDK.

# Core Objectives

This feature will allow users to issue update requests to a workflow, have that workflow process the update (accessing and mutating internal workflow state as necessary) and return a response to the caller. This functionality will be available from external workflows as well as from code external to Temporal altogether.


# Issues
- [x] #1745
- [x] #1742
- [x] #1743
- [x] #1744
- [x] #1748
- [x] #1769
- [ ] #1781

# Related user requests / reports
- [x] #1708

# External Issues

- [x] https://github.com/temporalio/features/issues/266

#### Comments (1)

<details>
<summary><strong>josh-berry</strong> commented on 2024-01-30 23:59:20.000 UTC</summary>

Consolidating the remainder of the work under https://github.com/temporalio/features/issues/296

</details>


---

<a id="1731"></a>

### #1731: Add attempt to MDC context of the activity worker handler

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1731 |
| **State** | CLOSED |
| **Author** | rp-julienguery (Julien Guery) |
| **Created** | 2023-04-03 13:52:44.000 UTC (2y 9m ago) |
| **Updated** | 2024-08-21 00:29:40.000 UTC |
| **Closed** | 2024-08-21 00:29:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Having the attempt added to the MDC context of the activity worker handler would allow me to differentiate between two activity attempts...

**Describe the solution you'd like**
Add the following lines to the `ActivityWorker#handle` and `LocalActivityWorker#handle` methods.

```java
MDC.put(LoggerTag.ACTIVITY_ATTEMPT, pollResponse.getAttempt());
...
MDC.remove(LoggerTag.ACTIVITY_ATTEMPT);
```


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-08-21 00:29:40.000 UTC</summary>

Closed in https://github.com/temporalio/sdk-java/commit/f2e113a49ba5d3d5b7a178bcaf14e6fb1e0df878

</details>


---

<a id="1729"></a>

### #1729: Jackson serialization issue when activity returns s3 object as response.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1729 |
| **State** | CLOSED |
| **Author** | poshak-greytip (poshak) |
| **Created** | 2023-04-02 09:26:18.000 UTC (2y 9m ago) |
| **Updated** | 2023-04-03 08:05:39.000 UTC |
| **Closed** | 2023-04-03 07:42:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The activities are not getting started.

The activity definition is 
@ActivityMethod
S3Object fetchS3File(PrefillPayload payload, String referenceId) throws IOException;

I am trying to call this activity in workflow.
S3Object s3Object  =  prefillActivity.fetchS3File(prefillPayloadRequest,"123");


## Actual Behavior
Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.amazonaws.services.s3.model.S3Object["objectContent"]->com.amazonaws.services.s3.model.S3ObjectInputStream["in"]->com.amazonaws.services.s3.internal.S3AbortableInputStream["in"]->com.amazonaws.services.s3.internal.DigestValidationInputStream["in"]->com.amazonaws.services.s3.AmazonS3Client$2["in"]->com.amazonaws.util.ServiceClientHolderInputStream["in"]->com.amazonaws.services.s3.model.S3ObjectInputStream["in"]->com.amazonaws.event.ResponseProgressInputStream["in"]->org.apache.http.conn.EofSensorInputStream["eofWatcher"]->org.apache.http.impl.execchain.ResponseEntityProxy["connHolder"]->org.apache.http.impl.execchain.ConnectionHolder["manager"]->com.amazonaws.http.conn.$Proxy109["h"]->com.amazonaws.http.conn.ClientConnectionManagerFactory$Handler["orig"]->org.apache.http.impl.conn.PoolingHttpClientConnectionManager["pool"]->org.apache.http.impl.conn.CPool["condition"])



## Steps to Reproduce the Problem

  1.Try creating a activity which should return an S3 object 
 
## Specifications

  - Version: 1.20
  - Platform: java 11


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-03 07:42:30.000 UTC</summary>

Temporal doesn't handle serialization, we provide integration points (`PayloadConverter`, `PayloadCovec` abstractions) and default implementations for basic scenarios.
We don't and can't cover all existing objects out there is our standard distribution.
`java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject` is obviously not JSON serializable by default (it's a serialization primitive) and you need to configure your entities or instruct Jackson or other Json framework of your choice on how to deal with that.
Temporal doesn't provide tooling on making S3 objects serializable by Jackson, but it does not limit what users can do with their own serialization logic / settings. It's the user's responsibility, the questions on S3/Jackson should be routed to S3 or Jackson maintainers and teams. 

Generally, an object containing any kind of input stream (`com.amazonaws.services.s3.model.S3ObjectInputStream`) shouldn't be used as an activity return value. The S3 object should be either fully fetched and converted into a full in-memory representation serializable by Json or any other framework or passed "by reference / id".

Reactions: üëç 1

</details>


---

<a id="1725"></a>

### #1725: temporal-testing-1.20.0-SNAPSHOT: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1725 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-03-30 08:18:39.000 UTC (2y 9m ago) |
| **Updated** | 2023-04-21 16:05:25.000 UTC |
| **Closed** | 2023-04-21 16:05:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>temporal-testing-1.20.0-SNAPSHOT</b></p></summary>

<p></p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.8/7c62f5f72ab05eb54d40e2abf0360a2fe9ea477f/json-smart-2.4.8.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (temporal-testing version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-1370](https://www.mend.io/vulnerability-database/CVE-2023-1370) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | json-smart-2.4.8.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2023-1370</summary>


###  Vulnerable Library - <b>json-smart-2.4.8.jar</b></p>

<p>JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.</p>
<p>Library home page: <a href="https://urielch.github.io/">https://urielch.github.io/</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.8/7c62f5f72ab05eb54d40e2abf0360a2fe9ea477f/json-smart-2.4.8.jar</p>
<p>

Dependency Hierarchy:
  - temporal-testing-1.20.0-SNAPSHOT (Root Library)
    - json-path-2.7.0.jar
      - :x: **json-smart-2.4.8.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
[Json-smart](https://netplex.github.io/json-smart/) is a performance focused, JSON processor lib. When reaching a ‚Äò[‚Äò or ‚Äò{‚Äò character in the JSON input, the code parses an array or an object respectively. It was discovered that the code does not have any limit to the nesting of such arrays or objects. Since the parsing of nested arrays and objects is done recursively, nesting too many of them can cause a stack exhaustion (stack overflow) and crash the software.

<p>Publish Date: 2023-03-22
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-1370>CVE-2023-1370</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://research.jfrog.com/vulnerabilities/stack-exhaustion-in-json-smart-leads-to-denial-of-service-when-parsing-malformed-json-xray-427633/">https://research.jfrog.com/vulnerabilities/stack-exhaustion-in-json-smart-leads-to-denial-of-service-when-parsing-malformed-json-xray-427633/</a></p>
<p>Release Date: 2023-03-22</p>
<p>Fix Resolution: net.minidev:json-smart:2.4.9</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-04-21 16:05:25.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1717"></a>

### #1717: temporal-testing-1.19.0-SNAPSHOT: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1717 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-03-24 01:14:33.000 UTC (2y 9m ago) |
| **Updated** | 2023-03-30 08:18:43.000 UTC |
| **Closed** | 2023-03-30 08:18:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>temporal-testing-1.19.0-SNAPSHOT</b></p></summary>

<p></p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.8/7c62f5f72ab05eb54d40e2abf0360a2fe9ea477f/json-smart-2.4.8.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (temporal-testing version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-1370](https://www.mend.io/vulnerability-database/CVE-2023-1370) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | json-smart-2.4.8.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the  "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2023-1370</summary>


###  Vulnerable Library - <b>json-smart-2.4.8.jar</b></p>

<p>JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.</p>
<p>Library home page: <a href="https://urielch.github.io/">https://urielch.github.io/</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.8/7c62f5f72ab05eb54d40e2abf0360a2fe9ea477f/json-smart-2.4.8.jar</p>
<p>

Dependency Hierarchy:
  - temporal-testing-1.19.0-SNAPSHOT (Root Library)
    - json-path-2.7.0.jar
      - :x: **json-smart-2.4.8.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
[Json-smart](https://netplex.github.io/json-smart/) is a performance focused, JSON processor lib. When reaching a ‚Äò[‚Äò or ‚Äò{‚Äò character in the JSON input, the code parses an array or an object respectively. It was discovered that the code does not have any limit to the nesting of such arrays or objects. Since the parsing of nested arrays and objects is done recursively, nesting too many of them can cause a stack exhaustion (stack overflow) and crash the software.

<p>Publish Date: 2023-03-22
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-1370>CVE-2023-1370</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://research.jfrog.com/vulnerabilities/stack-exhaustion-in-json-smart-leads-to-denial-of-service-when-parsing-malformed-json-xray-427633/">https://research.jfrog.com/vulnerabilities/stack-exhaustion-in-json-smart-leads-to-denial-of-service-when-parsing-malformed-json-xray-427633/</a></p>
<p>Release Date: 2023-03-22</p>
<p>Fix Resolution: net.minidev:json-smart:2.4.9</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-03-30 08:18:43.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1716"></a>

### #1716: json-path-2.7.0.jar: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1716 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-03-24 01:14:31.000 UTC (2y 9m ago) |
| **Updated** | 2023-04-21 16:05:28.000 UTC |
| **Closed** | 2023-04-21 16:05:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>json-path-2.7.0.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.7/8d7f4c1530c07c54930935f3da85f48b83b3c109/json-smart-2.4.7.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.7/8d7f4c1530c07c54930935f3da85f48b83b3c109/json-smart-2.4.7.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (json-path version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-1370](https://www.mend.io/vulnerability-database/CVE-2023-1370) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | json-smart-2.4.7.jar | Transitive | 2.8.0 | &#9989; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2023-1370</summary>


###  Vulnerable Library - <b>json-smart-2.4.7.jar</b></p>

<p>JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.</p>
<p>Library home page: <a href="https://urielch.github.io/">https://urielch.github.io/</a></p>
<p>Path to dependency file: /temporal-sdk/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.7/8d7f4c1530c07c54930935f3da85f48b83b3c109/json-smart-2.4.7.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.4.7/8d7f4c1530c07c54930935f3da85f48b83b3c109/json-smart-2.4.7.jar</p>
<p>

Dependency Hierarchy:
  - json-path-2.7.0.jar (Root Library)
    - :x: **json-smart-2.4.7.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
[Json-smart](https://netplex.github.io/json-smart/) is a performance focused, JSON processor lib. When reaching a ‚Äò[‚Äò or ‚Äò{‚Äò character in the JSON input, the code parses an array or an object respectively. It was discovered that the code does not have any limit to the nesting of such arrays or objects. Since the parsing of nested arrays and objects is done recursively, nesting too many of them can cause a stack exhaustion (stack overflow) and crash the software.

<p>Publish Date: 2023-03-22
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-1370>CVE-2023-1370</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://research.jfrog.com/vulnerabilities/stack-exhaustion-in-json-smart-leads-to-denial-of-service-when-parsing-malformed-json-xray-427633/">https://research.jfrog.com/vulnerabilities/stack-exhaustion-in-json-smart-leads-to-denial-of-service-when-parsing-malformed-json-xray-427633/</a></p>
<p>Release Date: 2023-03-22</p>
<p>Fix Resolution (net.minidev:json-smart): 2.4.9</p>
<p>Direct dependency fix Resolution (com.jayway.jsonpath:json-path): 2.8.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-04-21 16:05:27.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1710"></a>

### #1710: Test Code Coverage

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1710 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-22 15:58:10.000 UTC (2y 9m ago) |
| **Updated** | 2025-05-14 15:31:31.000 UTC |
| **Closed** | 2025-05-13 16:41:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Objective

This epic covers situations where Temporal JavaSDK is lacking test code coverage in critical code pieces. 

## Tasks

- [x] #1709
- [x] #1711

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:41:57.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="1707"></a>

### #1707: ServiceWorkflowHistoryIterator should eagerly request the next page

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1707 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-21 17:59:31.000 UTC (2y 9m ago) |
| **Updated** | 2023-04-20 18:49:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Some users experience issues with replays of long workflow histories.

**Describe the solution you'd like**
While this process will always inherently has O(n) complexity and there is not much that we can do with that, there is one low hanging fruit to improve it.
Currently `ServiceWorkflowHistoryIterator` requests the next page only when the worker is already blocked and finished processing the previous page. It may be optimized by requesting the next page immediately.

**Additional context**

See `io.temporal.client.EagerPaginator` and it's implementations where such an approach and logic are already implemented.


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-20 18:49:37.000 UTC</summary>

Related #1242

</details>


---

<a id="1680"></a>

### #1680: Improve shutdown of workers with wait for releasing of all reserved local dispatch slots

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1680 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-28 16:08:16.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-24 00:05:21.000 UTC |
| **Closed** | 2023-03-24 00:05:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.19.0 |

#### Description

Both Eager Activity and Eager Workflow Task Dispatch reserve task slots to have a guaranteed executor. Graceful Worker shutdown should wait for all such reservations to be released by the holders. This shouldn't take long anyway, because the time between obtaining an eager dispatch reservation and dispatching or releasing is short.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-03-24 00:05:20.000 UTC</summary>

Closed by #1679

</details>


---

<a id="1671"></a>

### #1671: New Failure types

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1671 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-23 16:26:26.000 UTC (2y 10m ago) |
| **Updated** | 2025-05-13 16:51:46.000 UTC |
| **Closed** | 2025-05-13 16:51:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The current Failures structure is lacking enough failure types to express some situations.

# Tasks

- [ ] https://github.com/temporalio/sdk-java/issues/1374

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:51:45.000 UTC</summary>

Closing since we no longer use GH issues to track epics

</details>


---

<a id="1667"></a>

### #1667: WorkflowStub.getExecution returns null on Temporal Java SDK 1.18.1 when workflow is started via signalWithStart

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1667 |
| **State** | CLOSED |
| **Author** | ddavidyuk |
| **Created** | 2023-02-22 14:03:47.000 UTC (2y 10m ago) |
| **Updated** | 2023-02-23 17:17:30.000 UTC |
| **Closed** | 2023-02-23 14:56:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.2 |

#### Description

Some of our unit tests start workflows via `WorkflowStub.fromTyped(workflowStub).signalWithStart()` API and then invoke `WorkflowStub.fromTyped(workflowStub).getExecution()` for some checks down the line.
We've upgraded to Temporal Java SDK 1.18.1 and now `WorkflowStub.getExecution()` returns null and so our unit tests are failing.

## Expected Behavior
`WorkflowStub.fromTyped(workflowStub).getExecution()` should not return null after the workflow is started via `signalWithStart`

## Actual Behavior
`WorkflowStub.fromTyped(workflowStub).getExecution()` returns null after the workflow is started via `signalWithStart`

## Steps to Reproduce the Problem
This unit test demonstrates the bug:
```java
public class DemoBugTest {
    @RegisterExtension
    public static final TestWorkflowExtension TEST_WORKFLOW_EXTENSION =
            TestWorkflowExtension.newBuilder()
                    .setUseTimeskipping(false)
                    .setDoNotStart(true)
                    .build();

    @WorkflowInterface
    public interface TestWorkflow {
        @SignalMethod
        void setEvent(String event);
        @WorkflowMethod
        String execute();
    }

    public static class TestWorkflowImpl implements TestWorkflow {
        private String event;
        @Override
        public void setEvent(String event) {
            this.event = event;
        }
        @Override
        public String execute() {
            Workflow.await(() -> event != null);

            return "Processed " + event;
        }
    }

    private TestWorkflow workflowStub;

    @BeforeEach
    void setUpTemporal(TestWorkflowEnvironment testEnv,
                       Worker worker,
                       WorkflowClient workflowClient,
                       WorkflowOptions workflowOptions) {

        worker.registerWorkflowImplementationTypes(TestWorkflowImpl.class);
        testEnv.start();

        workflowStub = workflowClient.newWorkflowStub(TestWorkflow.class, workflowOptions);
    }

    @Test
    public void testDemoBug() {
        WorkflowStub.fromTyped(workflowStub).signalWithStart("setEvent",
                new Object[]{"testEvent"},
                new Object[0]);

        String result = WorkflowStub.fromTyped(workflowStub).getResult(String.class);
        // The assertion below fails on Temporal Java SDK 1.18.1 but succeeds with 1.17.0
        assertThat(WorkflowStub.fromTyped(workflowStub).getExecution()).isNotNull();
    }
}
```

## Specifications

  - Version: Temporal Java SDK 1.18.1
  - Platform:


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-23 17:17:30.000 UTC</summary>

Patch release v1.18.2 that has a fix for this issue is out

</details>


---

<a id="1648"></a>

### #1648: Workers not auto starting in spring boot starter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1648 |
| **State** | CLOSED |
| **Author** | sidguptajhs (Siddharth Gupta) |
| **Created** | 2023-02-11 10:27:41.000 UTC (2y 11m ago) |
| **Updated** | 2023-02-11 15:16:33.000 UTC |
| **Closed** | 2023-02-11 15:09:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | invalid |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Issue in **io.temporal:temporal-spring-boot-starter-alpha:1.18.1**

## Expected Behavior
Workers should start and workflows should be processed.

## Actual Behavior

Workflows don't execute and time out. No errors in the spring logs.

## Steps to Reproduce the Problem

  1. Get a spring boot starter alpha based flow working with version 1.17.0 . Use start-workers flag
  2. Change version to 1.18.1 and restart application

## Specifications

  - Version: 1.18.1
  - Platform: amd64

## Spring Config

```
spring.temporal:
  start-workers: true
  workers:
    - task-queue: z_res_proc_int
      capacity:
        max-concurrent-workflow-task-executors: 10
        max-concurrent-activity-executors: 20
        max-concurrent-local-activity-executors: 2
        max-concurrent-workflow-task-pollers: 3
        max-concurrent-activity-task-pollers: 3
      rate-limits:
        max-worker-activities-per-second: 5.0
        max-task-queue-activities-per-second: 5.0
    - task-queue: z_hc_exec
      capacity:
        max-concurrent-workflow-task-executors: 20
        max-concurrent-activity-executors: 50
        max-concurrent-local-activity-executors: 5
        max-concurrent-workflow-task-pollers: 3
        max-concurrent-activity-task-pollers: 3
      rate-limits:
        max-worker-activities-per-second: 5.0
        max-task-queue-activities-per-second: 5.0
    - task-queue: z_infra_ops
      capacity:
        max-concurrent-workflow-task-executors: 5
        max-concurrent-activity-executors: 1
        max-concurrent-local-activity-executors: 1
        max-concurrent-workflow-task-pollers: 1
        max-concurrent-activity-task-pollers: 1
      rate-limits:
        max-worker-activities-per-second: 5.0
        max-task-queue-activities-per-second: 5.0
  workflow-cache:
      max-instances: 10
      max-threads: 10
  connection:
    target: local
  workers-auto-discovery:
    packages:
      - com.sample
```


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-11 15:09:22.000 UTC</summary>

Since version 1.18.x `ConfigurableApplicationContext.start()` needs to be called for workers to auto-start. If your application has a concept of `start`, it's the right thing to do anyway.
https://github.com/temporalio/sdk-java/blob/master/temporal-spring-boot-autoconfigure-alpha/README.md?plain=1#L206
https://www.baeldung.com/spring-context-events#2-contextstartedevent

</details>


---

<a id="1646"></a>

### #1646: Eager Workflow Task Dispatch

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1646 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-10 16:17:33.000 UTC (2y 11m ago) |
| **Updated** | 2023-03-07 03:52:52.000 UTC |
| **Closed** | 2023-02-28 04:21:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

WorkflowClient should request eager workflow task dispatch on #start and #signalWithStart calls from the Server if it's aware of the local worker listening on the correct task queue.

A detailed design: https://github.com/temporalio/features/issues/242

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-02-10 17:15:49.000 UTC</summary>

May need a features-level issue that this issue is referenced from for tracking across SDKs

</details>


---

<a id="1613"></a>

### #1613: spring-boot-dependencies-2.7.8.pom: 7 vulnerabilities (highest severity is: 9.8) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1613 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-01-23 20:34:21.000 UTC (2y 11m ago) |
| **Updated** | 2023-03-16 04:03:44.000 UTC |
| **Closed** | 2023-03-16 04:03:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-dependencies-2.7.8.pom</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-autoconfigure-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-dependencies version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-1471](https://www.mend.io/vulnerability-database/CVE-2022-1471) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 9.8 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-25857](https://www.mend.io/vulnerability-database/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-41854](https://www.mend.io/vulnerability-database/CVE-2022-41854) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38749](https://www.mend.io/vulnerability-database/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38752](https://www.mend.io/vulnerability-database/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38751](https://www.mend.io/vulnerability-database/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-38750](https://www.mend.io/vulnerability-database/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the  "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-1471</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.8.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content to restrict deserialization.

<p>Publish Date: 2022-12-01
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-1471>CVE-2022-1471</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>9.8</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374">https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374</a></p>
<p>Release Date: 2022-12-01</p>
<p>Fix Resolution: org.yaml:snakeyaml:2.0</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.8.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-41854</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.8.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Those using Snakeyaml to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack overflow. This effect may support a denial of service attack.

<p>Publish Date: 2022-11-11
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-41854>CVE-2022-41854</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/531/">https://bitbucket.org/snakeyaml/snakeyaml/issues/531/</a></p>
<p>Release Date: 2022-11-11</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.32</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.8.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.8.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.32
</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.8.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.8.pom (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-03-16 04:03:44.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1611"></a>

### #1611: error_prone_core-2.18.0.jar: 3 vulnerabilities (highest severity is: 7.5)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1611 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-01-23 15:30:08.000 UTC (2y 11m ago) |
| **Updated** | 2023-02-14 23:18:12.000 UTC |
| **Closed** | 2023-02-14 23:18:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>error_prone_core-2.18.0.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (error_prone_core version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-3510](https://www.mend.io/vulnerability-database/CVE-2022-3510) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-3509](https://www.mend.io/vulnerability-database/CVE-2022-3509) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-3171](https://www.mend.io/vulnerability-database/CVE-2022-3171) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the section "Details" below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3510</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-test-server/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.18.0.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-12-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3510>CVE-2022-3510</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-4gg5-vx3j-xwc7">https://github.com/advisories/GHSA-4gg5-vx3j-xwc7</a></p>
<p>Release Date: 2022-12-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.21.7,3.20.3,3.19.6,3.16.3</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3509</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-test-server/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.18.0.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue similar to CVE-2022-3171, but with textformat in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-12-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3509>CVE-2022-3509</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3509">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3509</a></p>
<p>Release Date: 2022-12-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3171</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-test-server/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.18.0.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue with binary data in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-10-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3171>CVE-2022-3171</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-h4h5-3hr4-j3g2">https://github.com/advisories/GHSA-h4h5-3hr4-j3g2</a></p>
<p>Release Date: 2022-10-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-javalite:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin:3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin-lite:3.19.6,3.20.3,3.21.7;google-protobuf - 3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-14 23:18:11.000 UTC</summary>

Compile-time vulnerability, error-prone is not a part of Temporal Runtime dependencies

</details>


---

<a id="1596"></a>

### #1596: issue - when   @Autowired other bean into  bean with @ActivityImpl @Component, this.workerFactory.start(); gonna start workers so that could not auto register other workers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1596 |
| **State** | CLOSED |
| **Author** | jack-yu-matrix (Jack Yu) |
| **Created** | 2023-01-10 08:44:10.000 UTC (3 years ago) |
| **Updated** | 2023-01-10 15:13:56.000 UTC |
| **Closed** | 2023-01-10 15:13:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/sdk-java/blob/71bc122eff4af3a1f53d98fab27d5d7a7f231d92/temporal-spring-boot-autoconfigure-alpha/src/main/java/io/temporal/spring/boot/autoconfigure/RootNamespaceAutoConfiguration.java#L152

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-01-10 15:13:56.000 UTC</summary>

duplicate of https://github.com/temporalio/sdk-java/issues/1597

</details>


---

<a id="1590"></a>

### #1590: workflow_completed counter counts successful completions of workflow method instead of workflow executions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1590 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-01-08 06:40:40.000 UTC (3 years ago) |
| **Updated** | 2025-12-10 13:20:46.000 UTC |
| **Closed** | 2025-12-10 13:20:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

`workflow_completed` metric counter is expected to count newly completed executions.

## Actual Behavior

workflow_completed counter counts successful completion of workflow methods, including replays for example.

## Additional Context

The same problem is present for `workflow_continue_as_new` counter and `workflow_failed`.

## Proposed solution

A worker should log these metrics only after reporting the completion of the workflow task to the server and getting a confirmation from the server that the completion was not rejected.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2023-01-09 12:57:48.000 UTC</summary>

I think we need to fix this in multiple SDKs. May be worth an sdk-features issue.

</details>


---

<a id="1588"></a>

### #1588: error_prone_core-2.17.0.jar: 3 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1588 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-01-06 02:31:09.000 UTC (3 years ago) |
| **Updated** | 2023-01-23 15:30:12.000 UTC |
| **Closed** | 2023-01-23 15:30:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>error_prone_core-2.17.0.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-remote-data-encoder/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f1c8454bd164864a40b736ad9ab1f04962dff5be">f1c8454bd164864a40b736ad9ab1f04962dff5be</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (error_prone_core version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-3510](https://www.mend.io/vulnerability-database/CVE-2022-3510) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-3509](https://www.mend.io/vulnerability-database/CVE-2022-3509) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-3171](https://www.mend.io/vulnerability-database/CVE-2022-3171) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the section "Details" below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3510</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.17.0.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f1c8454bd164864a40b736ad9ab1f04962dff5be">f1c8454bd164864a40b736ad9ab1f04962dff5be</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-12-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3510>CVE-2022-3510</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-4gg5-vx3j-xwc7">https://github.com/advisories/GHSA-4gg5-vx3j-xwc7</a></p>
<p>Release Date: 2022-12-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.21.7,3.20.3,3.19.6,3.16.3</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3509</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.17.0.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f1c8454bd164864a40b736ad9ab1f04962dff5be">f1c8454bd164864a40b736ad9ab1f04962dff5be</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue similar to CVE-2022-3171, but with textformat in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-12-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3509>CVE-2022-3509</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3509">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3509</a></p>
<p>Release Date: 2022-12-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3171</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.17.0.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f1c8454bd164864a40b736ad9ab1f04962dff5be">f1c8454bd164864a40b736ad9ab1f04962dff5be</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue with binary data in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-10-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3171>CVE-2022-3171</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-h4h5-3hr4-j3g2">https://github.com/advisories/GHSA-h4h5-3hr4-j3g2</a></p>
<p>Release Date: 2022-10-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-javalite:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin:3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin-lite:3.19.6,3.20.3,3.21.7;google-protobuf - 3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-23 15:30:12.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1585"></a>

### #1585:  Do not auto-retry gRPC-message-size-too-large errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1585 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-05 13:09:01.000 UTC (3 years ago) |
| **Updated** | 2025-08-12 13:25:53.000 UTC |
| **Closed** | 2025-08-12 13:25:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When server gets > 4MB message, it returns `ResourceExhausted` error with something like:

> grpc:¬†received¬†message¬†larger¬†than¬†max¬†(10248653¬†vs.¬†4194304)

Which is retried by our gRPC interceptor as are all other `ResourceExhausted`. We need to stop retrying this one in particular but still retry others. If we can prevent it from going over the wire without pre-calculating the size that would be best, but otherwise we may need to hack something to change the error type for this particular error before it gets to the retry interceptor (or inside the retry interceptor if you can). Yes that may mean a message string check which is admittedly gross.

Also, add an integration test with a workflow whose activity payload will trigger this and confirm that it's a workflow task failure (can be in sdk-features).

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2025-05-14 14:55:12.000 UTC</summary>

Features issue made at https://github.com/temporalio/features/issues/624. Please refer to that for ideal behavior.

</details>


---

<a id="1564"></a>

### #1564: spring-boot-starter-2.7.6.jar: 7 vulnerabilities (highest severity is: 9.8) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1564 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-12-09 02:40:26.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-23 20:34:25.000 UTC |
| **Closed** | 2023-01-23 20:34:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-starter-2.7.6.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-starter version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-1471](https://www.mend.io/vulnerability-database/CVE-2022-1471) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 9.8 | snakeyaml-1.30.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-25857](https://www.mend.io/vulnerability-database/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-41854](https://www.mend.io/vulnerability-database/CVE-2022-41854) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38749](https://www.mend.io/vulnerability-database/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38752](https://www.mend.io/vulnerability-database/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38751](https://www.mend.io/vulnerability-database/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38750](https://www.mend.io/vulnerability-database/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the section "Details" below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-1471</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.6.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization. Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content to restrict deserialization.

<p>Publish Date: 2022-12-01
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-1471>CVE-2022-1471</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>9.8</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.6.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-41854</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.6.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Those using Snakeyaml to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack overflow. This effect may support a denial of service attack.

<p>Publish Date: 2022-11-11
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-41854>CVE-2022-41854</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/531/">https://bitbucket.org/snakeyaml/snakeyaml/issues/531/</a></p>
<p>Release Date: 2022-11-11</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.6.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.6.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.6.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.6.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-23 20:34:25.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1559"></a>

### #1559: kotlin-stdlib-jdk8-1.4.32.jar: 1 vulnerabilities (highest severity is: 5.3)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1559 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-12-06 05:54:54.000 UTC (3y 1m ago) |
| **Updated** | 2023-02-14 23:17:23.000 UTC |
| **Closed** | 2023-02-14 23:17:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>kotlin-stdlib-jdk8-1.4.32.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.32/461367948840adbb0839c51d91ed74ef4a9ccb52/kotlin-stdlib-1.4.32.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (kotlin-stdlib-jdk8 version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-24329](https://www.mend.io/vulnerability-database/CVE-2022-24329) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.3 | kotlin-stdlib-1.4.32.jar | Transitive | 1.6.0 | &#9989; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-24329</summary>


###  Vulnerable Library - <b>kotlin-stdlib-1.4.32.jar</b></p>

<p>Kotlin Standard Library for JVM</p>
<p>Library home page: <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.32/461367948840adbb0839c51d91ed74ef4a9ccb52/kotlin-stdlib-1.4.32.jar</p>
<p>

Dependency Hierarchy:
  - kotlin-stdlib-jdk8-1.4.32.jar (Root Library)
    - :x: **kotlin-stdlib-1.4.32.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.

<p>Publish Date: 2022-02-25
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-24329>CVE-2022-24329</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-2qp4-g3q3-f92w">https://github.com/advisories/GHSA-2qp4-g3q3-f92w</a></p>
<p>Release Date: 2022-02-25</p>
<p>Fix Resolution (org.jetbrains.kotlin:kotlin-stdlib): 1.6.0-M1</p>
<p>Direct dependency fix Resolution (org.jetbrains.kotlin:kotlin-stdlib-jdk8): 1.6.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-14 23:17:22.000 UTC</summary>

Compile-time vulnerability, users should use modern Kotlin versions in their runtimes.

</details>


---

<a id="1552"></a>

### #1552: High level API to list workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1552 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-12-01 13:07:25.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-06 01:25:46.000 UTC |
| **Closed** | 2023-01-06 01:25:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

For the SDK side safe rollout feature we need a user-friendly API for listing workflows.

We've recently added this to TS and Python, Go already exposed a somewhat friendly API.
Java needs this too.

This API belongs on `WorkflowClient` and should return some form of iterator that can be mapped into histories for the mass replayer. The history mapper ideally would support a `concurrency` option to speed up history fetching.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-12-01 13:45:19.000 UTC</summary>

My implementation suggestion:

* Add `io.temporal.client.WorkflowExecution` class that is a high-level wrapper over `temporal.api.workflow.v1.WorkflowExecutionInfo`
  * Make sure it has raw proto access
* Add `io.temporal.client.WorkflowExecutionDescription` class that extends `WorkflowExecution` and is a high-level wrapper over `temporal.api.workflowservice.v1.DescribeWorkflowExecutionResponse` 
  * Make sure it has raw proto access (it has a singular workflow execution info inside it which is why it can extend the other one)
* Add `io.temporal.common.WorkflowExecutionHistory` that combines a raw `io.temporal.api.history.v1.History` and a `workflowId`
  * There is already `io.temporal.internal.common.WorkflowExecutionHistory` that is used by the replayer, I suggest this replace that
  * I think it'd make sense to put this in `io.temporal.client` instead, but I could understand not wanting to access client object from replayer later
  * Add a static `fromJson(String workflowId, String jsonString)` that builds this from our UI/tctl JSON format (there's already a helper)
  * Ideally we could have a `toJson` that doesn't store the workflow ID but does a normal proto-JSON on the history, but we either have to have that use our messed-up Go form of enum storage or have `fromJson` _also_ support the non-messed-up proto form which @Spikhalskiy has resisted this
* Add `WorkflowClient.describe(String workflowId)` (and overload `describe(String workflowId, Optional<String> runId)`) that returns `WorkflowExecutionDescription`
* Add `WorkflowClient.list(String query)` that returns `Stream<WorkflowExecution>`. I don't expect people to care about options to this function at this time (can add overloads later). I do not expect users need to care about pagination, but if they did, we could easily add `WorkflowClient.listPaginated` that returned `Stream<WorkflowExecutionPage>` or something.
* Add `WorkflowClient.fetchHistoryEvents(String workflowId)`, `WorkflowClient.fetchHistoryEvents(String workflowId, Optional<String> runId)`, and `WorkflowClient.fetchHistoryEvents(WorkflowExecution execution)`
  * This should return `Stream<io.temporal.api.history.v1.HistoryEvent>`
  * I don't think people need to be able to filter to close-event only or to be able to "wait" just yet, but if we do think that will come and we don't want to explode the overloads, maybe we want to go ahead and require an options object
* Add `WorkflowClient.fetchHistory(String workflowId)`, `WorkflowClient.fetchHistory(String workflowId, Optional<String> runId)`, and `WorkflowClient.fetchHistory(WorkflowExecution execution)`
  * This should return `WorkflowExecutionHistory`
  * This should leverage `fetchHistoryEvents` underneath
  * I don't think people need to be able to filter to close-event only (yet)
  * This obviates the need for some kind of special map from execution list to history list. Instead, they can just take their `Stream<WorkflowExecution>` and `.map(myClient::fetchHistory)` and boom, they have `Stream<WorkflowExecutionHistory>`
    * And stream already has options for doing this in parallel if they want it faster somehow
* Add `Worker.replayWorkflowExecution(io.temporal.common.WorkflowExecutionHistory)`
  * This already exists, but would be up to discussion on whether the remove the non-workflow-ID having form or just overload it
  * You do not need a special call for `Worker.replayWorkflowExecutions(Stream<io.temporal.common.WorkflowExecutionHistory>)` because the caller can easily do that (and in parallel if they want) with the existing one

All of this now makes for a really cohesive listing, history fetching, and replaying API. Take this awesome example:

```java
public void runBeforeDeployment(WorkflowClient client, Worker worker, String workflowType) {
  client
    .list("WorkflowType = '" + workflowType + "'")
    .map(client::fetchHistory)
    .parallel()
    .map(worker::replayWorkflowExecution);
}
```

That is a pretty looking API. Of course they could have their own lambda that wraps the replay part if they want to capture errors and continue. Or they could paralellize the history fetch or whatever.

> The history mapper ideally would support a concurrency option to speed up history fetching.

Java already has utilities for parallel handling of streams and since we prefer to give users control over their threads on the client side, we should not add this ourselves.

</details>


---

<a id="1522"></a>

### #1522: How to gracefully shut down a temporal worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1522 |
| **State** | CLOSED |
| **Author** | sherifr212 (Sherif R.) |
| **Created** | 2022-11-14 16:47:37.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-18 22:59:37.000 UTC |
| **Closed** | 2022-11-18 22:50:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hello,

I am using Java SDK, and I was wondering how to gracefully shut down a worker that executes my workflows without any data loss or corruption?
Or even re-executing steps/tasks/activity code?

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-18 22:50:03.000 UTC</summary>

Hi,

Please use Temporal community slack to ask questions: https://temporal.io/community

JavaSDK has [`WorkerFactory#shutdown`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.17.0/io/temporal/worker/WorkerFactory.html#shutdown()) method that allows to gracefully shutdown workers.

</details>


---

<a id="1511"></a>

### #1511: Cron Jitter support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1511 |
| **State** | CLOSED |
| **Author** | WangCHX (WangCHX) |
| **Created** | 2022-11-10 02:03:30.000 UTC (3y 2m ago) |
| **Updated** | 2022-11-16 19:17:23.000 UTC |
| **Closed** | 2022-11-16 19:16:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
wondering if there is a plan to support jittering for cron schedule. 


**Describe the solution you'd like**
not sure about the real implementation. just see it in [cadence sdk](https://github.com/uber-go/cadence-client/blob/master/internal/client.go#L420), looks reasonable to avoid all workflow start at the same time. 

**Describe alternatives you've considered**
currently i handle the jittering on my application level. :)

**Additional context**
nope


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-16 19:16:49.000 UTC</summary>

Existing cron functionality will not evolve, the internal implementation and the whole experience are quite finicky. We are working on a brand new fully revisited flexible scheduling API and implementation. 

</details>


---

<a id="1509"></a>

### #1509: Data Converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1509 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-11-08 20:18:50.000 UTC (3y 2m ago) |
| **Updated** | 2025-05-13 16:49:46.000 UTC |
| **Closed** | 2025-05-13 16:49:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Core Objectives

Covers improvements and bugs related to custom Data Converter / Payload Converter / Payload Codec implementations

# Tasks

- [ ] #1373
- [x] #1345
- [x] #1301
- [ ] #1586
- [x] #1694

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:49:45.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="1505"></a>

### #1505: IllegalStateException: Signal received after workflow is closed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1505 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-11-06 01:56:51.000 UTC (3y 2m ago) |
| **Updated** | 2023-11-09 16:39:45.000 UTC |
| **Closed** | 2023-11-09 16:39:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Next |

#### Description

Forum posts:
https://community.temporal.io/t/unexpected-signal-received-after-workflow-error/6405
https://community.temporal.io/t/signal-received-after-workflow-is-closed/6379

Working on a proper sdk test but just wanted to report and will update when test is done. 
Here is the code the i used to reproduce: https://gist.github.com/tsurdilo/14f538881c511ab0c1c2162fc7286eb0
( you have to start it and let it run for a while sometimes, you might see multiple ContinuedAsNew executions before error happens as signal has to hit the right time)

* Have a workflow that starts a long running activity (in loop) inside cancellation scope. Loop is for 10 activity invocations, then it calls continueasnew
* Workflow has a signal method which cancels the scope of the currently running activity inside that loop in wf
* Client keeps sending signals for cancellation to this workflow

Seems that when a signal comes in at same time as workflow calls continueasnew, worker raises UnhandledCommand to extend the workflow task and handle that signal, on next workflow task the signal is processed, tries to cancel CancellationScope and the wf task fails again with:

<img width="1686" alt="Screen Shot 2022-11-05 at 9 39 04 PM" src="https://user-images.githubusercontent.com/119422/200150501-1979159d-52c8-4f66-bb1c-c99a54b69eee.png">

at this point the workflow task keeps failing and replaying.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-11-05 03:18:27.000 UTC</summary>

Testing the reproduction on the latest SDK https://gist.github.com/tsurdilo/14f538881c511ab0c1c2162fc7286eb0 it does not cause any `IllegalStateException` on the latest SDK

</details>


---

<a id="1483"></a>

### #1483: error_prone_core-2.16.jar: 3 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1483 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-10-13 21:08:21.000 UTC (3y 2m ago) |
| **Updated** | 2023-01-06 02:31:12.000 UTC |
| **Closed** | 2023-01-06 02:31:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>error_prone_core-2.16.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-serviceclient/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (error_prone_core version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-3510](https://www.mend.io/vulnerability-database/CVE-2022-3510) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-3509](https://www.mend.io/vulnerability-database/CVE-2022-3509) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
| [CVE-2022-3171](https://www.mend.io/vulnerability-database/CVE-2022-3171) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | protobuf-java-3.19.2.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the section "Details" below to see if there is a version of transitive dependency where vulnerability is fixed.</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3510</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-serviceclient/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.16.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-12-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3510>CVE-2022-3510</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-4gg5-vx3j-xwc7">https://github.com/advisories/GHSA-4gg5-vx3j-xwc7</a></p>
<p>Release Date: 2022-12-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.21.7,3.20.3,3.19.6,3.16.3</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3509</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-serviceclient/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.16.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue similar to CVE-2022-3171, but with textformat in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-12-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3509>CVE-2022-3509</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3509">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3509</a></p>
<p>Release Date: 2022-12-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-3171</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-serviceclient/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.16.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue with binary data in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-10-12
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-3171>CVE-2022-3171</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-h4h5-3hr4-j3g2">https://github.com/advisories/GHSA-h4h5-3hr4-j3g2</a></p>
<p>Release Date: 2022-10-12</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-javalite:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin:3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin-lite:3.19.6,3.20.3,3.21.7;google-protobuf - 3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2023-01-06 02:31:12.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1482"></a>

### #1482: spring-boot-starter-2.7.4.jar: 5 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1482 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-10-13 21:08:19.000 UTC (3y 2m ago) |
| **Updated** | 2022-10-24 17:05:53.000 UTC |
| **Closed** | 2022-10-24 17:05:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-starter-2.7.4.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-25857](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38749](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38752](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38751](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |
| [CVE-2022-38750](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.4.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.4.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.4.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.32
</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.4.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.4.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution: org.yaml:snakeyaml:1.31</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-10-24 17:05:53.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1476"></a>

### #1476: error_prone_core-2.11.0.jar: 1 vulnerabilities (highest severity is: 4.3) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1476 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-10-07 01:09:14.000 UTC (3y 3m ago) |
| **Updated** | 2022-10-13 21:08:32.000 UTC |
| **Closed** | 2022-10-13 21:08:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>error_prone_core-2.11.0.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-testing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-3171](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-3171) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 4.3 | protobuf-java-3.19.2.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-3171</summary>


###  Vulnerable Library - <b>protobuf-java-3.19.2.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-sdk/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.19.2/e958ce38f96b612d3819ff1c753d4d70609aea74/protobuf-java-3.19.2.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.11.0.jar (Root Library)
    - :x: **protobuf-java-3.19.2.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue with binary data in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-10-12
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-3171>CVE-2022-3171</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>4.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Adjacent
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: Low
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-h4h5-3hr4-j3g2">https://github.com/advisories/GHSA-h4h5-3hr4-j3g2</a></p>
<p>Release Date: 2022-09-10</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-javalite:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin:3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin-lite:3.19.6,3.20.3,3.21.7;google-protobuf - 3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-10-13 21:08:32.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1475"></a>

### #1475: temporal-sdk-1.17.0-SNAPSHOT: 1 vulnerabilities (highest severity is: 4.3) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1475 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-10-07 01:09:10.000 UTC (3y 3m ago) |
| **Updated** | 2022-10-13 21:08:24.000 UTC |
| **Closed** | 2022-10-13 21:08:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>temporal-sdk-1.17.0-SNAPSHOT</b></p></summary>

<p></p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar</p>
<p>

</details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-3171](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-3171) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 4.3 | protobuf-java-3.21.6.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-3171</summary>


###  Vulnerable Library - <b>protobuf-java-3.21.6.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.21.6/ce20767245067f50a7a5d7ff0c265561582dddcd/protobuf-java-3.21.6.jar</p>
<p>

Dependency Hierarchy:
  - temporal-sdk-1.17.0-SNAPSHOT (Root Library)
    - temporal-serviceclient-1.17.0-SNAPSHOT
      - protobuf-java-util-3.21.6.jar
        - :x: **protobuf-java-3.21.6.jar** (Vulnerable Library)
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A parsing issue with binary data in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.

<p>Publish Date: 2022-10-12
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-3171>CVE-2022-3171</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>4.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Adjacent
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: Low
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-h4h5-3hr4-j3g2">https://github.com/advisories/GHSA-h4h5-3hr4-j3g2</a></p>
<p>Release Date: 2022-09-10</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-javalite:3.16.3,3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin:3.19.6,3.20.3,3.21.7;com.google.protobuf:protobuf-kotlin-lite:3.19.6,3.20.3,3.21.7;google-protobuf - 3.19.6,3.20.3,3.21.7</p>

</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-10-13 21:08:24.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1469"></a>

### #1469: jackson-databind-2.13.4.jar: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1469 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-10-03 01:21:39.000 UTC (3y 3m ago) |
| **Updated** | 2022-10-13 21:08:30.000 UTC |
| **Closed** | 2022-10-13 21:08:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>jackson-databind-2.13.4.jar</b></p></summary>

<p>General data-binding functionality for Jackson: works on core streaming API</p>
<p>Library home page: <a href="http://github.com/FasterXML/jackson">http://github.com/FasterXML/jackson</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/radle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-42003](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-42003) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | jackson-databind-2.13.4.jar | Direct | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2022-42003</summary>


###  Vulnerable Library - <b>jackson-databind-2.13.4.jar</b></p>

<p>General data-binding functionality for Jackson: works on core streaming API</p>
<p>Library home page: <a href="http://github.com/FasterXML/jackson">http://github.com/FasterXML/jackson</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/radle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.4/98b0edfa8e4084078f10b7b356c300ded4a71491/jackson-databind-2.13.4.jar</p>
<p>

Dependency Hierarchy:
  - :x: **jackson-databind-2.13.4.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In FasterXML jackson-databind before 2.14.0-rc1, resource exhaustion can occur because of a lack of a check in primitive value deserializers to avoid deep wrapper array nesting, when the UNWRAP_SINGLE_VALUE_ARRAYS feature is enabled.

<p>Publish Date: 2022-10-02
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-42003>CVE-2022-42003</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

</details>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-10-13 21:08:29.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1464"></a>

### #1464: Allow setting WorkflowOptions via WorkflowImplementationOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1464 |
| **State** | CLOSED |
| **Author** | roded (roded) |
| **Created** | 2022-09-27 06:37:24.000 UTC (3y 3m ago) |
| **Updated** | 2022-09-27 07:12:38.000 UTC |
| **Closed** | 2022-09-27 07:11:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Using `WorkflowImplementationOptions`, we can configure default values for `ActivityOptions`. This allows settings these values from by configuration and not injecting or passing configuration objects into the workflow implementations. We'd like to be able to accomplish the same for `WorkflowOptions`. I.e., set the `WorkflowOptions` per workflow in a general location and not only where the workflow stub is created and executed.

**Describe the solution you'd like**
Something like allowing `WorkerOptions` to be set with default `WorkflowOptions` per workflow (if technically possible of course).

**Describe alternatives you've considered**
Injecting configuration options to any code which creates a workflow stub.

**Additional context**
N/A


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-27 07:11:03.000 UTC</summary>

It's not possible with the current design, WorkflowOptions have to be defined at the workflow start BEFORE the workflow ever gets dispatched to the worker. So, Workflow Worker can't decide WorkflowOptions, it may only provide a subset of the settings using WorkflowImplementationOptions. In the same way, Activity Worker can't define ActivityOptions.

The problem and intention are clear though and we work on a new component that will solve this problem as a part of its broader functionality.

</details>


---

<a id="1422"></a>

### #1422: MicrometerClientStatsReporter does not report histograms

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1422 |
| **State** | CLOSED |
| **Author** | joelmarty (Jo√´l Marty) |
| **Created** | 2022-09-13 11:21:12.000 UTC (3y 3m ago) |
| **Updated** | 2022-09-13 11:50:49.000 UTC |
| **Closed** | 2022-09-13 11:48:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Using the tally/micrometer bridge `MicrometerClientStatsReporter` in client setup should report histogram metrics like it does with other metrics types.
For instance, only `temporal_client.temporal_request_latency` is published and the submetrics it is supposed to produce (`.max`, `.avg`, `.median`, ...) are not published.

## Actual Behavior

Configuring the SDK with that class as follows makes histogram not being published:
```java
return WorkflowServiceStubsOptions.newBuilder()
    .setMetricsScope(new RootScopeBuilder()
                .reporter(new MicrometerClientStatsReporter(statsdMeterRegistry))
                .reportEvery(com.uber.m3.util.Duration.ofMillis(publishInterval.toMillis())));
```

## Steps to Reproduce the Problem

  1. See "Actual Behavior"

## Details

The issue seems to be coming from the fact that that class implements `reportHistogramValueSamples` and `reportHistogramDurationSamples` as no-ops (see [code](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L108-L130))

## Specifications

  - Version: 1.8.1
  - Platform: all


#### Comments (1)

<details>
<summary><strong>joelmarty</strong> commented on 2022-09-13 11:50:49.000 UTC</summary>

Closing as it seems that with micrometer + datadog, distribution aggregation is done on the datadog backend and not on the client as it used to.

</details>


---

<a id="1402"></a>

### #1402: Split PayloadCodec into two Encoder/Decoder interfaces and have a separate config for each

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1402 |
| **State** | CLOSED |
| **Author** | ddavidyuk |
| **Created** | 2022-08-31 19:30:23.000 UTC (3y 4m ago) |
| **Updated** | 2024-12-23 10:06:55.000 UTC |
| **Closed** | 2024-12-23 10:06:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
There are multiple microservices, each one using a different encoding scheme for outgoing Temporal payloads, e.g.:
Microservice A: binary/gzip
Microservice B: binary/encrypt

Each microservice hosts its own activities and workflows that invoke each other.

**Describe the solution you'd like**
We should be able to configure Java SDK on Microservice A to encode payloads using binary/gzip but decode the incoming payloads using either binary/gzip or binary/encrypt. Same for Microservice B (but use binary/encrypt for encoding).

Here are some code examples:
```java
public interface PayloadEncoder {
    ByteString getEncoding();

    Payload encode(Payload payload) throws DataConverterException;
}

public interface PayloadDecoder {
    ByteString getEncoding();

    Payload decode(Payload payload) throws DataConverterException;

    default boolean willDecode(Payload payload) {
        ByteString encoding = payload.getMetadataOrDefault(EncodingKeys.METADATA_ENCODING_KEY, null);
        return getEncoding().equals(encoding);
    }
}

public class PayloadCodecs {
    final List<PayloadEncoder> encoders;
    final List<PayloadDecoder> decoders;

    public Payload encode(Payload payload) throws DataConverterException {
        Payload result = payload;
        for (PayloadEncoder encoder : encoders) {
            result = encoder.encode(result);
        }

        return result;
    }

    public Payload decode(Payload payload) throws DataConverterException {
        return decoders.stream().filter(decoder -> decoder.willDecode(payload))
                .findFirst()
                .map(decoder -> decode(decoder.decode(payload))) // !!! recursive call
                .orElse(payload);
    }
}

```
This can also be integrated into a Spring Boot module like this:
```java
@Bean
// get all PayloadEncoder/Decoder beans, use all decoder beans for decoding (will be selected based on 
// the Payload's encoding header)
// use only select encoder beans for encoding
// example: temporal.payload-encoding=binary/encrypt,binary/gzip - first gzip the payload and then encrypt
public PayloadCodecs payloadCodecs(List<PayloadDecoder> decoders, 
List<PayloadEncoders> encoders, 
@Value("${temporal.payload-encoding}") List<String> encodings ) {
       return new PayloadCodecs(selectEncoders(encoders, encodings), decoders);
}
```

**Describe alternatives you've considered**
Use our own library on top of Temporal Java SDK

**Additional context**
Add any other context or screenshots about the feature request here.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-12-23 10:06:55.000 UTC</summary>

We have no plan to make breaking changes to the `PayloadCodec` interface. In general if you want complex conditional logic that can be done in the `PayloadCodec` or a custom `CodecDataConverter`

</details>


---

<a id="1394"></a>

### #1394: [Spring Boot] Support user defined *Customizers for all *Options classes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1394 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-30 00:16:42.000 UTC (3y 4m ago) |
| **Updated** | 2023-01-30 19:13:09.000 UTC |
| **Closed** | 2023-01-30 19:13:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

**Describe the solution you'd like**
Spring boot supports externalized configuration, but for full flexibility, JavaSDK Spring Boot should allow users to intercept the creation of all *Options instances to support modification

**Describe alternatives you've considered**
Expose all properties through Spring externalized config. This will work for most cases, but it's not trivial when property values are complicated objects.


#### Comments (1)

<details>
<summary><strong>s-aliasgar</strong> commented on 2022-11-23 07:20:02.000 UTC</summary>

We are using 
temporal-sdk: 1.17.0
temporal-spring-boot-starter-alpha: 1.17.0

Is there a way to supply WorkerFactoryOptions and WorkerOptions using configuration properties, since worker creation is abstracted and done internally by temporal-spring-boot-starter-alpha

</details>


---

<a id="1393"></a>

### #1393: kotlin-stdlib-1.5.31.jar: 1 vulnerabilities (highest severity is: 5.3)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1393 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-08-29 16:59:44.000 UTC (3y 4m ago) |
| **Updated** | 2023-02-14 23:17:27.000 UTC |
| **Closed** | 2023-02-14 23:17:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>kotlin-stdlib-1.5.31.jar</b></p></summary>

<p>Kotlin Standard Library for JVM</p>
<p>Library home page: <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.31/6628d61d0f5603568e72d2d5915d2c034b4f1c55/kotlin-stdlib-1.5.31.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (kotlin-stdlib version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-24329](https://www.mend.io/vulnerability-database/CVE-2022-24329) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.3 | kotlin-stdlib-1.5.31.jar | Direct | 1.6.0-M1 | &#9989; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-24329</summary>


###  Vulnerable Library - <b>kotlin-stdlib-1.5.31.jar</b></p>

<p>Kotlin Standard Library for JVM</p>
<p>Library home page: <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.31/6628d61d0f5603568e72d2d5915d2c034b4f1c55/kotlin-stdlib-1.5.31.jar</p>
<p>

Dependency Hierarchy:
  - :x: **kotlin-stdlib-1.5.31.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.

<p>Publish Date: 2022-02-25
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-24329>CVE-2022-24329</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-2qp4-g3q3-f92w">https://github.com/advisories/GHSA-2qp4-g3q3-f92w</a></p>
<p>Release Date: 2022-02-25</p>
<p>Fix Resolution: 1.6.0-M1</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-14 23:17:26.000 UTC</summary>

Compile-time vulnerability, users should use modern Kotlin versions in their runtimes.

</details>


---

<a id="1374"></a>

### #1374: External workflow signal from a workflow code throws incorrect exceptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1374 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-18 01:34:21.000 UTC (3y 4m ago) |
| **Updated** | 2023-06-28 02:22:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | Next |

#### Description

## Actual Behavior

```
fun signalWorkflow(workflowId: String, signalName: String, vararg args: Any) {
        try {
            Workflow.newUntypedExternalWorkflowStub(workflowId).signal(signalName, args)
        } catch (ex: ApplicationFailure) {
            if (ex.type == "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND") {
                logger.info {
                    it.message("Workflow not found while attempting to send signal to it.")
                        .value("workflowId", workflowId).value("signal", signalName)
                }
            }
        }
    }
```

The code above shouldn't work and `ApplicationFailure` is an incorrect exception to be thrown here.


## Additional context

There is already an exception for this situation: `SignalExternalWorkflowException` that is currently not created anywhere.

There is also a todo to implement exactly this that never was done: https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/internal/statemachines/SignalExternalStateMachine.java#L152

Another alternative exception to consider here may be `WorkflowNotFoundException`

#### Comments (1)

<details>
<summary><strong>pragnareddye</strong> commented on 2023-06-28 02:21:53.000 UTC</summary>

@Spikhalskiy @Quinn-With-Two-Ns This would be a backwards incompatible change for users who have implemented their code by catching ApplicationFailure type right?

</details>


---

<a id="1373"></a>

### #1373: Child Workflow creation API should allow user to specify a custom data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1373 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-17 19:09:57.000 UTC (3y 4m ago) |
| **Updated** | 2022-10-28 21:26:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The user starts a child workflow on a different namespace or task queue, so it will be handled by a different worker.
This different worker may have a completely different configuration of data converters.
Such a situation is pretty legit if we have two different teams developing different modules listening on different task queues.
Right now there is no way for a parent workflow to specify a different data converter for such a child workflow invocation.

**Describe the solution you'd like**

`ChildWorkflowOptions` should allow specifying a custom data converter that may be different from the data converter of the current worker.

**Describe alternatives you've considered**
Currently, users may work around this problem by creating a `PayloadConverter` that applies only to an input class of the child workflow. This approach is hacky and has limitations. 

**Additional context**
The same applies to ActivityOptions. Activities can't be scheduled on another namespace but could be on a different task queue. 

#### Comments (1)

<details>
<summary><strong>geirhoe</strong> commented on 2022-08-17 19:27:01.000 UTC</summary>

We have a setup with multiple workers, hosted by different parties, using separate queues for each workflow
Worker A - hosts the main workflow, having keys p1 and s1
Worker B - hosts a child workflow doing work needed by the main workflow on worker A, having keys p2 and s2

All communication between the different workers and clients must be encrypted and protected.

A client starts the main workflow using encrypted payload (using p1) that is decrypted on worker A using a payloadconverter with S1, giving the main workflow the information it needs.
When the main workflow on worker A starts the child workflow on worker B, the payload needed for the child workflow must be encrypted using P2 on worker A before leaving the server.
Once worker B receives this request, it decrypts the payload using S2, and starts the child workflow to do its thing.
The result from the child workflow must then be encoded using P1, and sent back to the main workflow decrypting it using S1 once the result is back on worker A.

Currently there is no way of specifying a custom dataconverter/payloadconverter to be used for the child workflow when starting it in the main workflow on worker A, leaving me to use a hack to get it working.

</details>


---

<a id="1371"></a>

### #1371: Eviction of workflow due to too advanced state fails query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1371 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-16 18:59:29.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-23 20:49:26.000 UTC |
| **Closed** | 2022-08-23 20:49:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.16.0 |

#### Description

User [hits](https://github.com/temporalio/sdk-java/pull/1267#issuecomment-1216933564) the check located [here](https://github.com/temporalio/sdk-java/blob/da51b4852a74899a713b53d1400338c74c47b828/temporal-sdk/src/main/java/io/temporal/internal/statemachines/WorkflowStateMachines.java#L182) during a direct query, which fails the query.
JavaSDK probably should handle the query with a full replay when this happens instead of failing a workflow task.

Additional context:
1. We should try to reproduce this situation when it's possible. This check was added as a guard that should never happen if Server never loses progress after responding OK to completion of a workflow task. One theory is that query may be issued and sent DURING workflow task processing by the worker, in that case, it will arrive with outdated eventIds.
2. If users actually hit this line, we should cover this behavior with unit tests.  


Another manifestation of this problem:
Due to the way how we currently define "isReplaying" state inside state machines, if a workflow task (even not a real one, but a direct query one) carries an outdated `previousStartedWorkflowTaskId` that doesn't match an actual state of the server history, during replay we will go through "EXECUTE" route instead of "REPLAY" path of state machines, while we are actually replaying and immediately applying events from the server history. It leads to internal state machine exceptions. 

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-22 00:47:34.000 UTC</summary>

Another manifestation of this problem:
Due to the way how we currently define "isReplaying" state inside state machines, if a workflow task (even not a real one, but a direct query one) carries an outdated previousStartedWorkflowTaskId that doesn't match an actual state of the server history, during replay we will go through "EXECUTE" route instead of "REPLAY" path of state machines, while we are actually replaying and immediately applying events from the server history. It leads to [internal state machine exceptions](https://github.com/temporalio/sdk-java/files/9390368/java-sdk-public_build_1612_java-jdk18-unit-test-with-in-memory-test-service.log.zip).


</details>


---

<a id="1361"></a>

### #1361: üèöÔ∏è Local Activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1361 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-10 22:13:03.000 UTC (3y 5m ago) |
| **Updated** | 2025-05-13 16:41:45.000 UTC |
| **Closed** | 2025-05-13 16:41:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Description

Improve Local Activities support.

# Core Objectives

Local Activities in JavaSDK are lacking some features and enforcements that users expect and this Epic covers this area.

# Bugs

- [x] #1533
- [x] #1561

# Tasks

- [x] #1004
- [x] #1261
- [ ] #1346 and relevant problem report #1246
- [ ] #1303
- [x] #1512
- [ ] #1563



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:41:44.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="1357"></a>

### #1357: Latest test-server is broken

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1357 |
| **State** | CLOSED |
| **Author** | loopingrage (Jose de Castro) |
| **Created** | 2022-08-10 07:56:50.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-10 16:21:13.000 UTC |
| **Closed** | 2022-08-10 15:28:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.16.0 |

#### Description

## Expected Behavior
A working test server

## Actual Behavior
A busted test-server

## Steps to Reproduce the Problem

  1. Run the temporal typescript test server test [here](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/workflows.test.ts)

## Specifications

  - Version: Temporal Typescript SDK 1.0.1
  - Platform: Mac

## Details
The temporal Typescript SDK [simply pulls](https://github.com/temporalio/sdk-typescript/blob/main/packages/testing/scripts/download-test-server.mjs) the latest build of test server which currently fails with a bunch of Java NoCLassDefFound errors.

```
Exception in thread "grpc-default-executor-3" java.lang.ExceptionInInitializerError
        at io.temporal.api.common.v1.Payload$MetadataDefaultEntryHolder.<clinit>(Payload.java:124)
        at io.temporal.api.common.v1.Payload.<init>(Payload.java:61)
        at io.temporal.api.common.v1.Payload.<init>(Payload.java:15)
        at io.temporal.api.common.v1.Payload$1.parsePartialFrom(Payload.java:754)
        at io.temporal.api.common.v1.Payload$1.parsePartialFrom(Payload.java:748)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at io.temporal.api.common.v1.Payloads.<init>(Payloads.java:63)
        at io.temporal.api.common.v1.Payloads.<init>(Payloads.java:13)
        at io.temporal.api.common.v1.Payloads$1.parsePartialFrom(Payloads.java:754)
        at io.temporal.api.common.v1.Payloads$1.parsePartialFrom(Payloads.java:748)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest.<init>(StartWorkflowExecutionRequest.java:100)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest.<init>(StartWorkflowExecutionRequest.java:9)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest$1.parsePartialFrom(StartWorkflowExecutionRequest.java:3376)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest$1.parsePartialFrom(StartWorkflowExecutionRequest.java:3370)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:86)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:48)
        at io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller.parseFrom(ProtoLiteUtils.java:223)
        at io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller.parse(ProtoLiteUtils.java:215)
        at io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller.parse(ProtoLiteUtils.java:118)
        at io.grpc.MethodDescriptor.parseRequest(MethodDescriptor.java:307)
        at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:332)
        at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:315)
        at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
        at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
        at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
        at java.lang.Thread.run(Thread.java:833)
        at com.oracle.svm.core.thread.PlatformThreads.threadStartRoutine(PlatformThreads.java:705)
        at com.oracle.svm.core.posix.thread.PosixPlatformThreads.pthreadStartRoutine(PosixPlatformThreads.java:202)
Caused by: java.lang.RuntimeException: Generated message class "com.google.protobuf.DescriptorProtos$FieldOptions" missing method "getUnverifiedLazy".
        at com.google.protobuf.GeneratedMessageV3.getMethodOrDie(GeneratedMessageV3.java:1847)
        at com.google.protobuf.GeneratedMessageV3.access$1000(GeneratedMessageV3.java:79)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable$SingularFieldAccessor$ReflectionInvoker.<init>(GeneratedMessageV3.java:2178)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable$SingularFieldAccessor.<init>(GeneratedMessageV3.java:2252)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable.ensureFieldAccessorsInitialized(GeneratedMessageV3.java:1982)
        at com.google.protobuf.DescriptorProtos$FieldOptions.internalGetFieldAccessorTable(DescriptorProtos.java:28933)
        at com.google.protobuf.GeneratedMessageV3.getDescriptorForType(GeneratedMessageV3.java:133)
        at com.google.protobuf.GeneratedMessageV3$ExtendableMessage.parseUnknownField(GeneratedMessageV3.java:1134)
        at com.google.protobuf.DescriptorProtos$FieldOptions.<init>(DescriptorProtos.java:28901)
        at com.google.protobuf.DescriptorProtos$FieldOptions.<init>(DescriptorProtos.java:28795)
        at com.google.protobuf.DescriptorProtos$FieldOptions$1.parsePartialFrom(DescriptorProtos.java:31031)
        at com.google.protobuf.DescriptorProtos$FieldOptions$1.parsePartialFrom(DescriptorProtos.java:31025)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto.<init>(DescriptorProtos.java:11706)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto.<init>(DescriptorProtos.java:11598)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto$1.parsePartialFrom(DescriptorProtos.java:14351)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto$1.parsePartialFrom(DescriptorProtos.java:14345)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at com.google.protobuf.DescriptorProtos$DescriptorProto.<init>(DescriptorProtos.java:5232)
        at com.google.protobuf.DescriptorProtos$DescriptorProto.<init>(DescriptorProtos.java:5168)
        at com.google.protobuf.DescriptorProtos$DescriptorProto$1.parsePartialFrom(DescriptorProtos.java:10305)
        at com.google.protobuf.DescriptorProtos$DescriptorProto$1.parsePartialFrom(DescriptorProtos.java:10299)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at com.google.protobuf.DescriptorProtos$FileDescriptorProto.<init>(DescriptorProtos.java:1283)
        at com.google.protobuf.DescriptorProtos$FileDescriptorProto.<init>(DescriptorProtos.java:1203)
        at com.google.protobuf.DescriptorProtos$FileDescriptorProto$1.parsePartialFrom(DescriptorProtos.java:4892)
        at com.google.protobuf.DescriptorProtos$FileDescriptorProto$1.parsePartialFrom(DescriptorProtos.java:4886)
        at com.google.protobuf.AbstractParser.parsePartialFrom(AbstractParser.java:158)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:191)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:203)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:208)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:48)
        at com.google.protobuf.DescriptorProtos$FileDescriptorProto.parseFrom(DescriptorProtos.java:2301)
        at com.google.protobuf.Descriptors$FileDescriptor.internalBuildGeneratedFileFrom(Descriptors.java:417)
        at io.temporal.api.common.v1.MessageProto.<clinit>(MessageProto.java:134)
        ... 31 more
Caused by: java.lang.NoSuchMethodException: com.google.protobuf.DescriptorProtos$FieldOptions.getUnverifiedLazy()
        at java.lang.Class.getMethod(DynamicHub.java:2227)
        at com.google.protobuf.GeneratedMessageV3.getMethodOrDie(GeneratedMessageV3.java:1844)
        ... 65 more
Exception in thread "grpc-default-executor-3" java.lang.ExceptionInInitializerError
        at io.temporal.api.common.v1.Payload$MetadataDefaultEntryHolder.<clinit>(Payload.java:124)
        at io.temporal.api.common.v1.Payload.<init>(Payload.java:61)
        at io.temporal.api.common.v1.Payload.<init>(Payload.java:15)
        at io.temporal.api.common.v1.Payload$1.parsePartialFrom(Payload.java:754)
        at io.temporal.api.common.v1.Payload$1.parsePartialFrom(Payload.java:748)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at io.temporal.api.common.v1.Payloads.<init>(Payloads.java:63)
        at io.temporal.api.common.v1.Payloads.<init>(Payloads.java:13)
        at io.temporal.api.common.v1.Payloads$1.parsePartialFrom(Payloads.java:754)
        at io.temporal.api.common.v1.Payloads$1.parsePartialFrom(Payloads.java:748)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest.<init>(StartWorkflowExecutionRequest.java:100)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest.<init>(StartWorkflowExecutionRequest.java:9)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest$1.parsePartialFrom(StartWorkflowExecutionRequest.java:3376)
        at io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest$1.parsePartialFrom(StartWorkflowExecutionRequest.java:3370)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:86)
        at com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:48)
        at io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller.parseFrom(ProtoLiteUtils.java:223)
        at io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller.parse(ProtoLiteUtils.java:215)
        at io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller.parse(ProtoLiteUtils.java:118)
        at io.grpc.MethodDescriptor.parseRequest(MethodDescriptor.java:307)
        at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:332)
        at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:315)
        at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
        at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
        at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
        at java.lang.Thread.run(Thread.java:833)
        at com.oracle.svm.core.thread.PlatformThreads.threadStartRoutine(PlatformThreads.java:705)
        at com.oracle.svm.core.posix.thread.PosixPlatformThreads.pthreadStartRoutine(PosixPlatformThreads.java:202)
Caused by: java.lang.RuntimeException: Generated message class "com.google.protobuf.DescriptorProtos$FieldOptions" missing method "getUnverifiedLazy".
        at com.google.protobuf.GeneratedMessageV3.getMethodOrDie(GeneratedMessageV3.java:1847)
        at com.google.protobuf.GeneratedMessageV3.access$1000(GeneratedMessageV3.java:79)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable$SingularFieldAccessor$ReflectionInvoker.<init>(GeneratedMessageV3.java:2178)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable$SingularFieldAccessor.<init>(GeneratedMessageV3.java:2252)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable.ensureFieldAccessorsInitialized(GeneratedMessageV3.java:1982)
        at com.google.protobuf.DescriptorProtos$FieldOptions.internalGetFieldAccessorTable(DescriptorProtos.java:28933)
        at com.google.protobuf.GeneratedMessageV3.getDescriptorForType(GeneratedMessageV3.java:133)
        at com.google.protobuf.GeneratedMessageV3$ExtendableMessage.parseUnknownField(GeneratedMessageV3.java:1134)
        at com.google.protobuf.DescriptorProtos$FieldOptions.<init>(DescriptorProtos.java:28901)
        at com.google.protobuf.DescriptorProtos$FieldOptions.<init>(DescriptorProtos.java:28795)
        at com.google.protobuf.DescriptorProtos$FieldOptions$1.parsePartialFrom(DescriptorProtos.java:31031)
        at com.google.protobuf.DescriptorProtos$FieldOptions$1.parsePartialFrom(DescriptorProtos.java:31025)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto.<init>(DescriptorProtos.java:11706)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto.<init>(DescriptorProtos.java:11598)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto$1.parsePartialFrom(DescriptorProtos.java:14351)
        at com.google.protobuf.DescriptorProtos$FieldDescriptorProto$1.parsePartialFrom(DescriptorProtos.java:14345)
        at com.google.protobuf.CodedInputStream$ArrayDecoder.readMessage(CodedInputStream.java:889)
        at com.google.protobuf.DescriptorProtos$DescriptorProto.<init>(DescriptorProtos.java:5232)
        at com.google.protobuf.DescriptorProtos$DescriptorProto.<init>(DescriptorProtos.java:5168)
        at com.google.protobuf.DescriptorProtos$DescriptorProto$1.parsePartialFrom...
```


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-08-10 14:57:07.000 UTC</summary>

We mitigated the problem. You should be able to use the TS testing framework back.

</details>


---

<a id="1338"></a>

### #1338: PoC - Static analyzer for determinism

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1338 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-08-02 16:06:42.000 UTC (3y 5m ago) |
| **Updated** | 2024-06-04 16:43:22.000 UTC |
| **Closed** | 2024-06-04 16:43:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

*No description provided.*

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-01-05 19:40:41.000 UTC</summary>

I did a PoC of this at https://github.com/cretz/temporal-workflowcheck-java

</details>


---

<a id="1321"></a>

### #1321: An api to know if the current Thread is running under Workflow Context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1321 |
| **State** | CLOSED |
| **Author** | manas-tripathy |
| **Created** | 2022-07-23 13:42:47.000 UTC (3y 5m ago) |
| **Updated** | 2022-07-23 14:59:51.000 UTC |
| **Closed** | 2022-07-23 14:59:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Expected Behavior**
Introduce a new API Workflow.isWorkflowThread() to know if the current thread is under WorkflowContext

**Actual Behavior**
Workflow.getInfo() is throwing "Called from non workflow or workflow callback thread" when called from a  Non Workflow Thread.
Please refer [community thread](https://community.temporal.io/t/removing-thread-locals-after-context-propagation/5361) for more details.

**Specifications**
Version: 1.11.0
Platform: java-sdk
  

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-23 14:59:32.000 UTC</summary>

Already exists as `io.temporal.workflow.unsafe.WorkflowUnsafe.isWorkflowThread`

</details>


---

<a id="1293"></a>

### #1293: Support robfig style cron defs in TestWorkflowEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1293 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-06-29 21:33:44.000 UTC (3y 6m ago) |
| **Updated** | 2022-06-29 21:37:29.000 UTC |
| **Closed** | 2022-06-29 21:37:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Users can set cron schedules in their WorkflowOptions using [robfig](https://pkg.go.dev/github.com/robfig/cron) schedules/intervals format, but they cannot currently use them in tests as only crontab style is supported.

This is a feature request to add support for robfig predefined schedules and intervals: https://docs.temporal.io/workflows/#robfig-predefined-schedules-and-intervals
in TestWorkflowEnvironment. 

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-06-29 21:37:29.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-java/issues/341

</details>


---

<a id="1287"></a>

### #1287: kotlin-stdlib-1.5.20.jar: 1 vulnerabilities (highest severity is: 5.3) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1287 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-06-27 18:45:39.000 UTC (3y 6m ago) |
| **Updated** | 2022-08-29 16:59:47.000 UTC |
| **Closed** | 2022-08-29 16:59:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>kotlin-stdlib-1.5.20.jar</b></p></summary>

<p>Kotlin Standard Library for JVM</p>
<p>Library home page: <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.20/9de35cc611bcecec8edce1d56d8e659953806751/kotlin-stdlib-1.5.20.jar,/radle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.20/9de35cc611bcecec8edce1d56d8e659953806751/kotlin-stdlib-1.5.20.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2022-24329](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-24329) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.3 | kotlin-stdlib-1.5.20.jar | Direct | 1.6.0-M1 | &#9989; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-24329</summary>


###  Vulnerable Library - <b>kotlin-stdlib-1.5.20.jar</b></p>

<p>Kotlin Standard Library for JVM</p>
<p>Library home page: <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.20/9de35cc611bcecec8edce1d56d8e659953806751/kotlin-stdlib-1.5.20.jar,/radle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.20/9de35cc611bcecec8edce1d56d8e659953806751/kotlin-stdlib-1.5.20.jar</p>
<p>

Dependency Hierarchy:
  - :x: **kotlin-stdlib-1.5.20.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.

<p>Publish Date: 2022-02-25
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2022-24329>CVE-2022-24329</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-2qp4-g3q3-f92w">https://github.com/advisories/GHSA-2qp4-g3q3-f92w</a></p>
<p>Release Date: 2022-02-25</p>
<p>Fix Resolution: 1.6.0-M1</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-08-29 16:59:47.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1286"></a>

### #1286: kotlin-scripting-compiler-embeddable-1.4.32.jar: 1 vulnerabilities (highest severity is: 5.3) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1286 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-06-27 18:45:37.000 UTC (3y 6m ago) |
| **Updated** | 2022-12-06 05:54:57.000 UTC |
| **Closed** | 2022-12-06 05:54:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>kotlin-scripting-compiler-embeddable-1.4.32.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.32/461367948840adbb0839c51d91ed74ef4a9ccb52/kotlin-stdlib-1.4.32.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (kotlin-scripting-compiler-embeddable version) | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-24329](https://www.mend.io/vulnerability-database/CVE-2022-24329) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.3 | kotlin-stdlib-1.4.32.jar | Transitive | 1.6.0 | &#9989; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2022-24329</summary>


###  Vulnerable Library - <b>kotlin-stdlib-1.4.32.jar</b></p>

<p>Kotlin Standard Library for JVM</p>
<p>Library home page: <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.32/461367948840adbb0839c51d91ed74ef4a9ccb52/kotlin-stdlib-1.4.32.jar</p>
<p>

Dependency Hierarchy:
  - kotlin-scripting-compiler-embeddable-1.4.32.jar (Root Library)
    - :x: **kotlin-stdlib-1.4.32.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/462a3cf94a6aa20f94bb514b636fd10936b63e2f">462a3cf94a6aa20f94bb514b636fd10936b63e2f</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.

<p>Publish Date: 2022-02-25
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-24329>CVE-2022-24329</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-2qp4-g3q3-f92w">https://github.com/advisories/GHSA-2qp4-g3q3-f92w</a></p>
<p>Release Date: 2022-02-25</p>
<p>Fix Resolution (org.jetbrains.kotlin:kotlin-stdlib): 1.6.0-M1</p>
<p>Direct dependency fix Resolution (org.jetbrains.kotlin:kotlin-scripting-compiler-embeddable): 1.6.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-12-06 05:54:57.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1230"></a>

### #1230: Allow dynamic creation and shutdown of workers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1230 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-20 17:47:39.000 UTC (3y 7m ago) |
| **Updated** | 2025-05-13 22:07:24.000 UTC |
| **Closed** | 2025-05-13 22:07:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | 1.20.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
In some situations, users may have dynamic task queues. 

**Describe the solution you'd like**
To support this use case without a huge overhead we should allow starting and stopping of individual workers without the need to recreate the whole WorkersFactory

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
A related Slack discussion: https://temporalio.slack.com/archives/CTRCR8RBP/p1652713381216549
A related task that should be approached together with this one: https://github.com/temporalio/sdk-java/issues/966


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 22:07:23.000 UTC</summary>

Closing as this is currently not supported in any other SDK and not currently planned

</details>


---

<a id="1226"></a>

### #1226: Disabling time skipping in 1.11.0 is not working?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1226 |
| **State** | CLOSED |
| **Author** | riomus (Roman Bartusiak) |
| **Created** | 2022-05-18 07:36:57.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-18 20:54:21.000 UTC |
| **Closed** | 2022-05-18 07:43:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

We have some tests that are checking the correctness of integration between Kafka and our workflow implementation. In 1.8.1 we had to disable to time-skipping for them (that is ok as we have some async actions that are executed by Kafka listeners so temporal should not play with time). When upgraded to 1.11.0 those tests stopped working as it seems time skipping is used even though we are explicitly disabling it. By inspecting diagnostics i can see that workflow is timing out immediately with the event that happens 315359999 seconds after the last event (so explicit disabling of time-skipping seems to be ignored) 

# Expected Behavior

When running a test environment with disabled time-skipping, time should not be magically incremented by the test environment.


## Actual Behavior

The temporal test environment is using time skipping even though it is disabled.



## Steps to Reproduce the Problem

```
import io.temporal.client.WorkflowClient
import io.temporal.client.WorkflowOptions
import io.temporal.testing.TestEnvironmentOptions
import io.temporal.testing.TestWorkflowEnvironment
import io.temporal.workflow.SignalMethod
import io.temporal.workflow.Workflow
import io.temporal.workflow.WorkflowInterface
import io.temporal.workflow.WorkflowMethod
import org.junit.Assert
import java.time.Duration
import java.util.concurrent.CompletableFuture

object SignaledWorkflowImlTest {
    @JvmStatic
    fun main(args: Array<String>) {
        testSignal()
    }

    fun testSignal() {
        val testEnvironment =
            TestWorkflowEnvironment.newInstance(TestEnvironmentOptions.newBuilder().setUseTimeskipping(false).build())

        // Creates a worker that polls tasks from the service owned by the testEnvironment.
        val worker = testEnvironment.newWorker("default")
        worker.registerWorkflowImplementationTypes(SignaledWorkflowImpl::class.java)
        testEnvironment.start()

        // Creates a WorkflowClient that interacts with the server owned by the testEnvironment.
        val client = testEnvironment.workflowClient
        val workflow = client.newWorkflowStub(SignaledWorkflow::class.java,
            WorkflowOptions.newBuilder().setTaskQueue("default").setWorkflowRunTimeout(Duration.ofDays(1))
                .setWorkflowTaskTimeout(
                    Duration.ofDays(1)).setWorkflowExecutionTimeout(Duration.ofDays(1)).build())

        // Starts a workflow execution
        val result: CompletableFuture<String> = WorkflowClient.execute<String, String>({ input: String ->
            workflow.workflow1(input)
        }, "input1")

        // The sleep forwards the service clock for 65 minutes without blocking.
        // This ensures that the signal is sent after the one hour sleep in the workflow code.
        workflow.processSignal("signalInput")

        // Blocks until workflow is complete. Workflow sleep forwards clock for one hour and
        // this call returns almost immediately.
        val resultValue: String = result.get()
        println("got result $resultValue")
        Assert.assertEquals("signalInput-input1", resultValue)

        // Closes workers and releases in-memory service.
        testEnvironment.close()
    }

    @WorkflowInterface
    internal interface SignaledWorkflow {
        @WorkflowMethod
        fun workflow1(input: String): String

        @SignalMethod
        fun processSignal(input: String)
    }

    class SignaledWorkflowImpl : SignaledWorkflow {
        private var signalInput: String? = null
        override fun workflow1(input: String): String {
            Workflow.sleep(Duration.ofMinutes(1))
            Workflow.await { signalInput != null }
            return "$signalInput-$input"
        }

        override fun processSignal(input: String) {
            signalInput = input
        }
    }
}
```

With Java SDK 1.8.1 that code takes 1minute to run (as expected) with 1.11.0 it ends immediately because time-skipping is used while it was disabled explicitly (the same behaviour is in 1.8.1 with enabled time-skipping) 
## Specifications

  - Version: 1.11.0
  - Platform: Arch Linux, Adoptium Java 17


#### Comments (1)

<details>
<summary><strong>riomus</strong> commented on 2022-05-18 07:43:55.000 UTC</summary>

I see it was already fixed: https://github.com/temporalio/sdk-java/issues/1219#issuecomment-1128893187

</details>


---

<a id="1223"></a>

### #1223: Test server generates the same activity task token on retry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1223 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-05-17 22:05:22.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-17 23:19:19.000 UTC |
| **Closed** | 2022-05-17 23:19:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Should be a different task token

## Actual Behavior

Same token issued

## Steps to Reproduce the Problem

  1. Create a test with an activity that times out
  1. Wait for second attempt
  1. Observe the issued task token

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-17 23:19:19.000 UTC</summary>

Duplicate of #84

</details>


---

<a id="1222"></a>

### #1222: Consider making std-out of Test Server more useful.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1222 |
| **State** | CLOSED |
| **Author** | macrogreg (macrogreg) |
| **Created** | 2022-05-17 21:08:54.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-17 21:13:15.000 UTC |
| **Closed** | 2022-05-17 21:11:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement, wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When starting the Test Server (on Windows) without arguments, it displays this:

```
PS dir> .\temporal-test-server.exe
Usage: <command> <port> <flags>
Flags:
--enable-time-skipping - to enable time skipping on start
```

It is intuitively clear what "port" means, and "flags" is explained.
I have no idea what "command" means. and I cannot find any docs. Can the above usage display please explain it?

Also, both the _command_ and the _flags_ appear to be optional, as the following starts the server:

```
PS dir> .\temporal-test-server.exe 7233
```

Could we please indicate that on the usage display too?

Finally, once the above command with the port is issued, the server just starts. Nothing is displayed. Some brief message that the server is not running, listening on the specified port and is ready to handle requests would be very useful. :)

Thanks for considering those improvements. :)



#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-17 21:11:26.000 UTC</summary>

<command> is "./temporal-test-server" itself. It's, well, mandatory. I will probably leave it as it is because
for linux it's "./temporal-test-server", for windows it's "./temporal-test-server.exe" and what if users renamed the file?
It's not something getting installed into a static path in the system (at least right now).

> Also, both the command and the flags appear to be optional, as the following starts the server.

Flags are usually optional.



</details>


---

<a id="1220"></a>

### #1220: Test Server fails when starting a workflow that already exists.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1220 |
| **State** | CLOSED |
| **Author** | macrogreg (macrogreg) |
| **Created** | 2022-05-17 20:57:16.000 UTC (3y 7m ago) |
| **Updated** | 2022-09-15 14:32:57.000 UTC |
| **Closed** | 2022-09-15 14:32:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | 1.17.0 |

#### Description

I am running an integration test that is passing fine on both, a local docker-compose based server and on Temporal Cloud. But on the test server it fails immediately, and the server throws an internal exception.


* The test starts a workflow. (That succeeds.)

* Then it attempts to start a workflow with the _same_ Workflow Id as the workflow just started.

* The test expects to get an `AlreadyExists` gRPC status / error from the `StartWorkflowExecution(..)` gRPC call.

* Instead, it gets an unspecified gRPC error and the test server displays the following:
```
PS > .\temporal-test-server.exe 7233
May 14, 2022 2:06:22 AM io.grpc.internal.SerializingExecutor run
SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed@6bb8cba3
java.lang.RuntimeException: Generated message class "io.temporal.api.errordetails.v1.WorkflowExecutionAlreadyStartedFailure" missing method "getStartRequestId".
        at com.google.protobuf.GeneratedMessageV3.getMethodOrDie(GeneratedMessageV3.java:1847)
        at com.google.protobuf.GeneratedMessageV3.access$1000(GeneratedMessageV3.java:79)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable$SingularFieldAccessor$ReflectionInvoker.<init>(GeneratedMessageV3.java:2176)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable$SingularFieldAccessor.<init>(GeneratedMessageV3.java:2248)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable$SingularStringFieldAccessor.<init>(GeneratedMessageV3.java:2916)
        at com.google.protobuf.GeneratedMessageV3$FieldAccessorTable.ensureFieldAccessorsInitialized(GeneratedMessageV3.java:1977)
        at io.temporal.api.errordetails.v1.WorkflowExecutionAlreadyStartedFailure.internalGetFieldAccessorTable(WorkflowExecutionAlreadyStartedFailure.java:93)
        at com.google.protobuf.GeneratedMessageV3.getDescriptorForType(GeneratedMessageV3.java:133)
        at com.google.protobuf.Any.pack(Any.java:183)
        at io.temporal.serviceclient.StatusUtils.newException(StatusUtils.java:82)
        at io.temporal.internal.testservice.TestWorkflowService.throwDuplicatedWorkflow(TestWorkflowService.java:286)
        at io.temporal.internal.testservice.TestWorkflowService.startWorkflowExecutionImpl(TestWorkflowService.java:231)
        at io.temporal.internal.testservice.TestWorkflowService.startWorkflowExecution(TestWorkflowService.java:204)
        at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$MethodHandlers.invoke(WorkflowServiceGrpc.java:3822)
        at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
        at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:340)
        at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:866)
        at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
        at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
        at java.lang.Thread.run(Thread.java:833)
        at com.oracle.svm.core.thread.PlatformThreads.threadStartRoutine(PlatformThreads.java:704)
        at com.oracle.svm.core.windows.WindowsPlatformThreads.osThreadStartRoutine(WindowsPlatformThreads.java:143)
Caused by: java.lang.NoSuchMethodException: io.temporal.api.errordetails.v1.WorkflowExecutionAlreadyStartedFailure.getStartRequestId()
        at java.lang.Class.getMethod(DynamicHub.java:2227)
        at com.google.protobuf.GeneratedMessageV3.getMethodOrDie(GeneratedMessageV3.java:1844)
        ... 23 more
```

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-09-14 13:08:25.000 UTC</summary>

This is likely a graal-specific issue because those protos are not available via reflection and using status details inside proto probably uses reflection. I only see `io.temporal.api.errordetails.v1.WorkflowExecutionAlreadyStartedFailure` and `io.temporal.api.errordetails.v1.QueryFailedFailure` being used as status details, but should probably make that whole `errordetails.v1` package available for reflecting.

</details>


---

<a id="1203"></a>

### #1203: Rework long poll code to use an absolute deadline instead of calculating an elapsed time

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1203 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-11 15:27:57.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-18 20:59:21.000 UTC |
| **Closed** | 2022-05-18 20:59:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, the long polling retrying code has to maintain a very unpleasant calculation of the elapsed and remaining time.
Instead of this, it should be reworked onto using an absolute deadline.


**Describe the solution you'd like**
`GrpcRetryer` should support an absolute deadline directly, without error-prone explicit converting of the absolute deadline to the timeout duration.
This absolute deadline should be passed into `GrpcRetryer` using some internal `RetryerOptions`.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-18 20:59:21.000 UTC</summary>

Closed by #1209

</details>


---

<a id="1202"></a>

### #1202: Remove RpcRetryOptions from the public API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1202 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-11 15:23:44.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-12 16:32:56.000 UTC |
| **Closed** | 2022-05-12 16:32:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | wontfix |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

RpcRetryOptions should be moved from `io.temporal.serviceclient` into an internal package. 
This class is not participating in any APIs directly exposed to SDK users. 
The location of this class is a public package limits modification flexibility.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-12 16:32:56.000 UTC</summary>

RpcRetryOptions is exposed on WorkflowStubOptions.Builder. Won't fix.

</details>


---

<a id="1201"></a>

### #1201: Revisit continue-as-new that doesn't carry over some attributes of parent run if not set explicitly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1201 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-11 01:43:02.000 UTC (3y 8m ago) |
| **Updated** | 2023-05-23 17:59:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëÄ 1 |

#### Description

# Expected Behavior

Users calling `Workflow.continueAsNew` without an explicit `ContinueAsNewOptions` expect most workflow properties to carry over to the new run.

## Actual Behavior

Right now `continueAsNew` is implemented in a way that assumes that most parameters are carried over by the server if not specified on the continueAsNew request. While in fact, it's the opposite. Server doesn't carry over most parameters are not carried over by the server.

## Additional context

This task requires also 
- a careful alignment with GoSDK 
- documenting in Temporal API repo which parameters are carried over by the Server from the previous run.
- Test server should be updated to be aligned in its behavior with the real Temporal Server.

Related:
- [x] #1200
- [ ] Workflow RetryOptions are not carried forward automatically

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 17:59:43.000 UTC</summary>

related: https://github.com/temporalio/sdk-java/issues/1424

</details>


---

<a id="1195"></a>

### #1195: Support dynamic values for custom tags in metrics.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1195 |
| **State** | CLOSED |
| **Author** | ravikrn13 (Ravi Kiran) |
| **Created** | 2022-05-09 19:06:40.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-09 19:08:16.000 UTC |
| **Closed** | 2022-05-09 19:07:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently custom tag values are static in nature, once set cannot be updated during the workflow execution. 
E.g: the temporal_workflow_endtoend_latency_seconds is a very useful metric, but when we share the workflow with different inputs, we would like to add a custom tag and set its value based on the input.

**Describe the solution you'd like**
Ability to modify the custom tag using Workflow.getMetricsScope().tagged() method (similarly for Activity too).

**Describe alternatives you've considered**
Alternatives are to create custom metrics similar to already exposed by SDK. 

**Additional context**
As per discussion here, https://community.temporal.io/t/update-custom-tag-value-of-built-in-metrics/4631/1


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-09 19:07:55.000 UTC</summary>

Duplicate of https://github.com/temporalio/sdk-java/issues/1163

"Won't fix" for now.

</details>


---

<a id="1189"></a>

### #1189: Expose assertHistoryEvent utility method from TestWorkflowRule

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1189 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-05-06 18:18:27.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-09 17:53:20.000 UTC |
| **Closed** | 2022-05-09 17:53:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | wontfix |
| **Assignees** | None |
| **Milestone** | None |

#### Description

SDKTestWorkflowRule has a very useful [assertHistoryEvent](https://github.com/temporalio/sdk-java/blob/master/temporal-testing/src/main/java/io/temporal/testing/internal/SDKTestWorkflowRule.java#L277) method
which would be nice to have exposed from public TestWorkflowRule as well.

It's possible for users to write this on their own currently, see forum post [here](https://community.temporal.io/t/method-temporal-api-workflowservice-v1-workflowservice-listworkflowexecutions-is-unimplemented-when-using-sdktestworkflowrule/4639). 
It would be nice to have it out of the box if possible. 

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-06 18:54:08.000 UTC</summary>

Users' code doesn't work with history events directly, it works with Temporal API. 
It's a bad practice for application test code to assert Temporal history events which is basically a Temporal internal abstraction.
Tests asserting that Temporal produces a correct internal state should be in Temporal tests, not in user tests
I think we will not expose the convenient methods for it because it will promote a wrong practice.

Users who want to break the abstraction and test Temporal internal behavior are free to do so. Temporal provides all the information needed for that already. But Temporal shouldn't frame it as a good practice and provide a unit test tooling for it.

</details>


---

<a id="1177"></a>

### #1177: WorkflowStub.getResult and getResultAsync do not throw TimeoutException

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1177 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-04-29 17:49:00.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-16 03:52:26.000 UTC |
| **Closed** | 2022-05-16 03:52:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

     
     String result = workflow.getResult(X, TimeUnit.SECONDS, String.class);

If this call times out (workflow does not complete before X seconds):

1. if X < 10
You get GrpcSyncRetryer -> DEADLINE_EXCEEDED: deadline exceeded after Xs
and can catch WorkflowServiceException

3. if X >=10
You get two GrpcSyncRetryer logs:
a) DEADLINE_EXCEEDED: context deadline exceeded
b) Failure, out of retries
and can catch WorkflowServiceException

Same happens with getResultAsync

The only way to catch TimeoutException is if you use getResultAsync and put the timeout on Future.get, for example:

     CompletableFuture<String> future = workflow.getResultAsync(String.class);
     String result = future.get(X, TimeUnit.SECONDS);

Note that even in this case if X >=10 you do get DEADLINE_EXCEEDED in worker logs from GrpcAsyncRetryer





#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-05-11 15:29:17.000 UTC</summary>

#1203 should be done before this to cleanup the long poll implementation

</details>


---

<a id="1139"></a>

### #1139: TestWorkflowEnvironment - add support for filtering for ListOpenWorkflowExecutions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1139 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-04-12 23:34:26.000 UTC (3y 9m ago) |
| **Updated** | 2024-12-17 21:26:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently TestWorkflowEnvironment does support ListOpenWorkflowExecutions, but it does not apply filtering, for example:

StartTimeFilter

       ListOpenWorkflowExecutionsRequest req = ListOpenWorkflowExecutionsRequest
                      .newBuilder()
                      .setStartTimeFilter(StartTimeFilter.newBuilder()
                              .setEarliestTime(Timestamp.newBuilder()
                                      .setSeconds(seconds)
                                      .build())
                              .build())
                      .setNamespace(client.getOptions().getNamespace())
                      .build();


WorkflowTypeFilter

    ListOpenWorkflowExecutionsRequest req = ListOpenWorkflowExecutionsRequest
                    .newBuilder()
                    .setTypeFilter(WorkflowTypeFilter.newBuilder()
                            .setName(type)
                            .build())
                    .setNamespace(client.getOptions().getNamespace())
                    .build();

are not applied when using TestWorkflowEnvironment service and client. 

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-12 23:38:05.000 UTC</summary>

Assigning low priority. 
Test Server is intended for testing Workflow implementations, full on-par support of all administrative endpoints is not really a goal. Workflow logic shouldn‚Äôt trigger listopenworkflowexecutions, it's an admin/operation endpoint.

Leaving it open, because it's good to have.

</details>


---

<a id="1138"></a>

### #1138: Test server does not decrement time skipping lock for outstanding activities on workflow completion

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1138 |
| **State** | OPEN |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-04-12 23:33:23.000 UTC (3y 9m ago) |
| **Updated** | 2024-11-19 19:08:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Steps to Reproduce the Problem

https://github.com/temporalio/sdk-typescript/blob/0f4c391e897d833fadae54fe3b2dc9afdee47720/packages/test/src/test-testenvironment.ts#L87

## Expected Behavior

Calling sleep in the second activity should complete immediately

## Actual Behavior

The second activity sleeps in normal time


#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-10-28 15:58:07.000 UTC</summary>

Here's a test where I had to make a separate test server: https://github.com/temporalio/sdk-python/blob/657a13def5d4e0e0efc8c3e20677e5958bc7da75/tests/worker/test_workflow.py#L2383-L2440. It might be related to this issue. Basically running `poe test` with `-k 'test_workflow_cancel_activity or test_workflow_cancel_signal'` will cause the unlock-and-sleep of the second test to hang.

</details>


---

<a id="1126"></a>

### #1126: Add pass through for Payloads to the default DataConverter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1126 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-04-10 17:21:12.000 UTC (3y 9m ago) |
| **Updated** | 2025-05-15 02:24:03.000 UTC |
| **Closed** | 2025-05-15 02:24:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When implementing a DSL or a generic starter it might be needed to call a typed workflow or activity passing a matching JSON as input. Currently, it is not possible to use the high level APIs as they will pass this JSON as a string. Then receiving workflow or activity would fail to deserialize it.

**Describe the solution you'd like**
I propose to allow application code to pass Payloads as an activity or workflow argument. In this case, the default DataConverter would not look into its content and return it as it is. 

**Describe alternatives you've considered**
Ask users to implement their custom DataConverter.

**Additional context**
Community [thread](https://community.temporal.io/t/rest-api-like-tctl-workflow-start/4402) about this issue.


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-15 02:24:02.000 UTC</summary>

We added this support with the addition of `RawValues`

</details>


---

<a id="1125"></a>

### #1125: PotentialDeadlockException may collect inconsistent stacktraces 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1125 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-04-10 17:16:42.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-19 15:55:39.000 UTC |
| **Closed** | 2022-04-19 15:55:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.10.0 |

#### Description

When JavaSDK detects a potential deadlock, it creates a stack trace for the suspect thread in one place and creates the dump of other workflow threads in another place. Even more, it calls for stacktraces of each individual thread separately.

This leads to the situation that each stacktrace may be collected at a different safepoint and they may be inconsistent.

The relevant pieces of code:

```
throw new PotentialDeadlockException(currentThread.getName(), currentThread.getStackTrace(), this);
```
```
StringBuilder dump = new StringBuilder();
for (WorkflowThread t : threads) {
  if (t.getWorkflowThreadContext() != e.getWorkflowThreadContext()) {
    if (dump.length() > 0) {
      dump.append("\n");
    }
    dump.append(t.getStackTrace());
  }
}
e.setStackDump(dump.toString());
```

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-19 15:55:39.000 UTC</summary>

Closed by #1152

</details>


---

<a id="1114"></a>

### #1114: Suspend and resume Worker can cause Workflow stuck

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1114 |
| **State** | CLOSED |
| **Author** | dorg-wlam |
| **Created** | 2022-03-31 21:43:12.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-19 18:33:51.000 UTC |
| **Closed** | 2022-04-19 18:33:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.10.0 |

#### Description

I am checking out the Worker suspendPolling() and resumePolling() feature, that seems to work initially, but with repeated test workflows can get stuck, and never starts.
Looking at `temporal-matching` logs, I see errors as captured below, not sure if they're directly related.

My code is here https://github.com/dorg-wlam/temporal-example/blob/master/src/main/java/example/runner/ExampleRunner.java
to reproduce it, just run 'submit', 'suspend', 'submit', 'resume', repeatedly.

The other not so high priority issue is that 'suspend' does not take effect immediately, there is no fixed delay or triggering that I can tell when it will go into effect. 'resume' is quick though.

```json
{"level":"error","ts":"2022-03-31T21:09:47.044Z","msg":"matching client encountered error","service":"matching","error":"remote sync match failed","service-error-type":"serviceerror.Canceled","logging-call-at":"metricClient.go:259","stacktrace":"go.temporal.io/server/common/log.(*zapLogger).Error\n\t/temporal/common/log/zap_logger.go:142\ngo.temporal.io/server/common/log.(*throttledLogger).Error.func1\n\t/temporal/common/log/throttle_logger.go:79\ngo.temporal.io/server/common/log.(*throttledLogger).rateLimit\n\t/temporal/common/log/throttle_logger.go:100\ngo.temporal.io/server/common/log.(*throttledLogger).Error\n\t/temporal/common/log/throttle_logger.go:78\ngo.temporal.io/server/client/matching.(*metricClient).finishMetricsRecording\n\t/temporal/client/matching/metricClient.go:259\ngo.temporal.io/server/client/matching.(*metricClient).AddWorkflowTask.func1\n\t/temporal/client/matching/metricClient.go:92\ngo.temporal.io/server/client/matching.(*metricClient).AddWorkflowTask\n\t/temporal/client/matching/metricClient.go:101\ngo.temporal.io/server/service/matching.(*Forwarder).ForwardTask\n\t/temporal/service/matching/forwarder.go:147\ngo.temporal.io/server/service/matching.(*TaskMatcher).Offer\n\t/temporal/service/matching/matcher.go:150\ngo.temporal.io/server/service/matching.(*taskQueueManagerImpl).trySyncMatch\n\t/temporal/service/matching/taskQueueManager.go:523\ngo.temporal.io/server/service/matching.(*taskQueueManagerImpl).AddTask.func1\n\t/temporal/service/matching/taskQueueManager.go:291\ngo.temporal.io/server/common/backoff.Retry.func1\n\t/temporal/common/backoff/retry.go:104\ngo.temporal.io/server/common/backoff.RetryContext\n\t/temporal/common/backoff/retry.go:125\ngo.temporal.io/server/common/backoff.Retry\n\t/temporal/common/backoff/retry.go:105\ngo.temporal.io/server/service/matching.executeWithRetry\n\t/temporal/service/matching/taskQueueManager.go:501\ngo.temporal.io/server/service/matching.(*taskQueueManagerImpl).AddTask\n\t/temporal/service/matching/taskQueueManager.go:281\ngo.temporal.io/server/service/matching.(*matchingEngineImpl).AddWorkflowTask\n\t/temporal/service/matching/matchingEngine.go:280\ngo.temporal.io/server/service/matching.(*Handler).AddWorkflowTask\n\t/temporal/service/matching/handler.go:198\ngo.temporal.io/server/api/matchingservice/v1._MatchingService_AddWorkflowTask_Handler.func1\n\t/temporal/api/matchingservice/v1/service.pb.go:339\ngo.temporal.io/server/common/rpc/interceptor.(*RateLimitInterceptor).Intercept\n\t/temporal/common/rpc/interceptor/rate_limit.go:84\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1116\ngo.temporal.io/server/common/rpc/interceptor.(*TelemetryInterceptor).Intercept\n\t/temporal/common/rpc/interceptor/telemetry.go:108\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\ngo.temporal.io/server/common/metrics.NewServerMetricsTrailerPropagatorInterceptor.func1\n\t/temporal/common/metrics/grpc.go:113\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\ngo.temporal.io/server/common/metrics.NewServerMetricsContextInjectorInterceptor.func1\n\t/temporal/common/metrics/grpc.go:66\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\ngo.temporal.io/server/common/rpc.ServiceErrorInterceptor\n\t/temporal/common/rpc/grpc.go:131\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1121\ngo.temporal.io/server/api/matchingservice/v1._MatchingService_AddWorkflowTask_Handler\n\t/temporal/api/matchingservice/v1/service.pb.go:341\ngoogle.golang.org/grpc.(*Server).processUnaryRPC\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1282\ngoogle.golang.org/grpc.(*Server).handleStream\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1616\ngoogle.golang.org/grpc.(*Server).serveStreams.func1.2\n\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:921"}
```
```json
{"level":"error","ts":"2022-03-31T21:10:29.277Z","msg":"matching client encountered error","service":"matching","error":"remote sync match failed","service-error-type":"serviceerror.Canceled","logging-call-at":"metricClient.go:259","stacktrace":"go.temporal.io/server/common/log.(*zapLogger).Error\n\t/temporal/common/log/zap_logger.go:142\ngo.temporal.io/server/common/log.(*throttledLogger).Error.func1\n\t/temporal/common/log/throttle_logger.go:79\ngo.temporal.io/server/common/log.(*throttledLogger).rateLimit\n\t/temporal/common/log/throttle_logger.go:100\ngo.temporal.io/server/common/log.(*throttledLogger).Error\n\t/temporal/common/log/throttle_logger.go:78\ngo.temporal.io/server/client/matching.(*metricClient).finishMetricsRecording\n\t/temporal/client/matching/metricClient.go:259\ngo.temporal.io/server/client/matching.(*metricClient).AddWorkflowTask.func1\n\t/temporal/client/matching/metricClient.go:92\ngo.temporal.io/server/client/matching.(*metricClient).AddWorkflowTask\n\t/temporal/client/matching/metricClient.go:101\ngo.temporal.io/server/service/matching.(*Forwarder).ForwardTask\n\t/temporal/service/matching/forwarder.go:147\ngo.temporal.io/server/service/matching.(*TaskMatcher).MustOffer\n\t/temporal/service/matching/matcher.go:249\ngo.temporal.io/server/service/matching.(*taskQueueManagerImpl).DispatchTask\n\t/temporal/service/matching/taskQueueManager.go:382\ngo.temporal.io/server/service/matching.(*taskReader).dispatchBufferedTasks\n\t/temporal/service/matching/taskReader.go:114\ngo.temporal.io/server/internal/goro.(*Group).Go.func1\n\t/temporal/internal/goro/group.go:57"}
```

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-04-19 17:19:04.000 UTC</summary>

The problem is in `Worker#isSuspended` not returning the right value sometimes and your code trust this value and doesn't call `#resume` if it's already suspended. Will be fixed in 1.10

</details>


---

<a id="1112"></a>

### #1112: error_prone_core-2.9.0.jar: 1 vulnerabilities (highest severity is: 5.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1112 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-04-01 16:45:04.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-11 14:44:28.000 UTC |
| **Closed** | 2022-04-11 14:44:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>error_prone_core-2.9.0.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/094cc5b59d875cc33f8210f878b73cdf48c35abc">094cc5b59d875cc33f8210f878b73cdf48c35abc</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2021-22569](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2021-22569) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> Medium | 5.5 | protobuf-java-3.4.0.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png' width=19 height=20> CVE-2021-22569</summary>


###  Vulnerable Library - <b>protobuf-java-3.4.0.jar</b></p>

<p>Core Protocol Buffers library. Protocol Buffers are a way of encoding structured data in an
    efficient yet extensible format.</p>
<p>Library home page: <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>Path to dependency file: /temporal-test-server/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.4.0/b32aba0cbe737a4ca953f71688725972e3ee927c/protobuf-java-3.4.0.jar</p>
<p>

Dependency Hierarchy:
  - error_prone_core-2.9.0.jar (Root Library)
    - :x: **protobuf-java-3.4.0.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/094cc5b59d875cc33f8210f878b73cdf48c35abc">094cc5b59d875cc33f8210f878b73cdf48c35abc</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
An issue in protobuf-java allowed the interleaving of com.google.protobuf.UnknownFieldSet fields in such a way that would be processed out of order. A small malicious payload can occupy the parser for several minutes by creating large numbers of short-lived objects that cause frequent, repeated pauses. We recommend upgrading libraries beyond the vulnerable versions.

<p>Publish Date: 2022-01-10
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2021-22569>CVE-2021-22569</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-wrvw-hg22-4m67">https://github.com/advisories/GHSA-wrvw-hg22-4m67</a></p>
<p>Release Date: 2022-01-10</p>
<p>Fix Resolution: com.google.protobuf:protobuf-java:3.16.1,3.18.2,3.19.2; com.google.protobuf:protobuf-kotlin:3.18.2,3.19.2; google-protobuf - 3.19.2</p>

</p>

<p></p>

</details>
<!-- <REMEDIATE>[{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"Java","groupId":"com.google.protobuf","packageName":"protobuf-java","packageVersion":"3.4.0","packageFilePaths":["/temporal-test-server/build.gradle"],"isTransitiveDependency":true,"dependencyTree":"com.google.errorprone:error_prone_core:2.9.0;com.google.protobuf:protobuf-java:3.4.0","isMinimumFixVersionAvailable":true,"minimumFixVersion":"com.google.protobuf:protobuf-java:3.16.1,3.18.2,3.19.2; com.google.protobuf:protobuf-kotlin:3.18.2,3.19.2; google-protobuf - 3.19.2","isBinary":false}],"baseBranches":["master"],"vulnerabilityIdentifier":"CVE-2021-22569","vulnerabilityDetails":"An issue in protobuf-java allowed the interleaving of com.google.protobuf.UnknownFieldSet fields in such a way that would be processed out of order. A small malicious payload can occupy the parser for several minutes by creating large numbers of short-lived objects that cause frequent, repeated pauses. We recommend upgrading libraries beyond the vulnerable versions.","vulnerabilityUrl":"https://vuln.whitesourcesoftware.com/vulnerability/CVE-2021-22569","cvss3Severity":"medium","cvss3Score":"5.5","cvss3Metrics":{"A":"High","AC":"Low","PR":"None","S":"Unchanged","C":"None","UI":"Required","AV":"Local","I":"None"},"extraData":{}}]</REMEDIATE> -->

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-04-11 14:44:28.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by WhiteSource because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the WhiteSource inventory.

</details>


---

<a id="1111"></a>

### #1111: protobuf-java-util-3.19.4.jar: 1 vulnerabilities (highest severity is: 7.7) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1111 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-04-01 16:45:02.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-12 17:28:15.000 UTC |
| **Closed** | 2022-04-12 17:28:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>protobuf-java-util-3.19.4.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.8.6/9180733b7df8542621dc12e21e87557e8c99b8cb/gson-2.8.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.8.6/9180733b7df8542621dc12e21e87557e8c99b8cb/gson-2.8.6.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/094cc5b59d875cc33f8210f878b73cdf48c35abc">094cc5b59d875cc33f8210f878b73cdf48c35abc</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [WS-2021-0419](https://github.com/google/gson/pull/1991) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.7 | gson-2.8.6.jar | Transitive | N/A | &#10060; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> WS-2021-0419</summary>


###  Vulnerable Library - <b>gson-2.8.6.jar</b></p>

<p>Gson JSON library</p>
<p>Library home page: <a href="https://github.com/google/gson">https://github.com/google/gson</a></p>
<p>Path to dependency file: /temporal-serviceclient/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.8.6/9180733b7df8542621dc12e21e87557e8c99b8cb/gson-2.8.6.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.8.6/9180733b7df8542621dc12e21e87557e8c99b8cb/gson-2.8.6.jar</p>
<p>

Dependency Hierarchy:
  - protobuf-java-util-3.19.4.jar (Root Library)
    - :x: **gson-2.8.6.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/094cc5b59d875cc33f8210f878b73cdf48c35abc">094cc5b59d875cc33f8210f878b73cdf48c35abc</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Denial of Service vulnerability was discovered in gson before 2.8.9 via the writeReplace() method.

<p>Publish Date: 2021-10-11
<p>URL: <a href=https://github.com/google/gson/pull/1991>WS-2021-0419</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.7</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: High
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: Low
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/google/gson/releases/tag/gson-parent-2.8.9">https://github.com/google/gson/releases/tag/gson-parent-2.8.9</a></p>
<p>Release Date: 2021-10-11</p>
<p>Fix Resolution: com.google.code.gson:gson:2.8.9</p>

</p>

<p></p>

</details>
<!-- <REMEDIATE>[{"isOpenPROnVulnerability":true,"isPackageBased":true,"isDefaultBranch":true,"packages":[{"packageType":"Java","groupId":"com.google.code.gson","packageName":"gson","packageVersion":"2.8.6","packageFilePaths":["/temporal-serviceclient/build.gradle"],"isTransitiveDependency":true,"dependencyTree":"com.google.protobuf:protobuf-java-util:3.19.4;com.google.code.gson:gson:2.8.6","isMinimumFixVersionAvailable":true,"minimumFixVersion":"com.google.code.gson:gson:2.8.9","isBinary":false}],"baseBranches":["master"],"vulnerabilityIdentifier":"WS-2021-0419","vulnerabilityDetails":"Denial of Service vulnerability was discovered in gson before 2.8.9 via the writeReplace() method.","vulnerabilityUrl":"https://github.com/google/gson/pull/1991","cvss3Severity":"high","cvss3Score":"7.7","cvss3Metrics":{"A":"High","AC":"High","PR":"None","S":"Unchanged","C":"Low","UI":"None","AV":"Network","I":"High"},"extraData":{}}]</REMEDIATE> -->

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-04-12 17:28:15.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by WhiteSource because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the WhiteSource inventory.

</details>


---

<a id="1110"></a>

### #1110: jackson-databind-2.13.1.jar: 1 vulnerabilities (highest severity is: 7.5) - autoclosed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1110 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2022-04-01 16:45:00.000 UTC (3y 9m ago) |
| **Updated** | 2022-09-08 15:50:04.000 UTC |
| **Closed** | 2022-09-08 15:50:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>jackson-databind-2.13.1.jar</b></p></summary>

<p>General data-binding functionality for Jackson: works on core streaming API</p>
<p>Library home page: <a href="http://github.com/FasterXML/jackson">http://github.com/FasterXML/jackson</a></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/radle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in | Remediation Available |
| ------------- | ------------- | ----- | ----- | ----- | --- | --- |
| [CVE-2020-36518](https://vuln.whitesourcesoftware.com/vulnerability/CVE-2020-36518) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> High | 7.5 | jackson-databind-2.13.1.jar | Direct | 2.13.2.1 | &#9989; |


## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png' width=19 height=20> CVE-2020-36518</summary>


###  Vulnerable Library - <b>jackson-databind-2.13.1.jar</b></p>

<p>General data-binding functionality for Jackson: works on core streaming API</p>
<p>Library home page: <a href="http://github.com/FasterXML/jackson">http://github.com/FasterXML/jackson</a></p>
<p>Path to dependency file: /temporal-opentracing/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/radle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar,/home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.13.1/698b2d2b15d9a1b7aae025f1d9f576842285e7f6/jackson-databind-2.13.1.jar</p>
<p>

Dependency Hierarchy:
  - :x: **jackson-databind-2.13.1.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/489b9480700b742795e071c0526460c525dbf044">489b9480700b742795e071c0526460c525dbf044</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
jackson-databind before 2.13.0 allows a Java StackOverflow exception and denial of service via a large depth of nested objects.
 Mend Note: After conducting further research, Mend has determined that all versions of com.fasterxml.jackson.core:jackson-databind up to version 2.13.2 are vulnerable to CVE-2020-36518.

<p>Publish Date: 2022-03-11
<p>URL: <a href=https://vuln.whitesourcesoftware.com/vulnerability/CVE-2020-36518>CVE-2020-36518</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Release Date: 2022-03-11</p>
<p>Fix Resolution: 2.13.2.1</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation is available for this issue
</details>

***

<p>:rescue_worker_helmet: Automatic Remediation is available for this issue.</p>

#### Comments (1)

<details>
<summary><strong>mend-for-github-com</strong> commented on 2022-09-08 15:50:03.000 UTC</summary>

:heavy_check_mark: This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.

</details>


---

<a id="1107"></a>

### #1107: Workflow metadata resolution code registers an overridden method from parent class as a second query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1107 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-03-31 00:38:44.000 UTC (3y 9m ago) |
| **Updated** | 2022-10-13 17:27:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Such a workflow interfaces hierarchy:

```
@WorkflowInterface
public interface ReportingWorkflow extends TemporalWorkflow<ReportQueriesResponse> {
  @WorkflowMethod
  ReportQueriesResponse runReport(ReportQueries reportQueries);

  @QueryMethod
  @Override
  ReportQueriesResponse getResults();
}

public interface TemporalWorkflow<T> extends TemporalRunnable {
  T getResults();
}
```

should be fine.

## Actual Behavior

Triggers `java.lang.IllegalArgumentException: Duplicated name of QUERY: "getResults" declared at "public abstract xxx.ReportingProto$ReportQueriesResponse xxx.ReportingWorkflow.getResults()" and "public default java.lang.Object xxx.ReportingWorkflow.getResults()"`

## Specifications

  - Version: 1.8.x


#### Comments (1)

<details>
<summary><strong>shabalin</strong> commented on 2022-10-13 17:06:29.000 UTC</summary>

The same happened if you override with @WorkflowMethod
```
public interface TemporalWorkflow<T> {
    void execute(T params);
}
```
and then define the actual workflow interface:
```
@WorkflowInterface
public interface SearchTaskWorkflow extends TemporalWorkflow<SearchWorkflowParams> {
    @WorkflowMethod
    @Override
    void execute(SearchWorkflowParams params);
}
```
Workflow registration fails with the error:
```
java.lang.IllegalArgumentException: Duplicated @WorkflowMethod: public default void io.dev.analytics.temporal.SearchTaskWorkflow.execute(java.lang.Object) and public abstract void io.dev.analytics.temporal.SearchTaskWorkflow.execute(io.dev.analytics.service.search.async.SearchWorkflowParams)
	at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods(POJOWorkflowInterfaceMetadata.java:296) ~[temporal-sdk-1.16.0.jar:na]
	at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.<init>(POJOWorkflowInterfaceMetadata.java:205) ~[temporal-sdk-1.16.0.jar:na]
	at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newInstanceInternal(POJOWorkflowInterfaceMetadata.java:184) ~[temporal-sdk-1.16.0.jar:na]
	at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newImplementationInstance(POJOWorkflowInterfaceMetadata.java:153) ~[temporal-sdk-1.16.0.jar:na]
	at io.temporal.common.metadata.POJOWorkflowImplMetadata.<init>(POJOWorkflowImplMetadata.java:107) ~[temporal-sdk-1.16.0.jar:na]
	at io.temporal.common.metadata.POJOWorkflowImplMetadata.newInstance(POJOWorkflowImplMetadata.java:75) ~[temporal-sdk-1.16.0.jar:na]
```

In documentation it's said 
> Note that this approach does not apply to @WorkflowMethod annotations, meaning that when using a base interface, it should not include any @WorkflowMethod methods

but we don't mark the parent interface method with a @WorkflowMethod


I think the reason it's happening is in:
`POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods`

```
    Method[] declaredMethods = current.getDeclaredMethods();
    for (Method declaredMethod : declaredMethods) {
      POJOWorkflowMethod methodMetadata = new POJOWorkflowMethod(declaredMethod);
      if (validateAndQualifiedForWorkflowMethod(methodMetadata)) {
        result.add(methodMetadata);
      }
    }

```

the  `current.getDeclaredMethods()` returns both methods and then in POJOWorkflowMethod constructor there is this
```
 WorkflowMethod workflowMethod = method.getAnnotation(WorkflowMethod.class);
```
which returns not null result for both methods and that causes an error

============== Update ===========================
Looks like the fix could be quite simple for my case:
1. In `POJOWorkflowInterfaceMetadata.validateAndQualifiedForWorkflowMethod` there is a check whether the method is **synthetic**, if positive case it would reject the method. Parent interface method is `synthetic`, _but_  the check happens after another condition (`isAnnotatedWorkflowMethod`) that is true so the execution doesn't reach the synthetic flag checking.
```
    if (isAnnotatedWorkflowMethod) {
      // all methods explicitly marked with one of workflow method qualifiers
      return true;
    }

    if (method.isSynthetic()) {
      // if method is synthetic and not explicitly marked as a workflow method,
      // it's not qualified as a workflow method.
      // https://github.com/temporalio/sdk-java/issues/977
      // https://github.com/temporalio/sdk-java/issues/1331
      return false;
    }
```

Can we do `isAnnotatedWorkflowMethod && !method.isSynthetic()` here ?


</details>


---

<a id="1104"></a>

### #1104: Permissions Error for Links Followed via javadoc.io Search

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1104 |
| **State** | CLOSED |
| **Author** | tomwheeler (Tom Wheeler) |
| **Created** | 2022-03-28 19:33:41.000 UTC (3y 9m ago) |
| **Updated** | 2022-03-28 19:35:51.000 UTC |
| **Closed** | 2022-03-28 19:35:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

According to the sidebar on [this page](https://docs.temporal.io/docs/java/), Temporal's Java SDK documentation is published on javadoc.io, a site that allows one to browse, search, and read API documentation.

## Actual Behavior

Although you can successfully navigate to any page by clicking [links shown on the main API documentation page](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html), navigating to any page in the search results seems to produce an AccessDenied error. I suspect this might be related to the `/undefined/` path segment added to the URL when following search results, as this path segment does not appear in the URL otherwise.

## Steps to Reproduce the Problem

  1. Browse to [the latest API doc for the Temporal Java SDK](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html)
  2. Click the **Search** box near the upper-right corner
  3. Enter **`RetryOptions`** in the box (though any class or method would also demonstrate the problem)
  4. Click any of the matching results
  5. Observe the AccessDenied error similar to the screenshot below:

![image](https://user-images.githubusercontent.com/2183904/160472950-39be4655-9ed4-4656-a22f-19421aeb511d.png)

## Specifications

  - Version: Firefox, version 91.7.1esr (64-bit), but likely not browser-specific
  - Platform: Mac OS Monterey 12.2.1 (21D62), but likely not platform-specific


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-28 19:35:37.000 UTC</summary>

Already addressed in #1078

</details>


---

<a id="1097"></a>

### #1097: Incompatible protobuf-java-util library usage

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1097 |
| **State** | CLOSED |
| **Author** | pmh92 (Pedro Morales) |
| **Created** | 2022-03-24 10:37:34.000 UTC (3y 9m ago) |
| **Updated** | 2022-03-24 16:21:32.000 UTC |
| **Closed** | 2022-03-24 16:21:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
WorkerFactory instance is created properly

## Actual Behavior
The following exception is thrown:
`java.lang.NoSuchMethodError: 'boolean com.google.protobuf.GeneratedMessageV3.isStringEmpty(java.lang.Object)'`

## Steps to Reproduce the Problem

  1. Add io.temporal:temporal-sdk:1.8.1 to pom.xml
  2. Try to instantiate a WorkerFactory
  
## Specifications

  - Version: 1.8.1
  - Platform: macOS


As in the `io.temporal:temporal-serviceclient` pom.xml the version is labelled as follows:
```
<dependency>
      <groupId>com.google.protobuf</groupId>
      <artifactId>protobuf-java-util</artifactId>
      <version>[3.10.0,)</version>
      <scope>compile</scope>
      ...
</dependency> 
```
I found out that there is a new version of `com.google.protobuf:protobuf-java-util` with version **4.0.0-rc-2**. This new version is loaded first, which seems to be incompatible with `io.grpc:grpc-services:1.44.1`.

I fixed this by specifying version **3.19.4** of `com.google.protobuf:protobuf-java-util` in my application's pom.xml

```
<dependency>
      <groupId>com.google.protobuf</groupId>
      <artifactId>protobuf-java-util</artifactId>
      <version>3.19.4</version>
</dependency>
```

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-24 16:21:31.000 UTC</summary>

It's already fixed in master and will be included in the next release.
Duplicates of https://github.com/temporalio/sdk-java/issues/1085 and https://github.com/temporalio/sdk-java/issues/1091

</details>


---

<a id="1091"></a>

### #1091: Maven depends for temporal-sdk 1.8.1 does not respect range constraints for protobuf version

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1091 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-03-22 12:56:30.000 UTC (3y 9m ago) |
| **Updated** | 2022-03-22 14:59:43.000 UTC |
| **Closed** | 2022-03-22 14:59:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

In a Maven build when adding dependency:

        <dependency>
            <groupId>io.temporal</groupId>
            <artifactId>temporal-sdk</artifactId>
            <version>1.8.1</version>
        </dependency>

and running 

mvn dependency:tree

The depends pulls:

            +- com.google.protobuf:protobuf-java-util:jar:4.0.0-rc-2:compile (version selected from constraint [3.10.0,))
                    [ INFO] |  |  |  \- com.google.protobuf:protobuf-java:jar:4.0.0-rc-2:compile

The version range for proto was recently [restricted](https://github.com/temporalio/sdk-java/blob/master/build.gradle#L22), which should help, just opening this issue so we make sure to test it with next sdk release and Maven to make sure the new restriction is applied. 


#### Comments (1)

<details>
<summary><strong>tsurdilo</strong> commented on 2022-03-22 14:59:42.000 UTC</summary>

Tested with 1.9.0-SNAPSHOT and the updated range pulls
com.google.protobuf:protobuf-java-util:jar:3.20.0-rc-1
so the restriction to not pull 4.x seems to be working great. Will close. 

</details>


---

<a id="1085"></a>

### #1085: range dependency declaration in 1.8.1 causes NoSuchMethodError: com.google.protobuf.GeneratedMessageV3.isStringEmpty

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1085 |
| **State** | CLOSED |
| **Author** | kgignatyev (Konstantin Ignatyev) |
| **Created** | 2022-03-19 21:27:24.000 UTC (3y 9m ago) |
| **Updated** | 2022-03-19 21:52:08.000 UTC |
| **Closed** | 2022-03-19 21:47:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | 1.9.0 |

#### Description

## Expected Behavior
Executes normally

## Actual Behavior
At runtime see Exception 
Mar 19, 2022 2:06:48 PM io.grpc.stub.ClientCalls$ThreadlessExecutor waitAndDrain
WARNING: Runnable threw exception
java.lang.NoSuchMethodError: com.google.protobuf.GeneratedMessageV3.isStringEmpty(Ljava/lang/Object;)Z
	at io.grpc.health.v1.HealthCheckRequest.getSerializedSize(HealthCheckRequest.java:154)
	at io.grpc.protobuf.lite.ProtoInputStream.available(ProtoInputStream.java:108)
	at io.grpc.internal.MessageFramer.getKnownLength(MessageFramer.java:205)
	at io.grpc.internal.MessageFramer.writePayload(MessageFramer.java:137)
	at io.grpc.internal.AbstractStream.writeMessage(AbstractStream.java:65)
	at io.grpc.internal.ForwardingClientStream.writeMessage(ForwardingClientStream.java:37)
	at io.grpc.internal.DelayedStream$6.run(DelayedStream.java:283)
	at io.grpc.internal.DelayedStream.drainPendingCalls(DelayedStream.java:182)
	at io.grpc.internal.DelayedStream.access$100(DelayedStream.java:44)
	at io.grpc.internal.DelayedStream$4.run(DelayedStream.java:148)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:741)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	at io.grpc.health.v1.HealthGrpc$HealthBlockingStub.check(HealthGrpc.java:252)
	at io.temporal.serviceclient.WorkflowServiceStubsImpl.lambda$checkHealth$2(WorkflowServiceStubsImpl.java:286)
	at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:61)
	at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:51)
	at io.temporal.serviceclient.WorkflowServiceStubsImpl.checkHealth(WorkflowServiceStubsImpl.java:279)
	at io.temporal.serviceclient.WorkflowServiceStubsImpl.<init>(WorkflowServiceStubsImpl.java:186)
	at io.temporal.serviceclient.WorkflowServiceStubs.newInstance(WorkflowServiceStubs.java:51)
	at io.temporal.serviceclient.WorkflowServiceStubs.newInstance(WorkflowServiceStubs.java:41)

## Steps to Reproduce the Problem
run hello world workflow with only this declaration
 `    <dependency>
            <groupId>io.temporal</groupId>
            <artifactId>temporal-sdk</artifactId>
            <version>1.8.1</version>
        </dependency>
`
![image](https://user-images.githubusercontent.com/868783/159138949-97579e97-2299-4871-a4df-227d688a2ea9.png)
there is 
com.google.protobuf:protobuf-java-util:jar:4.0.0-rc-2:compile (version selected from constraint [3.10.0,))
## Steps to mitigate problem
add explicit version dependency 
`
   <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java-util</artifactId>
            <version>3.19.4</version>
        </dependency>
`
## Specifications

  - Version: SDK 1.8.1
  - Platform:  openjdk version "1.8.0_322"
OpenJDK Runtime Environment (Zulu 8.60.0.21-CA-macosx) (build 1.8.0_322-b06)
OpenJDK 64-Bit Server VM (Zulu 8.60.0.21-CA-macosx) (build 25.322-b06, mixed mode)

 mvn --version
Apache Maven 3.8.5 (3599d3414f046de2324203b78ddcf9b5e4388aa0)
Maven home: /usr/local/Cellar/maven/3.8.5/libexec
Java version: 1.8.0_322, vendor: Azul Systems, Inc., runtime: /Users/kignatyev/.sdkman/candidates/java/8.0.322-zulu/zulu-8.jdk/Contents/Home/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "mac os x", version: "10.16", arch: "x86_64", family: "mac"


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-19 21:47:07.000 UTC</summary>

Thank you for the report. It's already fixed in the current master, you will get it with the new release.

</details>


---

<a id="1080"></a>

### #1080: Bug when building WorkerOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1080 |
| **State** | CLOSED |
| **Author** | javiercanillas (Javier Canillas) |
| **Created** | 2022-03-17 21:58:48.000 UTC (3y 9m ago) |
| **Updated** | 2022-03-18 00:36:04.000 UTC |
| **Closed** | 2022-03-18 00:36:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

## Expected Behavior
Have different values of `maxConcurrentActivityExecutionSize` and `maxConcurrentLocalActivityExecutionSize` when configuring `WorkerOptions`.

## Actual Behavior
`maxConcurrentLocalActivityExecutionSize` is configured using `maxConcurrentActivityExecutionSize` when building the object:

Taken from `WorkerOptions.Builder.build()` [here](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/worker/WorkerOptions.java#L288):
```java
    public WorkerOptions build() {
      return new WorkerOptions(
          maxWorkerActivitiesPerSecond,
          maxConcurrentActivityExecutionSize,
          maxConcurrentWorkflowTaskExecutionSize,
          maxConcurrentActivityExecutionSize,
          maxTaskQueueActivitiesPerSecond,
          workflowPollThreadCount,
          activityPollThreadCount,
          localActivityWorkerOnly,
          defaultDeadlockDetectionTimeout);
    }
```
It should be:

```java
    public WorkerOptions build() {
      return new WorkerOptions(
          maxWorkerActivitiesPerSecond,
          maxConcurrentActivityExecutionSize,
          maxConcurrentWorkflowTaskExecutionSize,
          maxConcurrentLocalActivityExecutionSize,
          maxTaskQueueActivitiesPerSecond,
          workflowPollThreadCount,
          activityPollThreadCount,
          localActivityWorkerOnly,
          defaultDeadlockDetectionTimeout);
    }
```

See the change on the 4th argument.

## Steps to Reproduce the Problem

  1. Create an `WorkerOptions.Builder` object.
  2. Set the attribute `maxConcurrentActivityExecutionSize` with value 10
  3. Set the attribute `maxConcurrentLocalActivityExecutionSize` with value 200
  4. Call `build` over the Builder instance
  5. Check that the built object `WorkerOptions` will have both `maxConcurrentActivityExecutionSize` and `maxConcurrentLocalActivityExecutionSize` with value 10.

## Specifications
  - Version: temporal-sdk-1.3.1
  - Platform: java


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-03-17 22:31:23.000 UTC</summary>

Confirm, thanks for the report!

Please use `validateAndBuildWithDefaults` as a temporary workaround if you need one. This is our main method to build Options instances right now.

Reactions: üëç 1

</details>


---

<a id="1051"></a>

### #1051: PollWorkflowTaskQueueResponse should be available for interception

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1051 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-22 02:48:17.000 UTC (3y 10m ago) |
| **Updated** | 2022-02-22 14:24:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
PollWorkflowTaskQueueResponse has the information about the WorkflowTask and contains some pieces of information that may be needed for reporting/logging.
Specifically, the most interesting one is PollWorkflowTaskQueueResponse#attempt that may be used to log workflows that can't progress for a long time.

**Describe the solution you'd like**
PollWorkflowTaskQueueResponse or some parts of it should be made available to the user-configured handler/interceptor. 

TBD. It also can become an input of a new method of WorkflowInboundInterceptor. TBD because currently all methods of Interceptors are extremely bound to the user code lifecycle and directly connected to events in the user code, while this method would be something that interceptors are not currently observed/expose.

**Describe alternatives you've considered**
To solve the specific problem of reporting a workflow that doesn't progress because of a large number of failures, we can just hardcode logging in a manner that Server currently does: https://github.com/temporalio/temporal/blob/61b9b65744e455d4a85681b117e8315287911621/service/history/workflow/workflow_task_state_machine.go#L763
This solution is not flexible and doesn't move the extensibility of the SDK forward though.

**Additional context**
Related to https://github.com/temporalio/temporal/issues/2526

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-02-22 14:24:50.000 UTC</summary>

Technically this can be done with a gRPC interceptor. My concern with putting in our interceptors is we won't get to change our polling mechanism without breaking it. If it's needed for reporting/logging, maybe just making the most recent task available for a getter is good enough?

If done via our interceptors, arguably `pollWorkflowTaskQueue` should be on the outbound interceptor (and an equivalent for activities). I had considered putting it on the client interceptors, but in some languages like TypeScript that is a bit more difficult since it's Core that makes the call.

Also, we might want a general cross-SDK issue at https://github.com/temporalio/sdk-features or at least a general cross-SDK discussion because TypeScript won't be able to do this as cleanly as Go/Java.

</details>


---

<a id="1042"></a>

### #1042: Add ability to dynamically limit number of parallel activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1042 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-02-17 01:29:04.000 UTC (3y 10m ago) |
| **Updated** | 2024-04-29 17:43:21.000 UTC |
| **Closed** | 2024-04-29 17:43:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A user wants to execute an activity only if there is enough heap space left in a process.

**Describe the solution you'd like**
Provide a pluggable component that the user can tailor for his needs. This component would be called with poll request and can decide to delay the poll if some conditions are not satisfied.

**Additional context**
https://community.temporal.io/t/workloads-metrics/4002

#### Comments (1)

<details>
<summary><strong>Sushisource</strong> commented on 2024-04-29 17:43:21.000 UTC</summary>

Closing this since the interface now exists as of https://github.com/temporalio/sdk-java/pull/2014

Still in an experimental state, but functionality is there now and will evolve based on feedback.

</details>


---

<a id="1032"></a>

### #1032: Add ability to disable workflow worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1032 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-04 23:00:55.000 UTC (3y 11m ago) |
| **Updated** | 2025-05-26 14:44:19.000 UTC |
| **Closed** | 2025-05-26 14:44:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Cross-posting from GoSDK:
https://github.com/temporalio/sdk-go/issues/636

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2022-02-04 23:11:32.000 UTC</summary>

Note, we had to add an option in Go because we allowed registering of workflows _after_ the worker started. If Java requires all registration happen before worker is started, you can just not turn on the workflow worker/poller if no workflows were registered (same for activity).

</details>


---

<a id="1030"></a>

### #1030: Rename poller related WorkerOptions options

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1030 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-04 20:58:50.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-11 18:20:49.000 UTC |
| **Closed** | 2022-02-11 18:20:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
JavaSDK has `WorkerOptions`: `#workflowPollThreadCount` and `#activityPollThreadCount`.
GoSDK has `WorkerOptions` with the same meaning: `#MaxConcurrentWorkflowTaskPollers` and `#MaxConcurrentActivityTaskPollers`.

**Describe the solution you'd like**
GoSDK naming is more generic and should be preferred for unification between SDKs.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-02-11 18:20:48.000 UTC</summary>

Closed by #1031

</details>


---

<a id="1028"></a>

### #1028: Missing WorkflowExecutionUtils.describeWorkflowInstance()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1028 |
| **State** | CLOSED |
| **Author** | SilverSheep (SilverSheep) |
| **Created** | 2022-02-03 15:17:06.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-03 15:38:11.000 UTC |
| **Closed** | 2022-02-03 15:22:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | question, invalid |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I want to upgrade from temporalio/sdk-java 1.1.0 to 1.8.0, but I've encountered a problem. New version is missing `WorkflowExecutionUtils.describeWorkflowInstance()` method. As I've checked - it was still available in 1.3.1, but during refactoring of `WorkflowExecutionUtils` in 1.4.0 it was removed. 

Why was it removed? Is there an alternative to get workflow execution status?

## Expected Behavior
WorkflowExecutionUtils.describeWorkflowInstance() is available

## Actual Behavior
WorkflowExecutionUtils.describeWorkflowInstance() is missing 

## Steps to Reproduce the Problem

  1. Use version 1.1.0 of temporalio/sdk-java
  1. Use WorkflowExecutionUtils.describeWorkflowInstance() somewhere in your code
  1. Update temporalio/sdk-java to version 1.8.0
  1. Try to compile your code

## Specifications

  - Version: 1.8.0
  - Platform: Linux


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-02-03 15:22:42.000 UTC</summary>

`io.temporal.internal.common.WorkflowExecutionUtils` is an internal class and you shouldn't be using it in the first place.
Internal classes get refactored without any consideration for users who may be using them.
This method is right now located in `io.temporal.internal.client.WorkflowClientHelper`, but it can be removed any time again from there because it's still an internal class.

This is the implementation of this method that you can drop in your project if you need it, it's a trivial API call.
```
  public static WorkflowExecutionInfo describeWorkflowInstance(
      WorkflowServiceStubs service,
      String namespace,
      WorkflowExecution workflowExecution) {
    DescribeWorkflowExecutionRequest describeRequest =
        DescribeWorkflowExecutionRequest.newBuilder()
            .setNamespace(namespace)
            .setExecution(workflowExecution)
            .build();
    DescribeWorkflowExecutionResponse executionDetail =
        service
            .blockingStub()
            .describeWorkflowExecution(describeRequest);
    return executionDetail.getWorkflowExecutionInfo();
  }
```

We may productize and expose an official SDK API for these kinds of calls as a part of https://github.com/temporalio/sdk-java/issues/976 effort, but for now, you should be using the gRPC stubs directly.

Please use [Temporal Forum](https://community.temporal.io/) or [Temporal Slack](https://temporal.io/slack) for questions.

</details>


---

<a id="1027"></a>

### #1027: Javadocs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1027 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-03 00:21:34.000 UTC (3y 11m ago) |
| **Updated** | 2025-05-13 16:51:08.000 UTC |
| **Closed** | 2025-05-13 16:50:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | documentation, epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Description

Tracking areas that need improvements in Javadocs

# Tasks

- [ ] CancelationScope.cancel
- [x] #387
- [x] #752
- [ ] Workflow.registerListener revisit is needed, "The object must implement at least one interface annotated
   * with {@link WorkflowInterface}" is not true, javadoc should also mention `DynamicSignalHandler` and `DynamicQueryHandler`
- [ ] https://github.com/temporalio/sdk-java/blob/914ecf176b926b1dd736320dc94a159b939f1f46/temporal-sdk/src/main/java/io/temporal/activity/ActivityOptions.java#L167
- [x] #1318

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:50:18.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="1011"></a>

### #1011: UX - Java SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1011 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-30 07:47:15.000 UTC (3y 11m ago) |
| **Updated** | 2025-05-13 16:42:50.000 UTC |
| **Closed** | 2025-05-13 16:42:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Description

User experience improvements

# Core Objectives

Some parts of the JDK APIs are not easy to use, require workarounds, and seemingly unneeded additional artificial efforts from users to implement things. Tasks under this epic are intended to improve such an experience. Usually, these tasks are not blockers and have reasonable safe workarounds and alternatives.

# Tasks

- [ ] #1009
- [ ] #1010
- [ ] #1098

# Related user requests / reports


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:42:49.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="1005"></a>

### #1005: Provide ActivityExecutionContext#isCancelled

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1005 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-25 20:14:42.000 UTC (3y 11m ago) |
| **Updated** | 2025-08-27 17:56:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, the only way for an activity to know that it's canceled is heartbeating and getting a CancellationException from the heartbeat.
1. Not all activities need to heartbeat and making them do it just to check for cancelation is ugly.
2. Local Activities don't heartbeat, so now there is no way to notify them that they should cancel (for example, because there is a timeout). GoSDK has go context for it, Java has nothing. Using Interruption here is not right, because we need to distinguish it from a thread interruption during the shutdown to keep things clean. 
3. Heartbeating activities may not be able to reach the service , the SDK should keep tack of the heartbeat timeout and fail if it can't reach the server in time.

**Describe the solution you'd like**
ActivityExecutionContext#isCancelled method that activity can periodically check as an alternative to listening cancelations through heart beating. This solution will be close to the native Interruption design in Java: We will have an exception if Activity calls a heartbeat and a flag otherwise.

**Additional context**
This is related to #1004. There is no way to notify Local Activity about the cancelation.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-06-09 06:38:25.000 UTC</summary>

We should also add a more detailed method (name TBD) that returns an object that contains the reason/reasons for the activity being cancelled.

</details>


---

<a id="989"></a>

### #989: Retry Interval doesn't work for LocalActivity, default value is used instead

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/989 |
| **State** | CLOSED |
| **Author** | GeekNickson (Sadboi) |
| **Created** | 2022-01-20 14:25:49.000 UTC (3y 11m ago) |
| **Updated** | 2022-01-20 20:26:23.000 UTC |
| **Closed** | 2022-01-20 20:26:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.8.0 |

#### Description

Retry interval doesn't work for LocalActivity. 
The problem is that in LocalActivityWorker.class there is a method "handleLocalActivity", which sets retryPolicy.
in line 255 there is a check:
`if (retryPolicy.getMaximumInterval().getNanos() > 0) {
        roBuilder.setMaximumInterval(
            ProtobufTimeUtils.toJavaDuration(retryPolicy.getMaximumInterval()));
}`

The problem is that getNanos() always returns 0, so default value is used. It doesn't matter if use MethodRetry annotation or specify RetryOptions via setRetryOptions method of LocalActivityOptions. (I do specify nanos in Duration.ofSeconds(30, 1) like so)

## Specifications

  - Version: 1.7.1
  - Platform: 1.7.1


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-20 18:13:24.000 UTC</summary>

Confirm. Thanks for the report!

</details>


---

<a id="979"></a>

### #979: Gauge metrics disappear after ~60 seconds

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/979 |
| **State** | CLOSED |
| **Author** | desheffer (Doug Sheffer) |
| **Created** | 2022-01-15 00:06:35.000 UTC (3y 12m ago) |
| **Updated** | 2022-01-26 19:25:02.000 UTC |
| **Closed** | 2022-01-26 19:25:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.8.0 |

#### Description

## Expected Behavior

After configuring a metrics scope (similar to what is described here: https://community.temporal.io/t/how-to-enable-metrics-support-using-java-sdk/366/2), I am having issues getting "gauge" metrics to register properly.

It seems that I can report metrics directly to the `MicrometerClientStatsReporter`, like this:

```
reporter.reportGauge("my_gauge", new HashMap<>(), 123.0);
```

Or, if I am inside the context of a Workflow, like this:

```
Workflow.getMetricsScope().gauge("my_gauge").update(123.0);
```

In either example, I would expect to see "my_gauge" in my metrics backend, and I would expect to see it updated whenever this code runs.

## Actual Behavior

In actuality, I am seeing the gauge value being reported, but it disappears approximately 60 seconds later. If I restart my program, the gauge starts reporting again, but it stops again after 60 seconds. If I try using a counter or a timer, then those seem to work fine. But there seems to be a problem that is specific to gauges.

Digging a bit deeper... It seems that both code examples above make use of the `reportGauge` method in the `MicrometerClientStatsReporter`. This method uses the `io.micrometer.core.instrument.MeterRegistry` to create a new gauge each time it is called. Once created, it updates the gauge using a value of type `double`.

This appears to violate 2 warnings listed in the [Gauges section](https://micrometer.io/docs/concepts#_gauges) of the Micrometer documentation. To summarize from section 9.1:

> Attempting to construct a gauge with a primitive number or one of its `java.lang` object forms is always incorrect.

From section 9.3, titled "Why is My Gauge Reporting NaN or Disappearing?":

> It is your responsibility to hold a strong reference to the state object that you are measuring with a  `Gauge`.

One more note is that if I create a `Gauge` through the `io.micrometer.core.instrument.MeterRegistry` directly (as well as using an `AtomicLong` and ensuring that it's not garbage collected), then the bug does not appear. In other words, I don't believe that my metrics backend is where the values are getting dropped.

## Steps to Reproduce the Problem

  1. Enable metrics as described here: https://community.temporal.io/t/how-to-enable-metrics-support-using-java-sdk/366/2
  2. Create a new gauge using one of the examples above
  3. Verify that the gauge is being reported to your metrics backend
  4. Wait for approximately 60 seconds and the gauge _should_ stop being reported

## Specifications

  - Version: tested with Java SDK v1.5.0 and v1.7.0; Temporal is v1.14.0
  - Platform: Docker on Linux
  - Metrics backend: Prometheus

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-24 02:22:00.000 UTC</summary>

Confirm, it does look like a bug in Temporal `MicrometerClientStatsReporter` where we incorrectly integrate tally and micrometer interfaces.
Thank you for the detailed report!

</details>


---

<a id="977"></a>

### #977: Static and synthetic methods are considered Activity methods in activity interfaces

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/977 |
| **State** | CLOSED |
| **Author** | WellingR (Ruud Welling) |
| **Created** | 2022-01-14 16:14:46.000 UTC (3y 12m ago) |
| **Updated** | 2022-03-18 21:40:15.000 UTC |
| **Closed** | 2022-03-18 21:40:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

## Expected Behavior
While running a jacoco coverage run on my temporal project. I discovered that temporal tries to register activity types for generated (synthetic) methods.

I would expect that running with or without jacoco has no influcence on the result of the test itself.

Jacoco generates the following method with is both static and synthetic (can be seen using reflection: `Method::isSynthetic()`
`private static boolean[] com.mypackage.GreetingActivities.$jacocoInit(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.Class)`

The java spec states:
> A construct emitted by a Java compiler must be marked as synthetic if it does not correspond to a construct declared explicitly or implicitly in source code, unless the emitted construct is a class initialization method 

To me it would make sense for temporal to ignore synthetic methods. As well as static methods.

## Actual Behavior

```
java.lang.IllegalArgumentException: "$jacocoInit" activity type is already registered with the worker
	at io.temporal.internal.activity.POJOActivityTaskHandler.registerActivityImplementation(POJOActivityTaskHandler.java:140)
	at io.temporal.internal.activity.POJOActivityTaskHandler.registerActivityImplementations(POJOActivityTaskHandler.java:93)
	at io.temporal.internal.sync.SyncActivityWorker.registerActivityImplementations(SyncActivityWorker.java:91)
	at io.temporal.worker.Worker.registerActivitiesImplementations(Worker.java:313)
```


## Steps to Reproduce the Problem

Change `HelloActivity` in the temporal java samples as follows:

Ensure there are two activity interfaces declared, which both have a static methods:
```java
  @ActivityInterface
  public interface GreetingActivities {

    @ActivityMethod
    String composeGreeting(String greeting, String name);

    static String name() {
      return "1";
    }
  }

  @ActivityInterface
  public interface GreetingActivities2 {

    @ActivityMethod
    String composeGreeting2(String greeting, String name);

    static String name() {
      return "2";
    }
  }
```
Ensure that both interfaces are implemented (GreetingActivities already has an implementation)
```java
  static class GreetingActivitiesImpl2 implements GreetingActivities2 {
    @Override
    public String composeGreeting2(String greeting, String name) {
      return greeting + " " + name + "!";
    }
  }
```
In the first test in `HelloActivityTest`, ensure that both activity implementaitons are registered
```java
    testWorkflowRule
        .getWorker()
        .registerActivitiesImplementations(
            new GreetingActivitiesImpl(), new HelloActivity.GreetingActivitiesImpl2());
```

Enable jacoco in build.gradle.
```
plugins {
    ... (existing plugins here) ...
    id 'jacoco'
}

jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
}

jacoco {
    toolVersion = "0.8.7"
    reportsDir = file("$buildDir/jacoco")
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport // report is always generated after tests run
}
```

Then run `  ./gradlew clean  jacocoTestReport`

## Specifications

  - Version: The samples used temporal-sdk 1.7.0
  - Platform: MacOs (Monerey M1), reproduced using both JDK 11 and 17


#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2022-01-23 21:52:24.000 UTC</summary>

An activity interface defines the signature of remote calls. Having static methods in this interface doesn't really make sense as the caller workflow and an activity implementation can reside in completely different codebases and processes. 

</details>


---

<a id="955"></a>

### #955: Expose a method allowing user code to defined if they are inside workflow thread

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/955 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-06 18:21:57.000 UTC (4 years ago) |
| **Updated** | 2022-01-10 22:46:49.000 UTC |
| **Closed** | 2022-01-10 18:06:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.7.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Users want to reuse pieces of code in workflow and outside of the workflow context and use deterministic `Workflow` class methods if they are inside a workflow context and non-deterministic versions if they are outside.

**Describe the solution you'd like**
Probably a method on the `Workflow` class returning true if we are executing inside a workflow thread

**Describe alternatives you've considered**
- Not exposing access to this info, maybe enforcing users to don't share code in such a manner.
- Give an API, but not on `Workflow`, but somewhere deeper, which will highlight the fact that it may be not a good practice.

**Additional context**
Related discussion in a Temporal Support Slack: https://temporalio.slack.com/archives/CTT84KXK9/p1641489380001200


#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2022-01-06 18:23:37.000 UTC</summary>

I have no objections having that we document the intended purpose well.

</details>


---

<a id="929"></a>

### #929: Can't register activity implementation that uses inheritance

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/929 |
| **State** | CLOSED |
| **Author** | aniketbhatnagar (Aniket Bhatnagar) |
| **Created** | 2021-12-15 12:00:01.000 UTC (4 years ago) |
| **Updated** | 2021-12-28 20:43:48.000 UTC |
| **Closed** | 2021-12-28 16:21:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.7.0 |

#### Description

## Expected Behavior
Consider the following:
```
@ActivityInterface
public interface BlockListenerActivities {
     @ActivityMethod
     Optional<BlockRef> processNextBlock();
}

@Slf4j
public abstract class BaseBlockListenerActivities implements BlockListenerActivities {
    @Override
    public final Optional<BlockRef> processNextBlock() {
        return doProcessNextBlock();
    }

    abstract protected Optional<BlockRef> doProcessNextBlock();
}

@Slf4j
public class BlockListenerActivitiesImpl extends BaseBlockListenerActivities {
    @Override
    protected Optional<BlockRef> doProcessNextBlock() {
        log.info("Processing next ETH block");
        return Optional.empty();
    }
}
```

Then, registering the activity implementation (`worker.registerActivitiesImplementations(new BlockListenerActivitiesImpl());`) should work.


## Actual Behavior
Registering the activity implementation (`worker.registerActivitiesImplementations(new BlockListenerActivitiesImpl());`) causes the exception `Class doesn't implement any non empty interface annotated with @ActivityInterface: BlockListenerActivitiesImpl`.

It seems that that SDK expects `BlockListenerActivitiesImpl` to explicitly say `implements BlockListenerActivities`. 

I ran into this is because I was provided a "quarkus" injected bean that automatically extends the activity implementation class to form a proxy like `ActivityImpl_ClientProxy extends ActivityImpl` and temporal SDK rejects `ActivityImpl_ClientProxy` as a valid activity implementation.

## Steps to Reproduce the Problem
Use the code snippet above and register activity using `worker.registerActivitiesImplementations(new BlockListenerActivitiesImpl());`


## Specifications

  - Version: temporal-sdk 1.6.0
  - Platform: Reproduced on Mac with jdk 14 but should be applicable on all platforms.


#### Comments (1)

<details>
<summary><strong>tsurdilo</strong> commented on 2021-12-15 15:38:12.000 UTC</summary>

Community Forum ref: https://community.temporal.io/t/cant-register-activity-implementation-that-uses-inheritance/3603

</details>


---

<a id="901"></a>

### #901: Workers hammering server with incorrectly formed commands without rate limit or backoff

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/901 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-24 22:45:22.000 UTC (4y 1m ago) |
| **Updated** | 2021-11-29 23:37:32.000 UTC |
| **Closed** | 2021-11-29 23:32:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

If workflow code is broken and creates an invalid command, workflow task gets failed-> recreated-> retried in a cycle. As a result, all workers end up utilizing all of their allowed by `maxConcurrentWorkflowTaskExecutionSize` (200 by default) parallel tasks processors to just hammer the server with either faulty commands or just reports about failed-again-workflow-task.
We need some kind of backoff or rate-limiting.

Caused by user report in the community slack: https://temporalio.slack.com/archives/CTT84KXK9/p1637700233132300
Related to: #898 #900

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-11-29 23:31:03.000 UTC</summary>

We can't handle it on the SDK side only in effective manner and we need support from Server to have an Exponential Backoff for Workflow Tasks, hence https://github.com/temporalio/temporal/issues/2238

On the SDK side, we implement proactive validation of Options that could cause invalid commands, so at least we have the default SDK side backoff utilizing Workflow Task Run Timeout.

But we make a conscious decision that we don't try to fully duplicate server-side validation logic and we will be performing only basic sanity checks on SDKs, which leaves the opportunity for a workflow code to effectively DDOS the server until server-side exponential backoff is in place.

</details>


---

<a id="886"></a>

### #886: testActivityScheduleToCloseTimeout is flaky with dockerized service

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/886 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-17 21:58:11.000 UTC (4y 1m ago) |
| **Updated** | 2022-01-13 22:40:31.000 UTC |
| **Closed** | 2022-01-13 22:40:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

[java-sdk-public_build_109_docker-unit-test-with-docker-service.log](https://github.com/temporalio/sdk-java/files/7558235/java-sdk-public_build_109_docker-unit-test-with-docker-service.log)


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-13 22:40:31.000 UTC</summary>

not anymore

</details>


---

<a id="878"></a>

### #878: Implement autoscaling of Pollers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/878 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-16 19:15:19.000 UTC (4y 1m ago) |
| **Updated** | 2025-05-16 22:39:07.000 UTC |
| **Closed** | 2025-05-16 22:39:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Temporal have default magic numbers of 5 activity pollers and 2 workflow pollers. 
We have some guidance on how these numbers can be selected adjusted, but we shouldn't be making users guess and adjust these numbers. SDK can adapt them accordingly to the load profile of executors and pollers.

#### Comments (1)

<details>
<summary><strong>bergundy</strong> commented on 2021-11-16 19:18:20.000 UTC</summary>

@Spikhalskiy this requires a bit of design.
Whatever we come up with should be ported to all SDKs.

</details>


---

<a id="856"></a>

### #856: WorkflowClient#execute doesn't pair correctly with workflowStub.getResult()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/856 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-03 22:36:18.000 UTC (4y 2m ago) |
| **Updated** | 2022-04-13 22:05:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | tsurdilo |
| **Milestone** | Next |

#### Description

## Actual behavior

https://github.com/Spikhalskiy/java-sdk/commit/40c0d626e0ea4778a956e388d33754e67bde23a8#diff-7cfba47d2337ff3ee746b09a4d916e5e839f9b8bff45a26e588727667437c160R94
```
  @Test
  public void executeAndGetResultFromStub() throws InterruptedException, ExecutionException {
    TestNoArgsWorkflowProc stubP =
        testWorkflowRule.newWorkflowStubTimeoutOptions(TestNoArgsWorkflowProc.class);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(stubP);
    CompletableFuture<Void> executeCF = WorkflowClient.execute(stubP::proc);

    // This test hangs (times out), but uncommenting of either if these two lines makes it
    // pass, which doesn't make much sense
    // sleep(1000);
    // executeCF.get();
    workflowStub.getResult(Void.class);
  }
```

This unit test for a trivial workflow, that finishes immediately, hangs.
Uncommenting on either sleep or waiting for a completable future makes it pass.
Replacing execute with start (that returns `WorkflowExecution`) also makes this test pass.

## Expected behavior

The test passes.

#### Comments (1)

<details>
<summary><strong>joelmarty</strong> commented on 2022-02-10 15:24:06.000 UTC</summary>

I am seeing a similar issue with `WorkflowClient.execute()` but not sure if it is exactly the same situation, as calling `Thread.sleep()` or waiting on the future does not fix it:

The use case looks like this:
```java
class EventConsumer {

  private WorkflowClient workflowClient;

  public EventConsumer(WorkflowClient client) {
    this.workflowClient = client;
  }

  public void accept(Stream<SomeEvent> eventStream) {
    eventStream.forEach(event -> {
      final var workflowOptions = WorkflowOptions.newBuilder()
        .setTaskQueue("someQueue)
        .setWorkflowId(event.getId())
        .setWorkflowIdReusePolicy(WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY)
        .build();
      final var workflow = workflowClient.newWorkflowStub(MyWorkflow.class, workflowOptions);
      WorkflowClient.execute(workflow::processEvent, event)
        .whenComplete((v, throwable) -> log.info("completed"));
    });
  }
}
```

The test case uses junit5 extension:
```java
class EventConsumerTest {
  @RegisterExtension
  public static final TestWorkflowExtension testWorkflowExtension = TestWorkflowExtension.newBuilder()
    .setWorkflowClientOptions(WorkflowClientOptions.newBuilder()
      .setNamespace("namespace")
      .build())
    .setWorkflowTypes(MyWorkflow.class)
    .setDoNotStart(true)
    .build();

  @Test
  void startWorkflow(TestWorkflowEnvironment testEnv, Worker worker) {
    MyActivity activity = mock(MyActivity.class, withSettings().withoutAnnotations());
    worker.registerActivitiesImplementations(activity);
    testEnv.start();

    EventConsumer consumer = new EventConsumer(testEnv.getWorkflowClient());

    // assertJ assertion
    assertThatCode(() -> consumer.accept(Stream.of(event))).doesNotThrowAnyException();

    // mockito verification
    then(activity).should(timeout(5000)).doSomething();
}
```

The test times out after 5s as specified on the mockito verification and the (anonymized) log trace looks like this:
```
16:11:05.761 [main] INFO io.temporal.serviceclient.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=directaddress:///3c1827fc-4a62-4d7d-a725-efe16cfef991}}
16:11:05.777 [main] INFO io.temporal.serviceclient.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=5, target=directaddress:///06e8951f-ef30-489d-80fb-ec06add9150e}}
16:11:05.881 [main] INFO io.temporal.internal.worker.Poller - start: Poller{name=Workflow Poller taskQueue="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", namespace="namespace", identity=37008@myhostname}
16:11:05.885 [main] INFO io.temporal.internal.worker.Poller - start: Poller{name=Local Activity Poller taskQueue="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", namespace="namespace", identity=37008@myhostname}
16:11:05.887 [main] INFO io.temporal.internal.worker.Poller - start: Poller{name=Activity Poller taskQueue="namespace", namespace="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", identity=37008@myhostname}
16:11:05.888 [main] INFO io.temporal.internal.worker.Poller - start: Poller{name=Host Local Workflow Poller, identity=90621874-bf17-42a0-b6b4-16b5f6433a3b}
16:11:11.266 [main] INFO io.temporal.worker.WorkerFactory - shutdownNow: WorkerFactory{identity=37008@myhostname, uniqueId=90621874-bf17-42a0-b6b4-16b5f6433a3b}
16:11:11.266 [main] INFO io.temporal.internal.worker.Poller - shutdown: Poller{name=Host Local Workflow Poller, identity=90621874-bf17-42a0-b6b4-16b5f6433a3b}
16:11:11.272 [main] INFO io.temporal.worker.WorkerFactory - awaitTermination begin: WorkerFactory{identity=37008@myhostname, uniqueId=90621874-bf17-42a0-b6b4-16b5f6433a3b}
16:11:11.272 [Host Local Workflow Poller: 3] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@2f410cb5
16:11:11.272 [Host Local Workflow Poller: 4] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@1da8bb99
16:11:11.272 [Host Local Workflow Poller: 2] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@368de08f
16:11:11.272 [Host Local Workflow Poller: 1] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@56e21162
16:11:11.272 [Host Local Workflow Poller: 5] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@18cc9d5b
16:11:11.526 [TemporalShutdownManager: 1] INFO io.temporal.internal.worker.Poller - shutdown: Poller{name=Workflow Poller taskQueue="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", namespace="namespace", identity=37008@myhostname}
16:11:11.527 [Workflow Poller taskQueue="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", namespace="namespace": 1] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@1d1ce3ca
16:11:11.527 [Workflow Poller taskQueue="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", namespace="namespace": 2] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@61c24b97
16:11:11.529 [TemporalShutdownManager: 1] INFO io.temporal.internal.worker.Poller - shutdown: Poller{name=Activity Poller taskQueue="namespace", namespace="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", identity=37008@myhostname}
16:11:11.529 [TemporalShutdownManager: 1] INFO io.temporal.internal.worker.Poller - shutdown: Poller{name=Local Activity Poller taskQueue="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", namespace="namespace", identity=37008@myhostname}
16:11:11.530 [Local Activity Poller taskQueue="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]", namespace="namespace": 1] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@775ac2f4
16:11:11.530 [Activity Poller taskQueue="namespace", namespace="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]": 3] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@13f7bf0c
16:11:11.530 [Activity Poller taskQueue="namespace", namespace="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]": 5] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@17e59124
16:11:11.530 [Activity Poller taskQueue="namespace", namespace="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]": 2] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@1604dc95
16:11:11.530 [Activity Poller taskQueue="namespace", namespace="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]": 1] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@130e4636
16:11:11.530 [Activity Poller taskQueue="namespace", namespace="WorkflowTest-startWorkflow(TestWorkflowEnvironment, Worker)-[engine:junit-jupiter]/[class:com.xyz.EventConsumerTest]/[method:startWorkflow(io.temporal.testing.TestWorkflowEnvironment, io.temporal.worker.Worker)]": 4] INFO io.temporal.internal.worker.Poller - poll loop is terminated: io.temporal.internal.worker.Poller$PollLoopTask@72885c3d
16:11:11.783 [main] INFO io.temporal.worker.WorkerFactory - awaitTermination done: WorkerFactory{identity=37008@myhostname, uniqueId=90621874-bf17-42a0-b6b4-16b5f6433a3b}
16:11:11.784 [main] INFO io.temporal.serviceclient.WorkflowServiceStubsImpl - shutdownNow
16:11:11.790 [ForkJoinPool.commonPool-worker-19] DEBUG io.temporal.internal.retryer.GrpcAsyncRetryer - Retrying after failure
io.grpc.StatusRuntimeException: UNAVAILABLE: Channel shutdownNow invoked
```

</details>


---

<a id="850"></a>

### #850: Document gRPC retrying logic and parameters across SDKs and normalize the approach

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/850 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-28 23:18:06.000 UTC (4y 2m ago) |
| **Updated** | 2023-05-23 17:02:07.000 UTC |
| **Closed** | 2023-05-23 17:02:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Each SDK has a little different implementation of gRPC retry/deadline logic and parameters and default values for them.

**Describe the solution you'd like**
We should write a unified specification including default parameter values and normalize the retrying behavior across SDKs.

**Describe alternatives you've considered**
Each SDK went its own way while looking around. And it has to change. There are too many moving parts - deadline_exceeded, timeout of single calls, total default timeouts for different kinds of calls, jitter in retries, etc.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 17:02:07.000 UTC</summary>

Closing in favor of https://github.com/temporalio/features/issues/27 since this is a cross SDK issue

</details>


---

<a id="842"></a>

### #842: Test env - ListOpenWorkflowExecutionsResponse exec status is always WORKFLOW_EXECUTION_STATUS_UNSPECIFIED

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/842 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2021-10-26 17:20:43.000 UTC (4y 2m ago) |
| **Updated** | 2022-01-07 20:53:15.000 UTC |
| **Closed** | 2022-01-07 20:53:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

To reproduce:
1. Simple workflow (just like a workflow.sleep, no activities, signals etc) with an "execute" workflow method
2. Simple test using 

        @Rule
            public TestWorkflowRule testWorkflowRule =
                    TestWorkflowRule.newBuilder()
                            .setWorkflowTypes(MyWorkflowImpl.class)
                            .build();

3. In test method start the workflow async:

           MyWorkflow workflow =
                      testWorkflowRule
                              .getWorkflowClient()
                              .newWorkflowStub(
                                      MyWorkflow.class,
                                      WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());
           WorkflowExecution execution = WorkflowClient.start(workflow::execute, myTestInput);

4. List open workflow executions:
     
        ListOpenWorkflowExecutionsResponse result = testWorkflowRule.blockingStub()
                .listOpenWorkflowExecutions( ListOpenWorkflowExecutionsRequest.newBuilder()
                .setNamespace(testWorkflowRule.getTestEnvironment().getNamespace()).build());

5. Check that execution size is 1:

        assertEquals(result.getExecutionsList().size(), 1);

6. Check the status: 

        result.getExecutionsList().get(0).getStatus()

7. See that status is always 

       WorkflowExecutionStatus.WORKFLOW_EXECUTION_STATUS_UNSPECIFIED


Should be WorkflowExecutionStatus.WORKFLOW_EXECUTION_STATUS_RUNNING

Community forum reference: https://community.temporal.io/t/when-running-unit-tests-getting-status-workflow-execution-status-unspecified/3246

#### Comments (1)

<details>
<summary><strong>adrien-layer</strong> commented on 2021-10-29 10:33:10.000 UTC</summary>

Hello, thanks again for verifying the bug report and following-up by creating this GitHub issue.

In order for us to plan ahead, do you have rough estimates regarding when a new release might contain a fix for this?
Order of magnitude of days, weeks, months?

Thank you very much

</details>


---

<a id="840"></a>

### #840: Add "listQueries" built-in query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/840 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2021-10-25 15:49:52.000 UTC (4y 2m ago) |
| **Updated** | 2024-02-02 21:26:56.000 UTC |
| **Closed** | 2024-02-02 21:26:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

temporalio/sdk-features#51

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-02-02 21:26:56.000 UTC</summary>

Closing as duplicate of #335 

</details>


---

<a id="828"></a>

### #828: Expose health check on WorkflowServiceStubs or WorkflowClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/828 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-19 16:53:25.000 UTC (4y 2m ago) |
| **Updated** | 2022-04-29 16:36:20.000 UTC |
| **Closed** | 2022-04-29 16:36:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.11.0 |

#### Description

Temporal SDK should expose a method like `WorkflowServiceStubs#healthCheck` or `WorkflowServiceStubs#isHealthy` that allows users to check if the WorkflowClient/WorkflowServiceStubs underlying channel / connection to Temporal server is healthy.
There were quite a bit of user requests for such a method from users for all SDKs.
Having this method on Stubs is preferable over WorkflowClient, because it's the lowest level abstraction on top of the channel and WorkflowClient can just fall back on the WorkflowServiceStubs method. But if the language doesn't have a wrapper for stubs (like Java does), this method may be on WorkflowClient.

Issues for other SDKs:
https://github.com/temporalio/sdk-go/issues/595
https://github.com/temporalio/sdk-node/issues/312

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2021-10-19 17:23:08.000 UTC</summary>

@Spikhalskiy - Will wait on suggested Java signatures before adding to Go.

To confirm, are you thinking `healthCheck` just invokes https://github.com/grpc/grpc/blob/790ce5c97ff3a3922d50a1fd3a4bab91e2bcd435/src/proto/grpc/health/v1/health.proto#L45 for the workflow service, and then returns a boolean? And `isHealthy` returns the boolean based on the client's existing known knowledge (i.e. last health check, not a new one)? We can definitely do both easily in Go.

</details>


---

<a id="815"></a>

### #815: [Port] Allow multiple host:port to be specified for connection

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/815 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-12 16:09:53.000 UTC (4y 3m ago) |
| **Updated** | 2024-09-18 23:26:42.000 UTC |
| **Closed** | 2024-09-18 23:26:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

JavaSDK should have this change from Go SDK incorporated: https://github.com/temporalio/sdk-go/pull/582
An original description from Go SDK request (https://github.com/temporalio/sdk-go/issues/577):

### Distribute pollers to multiple frontend servers.

**Is your feature request related to a problem? Please describe.**
When worker configured to have multiple pollers, all pollers share one connection and will poll from only one frontend server. This does not work well when worker count is the same or smaller than frontend server count.

**Describe the solution you'd like**
There should have an option to be able to specify how many connections you want for one worker so the load is more evenly distributed among frontend servers. 

**Describe alternatives you've considered**
User has to start more workers to have the load more evenly distributed across all frontend servers.



#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2024-09-18 23:26:42.000 UTC</summary>

Closing as original Go PR was closed in favour of DNS based approach

</details>


---

<a id="814"></a>

### #814: testUntypedChildStubWorkflowAsync flaked in CI with test service internal state machine exception

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/814 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-12 15:01:17.000 UTC (4y 3m ago) |
| **Updated** | 2022-07-06 14:20:25.000 UTC |
| **Closed** | 2022-07-06 14:20:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

All parts of the test log:
[testUntypedChildStubWorkflowAsync.log](https://github.com/temporalio/sdk-java/files/7331051/testUntypedChildStubWorkflowAsync.log)

This failure looks very similar to #830
They are most likely related and should be evaluated together.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-06 14:20:24.000 UTC</summary>

Closed by #1289

</details>


---

<a id="802"></a>

### #802: whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows flakes with Dockerized service

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/802 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-06 21:55:06.000 UTC (4y 3m ago) |
| **Updated** | 2022-01-13 22:43:24.000 UTC |
| **Closed** | 2022-01-13 22:43:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`StickyWorkerTest#whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows` flakes with Dockerized Temporal service in buildkite.
[java-sdk_build_2396_java-unit-test-with-docker-service.log](https://github.com/temporalio/sdk-java/files/7297347/java-sdk_build_2396_java-unit-test-with-docker-service.log)


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-13 22:43:24.000 UTC</summary>

not anymore

</details>


---

<a id="779"></a>

### #779: History produced by test environment should be compliant with tctl history format

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/779 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-28 17:44:21.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-28 20:28:35.000 UTC |
| **Closed** | 2021-09-28 20:28:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

JavaSDK mostly migrated replaying logic and helpers onto tctl history format: https://github.com/temporalio/sdk-java/issues/300
But in case of a test fail, the history that gets generated is not compliant with tctl format.
The test environment should produce histories that can be used in the replayer.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-28 20:28:35.000 UTC</summary>

tctl format is not really human-readable because of the way protobuf JsonFormat handles ByteString format by converting it to Base64. See https://github.com/protocolbuffers/protobuf/issues/2801#issuecomment-285812695

So we have to stick to using TextFormat for human consumption printing which is not tctl compatible.


</details>


---

<a id="778"></a>

### #778: üßµ Performance & Threading model

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/778 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-28 15:59:02.000 UTC (4y 3m ago) |
| **Updated** | 2025-06-11 20:30:48.000 UTC |
| **Closed** | 2025-05-13 16:41:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | epic |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ‚ù§Ô∏è 5 |

#### Description

# Description

Improve threading model in different areas of JavaSDK

# Core Objectives

With the absence of coroutines, we create and use short-living separate Java threads for a lot of things. 
This is wasteful and can be reworked to pooling, event loops, work-stealing, or any other solution that will minimize threads churning and also will allow management and constraining of resources used by a single workflow.

# Workflow threads

- [x] #294
- [ ] #214
- [x] Add workflowId to workflow thread name
- [x] #1120

# Performance

- [x] #760
- [x] #998
- [x] #1456
- [x] #343
- [ ] #1413 
- [x] #878
- [ ] Consider implementing a streaming interface on the server and SDKs instead of a long poll
- [ ] #1707

# Related user requests / reports

- [ ] #1211

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2025-05-13 16:41:22.000 UTC</summary>

Closing since we no longer want to use GH issues as epics

</details>


---

<a id="762"></a>

### #762: AuthorizationGrpcMetadataProvider doesn't have a public constructor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/762 |
| **State** | CLOSED |
| **Author** | jrpedrianes (Jorge Rodr√≠guez Pedrianes) |
| **Created** | 2021-09-24 12:23:44.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-24 17:03:59.000 UTC |
| **Closed** | 2021-09-24 17:03:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

## Expected Behavior
Allow to instantiate AuthorizationGrpcMetadataProvider

## Actual Behavior
We can't create an AuthorizationGrpcMetadataProvider instance without using the same package.

## Steps to Reproduce the Problem
 
## Specifications

  - Version: 1.3.1
  - Platform: sdk-java


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-24 16:45:25.000 UTC</summary>

I will fix it in 1.4.0


If you need a workaround now, please extend the `AuthorizationGrpcMetadataProvider ` class and expose the constructor.

Reactions: üëç 1

</details>


---

<a id="760"></a>

### #760: Implement Workflow Tasks backpressure for Pollers if there is no available executors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/760 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-23 17:33:14.000 UTC (4y 3m ago) |
| **Updated** | 2022-09-16 04:55:29.000 UTC |
| **Closed** | 2022-09-16 04:55:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | 1.17.0 |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now the WFT polling logic is to always poll first, then try to send the task to the processing executor. If there is a significant imbalance or misconfiguration of pollers/executors, it can cause significant delays and backlog of WFT.

**Describe the solution you'd like**
Poller should pause polling in this case until a processing thread is freed up.

**Describe alternatives you've considered**
Scaling by decreasing the number of pollers or increasing the number of worker threads. This requires manual work that doesn't have to be needed and it's also a static solution that can't adjust to dynamic changes in a workload.

**Additional context**
Similar change was implemented earlier for Activities: #286


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-09-16 04:55:28.000 UTC</summary>

Closed by #1431

</details>


---

<a id="743"></a>

### #743: SignalTest#testSignalUntyped is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/743 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-20 16:00:17.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-25 02:36:58.000 UTC |
| **Closed** | 2021-10-25 02:36:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

`SignalTest#testSignalUntyped` is disabled for being flaky.
We should investigate and enable it back.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-10-25 02:36:58.000 UTC</summary>

This test is reenabled back for some time and doesn't flake. Close for now.

</details>


---

<a id="664"></a>

### #664: GrpcRetryer should have a special handling of ResourceExhausted exception

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/664 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-24 21:21:16.000 UTC (4y 4m ago) |
| **Updated** | 2023-05-23 16:58:16.000 UTC |
| **Closed** | 2023-05-23 16:58:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Due to its nature, ResourceExhausted should be a retryable exception for GrpcRetryer by default, at the same time it probably needs a special handling (for example, more aggressive backoff).
Specifics are TBD.

#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 16:58:16.000 UTC</summary>

resolved by https://github.com/temporalio/sdk-java/pull/1465

</details>


---

<a id="652"></a>

### #652: Make WorkflowStub#getResult timeout configurable on WorkflowOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/652 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-19 18:58:42.000 UTC (4y 4m ago) |
| **Updated** | 2023-04-19 20:40:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Right now the caller can set a timeout on getResult by working directly with  WorkflowStub using the following method:
https://github.com/temporalio/sdk-java/blob/b0199150b69bb5a4eaf6c13ba4b89c2a8746a113/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowStubImpl.java#L232

But if the caller is not using the low-level stub API and just calls the workflow method of a workflow proxy (which most of our users for sure do) a method with `Integer.MAX_VALUE` timeout is used by default:
https://github.com/temporalio/sdk-java/blob/b0199150b69bb5a4eaf6c13ba4b89c2a8746a113/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowStubImpl.java#L222

We should allow defining the `#getResult` timeout on WorkflowOptions to allow the neat proxy API to enforce reasonable timeouts.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-19 20:40:23.000 UTC</summary>

Related to #88. All methods of WorkflowStub and/or WorkflowClient should have some way to be limited by a user-supplied timeout.

</details>


---

<a id="650"></a>

### #650: Add unit tests for WorkflowExecutionUtils#getInstanceCloseEvent 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/650 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-19 18:31:21.000 UTC (4y 4m ago) |
| **Updated** | 2021-09-30 15:25:02.000 UTC |
| **Closed** | 2021-09-30 15:25:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

WorkflowExecutionUtils right now is completely untestable and unmockable, we should decouple this class into testable pieces to make it possible to cover it with unit tests.
The first unit test worth adding is a unit test for an issue fixed in https://github.com/temporalio/sdk-java/pull/472

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-30 15:25:01.000 UTC</summary>

This was mostly covered by extensive GrpcRetryer reworking and testing done in the last couple of months.

</details>


---

<a id="628"></a>

### #628: In TestWorkflowEnviornment, getResult() hangs after terminate()

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/628 |
| **State** | CLOSED |
| **Author** | nagl-stripe |
| **Created** | 2021-08-12 22:55:23.000 UTC (4y 5m ago) |
| **Updated** | 2021-09-08 18:36:08.000 UTC |
| **Closed** | 2021-09-08 16:35:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

## Expected Behavior
Against the real temporal server, calling WorkflowStub.getResult() for a workflow that has been terminated immediately throws a WorkflowFailedException. The test environment should behave the same way.

## Actual Behavior
getResult() hangs indefinitely or until the user-supplied timeout.

## Steps to Reproduce the Problem

  1. git clone git@github.com:nagl-stripe/samples-java.git
  1. Run GreetingWorkflow.java. As checked in, it demonstrates the hanging behavior.
  1. To see the expected behavior, `docker-compose up`, change useReal to true on line 154, and re-run.

## Specifications

  - Version: 1.2.0
  - Platform: Cassandra, but probably doesn't matter.

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-09-03 18:41:20.000 UTC</summary>

Small simplification for the sample, you can do:
```
workflow.terminate("testing");
```
instead of 
```
    TerminateWorkflowExecutionRequest terminateWorkflowExecutionRequest =
        TerminateWorkflowExecutionRequest.newBuilder()
            .setReason("testing")
            .setWorkflowExecution(execution)
            .setNamespace("default")
            .build();

    client
        .getWorkflowServiceStubs()
        .blockingStub()
        .terminateWorkflowExecution(terminateWorkflowExecutionRequest);
```
Which will also reproduce the same problem.

</details>


---

<a id="607"></a>

### #607: Automate pre-release SDK testing against samples-java & canary-java

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/607 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-07-26 21:31:22.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-15 22:12:07.000 UTC |
| **Closed** | 2021-08-15 22:12:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently we run a snapshot of prerelease against [samples-java](https://github.com/temporalio/samples-java) & [canary-java](https://github.com/temporalio/canary-java) manually.

**Describe the solution you'd like**
Automate.


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-15 22:12:07.000 UTC</summary>

It's an internal infrastructure related issue, please move to Notion.

</details>


---

<a id="600"></a>

### #600: Allow context propagator to be set on LocalActivityOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/600 |
| **State** | CLOSED |
| **Author** | ravikrn13 (Ravi Kiran) |
| **Created** | 2021-07-22 17:29:29.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-15 19:50:15.000 UTC |
| **Closed** | 2021-07-22 17:50:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | invalid |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Users should be able to add custom ContextPropagators to LocalActivityOptions just like ActivityOptions.

## Actual Behavior
LocalActivityOptions does not have a list of context propagators and users are unable to add custom ContextPropagators.

## Steps to Reproduce the Problem

  1. Create a LocalActivityOption using builder
  2. Implement a ContextPropagator.
  3. Try to set the new ContextPropagator to LocalActivityOption.

## Specifications

  - Version: 1.0.9
  - Platform: sdk-java


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-07-22 17:50:45.000 UTC</summary>

It's a duplicate of https://github.com/temporalio/sdk-java/issues/490

Please see a resolution there describing why we decided that it's not something we want to implement. Please use WorkerOptions#contextPropagators instead.

I will consider improving a Javadoc of ActivityOptions#contextPropagators to include information about its extremely limited use case. I can see how this option can easily be misunderstood right now like it's something that can be set up and applied on both the workflow worker (client) and activity worker side and it happened to me initially too. While in fact, ActivityOptions#contextPropagators stay on the client-side only and can't be applied on a worker side. See https://github.com/temporalio/sdk-java/issues/490 for more details.


</details>


---

<a id="599"></a>

### #599: Default MDC entries not propagated to LocalActivities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/599 |
| **State** | CLOSED |
| **Author** | ravikrn13 (Ravi Kiran) |
| **Created** | 2021-07-22 17:21:48.000 UTC (4y 5m ago) |
| **Updated** | 2021-07-22 18:00:58.000 UTC |
| **Closed** | 2021-07-22 17:56:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
WorkflowId, RunId etc should be propagated to LocalActivities. 

## Actual Behavior
MDC entries like WorkflowId, RunId etc are not propagated to LocalActivities. These entries are absent.
This [section](https://github.com/temporalio/sdk-java/blob/b0199150b69bb5a4eaf6c13ba4b89c2a8746a113/temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java#L182) from ActivityWorker is not present in LocalActivityWorker [handle](https://github.com/temporalio/sdk-java/blob/b23edac35fc6ef4fe44685f9897027f9d1d5569e/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivityWorker.java#L200) method

From the thread: https://community.temporal.io/t/mdc-values-not-present-for-local-activities/2502/4

## Steps to Reproduce the Problem

  1. Create a Workflow.
  2. Create a LocalActivity.
  3. Invoke local activity from workflow.
  4. Inside local activity print `MDC.get(LoggerTag.WORKFLOW_ID) ` . 

## Specifications

  - Version: 1.0.9
  - Platform: java-sdk


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-07-22 17:56:31.000 UTC</summary>

This a duplicate of https://github.com/temporalio/sdk-java/issues/489 and it's fixed. We also have a unit test checking exactly MDC propagation to local activities: https://github.com/temporalio/sdk-java/commit/b23edac35fc6ef4fe44685f9897027f9d1d5569e#diff-061e39ce33d4eacc5c8d5a281e5497251fa53188779217af391d87c363e4c918R1107

Please feel free to reopen this issue providing a failing unit test or code demonstrating the problem.

</details>


---

<a id="586"></a>

### #586: Activities advised with AspectJ are not recognised as implementation of @ActivityInterface anymore

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/586 |
| **State** | CLOSED |
| **Author** | adriil (Adrien LESUR) |
| **Created** | 2021-07-12 18:41:28.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-15 11:12:13.000 UTC |
| **Closed** | 2021-07-15 11:12:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

From a working Spring Boot application that successfully registers Activities implementation with `io.temporal.worker.Worker.registerActivitiesImplementations`, when I add an `@Aspect` component to advise my Activities method, application should still start successfully.

## Actual Behavior

Application startup fails with the following log : `Class doesn't implement any non empty interface annotated with @ActivityInterface: com.example.test.InitialActivityImpl$$EnhancerBySpringCGLIB$$10ca071e`
```
{
	"@timestamp": "2021-07-12T18:54:43.736671+02:00",
	"application": "Test as a Service",
	"class": "org.springframework.beans.factory.support.ConstructorResolver",
	"correlation_id": "e6888554-0c11-485c-842b-7c010a0709bb",
	"data_version": 2,
	"description": "Application run failed",
	"environment": "dev",
	"exception_obj": {
		"cause": "Failed to instantiate [com.example.mos.configuration.SourceWorkerConfiguration$$EnhancerBySpringCGLIB$$bdd1899]: Constructor threw exception; nested exception is java.lang.IllegalArgumentException: Class doesn't implement any non empty interface annotated with @ActivityInterface: com.example.test.InitialActivityImpl$$EnhancerBySpringCGLIB$$10ca071e",
		"message": "Error creating bean with name 'com.example.mos.configuration.SourceWorkerConfiguration': Bean instantiation via constructor failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.example.mos.configuration.SourceWorkerConfiguration$$EnhancerBySpringCGLIB$$bdd1899]: Constructor threw exception; nested exception is java.lang.IllegalArgumentException: Class doesn't implement any non empty interface annotated with @ActivityInterface: com.example.test.InitialActivityImpl$$EnhancerBySpringCGLIB$$10ca071e",
		"stacktrace": "org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'com.example.mos.configuration.SourceWorkerConfiguration': Bean instantiation via constructor failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.example.mos.configuration.SourceWorkerConfiguration$$EnhancerBySpringCGLIB$$bdd1899]: Constructor threw exception; nested exception is java.lang.IllegalArgumentException: Class doesn't implement any non empty interface annotated with @ActivityInterface: com.example.test.InitialActivityImpl$$EnhancerBySpringCGLIB$$10ca071e
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:313)
	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:294)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1356)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1203)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:556)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:897)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:879)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:551)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:744)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:391)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1204)
	at com.example.app.Application.main(Application.java:44)
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.example.mos.configuration.SourceWorkerConfiguration$$EnhancerBySpringCGLIB$$bdd1899]: Constructor threw exception; nested exception is java.lang.IllegalArgumentException: Class doesn't implement any non empty interface annotated with @ActivityInterface: com.example.test.InitialActivityImpl$$EnhancerBySpringCGLIB$$10ca071e
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:217)
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:117)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:309)
	... 19 more
Caused by: java.lang.IllegalArgumentException: Class doesn't implement any non empty interface annotated with @ActivityInterface: com.example.test.InitialActivityImpl$$EnhancerBySpringCGLIB$$10ca071e
	at io.temporal.common.metadata.POJOActivityImplMetadata.<init>(POJOActivityImplMetadata.java:109)
	at io.temporal.common.metadata.POJOActivityImplMetadata.newInstance(POJOActivityImplMetadata.java:53)
	at io.temporal.internal.sync.POJOActivityTaskHandler.registerActivityImplementation(POJOActivityTaskHandler.java:110)
	at io.temporal.internal.sync.POJOActivityTaskHandler.registerActivityImplementations(POJOActivityTaskHandler.java:179)
	at io.temporal.internal.sync.SyncActivityWorker.registerActivityImplementations(SyncActivityWorker.java:55)
	at io.temporal.worker.Worker.registerActivitiesImplementations(Worker.java:326)
	at com.example.mos.configuration.SourceWorkerConfiguration.<init>(SourceWorkerConfiguration.java:93)
	at com.example.mos.configuration.SourceWorkerConfiguration$$EnhancerBySpringCGLIB$$bdd1899.<init>(<generated>)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:204)
	... 21 more
",
		"type": "org.springframework.beans.factory.BeanCreationException"
	},
	"level": "ERROR",
	"line": 313,
	"method": "instantiate",
	"number_of_events": 1,
	"request_id": "e6888554-0c11-485c-842b-7c010a0709bb",
	"roletype": "dev",
	"thread": "main",
	"type": "log"
}
```

## Steps to Reproduce the Problem

  1. Considering an application that registers the following Activity implementation
  ```java
  @ActivityInterface(namePrefix = "myactivity")
  public interface MyActivity {
      void run(Object param);
      void rollback(Object param);
  }

  @Slf4j
  @Component
  public class MyActivityImpl implements MyActivity {

      @Override
      public void run(Object param) {
          log.info("Initiate Activity - Running the default run method");
      }

      @Override
      public void rollback(Object param) {
        log.info("Initiate Activity - Running the default rollback method");
      }
  }
  ```
  2. The implementation is registered like the following
  ```java
  worker.registerActivitiesImplementations(myActivityImpl);
  ```
  3. Add an `@Aspect` component to advise your Activity implementation methods
  ```java
@Slf4j
@Aspect
@Component
public class MyLoggerAspect {

    /**
     * Matches activities run/rollback methods.
     *
     * @param method Activity's run/rollback method
     * @throws Throwable any exception Activity method might throw
     */
    @Around("execution(* com.example.test.*.*(java.lang.Object))")
    public void aroundActivityMethod(ProceedingJoinPoint method) throws Throwable {
        log.info("Starting the Activity");

        // Run the activity method
        method.proceed();
       
        log.info("Activity completed")
    }
  ```
  4. Start the application -> it fails
  5. Comment the line with the `@Around` or put a different path that doesn't match the Activity implementation path and try again -> application startup successful

## Specifications

  - Version: 
    - SDK `1.0.4`,  `1.0.7` and `1.1.0`
    - Sprint Boot `2.1.9`
  - Platform: macOS Big Sur, OpenJDK 11


#### Comments (1)

<details>
<summary><strong>adriil</strong> commented on 2021-07-15 11:12:12.000 UTC</summary>

After some research I've found out that this is because of Spring AOP proxying the advised classes using CGLIB by default.

Because of this, the advised Activity implementation that `worker` receives is actually a proxy to the implementation but not the implementation itself (debug view below).
```
1 = {InitialActivityImpl$$EnhancerBySpringCGLIB$$cbcf576b@14778} "com.[...].InitialActivityImpl@3ea9b180"
 CGLIB$BOUND = false
 CGLIB$CALLBACK_0 = {CglibAopProxy$DynamicAdvisedInterceptor@14792} 
 CGLIB$CALLBACK_1 = {CglibAopProxy$StaticUnadvisedInterceptor@14793} 
 CGLIB$CALLBACK_2 = {CglibAopProxy$SerializableNoOp@14794} 
 CGLIB$CALLBACK_3 = {CglibAopProxy$StaticDispatcher@14795} 
 CGLIB$CALLBACK_4 = {CglibAopProxy$AdvisedDispatcher@14796} 
 CGLIB$CALLBACK_5 = {CglibAopProxy$EqualsInterceptor@14797} 
 CGLIB$CALLBACK_6 = {CglibAopProxy$HashCodeInterceptor@14798} 
 migrationService = null
```

So I needed to add the non-empty `@ActivityInterface` interface inside of the proxy, which could be achieved with the code below : 
* a custom `AnnotationAwareAspectJAutoProxyCreator` that adds the interface to the ProxyFactory
```java
public class CompanyMigrationAspectProxyCreator extends AnnotationAwareAspectJAutoProxyCreator {

    /**
     * Map that gives the correct non-empty @ActivityInterface for each Activities.
     */
    private final Map<Class, Class> activityImplAndInterface;

    @Autowired
    public CompanyMigrationAspectProxyCreator(final InitiateActivity initiateActivityImpl) {
        activityImplAndInterface = Map.of(initiateActivityImpl.getClass(), InitiateActivity.class);
    }

    /**
     * Customizes AOP proxies of our Activities to add non-empty @ActivityInterface required by Temporal SDK.
     *
     * @param proxyFactory the proxy factory
     */
    @Override
    protected void customizeProxyFactory(ProxyFactory proxyFactory) {
        Class<?> activityInterface = activityImplAndInterface.get(proxyFactory.getTargetClass());

        if (activityInterface != null) {
            proxyFactory.addInterface(activityInterface);
        }
    }

}
```
* a little hack taken from [there](https://github.com/spring-projects/spring-boot/issues/25367#issuecomment-781999430) that allows to inject my custom AnnotationAwareAspectJAutoProxyCreator instead of the regular one, when applicable
```java
    /**
     * Injects our own AnnotationAwareAspectJAutoProxyCreator ({@link CompanyMigrationAspectProxyCreator})
     * to answer Temporal requirements to have Activities proxies to proxy non-empty @ActivityInterface.
     *
     * @return bean factory post processor
     */
    @Bean
    static BeanFactoryPostProcessor replaceDefaultAspectAutoProxyCreator() {
        return (beanFactory) -> {
            BeanDefinition definition = beanFactory.getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);
            if (AnnotationAwareAspectJAutoProxyCreator.class.getName().equals(definition.getBeanClassName())) {
                definition.setBeanClassName(CompanyMigrationAspectProxyCreator.class.getName());
            }
        };
    }
```

Reactions: üëç 1

</details>


---

<a id="514"></a>

### #514: DescribeWorkflowExecution is not implemented for the java test service.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/514 |
| **State** | CLOSED |
| **Author** | drewhoskins-stripe (Drew Hoskins) |
| **Created** | 2021-05-26 23:28:23.000 UTC (4y 7m ago) |
| **Updated** | 2021-08-30 19:57:12.000 UTC |
| **Closed** | 2021-08-30 19:57:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Works

## Actual Behavior
`Method temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution is unimplemented.`

## Steps to Reproduce the Problem
I reproduced this using the out-of-proc test service (https://github.com/temporalio/sdk-java/pull/470/files) which simply exposes the GRPC, but I'm guessing you'd rather reproduce this in process by writing a test.


## Specifications

  - Version:
  - Platform:


#### Comments (1)

<details>
<summary><strong>drewhoskins-stripe</strong> commented on 2021-05-26 23:30:53.000 UTC</summary>

I'd be happy to help contribute if somebody could fast-forward me by telling me some of the places I need to edit and where I should put the test (and perhaps similar tests to pattern-match off of.)

</details>


---

<a id="503"></a>

### #503: Make DEFAULT_DEADLOCK_DETECTION_TIMEOUT configurable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/503 |
| **State** | CLOSED |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2021-05-20 20:46:48.000 UTC (4y 7m ago) |
| **Updated** | 2021-06-10 01:52:52.000 UTC |
| **Closed** | 2021-06-10 01:52:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

We have a custom data converter that can get a little slow due to certain cluster conditions and we sometimes trip over this 1s timeout.

**Describe the solution you'd like**

Make DEFAULT_DEADLOCK_DETECTION_TIMEOUT configurable, see https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/sync/DeterministicRunner.java#L37

**Describe alternatives you've considered**

Forking üòÖ 


#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-25 23:53:08.000 UTC</summary>

Yes, I agree we should do it. Let's add a new worker option.

</details>


---

<a id="499"></a>

### #499: Handle all exceptions as non-retryable when TEMPORAL_DEBUG is set

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/499 |
| **State** | OPEN |
| **Author** | mobiletoly (Toly Pochkin) |
| **Created** | 2021-05-18 20:59:38.000 UTC (4y 7m ago) |
| **Updated** | 2021-05-24 17:20:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
By default all exceptions are Retryable in workflows/activities and it makes troubleshooting much harder when we have to deal with a core exceptions such as NullPointerException, InvalidArgumentException, SQL errors etc during a development cycle.

**Describe the solution you'd like**
TEMPORAL_DEBUG env variable is already in use to assist with debugging (e.g. timeouts) and it could be reused to handle all exception as non-retryable by default.

There is some discussion here as well that might provide more context:
https://temporalio.slack.com/archives/CTT84KXK9/p1621341005008500


#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-05-24 17:20:23.000 UTC</summary>

Hey @mobiletoly, `TEMPORAL_DEBUG` is intended to be used to adjust certain timeouts so that when you stop in the debugger you don't affect workflow execution. Your proposal goes slightly against this idea as it would alter workflow behavior by changing how it handles the errors. I don't like this, as it could make certain tests pass/fail with or without the flag.

</details>


---

<a id="490"></a>

### #490: Add LocalActivityOption#contextPropagators

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/490 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-05-14 19:43:15.000 UTC (4y 8m ago) |
| **Updated** | 2021-07-22 18:10:37.000 UTC |
| **Closed** | 2021-05-19 01:43:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Looks like Temporal Java SDK is lacking the support of context propagators for local activities.
Currently, there is no way to make context propagation work for LocalActivities as described in Issue #489.
But even when #489 is resolved, Java SDK API lacks functionality for LocalActivities + ContextPropagators comparable to the one that is available for Activities + ContextPropagators.
`ActivityOption` has `ActivityOption#contextPropagators` that allow specifying custom context propagators for the activity.
You would expect that `LocalActivityOption` will have `LocalActivityOption#contextPropagators` with the same semantic, but it's not there.

**Describe the solution you'd like**
Add `LocalActivityOption#contextPropators` and ensure they are supported the same way as `ActivityOption#contextPropators`

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-05-19 01:43:30.000 UTC</summary>

After discussion with @mfateev we decided that `ActivityOptions#contextPropagators` has extremely limited usage. 
Probably the only reasonable use case would be if we have a regular activity implemented in a different codebase or language. 
Otherwise, ContextPropagators should be specified on `WorkerOptions` and be applied for all activities on both the caller (workflow) and activity worker side anyway, because ActivityOptions are used and applied only on a caller side. Adding a `ContextPropagator` just to the `ActivityOptions` doesn‚Äôt enable it on the Acitivity Worker side. 
So, it's not a good idea to adapt it for local activities, and event the existing `ActivityOptions#contextPropagators` should be used carefully with full understanding that they are applied only to the client/stub side.

</details>


---

<a id="489"></a>

### #489: ContextPropagators don't work for local activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/489 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-05-14 19:21:24.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-14 22:46:40.000 UTC |
| **Closed** | 2021-05-14 22:46:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

ContextPropagators should be respected and work correctly for LocalActvities the same way as for normal Activities.

## Actual Behavior

ContextPropagators don't work for LocalAcitivities.


## Steps to Reproduce the Problem

The test `testDefaultLocalActivityContextPropagation` in this commit fails: https://github.com/Spikhalskiy/java-sdk/commit/045ff66895793c2bb41ed23490722ec8fe661894
While it's identical to testDefaultActivityContextPropagation, the only difference is that the activity is converted to a local activity

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-05-14 22:46:36.000 UTC</summary>

Closed by #491 

</details>


---

<a id="487"></a>

### #487: How to set / update search attribute values during Workflow / Activity runtime ?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/487 |
| **State** | CLOSED |
| **Author** | anandundavia (Anand Undavia) |
| **Created** | 2021-05-10 09:07:34.000 UTC (4y 8m ago) |
| **Updated** | 2021-08-11 01:35:00.000 UTC |
| **Closed** | 2021-08-11 01:34:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | question |
| **Assignees** | None |
| **Milestone** | None |

#### Description

With Custom Search Attributes, I can set the values for the search attributes before starting the workflow using `WorkflowOptions`.

Consider that I have added `LastEmailSentTimestamp` in my cluster.

Before beginning the workflow, I can set the search value with this piece of code.
```java

HashMap<String, Object> workflowSearchAttributes = new HashMap<>();
workflowSearchAttributes.put("LastEmailSentTimestamp", -1);

WorkflowOptions options = WorkflowOptions.newBuilder()
.setSearchAttributes(workflowSearchAttributes) // Map of String -> Object
.build()
```

Is there a way to update the search attribute once the workflow / activity are running ?

For example, Say I have an activity that sends an email. And a workflow to send monthly newsletter.
```java
@Override
public void sendMonthlyNewsLetter() {
      while (true) {
	      newsLetterActivity.sendEmail();
	      long lastSentTimeStamp = Workflow.currentTimeMillis();
	      // --->  How to update the `lastSentTimeStamp` in the search attributes ?!
	      Workflow.sleep(Duration.ofDays(30));
      }
}
```

How do I keep updating the search attributes while the workflow is still running ?!


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-11 01:34:19.000 UTC</summary>

There is `Workflow.upsertSearchAttributes` to add/update search attributes from the workflow code. It's not possible from Activities runtime though, activities don't have an access to `Workflow` methods.

</details>


---

<a id="476"></a>

### #476: GrpcRetryer#retryWithResultAsync doesn't perform retries in some cases

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/476 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-05-09 06:00:15.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-12 01:30:05.000 UTC |
| **Closed** | 2021-05-12 01:30:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
GrpcRetryer#retryWithResultAsync work as expected performing retries until expiration time is reached.

## Actual Behavior
GrpcRetryer#retryWithResultAsync returns after the first retry if an exception is thrown from the supplied function instead of being provided in the returned CompletableFuture.

## Cause
CompletionException is not processed and unwrapped correctly.

## Steps to Reproduce the Problem

This unit test fails with the current implementation, while it's expected to pass:
https://github.com/Spikhalskiy/java-sdk/commit/73f678f79a2338f53da394f3a317897953b92951#diff-889cc42980a7287f0e29c43980e54d3c67c343c483105136bf09cb35269e9051R46

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-05-12 01:30:05.000 UTC</summary>

Closed by #477

</details>


---

<a id="471"></a>

### #471: WorkflowExecutionUtils#getInstanceCloseEvent could get into infinite loop after timeout

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/471 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-05-07 04:39:58.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-07 16:22:58.000 UTC |
| **Closed** | 2021-05-07 16:22:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Actual Behavior

WorkflowExecutionUtils#getInstanceCloseEvent is implemented in a way that could get into an infinite loop after a timeout.

`WorkflowExecutionUtils#getInstanceCloseEvent` has the following simplified implementation:

```
GetWorkflowExecutionHistoryResponse response = null;
long start = System.currentTimeMillis();
do {
      long elapsed = System.currentTimeMillis() - start;
      long expiration = unit.toMillis(timeout) - elapsed;
      if (expiration > 0) {
        response = ...
      }
      if (response == null || !response.hasHistory()) {
          //if we are here and it's a timeout - we will never return from this cycle, we will never get to the following timeout check
          continue;
      }
      if (timeout != 0 && System.currentTimeMillis() - start > unit.toMillis(timeout)) {throw new TimeoutException(...);}
      ...
      }
    } while (true);
```

This simplified structure shows that if we got an empty response and we used up our allocated timeout - we can fall into an infinite `continue` loop which never will enforce the timeout.

I found investigating an incident when after a network blip some temporal stubs stuck into "retries" of WorkflowExecutionUtils#getInstanceCloseEvent performed every 1ms


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-05-07 16:22:58.000 UTC</summary>

Fixed in #472

</details>


---

<a id="420"></a>

### #420: TestWorkflowService doesn't pass headers into workflow retry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/420 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-04-01 06:59:03.000 UTC (4y 9m ago) |
| **Updated** | 2021-04-05 20:14:27.000 UTC |
| **Closed** | 2021-04-05 20:14:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The subsequent workflow runs after a failure of the first run should get the same set of headers as input.

## Actual Behavior
When we use TestWorkflowService, workflow retry runs get an empty set of headers.

## Specifications

  - Master: b682a2d68c5d4caae1585d34bae5d8d8e92253bd


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-04-05 20:14:27.000 UTC</summary>

Addressed in #419

</details>


---

<a id="417"></a>

### #417: TestWorkflowRule get workerInterceptors from two different sources and merges them incorrectly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/417 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-04-01 05:22:44.000 UTC (4y 9m ago) |
| **Updated** | 2021-07-16 01:04:37.000 UTC |
| **Closed** | 2021-04-02 22:48:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior
```
@Rule
public TestWorkflowRule workflowRule =
       TestWorkflowRule.newBuilder()
            .setWorkerFactoryOptions(WorkerFactoryOptions.newBuilder().setWorkerInterceptors(workerInterceptor).build())
            //...
            .build();
```
You would expect that `workerInterceptor` will be respected and used. 

## Actual Behavior
TestWorkflowRule inside will create WorkerFactoryOptions without interceptors:
```
    workerFactoryOptions =
        (builder.workerFactoryOptions == null)
            ? WorkerFactoryOptions.newBuilder().setWorkerInterceptors(interceptors).build()
            : builder.workerFactoryOptions.toBuilder().setWorkerInterceptors(interceptors).build(); // here workerInterceptor will be thrown away
```
The reason is an incorrect refactoring when TestWorkflowRule first got `setWorkerInterceptors()` method and after that `setWorkerFactoryOptions` with forced rewriting of `WorkerFactoryOptions#workerInterceptors` with collection provided (or nor provided) in the separate `setWorkerInterceptors()`.

`TestWorkflowRule` also has a mess inside with naming. `Builder#workerInterceptors` is copied into `#interceptors`, etc. Name "interceptors" shouldn't be used at all for a class field, because there are at least client and worker interceptors (which inside consist of more subtypes). So, we should use more specific names that encode which kind of interceptors we are working with here. `workerInterceptors` is a much better idea.

## Proposed solution

Remove this separate new `setWorkflowInterceptors` method from `TestWorkflowRule` and Builder completely and supply workerInterceptors inside `WorkerFactoryOptions`. It's much cleaner, consistent with actual internals and options structure, and with the way how client interceptors now are supplied inside `WorkflowClientOptions`.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-04-01 05:23:39.000 UTC</summary>

@vkoby this bug is introduced by the recent refactorings.

</details>


---

<a id="414"></a>

### #414: Workflow retry after Activity failure works incorrectly with TestService

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/414 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-03-31 20:20:51.000 UTC (4y 9m ago) |
| **Updated** | 2021-07-16 01:04:30.000 UTC |
| **Closed** | 2021-05-28 20:49:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior

We have a simple workflow that triggers an activity that fails on its first invocation and succeeds on subsequent calls.
We setup Activity#retryOptions into maxAttempt = 1 and Workflow#retryOptions into maxAttempt = 2.
We expect the workflow to pass after the second run.

## Actual Behavior

Workflow fails in unit tests, there is no second run of the workflow.

## Steps to Reproduce the Problem
The following unit test is failing, while expected to pass:
https://github.com/Spikhalskiy/java-sdk/commit/3ff42f47a9a0c4da359cec07d6cccccf808e6836#diff-1cfa937ab805ee84ebdaf1e67c2f920b3ad72d53cf29e560061aeee0f3d7e012R91
 
If uncomment `//.setUseExternalService(true)` the test passes which points that the issue is probably in TestService implementation.

## Specifications

Current master: 8384e5393eb84be3044fced0b3db3daa8749c75f


#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2021-04-01 04:38:02.000 UTC</summary>

Thanks for reporting the issue, we'll take a look and will get back to you.

</details>


---

<a id="400"></a>

### #400: Workflow as a cron job executing more number of times than expected

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/400 |
| **State** | CLOSED |
| **Author** | arjunacharya10 (Arjun Acharya) |
| **Created** | 2021-03-25 05:54:53.000 UTC (4y 9m ago) |
| **Updated** | 2021-10-14 00:24:22.000 UTC |
| **Closed** | 2021-10-14 00:24:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | question |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

`WorkflowOptions options = WorkflowOptions.newBuilder()
                .setTaskQueue(TASK_QUEUE)
                .setCronSchedule("0 5 */30 * *")
                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(5).build())
                .build();`
In a test case Java sdk, when we start a cron workflow like this; i.e a workflow that executes once every 30 days. Subsequently when we use 
`testEnv.sleep(Duration.ofDays(90))`
## Expected Behavior
The workflow is triggerd 3 times.
## Actual Behavior
Workflow is triggered 6 times

## Steps to Reproduce the Problem

  1. In a test case, start a workflow as a cron that runs once every 30 days
  2. Assert how many times it is run after 90 days (by doing `testEnv.sleep(Durtion.ofDays(90))`)
  3. The number of times it is executed should be 3 but observed as 6

## Specifications

  - Version: temporal-sdk:1.0.6, temporal-testing:1.0.6, temporal-testing-junit4:1.0.6
  - Platform:


#### Comments (1)

<details>
<summary><strong>vkoby</strong> commented on 2021-10-08 20:56:25.000 UTC</summary>

@arjunacharya10, you're getting 6 runs because when you start a cron workflow, it executes immediately (1st run) and then every  1st and 31st of the month per [this](https://pkg.go.dev/github.com/robfig/cron#hdr-CRON_Expression_Format) doc. 
The fact that your workflow executes immediately in this case is a bug, but with real server should work correctly.

</details>


---

<a id="387"></a>

### #387: API docs erroneously claim WorkflowIdReusePolicy default is AllowDuplicateFailedOnly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/387 |
| **State** | CLOSED |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2021-03-15 19:49:21.000 UTC (4y 10m ago) |
| **Updated** | 2022-07-22 00:03:36.000 UTC |
| **Closed** | 2022-07-22 00:03:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | documentation |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |

#### Description

## Expected Behavior

According to maxim, the default is `AllowDuplicate`

## Actual Behavior

Docs say default is `AllowDuplicateFailedOnly`

## Steps to Reproduce the Problem

check the docs:
https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/WorkflowOptions.java#L134

## Specifications

  - Version: v1.0.6


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-22 00:03:35.000 UTC</summary>

Closed by #1307

</details>


---

<a id="373"></a>

### #373: Interceptors: Add missing header to activity and client interceptors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/373 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-03-01 22:17:06.000 UTC (4y 10m ago) |
| **Updated** | 2021-07-02 18:24:23.000 UTC |
| **Closed** | 2021-07-02 18:24:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
It should be possible to inject context into the header when starting workflow and executing an activity.

## Actual Behavior
There is no way to set header from client interceptor and activity interceptor.



#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-03-31 06:24:11.000 UTC</summary>

@mfateev this is fully implemented and probably can be closed now.

</details>


---

<a id="361"></a>

### #361: Default WorkflowIdReusePolicy is AllowDuplicate and not AllowDuplicateFailedOnly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/361 |
| **State** | CLOSED |
| **Author** | kartikv11 (Kartik Verma) |
| **Created** | 2021-02-23 18:52:50.000 UTC (4y 10m ago) |
| **Updated** | 2023-05-23 06:38:25.000 UTC |
| **Closed** | 2023-05-23 06:38:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Default WorkflowIdReusePolicy should be AllowDuplicateFailedOnly as per [documentation](https://docs.temporal.io/docs/workflows/?_ga=2.1788337.1425639198.1614084660-706488885.1612797794#id-uniqueness)

## Actual Behavior
Default WorkflowIdReusePolicy is AllowDuplicate instead

## Steps to Reproduce the Problem

  1.Create a Workflow and let it complete
  1.Create another workflow with same id as Workflow from Step 1
  1.Both workflows get processed

## Specifications

  - Version: 1.0.5
  - Platform: java


#### Comments (1)

<details>
<summary><strong>Quinn-With-Two-Ns</strong> commented on 2023-05-23 06:38:20.000 UTC</summary>

current dev guide and java docs says `AllowDuplicate` is the default

https://docs.temporal.io/workflows?_ga=2.1788337.1425639198.1614084660-706488885.1612797794#workflow-id-reuse-policy

</details>


---

<a id="342"></a>

### #342: maven packages for java client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/342 |
| **State** | CLOSED |
| **Author** | MaksimRT |
| **Created** | 2020-04-14 15:34:58.000 UTC (5y 9m ago) |
| **Updated** | 2021-06-02 18:26:04.000 UTC |
| **Closed** | 2021-06-02 18:26:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Please add similar maven package https://mvnrepository.com/artifact/com.uber.cadence/cadence-client

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-04-14 19:36:14.000 UTC</summary>

Absolutely! We are waiting for completing all the backward incompatible changes before making an official release.

For now use the 0.20.0-SNAPSHOT  release from the "https://oss.sonatype.org/content/repositories/snapshots/" repository. Here is the snippet of the build.gradle from [temporal-java-samples](https://github.com/temporalio/temporal-java-samples/):

```
repositories {
    maven {
        url "https://plugins.gradle.org/m2/"
    }
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots/"
    }
    mavenCentral()
}

dependencies {
    compile group: 'io.temporal', name: 'temporal-sdk', version: '0.20.0-SNAPSHOT'

    ...
}
```


Reactions: üëç 1

</details>


---

<a id="341"></a>

### #341: Support robfig style cron defs in TestWorkflowEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/341 |
| **State** | OPEN |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2020-08-31 19:01:29.000 UTC (5y 4m ago) |
| **Updated** | 2024-11-20 21:04:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

I have a cron workflow that uses the cron expression "@every 30s". This works fine when run against a temporal server, however, it fails when using the workflow unit test scaffolding.

## Actual Behavior

```
com.xxx.runner.WorkflowTestRunnerStarterTest > run FAILED
    io.grpc.StatusRuntimeException: INVALID_ARGUMENT: Invalid cron expression "@every 30s": Cron expression contains 2 parts but we expect one of [5]
        at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:244)
        at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:225)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:142)
        at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.startWorkflowExecution(WorkflowServiceGrpc.java:2613)
        at io.temporal.internal.external.GenericWorkflowClientExternalImpl.lambda$start$0(GenericWorkflowClientExternalImpl.java:86)
        at io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:127)
        at io.temporal.internal.external.GenericWorkflowClientExternalImpl.start(GenericWorkflowClientExternalImpl.java:80)
        at io.temporal.internal.sync.WorkflowStubImpl.startWithOptions(WorkflowStubImpl.java:155)
        at io.temporal.internal.sync.WorkflowStubImpl.start(WorkflowStubImpl.java:267)
        at io.temporal.internal.sync.TestWorkflowEnvironmentInternal$TimeLockingInterceptor$TimeLockingWorkflowStub.start(TestWorkflowEnvironmentInternal.java:230)
        at io.temporal.internal.sync.WorkflowInvocationHandler$StartWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:242)
        at io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)
        at com.sun.proxy.$Proxy29.run(Unknown Source)
        at io.temporal.internal.sync.WorkflowClientInternal.start(WorkflowClientInternal.java:220)
        at io.temporal.client.WorkflowClient.start(WorkflowClient.java:238)
        at com.xxx.runner.WorkflowTestRunnerStarter.start(WorkflowTestRunnerStarter.java:52)
        at com.xxx.runner.WorkflowTestRunnerStarterTest.run(WorkflowTestRunnerStarterTest.java:50)```

## Specifications

  - Version: temporal java client 0.27.0


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-26 16:31:53.000 UTC</summary>

https://github.com/jmrozanec/cron-utils/issues/505
https://github.com/jmrozanec/cron-utils/issues/506

</details>


---

<a id="335"></a>

### #335: Support workflow metadata query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/335 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-02-06 20:49:10.000 UTC (4y 11m ago) |
| **Updated** | 2024-11-19 15:33:26.000 UTC |
| **Closed** | 2024-11-19 15:33:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, it is not possible to get a list of queries and signals a workflow is listening on. So UI has to emit an unsupported query and parse the list of supported ones from the message. 

**Describe the solution you'd like**
Add a query that would return metadata about workflow. Lists of supported queries and signals should be included into the result.

**Describe alternatives you've considered**
Use worker query (not implemented yet) instead. But as the set of queries and signals that workflow accepts is dynamic a normal query would make more sense.

**Additional context**
[An error is logged by the service ](https://community.temporal.io/t/io-temporal-internal-sync-syncworkflowcontext-query-uncategorized-exception-often-seen-in-server-log/1454)every time UI needs to find out the list of supported queries.

The query should be supported by all SDKs.

#### Comments (1)

<details>
<summary><strong>cretz</strong> commented on 2024-02-02 21:29:34.000 UTC</summary>

See https://github.com/temporalio/features/issues/51

</details>


---

<a id="330"></a>

### #330: Customizable RpcRetryOptions in ServiceStubsOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/330 |
| **State** | CLOSED |
| **Author** | CalPeterWu (Peter Wu) |
| **Created** | 2021-02-02 06:55:34.000 UTC (4y 11m ago) |
| **Updated** | 2021-06-02 18:27:18.000 UTC |
| **Closed** | 2021-06-02 18:27:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We would like to control how many times grpc retries. Currently, it will retry for a total of 1 mins when deadline exceeded, and it is too long for us. We would like to have more options for the configuration than rpcTimeout/rpcLongPollTimeout/rpcQueryTimeout.

**Describe the solution you'd like**
We could add those parameters into ServiceStubsOptions and propagate them similarly as the deadline.

**Describe alternatives you've considered**
Any other feasible solutions

**Additional context**
N/A


#### Comments (1)

<details>
<summary><strong>CalPeterWu</strong> commented on 2021-02-02 06:56:29.000 UTC</summary>

@vitarb 

</details>


---

<a id="328"></a>

### #328: JSON de-serializer fails on field additions and removals

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/328 |
| **State** | CLOSED |
| **Author** | ranand-git |
| **Created** | 2021-02-01 18:47:12.000 UTC (4y 11m ago) |
| **Updated** | 2021-09-28 15:47:16.000 UTC |
| **Closed** | 2021-09-28 15:45:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | invalid |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
The Data class input parameter to a Workflow method could be changed in the following ways as part of a new deployment/rollout:
- remove an existing field in the input parameter class definition and/or
- add a new field and/or
- modify the type (and/or name) of a field. 

Note that it could be a combination of the above as well.

Temporal needs to ensure that the old workers running the old version of the code don't break. Ideally, nothing should break.

## Actual Behavior
The observed behavior is that when say a new field is added, the old worker code fails during de-serialization because of the additional fields added.

Are we **expected** to annotate our data classes with: "@JsonIgnoreProperties(ignoreUnknown = true)" before we rollout a breaking change?

I haven't tried to repro what happens when a field is removed or when the data type and/or name of a field is changed. Perhaps we need to use custom de-serializators for the latter.

All of this should be well documented. Currently, all that is documented is Temporal versioning which kicks in only after de-serialization has happened. While Temporal versioning is good for branching code when the behavior is drastically different, there is a gap on how to handle data class changes.

Note that this issue exists even for activities (when the input/output classes they use change). However, it is a blocker for data class changes for workflow methods. The fundamental question is it **even possible** to iterate on data classes used in Workflow methods or is that a sailed ship?

## Steps to Reproduce the Problem

  1. Change the data class input to a Workflow or activity by adding, removing and changing some fields and deploy this change to a running system. Ideally, test addition, removal and change separately to correctly observe the behavior.
  2. Rollout this change.
  3. The old workers running the old code will barf when they try to de-serialize the data input serialized by the new code.

## Specifications

  - Version: 1.0.3
  - Platform: Java SDK


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-28 15:45:40.000 UTC</summary>

Temporal doesn't handle the serialization of inputs/outputs in its code.
By default Temporal uses Jackson in it's data converters and this behavior is defined by Jackson mapper configuration.
You can set your own data converter with your own settings, for example ignoring newly added fields.
We use pretty much an [original mapper](https://github.com/temporalio/sdk-java/blob/30420212a26283cf7cbe6339512058a3186074e8/temporal-sdk/src/main/java/io/temporal/common/converter/JacksonJsonPayloadConverter.java#L40) to give users the default behavior they get used to.

I don't think that Temporal documentation should have the details of how to make changes in data classes that are compatible with **Jackson** or any other serialization framework that may be used.


We will consider adding information about default out-of-the-box serializers we supply in data converters.
We will make sure to express an idea "You should be aware of the serializer that you use and its configuration and make changes to data classes that are compatible with your combination of serializer and options if you want to maintain compatibility".

Closing the issue for being not a bug and more of misconfiguration.
The steps should be to improve Temporal documentation in this area.

</details>


---

<a id="310"></a>

### #310: Do not fail stack trace query on a closed workflow. But return empty stack

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/310 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-01-15 22:40:13.000 UTC (4y 11m ago) |
| **Updated** | 2021-05-07 22:45:21.000 UTC |
| **Closed** | 2021-05-07 22:45:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior
A human readable string that indicates that workflow is closed.

## Actual Behavior
```
3 INVALID_ARGUMENT: java.lang.Error: closed at
io.temporal.internal.sync.DeterministicRunnerImpl.checkClosed(DeterministicRunnerImpl.java:433) at 
io.temporal.internal.sync.DeterministicRunnerImpl.stackTrace(DeterministicRunnerImpl.java:418) at 
io.temporal.internal.sync.SyncWorkflow.query(SyncWorkflow.java:171) at 
io.temporal.internal.replay.ReplayWorkflowExecutor.query(ReplayWorkflowExecutor.java:137) at 
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleQueryWorkflowTask(ReplayWorkflowRunTaskHandler.java:256) at 
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleQueryOnlyWorkflowTask(ReplayWorkflowTaskHandler.java:257) at 
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:112) at 
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:314) at 
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:280) at 
io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73) at 
java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at 
java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at 
java.base/java.lang.Thread.run(Thread.java:834)
```


#### Comments (1)

<details>
<summary><strong>Mhany95</strong> commented on 2021-02-18 08:56:29.000 UTC</summary>

Any updates on this one? I can see the stack trace as long as the workflow is "Running", but once it's completed, failed or terminated, I get that error that @mfateev is mentioning?

</details>


---

<a id="305"></a>

### #305: Run Saga compensations in a disconnected scope

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/305 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-01-12 21:10:42.000 UTC (4y 12m ago) |
| **Updated** | 2021-03-14 08:24:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently `Saga.compensate` is called in the current cancellation scope. It means that in the case of cancellation the compensations are not going to run. So it requires that `compensate` is called in the detached cancellation scope. But our [sample does not do it](https://github.com/temporalio/samples-java/blob/61bf7a9071fe443eb6f1722ccdb7a78fdd6ccd9b/src/main/java/io/temporal/samples/bookingsaga/TripBookingWorkflowImpl.java#L55).

**Describe the solution you'd like**
By default execute compensation actions in a disconnected cancellation scope. Add Saga.Option to disable this behavior. 
Change [bookingsaga](https://github.com/temporalio/samples-java/tree/master/src/main/java/io/temporal/samples/bookingsaga) sample to catch TemporalFailure to support cancellation scenarios.



#### Comments (1)

<details>
<summary><strong>ShubhSingh</strong> commented on 2021-03-14 08:01:43.000 UTC</summary>

hi @mfateev, is this issue still open?
I tried running booking saga and when exception occurs during bookFlight compensations run as shown below.

cancelling car reservation '953c8762-fc18-4e8a-8a2b-8fe468d0381e' for 'trip2'
cancelling hotel reservation '0c7428dd-5357-480c-845d-1c558d3e20d4' for 'trip2'

I didn't understand current and disconnected cancellation scope, 
does it mean that instead of exception if user deliberately cancels the flight after successful booking then compensations need to run? 
I might be wrong here so please excuse me.

I checked Saga.Options to disable behavior but there's only 2 configs available as of now: parallelCompensation and continueWithError

</details>


---

<a id="302"></a>

### #302: Print stacktrace coming from another language in the exception message

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/302 |
| **State** | OPEN |
| **Author** | wolfy-j (Anton Tsitou) |
| **Created** | 2021-01-11 18:50:37.000 UTC (4y 12m ago) |
| **Updated** | 2022-07-06 14:38:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

StackTrace is empty when failure comes from another SDK
Expected to see trace supplied in stackTrace proto message.

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-07-06 14:37:29.000 UTC</summary>

Temporal can't deserialize a stacktrace from another language into a language-specific stack trace.
I will think about how we could make an original stacktrace readable and accessible in this scenario.

</details>


---

<a id="300"></a>

### #300: WorkflowExecutionHistory.fromJson does not support JSONs exported via Web console or CLI 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/300 |
| **State** | CLOSED |
| **Author** | GreyTeardrop (Mykola Rybak) |
| **Created** | 2021-01-11 14:30:43.000 UTC (4y 12m ago) |
| **Updated** | 2021-09-16 20:47:32.000 UTC |
| **Closed** | 2021-09-16 18:00:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

## Overview & Expected Behavior

This issue was discovered when I tried to re-create the workflow replay test from the [samples-go](https://github.com/temporalio/samples-go/blob/29f9a20ae56155fe1f273c29a0488c5be1c898b1/helloworld/replay_test.go) project with Java SDK via `WorkflowReplayer`. Here's the test code:

```java
import io.temporal.testing.WorkflowReplayer;
import org.junit.jupiter.api.Test;

public class SubmissionWorkflowReplayTest {

    @Test
    public void replayTest() throws Exception {
        WorkflowReplayer.replayWorkflowExecutionFromResource(
            "submission_workflow.json",
            SubmissionWorkflowImpl.class
        );
    }
}
```

As there doesn't seem to be a documented way to get JSON workflow history for replay tests (or I've missed it), I tried 2 approaches

1. Via the web console's "export JSON history".
2. Via CLI with `tctl workflow show -w <workflow-id> -r <rid> --of <file> `.

I would have expected both options to provide the same JSON model that could later be used to replay workflow via `WorkflowReplayer`.

**Update**: I've found that [WorkflowTest](https://github.com/temporalio/sdk-java/blob/24a55be08d8cfaf0b8bb2bb49aab38e8344ce08c/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowTest.java#L1041-L1063) has the code to fetch workflow history in the exact format the SDK expects. Nevertheless, it would have been great, if Java and Go SDKs supported the same JSON history formats - that might become useful if workflow logic is to be migrated from Go to Java or vice versa.

## Actual Behavior

Both web console history export and CLI history export provide JSONs of different schemes, although the contents seem to be mostly the same. Tctl JSON format seems to match the one used on [go samples](https://github.com/temporalio/samples-go/blob/29f9a20ae56155fe1f273c29a0488c5be1c898b1/helloworld/helloworld.json) and is readable by Go SDK.

Both formats do not work with Java SDK's `WorkflowReplayer` and fail when it tries to run `WorkflowExecutionHistory.fromJson()` due to various JSON deserialization issues. 

Seems like `WorkflowExecutionHistory.fromJson()` is unable to read date/time fields from the "web console JSON" and enums from the "tctl JSON".

I was able to make `WorkflowExecutionHistory.fromJson()` work and to proceed further with the `WorkflowReplayer` test by taking "tctl JSON" and manually replacing all enum values in it with matching enum values from the "web console JSON".

To illustrate the difference here's the diff of 2 JSON representations of the `WorkflowExecutionStarted` event
```diff
--- submission_workflow_console__started.json	2021-01-11 16:21:06.000000000 +0200
+++ submission_workflow_tctl__started.json	2021-01-11 16:15:32.000000000 +0200
@@ -1,22 +1,15 @@
 {
   "eventId": "1",
-  "eventTime": {
-    "seconds": "1610308631",
-    "nanos": 207997800
-  },
-  "eventType": "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
-  "version": "0",
+  "eventTime": "2021-01-10T19:57:11.207997800Z",
+  "eventType": "WorkflowExecutionStarted",
   "taskId": "2097152",
-  "attributes": "workflowExecutionStartedEventAttributes",
   "workflowExecutionStartedEventAttributes": {
     "workflowType": {
       "name": "SubmissionWorkflow"
     },
-    "parentWorkflowNamespace": "",
-    "parentInitiatedEventId": "0",
     "taskQueue": {
       "name": "Submission",
-      "kind": "TASK_QUEUE_KIND_NORMAL"
+      "kind": "Normal"
     },
     "input": {
       "payloads": [
@@ -28,28 +21,13 @@
         }
       ]
     },
-    "workflowExecutionTimeout": {
-      "seconds": "0",
-      "nanos": 0
-    },
-    "workflowRunTimeout": {
-      "seconds": "0",
-      "nanos": 0
-    },
-    "workflowTaskTimeout": {
-      "seconds": "10",
-      "nanos": 0
-    },
-    "continuedExecutionRunId": "",
-    "initiator": "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
+    "workflowExecutionTimeout": "0s",
+    "workflowRunTimeout": "0s",
+    "workflowTaskTimeout": "10s",
     "originalExecutionRunId": "3341c57e-42c9-491d-a0b9-843af9887c6c",
     "identity": "27852@CRD-MBP-0260",
     "firstExecutionRunId": "3341c57e-42c9-491d-a0b9-843af9887c6c",
     "attempt": 1,
-    "cronSchedule": "",
-    "firstWorkflowTaskBackoff": {
-      "seconds": "0",
-      "nanos": 0
-    }
+    "firstWorkflowTaskBackoff": "0s"
   }
 }
```

## Steps to Reproduce the Problem

1. Export workflow history from the Temporal server.
2. Feed it to Java SDK's `WorkflowReplayer`.
3. See JSON deserialization issues.

## Specifications

  - Version: Temporal server 1.5.1, Temporal Java SDK 1.0.4
  - Platform: macOS


#### Comments (1)

<details>
<summary><strong>GreyTeardrop</strong> commented on 2021-02-16 18:39:02.000 UTC</summary>

Related issue: https://github.com/temporalio/web/issues/268

</details>


---

<a id="290"></a>

### #290: Flaky whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows test

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/290 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-12-26 19:54:16.000 UTC (5 years ago) |
| **Updated** | 2022-01-13 22:55:08.000 UTC |
| **Closed** | 2022-01-13 22:55:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The [failed build](https://buildkite.com/temporal/java-sdk/builds/706#8f286074-cb8e-488c-a0c8-6d952fc9800f).

The test output:
```
io.temporal.worker.StickyWorkerTest > whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows[Docker] STANDARD_OUT
¬† | 19:28:41.314 [Test worker] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Host Local Workflow Poller'}, identity=014c4836-e433-491c-9982-b26ab8b220c4}
¬† | ¬†
¬† | io.temporal.workflow.WorkflowTest > testUntypedChildStubWorkflowAsyncInvoke STANDARD_OUT
¬† | 19:28:41.342 [Time-limited test] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Host Local Workflow Poller'}, identity=0b8cce66-e6f6-45a6-9e5d-7581a6b8e38b}
¬† | ¬†
¬† | io.temporal.worker.StickyWorkerTest > whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows[Docker] STANDARD_OUT
¬† | 19:28:41.518 [Test worker] INFO  i.t.s.WorkflowServiceStubsImpl - shutdownNow
¬† | ¬†
¬† | io.temporal.worker.StickyWorkerTest > whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows[Docker] FAILED
¬† | java.lang.AssertionError: 1 expected:<2> but was:<1>
¬† | at org.junit.Assert.fail(Assert.java:89)
¬† | at org.junit.Assert.failNotEquals(Assert.java:835)
¬† | at org.junit.Assert.assertEquals(Assert.java:647)
¬† | at io.temporal.common.reporter.TestStatsReporter.assertCounter(TestStatsReporter.java:72)
¬† | at io.temporal.worker.StickyWorkerTest.whenStickyIsEnabledThenTheWorkflowIsCachedChildWorkflows(StickyWorkerTest.java:303)
```

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-01-13 22:55:08.000 UTC</summary>

Not anymore

</details>


---

<a id="257"></a>

### #257: Expose previous run failure though workflow context API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/257 |
| **State** | CLOSED |
| **Author** | samarabbas (Samar Abbas) |
| **Created** | 2020-11-17 02:42:58.000 UTC (5y 1m ago) |
| **Updated** | 2021-09-01 21:00:08.000 UTC |
| **Closed** | 2021-09-01 21:00:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Current we expose getLastCompletionResult api used for communicating the result of 
previous workflow run to next run.  But we don't have similar api which exposes last
failure.  

**Describe the solution you'd like**
Expose lastFailure api which exposes failure of previous run but we still did a 
continueAsNew because of cron or retry policy.  LastCompletionResult is still carried over
from earlier run even when previous run fails due to an error.

**Additional context**
https://community.temporal.io/t/bug-on-getlastcompletionresult-returns-null-if-previous-run-timeout-or-fail/997


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-01 21:00:08.000 UTC</summary>

Closed by #260

</details>


---

<a id="248"></a>

### #248: PollActivityTaskQueue should return empty poll after a minute

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/248 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-11-08 18:46:52.000 UTC (5y 2m ago) |
| **Updated** | 2021-09-23 17:36:49.000 UTC |
| **Closed** | 2021-09-23 17:36:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Service returns an empty poll after a minute if no tasks are available. The test service[ never returns an empty poll](https://github.com/temporalio/sdk-java/blob/30420212a26283cf7cbe6339512058a3186074e8/temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowStoreImpl.java#L365), blocking until a task is available. It causes gRPC level request timeouts which while benign look scary.

**Describe the solution you'd like**
Return an empty poll after a minute.



#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-23 17:36:41.000 UTC</summary>

Closed by #713

</details>


---

<a id="204"></a>

### #204: Block of copied code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/204 |
| **State** | CLOSED |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2020-09-10 23:55:13.000 UTC (5y 4m ago) |
| **Updated** | 2021-08-10 20:29:51.000 UTC |
| **Closed** | 2021-08-10 20:29:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Looks like there was a block of code copied twice here:

https://github.com/temporalio/java-sdk/blob/27ba155bf0684f05d2b26a7777651db83ad4641c/src/main/java/io/temporal/internal/worker/ActivityPollTask.java#L78

Does not look like it is a problem though.


#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-08-10 20:29:51.000 UTC</summary>

Closed by #478

</details>


---

<a id="201"></a>

### #201: STICKY_CACHE_THREAD_FORCED_EVICTION double reporting

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/201 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2020-08-26 23:25:04.000 UTC (5y 4m ago) |
| **Updated** | 2021-10-05 19:58:59.000 UTC |
| **Closed** | 2021-10-05 19:58:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior

`WorkflowThreadImpl#start` in case of full thread pool triggers `getWorkflowContext().getMetricsScope().counter(MetricsType.STICKY_CACHE_THREAD_FORCED_EVICTION).inc(1)` directly, after that it calls `cache.evictAnyNotInProcessing` which triggers the metrics increment one more time inside:
`metricsScope.counter(MetricsType.STICKY_CACHE_THREAD_FORCED_EVICTION).inc(1)`

As the result one eviction will be reported twice. 

## Proposed solution

Remove unconditional increment from `WorkflowThreadImpl#start` and leave more correct and checked increment inside `cache.evictAnyNotInProcessing`

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2020-08-26 23:32:10.000 UTC</summary>

I also have some questions about `WorkflowThreadImpl` logic, because it looks strange.

```
while (true) {
      try {
        taskFuture = threadPool.submit(task);
        return;
      } catch (RejectedExecutionException e) {
        ...
        if (cache != null) {
          boolean evicted =
              cache.evictAnyNotInProcessing(
                  context.getWorkflowExecution(), workflowContext.getMetricsScope());
          if (!evicted) {
            throw new WorkflowRejectedExecutionError(e);
          }
        } else {
          throw new WorkflowRejectedExecutionError(e);
        }
      }
    }
```

Why in case we successfully evicted from the cache we do try to resubmit the task into the pool, while if we failed to evict - we don't try to resubmit the task? Successful eviction from the cache doesn't influence an amount of available threads in the thread pool anyhow or an available space in the thread pool queue, so this logic looks off.
Also, looks like if the thread pool is full - we will continue to eviction from the cache one by one till we clean everything "not in progress" from it. Why not to make it in one visit and one iteration through the cache, what's the benefit to do it one by one?

</details>


---

<a id="192"></a>

### #192: Netty NioEventLoop exception

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/192 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-08-22 02:28:55.000 UTC (5y 4m ago) |
| **Updated** | 2021-09-23 17:40:28.000 UTC |
| **Closed** | 2021-09-23 17:40:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | mfateev |
| **Milestone** | None |

#### Description

## Expected Behavior
gRPC works.

## Actual Behavior
Intermittently unit tests get blocked producing a bunch of exceptions into the log:
```
19:26:22.214 [grpc-nio-worker-ELG-1-14] WARN  i.g.n.s.i.n.channel.nio.NioEventLoop - Unexpected exception in the selector loop.
java.io.IOException: Invalid argument
	at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
	at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
	at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:117)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
	at io.grpc.netty.shaded.io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:807)
	at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:457)
	at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
19:26:23.217 [grpc-nio-worker-ELG-1-14] INFO  i.g.n.s.i.n.channel.nio.NioEventLoop - Migrated 0 channel(s) to the new Selector.
```

## Steps to Reproduce the Problem
Specific steps are unknown. The problem happens intermittently with different tests.

## Specifications

  - Version: 0.28.0 of service and Java SDK



#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2021-09-23 17:40:28.000 UTC</summary>

This problem wasn't noticed recently in any configuration of our unit test runs

</details>


---

<a id="185"></a>

### #185: Incorrect Temporal Error handling in POJOActivityInboundCallsInterceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/185 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2020-08-18 03:57:29.000 UTC (5y 4m ago) |
| **Updated** | 2020-08-21 22:44:28.000 UTC |
| **Closed** | 2020-08-21 22:44:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Test

```
@WorkflowInterface
public interface TestWorkflow {
    @WorkflowMethod
    String workflow(String input);
}

public static class ActivityWorkflow implements TestWorkflow {
    private final TestActivity1 activity1 =
        Workflow.newLocalActivityStub(
            TestActivity1.class,
            LocalActivityOptions.newBuilder()
                ...
                .build());

    @Override
    public String workflow(String input) {return activity1.activity1(input);}
}

@ActivityInterface
public interface TestActivity1 {
    String activity1(String input);
}

private static class Activity1Impl implements TestActivity1 {
    @Override
    public String activity1(String input) {return Workflow.randomUUID().toString();}
}

@Test
public void trivialTest() {
    Worker worker = testEnvironment.newWorker(TASK_QUEUE);
    worker.registerWorkflowImplementationTypes(ActivityWorkflow.class);
    worker.registerActivitiesImplementations(new Activity1Impl());

    testEnvironment.start();
    WorkflowClient client = testEnvironment.getWorkflowClient();
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            ...
            .build();

    TestWorkflow workflow = client.newWorkflowStub(TestWorkflow.class, options);
    workflow.workflow(UUID.randomUUID().toString());
  }
```

## Expected Behavior

Meaningful original exception from calling Workflow method from Activity (java.lang.Error: Called from non workflow or workflow callback thread)

## Actual Behavior

The root cause is completely lost and overridden by incorrect handling inside `POJOActivityInboundCallsInterceptor#execute`. The actual exception:
```
Caused by: io.temporal.failure.ApplicationFailure: message='java.lang.Error cannot be cast to java.lang.Exception', type='java.lang.ClassCastException', nonRetryable=false
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:263)
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOLocalActivityImplementation.execute(POJOActivityTaskHandler.java:298)
	at io.temporal.internal.sync.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:185)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:248)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:289)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:289)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:202)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:191)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 3 common frames omitted
```

## Steps to Reproduce the Problem

Find the full test here:
https://github.com/Spikhalskiy/java-sdk/commit/d43873e985b68521e3da2ebdb2e54f3dcda9b222

## Specifications

  - Version: 0.28.0 and current master (https://github.com/temporalio/java-sdk/tree/35abfd425c13e86f16b81e26c85c07b17ee3448f)

## Proposed improvement

Temporal code and error handling can greatly benefit from creation of an Error subclass for Temporal Exceptions that need to be propagated thru exception handling. It will also make it possible to handle the temporal errors in such exception handling blocks. Right now all Errors have to be intercepted in the `POJOActivityInboundCallsInterceptor#execute` to fix this issue and this is not a right way.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-21 22:44:28.000 UTC</summary>

Thanks a lot for the report and the repro. Resolving as it is fixed in #190 

</details>


---

<a id="176"></a>

### #176: Support development with recent JDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/176 |
| **State** | CLOSED |
| **Author** | shyamalprasad (Shyamal Prasad) |
| **Created** | 2020-08-14 21:35:20.000 UTC (5y 4m ago) |
| **Updated** | 2020-08-14 23:30:47.000 UTC |
| **Closed** | 2020-08-14 23:30:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It's a very minor one-time annoyance, but it would be great if any recent JDK (JDK11 and JDK14 in my case) would "just work" to build the SDK after I check it out.

The changes to support JDK 9 are minor (annotations module, a deprecated constructor call), and JDK 14 requires one change for `yield` having become a Java keyword in some contexts. I will open a PR shortly to illustrate.

I can totally understand if this is not a priority right now.

#### Comments (1)

<details>
<summary><strong>shyamalprasad</strong> commented on 2020-08-14 23:30:47.000 UTC</summary>

Thanks!

</details>


---

<a id="153"></a>

### #153: java.time.OffsetDateTime deserialization failing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/153 |
| **State** | CLOSED |
| **Author** | myfancypants (Shanan Sussman) |
| **Created** | 2020-07-23 19:48:53.000 UTC (5y 5m ago) |
| **Updated** | 2020-08-22 02:17:33.000 UTC |
| **Closed** | 2020-08-22 02:17:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
JacksonJsonPayloadConverter should be able to handle OffsetDateTime deserialization

Version `0.26.0` did not encounter any issues with it previously

## Actual Behavior
Workflow execution failure

```
maestro    | WARNING: An illegal reflective access operation has occurred
maestro    | WARNING: Illegal reflective access by com.fasterxml.jackson.databind.util.ClassUtil (file:/service/bin/maestro.jar) to constructor java.time.OffsetDateTime(java.time.LocalDateTime,java.time.ZoneOffset)
maestro    | WARNING: Please consider reporting this to the maintainers of com.fasterxml.jackson.databind.util.ClassUtil
maestro    | WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
maestro    | WARNING: All illegal access operations will be denied in a future release
maestro    | 2020-07-23T18:38:26.762Z ERROR [i.t.i.sync.POJOWorkflowImplementationFactory] [workflow-method] Workflow execution failure WorkflowId=e4821190-81f8-4eab-8191-406193cbe6ef, RunId=fcf2d818-30a5-4f01-b68c-3e367242ae07, WorkflowType=ServerlessWorkflowMethods
maestro    | io.temporal.common.converter.DataConverterException: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `java.time.ZoneOffset` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)
maestro    |  at [Source: (byte[])"{"_type":"ServiceOk","response":{"dateCreated":{"offset":{"totalSeconds":0,"id":"Z","rules":{"fixedOffset":true,"transitions":[],"transitionRules":[]}},"nano":0,"year":2020,"monthValue":7,"dayOfMonth":23,"hour":18,"minute":38,"second":26,"month""[truncated 309 bytes]; line: 1, column: 314] (through reference chain: ServiceOk["response"]-> Service["dateCreated"]->java.time.OffsetDateTime["offset"])
maestro    |    at io.temporal.common.converter.JacksonJsonPayloadConverter.fromData(JacksonJsonPayloadConverter.java:82)
maestro    |    at io.temporal.common.converter.DefaultDataConverter.fromPayload(DefaultDataConverter.java:106)
maestro    |    at io.temporal.common.converter.DefaultDataConverter.fromPayloads(DefaultDataConverter.java:158)
maestro    |    at io.temporal.internal.sync.SyncWorkflowContext.lambda$executeActivity$aba2ce5b$1(SyncWorkflowContext.java:181)
maestro    |    at io.temporal.internal.sync.CompletablePromiseImpl.lambda$thenApply$2df5ef44$1(CompletablePromiseImpl.java:209)
maestro    |    at io.temporal.internal.sync.CompletablePromiseImpl.lambda$handle$6a2a7e3d$1(CompletablePromiseImpl.java:218)
maestro    |    at io.temporal.internal.sync.CompletablePromiseImpl.lambda$then$16b0e4cc$1(CompletablePromiseImpl.java:267)
maestro    |    at io.temporal.internal.sync.CompletablePromiseImpl.invokeHandlers(CompletablePromiseImpl.java:275)
maestro    |    at io.temporal.internal.sync.CompletablePromiseImpl.complete(CompletablePromiseImpl.java:166)
maestro    |    at io.temporal.internal.sync.SyncWorkflowContext$ActivityCallback.lambda$invoke$1(SyncWorkflowContext.java:210)
maestro    |    at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:104)
maestro    |    at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:107)
maestro    |    at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
maestro    |    at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
maestro    |    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
maestro    |    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
maestro    |    at java.base/java.lang.Thread.run(Thread.java:834)
maestro    | Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `java.time.ZoneOffset` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)
```

## Specifications

  - Version: 0.27.0

## Found workaround
using `jackson-datatype-jsr310` and `objectMapper.registerModule(new JavaTimeModule());` seems to alleviate the issue

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-22 02:17:32.000 UTC</summary>

https://github.com/temporalio/java-sdk/pull/191 added a test that validates that OffsetDateTime is convertible.

</details>


---

<a id="149"></a>

### #149: Workflow.wrap and Activity.wrap fail on chained Throwable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/149 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-07-13 23:53:45.000 UTC (5y 6m ago) |
| **Updated** | 2020-08-23 01:34:59.000 UTC |
| **Closed** | 2020-08-23 01:34:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

`Activity.wrap(new ActivityFailure(100, 1234,"", "234", RetryStatus.RETRY_STATUS_INTERNAL_SERVER_ERROR, "runId", new Throwable()))
`
should work

## Actual Behavior
Fails with ClassCastException:

```
java.lang.RuntimeException: Failure processing local activity task.
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.wrapFailure(LocalActivityWorker.java:229)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.wrapFailure(LocalActivityWorker.java:189)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.ClassCastException: class java.lang.Throwable cannot be cast to class java.lang.Exception (java.lang.Throwable and java.lang.Exception are in module java.base of loader 'bootstrap')
	at io.temporal.internal.common.CheckedExceptionWrapper.unwrap(CheckedExceptionWrapper.java:94)
	at io.temporal.failure.FailureConverter.exceptionToFailure(FailureConverter.java:182)
	at io.temporal.failure.FailureConverter.exceptionToFailureNoUnwrapping(FailureConverter.java:201)
	at io.temporal.failure.FailureConverter.exceptionToFailure(FailureConverter.java:183)
	at io.temporal.internal.sync.POJOActivityTaskHandler.mapToActivityFailure(POJOActivityTaskHandler.java:128)
	at io.temporal.internal.sync.POJOActivityTaskHandler.access$400(POJOActivityTaskHandler.java:54)
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOLocalActivityImplementation.execute(POJOActivityTaskHandler.java:257)
	at io.temporal.internal.sync.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:176)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:270)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:200)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:189)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 3 common frames omitted

```

The bug is in the CheckedExceptionWrapper.unwrap which assumes that a cause of an exception is either Error or Exception, but never any other child of Throwable or Throwable itself.


#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-23 01:34:59.000 UTC</summary>

Fixed by https://github.com/temporalio/java-sdk/pull/172. Validated by #194 

</details>


---

<a id="144"></a>

### #144: newUntypedWorkflowStub should check if runId.isPresent() before calling get

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/144 |
| **State** | CLOSED |
| **Author** | spozharov |
| **Created** | 2020-07-07 13:47:03.000 UTC (5y 6m ago) |
| **Updated** | 2020-08-22 02:20:10.000 UTC |
| **Closed** | 2020-08-22 02:20:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/temporal-java-sdk/blob/5faf2f81925226a949435b736339088fdb10e2d2/src/main/java/io/temporal/internal/sync/WorkflowClientInternal.java#L176



#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-22 02:20:10.000 UTC</summary>

Fixed by https://github.com/temporalio/java-sdk/pull/148

</details>


---

<a id="107"></a>

### #107: Intermittent testWorkflowMetrics Unit test failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/107 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-06-18 23:14:24.000 UTC (5y 6m ago) |
| **Updated** | 2021-09-23 17:41:04.000 UTC |
| **Closed** | 2021-09-23 17:41:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Test always passing

## Actual Behavior
When running in a constrained CI/CD environment it sometimes fails:

```
io.temporal.workflow.MetricsTest > testWorkflowMetrics FAILED
    java.lang.AssertionError: 3.39s
        at org.junit.Assert.fail(Assert.java:89)
        at org.junit.Assert.assertTrue(Assert.java:42)
        at io.temporal.workflow.MetricsTest.testWorkflowMetrics(MetricsTest.java:280)
```



#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:47:57.000 UTC</summary>

Possibly fixed, need to double check.

</details>


---

<a id="94"></a>

### #94: Do not retry SimulatedTimeoutException

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/94 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-23 02:15:50.000 UTC (5y 7m ago) |
| **Updated** | 2022-11-10 03:28:04.000 UTC |
| **Closed** | 2022-11-10 03:28:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
SimulatedTimeoutException of ScheduleToStart type should not be retried.

## Actual Behavior
FileProcessingTest.testHostFailover test demonstrates that it is retried according to the retry policy.



#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2022-11-10 03:28:04.000 UTC</summary>

There is no more simulated timeout exception in temporal java-sdk for some time, support of that class was incorrect and was making error handling convoluted. We will implement this or another mechanism like that when it's needed from scratch.

</details>


---

<a id="89"></a>

### #89: Add binary checksum to WorkerOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/89 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-19 19:56:40.000 UTC (5y 7m ago) |
| **Updated** | 2020-12-21 08:01:05.000 UTC |
| **Closed** | 2020-12-21 08:01:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently there is no way to set binary checksum used for marking bad builds in JavaSDK.



#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2020-12-21 08:01:04.000 UTC</summary>

#270 

</details>


---

<a id="88"></a>

### #88: Customer needs to specify timeout for start workflow call

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/88 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-19 15:39:54.000 UTC (5y 7m ago) |
| **Updated** | 2023-05-23 06:27:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
From slack:

> Use-Case: If we can't start workflow for an operation in X secs, we have a fallback option. Now, the fallback option AND workflow can't run concurrently. Hence, it's important that the start workflow deterministically succeeds or fails within X secs.

## Actual Behavior
Currently retry options are not configurable.


#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:37:54.000 UTC</summary>

In go we have context, and we can specify deadline in the code. If we specify deadline for 3 seconds and workflow didn't start for 3 seconds, code will return. In java we don't have that ability. We need to be able to specify override to gRPC timeout in code.

</details>


---

<a id="84"></a>

### #84: TestWorkflowService: Make tokens unique across retries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/84 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-05-11 03:03:51.000 UTC (5y 8m ago) |
| **Updated** | 2022-11-21 16:15:13.000 UTC |
| **Closed** | 2022-11-21 16:15:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

Currently real service doesn't accepts activity and workflow task tokens across retries. But the TestWorkflowService [includes only workflow and activity id in it](https://github.com/temporalio/temporal-java-sdk/blob/538557e55d27635bd08e507bc4b595c19e20223a/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java#L544).

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:32:05.000 UTC</summary>

We don't include retry count into the token, which is why previous activity retry can complete next one in the test service. To be consistent with the real service we want to fix this.

</details>


---

<a id="75"></a>

### #75: Provide shaded release JAR

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/75 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-30 14:04:52.000 UTC (5y 8m ago) |
| **Updated** | 2023-02-16 17:28:33.000 UTC |
| **Closed** | 2023-02-16 17:28:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëÄ 1 |

#### Description

From slack:

> I am exploring temporal as a replacement for our internal workflow engine.
> Is there a java uber-jar available with all dependencies shaded to an internal namespace? I see a lot of netty & guava dependencies and if I make a REST call in an activity using a library dependent on a different version of netty, the classes could conflict, right?

So I propose to add the shaded jar to the release artifacts

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-02-16 17:28:32.000 UTC</summary>

Closed by #1656

</details>


---

<a id="74"></a>

### #74: Delay workflow completion until abandoned workflows start

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/74 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-30 03:20:46.000 UTC (5y 8m ago) |
| **Updated** | 2020-08-24 16:05:04.000 UTC |
| **Closed** | 2020-08-24 16:05:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently if a parent workflow exits before a child workflow has started the child is not going to start at all. It is possible to resolve by waiting for a Promise returned from ChildWorkflowStub.getExecution(). But this is a pretty obscure and error prone feature.

The proposal is to automatically delay workflow completion if there is an outstanding start child request that has abandon parent policy until the child reported that it started successfully. 

This also applies to cancellation requests to child workflows that have abandon parent close policy.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-24 16:05:02.000 UTC</summary>

After thinking about this a little bit more I think we should implement this on the server-side. The delay of completion is easy by the SDK. But dealing with events that happened after completion was requested and children have started is really hard without service support. I"m going to resolve it here. [Here is ](https://github.com/temporalio/temporal/issues/685)the corresponding service repo issue.

</details>


---

<a id="66"></a>

### #66: Fix incorrect use of System.nanoTime

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/66 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-16 16:06:12.000 UTC (5y 8m ago) |
| **Updated** | 2020-04-25 16:27:24.000 UTC |
| **Closed** | 2020-04-25 16:27:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/uber/cadence-java-client/blob/master/src/main/java/com/uber/cadence/internal/worker/ActivityWorker.java#L190

nanoTime() has no correlation with the actual wall clock time.  If we want nanoseconds, call currentTimeMillis and multiply by 1M.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-04-25 16:27:23.000 UTC</summary>

Fixed through https://github.com/temporalio/temporal-java-sdk/pull/68

</details>


---

<a id="57"></a>

### #57: Automatically reconnect to the service when it changes ip address

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/57 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-04 16:04:17.000 UTC (5y 9m ago) |
| **Updated** | 2023-05-23 06:16:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

During various failure/deployment scenarios especially in K8s the service IP might change. Currently a worker and client restart is needed to deal with it.

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:20:31.000 UTC</summary>

1. We need to make sure that when new hosts are getting traffic.
2. When were restart the service different IPs will be behind DNS record and this may cause problems on the client side when the client tries to reconnect.

</details>


---

<a id="28"></a>

### #28: Add workflow deadlock detector

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/28 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-03-13 16:18:16.000 UTC (5y 10m ago) |
| **Updated** | 2020-11-10 20:13:08.000 UTC |
| **Closed** | 2020-11-10 20:13:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | enhancement |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

Currently if a workflow code by mistake uses Java synchronization primitives it deadlocks as dispatcher relies on cooperative multithreading. Here is an example stack trace that shows that one thread obtains lock (0x00000006c815ddb8) through synchronized method and blocks other thread from making progress. 

The proposal is to implement deadlock detection feature to fail decision task with a clear message that Java locking primitives are prohibited inside the workflow code.
```
    public static void main(String[] args) {
        ""WorkflowStageProgressListener::stageCompleted" signal handler" #78 prio=5 os_prio=0 tid=0x0000560f1fe02800 nid=0x5e waiting for monitor entry [0x00007f142a435000]
        java.lang.Thread.State: BLOCKED (on object monitor)
        at com.somecompany.platform.cadence.workflows.onboarding.HiringWorkFlowImpl.transitionMainTaskToInProgress(HiringWorkFlowImpl.java:327)
        - waiting to lock <0x00000006c815ddb8> (a com.somecompany.platform.cadence.workflows.onboarding.HiringWorkFlowImpl)
        at com.somecompany.platform.cadence.workflows.onboarding.HiringWorkFlowImpl.stageCompleted(HiringWorkFlowImpl.java:282)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at com.uber.cadence.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.processSignal(POJOWorkflowImplementationFactory.java:312)
        at com.uber.cadence.internal.sync.WorkflowRunnable.processSignal(WorkflowRunnable.java:65)
        at com.uber.cadence.internal.sync.SyncWorkflow.lambda$handleSignal$0(SyncWorkflow.java:106)
        at com.uber.cadence.internal.sync.SyncWorkflow$$Lambda$1231/1900852990.run(Unknown Source)
        at com.uber.cadence.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:102)
        at com.uber.cadence.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:85)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)
        ""WorkflowStageProgressListener::stageInProgress" signal handler" #77 prio=5 os_prio=0 tid=0x0000560f20a13000 nid=0x5d waiting on condition [0x00007f142a536000]
        java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
                - parking to wait for  <0x00000006c81a5550> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at com.uber.cadence.internal.sync.WorkflowThreadContext.yield(WorkflowThreadContext.java:76)
        at com.uber.cadence.internal.sync.WorkflowThreadImpl.yield(WorkflowThreadImpl.java:400)
        at com.uber.cadence.internal.sync.WorkflowThread.await(WorkflowThread.java:43)
        at com.uber.cadence.internal.sync.CompletablePromiseImpl.get(CompletablePromiseImpl.java:71)
        at com.uber.cadence.internal.sync.ActivityStubBase.execute(ActivityStubBase.java:42)
        at com.uber.cadence.internal.sync.ActivityStubImpl.execute(ActivityStubImpl.java:26)
        at com.uber.cadence.internal.sync.ActivityInvocationHandler.lambda$getActivityFunc$0(ActivityInvocationHandler.java:51)
        at com.uber.cadence.internal.sync.ActivityInvocationHandler$$Lambda$1192/803084529.apply(Unknown Source)
        at com.uber.cadence.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:76)
        at com.sun.proxy.$Proxy231.updateTaskStatus(Unknown Source)
        at com.somecompany.platform.cadence.workflows.onboarding.HiringWorkFlowImpl.transitionMainTaskToInProgress(HiringWorkFlowImpl.java:328)
        - locked <0x00000006c815ddb8> (a com.somecompany.platform.cadence.workflows.onboarding.HiringWorkFlowImpl)
        at com.somecompany.platform.cadence.workflows.onboarding.HiringWorkFlowImpl.stageInProgress(HiringWorkFlowImpl.java:317)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at com.uber.cadence.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.processSignal(POJOWorkflowImplementationFactory.java:312)
        at com.uber.cadence.internal.sync.WorkflowRunnable.processSignal(WorkflowRunnable.java:65)
        at com.uber.cadence.internal.sync.SyncWorkflow.lambda$handleSignal$0(SyncWorkflow.java:106)
        at com.uber.cadence.internal.sync.SyncWorkflow$$Lambda$1231/1900852990.run(Unknown Source)
        at com.uber.cadence.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:102)
        at com.uber.cadence.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:85)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)

```

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-10-31 22:50:14.000 UTC</summary>

Another user was calling an external service to track workflow state transitions. The call was taking a long time causing workflow task timeout. It took a long time to track the issue down. With the deadlock detector, it would be reported immediately. 

</details>


---

<a id="27"></a>

### #27: Add support for ActivityOptions.WaitForCancellation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/27 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-03-06 04:00:28.000 UTC (5y 10m ago) |
| **Updated** | 2020-04-25 16:29:06.000 UTC |
| **Closed** | 2020-04-25 16:29:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently on cancellation activity is abandoned. There is no way to wait for its cancellation.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-04-25 16:29:06.000 UTC</summary>

Fixed through https://github.com/temporalio/temporal-java-sdk/pull/61

</details>


---

<a id="24"></a>

### #24: Fix getVersion

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/24 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-25 18:01:56.000 UTC (5y 10m ago) |
| **Updated** | 2020-08-24 18:05:28.000 UTC |
| **Closed** | 2020-08-24 18:05:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

It was reported that getVersion doesn't return the same value for the same changeID

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-02-25 18:06:15.000 UTC</summary>

Reported by a customer:

_When an unversioned workflow ‚Äúresumes‚Äù with versioned code, that doesn‚Äôt cause a MarkerRecorded in Golang. But it does cause a MarkerRecorded in the Java client._



</details>


---

<a id="21"></a>

### #21: Add support for cross domain activity and child workflow scheduling

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/21 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-18 23:04:13.000 UTC (5y 10m ago) |
| **Updated** | 2023-04-18 17:35:52.000 UTC |
| **Closed** | 2023-04-18 17:35:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

*No description provided.*

#### Comments (1)

<details>
<summary><strong>Spikhalskiy</strong> commented on 2023-04-18 17:35:52.000 UTC</summary>

Cross-namespace activity or workflow scheduling is currently explicitly not supported by the server.


</details>


---

<a id="20"></a>

### #20: Rename Worker.register... to Worker.set

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/20 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-16 20:46:15.000 UTC (5y 10m ago) |
| **Updated** | 2020-12-22 05:08:00.000 UTC |
| **Closed** | 2020-12-22 05:08:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

The current `Worker.registerActivitiesImpl `and `registerWorkflowImplementationTypes` are  confusing as it takes a list and fully overrides it which is expected from `set<foo> `methods.

#### Comments (1)

<details>
<summary><strong>vitarb</strong> commented on 2020-11-25 01:17:26.000 UTC</summary>

We should not erase contents passed through register and allow accumulation.

</details>


---

<a id="18"></a>

### #18: Add Logger that works in both activity and workflow context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/18 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-14 23:37:59.000 UTC (5y 11m ago) |
| **Updated** | 2020-08-23 19:44:04.000 UTC |
| **Closed** | 2020-08-23 19:44:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Some utility code can be invoked from workflow context as well as outside of it. `Workflow.getLogger` fails with an exception when invoked outside of a workflow. The proposal is to change `getLogger` to not fail due to called outside of the workflow context and just return standard loger instead of `ReplayAwareLogger`.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-23 19:44:03.000 UTC</summary>

Fixed by https://github.com/temporalio/java-sdk/pull/143

</details>


---

<a id="1"></a>

### #1: Switch to Jackson for default DataConverter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2019-12-13 00:06:43.000 UTC (6 years ago) |
| **Updated** | 2020-08-23 19:45:48.000 UTC |
| **Closed** | 2020-08-23 19:45:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 1 |
| **Priority Score** | 1 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

Jackson looks like better maintained with Java 11 support.

#### Comments (1)

<details>
<summary><strong>mfateev</strong> commented on 2020-08-23 19:45:47.000 UTC</summary>

Implemented as part of https://github.com/temporalio/java-sdk/pull/101

</details>


---

<a id="2755"></a>

### #2755: Support using Temporal failures in Nexus APIs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2755 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2026-01-05 21:37:57.000 UTC (3 days ago) |
| **Updated** | 2026-01-05 21:38:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

 Support using Temporal failures in Nexus APIs.

**Additional context**

https://github.com/temporalio/api/pull/682


---

<a id="2754"></a>

### #2754: Environment Configuration does not read the correct file path on macOS

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2754 |
| **State** | OPEN |
| **Author** | pvsone (Peter Sullivan) |
| **Created** | 2026-01-04 17:49:02.000 UTC (4 days ago) |
| **Updated** | 2026-01-04 17:49:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Per [the documentation](https://docs.temporal.io/develop/environment-configuration), the SDKs should read the toml config file on a mac from `$HOME/Library/Application Support/temporal/temporal.toml`.  However this path is not being read (the Linux path is being read instead `~/.config/temporalio/temporal.toml`)

## Actual Behavior
On a mac I expect the SDK to read the Environment Config profile from $HOME/Library/Application Support/temporal/temporal.toml

## Steps to Reproduce the Problem

  1. Create a Profile TOML file on a Mac using the CLI, which writes a file to: $HOME/Library/Application Support/temporal/temporal.toml
  1. Create a Java program that attempts to read the Profile using the Env Config APIs.  An error will be thrown that the profile cannot be found
  1. For fun, copy the profile file from the default, documented location ($HOME/Library/Application Support/temporal/temporal.toml) to ~/.config/temporalio/temporal.toml.  Run the Java program again.  The profile will now be successfully found and loaded

## Specifications

  - Version: Java SDK 1.32.1
  - Platform: Mac



---

<a id="2752"></a>

### #2752: OpenTracingWorkflowClientCallsInterceptor - support for updateWithStart is not present

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2752 |
| **State** | OPEN |
| **Author** | deepika-awasthi |
| **Created** | 2025-12-30 20:45:57.000 UTC (9 days ago) |
| **Updated** | 2025-12-30 20:46:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Traces are not propagated for the operation updateWithStart

header field is empty for the first event EVENT_TYPE_WORKFLOW_EXECUTION_STARTED
`=== Client UpdateWithStart Interceptor Called ===
Workflow ID: TestInterceptorUpdateWithStartWorkflow
Workflow Type: MyWorkflow
Update Name: updateNameAndTitle
Update ID: 9adc07b0-e8ef-48f5-b4ca-0d7a67e677a7
Start Header: {}
Start Header size: 0
`

https://javadoc.io/static/io.temporal/temporal-opentracing/1.32.0/io/temporal/opentracing/internal/OpenTracingWorkflowClientCallsInterceptor.html


---

<a id="2750"></a>

### #2750: Tests not passing: TestStatsReporter Flush not flushing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2750 |
| **State** | OPEN |
| **Author** | TbirdDuncan |
| **Created** | 2025-12-28 18:26:55.000 UTC (11 days ago) |
| **Updated** | 2025-12-28 19:04:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I'd expect running ./gradlew test or build would pass on a clean main branch. That is not happening.
WorkflowFailedMetricsTests.java runs a @Before setup that contains: reporter.flush()
Some methods are experiencing failures when ran in conjunction with other tests, such as:
`runtimeExceptionWorkflowFailedMetric
java.lang.AssertionError: No metric 'temporal_workflow_failed [namespace=UnitTest|task_queue=WorkflowTest-runtimeExceptionWorkflowFailedMetric-b83ed43d-267b-430a-8634-4ecc35a5ceb2|workflow_type=TestWorkflow]', reported metrics: 
 temporal_poller_start [namespace=UnitTest|task_queue=WorkflowTest-runtimeExceptionWorkflowFailedMetric-b83ed43d-267b-430a-8634-4ecc35a5ceb2|worker_type=WorkflowWorker]
 temporal_worker_start [namespace=UnitTest|task_queue=WorkflowTest-runtimeExceptionWorkflowFailedMetric-b83ed43d-267b-430a-8634-4ecc35a5ceb2|worker_type=WorkflowWorker]
 temporal_request [operation=DescribeNamespace]
 temporal_long_request [namespace=UnitTest|operation=GetWorkflowExecutionHistory]
 temporal_request []
 temporal_request [operation=GetSystemInfo]
 temporal_request [namespace=UnitTest|operation=StartWorkflowExecution|task_queue=WorkflowTest-runtimeExceptionWorkflowFailedMetric-b83ed43d-267b-430a-8634-4ecc35a5ceb2|workflow_type=TestWorkflow]
 temporal_long_request [namespace=UnitTest|operation=PollWorkflowTaskQueue|task_queue=WorkflowTest-runtimeExceptionWorkflowFailedMetric-b83ed43d-267b-430a-8634-4ecc35a5ceb2|worker_type=WorkflowWorker]
 temporal_workflow_task_queue_poll_succeed [namespace=UnitTest|task_queue=WorkflowTest-runtimeExceptionWorkflowFailedMetric-b83ed43d-267b-430a-8634-4ecc35a5ceb2|worker_type=WorkflowWorker]
	at org.junit.Assert.fail(Assert.java:89)
	at io.temporal.common.reporter.TestStatsReporter.assertCounter(TestStatsReporter.java:53)
	at io.temporal.common.reporter.TestStatsReporter.assertCounter(TestStatsReporter.java:45)
	at io.temporal.internal.worker.WorkflowFailedMetricsTests.runtimeExceptionWorkflowFailedMetric(WorkflowFailedMetricsTests.java:164)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at io.temporal.testing.internal.SDKTestWorkflowRule$1.evaluate(SDKTestWorkflowRule.java:233)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:299)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:293)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.lang.Thread.run(Thread.java:1583)
workflowFailureMetricBenignApplicationError
java.lang.AssertionError: No metric 'temporal_workflow_failed [namespace=UnitTest|task_queue=WorkflowTest-workflowFailureMetricBenignApplicationError-20c969a7-bd07-49f5-b275-eea4eacb2533|workflow_type=ApplicationFailureWorkflow]', reported metrics: 
 temporal_worker_start [namespace=UnitTest|task_queue=WorkflowTest-workflowFailureMetricBenignApplicationError-20c969a7-bd07-49f5-b275-eea4eacb2533|worker_type=WorkflowWorker]
 temporal_request [operation=DescribeNamespace]
 temporal_poller_start [namespace=UnitTest|task_queue=WorkflowTest-workflowFailureMetricBenignApplicationError-20c969a7-bd07-49f5-b275-eea4eacb2533|worker_type=WorkflowWorker]
 temporal_request [namespace=UnitTest|operation=StartWorkflowExecution|task_queue=WorkflowTest-workflowFailureMetricBenignApplicationError-20c969a7-bd07-49f5-b275-eea4eacb2533|workflow_type=ApplicationFailureWorkflow]
 temporal_request [operation=GetSystemInfo]
 temporal_long_request [namespace=UnitTest|operation=PollWorkflowTaskQueue|task_queue=WorkflowTest-workflowFailureMetricBenignApplicationError-20c969a7-bd07-49f5-b275-eea4eacb2533|worker_type=WorkflowWorker]
	at org.junit.Assert.fail(Assert.java:89)
	at io.temporal.common.reporter.TestStatsReporter.assertCounter(TestStatsReporter.java:53)
	at io.temporal.common.reporter.TestStatsReporter.assertCounter(TestStatsReporter.java:45)
	at io.temporal.internal.worker.WorkflowFailedMetricsTests.workflowFailureMetricBenignApplicationError(WorkflowFailedMetricsTests.java:204)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at io.temporal.testing.internal.SDKTestWorkflowRule$1.evaluate(SDKTestWorkflowRule.java:233)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:299)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:293)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.lang.Thread.run(Thread.java:1583)`

## Steps to Reproduce the Problem

  1. Run ./gradlew build, or ./gradlew test
 



---

<a id="2747"></a>

### #2747: @WorkflowImpl(workers = "...") should support Spring property placeholders like taskQueues does

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2747 |
| **State** | OPEN |
| **Author** | karunagoyal (Karuna Goyal) |
| **Created** | 2025-12-12 17:25:42.000 UTC (28 days ago) |
| **Updated** | 2025-12-12 17:25:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The @WorkflowImpl annotation has two attributes for specifying which worker to register a workflow with:
workers - by worker name
taskQueues - by task queue
Currently, only taskQueues supports Spring property placeholders (e.g., ${my.property}), while workers does not. This inconsistency causes issues when sharing workflow modules across multiple services that need different worker names.

**Current Behavior**
In WorkersTemplate.java:
taskQueues - ‚úÖ Resolves placeholders:
workers - ‚ùå Does NOT resolve placeholders:

**Expected Behavior**
Both workers and taskQueues should support Spring property placeholders for consistency:

**Use Case**
We have a shared workflow module used by multiple Spring Boot services. Each service configures its own worker name in application.yaml. We want to use:
Currently, this fails because the placeholder is not resolved, causing:
Workaround
Using taskQueues with a placeholder works:
However, this is inconsistent with the workers attribute behavior.

**Proposed Fix**
Add placeholder resolution in configureWorkflowImplementationsByWorkerName(), configureActivityBeansByWorkerName(), and configureNexusServiceBeansByWorkerName() methods in WorkersTemplate.java.


---

<a id="2745"></a>

### #2745: WorkerOptions isUsingVirtualThreadsOnWorkflowWorker issue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2745 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-12-08 19:43:12.000 UTC (1 months ago) |
| **Updated** | 2025-12-08 19:43:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/worker/WorkerOptions.java#L870-L872

returning usingVirtualThreadsOnActivityWorker currently


---

<a id="2735"></a>

### #2735: Non-root namespaces should be able to use the in-memory test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2735 |
| **State** | CLOSED |
| **Author** | billrich2001 (Bill Richards) |
| **Created** | 2025-11-24 17:28:13.000 UTC (1 months ago) |
| **Updated** | 2025-11-26 17:39:04.000 UTC |
| **Closed** | 2025-11-26 17:39:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Non-root namespaces should be able to use the in-memory test server when `spring.temporal.test-server.enabled=true` is configured, just like the root namespace does.

## Actual Behavior
Non-root namespaces cannot use the in-memory test server due to a bean name/type mismatch in Spring autoconfiguration. Instead of using `TestWorkflowEnvironment`, the configuration creates a client connecting to the dev server when multiple namespaces are used.

## Steps to Reproduce the Problem
[Example](https://github.com/bbeck10/temporal-samples-java/pull/1/files)
1. Configure Spring Boot application with `spring.temporal.test-server.enabled=true`
2. Set up multiple namespaces (root and non-root namespaces)
3. Attempt to run tests with non-root namespaces
4. Observe that non-root namespaces connect to dev server instead of in-memory test server

## Specifications
- Version: Temporal Java SDK v1.30.0+
- Platform: Spring Boot with Temporal Spring Boot Autoconfigure

**Root Cause:** The issue appears to be in `NonRootBeanPostProcessor` where there's a name/type mismatch:
```java
testWorkflowEnvironment = findBean("temporalTestWorkflowEnvironment", TestWorkflowEnvironmentAdapter.class);
```

However, `TestServerAutoConfiguration` registers:
- `"temporalTestWorkflowEnvironment"` as a `TestWorkflowEnvironment`
- `"temporalTestWorkflowEnvironmentAdapter"` as a `TestWorkflowEnvironmentAdapter`

The code is looking for a `TestWorkflowEnvironmentAdapter` with the wrong bean name.


---

<a id="2732"></a>

### #2732: Set GrpcMessageTooLarge as failure_reason for workflow task failed metric

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2732 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-11-19 04:27:52.000 UTC (1 months ago) |
| **Updated** | 2025-11-20 17:59:13.000 UTC |
| **Closed** | 2025-11-20 17:59:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/695


---

<a id="2726"></a>

### #2726: Allow overriding of the Worker Deployment Version when invoking a Child Workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2726 |
| **State** | OPEN |
| **Author** | chris-olszewski (Chris Olszewski) |
| **Created** | 2025-11-12 16:22:34.000 UTC (1 months ago) |
| **Updated** | 2025-11-12 16:22:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Users want to override the target version on a workflow, especially when doing pre-deployment testing. This should work the same as it does when creating a Workflow from a client.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="2716"></a>

### #2716: Worker Heartbeating

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2716 |
| **State** | OPEN |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-10-28 01:50:50.000 UTC (2 months ago) |
| **Updated** | 2025-10-28 01:50:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**
Implement worker heartbeating, which is sent via a new background nexus worker.

Basically need to design a Java version of https://github.com/temporalio/sdk-core/pull/953 and https://github.com/temporalio/sdk-core/pull/1038

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="2714"></a>

### #2714: Improper file path for envconfig

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2714 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-10-27 15:13:46.000 UTC (2 months ago) |
| **Updated** | 2025-10-28 00:16:44.000 UTC |
| **Closed** | 2025-10-28 00:16:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

https://github.com/temporalio/sdk-java/blob/019ad7011ad940c78cb638d527c90d7120e6a2ed/temporal-envconfig/src/main/java/io/temporal/envconfig/ClientConfig.java#L41 needs to be changed to have the dir be `temporalio`


---

<a id="2707"></a>

### #2707: duplicated error message "invalid interval:..."  in RPCRetryOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2707 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2025-10-22 07:39:55.000 UTC (2 months ago) |
| **Updated** | 2025-10-22 22:09:51.000 UTC |
| **Closed** | 2025-10-22 22:09:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

the [RPCRetryOptions](https://github.com/temporalio/sdk-java/blob/c46eb46c872a4541a439cba0d46fe5d8268af739/temporal-serviceclient/src/main/java/io/temporal/serviceclient/RpcRetryOptions.java#L108-L146) class throws a duplicated error message: invalid interval:... for several different properties. This duplication makes it difficult to determine which property is misconfigured when the error occurs


**Describe the solution you'd like**

Update the error messages in RPCRetryOptions to be unique for each property, allowing users to identify misconfigurations more easily.



---

<a id="2705"></a>

### #2705: Default task failure cause to "workflow worker unhandled failure"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2705 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-10-21 18:32:39.000 UTC (2 months ago) |
| **Updated** | 2025-11-12 18:20:56.000 UTC |
| **Closed** | 2025-11-12 18:20:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Today, if my reading is right, we default `RespondWorkflowTaskFailedRequest.cause` to `WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED`. This is unlike Go SDKs that defaults task failures to `WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE`. We should change to the latter in these cases where it is usually user exception (also see same issue in Core: https://github.com/temporalio/sdk-core/issues/1041).


---

<a id="2703"></a>

### #2703: [java] Plugin + SimplePlugin

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2703 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2025-10-20 21:22:53.000 UTC (2 months ago) |
| **Updated** | 2025-10-20 21:25:46.000 UTC |
| **Closed** | 2025-10-20 21:25:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Implement Plugins so that users can self-serve creating integrations with Temporal Workflows.  This is done in Python and we can copy. 


---

<a id="2702"></a>

### #2702: Add support for static summary for side effects and mutable side effects

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2702 |
| **State** | CLOSED |
| **Author** | yuandrew (Andrew Yuan) |
| **Created** | 2025-10-20 16:42:40.000 UTC (2 months ago) |
| **Updated** | 2025-10-31 02:09:42.000 UTC |
| **Closed** | 2025-10-31 02:09:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ‚ù§Ô∏è 1 |

#### Description

**Is your feature request related to a problem? Please describe.**
Side Effect markers in the UI don't have any identifiable information, when there's multiple in quick succession in the UI, we're not able to identify them apart unless we click into the specific item.

**Describe the solution you'd like**
Support static summary for these items, then UI can be changed to display their summaries, similar to activities and local activities.

**Additional context**
Add any other context or screenshots about the feature request here.
https://github.com/temporalio/sdk-go/issues/2076



---

<a id="2689"></a>

### #2689: Use normal task queue name for sticky task queue client metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2689 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-10-17 21:41:34.000 UTC (2 months ago) |
| **Updated** | 2025-10-20 17:27:53.000 UTC |
| **Closed** | 2025-10-20 17:27:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Port https://github.com/temporalio/sdk-core/pull/1039


---

<a id="2666"></a>

### #2666: Test server needs to set metadata `type` for search attribute payloads

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2666 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-09-24 18:22:29.000 UTC (3 months ago) |
| **Updated** | 2025-10-10 15:14:54.000 UTC |
| **Closed** | 2025-10-10 15:14:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Today, Temporal server sets `type` metadata on search attribute payloads even if user doesn't set it, test server should do the same.


---

<a id="2661"></a>

### #2661: Set history size and suggest continue as new on task start attributes in test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2661 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-09-15 20:37:45.000 UTC (3 months ago) |
| **Updated** | 2025-09-25 23:14:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ‚ù§Ô∏è 1 |

#### Description

**Describe the solution you'd like**

Populate `WorkflowTaskStartedEventAttributes.suggest_continue_as_new` and `WorkflowTaskStartedEventAttributes.history_size_bytes` on the test server. The former can be just the Temporal server default (doesn't need to be configurable at this time like the server's is).


---

<a id="2659"></a>

### #2659: temporal-testing for Java does not propagate headers for signals in interceptors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2659 |
| **State** | CLOSED |
| **Author** | ivanasen (Ivan-Asen Chakarov) |
| **Created** | 2025-09-14 14:58:01.000 UTC (3 months ago) |
| **Updated** | 2025-09-15 03:33:31.000 UTC |
| **Closed** | 2025-09-15 03:33:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Assume we have a `WorkflowClientInterceptor` that sets a header when a signal is sent. In a real (or dev server) Temporal environment, the header will be present in the corresponding `WorkflowInboundCallsInterceptor.handleSignal`. However, if we use temporal-testing there will be no header. The `temporal-testing` library should be as close as possible to a real environment, and the header should be propagated.

## Actual Behavior
There is no header in the inbound interceptor's handler for signals.

## Steps to Reproduce the Problem
Here is a minimal example that reproduces the bug:
- [intercept.zip](https://github.com/user-attachments/files/22321086/intercept.zip) - The entire Maven project
- [ClientApp.java](https://github.com/user-attachments/files/22320971/ClientApp.java) - The client application.
- [WorkerApp.java](https://github.com/user-attachments/files/22320973/WorkerApp.java) - The worker application.
- [InterceptingSignalsBug.java](https://github.com/user-attachments/files/22320974/InterceptingSignalsBug.java) - Here are the workflows and interceptors.
- [InterceptingSignalsBugTest.java](https://github.com/user-attachments/files/22320984/InterceptingSignalsBugTest.java) - Here is a test.

Here are also snippets of the interceptors for better visibility:
```java
    public static final String HEADER = "my-header";
    public static final Payload PAYLOAD = GlobalDataConverter.get().toPayload("my-value").get();

    public static class Client extends WorkflowClientInterceptorBase {
        @Override
        public WorkflowClientCallsInterceptor workflowClientCallsInterceptor(WorkflowClientCallsInterceptor next) {
            return new WorkflowClientCallsInterceptorBase(next) {
                // ...

                @Override
                public WorkflowSignalOutput signal(WorkflowSignalInput input) {
                    log.info("CLIENT signal: Setting headers");
                    input.getHeader().getValues().put(HEADER, PAYLOAD);
                    return super.signal(input);
                }
            };
        }
    }

    static class Worker extends WorkerInterceptorBase {
        @Override
        public WorkflowInboundCallsInterceptor interceptWorkflow(WorkflowInboundCallsInterceptor next) {
            return new WorkflowInboundCallsInterceptorBase(next) {
                // ...

                @Override
                public void handleSignal(SignalInput input) {
                    log.info("INBOUND signal: Received header: {}", input.getHeader().getValues().get(HEADER));
                    super.handleSignal(input);
                }
            };
        }
    }
```

If we run a Temporal server, and also the `ClientApp` and `WorkerApp`, then the logs of the worker app will contain:
```
[signal signal] INFO com.example.InterceptingSignalsBug - INBOUND signal: Received header: metadata {
  key: "encoding"
  value: "json/plain"
}
data: "\"my-value\""
```
and on the other hand, if the test `InterceptingSignalsBugTest` is run, then the log will be:
```
[signal signal] INFO com.example.InterceptingSignalsBug - INBOUND signal: Received header: null
```

From my testing, it seems that all other inbound interceptor methods receive the headers correctly. Only the `signal` is problematic.

## Specifications

- Version:
```
$ temporal --version
temporal version 1.4.1 (Server 1.28.0, UI 2.39.0)

$ java --version
openjdk 22.0.2 2024-07-16
OpenJDK Runtime Environment (build 22.0.2+9-70)
OpenJDK 64-Bit Server VM (build 22.0.2+9-70, mixed mode, sharing)
```
- `temporal-sdk` and `temporal-testing` version used: **1.31.0**
- Platform: Ran on Macbook M1 Pro


---

<a id="2657"></a>

### #2657: Expose Temporal Nexus operation info to Temporal Nexus operation authors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2657 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-09-12 22:07:27.000 UTC (3 months ago) |
| **Updated** | 2025-09-18 16:35:04.000 UTC |
| **Closed** | 2025-09-18 16:35:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/674



---

<a id="2656"></a>

### #2656: Springboot Multi Namespace: Add annotation to specify Namespace a bean belongs too

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2656 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-09-08 22:15:38.000 UTC (4 months ago) |
| **Updated** | 2025-09-08 22:18:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Users would like to assign certain interceptors/customizers to certain namespaces in a multi namespace setup. Currently users can do this but they must specify it by prefixing the bean name with the appropriate namespace.

**Describe the solution you'd like**
A Java annotation or interface may be more idiomatic in Springboot

**Describe alternatives you've considered**
Keep the customization by bean name prefix.

***Related***

https://github.com/temporalio/sdk-java/issues/2638




---

<a id="2655"></a>

### #2655: Testing server continue-as-new doesn't carry memo/search attributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2655 |
| **State** | OPEN |
| **Author** | jasonmchan (Jason Chan) |
| **Created** | 2025-09-08 17:45:38.000 UTC (4 months ago) |
| **Updated** | 2025-09-25 23:14:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
When using ContinueAsNew with the testing server, the requested Memo and Search Attributes should be propagated into the new workflow execution.

This is what the production Temporal server does.

## Actual Behavior
The memo and search attributes in the command are dropped. See [here](https://github.com/temporalio/sdk-java/blob/31d044cfb67a29f456d0f699296e40cd4f05eb1e/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java?plain=1#L1531-L1571) for where the start request is constructed‚Äîthe memo and search attributes are not extracted from the `ContinueAsNewWorkflowExecutionCommandAttributes`.

## Steps to Reproduce the Problem
  1. Start a testing server
  2. Run a workflow that uses continue-as-new with search attributes / memo

## Specifications
  - Version: v1.31.0
  - Platform: all



---

<a id="2651"></a>

### #2651: Add overload for `WorkflowStub.cancel` to target exact workflow execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2651 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-09-05 19:13:33.000 UTC (4 months ago) |
| **Updated** | 2025-11-18 05:42:23.000 UTC |
| **Closed** | 2025-11-18 05:42:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

When I call `WorkflowStub.cancel` I want to only target the workflow execution I used to create the stub and not the latest workflow.

**Describe the solution you'd like**

Add overload for `WorkflowStub.cancel` to target exact workflow execution instead of the latest workflow ID/execution chain

**Describe alternatives you've considered**

We could also look at setting `first_execution_run_id`, need to verify if it is properly implemented for cancel.

**Additional context**

We need to add an appropriate note/warning to this overload since targeting such a specific run can be flaky when using things like continue as new. 


---

<a id="2650"></a>

### #2650: Ensure tests exist to confirm custom slot supplier slot info has proper fields

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2650 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-09-05 12:30:41.000 UTC (4 months ago) |
| **Updated** | 2025-09-05 12:30:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/672


---

<a id="2644"></a>

### #2644: `workflow_task_queue_poll_succeed` is not emitted when poller autoscaling is on

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2644 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-08-28 00:22:27.000 UTC (4 months ago) |
| **Updated** | 2025-08-28 16:30:40.000 UTC |
| **Closed** | 2025-08-28 16:30:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

`workflow_task_queue_poll_succeed` is emitted when poller autoscaling is on

## Actual Behavior

 `workflow_task_queue_poll_succeed` is not emitted when poller autoscaling is on




---

<a id="2643"></a>

### #2643: [Feature Request] Reclassify Benign Application errors in OpenTelemetry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2643 |
| **State** | CLOSED |
| **Author** | THardy98 (Thomas Hardy) |
| **Created** | 2025-08-26 20:40:17.000 UTC (4 months ago) |
| **Updated** | 2025-09-22 18:30:44.000 UTC |
| **Closed** | 2025-09-22 18:30:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See issue description here:

https://github.com/temporalio/sdk-python/issues/1041


---

<a id="2629"></a>

### #2629: Clarify nexus operation cancellation failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2629 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-08-15 18:17:27.000 UTC (4 months ago) |
| **Updated** | 2025-08-18 14:33:14.000 UTC |
| **Closed** | 2025-08-18 14:33:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Clarify nexus operation cancellation failure


---

<a id="2626"></a>

### #2626: Plugin support

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2626 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-08-15 14:32:53.000 UTC (4 months ago) |
| **Updated** | 2025-08-15 14:32:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/652


---

<a id="2620"></a>

### #2620: OpenTracingClientInterceptor add support for updateWithStart

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2620 |
| **State** | OPEN |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2025-08-12 12:34:57.000 UTC (5 months ago) |
| **Updated** | 2025-08-12 12:34:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Traces are not propagated for the operation updateWithStart

`header` field is empty for the first event EVENT_TYPE_WORKFLOW_EXECUTION_STARTED 




---

<a id="2614"></a>

### #2614: In a Nexus handler only pass a completion callback if a completion URL is provided

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2614 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-08-08 06:22:11.000 UTC (5 months ago) |
| **Updated** | 2025-08-12 16:41:35.000 UTC |
| **Closed** | 2025-08-12 16:41:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
In a Nexus handler only pass a completion callback if a completion URL is provided

## Actual Behavior
In a Nexus handler a completion callback is always provided.



---

<a id="2612"></a>

### #2612: Align Nexus handler failure conversion with other SDKs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2612 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-08-08 06:10:18.000 UTC (5 months ago) |
| **Updated** | 2025-08-11 18:10:37.000 UTC |
| **Closed** | 2025-08-11 18:10:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Align Nexus handler failure conversion with other SDKs




---

<a id="2610"></a>

### #2610: Spring boot with namespaces configuration Connection refused: /127.0.0.1:7233 in tests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2610 |
| **State** | CLOSED |
| **Author** | oleg-kovrizhin-paradym |
| **Created** | 2025-08-06 13:35:45.000 UTC (5 months ago) |
| **Updated** | 2025-08-08 05:36:32.000 UTC |
| **Closed** | 2025-08-08 05:36:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Tests should be started without fail
## Actual Behavior

Test failed with
Caused by: io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: /127.0.0.1:7233
Caused by: java.net.ConnectException: Connection refused


## Steps to Reproduce the Problem

The problem is: 

We are trying to migrate our app from the previous temporal boot starter from '1.29.0' to '1.30.1', but we can't because our tests are failing. It is a bit strange because we didn't change anything except the version of the library. Maybe you could help us and say what is going wrong.

Our configuration is:
spring.main.allow-bean-definition-overriding=true
spring.temporal.connection.target=127.0.0.1:7233
spring.temporal.namespace=default
spring.temporal.test-server.enabled=true
spring.temporal.namespaces[0].namespace=default
spring.temporal.namespaces[0].alias=microservice
spring.temporal.namespaces[0].connection.target=127.0.0.1:7233
spring.temporal.namespaces[0].workersAutoDiscovery.packages=com.package.temporal

Nothing special in the workers and activities definitions, only taskQueues are defined.

Client autowired like this:

   @Autowired
    @Qualifier("microserviceWorkflowClient")
    @Lazy
    private WorkflowClient microserviceWorkflowClient;

One interesting thing, if we put everything to the default client and have a configuration like this, the test started normally, and we don't see any issue. Looks like something is wrong with the namespaces configuration for Spring Boot.

This is the working configuration:

spring.main.allow-bean-definition-overriding=true
spring.temporal.connection.target=127.0.0.1:7233
spring.temporal.namespace=default
spring.temporal.test-server.enabled=true
spring.temporal.workersAutoDiscovery.packages=io.package.temporal
#spring.temporal.namespaces[0].namespace=default
#spring.temporal.namespaces[0].alias=microservice
#spring.temporal.namespaces[0].connection.target=127.0.0.1:7233
#spring.temporal.namespaces[0].workersAutoDiscovery.packages=io.package.temporal

Client:

    @Autowired
    private WorkflowClient workflowClient;

It looks like the gRPC server is not started when you define namespaces, but it is a bit hard to figure out why. Could you have a look at that? Thanks. Or give some advice on what to check.

On version 1.29.0 both configurations are working fine.

## Specifications

  - Version: 1.30.1
  - Platform: Mac



---

<a id="2606"></a>

### #2606: TestWorkflowMutableStateImpl - race condition between TimerFired event and CancelTimer command

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2606 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-07-27 17:32:27.000 UTC (5 months ago) |
| **Updated** | 2025-09-26 06:39:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

[processCancelTimer](https://github.com/temporalio/sdk-java/blob/master/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java#L979-L983) throws invalid_argument exception here if timer is null
this timer however would have been already removed if this same workflow task receives a TIMER_FIRED event for this same timer:

https://github.com/temporalio/sdk-java/blob/master/temporal-test-server/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java#L1437

I think on cancel command, we should only throw if we check first that if timer is null if it was actually removed in same workflow task.

Issue does not allow workflow in test to complete / make progress.

Full error can look like:

[Workflow Executor taskQueue="flakyservice", namespace="default": 1] WARN io.temporal.internal.worker.WorkflowWorker - Failure while reporting workflow progress to the server. If seen continuously the workflow might be stuck. WorkflowId=flaky, RunId=6d9e3f8a-7a73-4aaf-8cdd-02a3cee750f1, startedEventId=22
io.grpc.StatusRuntimeException: INVALID_ARGUMENT: invalid history builder state for action
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:268)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:249)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:167)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.respondWorkflowTaskCompleted(WorkflowServiceGrpc.java:6079)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.lambda$sendTaskCompleted$0(WorkflowWorker.java:557)
	at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:49)
	at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:40)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.sendTaskCompleted(WorkflowWorker.java:552)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:409)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:336)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$1(PollTaskExecutor.java:76)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)


Still working on a reliable test for this. @Quinn-With-Two-Ns ping me and can point you to slack there where there is a reproduce that you may need to run a number of times to run into this.


---

<a id="2601"></a>

### #2601: ApplicationFailure.Builder requires Category be set

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2601 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-07-18 20:35:16.000 UTC (5 months ago) |
| **Updated** | 2025-07-22 16:14:04.000 UTC |
| **Closed** | 2025-07-22 16:14:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`ApplicationFailure.Builder` should not require Category be set

## Actual Behavior
`ApplicationFailure.Builder` requires Category be set




---

<a id="2598"></a>

### #2598: Allow specifying activity options for specific activity call

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2598 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-07-15 15:37:05.000 UTC (5 months ago) |
| **Updated** | 2025-07-15 15:37:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to call an activity method (or child workflow method or nexus operation) with specific options that are different from the options I used to create the stub.

**Describe the solution you'd like**
Add an API to support calling an activity method with an option override

**Describe alternatives you've considered**
Create a new stub for each call



---

<a id="2593"></a>

### #2593: Created accidentally

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2593 |
| **State** | CLOSED |
| **Author** | andelgdo (andelgdo) |
| **Created** | 2025-07-11 00:12:27.000 UTC (6 months ago) |
| **Updated** | 2025-07-11 14:54:41.000 UTC |
| **Closed** | 2025-07-11 00:17:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description


Created accidentally


---

<a id="2592"></a>

### #2592: Python Nexus tests failing under Java test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2592 |
| **State** | OPEN |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2025-07-10 23:02:28.000 UTC (6 months ago) |
| **Updated** | 2025-07-10 23:06:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Repro

First locate the test referenced below and remove the skipping.

```
cd sdk-python
uv sync
uv run poe build-develop
uv run pytest -E time-skipping -s 'tests/nexus/test_workflow_caller.py::test_workflow_run_operation_happy_path'
```

```
tests/nexus/test_workflow_caller.py 2025-07-10T22:52:12.848145Z  WARN temporal_client::retry: gRPC call respond_workflow_task_completed retried 5 times error=Status { code: Internal, message: "Generated message class \"io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest\" missing method \"getNamespace\".", metadata: MetadataMap { headers: {"content-type": "application/grpc"} }, source: None }
2025-07-10T22:52:13.744468Z  WARN temporal_client::retry: gRPC call respond_workflow_task_completed retried 6 times error=Status { code: Internal, message: "Generated message class \"io.temporal.api.workflowservice.v1.StartWorkflowExecutionRequest\" missing method \"getNamespace\".", metadata: MetadataMap { headers: {"content-type": "application/grpc"} }, source: None }
```

These warnings do not occur under the real server; the test eventually times out.


---

<a id="2590"></a>

### #2590: When parsing operation token, treat `null` as zero

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2590 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-07-10 18:13:09.000 UTC (6 months ago) |
| **Updated** | 2025-07-15 01:14:03.000 UTC |
| **Closed** | 2025-07-15 01:14:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When parsing operation token, treat `null` as zero


---

<a id="2588"></a>

### #2588: Use operation token for the OPERATION_TOKEN header value

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2588 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-07-10 17:48:19.000 UTC (6 months ago) |
| **Updated** | 2025-07-10 21:15:47.000 UTC |
| **Closed** | 2025-07-10 21:15:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Use operation token for the OPERATION_TOKEN header value, currently we use the workflow ID which is not correct.


---

<a id="2586"></a>

### #2586: Time skipping server drops headers in workflow signal

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2586 |
| **State** | OPEN |
| **Author** | tconley1428 |
| **Created** | 2025-07-08 17:36:26.000 UTC (6 months ago) |
| **Updated** | 2025-09-25 23:16:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Headers set in client interceptor appear in inbound workflow interceptor

## Actual Behavior
Headers are blank

## Steps to Reproduce the Problem
Using python sdk:
```
class HeaderWorkerInterceptor(temporalio.worker.Interceptor):
    def workflow_interceptor_class(
        self, input: temporalio.worker.WorkflowInterceptorClassInput
    ) -> Optional[Type[temporalio.worker.WorkflowInboundInterceptor]]:
        return HeaderWorkflowInboundInterceptor


class HeaderWorkflowInboundInterceptor(temporalio.worker.WorkflowInboundInterceptor):
    def init(self, outbound: temporalio.worker.WorkflowOutboundInterceptor) -> None:
        super().init(HeaderWorkflowOutboundInterceptor(outbound))

    async def handle_signal(self, input: HandleSignalInput) -> None:
        assert input.headers["foo"].data == b"bar"
        await super().handle_signal(input)


class HeaderWorkflowOutboundInterceptor(temporalio.worker.WorkflowOutboundInterceptor):
    def start_activity(
        self, input: temporalio.worker.StartActivityInput
    ) -> workflow.ActivityHandle:
        # Add a header to the outbound activity call
        input.headers = {"foo": Payload(data=b"bar")}
        return super().start_activity(input)


class HeaderClientInterceptor(temporalio.client.Interceptor):
    def __init__(self, header: Payload):
        self.header = header
        super().__init__()

    def intercept_client(
        self, next: temporalio.client.OutboundInterceptor
    ) -> temporalio.client.OutboundInterceptor:
        return HeaderClientOutboundInterceptor(
            super().intercept_client(next), self.header
        )


class HeaderClientOutboundInterceptor(temporalio.client.OutboundInterceptor):
    def __init__(
        self, next: temporalio.client.OutboundInterceptor, header: Payload
    ) -> None:
        self.header = header
        super().__init__(next)

    async def signal_workflow(self, input: SignalWorkflowInput) -> None:
        input.headers = {"foo": self.header.__deepcopy__()}
        return await super().signal_workflow(input)



@pytest.mark.parametrize(
    "header_codec_behavior",
    [
        HeaderCodecBehavior.NO_CODEC,
        HeaderCodecBehavior.CODEC,
        HeaderCodecBehavior.WORKFLOW_ONLY_CODEC,
    ],
)
async def test_workflow_headers_with_codec(
    client: Client, env: WorkflowEnvironment, header_codec_behavior: HeaderCodecBehavior
):
    header_payload = Payload(data=b"bar")
    if header_codec_behavior == HeaderCodecBehavior.WORKFLOW_ONLY_CODEC:
        header_payload = (await SimpleCodec().encode([header_payload]))[0]

    # Make client with this codec and run a couple of existing tests
    config = client.config()
    config["data_converter"] = DataConverter(payload_codec=SimpleCodec())
    config["interceptors"] = [HeaderClientInterceptor(header_payload)]
    config["header_codec_behavior"] = header_codec_behavior
    client = Client(**config)

    global global_header_codec_behavior
    global_header_codec_behavior = header_codec_behavior

    async with new_worker(
        client,
        SimpleActivityWorkflow,
        SignalAndQueryWorkflow,
        activities=[say_hello],
        interceptors=[HeaderWorkerInterceptor()],
    ) as worker:
        handle = await client.start_workflow(
            SignalAndQueryWorkflow.run,
            id=f"workflow-{uuid.uuid4()}",
            task_queue=worker.task_queue,
        )

        # Simple signals and queries
        await handle.signal(SignalAndQueryWorkflow.signal1, "some arg")
        assert "signal1: some arg" == await handle.query(
            SignalAndQueryWorkflow.last_event
        )

        async for e in handle.fetch_history_events():
            if e.HasField("workflow_execution_signaled_event_attributes"):
                header = e.workflow_execution_signaled_event_attributes.header.fields[
                    "foo"
                ]
                if header_codec_behavior == HeaderCodecBehavior.CODEC:
                    assert "simple-codec" in header.metadata

```
poe test -k "test_workflow_headers_with_codec" --workflow-environment time-skipping

## Specifications

  - Version:
  - Platform:



---

<a id="2582"></a>

### #2582: Null cause in Nexus HandlerException is not handled correctly

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2582 |
| **State** | OPEN |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2025-07-05 22:53:44.000 UTC (6 months ago) |
| **Updated** | 2025-07-06 13:40:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

In a Nexus operation, `HandlerException` has a constructor
```java
  public HandlerException(ErrorType errorType, @Nullable Throwable cause)
```
inviting operation authors to throw a `HandlerException` with no cause, such as

```java
throw new HandlerException(HandlerException.ErrorType.NOT_FOUND, (Throwable) null);
```

But this crashes at https://github.com/temporalio/sdk-java/blob/f919926a2d67c10c34fee4b19eed1c605d4223a4/temporal-sdk/src/main/java/io/temporal/common/converter/PayloadAndFailureDataConverter.java#L136-L145



---

<a id="2562"></a>

### #2562: Environment configuration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2562 |
| **State** | CLOSED |
| **Author** | THardy98 (Thomas Hardy) |
| **Created** | 2025-06-17 19:56:09.000 UTC (6 months ago) |
| **Updated** | 2025-09-24 21:50:34.000 UTC |
| **Closed** | 2025-09-24 21:50:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/441 and https://github.com/temporalio/proposals/blob/master/all-sdk/external-client-configuration.md


---

<a id="2559"></a>

### #2559: [java] Add `WorkflowTaskFailedCause` to `RespondQueryTaskCompletedRequest`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2559 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-06-13 21:27:44.000 UTC (6 months ago) |
| **Updated** | 2025-08-01 23:04:39.000 UTC |
| **Closed** | 2025-08-01 23:04:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Should work the same as for workflow task failures


---

<a id="2552"></a>

### #2552: Add poller autoscaling options for Spring

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2552 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-06-12 01:21:10.000 UTC (7 months ago) |
| **Updated** | 2025-06-12 19:15:32.000 UTC |
| **Closed** | 2025-06-12 19:15:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add poller autoscaling options for Spring




---

<a id="2550"></a>

### #2550: deploymentOptions should be set on all poll requests, not just workflow polls

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2550 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-06-10 19:35:23.000 UTC (7 months ago) |
| **Updated** | 2025-06-12 22:35:09.000 UTC |
| **Closed** | 2025-06-12 22:35:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Looks like currently we only set the deployment options (new versioning) info on workflow polls, but it ought to apply to all kinds of poll requests.

## Actual Behavior
Only workflow polls get them

## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:



---

<a id="2538"></a>

### #2538: [Feature Request]  Add counter metric for unaccessed failed promises

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2538 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2025-05-27 20:38:43.000 UTC (7 months ago) |
| **Updated** | 2025-05-27 20:50:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/sync/DeterministicRunnerImpl.java#L336-L347

Would be useful to have a counter metric for this. Would allow detection so can fix in code if was oversight not to wait on promise,or ignore warning via something like

promise.exceptionally(e->null);
or promise.handle((ex, failure) -> null);



---

<a id="2533"></a>

### #2533: NonRootNamespaceAutoConfiguration#nonRootBeanPostProcessor breaks MeterRegistry customizations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2533 |
| **State** | CLOSED |
| **Author** | rpost (Radek Posto≈Çowicz) |
| **Created** | 2025-05-21 16:01:05.000 UTC (7 months ago) |
| **Updated** | 2025-06-17 16:32:16.000 UTC |
| **Closed** | 2025-06-17 16:32:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Exposed metrics are filtered according to defined `MeterRegistryCustomizer`.

## Actual Behavior

`io.temporal.spring.boot.autoconfigure.NonRootNamespaceAutoConfiguration#nonRootBeanPostProcessor` causes early initialization of `MeterRegistry` (through `io.temporal.spring.boot.autoconfigure.MetricsScopeAutoConfiguration#scope`), even before `org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryPostProcessor` is ready. This makes 
any `MeterRegistryCustomizer` effectively ignored.

## Steps to Reproduce the Problem

I prepared small reproducer project: https://github.com/rpost/temporal-bug:

  1. https://github.com/rpost/temporal-bug/commit/d97d7356790da88d530c801a722905d3d8b86736 introduces setup and adds test which proves metrics being filtered accordingly.
  1. https://github.com/rpost/temporal-bug/commit/0a77f4aac841486e78ba8604c10047bb5433f5d1 adds temporal client and this makes test broken
  1.  https://github.com/rpost/temporal-bug/commit/d16476e4ec796bb338efcade55d6469e9870842e contains workaround




---

<a id="2523"></a>

### #2523: Expose StartWorkflowExecutionResponse fields to ExecuteWorkflow API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2523 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-05-14 14:08:04.000 UTC (8 months ago) |
| **Updated** | 2025-06-09 14:34:42.000 UTC |
| **Closed** | 2025-06-09 14:34:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

see https://github.com/temporalio/features/issues/619



---

<a id="2521"></a>

### #2521: Workflow instance should be accessible in test environment for simple assertion

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2521 |
| **State** | OPEN |
| **Author** | madhav2302 (Madhav Sodhani) |
| **Created** | 2025-05-13 20:54:07.000 UTC (8 months ago) |
| **Updated** | 2025-05-13 20:54:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to write unit tests on workflow code, and would like to access workflow for assertions in test env. 

eg. 
```
class WorkflowImpl implements Workflow {
    public String value = "something";

//// more workflow code
}
```

and the value is updated in the workflow code. I would like to add access the values. 

Currently there is no easy way to access the workflow object, as we simply register workflow class as type

**Describe the solution you'd like**
I would like to access the workflow object at any point in time for test env, and it should provide me an object of workflow with latest state of workflow.

Like

```
var workflowImpl = (WorkflowImpl) testWorkflowClient.getWorkflowObject("workflowId", "workflowRunId");
assertThat(workflowImpl.value, is("some-assertion-value"));
```

**Describe alternatives you've considered**
The other method we have considered is to add a QueryMethod in the workflow but we don't want to add QueryMethod in production code at all. 

We can surely do it for tests as well as mentioned at https://temporalio.slack.com/archives/CTT84KXK9/p1747167261307199?thread_ts=1747086843.705119&cid=CTT84KXK9, but it can cause issues when you have multiple variables, and adding QueryMethod for each a lot, and managing QueryMethod for testing can be cumbersome. 

**Additional context**
Discussed this previously at Github - https://temporalio.slack.com/archives/CTT84KXK9/p1747086843705119



---

<a id="2502"></a>

### #2502: Remove license headers from files

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2502 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-05-02 16:08:53.000 UTC (8 months ago) |
| **Updated** | 2025-05-02 21:41:27.000 UTC |
| **Closed** | 2025-05-02 21:41:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Following server in https://github.com/temporalio/temporal/pull/7689, license headers are no longer required on files. Remove from all files in the SDK and remove any tooling that generates them or requires them.


---

<a id="2494"></a>

### #2494: Test server not showing user metadata for workflow start in history

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2494 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-29 16:38:49.000 UTC (8 months ago) |
| **Updated** | 2025-05-01 04:45:14.000 UTC |
| **Closed** | 2025-05-01 04:45:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Workflow start with summary/details on test server should show this in user metadata of `EVENT_TYPE_WORKFLOW_EXECUTION_STARTED` event but it is not.

## Actual Behavior

User metadata not visible. Testing on latest release of Java SDK which should have #2441. May need to also check that child workflow propagates the metadata too.

First noticed in https://github.com/temporalio/sdk-python/issues/851


---

<a id="2493"></a>

### #2493: NP–ï in ScheduleDescription.getMemo (should check `memoPayload == null`, not `memo`)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2493 |
| **State** | CLOSED |
| **Author** | fmaylinch (Ferran Maylinch) |
| **Created** | 2025-04-29 09:24:32.000 UTC (8 months ago) |
| **Updated** | 2025-05-01 02:50:10.000 UTC |
| **Closed** | 2025-05-01 02:50:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Looks like line 116 should be `if (memoPayload == null) {`.

https://github.com/temporalio/sdk-java/blob/7460156411566d9a1ade1010b9b20ae44540647d/temporal-sdk/src/main/java/io/temporal/client/schedules/ScheduleDescription.java#L113-L120


---

<a id="2488"></a>

### #2488: [java] SDK support for activity reset

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2488 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2025-04-23 19:08:11.000 UTC (8 months ago) |
| **Updated** | 2025-07-09 06:26:02.000 UTC |
| **Closed** | 2025-07-09 06:26:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/620


---

<a id="2481"></a>

### #2481: Show retry policy on activity info

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2481 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-04-17 12:23:45.000 UTC (8 months ago) |
| **Updated** | 2025-08-13 22:00:54.000 UTC |
| **Closed** | 2025-08-13 22:00:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/615


---

<a id="2480"></a>

### #2480: Memo-s not present in listOpenWorkflowExecutions when running with temporal-testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2480 |
| **State** | OPEN |
| **Author** | rpost (Radek Posto≈Çowicz) |
| **Created** | 2025-04-17 08:16:27.000 UTC (8 months ago) |
| **Updated** | 2025-05-26 14:45:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

I'm using temporal-testing and when I query running workflows:

```java
        List<WorkflowExecutionInfo> executions = client.getWorkflowServiceStubs()
                .blockingStub()
                .listOpenWorkflowExecutions(
                        ListOpenWorkflowExecutionsRequest.newBuilder()
                                .setNamespace("default")
                                .build()
                )
                .getExecutionsList();

        executions.forEach(execution -> {
            System.err.println(execution.getExecution().getWorkflowId());
            System.err.println(execution.getMemo());
        });
```

memo is empty despite being filled in workflow.

## Actual Behavior

The same piece of code run with `setUseExternalService(true)` and `temporal server start-dev` running outputs memo-s as expected. 

## Steps to Reproduce the Problem

I prepared reproducer project: https://github.com/rpost/temporal-test-memo/blob/main/src/test/java/rpost/MemoTest.java

## Specifications

  - Version: io.temporal:temporal-testing:1.28.4



---

<a id="2475"></a>

### #2475: Apply application failure logging and metrics behaviour according to `ApplicationErrorCategory`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2475 |
| **State** | CLOSED |
| **Author** | THardy98 (Thomas Hardy) |
| **Created** | 2025-04-09 18:34:11.000 UTC (9 months ago) |
| **Updated** | 2025-04-25 23:53:08.000 UTC |
| **Closed** | 2025-04-25 23:53:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See corresponding features issue:
https://github.com/temporalio/features/issues/614


---

<a id="2469"></a>

### #2469: [Java] Worker Versioning high level client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2469 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-04-02 21:08:14.000 UTC (9 months ago) |
| **Updated** | 2025-04-02 21:16:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Create the high-level client for control plane operations concerning worker deployments, as a follow-up to https://github.com/temporalio/sdk-java/issues/2458


---

<a id="2465"></a>

### #2465: Heartbeating activities should be interrupted when the activities are paused.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2465 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2025-04-01 23:43:11.000 UTC (9 months ago) |
| **Updated** | 2025-04-15 19:18:27.000 UTC |
| **Closed** | 2025-04-15 19:18:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/602


---

<a id="2459"></a>

### #2459: Test server can overwrite last heartbeat details when not on fail request

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2459 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-03-26 15:34:24.000 UTC (9 months ago) |
| **Updated** | 2025-03-26 17:04:56.000 UTC |
| **Closed** | 2025-03-26 17:04:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Test server should not overwrite last heartbeat details on activity failure unless it is actually set

## Actual Behavior

As of #2354, the last heartbeat details are always overridden regardless of whether set which, while that's ok for Java, is not for Core-based SDKs (at least until https://github.com/temporalio/sdk-core/issues/293 is done)


---

<a id="2458"></a>

### #2458: Support New Worker Versioning API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2458 |
| **State** | CLOSED |
| **Author** | antlai-temporal (Antonio Lain) |
| **Created** | 2025-03-24 18:04:07.000 UTC (9 months ago) |
| **Updated** | 2025-04-02 23:27:29.000 UTC |
| **Closed** | 2025-04-02 23:27:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

We need to add annotations to workflows to support the new versioning APIs. Refer to temporalio/features#548 for the Go equivalents.

**Describe the solution you'd like**

There are some designs for all languages including Java here: https://docs.google.com/document/d/1QGacjnlFwrfFtAvv9besx6sEdr36kJ3zQ9J7bGLRwk4/edit?usp=sharing




---

<a id="2450"></a>

### #2450: GenericWorkflowClient can prevent exit of JVM

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2450 |
| **State** | CLOSED |
| **Author** | lverns (Laverne Schrock) |
| **Created** | 2025-03-18 21:29:00.000 UTC (9 months ago) |
| **Updated** | 2025-05-16 15:36:33.000 UTC |
| **Closed** | 2025-05-16 15:36:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

` io.temporal.internal.client.external.GenericWorkflowClient` should allow all resources to be reclaimed and not block natural termination of the JVM.

The Reproduction steps should finish with the `java` process exiting.

## Actual Behavior

Once the `asyncThrottlerExecutor` in that class has started a thread, there is no mechanism to terminate it, and the JVM will not exit unless `System.exit()` is manually called.

The `java` call does not exit.

## Steps to Reproduce the Problem

  1. Checkout the https://github.com/temporalio/money-transfer-project-java repo from the [Getting Started tutorial ](https://learn.temporal.io/getting_started/java/first_program_in_java/).
  1. Add this commit on top: https://github.com/lverns/money-transfer-project-java/commit/2492e11338b1b6a3ac2c45f1bae113422bc2dd89
  1. Generate a classpath: ` mvn dependency:build-classpath -Dmdep.outputFile=cp.txt`
  2. Compile `mvn compile`
  3. Run the worker:`mvn  exec:java  -Dexec.mainClass="moneytransferapp.MoneyTransferWorker"     -Dorg.slf4j.simpleLogger.defaultLogLevel=warn`
  4. In another terminal run the app: `java -cp $(cat cp.txt):target/classes moneytransferapp.TransferApp`
  5. Observe that the app prints "Got Transfer complete", but the JVM remains running.
  6. If you inspect the process with `jstack` you will see a non-daemon thread called `generic-wf-client-async-throttler` that is preventing the JVM from exiting.

## Specifications

  - Version: 1.24.1
  - Platform: Linux 
  - Java Version: OpenJDK Runtime Environment (Red_Hat-21.0.6.0.7-1) (build 21.0.6+7)

## Other notes
This seems to be a known issue based on a [comment in the code](https://github.com/temporalio/sdk-java/blob/6b05cd82de3aa76220a4ad3f9567f0ab0e657e48/temporal-sdk/src/main/java/io/temporal/internal/client/external/GenericWorkflowClientImpl.java#L42), but opening this bug for visibility.

An easy work around is to call `System.exit(0)`, but it seems possible that there are scenarios where a program might want to rely on the JVM's exit semantics.


---

<a id="2442"></a>

### #2442: Add summary to Nexus operation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2442 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-03-11 18:37:54.000 UTC (10 months ago) |
| **Updated** | 2025-03-17 15:29:09.000 UTC |
| **Closed** | 2025-03-17 15:29:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/610


---

<a id="2432"></a>

### #2432: Expose static summary/details on workflow execution description

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2432 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-27 13:39:58.000 UTC (10 months ago) |
| **Updated** | 2025-03-11 19:37:57.000 UTC |
| **Closed** | 2025-03-11 19:37:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

As part of user metadata, we should have `getStaticSummary()` and `getStaticDetails()` on the result of `describe` which is `WorkflowExecutionDescription`. Note these are not in the base class `WorkflowExecutionMetadata` which also comes back from `listExecutions` because it's not in visibility.


---

<a id="2430"></a>

### #2430: Expose root workflow execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2430 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-25 14:15:21.000 UTC (10 months ago) |
| **Updated** | 2025-03-11 19:38:03.000 UTC |
| **Closed** | 2025-03-11 19:38:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/605



---

<a id="2426"></a>

### #2426: Built-in query responses should use "RawValue"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2426 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-21 20:32:13.000 UTC (10 months ago) |
| **Updated** | 2025-06-11 05:46:34.000 UTC |
| **Closed** | 2025-06-11 05:46:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/604. When #2425 is done, make sure built-in queries return a raw value



---

<a id="2425"></a>

### #2425: Support "RawValue" non-converted values

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2425 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-21 20:26:36.000 UTC (10 months ago) |
| **Updated** | 2025-04-29 16:50:37.000 UTC |
| **Closed** | 2025-04-29 16:50:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/603, need a simple payload wrapper that tells converters not to apply conversion.


---

<a id="2402"></a>

### #2402: Support musl-based build of test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2402 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-02-05 22:39:25.000 UTC (11 months ago) |
| **Updated** | 2025-06-11 23:12:16.000 UTC |
| **Closed** | 2025-06-11 23:12:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/594.

Upon Java SDK release, support a musl-based test server binary in the assets with an obvious name that can be used by `temporal.download`.


---

<a id="2399"></a>

### #2399: Support Priority Annotations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2399 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2025-02-03 18:19:24.000 UTC (11 months ago) |
| **Updated** | 2025-03-26 06:56:46.000 UTC |
| **Closed** | 2025-03-26 06:56:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add support for attaching priority to workflows/activities

**Describe the solution you'd like**
See https://github.com/temporalio/features/issues/593 for details



---

<a id="2393"></a>

### #2393: Add `patched()` and `deprecatePatch()` APIs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2393 |
| **State** | OPEN |
| **Author** | mjameswh (James Watkins-Harvey) |
| **Created** | 2025-01-29 23:38:05.000 UTC (11 months ago) |
| **Updated** | 2025-01-29 23:38:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

### Describe the solution you'd like

In short:

- Add the `boolean Workflow.patched(String patchId, boolean memoized)` and `Workflow.deprecatePatch(String patchId, boolean memoized)` APIs. Refer to Core's implementation (once it is ready).

- (Maybe) Deprecate the `GetVersion` API.

See temporalio/features#591 for details.


---

<a id="2368"></a>

### #2368: Special behavior for Temporal built-in prefixes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2368 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-01-15 13:12:33.000 UTC (11 months ago) |
| **Updated** | 2025-02-12 16:16:28.000 UTC |
| **Closed** | 2025-02-12 16:16:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/576



---

<a id="2367"></a>

### #2367: Removing a `Workflow.getVersion` with a succeeding `Workflow.sideEffect` causes NDE

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2367 |
| **State** | CLOSED |
| **Author** | taonic (Tao Guo) |
| **Created** | 2025-01-15 07:58:02.000 UTC (11 months ago) |
| **Updated** | 2025-01-16 23:28:14.000 UTC |
| **Closed** | 2025-01-16 23:28:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Having `Workflow.sideEffect` following a `Workflow.getVersion` should not cause a NDE when the getVersion is removed.

## Actual Behavior
Removing `getVersion` leads to NDE when there is a succeeding `Workflow.sideEffect`.

## Steps to Reproduce the Problem
```java
public class GetVersionRemovalTest {
  private static boolean hasReplayed;

  @Rule
  public SDKTestWorkflowRule testWorkflowRule =
      SDKTestWorkflowRule.newBuilder()
          .setWorkflowTypes(TestGetVersionRemovalWorkflowImpl.class)
          .setActivityImplementations(new TestActivitiesImpl())
          // Forcing a replay. Full history arrived from a normal queue causing a replay.
          .setWorkerOptions(
              WorkerOptions.newBuilder()
                  .setStickyQueueScheduleToStartTimeout(Duration.ZERO)
                  .build())
          .build();

  @Test
  public void testGetVersionMultithreadingRemoval() {
    TestWorkflow1 workflowStub =
        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflow1.class);
    String result = workflowStub.execute(testWorkflowRule.getTaskQueue());
    assertTrue(hasReplayed);
    assertEquals("activity1", result);
  }

  public static class TestGetVersionRemovalWorkflowImpl implements TestWorkflow1 {
    @Override
    public String execute(String taskQueue) {
      VariousTestActivities testActivities =
          Workflow.newActivityStub(
              VariousTestActivities.class,
              SDKTestOptions.newActivityOptionsForTaskQueue(taskQueue));

      // Test removing a version check in replaying code with an additional thread running.
      if (!WorkflowUnsafe.isReplaying()) {
        int version = Workflow.getVersion("changeId", 1, 2);
        assertEquals(version, 2);
      } else {
        hasReplayed = true;
      }

      // This sideEffect following a getVersion causes NDE after the getVersion is removed
      Workflow.sideEffect(String.class, () -> System.getenv("USER"));

      String result =
          "activity" + testActivities.activity1(1); // This is executed in non-replay mode.
      return result;
    }
  }
}
```

Output:
```
...
Caused by: java.lang.IllegalStateException: Expected SideEffect, received: marker_name: "Version"
details {
  key: "changeId"
  value {
    payloads {
      metadata {
        key: "encoding"
        value: "json/plain"
      }
      data: "\"changeId\""
    }
  }
}
details {
  key: "version"
  value {
    payloads {
      metadata {
        key: "encoding"
        value: "json/plain"
      }
      data: "2"
    }
  }
}
workflow_task_completed_event_id: 3

	at io.temporal.internal.statemachines.SideEffectStateMachine.markerResultFromEvent(SideEffectStateMachine.java:155)
	at io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:46)
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:159)
```

## Specifications

  - Version: tested in 1.27.0



---

<a id="2362"></a>

### #2362: Provide client from activity context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2362 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-01-07 14:30:51.000 UTC (1 years ago) |
| **Updated** | 2025-01-15 17:34:59.000 UTC |
| **Closed** | 2025-01-15 17:34:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Allow users to access Temporal client from within an activity. This is likely a `getWorkflowClient() WorkflowClient` instance method on `ActivityExecutionContext`. See https://github.com/temporalio/features/issues/203.


---

<a id="2361"></a>

### #2361: Access to workflow/activity instance from context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2361 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2025-01-07 13:42:42.000 UTC (1 years ago) |
| **Updated** | 2025-01-22 18:14:04.000 UTC |
| **Closed** | 2025-01-22 18:14:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Provide access to the Temporal created/owned workflow and activity instance from their respective contexts. This means adding something like `ActivityExecutionContext.getInstance()` instance method and `Workflow.getInstance()` static method. See https://github.com/temporalio/features/issues/572.


---

<a id="2359"></a>

### #2359: Clarify `UnableToAcquireLockException`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2359 |
| **State** | OPEN |
| **Author** | GSmithApps (Grant) |
| **Created** | 2025-01-07 10:51:25.000 UTC (1 years ago) |
| **Updated** | 2025-01-07 10:59:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
[This Slack thread](https://temporalio.slack.com/archives/C05JRT1GKEE/p1735812460229109?thread_ts=1735802152.698209&cid=C05JRT1GKEE): a user had a question about this Exception, and they asked Kapa, and Kapa gave a wrong answer (which Tiho corrected üôè ). I suspect Kapa could have given better direction if this exception message contained the info that Tiho corrected with.

**Describe the solution you'd like**
I ported Tiho's response over to the code and submitted a [PR](https://github.com/temporalio/sdk-java/pull/2360)

**Describe alternatives you've considered**
I recognize that the message I'm putting here is less general than the one that was there previously. If any of it is incorrect in more general scenarios, please correct me üëç üëç 

**Additional context**
None



---

<a id="2358"></a>

### #2358: Nexus error rehydration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2358 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2025-01-06 21:53:52.000 UTC (1 years ago) |
| **Updated** | 2025-02-28 03:17:14.000 UTC |
| **Closed** | 2025-02-28 03:17:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add support for Nexus Error rehydration.

See: https://github.com/temporalio/sdk-go/pull/1751


---

<a id="2349"></a>

### #2349: Failure to allocate thread can lock up local activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2349 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2024-12-17 18:50:05.000 UTC (1 years ago) |
| **Updated** | 2025-01-17 22:58:59.000 UTC |
| **Closed** | 2025-01-17 22:58:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Local activities should be kept in the queue if a thread can't be allocated to run them

## Actual Behavior
Silent lock up

## Steps to Reproduce the Problem
1. When a local activity task was taken off the LocalActivitySlotSupplierQueue in #processQueue [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L79-L102), it was passed to the afterReservedCallback [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L97)
2. This callback is set up [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivityWorker.java#L94-L96) in LocalActivityWorker, where it forwards each task to the PollTaskExecutor#process method [defined here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/PollTaskExecutor.java#L98-L118)
3. That method calls ThreadPoolExecutor#execute [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/PollTaskExecutor.java#L101), which [may spin up a new thread](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html#execute-java.lang.Runnable-)
4. The creation up of that thread failed (see [0]), which thankfully our JVM deployment seems to always log (since I don't believe this comes from the Temporal SDK)
We suspect that this is due to the process running out of memory used for allocating thread stacks
5. That call to ThreadPoolExecutor#execute raises a java.lang.OutOfMemoryError, which unwinds back up the call stack and ends up back in #processQueue. The line where the callback is applied is only guarded by a catch block for InterruptedException, so the exception unwinds out of the #processQueue call, which is the "root" runnable of the thread inside the queueThreadService started [here ](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L106C10-L106C28)(where the thread "service" is a single-thread threadpool, initialized [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L75-L76))
6. No uncaught exception handler is installed on the queueThreadService, and no log is emitted from any SDK code when this happens. Instead, the local activity task queue stops processing any tasks that go into it, and the overall local activity worker machinery deadlocks. The activity and workflow workers remain functional and keep processing work. The process continues in this half-deadlocked state, without crashing early (which we'd strongly prefer over the current behavior).

[0] except a single pair of log lines:
```
[warning][os,thread      ] Failed to start thread "Unknown thread" - pthread_create failed (EAGAIN) for attributes: stacksize: 2040k, guardsize: 0k, detached.
[warning][os,thread      ] Failed to start the native thread for java.lang.Thread "Local Activity Executor taskQueue="...", namespace="...": ..."
```




---

<a id="2333"></a>

### #2333: `taskTimeoutWillRescheduleTheTaskOnTheGlobalList ` on the test server is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2333 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-11-28 17:28:47.000 UTC (1y 1m ago) |
| **Updated** | 2025-05-16 22:41:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`taskTimeoutWillRescheduleTheTaskOnTheGlobalList ` should always pass on the test server

## Actual Behavior
`taskTimeoutWillRescheduleTheTaskOnTheGlobalList ` doesn't always pass on the test server



---

<a id="2331"></a>

### #2331: [Bug] CI build will soon get broken due to GHA dropping support for node16-based actions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2331 |
| **State** | CLOSED |
| **Author** | mjameswh (James Watkins-Harvey) |
| **Created** | 2024-11-26 23:11:34.000 UTC (1y 1m ago) |
| **Updated** | 2024-12-02 05:20:17.000 UTC |
| **Closed** | 2024-12-02 05:20:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

### Describe the bug

GitHub Action‚Äôs just started enforcing the long-announced EOL on Node16-based actions. Basically, the latest release of GHA‚Äôs Runner agent ignores the fact that an action is requesting node16, and instead just calls node20 anyway. 

Until now, we were relying on an older GLIBC 2.27-based runner to ensure that the native artifacts of the Test Server would run on some older Linux distros that some of our customers were still using.

However, given that Node20 is incompatible with GLIBC 2.27 or earlier, this should no longer work. We may get some extra time to resolve this issue, as it is believed that the buildjet runner image we currently use may not be immediately updated to the newer GHA runner software, but it is expected that our release workflows may start failing in the very near future.



---

<a id="2328"></a>

### #2328: Add an interceptor for listExecutions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2328 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-11-25 23:56:35.000 UTC (1y 1m ago) |
| **Updated** | 2025-06-03 14:00:58.000 UTC |
| **Closed** | 2025-06-03 14:00:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add an interceptor for `WorkflowClient.listExecutions`. We should also expose the constructor of `WorkflowExecutionMetadata`

**Additional context**
https://github.com/temporalio/sdk-java/pull/2326#discussion_r1854044466


---

<a id="2317"></a>

### #2317: Do runtime check to ensure update validator has the same parameter signature as update it validates

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2317 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-11-14 05:51:24.000 UTC (1y 1m ago) |
| **Updated** | 2024-11-22 16:19:19.000 UTC |
| **Closed** | 2024-11-22 16:19:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We need to make sure at runtime the parameter portion of the signature of the validator matches the parameter portion of the signature of the update method it is validating.

**Additional context**
https://github.com/temporalio/sdk-python/issues/689


---

<a id="2314"></a>

### #2314: Clear MDC context after each Task

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2314 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-11-12 17:51:08.000 UTC (1y 1m ago) |
| **Updated** | 2025-06-04 18:17:28.000 UTC |
| **Closed** | 2025-06-04 18:17:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Users may set MDC context during activity or nexus task execution and not unset them after the activity code completes. Users may not clear them because they wanted them to be applied to SDK loggers or they just forgot. Since the SDK may use thread pools to execute tasks this risks leaking context between unrelated tasks.

**Describe the solution you'd like**
Automatically clear MDC context after each Task




---

<a id="2307"></a>

### #2307: Removing a `Workflow.GetVersion` call can cause NDE if there are multiple parallel workflow threads running.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2307 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-11-04 23:06:39.000 UTC (1y 2m ago) |
| **Updated** | 2024-11-05 03:06:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Removing a `Workflow.GetVersion` call should never cause a NDE

## Actual Behavior
Removing a `Workflow.GetVersion` call can cause a NDE if there are multiple workflow threads running.


## Steps to Reproduce the Problem

```
public class GetVersionMultithreadingRemoveTest {

  private static boolean hasReplayed;

  @Rule
  public SDKTestWorkflowRule testWorkflowRule =
      SDKTestWorkflowRule.newBuilder()
          .setWorkflowTypes(TestGetVersionWorkflowImpl.class)
          .setActivityImplementations(new TestActivitiesImpl())
          // Forcing a replay. Full history arrived from a normal queue causing a replay.
          .setWorkerOptions(
              WorkerOptions.newBuilder()
                  .setStickyQueueScheduleToStartTimeout(Duration.ZERO)
                  .build())
          .build();

  @Test
  public void testGetVersionMultithreadingRemoval() {
    TestWorkflow1 workflowStub =
        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflow1.class);
    String result = workflowStub.execute(testWorkflowRule.getTaskQueue());
    assertTrue(hasReplayed);
    assertEquals("activity1", result);
  }

  public static class TestGetVersionWorkflowImpl implements TestWorkflow1 {

    @Override
    public String execute(String taskQueue) {
      VariousTestActivities testActivities =
          Workflow.newActivityStub(
              VariousTestActivities.class,
              SDKTestOptions.newActivityOptionsForTaskQueue(taskQueue));

      Async.procedure(
          () -> {
            Workflow.sleep(1000);
          });

      // Test removing a version check in replaying code with an additional thread running.
      if (!WorkflowUnsafe.isReplaying()) {
        int version = Workflow.getVersion("changeId", 1, 2);
        assertEquals(version, 2);
      } else {
        hasReplayed = true;
      }
      String result =
          "activity" + testActivities.activity1(1); // This is executed in non-replay mode.
      return result;
    }
  }
}
```

This happens because ` Workflow.getVersion` causes the current thread to block so when it is removed the order of execution can change.

## Specifications

  - Version: All
  
  The current workaround is to not remove the `Workflow.getVersion` call



---

<a id="2299"></a>

### #2299: Springboot workflow implementation with non default constructors fail in 1.26.0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2299 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-10-28 20:53:02.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-29 18:39:43.000 UTC |
| **Closed** | 2024-10-29 18:39:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior 
Workflow implementation with non default constructors succeeds as Spring can autowires the parameters 

## Actual Behavior
Workflow implementation with non default constructors fail
```
java.lang.IllegalArgumentException: No default constructor or constructor annotated with @WorkflowInit found: 
```

## Steps to Reproduce the Problem

Have a workflow implementation with a constructor with parameters that can be auto wired and no default constructor 

## Specifications

  - Version: 1.26.0



---

<a id="2289"></a>

### #2289: Allow for API key authentication instead of mTLS in Spring Boot Autoconfigure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2289 |
| **State** | CLOSED |
| **Author** | chriso153 (Chris Oman) |
| **Created** | 2024-10-22 18:17:32.000 UTC (1y 2m ago) |
| **Updated** | 2025-02-11 17:08:56.000 UTC |
| **Closed** | 2025-02-11 17:08:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We are using API keys to connect to Temporal Cloud. There is no way to do this with configuration options. Instead, we have to write a customizer.

**Describe the solution you'd like**
Add another configuration option for API key and automatically configure the service stubs to use API key authentication.

**Describe alternatives you've considered**
Keep writing a customizer




---

<a id="2285"></a>

### #2285: Workflow update with start does not pass Workflow arguments 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2285 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-10-22 00:17:33.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-22 15:45:25.000 UTC |
| **Closed** | 2024-10-22 15:45:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`WorkflowClient.updateWithStart` passes workflow arguments 

## Actual Behavior
`WorkflowClient.updateWithStart` does not pass workflow arguments 


## Steps to Reproduce the Problem
```java
  @Test
  public void startVariousFuncs() throws ExecutionException, InterruptedException {
    WorkflowClient workflowClient = testWorkflowRule.getWorkflowClient();

    BiFunction<Functions.Func1<Integer, String>, Integer, UpdateWithStartWorkflowOperation<String>>
        newUpdateOp =
            (request, input) ->
                UpdateWithStartWorkflowOperation.newBuilder(request, input)
                    .setWaitForStage(WorkflowUpdateStage.COMPLETED)
                    .build();

    // no arg
    TestMultiArgWorkflowFunctions.TestNoArgsWorkflowFunc stubF =
        workflowClient.newWorkflowStub(
            TestMultiArgWorkflowFunctions.TestNoArgsWorkflowFunc.class, createOptions());
    UpdateWithStartWorkflowOperation<String> updateOp0 = newUpdateOp.apply(stubF::update, 0);
    WorkflowUpdateHandle<String> handle0 = WorkflowClient.updateWithStart(stubF::func, updateOp0);

    // 1 arg
    TestMultiArgWorkflowFunctions.Test1ArgWorkflowFunc stubF1 =
        workflowClient.newWorkflowStub(
            TestMultiArgWorkflowFunctions.Test1ArgWorkflowFunc.class, createOptions());
    UpdateWithStartWorkflowOperation<String> updateOp1 = newUpdateOp.apply(stubF1::update, 1);
    WorkflowUpdateHandle<String> handle1 =
        WorkflowClient.updateWithStart(stubF1::func1, "1", updateOp1);

    // 2 args
    TestMultiArgWorkflowFunctions.Test2ArgWorkflowFunc stubF2 =
        workflowClient.newWorkflowStub(
            TestMultiArgWorkflowFunctions.Test2ArgWorkflowFunc.class, createOptions());
    UpdateWithStartWorkflowOperation<String> updateOp2 = newUpdateOp.apply(stubF2::update, 2);
    WorkflowUpdateHandle<String> handle2 =
        WorkflowClient.updateWithStart(stubF2::func2, "1", 2, updateOp2);

    // 3 args
    TestMultiArgWorkflowFunctions.Test3ArgWorkflowFunc stubF3 =
        workflowClient.newWorkflowStub(
            TestMultiArgWorkflowFunctions.Test3ArgWorkflowFunc.class, createOptions());
    UpdateWithStartWorkflowOperation<String> updateOp3 = newUpdateOp.apply(stubF3::update, 3);
    WorkflowUpdateHandle<String> handle3 =
        WorkflowClient.updateWithStart(stubF3::func3, "1", 2, 3, updateOp3);

    // 4 args
    TestMultiArgWorkflowFunctions.Test4ArgWorkflowFunc stubF4 =
        workflowClient.newWorkflowStub(
            TestMultiArgWorkflowFunctions.Test4ArgWorkflowFunc.class, createOptions());
    UpdateWithStartWorkflowOperation<String> updateOp4 = newUpdateOp.apply(stubF4::update, 4);
    WorkflowUpdateHandle<String> handle4 =
        WorkflowClient.updateWithStart(stubF4::func4, "1", 2, 3, 4, updateOp4);

    // 5 args
    TestMultiArgWorkflowFunctions.Test5ArgWorkflowFunc stubF5 =
        workflowClient.newWorkflowStub(
            TestMultiArgWorkflowFunctions.Test5ArgWorkflowFunc.class, createOptions());
    UpdateWithStartWorkflowOperation<String> updateOp5 = newUpdateOp.apply(stubF5::update, 5);
    WorkflowUpdateHandle<String> handle5 =
        WorkflowClient.updateWithStart(stubF5::func5, "1", 2, 3, 4, 5, updateOp5);

    // 6 args
    TestMultiArgWorkflowFunctions.Test6ArgWorkflowFunc stubF6 =
        workflowClient.newWorkflowStub(
            TestMultiArgWorkflowFunctions.Test6ArgWorkflowFunc.class, createOptions());
    UpdateWithStartWorkflowOperation<String> updateOp6 = newUpdateOp.apply(stubF6::update, 6);
    WorkflowUpdateHandle<String> handle6 =
        WorkflowClient.updateWithStart(stubF6::func6, "1", 2, 3, 4, 5, 6, updateOp6);

    assertEquals("0", handle0.getResultAsync().get());
    assertEquals("func", WorkflowStub.fromTyped(stubF).getResult(String.class));
    assertEquals("1", handle1.getResultAsync().get());
    assertEquals("1", WorkflowStub.fromTyped(stubF1).getResult(String.class));
    assertEquals("2", handle2.getResultAsync().get());
    assertEquals("12", WorkflowStub.fromTyped(stubF2).getResult(String.class));
    assertEquals("3", handle3.getResultAsync().get());
    assertEquals("123", WorkflowStub.fromTyped(stubF3).getResult(String.class));
    assertEquals("4", handle4.getResultAsync().get());
    assertEquals("1234", WorkflowStub.fromTyped(stubF4).getResult(String.class));
    assertEquals("5", handle5.getResultAsync().get());
    assertEquals("12345", WorkflowStub.fromTyped(stubF5).getResult(String.class));
    assertEquals("6", handle6.getResultAsync().get());
    assertEquals("123456", WorkflowStub.fromTyped(stubF6).getResult(String.class));
  }
```

Think the issue is this line https://github.com/temporalio/sdk-java/blob/0ce1d6ec917d421d31176615f59087527b3ca27f/temporal-sdk/src/main/java/io/temporal/client/UpdateWithStartWorkflowOperation.java#L299 were we pass the update args as workflow args.

## Specifications

  - Version: v1.26.0


---

<a id="2284"></a>

### #2284: Workflow update with start cannot use a `UpdateWithStartWorkflowOperation` created from a String update name

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2284 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-10-22 00:14:19.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-22 16:40:12.000 UTC |
| **Closed** | 2024-10-22 16:40:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`WorkflowClient.updateWithStart` can take any valid `UpdateWithStartWorkflowOperation`

## Actual BehaviorUpdateWithStartWorkflowOperation
`WorkflowClient.updateWithStart` can not take a valid `UpdateWithStartWorkflowOperation` if it was created with a String update name

## Steps to Reproduce the Problem

```java
  @Test
  public void startAndSendUpdateTogetherUntypedWorkflowOperation()
      throws ExecutionException, InterruptedException {
    WorkflowClient workflowClient = testWorkflowRule.getWorkflowClient();

    WorkflowOptions options = createOptions();
    TestWorkflows.TestUpdatedWorkflow workflow =
        workflowClient.newWorkflowStub(TestWorkflows.TestUpdatedWorkflow.class, options);

    UpdateWithStartWorkflowOperation<Void> updateOp =
        UpdateWithStartWorkflowOperation.newBuilder("testUpdate", Void.class, "Hello Update")
            .setWaitForStage(WorkflowUpdateStage.COMPLETED)
            .build();

    WorkflowUpdateHandle<Void> handle1 =
        WorkflowClient.updateWithStart(workflow::execute, updateOp);
    assertNull(handle1.getResultAsync().get());

    WorkflowUpdateHandle<Void> updHandle = updateOp.getUpdateHandle().get();
    assertEquals(updateOp.getResult(), updHandle.getResultAsync().get());

    assertEquals("Hello Update", WorkflowStub.fromTyped(workflow).getResult(String.class));
  }
```

## Specifications

  - Version: v1.26.0



---

<a id="2283"></a>

### #2283: Auto-skip time in time-skipping testing environment when waiting on update result

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2283 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-10-21 16:29:49.000 UTC (1y 2m ago) |
| **Updated** | 2025-06-08 18:33:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

We auto-skip time when waiting on workflow result, we need to do the same when waiting on update result. See https://github.com/temporalio/features/issues/551.


---

<a id="2273"></a>

### #2273: Add Nexus failure_reason metric tag

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2273 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-10-16 15:51:44.000 UTC (1y 2m ago) |
| **Updated** | 2024-10-24 16:18:28.000 UTC |
| **Closed** | 2024-10-24 16:18:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add Nexus `failure_reason` metric tag to `nexus_task_execution_failed`

see: https://github.com/temporalio/sdk-go/pull/1671



---

<a id="2268"></a>

### #2268: Add "summary" to activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2268 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-10-15 15:15:45.000 UTC (1y 2m ago) |
| **Updated** | 2024-11-04 16:28:24.000 UTC |
| **Closed** | 2024-11-04 16:28:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

As part of initial MVP of user metadata, it was now decided to add optional "summary" to activities. Add, mark experimental, and populate user metadata on command with it.


---

<a id="2265"></a>

### #2265: Add high-level workflow describe

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2265 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-10-10 16:09:02.000 UTC (1y 3m ago) |
| **Updated** | 2024-11-25 23:57:05.000 UTC |
| **Closed** | 2024-11-25 23:57:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

* Add high-level workflow describe call
  * Probably `describe` on the workflow stub
* Return a `WorkflowExecutionDescription` that contains at least the things list does and access to the raw describe response for now
  * In other SDKs, this would be an extension of the `WorkflowExecutionMetadata` class since it has all of that and more
* Make sure it is interceptable

See TypeScript, Python, and .NET SDKs if looking for design inspiration for this call, or reference https://github.com/temporalio/sdk-go/issues/1667.


---

<a id="2246"></a>

### #2246: Time-skipping past activity‚Äôs startToCloseTimeout causes worker not to close

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2246 |
| **State** | OPEN |
| **Author** | ikonst (Ilya Priven) |
| **Created** | 2024-10-01 19:03:16.000 UTC (1y 3m ago) |
| **Updated** | 2025-06-02 15:26:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

`worker.runUntil` returns shortly after workflow ends

## Actual Behavior

- `worker.runUntil` usually hangs, ostensibly because it fails to wait for the abandoned activity
- Logged SDK warning:
  ```
  WARN temporal_sdk_core::worker::activities: Activity not found on completion. This may happen if the activity has already been cancelled but completed anyway. task_token=TaskToken(<activity's token>) details=Status { code: NotFound, message: "invalid activityID or activity already timed out or invoking workflow is completed", metadata: MetadataMap { headers: {"content-type": "application/grpc"} }, source: None }
  ```

## Steps to Reproduce the Problem

Pardon my TypeScript...

Assume activity `foo`:
```ts
export async function foo() {
}
```
and workflow `workflow`:
```ts
const { foo } = proxyActivities<typeof activities>({ startToCloseTimeout: "60 seconds" });

export async function workflow() {
  await foo();
}
```

And let this be the test:
```ts
test("foo", async () => {
  testEnv = await TestWorkflowEnvironment.createTimeSkipping();
  worker = Worker.create({
    connection: testEnv.nativeConnection,
    ...
  });

  let waited = false;
  const worker = await createWorker({
    activities: {
      foo: async function() { 
        if (!waited) {
          await testEnv.sleep("61 seconds");
          waited = true;
        }
      }
    },
  });
  
  await worker.runUntil(testEnv.client.workflow.execute(workflow, {}));
  // ^ gets stuck here:
});
```

## Specifications

  - Version: TypeScript SDK 1.11.1
  - Platform: MacOS

## Discussion

- Original Slack thread: https://temporalio.slack.com/archives/C01DKSMU94L/p1727789446627909


---

<a id="2237"></a>

### #2237: Show update handler and ID in logging context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2237 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-09-24 16:37:40.000 UTC (1y 3m ago) |
| **Updated** | 2024-10-08 15:09:17.000 UTC |
| **Closed** | 2024-10-08 15:09:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/466 for more details


---

<a id="2235"></a>

### #2235: Add Nexus Support to TestWorkflowExtension

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2235 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-23 15:25:46.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-26 03:55:19.000 UTC |
| **Closed** | 2024-09-26 03:55:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add Nexus Support to TestWorkflowExtension


---

<a id="2232"></a>

### #2232: Fix inconsistency in javadoc for WorkflowInterface

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2232 |
| **State** | OPEN |
| **Author** | mackler (Adam Makl√©r) |
| **Created** | 2024-09-22 08:12:29.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-22 08:12:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The example code given in the documentation for the [`@WorkflowInterface`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/WorkflowInterface.html) annotation would not behave as described in the accompanying text.

See [this forum post](https://community.temporal.io/t/trying-to-understand-example-in-the-workflowinterface-annotation-documentation/13559/2) for background details.


---

<a id="2229"></a>

### #2229: Add TestNexusEnvironment similar to TestActivityEnvironment

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2229 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-19 14:26:20.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-19 14:26:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to test Nexus operations without a workflow

**Describe the solution you'd like**
Add TestNexusEnvironment similar to [TestActivityEnvironment](https://javadoc.io/doc/io.temporal/temporal-testing/latest/io/temporal/testing/TestActivityEnvironment.html)

**Describe alternatives you've considered**
Write a short workflow to invoke the operation




---

<a id="2227"></a>

### #2227: Test Server: Fill in namespace capabilities in describe response

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2227 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-19 00:17:51.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-23 15:27:05.000 UTC |
| **Closed** | 2024-09-23 15:27:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/temporal/pull/6256


---

<a id="2220"></a>

### #2220: Add Nexus Worker interceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2220 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-15 23:59:47.000 UTC (1y 3m ago) |
| **Updated** | 2024-12-17 11:39:20.000 UTC |
| **Closed** | 2024-12-17 11:39:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add support for Nexus worker interceptor to `WorkerInterceptor` similar to `ActivityInboundCallsInterceptor`


---

<a id="2219"></a>

### #2219: Test Server: Add support for user metadata

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2219 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-15 23:57:13.000 UTC (1y 3m ago) |
| **Updated** | 2025-03-11 19:38:14.000 UTC |
| **Closed** | 2025-03-11 19:38:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add support for https://github.com/temporalio/api/commit/de9e0055a5067ee3e3a6105a207b7c78e8ea8668 on workflow start and commands.



---

<a id="2216"></a>

### #2216: MVP support for user meta data on workflows and events 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2216 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-15 06:36:42.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-16 23:02:06.000 UTC |
| **Closed** | 2024-09-16 23:02:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add support for user meta data on events 

* Fixed "summary" and "details" on workflow start (includes signal with start and child workflow and scheduled workflows)
* "summary" on timer start (can serve as "timer ID")

https://github.com/temporalio/features/issues/486



---

<a id="2215"></a>

### #2215: Test Server does not treat internal errors as retryable from Nexus operations 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2215 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-14 04:55:56.000 UTC (1y 3m ago) |
| **Updated** | 2024-09-17 16:20:18.000 UTC |
| **Closed** | 2024-09-17 16:20:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Test server treats internal errors from nexus operations as retryable

## Actual Behavior
Test server treats internal errors from nexus operations as non-retryable

## Steps to Reproduce the Problem
```
package io.temporal.workflow.nexus;

import static org.junit.Assume.assumeTrue;

import io.nexusrpc.handler.OperationHandler;
import io.nexusrpc.handler.OperationImpl;
import io.nexusrpc.handler.ServiceImpl;
import io.temporal.client.WorkflowFailedException;
import io.temporal.failure.NexusOperationFailure;
import io.temporal.failure.TimeoutFailure;
import io.temporal.testing.internal.SDKTestWorkflowRule;
import io.temporal.workflow.*;
import io.temporal.workflow.shared.TestNexusServices;
import io.temporal.workflow.shared.TestWorkflows;
import java.time.Duration;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

public class SyncOperationTimeoutTest extends BaseNexusTest {
  @Rule
  public SDKTestWorkflowRule testWorkflowRule =
      SDKTestWorkflowRule.newBuilder()
          .setWorkflowTypes(TestNexus.class)
          .setNexusServiceImplementation(new TestNexusServiceImpl())
          .build();

  @Override
  protected SDKTestWorkflowRule getTestWorkflowRule() {
    return testWorkflowRule;
  }

  @Test
  public void typedOperationTimeout() {
    TestWorkflows.TestWorkflow1 workflowStub =
        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflows.TestWorkflow1.class);
    WorkflowFailedException exception =
        Assert.assertThrows(WorkflowFailedException.class, () -> workflowStub.execute(""));
    Assert.assertTrue(exception.getCause() instanceof NexusOperationFailure);
    NexusOperationFailure nexusFailure = (NexusOperationFailure) exception.getCause();
    Assert.assertTrue(nexusFailure.getCause() instanceof TimeoutFailure);
    TimeoutFailure timeoutFailure = (TimeoutFailure) nexusFailure.getCause();
    Assert.assertEquals("operation timed out", timeoutFailure.getOriginalMessage());
  }

  public static class TestNexus implements TestWorkflows.TestWorkflow1 {
    @Override
    public String execute(String input) {
      NexusOperationOptions options =
          NexusOperationOptions.newBuilder()
              .setScheduleToCloseTimeout(Duration.ofSeconds(1))
              .build();
      NexusServiceOptions serviceOptions =
          NexusServiceOptions.newBuilder()
              .setEndpoint(getEndpointName())
              .setOperationOptions(options)
              .build();
      // Try to call a synchronous operation in a blocking way
      TestNexusServices.TestNexusService1 serviceStub =
          Workflow.newNexusServiceStub(TestNexusServices.TestNexusService1.class, serviceOptions);
      return serviceStub.operation("test timeout");
    }
  }

  @ServiceImpl(service = TestNexusServices.TestNexusService1.class)
  public class TestNexusServiceImpl {
    @OperationImpl
    public OperationHandler<String, String> operation() {
      // Implemented inline
      return OperationHandler.sync(
          (ctx, details, name) -> {
            throw new RuntimeException("failed to call operation");
          });
    }
  }
}
```




---

<a id="2212"></a>

### #2212: UpdateHandle should have a getResult method

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2212 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-09-12 19:53:11.000 UTC (1y 3m ago) |
| **Updated** | 2024-11-23 23:43:53.000 UTC |
| **Closed** | 2024-11-23 23:43:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Usability nit.  To get the result of the update, you have to do
`handle.getResultAsync().get()`
Given that updates are mostly used for synchronous use cases, could we make this more convenient?

**Describe the solution you'd like**
It makes sense to have a `getResult()` convenience helper that aliases the above code.

**Describe alternatives you've considered**

We considered renaming the async version to `getResult()` to be consistent with some other methods on the Java SDK.
But we decided that `WorkflowStub` has `getResult/getResultAsync` which is precedent enough given there's no way to be globally consistent.
And that having both is clearer and more usable.


**Additional context**
Add any other context or screenshots about the feature request here.



---

<a id="2209"></a>

### #2209: Nexus handler - well known Temporal error translation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2209 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-09-09 17:47:14.000 UTC (1y 4m ago) |
| **Updated** | 2024-10-04 18:35:36.000 UTC |
| **Closed** | 2024-10-04 18:35:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Replicate the behavior implemented in this Go SDK PR: https://github.com/temporalio/sdk-go/pull/1626


---

<a id="2208"></a>

### #2208: Add `getMetricsScope` to `WorkflowOutboundCallsInterceptor`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2208 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-09-09 15:49:02.000 UTC (1y 4m ago) |
| **Updated** | 2024-09-23 16:59:34.000 UTC |
| **Closed** | 2024-09-23 16:59:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I want to add custom tags to all metrics emitted in my workflow

**Describe the solution you'd like**
Add `getMetricsScope` to `WorkflowOutboundCallsInterceptor`




---

<a id="2192"></a>

### #2192: Missing Attempt value on MDC for logging purposes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2192 |
| **State** | CLOSED |
| **Author** | javiercanillas (Javier Canillas) |
| **Created** | 2024-08-18 23:40:55.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-21 00:28:50.000 UTC |
| **Closed** | 2024-08-21 00:28:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Workflow or activity execution logs miss the Attempt number, just the same way they have the WorkflowId, ActivityId and so on.

**Describe the solution you'd like**
Add a new LoggerTag ATTEMPT and introduce its value on MDC like the others.

**Describe alternatives you've considered**
None besides the first one.

**Additional context**
None



---

<a id="2184"></a>

### #2184: Fix workflow start delay docs to say signal does not interrupt delay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2184 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-08-15 12:30:19.000 UTC (1y 4m ago) |
| **Updated** | 2024-08-15 23:56:20.000 UTC |
| **Closed** | 2024-08-15 23:56:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Per discussion at https://github.com/temporalio/api/pull/441#discussion_r1710132081, signal does not interrupt delay


---

<a id="2181"></a>

### #2181: Type safe async update API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2181 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-08-13 22:52:47.000 UTC (1y 4m ago) |
| **Updated** | 2024-11-26 20:33:08.000 UTC |
| **Closed** | 2024-11-26 20:33:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add a type safe async update API

**Describe the solution you'd like**
Add an API similar to [WorkflowClient. start](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClient.html) for update methods that return an update handle

**Describe alternatives you've considered**
Not use the stub/proxy based approach




---

<a id="2178"></a>

### #2178: Carry over search attributes on continue-as-new if none are explicitly specified

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2178 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2024-08-09 21:33:16.000 UTC (1y 5m ago) |
| **Updated** | 2025-12-04 18:02:16.000 UTC |
| **Closed** | 2025-12-04 18:02:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This will match the behavior in other SDKs. Currently it looks like nothing is carried over.


---

<a id="2165"></a>

### #2165: Enable Nexus test server docker functional tests once 1.25 is released

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2165 |
| **State** | CLOSED |
| **Author** | pdoerner |
| **Created** | 2024-08-02 00:30:51.000 UTC (1y 5m ago) |
| **Updated** | 2025-09-26 06:41:35.000 UTC |
| **Closed** | 2025-09-26 06:41:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Nexus is only fully supported in OSS 1.25.0+ so the functional tests using an external server are disabled for now. They should be re-enabled once 1.25.0 is officially released.




---

<a id="2160"></a>

### #2160: Child workflow cancellation can trigger SDK event loop without a WFT Started

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2160 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-07-30 15:25:22.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-30 15:25:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Child workflow cancellation would not trigger the event loop without a WFT Started

## Actual Behavior

Child workflow cancellation can trigger SDK event loop without a WFT Started

## Steps to Reproduce the Problem

see: https://github.com/temporalio/sdk-java/issues/2155

https://github.com/temporalio/sdk-java/blob/eabd51fbdc62a7435c8f4d8dc1ac24da26f6022d/temporal-sdk/src/main/java/io/temporal/internal/statemachines/WorkflowStateMachines.java#L884


Fixing this would be a non deterministic change so we will need to version this change.



---

<a id="2157"></a>

### #2157: CI: Get rid of buildjet-2vcpu-ubuntu-1804 GHA runners

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2157 |
| **State** | CLOSED |
| **Author** | mjameswh (James Watkins-Harvey) |
| **Created** | 2024-07-29 19:24:02.000 UTC (1y 5m ago) |
| **Updated** | 2024-12-03 05:31:49.000 UTC |
| **Closed** | 2024-12-03 05:31:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | mjameswh |
| **Milestone** | None |

#### Description

## Description

Our CI workflows are still using `buildjet-2vcpu-ubuntu-1804` runners to build the Test Server binaries, so that we maintain glibc compatibility with various, older Linux distributions.

GitHub dropped support for Ubuntu 18.04 about 2 years ago, but until now, it was still possible for external builders (like Buildjet's) to continue using that distribution. However, the latest release of GitHub's Runner Agent brings in new dependencies that are incompatible with Ubuntu 18.04, forcing immediate update of all Runners.

It is therefore urgent that we update our CI workflows to use a more recent runner, as we might be incapable of making a new Java SDK release until this is fixed.


---

<a id="2155"></a>

### #2155: WorkflowTask failure because of an invalid state transition in LocalActivity state machine

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2155 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-07-27 01:58:39.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-30 18:32:37.000 UTC |
| **Closed** | 2024-07-30 18:32:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The following test case should pass

```
public class LocalActivityAfterCancelTest {
  private final TestActivitiesImpl activitiesImpl = new TestActivitiesImpl();

  @Rule
  public SDKTestWorkflowRule testWorkflowRule =
      SDKTestWorkflowRule.newBuilder()
          .setUseExternalService(true)
          .setWorkflowTypes(TestLocalActivityRetry.class, BlockingWorkflow.class)
          .setActivityImplementations(activitiesImpl)
          .build();

  @Test
  public void localActivityAfterChildWorkflowCanceled() {
    TestWorkflow1 workflowStub =
        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflow1.class);
    WorkflowClient.execute(workflowStub::execute, "input");
    WorkflowStub.fromTyped(workflowStub).cancel();
    WorkflowFailedException exception =
        Assert.assertThrows(WorkflowFailedException.class, () -> workflowStub.execute("input"));
    Assert.assertEquals(
        EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED, exception.getWorkflowCloseEventType());
  }

  @Test
  public void testLocalActivityAfterChildWorkflowCanceledReplay() {
    assertThrows(
        RuntimeException.class,
        () ->
            WorkflowReplayer.replayWorkflowExecutionFromResource(
                "testLocalActivityAfterCancelTest.json",
                LocalActivityAfterCancelTest.TestLocalActivityRetry.class));
  }

  @WorkflowInterface
  public static class BlockingWorkflow implements TestWorkflows.TestWorkflowReturnString {
    @Override
    public String execute() {
      Workflow.await(() -> false);
      return "";
    }
  }

  public static class TestLocalActivityRetry implements TestWorkflow1 {

    @Override
    public String execute(String taskQueue) {
      try {
        ChildWorkflowOptions childOptions =
            ChildWorkflowOptions.newBuilder()
                .setWorkflowId(Workflow.getInfo().getWorkflowId() + "-child1")
                .setCancellationType(ChildWorkflowCancellationType.WAIT_CANCELLATION_REQUESTED)
                .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_REQUEST_CANCEL)
                .validateAndBuildWithDefaults();
        TestWorkflows.TestWorkflowReturnString child =
            Workflow.newChildWorkflowStub(
                TestWorkflows.TestWorkflowReturnString.class, childOptions);
        child.execute();
      } catch (TemporalFailure e) {
        if (CancellationScope.current().isCancelRequested()) {
          Workflow.newDetachedCancellationScope(
                  () -> {
                    VariousTestActivities act =
                        Workflow.newLocalActivityStub(
                            VariousTestActivities.class,
                            LocalActivityOptions.newBuilder()
                                .setStartToCloseTimeout(Duration.ofSeconds(5))
                                .validateAndBuildWithDefaults());
                    act.activity1(10);
                  })
              .run();
          throw e;
        }
      }
      return "ignored";
    }
  }
}

```
It fails with an error like
```
	LocalActivity: invalid REQUEST_PREPARED->NON_REPLAY_WORKFLOW_TASK_STARTED, transition history is [CREATED->CHECK_EXECUTION_STATE, EXECUTING->SCHEDULE]

```

See also: https://community.temporal.io/t/workflowtask-failure-because-of-an-invalid-state-transition-in-localactivity-state-machine/12895/3



---

<a id="2152"></a>

### #2152: Support schedule search attribute update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2152 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-24 19:23:49.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-12 23:08:39.000 UTC |
| **Closed** | 2024-08-12 23:08:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/512 and the Go implementation at https://github.com/temporalio/sdk-go/issues/1561



---

<a id="2150"></a>

### #2150: Generated Google proto classes are part of generated service client classes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2150 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-23 13:04:20.000 UTC (1y 5m ago) |
| **Updated** | 2024-08-08 20:40:58.000 UTC |
| **Closed** | 2024-08-08 20:40:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Do not include generated Google protos.

## Actual Behavior

Per @antmendoza, `duplicate-finder-maven-plugin` on `v1.23.2`:

```
[INFO] Checking test classpath
[WARNING] Found duplicate (but equal) classes in [com.google.api.grpc:proto-google-common-protos:2.9.0, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.api.CustomHttpPatternOrBuilder
[WARNING] Found duplicate and different classes in [com.google.api.grpc:proto-google-common-protos:2.9.0, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.api.AnnotationsProto
[WARNING]   com.google.api.CustomHttpPattern
[WARNING]   com.google.api.Http
[WARNING]   com.google.api.HttpOrBuilder
[WARNING]   com.google.api.HttpProto
[WARNING]   com.google.api.HttpRule
[WARNING]   com.google.api.HttpRuleOrBuilder
[WARNING] Found duplicate and different classes in [com.google.protobuf:protobuf-java:3.21.7, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.protobuf.Any
[WARNING]   com.google.protobuf.AnyOrBuilder
[WARNING]   com.google.protobuf.AnyProto
[WARNING]   com.google.protobuf.BoolValue
[WARNING]   com.google.protobuf.BoolValueOrBuilder
[WARNING]   com.google.protobuf.BytesValue
[WARNING]   com.google.protobuf.BytesValueOrBuilder
[WARNING]   com.google.protobuf.DescriptorProtos
[WARNING]   com.google.protobuf.DoubleValue
[WARNING]   com.google.protobuf.DoubleValueOrBuilder
[WARNING]   com.google.protobuf.Duration
[WARNING]   com.google.protobuf.DurationOrBuilder
[WARNING]   com.google.protobuf.DurationProto
[WARNING]   com.google.protobuf.Empty
[WARNING]   com.google.protobuf.EmptyOrBuilder
[WARNING]   com.google.protobuf.EmptyProto
[WARNING]   com.google.protobuf.FloatValue
[WARNING]   com.google.protobuf.FloatValueOrBuilder
[WARNING]   com.google.protobuf.Int32Value
[WARNING]   com.google.protobuf.Int32ValueOrBuilder
[WARNING]   com.google.protobuf.Int64Value
[WARNING]   com.google.protobuf.Int64ValueOrBuilder
[WARNING]   com.google.protobuf.ListValue
[WARNING]   com.google.protobuf.ListValueOrBuilder
[WARNING]   com.google.protobuf.NullValue
[WARNING]   com.google.protobuf.StringValue
[WARNING]   com.google.protobuf.StringValueOrBuilder
[WARNING]   com.google.protobuf.Struct
[WARNING]   com.google.protobuf.StructOrBuilder
[WARNING]   com.google.protobuf.StructProto
[WARNING]   com.google.protobuf.Timestamp
[WARNING]   com.google.protobuf.TimestampOrBuilder
[WARNING]   com.google.protobuf.TimestampProto
[WARNING]   com.google.protobuf.UInt32Value
[WARNING]   com.google.protobuf.UInt32ValueOrBuilder
[WARNING]   com.google.protobuf.UInt64Value
[WARNING]   com.google.protobuf.UInt64ValueOrBuilder
[WARNING]   com.google.protobuf.Value
[WARNING]   com.google.protobuf.ValueOrBuilder
[WARNING]   com.google.protobuf.WrappersProto
[WARNING] Found duplicate classes/resources in compile classpath.
[WARNING] Found duplicate (but equal) classes in [com.google.api.grpc:proto-google-common-protos:2.9.0, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.api.CustomHttpPatternOrBuilder
[WARNING] Found duplicate and different classes in [com.google.api.grpc:proto-google-common-protos:2.9.0, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.api.AnnotationsProto
[WARNING]   com.google.api.CustomHttpPattern
[WARNING]   com.google.api.Http
[WARNING]   com.google.api.HttpOrBuilder
[WARNING]   com.google.api.HttpProto
[WARNING]   com.google.api.HttpRule
[WARNING]   com.google.api.HttpRuleOrBuilder
[WARNING] Found duplicate and different classes in [com.google.protobuf:protobuf-java:3.21.7, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.protobuf.Any
[WARNING]   com.google.protobuf.AnyOrBuilder
[WARNING]   com.google.protobuf.AnyProto
[WARNING]   com.google.protobuf.BoolValue
[WARNING]   com.google.protobuf.BoolValueOrBuilder
[WARNING]   com.google.protobuf.BytesValue
[WARNING]   com.google.protobuf.BytesValueOrBuilder
[WARNING]   com.google.protobuf.DescriptorProtos
[WARNING]   com.google.protobuf.DoubleValue
[WARNING]   com.google.protobuf.DoubleValueOrBuilder
[WARNING]   com.google.protobuf.Duration
[WARNING]   com.google.protobuf.DurationOrBuilder
[WARNING]   com.google.protobuf.DurationProto
[WARNING]   com.google.protobuf.Empty
[WARNING]   com.google.protobuf.EmptyOrBuilder
[WARNING]   com.google.protobuf.EmptyProto
[WARNING]   com.google.protobuf.FloatValue
[WARNING]   com.google.protobuf.FloatValueOrBuilder
[WARNING]   com.google.protobuf.Int32Value
[WARNING]   com.google.protobuf.Int32ValueOrBuilder
[WARNING]   com.google.protobuf.Int64Value
[WARNING]   com.google.protobuf.Int64ValueOrBuilder
[WARNING]   com.google.protobuf.ListValue
[WARNING]   com.google.protobuf.ListValueOrBuilder
[WARNING]   com.google.protobuf.NullValue
[WARNING]   com.google.protobuf.StringValue
[WARNING]   com.google.protobuf.StringValueOrBuilder
[WARNING]   com.google.protobuf.Struct
[WARNING]   com.google.protobuf.StructOrBuilder
[WARNING]   com.google.protobuf.StructProto
[WARNING]   com.google.protobuf.Timestamp
[WARNING]   com.google.protobuf.TimestampOrBuilder
[WARNING]   com.google.protobuf.TimestampProto
[WARNING]   com.google.protobuf.UInt32Value
[WARNING]   com.google.protobuf.UInt32ValueOrBuilder
[WARNING]   com.google.protobuf.UInt64Value
[WARNING]   com.google.protobuf.UInt64ValueOrBuilder
[WARNING]   com.google.protobuf.Value
[WARNING]   com.google.protobuf.ValueOrBuilder
[WARNING]   com.google.protobuf.WrappersProto
[WARNING] Found duplicate classes/resources in runtime classpath.
[WARNING] Found duplicate (but equal) classes in [com.google.api.grpc:proto-google-common-protos:2.9.0, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.api.CustomHttpPatternOrBuilder
[WARNING] Found duplicate and different classes in [com.google.api.grpc:proto-google-common-protos:2.9.0, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.api.AnnotationsProto
[WARNING]   com.google.api.CustomHttpPattern
[WARNING]   com.google.api.Http
[WARNING]   com.google.api.HttpOrBuilder
[WARNING]   com.google.api.HttpProto
[WARNING]   com.google.api.HttpRule
[WARNING]   com.google.api.HttpRuleOrBuilder
[WARNING] Found duplicate and different classes in [com.google.protobuf:protobuf-java:3.21.7, io.temporal:temporal-serviceclient:1.24.0]:
[WARNING]   com.google.protobuf.Any
[WARNING]   com.google.protobuf.AnyOrBuilder
[WARNING]   com.google.protobuf.AnyProto
[WARNING]   com.google.protobuf.BoolValue
[WARNING]   com.google.protobuf.BoolValueOrBuilder
[WARNING]   com.google.protobuf.BytesValue
[WARNING]   com.google.protobuf.BytesValueOrBuilder
[WARNING]   com.google.protobuf.DescriptorProtos
[WARNING]   com.google.protobuf.DoubleValue
[WARNING]   com.google.protobuf.DoubleValueOrBuilder
[WARNING]   com.google.protobuf.Duration
[WARNING]   com.google.protobuf.DurationOrBuilder
[WARNING]   com.google.protobuf.DurationProto
[WARNING]   com.google.protobuf.Empty
[WARNING]   com.google.protobuf.EmptyOrBuilder
[WARNING]   com.google.protobuf.EmptyProto
[WARNING]   com.google.protobuf.FloatValue
[WARNING]   com.google.protobuf.FloatValueOrBuilder
[WARNING]   com.google.protobuf.Int32Value
[WARNING]   com.google.protobuf.Int32ValueOrBuilder
[WARNING]   com.google.protobuf.Int64Value
[WARNING]   com.google.protobuf.Int64ValueOrBuilder
[WARNING]   com.google.protobuf.ListValue
[WARNING]   com.google.protobuf.ListValueOrBuilder
[WARNING]   com.google.protobuf.NullValue
[WARNING]   com.google.protobuf.StringValue
[WARNING]   com.google.protobuf.StringValueOrBuilder
[WARNING]   com.google.protobuf.Struct
[WARNING]   com.google.protobuf.StructOrBuilder
[WARNING]   com.google.protobuf.StructProto
[WARNING]   com.google.protobuf.Timestamp
[WARNING]   com.google.protobuf.TimestampOrBuilder
[WARNING]   com.google.protobuf.TimestampProto
[WARNING]   com.google.protobuf.UInt32Value
[WARNING]   com.google.protobuf.UInt32ValueOrBuilder
[WARNING]   com.google.protobuf.UInt64Value
[WARNING]   com.google.protobuf.UInt64ValueOrBuilder
[WARNING]   com.google.protobuf.Value
[WARNING]   com.google.protobuf.ValueOrBuilder
[WARNING]   com.google.protobuf.WrappersProto
[WARNING] Found duplicate classes/resources in test classpath.
```

This is probably due to #2039 (specifically there seemed to be a backport to 1.23 series).


---

<a id="2149"></a>

### #2149: Revisit local activity backpressure logic w/ no-max slot suppliers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2149 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2024-07-19 21:03:46.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-19 21:03:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Before slot supplier introduction, there was a backpressure semaphore for LAs sized at 2x the number of concurrent executions which, when the limit is reached, fails the WFT.

After suppliers, this behavior is the same, but for suppliers with no defined upper-limit on slots, there is no way to pick a reasonable number, so we default to 100. See if there's anything better to be done here.


---

<a id="2148"></a>

### #2148: Better toString representations on service stub options

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2148 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-07-17 19:40:18.000 UTC (1y 5m ago) |
| **Updated** | 2024-07-17 19:40:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

* `WorkflowServiceStubsOptions.toString` only includes direct fields not inherited ones
* `OperatorServiceStubsOptions.toString` and `CloudServiceStubsOptions.toString` (as of #2146) do not exist


---

<a id="2127"></a>

### #2127: Test server sometimes fails to include signal in first WFT

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2127 |
| **State** | OPEN |
| **Author** | dandavison (Dan Davison) |
| **Created** | 2024-06-26 12:38:09.000 UTC (1y 6m ago) |
| **Updated** | 2024-11-20 20:59:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Using the Python SDK, I did

1. `handle = await start_workflow()`
2. `await handle.signal()`
3. run worker

## Expected Behavior
I expect Python to process a `signal_workflow` job and then a `start_workflow` in the activation for the first WFT.

## Actual Behavior
Nearly always, we see the expected behavior. Occasionally (on `macos-intel` builds) Python processes a `start_workflow` activation job first. Almost certainly this is because the first WFT has no signal in it, although I have not yet investigated further and actually proved that (the test in question exits immediately if it sees `start_workflow` before `signal_workflow`).

## Steps to Reproduce the Problem
Run the `sdk-python` test `tests/worker/test_workflow.py::test_unfinished_signal_handler_with_workflow_failure applying job` under `--workflow-environment=time-skipping` multiple times on a GitHub `macos-intel` runner until you see this failure.

Note: There are two variants of the python test; one involves the workflow throwing `ApplicationError`, and the other involves the client sending a cancel request, again before starting the worker. Interestingly, I've only seen the error described in this ticket for the  `ApplicationError` variant of the test, suggesting that handling the cancel request somehow causes the test server to include all of them in the first WFT, whereas without the cancel request sometimes the signal event is omitted.

See failures in build history of https://github.com/temporalio/sdk-python/pull/556


---

<a id="2116"></a>

### #2116: Workflow-friendly concurrency control

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2116 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 17:14:14.000 UTC (1y 6m ago) |
| **Updated** | 2024-07-30 20:15:58.000 UTC |
| **Closed** | 2024-07-30 20:15:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.  To be used within signal and update handlers and the main workflow coroutine.


---

<a id="2114"></a>

### #2114: Testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2114 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 03:56:35.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-18 03:56:51.000 UTC |
| **Closed** | 2024-06-18 03:56:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

testing


---

<a id="2113"></a>

### #2113: Testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2113 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 03:54:59.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-19 15:17:32.000 UTC |
| **Closed** | 2024-06-19 15:17:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

testing


---

<a id="2112"></a>

### #2112: Testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2112 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 03:54:10.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-19 15:17:52.000 UTC |
| **Closed** | 2024-06-19 15:17:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

testing


---

<a id="2111"></a>

### #2111: Testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2111 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-18 03:53:04.000 UTC (1y 6m ago) |
| **Updated** | 2024-06-19 15:18:00.000 UTC |
| **Closed** | 2024-06-19 15:18:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

testing


---

<a id="2107"></a>

### #2107: Concurrent Modification Exception when executing workflow with local activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2107 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-06-12 21:24:21.000 UTC (1y 7m ago) |
| **Updated** | 2024-06-13 07:03:15.000 UTC |
| **Closed** | 2024-06-13 07:03:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Issue

When executing workflow tasks with local activities `LocalActivityMeteringHelper` may attempt to make illegal modifications to its underlying data structure when calling `newWFTStarting` causing a `ConcurrentModificationException`

## Example: 
```
java.util.ConcurrentModificationException: null
	at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1605)
	at java.base/java.util.HashMap$KeyIterator.next(HashMap.java:1628)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler$LocalActivityMeteringHelper.newWFTStarting(ReplayWorkflowRunTaskHandler.java:431)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler$LocalActivityMeteringHelper.access$200(ReplayWorkflowRunTaskHandler.java:425)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:143)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:133)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:98)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:413)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:320)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:261)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:105)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
```

https://community.temporal.io/t/concurrent-modification-exception-when-executing-workflow/12479/1

## Specifications

  - Platform: 1.23.1



---

<a id="2094"></a>

### #2094: Java SDK `StartUpdate` waits outside of intercepted call

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2094 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-06-04 17:52:53.000 UTC (1y 7m ago) |
| **Updated** | 2024-07-30 16:24:43.000 UTC |
| **Closed** | 2024-07-30 16:24:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently when the Java SDK executes a start update call and the update request does not reach the required waitstage the SDK will block the call waiting for the update request to reach the required stage. Currently we do this after the interceptor, but in all other SDKs we do this inside the intercepted call. This makes it impossible to run logic in the interceptor after the start update call has completed. We need to align the Java SDK with other SDKs here.



---

<a id="2093"></a>

### #2093: Expose UpdateID in an update handler

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2093 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-04 16:17:05.000 UTC (1y 7m ago) |
| **Updated** | 2024-08-02 06:38:59.000 UTC |
| **Closed** | 2024-08-02 06:38:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This will allow users to use it when they want a unique primary key for handlers.


---

<a id="2091"></a>

### #2091: Provide methods to wait for all handlers to finish

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2091 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-06-04 04:39:17.000 UTC (1y 7m ago) |
| **Updated** | 2024-08-13 15:09:14.000 UTC |
| **Closed** | 2024-08-13 15:09:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Users want to easily await (or ignore) all their remaining handlers when they continue as new or exit the workflow.  Since we can't tell what they want, they should specify.


---

<a id="2078"></a>

### #2078: Add the ability to specify worker identity for each worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2078 |
| **State** | CLOSED |
| **Author** | Duzhinsky (Dmitrii Duzhinskii) |
| **Created** | 2024-05-28 17:09:03.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-29 18:28:47.000 UTC |
| **Closed** | 2024-05-29 18:28:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
It is assumed that in a single application, there are multiple workers that operate for different queues. Due to internal integrations in our infrastructure, I must specify a queue in the identity property. The worker is created using a `WorkerFactory`, which is linked to a `WorkflowClient`. Currently, there is only the ability to specify identity for the client.

**Describe the solution you'd like**
I propose the introduction of an option to assign an identity within `WorkerOptions`, and for this identity to be treated as a priority when `SingleWorkerOptions` are being configured.

https://github.com/temporalio/sdk-java/blob/5e5cf0bf2db695cba46d1855959e02b4cdfa3cff/temporal-sdk/src/main/java/io/temporal/worker/Worker.java#L586-L608

**Describe alternatives you've considered**
A possible workaround could involve creating a distinct `WorkflowClient` for every queue, which in turn would necessitate a separate `WorkerFactory` for each. However, employing a single client is fully sufficient for the application's needs.




---

<a id="2077"></a>

### #2077: TestWorkflowEnvironment, TestWorkflowRule, TestWorkflowExtension - auto-register search attributes from WorkflowStub 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2077 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-05-24 15:45:04.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-24 15:46:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Feature request to auto-register search attributes from WorkflowStub created by test envWorkflowClient

Currently each search attribute has to be explicitly registered with test env before using it in tests


---

<a id="2073"></a>

### #2073: Send original update request back in accept/reject response

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2073 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-21 12:33:24.000 UTC (1y 7m ago) |
| **Updated** | 2024-05-21 23:03:51.000 UTC |
| **Closed** | 2024-05-21 23:03:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/sdk-go/pull/1480, need to send original request back to server when accepting/rejecting update.


---

<a id="2068"></a>

### #2068: Disallow continue as new in update handlers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2068 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-17 18:20:15.000 UTC (1y 7m ago) |
| **Updated** | 2024-08-06 18:23:10.000 UTC |
| **Closed** | 2024-08-06 18:23:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Previously at https://github.com/temporalio/features/issues/379 it was decided to allow continue-as-new in update handlers. This decision has been reverted but Java was the only one that implemented it.  Should probably fail if the user tries to call it, but up to implementer here.


---

<a id="2060"></a>

### #2060: Call describe namespace on worker start

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2060 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-10 12:31:29.000 UTC (1y 8m ago) |
| **Updated** | 2025-08-25 17:22:32.000 UTC |
| **Closed** | 2025-08-25 17:22:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/477




---

<a id="2059"></a>

### #2059: Cloud Operations API Client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2059 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-05-09 14:53:47.000 UTC (1y 8m ago) |
| **Updated** | 2024-07-19 12:46:54.000 UTC |
| **Closed** | 2024-07-19 12:46:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/440 and https://github.com/temporalio/sdk-go/pull/1426. We need a separate cloud client using the cloud protos (they are separate today). The client should be marked experimental.


---

<a id="2051"></a>

### #2051: Ability to specify activity timeouts via annotation in Java SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2051 |
| **State** | OPEN |
| **Author** | luispollo (Luis Pollo) |
| **Created** | 2024-05-03 16:32:19.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-03 18:46:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
In the Java SDK, you have an `@ActivityInterface` with multiple `@ActivityMethod`s. The latter is the actual unit of execution. However, you specify retry and timeout options on the activity stub, which is based on the interface, so in order to have specific config for each activity you have to go out of your way and break up the interface into small pieces, which kinda defeats one of the nicest features of Temporal which is to just program your service as if it were native code. You can configure specific settings per method, but you have to use strings for activity names instead of strongly typed constructs, and still the activity-stub level config takes precedence.

Recently, I became aware of the `@MethodRetry` annotation, which is great, but it only allows you to specify retry options, not timeouts, so it falls short of addressing the basic issue.

**Describe the solution you'd like**
Either an additional set of parameters in `@MethodRetry` or a new annotation (e.g. `@ActivityTimeouts`) that allows me to specify activity timeouts (start-to-close and schedule-to-close) at the method level.

**Describe alternatives you've considered**
Specifying per-activity config using [WorkflowImplementationOptions](https://docs.temporal.io/dev-guide/java/foundations#required-timeout), but you have to use strings for activity names instead of strongly typed constructs, and still the activity-stub level config takes precedence.

**Additional context**
N/A.



---

<a id="2048"></a>

### #2048: ScheduleClient is missing an option to add interceptors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2048 |
| **State** | CLOSED |
| **Author** | dano (Dan O'Reilly) |
| **Created** | 2024-05-01 14:39:11.000 UTC (1y 8m ago) |
| **Updated** | 2024-05-03 16:51:57.000 UTC |
| **Closed** | 2024-05-03 16:51:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
There should be an API on ScheduleClientOptions to add ScheduleClientCallsInterceptor (or maybe ScheduleClientInterceptor, if the pattern used by WorkflowClient is followed) instances to the ScheduleClient.

## Actual Behavior
There is no such API.



---

<a id="2045"></a>

### #2045: Make startUpdate users aware that it's synchronous w/ worker

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2045 |
| **State** | CLOSED |
| **Author** | drewhoskins-temporal (Drew Hoskins) |
| **Created** | 2024-04-25 01:37:30.000 UTC (1y 8m ago) |
| **Updated** | 2024-06-03 16:52:22.000 UTC |
| **Closed** | 2024-06-03 16:52:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
https://github.com/temporalio/features/issues/469

**Describe the solution you'd like**
A clear and concise description of what you want to happen.
Related to https://github.com/temporalio/sdk-java/blob/ed211fa611112288b576a2c979be9284e17fec89/temporal-sdk/src/main/java/io/temporal/client/WorkflowStub.java#L94-L106
Developers should be informed about and opt in to behavior that `startWorkflow` waits for acceptance

**Describe alternatives you've considered**

**Additional context**



---

<a id="2044"></a>

### #2044: Fail workflow task on illegal calls in `Workflow.await`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2044 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-04-19 21:17:59.000 UTC (1y 8m ago) |
| **Updated** | 2024-09-23 14:38:25.000 UTC |
| **Closed** | 2024-09-23 14:38:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

`Workflow.await` is expected to be idempotent, so it is not allowed to make any calls to mutate workflow state like start an activity. If we detect any such call we should fail the workflow task since it indicates a bug in the workflow implementation.

```
boolean activityExecuted = Workflow.await(Duration.ofSeconds(5), () -> {
    activity.doSomething();
    return true;
});
```


---

<a id="2038"></a>

### #2038: [CI] StickyWorkflowDrainShutdownTest.testShutdown is flaky

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2038 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-04-15 16:56:24.000 UTC (1y 8m ago) |
| **Updated** | 2024-06-03 16:21:59.000 UTC |
| **Closed** | 2024-06-03 16:21:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

In CI StickyWorkflowDrainShutdownTest.testShutdown is flaky. Looking at it I think there is a race condition in worker shutdown if no activities are registered.

https://github.com/temporalio/sdk-java/actions/runs/8667250325/job/23771031368?pr=2021


---

<a id="2035"></a>

### #2035: Expose defaultConnection() method to switch between localhost and cloud based on env

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2035 |
| **State** | CLOSED |
| **Author** | josh-berry (Josh Berry) |
| **Created** | 2024-04-12 23:54:38.000 UTC (1y 9m ago) |
| **Updated** | 2025-10-04 14:28:14.000 UTC |
| **Closed** | 2025-10-04 14:28:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Expose a defaultConnection() method or similar that switches between localhost (default) and cloud based on some environment variable, so that we can use it in the samples repos to allow people to easily run samples in the cloud. See: https://github.com/temporalio/features/issues/454




---

<a id="2033"></a>

### #2033: Support for WorkflowIdConflictPolicy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2033 |
| **State** | CLOSED |
| **Author** | josh-berry (Josh Berry) |
| **Created** | 2024-04-11 00:32:26.000 UTC (1y 9m ago) |
| **Updated** | 2024-06-03 16:14:02.000 UTC |
| **Closed** | 2024-06-03 16:14:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/437


---

<a id="2031"></a>

### #2031: Add SpringBoot integration for `SlotSupplier`s

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2031 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2024-04-10 18:39:45.000 UTC (1y 9m ago) |
| **Updated** | 2024-04-10 18:39:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add sprintboot config options to configure slot suppliers as introduced in https://github.com/temporalio/sdk-java/pull/2014


---

<a id="2030"></a>

### #2030: Add `PauseableSlotSupplier`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2030 |
| **State** | OPEN |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2024-04-10 18:38:37.000 UTC (1y 9m ago) |
| **Updated** | 2024-04-10 18:38:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add an implementation of `SlotSupplier` that wraps another implementation adding a `pause()` function. See https://github.com/temporalio/proposals/blob/master/all-sdk/autotuning.md for more on how it should work.


---

<a id="2026"></a>

### #2026: [SpringBoot] Add graceful shutdown wait time as property

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2026 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-04-05 23:54:48.000 UTC (1y 9m ago) |
| **Updated** | 2024-04-05 23:54:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently when the worker factory is shutdown by Springboot on close there is no wait to for the shutdown to finish. This can cause the application to close before all inflight tasks are finished.

**Describe the solution you'd like**
Add a property that will control how long the workerfactory waits before continuing shutdown.

**Describe alternatives you've considered**
Users can manually work around this by adding a hook to the context close event and manually shutting down the factory and waiting.

**Additional context**




---

<a id="2020"></a>

### #2020: `ReplayWorkflowTaskHandler.failureToWFTResult` does not use a `SeralizationContext` when serializing an exception for a direct query

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2020 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-03-28 17:07:38.000 UTC (1y 9m ago) |
| **Updated** | 2024-04-01 00:26:29.000 UTC |
| **Closed** | 2024-04-01 00:26:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`ReplayWorkflowTaskHandler.failureToWFTResult` does use a `SeralizationContext` when serializing an exception for a direct query

## Actual Behavior
`ReplayWorkflowTaskHandler.failureToWFTResult` does not use a `SeralizationContext` when serializing an exception for a direct query

https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowTaskHandler.java#L302C50-L302C68



---

<a id="2017"></a>

### #2017: [Feature Request] Use macOS M1/ARM runners for all SDK CI

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2017 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-03-26 17:52:08.000 UTC (1y 9m ago) |
| **Updated** | 2024-11-22 05:51:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See: https://github.com/temporalio/features/issues/396




---

<a id="2002"></a>

### #2002: [Feature Request] SDK should not return an update handle if the update has not reached the desired state

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/2002 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-03-06 18:20:51.000 UTC (1y 10m ago) |
| **Updated** | 2024-05-21 19:13:08.000 UTC |
| **Closed** | 2024-05-21 19:13:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See https://github.com/temporalio/features/issues/432



---

<a id="1990"></a>

### #1990: grpc-api-1.54.1.jar: 1 vulnerabilities (highest severity is: 7.1)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1990 |
| **State** | CLOSED |
| **Author** | app/mend-for-github-com |
| **Created** | 2024-02-16 18:07:28.000 UTC (1y 10m ago) |
| **Updated** | 2025-06-02 15:26:29.000 UTC |
| **Closed** | 2025-06-02 15:26:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>grpc-api-1.54.1.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-serviceclient/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (grpc-api version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-2976](https://www.mend.io/vulnerability-database/CVE-2023-2976) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.1 | guava-31.1-jre.jar | Transitive | 1.57.0 | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-2976</summary>


###  Vulnerable Library - <b>guava-31.1-jre.jar</b></p>

<p>Guava is a suite of core and expanded libraries that include
    utility classes, Google's collections, I/O classes, and
    much more.</p>
<p>Path to dependency file: /temporal-serviceclient/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/31.1-jre/60458f877d055d0c9114d9e1a2efb737b4bc282c/guava-31.1-jre.jar</p>
<p>

Dependency Hierarchy:
  - grpc-api-1.54.1.jar (Root Library)
    - :x: **guava-31.1-jre.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Use of Java's default temporary directory for file creation in `FileBackedOutputStream` in Google Guava versions 1.0 to 31.1 on Unix systems and Android Ice Cream Sandwich allows other users and apps on the machine with access to the default Java temporary directory to be able to access the files created by the class.

Even though the security vulnerability is fixed in version 32.0.0, we recommend using version 32.0.1 as version 32.0.0 breaks some functionality under Windows.


 Mend Note: Even though the security vulnerability is fixed in version 32.0.0, maintainers recommend using version 32.0.1 as version 32.0.0 breaks some functionality under Windows.

<p>Publish Date: 2023-06-14
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-2976>CVE-2023-2976</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.1</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-7g45-4rm6-3mm3">https://github.com/advisories/GHSA-7g45-4rm6-3mm3</a></p>
<p>Release Date: 2023-06-14</p>
<p>Fix Resolution (com.google.guava:guava): 32.0.1-android</p>
<p>Direct dependency fix Resolution (io.grpc:grpc-api): 1.57.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>


---

<a id="1987"></a>

### #1987: Configurable workflow exception types at the worker level

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1987 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2024-02-12 14:25:38.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-12 14:28:15.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

See https://github.com/temporalio/features/issues/322. May be determined we don't need this and closed.


---

<a id="1983"></a>

### #1983: Expose next retry delay on Application Failure in all SDKs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1983 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2024-02-02 22:35:14.000 UTC (1y 11m ago) |
| **Updated** | 2024-05-29 18:28:50.000 UTC |
| **Closed** | 2024-05-29 18:28:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We recently added the ability for an activity to specify the next retry delay on failure via a [field on `ApplicationFailureInfo`](https://github.com/temporalio/api/blob/822966d29758cba3462d6f5ff198257fbaa426f6/temporal/api/failure/v1/message.proto#L49).

Expose this in the SDK.


---

<a id="1982"></a>

### #1982: Verify DynamicWorkflows implementation applies serialization 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1982 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2024-02-02 10:30:02.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-16 23:04:59.000 UTC |
| **Closed** | 2024-02-16 23:04:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Customer reported an issue similar to https://github.com/temporalio/sdk-java/issues/1895 that involves DynamicWorkflow

It seems that replacing 

https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/sync/POJOWorkflowImplementationFactory.java#L232-L233 

for 

```
return new DynamicSyncWorkflowDefinition(
            dynamicWorkflowImplementationFactory, workerInterceptors, dataConverter
                .withContext(new WorkflowSerializationContext(namespace, execution.getWorkflowId()));

```
fix the issue 





---

<a id="1981"></a>

### #1981: Add source code to shaded library

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1981 |
| **State** | OPEN |
| **Author** | longquanzheng (Quanzheng Long) |
| **Created** | 2024-02-01 22:59:54.000 UTC (1y 11m ago) |
| **Updated** | 2024-02-01 22:59:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
No source code available to read in IDE for java docs

**Describe the solution you'd like**
Just publish the jar with source code

**Describe alternatives you've considered**
I have to use browser/online java docs which is very frustrating 

**Additional context**
N/A



---

<a id="1978"></a>

### #1978:  Disable eager activities if task queue rate limits is set

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1978 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-24 15:45:05.000 UTC (1y 11m ago) |
| **Updated** | 2024-11-22 14:41:19.000 UTC |
| **Closed** | 2024-11-22 14:41:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

see https://github.com/temporalio/features/issues/405


---

<a id="1973"></a>

### #1973: WorkflowUpdateException incorrectly wrapped by ExecutionException in some edge case

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1973 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-19 18:45:27.000 UTC (1y 11m ago) |
| **Updated** | 2024-01-22 18:23:37.000 UTC |
| **Closed** | 2024-01-22 18:23:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`WorkflowUpdateException` may be wrapped in a `ExecutionException` on a sync update call if the update request could not finish in the servers long poll deadline and the SDK switched to long polling the update request. This can happen if the update took longer then the servers long poll deadline request deadline was longer then the servers long poll deadline. This is undesirable since from the user perspective they did not wait on any future so the exception being wrapped in a `ExecutionException` is unexpected.


https://github.com/temporalio/sdk-java/blob/806eab71f2b65f762cdd1c4079d3fbad0b62ae1d/temporal-sdk/src/main/java/io/temporal/client/WorkflowStubImpl.java#L307


---

<a id="1971"></a>

### #1971: Fix start-workers config

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1971 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2024-01-16 03:33:29.000 UTC (1y 11m ago) |
| **Updated** | 2024-01-16 13:05:29.000 UTC |
| **Closed** | 2024-01-16 13:05:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | tsurdilo |
| **Milestone** | None |

#### Description

Fix start-workers config. Currently its "startWorkers"


---

<a id="1966"></a>

### #1966: Workflow stub with only an update method fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1966 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2024-01-09 16:12:44.000 UTC (2 years ago) |
| **Updated** | 2024-01-13 00:51:08.000 UTC |
| **Closed** | 2024-01-13 00:51:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
To use a stub that only defines an update method

## Actual Behavior
Cannot use a stub that only defines an update method

reported on slack: https://temporalio.slack.com/archives/CTT84KXK9/p1704733148879439

example: 
```
public interface ParentWorkflowInterface {

    @UpdateMethod
    void foo();

}

@WorkflowInterface
public interface WorkflowInterface extends ParentWorkflowInterface {

    @WorkflowMethod
    void execute();
}

public class WorkflowImpl implements WorkflowInterface {

	@Override
	void execute() {
	
	}
	
	@Override
	void foo() {
	
	}

}
```
This call fails
```
ParentWorkflowInterface workflow = workflowClient.newWorkflowStub(ParentWorkflowInterface.class, "workflowId");
workflow.foo();
```



---

<a id="1956"></a>

### #1956: Worker autotuning - Pollers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1956 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-12-15 16:02:37.000 UTC (2 years ago) |
| **Updated** | 2025-06-11 20:30:47.000 UTC |
| **Closed** | 2025-06-11 20:30:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://github.com/temporalio/features/issues/334



---

<a id="1952"></a>

### #1952: ktlint-0.47.1.jar: 2 vulnerabilities (highest severity is: 7.5)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1952 |
| **State** | OPEN |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-12-06 06:45:33.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-14 22:30:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>ktlint-0.47.1.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.3.0/525b10f014422eb84e157e400960ca921949aa2a/logback-classic-1.3.0.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (ktlint version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-6481](https://www.mend.io/vulnerability-database/CVE-2023-6481) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | logback-core-1.3.0.jar | Transitive | N/A* | &#10060; |
| [CVE-2023-6378](https://www.mend.io/vulnerability-database/CVE-2023-6378) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | logback-classic-1.3.0.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p><p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-6481</summary>


###  Vulnerable Library - <b>logback-core-1.3.0.jar</b></p>

<p>logback-core module</p>
<p>Library home page: <a href="http://logback.qos.ch">http://logback.qos.ch</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.3.0/9718166ba4834f1e9585ba9212c93c04baec511d/logback-core-1.3.0.jar</p>
<p>

Dependency Hierarchy:
  - ktlint-0.47.1.jar (Root Library)
    - logback-classic-1.3.0.jar
      - :x: **logback-core-1.3.0.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A serialization vulnerability in logback receiver component part of 
logback version 1.4.13,¬†1.3.13 and¬†1.2.12 allows an attacker to mount a Denial-Of-Service 
attack by sending poisoned data.



<p>Publish Date: 2023-12-04
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-6481>CVE-2023-6481</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://www.cve.org/CVERecord?id=CVE-2023-6481">https://www.cve.org/CVERecord?id=CVE-2023-6481</a></p>
<p>Release Date: 2023-12-04</p>
<p>Fix Resolution: ch.qos.logback:logback-core:1.2.13,1.3.14,1.4.14</p>

</p>

<p></p>

</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-6378</summary>


###  Vulnerable Library - <b>logback-classic-1.3.0.jar</b></p>

<p>logback-classic module</p>
<p>Library home page: <a href="http://logback.qos.ch">http://logback.qos.ch</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.3.0/525b10f014422eb84e157e400960ca921949aa2a/logback-classic-1.3.0.jar</p>
<p>

Dependency Hierarchy:
  - ktlint-0.47.1.jar (Root Library)
    - :x: **logback-classic-1.3.0.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A serialization vulnerability in logback receiver component part of 
logback version 1.4.11 allows an attacker to mount a Denial-Of-Service 
attack by sending poisoned data.



<p>Publish Date: 2023-11-29
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-6378>CVE-2023-6378</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://logback.qos.ch/news.html#1.3.12">https://logback.qos.ch/news.html#1.3.12</a></p>
<p>Release Date: 2023-11-29</p>
<p>Fix Resolution: ch.qos.logback:logback-classic:1.3.12,1.4.12</p>

</p>

<p></p>

</details>


---

<a id="1951"></a>

### #1951: spring-boot-dependencies-2.7.12.pom: 1 vulnerabilities (highest severity is: 7.5)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1951 |
| **State** | OPEN |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-12-06 06:45:31.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-14 22:30:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-dependencies-2.7.12.pom</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.2.12/1d8e51a698b138065d73baefb4f94531faa323cb/logback-core-1.2.12.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-dependencies version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2023-6481](https://www.mend.io/vulnerability-database/CVE-2023-6481) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | logback-core-1.2.12.jar | Transitive | N/A* | &#10060; |
<p>*For some transitive vulnerabilities, there is no version of direct dependency with a fix. Check the "Details" section below to see if there is a version of transitive dependency where vulnerability is fixed.</p><p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-6481</summary>


###  Vulnerable Library - <b>logback-core-1.2.12.jar</b></p>

<p>logback-core module</p>
<p>Library home page: <a href="http://logback.qos.ch">http://logback.qos.ch</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.2.12/1d8e51a698b138065d73baefb4f94531faa323cb/logback-core-1.2.12.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-dependencies-2.7.12.pom (Root Library)
    - :x: **logback-core-1.2.12.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A serialization vulnerability in logback receiver component part of 
logback version 1.4.13,¬†1.3.13 and¬†1.2.12 allows an attacker to mount a Denial-Of-Service 
attack by sending poisoned data.



<p>Publish Date: 2023-12-04
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-6481>CVE-2023-6481</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://www.cve.org/CVERecord?id=CVE-2023-6481">https://www.cve.org/CVERecord?id=CVE-2023-6481</a></p>
<p>Release Date: 2023-12-04</p>
<p>Fix Resolution: ch.qos.logback:logback-core:1.2.13,1.3.14,1.4.14</p>

</p>

<p></p>

</details>


---

<a id="1945"></a>

### #1945: Fail task on unknown event when HistoryEvent.worker_may_ignore is false

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1945 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-12-01 13:43:34.000 UTC (2y 1m ago) |
| **Updated** | 2024-03-04 21:54:49.000 UTC |
| **Closed** | 2024-03-04 21:54:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, good first issue |
| **Assignees** | chronos-tachyon |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Fail the task when an event is seen that the worker must handle but is not familiar with



---

<a id="1938"></a>

### #1938: `toProtoDuration` may throw an `ArithmeticException` if Duration is too large

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1938 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-19 22:16:56.000 UTC (2y 1m ago) |
| **Updated** | 2023-12-14 22:28:29.000 UTC |
| **Closed** | 2023-12-14 22:28:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | good first issue |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When the SDK converts a Java `Duration` to a `protobuf.Duration` it uses `toMillis()`, but if the Java `Duration` represents a very large value converting to milliseconds may result in an overflow. We should probably convert the seconds directly and truncate the nanoseconds to millisecond precision to maintain consistency.

```
  public static com.google.protobuf.Duration toProtoDuration(Duration d) {
    // TODO we should refactor an implicit conversion of empty values into ZERO and rename the
    // current method into toJavaDurationSafe, toJavaDurationOrDefault or something like that
    if (d == null) {
      return Durations.ZERO;
    }

    return Durations.fromMillis(d.toMillis());
  }

```


---

<a id="1929"></a>

### #1929: [Feature Request] Tag workflow_task_execution_failed with error type

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1929 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-07 16:12:30.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-16 23:19:26.000 UTC |
| **Closed** | 2023-11-16 23:19:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

see https://github.com/temporalio/features/issues/231


---

<a id="1928"></a>

### #1928: Flag signal after workflow complete as NonDeterminism

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1928 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-11-07 16:10:17.000 UTC (2y 2m ago) |
| **Updated** | 2023-11-09 16:39:43.000 UTC |
| **Closed** | 2023-11-09 16:39:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
If a workflow receives multiple signals and one signal has non deterministic logic in the signal handler that originally did not continue as new but on replay does should throw a `NonDeterministicException`

## Actual Behavior

Worker throws an `IllegalStateException` Signal received after workflow is closed


---

<a id="1920"></a>

### #1920: Support bind address for test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1920 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-11-01 12:26:40.000 UTC (2y 2m ago) |
| **Updated** | 2024-11-20 21:00:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Need to be able to set bind address (e.g. for 127.0.0.1) instead of assuming all addresses


---

<a id="1915"></a>

### #1915: Java SDK should verify it replays up to `StartedEventId` when processing a workflow task

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1915 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-28 17:53:59.000 UTC (2y 2m ago) |
| **Updated** | 2023-10-31 22:41:34.000 UTC |
| **Closed** | 2023-10-30 18:00:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Java SDK should verify it replays up to `StartedEventId` sent on the poll request when processing a workflow task

## Actual Behavior
Java SDK does not verify it replays up to `StartedEventId` sent on the poll request when processing a workflow task. This can lead to the Java SDK not replaying the full workflow history if it is fetching history using `GetWorkflowExecutionHistory` after receiving a partial history with no cached execution and hitting a stale history node.

Note: In server version 1.21 and greater the server won't send a partial history on the normal task queue so this issue wold not occur on more up to date servers.




---

<a id="1911"></a>

### #1911: com.google.api.grpc:proto-google-common-protos is not included in shaded SDK

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1911 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-27 03:28:25.000 UTC (2y 2m ago) |
| **Updated** | 2023-10-30 18:20:41.000 UTC |
| **Closed** | 2023-10-30 18:20:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`com.google.api.grpc:proto-google-common-protos` that is used by `StatusUtils` is not included in the shaded SDK. This causes `NoClassDefFoundErrors` or `IncompatibleClassChangeError` when using the shaded SDK and the SDK needs to convert a status to/from an exception.


---

<a id="1895"></a>

### #1895: Verify DataConverters apply SerializationContext consistently 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1895 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-11 23:06:21.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-16 15:48:00.000 UTC |
| **Closed** | 2023-10-16 15:48:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`SerializationContext` should be applied consistently in the Java SDK

## Actual Behavior
`SerializationContext` may not be applied consistently in the Java SDK


One example reported is `memo` does not use a data converter with a `SerializationContext` when calling `StartWorkflow`

We should audit and test all data conversion site in the SDK to verify we consistently apply `SerializationContext`.


---

<a id="1893"></a>

### #1893: Identity not set on `Terminate` call

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1893 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-11 15:27:41.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-11 20:24:42.000 UTC |
| **Closed** | 2023-10-11 20:24:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Identity not set on `Terminate` call in the Java SDK

see https://github.com/temporalio/features/issues/193



---

<a id="1890"></a>

### #1890: spring-boot-starter-2.7.12.jar: 9 vulnerabilities (highest severity is: 9.8)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1890 |
| **State** | OPEN |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-10-10 17:07:38.000 UTC (2y 3m ago) |
| **Updated** | 2024-02-29 17:00:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>spring-boot-starter-2.7.12.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (spring-boot-starter version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-1471](https://www.mend.io/vulnerability-database/CVE-2022-1471) | <img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20> Critical | 9.8 | snakeyaml-1.30.jar | Transitive | 3.2.0 | &#9989; |
| [CVE-2023-6378](https://www.mend.io/vulnerability-database/CVE-2023-6378) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | logback-classic-1.2.12.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-25857](https://www.mend.io/vulnerability-database/CVE-2022-25857) | <img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> High | 7.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2023-34055](https://www.mend.io/vulnerability-database/CVE-2023-34055) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | spring-boot-2.7.12.jar | Transitive | 2.7.18 | &#9989; |
| [CVE-2022-41854](https://www.mend.io/vulnerability-database/CVE-2022-41854) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38752](https://www.mend.io/vulnerability-database/CVE-2022-38752) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38751](https://www.mend.io/vulnerability-database/CVE-2022-38751) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38749](https://www.mend.io/vulnerability-database/CVE-2022-38749) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 6.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
| [CVE-2022-38750](https://www.mend.io/vulnerability-database/CVE-2022-38750) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 5.5 | snakeyaml-1.30.jar | Transitive | 3.0.0 | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20> CVE-2022-1471</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization.¬†Deserializing yaml content provided by an attacker can lead to remote code execution. We recommend using SnakeYaml's SafeConsturctor when parsing untrusted content to restrict deserialization. We recommend upgrading to version 2.0 and beyond.


<p>Publish Date: 2022-12-01
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-1471>CVE-2022-1471</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>9.8</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: High
  - Integrity Impact: High
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374">https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in#comment-64634374</a></p>
<p>Release Date: 2022-12-01</p>
<p>Fix Resolution (org.yaml:snakeyaml): 2.0</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.2.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2023-6378</summary>


###  Vulnerable Library - <b>logback-classic-1.2.12.jar</b></p>

<p>logback-classic module</p>
<p>Library home page: <a href="http://logback.qos.ch">http://logback.qos.ch</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.2.12/d4dee19148dccb177a0736eb2027bd195341da78/logback-classic-1.2.12.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - spring-boot-starter-logging-2.7.12.jar
      - :x: **logback-classic-1.2.12.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
A serialization vulnerability in logback receiver component part of 
logback version 1.4.11 allows an attacker to mount a Denial-Of-Service 
attack by sending poisoned data.



<p>Publish Date: 2023-11-29
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-6378>CVE-2023-6378</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://logback.qos.ch/news.html#1.3.12">https://logback.qos.ch/news.html#1.3.12</a></p>
<p>Release Date: 2023-11-29</p>
<p>Fix Resolution (ch.qos.logback:logback-classic): 1.2.13</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20> CVE-2022-25857</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
The package org.yaml:snakeyaml from 0 and before 1.31 are vulnerable to Denial of Service (DoS) due missing to nested depth limitation for collections.

<p>Publish Date: 2022-08-30
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-25857>CVE-2022-25857</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>7.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25857</a></p>
<p>Release Date: 2022-08-30</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2023-34055</summary>


###  Vulnerable Library - <b>spring-boot-2.7.12.jar</b></p>

<p>Spring Boot</p>
<p>Library home page: <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p>
<p>Path to dependency file: /temporal-spring-boot-autoconfigure-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot/2.7.12/888c3545dc3c6ca791753c7ad621a2d03f222732/spring-boot-2.7.12.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **spring-boot-2.7.12.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In Spring Boot versions 2.7.0 - 2.7.17, 3.0.0-3.0.12 and 3.1.0-3.1.5, it is possible for a user to provide specially crafted HTTP requests that may cause a denial-of-service (DoS) condition.

Specifically, an application is vulnerable when all of the following are true:

  *  the application uses Spring MVC or Spring WebFlux
  *  org.springframework.boot:spring-boot-actuator¬†is on the classpath





<p>Publish Date: 2023-11-28
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2023-34055>CVE-2023-34055</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://spring.io/security/cve-2023-34055">https://spring.io/security/cve-2023-34055</a></p>
<p>Release Date: 2023-11-28</p>
<p>Fix Resolution (org.springframework.boot:spring-boot): 2.7.18</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 2.7.18</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-41854</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Those using Snakeyaml to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack overflow. This effect may support a denial of service attack.

<p>Publish Date: 2022-11-11
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-41854>CVE-2022-41854</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/531/">https://bitbucket.org/snakeyaml/snakeyaml/issues/531/</a></p>
<p>Release Date: 2022-11-11</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38752</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stack-overflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38752>CVE-2022-38752</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-9w3m-gqgf-c4p9">https://github.com/advisories/GHSA-9w3m-gqgf-c4p9</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.32</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38751</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38751>CVE-2022-38751</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47039</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38749</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38749>CVE-2022-38749</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>6.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: Low
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027">https://bitbucket.org/snakeyaml/snakeyaml/issues/526/stackoverflow-oss-fuzz-47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details><details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-38750</summary>


###  Vulnerable Library - <b>snakeyaml-1.30.jar</b></p>

<p>YAML 1.1 parser and emitter for Java</p>
<p>Library home page: <a href="https://bitbucket.org/snakeyaml/snakeyaml">https://bitbucket.org/snakeyaml/snakeyaml</a></p>
<p>Path to dependency file: /temporal-spring-boot-starter-alpha/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.30/8fde7fe2586328ac3c68db92045e1c8759125000/snakeyaml-1.30.jar</p>
<p>

Dependency Hierarchy:
  - spring-boot-starter-2.7.12.jar (Root Library)
    - :x: **snakeyaml-1.30.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
Using snakeYAML to parse untrusted YAML files may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow.

<p>Publish Date: 2022-09-05
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-38750>CVE-2022-38750</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.5</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Local
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: Required
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: None
  - Availability Impact: High
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47027</a></p>
<p>Release Date: 2022-09-05</p>
<p>Fix Resolution (org.yaml:snakeyaml): 1.31</p>
<p>Direct dependency fix Resolution (org.springframework.boot:spring-boot-starter): 3.0.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>


---

<a id="1888"></a>

### #1888: kotlin-klib-commonizer-embeddable-1.5.32.jar: 1 vulnerabilities (highest severity is: 5.3)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1888 |
| **State** | OPEN |
| **Author** | app/mend-for-github-com |
| **Created** | 2023-10-10 17:07:36.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-10 17:07:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | Mend: dependency security vulnerability |
| **Assignees** | None |
| **Milestone** | None |

#### Description

<details><summary><img src='https://whitesource-resources.whitesourcesoftware.com/vulnerability_details.png' width=19 height=20> Vulnerable Library - <b>kotlin-klib-commonizer-embeddable-1.5.32.jar</b></p></summary>

<p></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.32/a1f8a73f899b85e6eb4337dff7e81b8b914bd2c9/kotlin-stdlib-1.5.32.jar</p>
<p>


<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p></details>

## Vulnerabilities

| CVE | Severity | <img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width=19 height=20> CVSS | Dependency | Type | Fixed in (kotlin-klib-commonizer-embeddable version) | Remediation Possible** |
| ------------- | ------------- | ----- | ----- | ----- | ------------- | --- |
| [CVE-2022-24329](https://www.mend.io/vulnerability-database/CVE-2022-24329) | <img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> Medium | 5.3 | kotlin-stdlib-1.5.32.jar | Transitive | 1.6.0 | &#9989; |
<p>**In some cases, Remediation PR cannot be created automatically for a vulnerability despite the availability of remediation</p>

## Details

<details>

<summary><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20> CVE-2022-24329</summary>


###  Vulnerable Library - <b>kotlin-stdlib-1.5.32.jar</b></p>

<p>Kotlin Standard Library for JVM</p>
<p>Library home page: <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Path to dependency file: /temporal-kotlin/build.gradle</p>
<p>Path to vulnerable library: /home/wss-scanner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.32/a1f8a73f899b85e6eb4337dff7e81b8b914bd2c9/kotlin-stdlib-1.5.32.jar</p>
<p>

Dependency Hierarchy:
  - kotlin-klib-commonizer-embeddable-1.5.32.jar (Root Library)
    - :x: **kotlin-stdlib-1.5.32.jar** (Vulnerable Library)
<p>Found in HEAD commit: <a href="https://github.com/temporalio/sdk-java/commit/f389bd8e9cd8956213466e705d5e2a36978aea65">f389bd8e9cd8956213466e705d5e2a36978aea65</a></p>
<p>Found in base branch: <b>master</b></p>
</p>

<p></p>

###  Vulnerability Details
<p>  
  
In JetBrains Kotlin before 1.6.0, it was not possible to lock dependencies for Multiplatform Gradle Projects.

<p>Publish Date: 2022-02-25
<p>URL: <a href=https://www.mend.io/vulnerability-database/CVE-2022-24329>CVE-2022-24329</a></p>
</p>

<p></p>

###  CVSS 3 Score Details (<b>5.3</b>)
<p>

Base Score Metrics:
- Exploitability Metrics:
  - Attack Vector: Network
  - Attack Complexity: Low
  - Privileges Required: None
  - User Interaction: None
  - Scope: Unchanged
- Impact Metrics:
  - Confidentiality Impact: None
  - Integrity Impact: Low
  - Availability Impact: None
</p>
For more information on CVSS3 Scores, click <a href="https://www.first.org/cvss/calculator/3.0">here</a>.
</p>

<p></p>

###  Suggested Fix
<p>

<p>Type: Upgrade version</p>
<p>Origin: <a href="https://github.com/advisories/GHSA-2qp4-g3q3-f92w">https://github.com/advisories/GHSA-2qp4-g3q3-f92w</a></p>
<p>Release Date: 2022-02-25</p>
<p>Fix Resolution (org.jetbrains.kotlin:kotlin-stdlib): 1.6.0-M1</p>
<p>Direct dependency fix Resolution (org.jetbrains.kotlin:kotlin-klib-commonizer-embeddable): 1.6.0</p>

</p>

<p></p>


:rescue_worker_helmet: Automatic Remediation will be attempted for this issue.
</details>

***

<p>:rescue_worker_helmet:Automatic Remediation will be attempted for this issue.</p>


---

<a id="1885"></a>

### #1885: Metric temporal_workflow_task_execution_failed is unexpectedly incremented on server-side task completion send failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1885 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-10-06 13:55:27.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-10 21:10:47.000 UTC |
| **Closed** | 2023-10-10 21:10:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Users use `workflow_task_execution_failed` to know when they are sending workflow task failure because of a worker-side failure (e.g. panic in Go, non-Temporal exception in Java). So it's expected to only increment this on worker-side task fail.

## Actual Behavior

In Java, unlike Go, we _also_ increment this on server-side task completion rejection (e.g. `UNHANDLED_COMMAND`). We should have some way to differentiate worker-side task failure and server-side task rejection. In Go we don't even have a metric for the latter, we just log. We should either stop incrementing in this case or we should introduce a label to let the different situations be differentiated.


---

<a id="1880"></a>

### #1880: Speculative workflow task can cause WFT failure

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1880 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-10-04 16:41:54.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-10 15:10:26.000 UTC |
| **Closed** | 2023-10-10 15:10:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Speculative workflow task don't cause WFT failure

## Actual Behavior
Speculative workflow task can cause WFT failure

## Steps to Reproduce the Problem

  1. Send a speculative update that is rejected
  2. Send a signal
  



---

<a id="1875"></a>

### #1875: TestWorkflowEnvironment Workflow.getTypedSearchAttributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1875 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-09-28 03:08:28.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-28 03:08:58.000 UTC |
| **Closed** | 2023-09-28 03:08:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

       Workflow.getTypedSearchAttributes()
              .get(SearchAttributeKey.forOffsetDateTime("CustomDatetimeField"));

When running a workflow that does getTypedSearchAttributes in test using TestWorkflowEnvironment
the value of getTypedSearchAttributes is null. When run outside of test env this works fine


---

<a id="1872"></a>

### #1872: Enable TCP Keep alive by default

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1872 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-26 15:13:16.000 UTC (2y 3m ago) |
| **Updated** | 2023-11-16 16:00:30.000 UTC |
| **Closed** | 2023-11-16 16:00:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Enable TCP Keep alive by default

https://github.com/temporalio/features/issues/123




---

<a id="1870"></a>

### #1870: `UnableToAcquireLockException` exception causes slots to not get freed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1870 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-25 22:04:32.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-26 14:33:14.000 UTC |
| **Closed** | 2023-09-26 14:33:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
If a workflow task times out with `UnableToAcquireLockException` the slot is released

## Actual Behavior
If a workflow task times out with `UnableToAcquireLockException` the slot is not released




---

<a id="1864"></a>

### #1864: Null pointer exception on creating schedule with `TriggerImmediately` and no `Policy`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1864 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-20 15:29:10.000 UTC (2y 3m ago) |
| **Updated** | 2023-09-25 16:42:59.000 UTC |
| **Closed** | 2023-09-25 16:42:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Creating a schedule with `TriggerImmediately` and no policy set should work

## Actual Behavior
Creating a schedule with `TriggerImmediately` and no policy set throws a null pointer exception






---

<a id="1863"></a>

### #1863: Add start delay to start workflow options

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1863 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-20 14:08:06.000 UTC (2y 3m ago) |
| **Updated** | 2023-10-16 13:49:11.000 UTC |
| **Closed** | 2023-10-16 13:49:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

see:
https://github.com/temporalio/features/issues/338



---

<a id="1862"></a>

### #1862: Support build ID reachability API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1862 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-13 23:00:01.000 UTC (2y 3m ago) |
| **Updated** | 2023-11-03 15:24:42.000 UTC |
| **Closed** | 2023-11-03 15:24:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Build ID reachability API should be supported in the Java SDK

https://docs.temporal.io/workers#build-id-reachability



---

<a id="1858"></a>

### #1858: Worker can get stuck only polling sticky queue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1858 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-09-07 14:05:56.000 UTC (2y 4m ago) |
| **Updated** | 2023-09-07 16:09:24.000 UTC |
| **Closed** | 2023-09-07 16:09:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
If a worker gets an empty response or an error polling the stick task queue the worker should reset the sticky queue backlog.

[This is how Go works today
](https://github.com/temporalio/sdk-go/blob/b7931cbfb1de6e5797a0dded2163b63d8a5836e8/internal/internal_task_pollers.go#L770)
## Actual Behavior
The worker only resets the backlog if it receives a non empty response. This can cause the worker to get stuck only polling the stick task queue if all the pollers are polling the sticky queue and all the WFT get moved to the normal task queue.

https://github.com/temporalio/sdk-go/blob/b7931cbfb1de6e5797a0dded2163b63d8a5836e8/internal/internal_task_pollers.go#L770

## Specifications

  - Version: 1.21.1
  - Platform: Mac OS



---

<a id="1856"></a>

### #1856: expose worker versioning via spring boot autoconfig

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1856 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-09-01 15:44:49.000 UTC (2y 4m ago) |
| **Updated** | 2023-10-04 16:48:02.000 UTC |
| **Closed** | 2023-10-04 16:48:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | tsurdilo |
| **Milestone** | None |

#### Description

feature request is to allow worker versioning configs to be added to autoconfig (properties/yaml)


---

<a id="1854"></a>

### #1854: Fix WorkerOptions equals method

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1854 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-08-31 02:40:15.000 UTC (2y 4m ago) |
| **Updated** | 2023-09-26 14:27:30.000 UTC |
| **Closed** | 2023-09-26 14:27:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | tsurdilo |
| **Milestone** | None |

#### Description

WorkerOptions equals is failing with NullPointer if buildid is not explicitly set. To reproduce:

          WorkerOptions w1 = WorkerOptions.newBuilder().build();
          WorkerOptions w2 = WorkerOptions.newBuilder().build();
          assertTrue(w1.equals(w2));

This is due to added buildid in equals without a null check for it:
https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/worker/WorkerOptions.java#L582


---

<a id="1847"></a>

### #1847: Typed search attributes aren't consistent with schedules

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1847 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-08-24 14:07:29.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-28 14:02:44.000 UTC |
| **Closed** | 2023-08-28 14:02:44.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Typed search attributes in Java don't interact cleanly with Schedule Workflows in Java. 

One issue is the search attribute field on the `ScheduleOptions` still use the old approach. This was just a miss in the typed search attribute PR because it was mostly done before schedules was merged.

Another more annoying behaviour is typed search attributes on the schedule workflow action: 
* If a user uses the old, deprecated way of setting search attributes when creating a schedule, Java SDK just ignores them when creating the schedule. 
* If a users set the SA through both the deprecated and typed way we just accept the typed values and don't error or warn like we do in other places in the Java SDK. 
* On the describe path Java SDK will panic if the search attributes does not type information in their metadata. Java always writes this, but other SDKs like Go did not (we would warn in this case) and the server does not currently fill this information in like was expected.




---

<a id="1839"></a>

### #1839: Add HealthIndicator to spring-boot library

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1839 |
| **State** | OPEN |
| **Author** | osialr (Ryan Osial) |
| **Created** | 2023-08-14 14:19:26.000 UTC (2y 4m ago) |
| **Updated** | 2023-08-14 14:19:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to monitor the state of Temporal Java SDK and workers through spring-boot-actuator's /health endpoint

**Describe the solution you'd like**
In the `temporal-spring-boot-autoconfigure-alpha` project, create a HealthIndicator and AutoConfiguration that includes information on the connection, state of the workers, and anything else that could be of value for health.

Could use [RabbitHealthIndicator](https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java) and [RabbitHealthContributorAutoConfiguration](https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/amqp/RabbitHealthContributorAutoConfiguration.java) as an starting point.

**Describe alternatives you've considered**
Split monitoring health of workers and temporal connection into separate health indicators

**Additional context**
HealthIndicator allows external monitoring tools to check whether the application has entered a failed state and needs a restart.



---

<a id="1838"></a>

### #1838: Update sdk-name and sdk-version in task-level metadata if changed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1838 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-08-09 20:30:38.000 UTC (2y 5m ago) |
| **Updated** | 2025-02-21 20:49:17.000 UTC |
| **Closed** | 2025-02-21 20:49:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Independently, if either SDK name or SDK version changed on the workflow from what was last seen on some task, set it to the current values (same values as client-name and client-version gRPC headers).

See https://github.com/temporalio/features/issues/321


---

<a id="1830"></a>

### #1830: WorkflowReplayer throws unclear exception when LocalActivityOptions are misconfigured

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1830 |
| **State** | OPEN |
| **Author** | tylercunnion (Tyler Cunnion) |
| **Created** | 2023-07-31 22:50:45.000 UTC (2y 5m ago) |
| **Updated** | 2023-07-31 22:50:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

When using WorkflowReplayer with the TestWorkflowEnvironment, I expect missing/misconfigured LocalActivityOptions to throw a useful error, similar to the one presented when missing regular ActivityOptions:

```
Caused by: java.lang.IllegalArgumentException: Both StartToCloseTimeout and ScheduleToCloseTimeout aren't specified for ImportInitialization activity. Please set at least one of the above through the ActivityStub or WorkflowImplementationOptions.
```

## Actual Behavior

The exception presented is fairly cryptic:
```
java.lang.RuntimeException: query failure for workflow_id: "workflow_id_in_replay"
run_id: "run_id_in_replay", queryType=__replay_only, args=Optional.empty, error=java.lang.Error: closed
```

Stepping through shows that the cause is in the [validateAndBuildWithDefaults](https://github.com/temporalio/sdk-java/blob/c2b941a0fb8b2cfe907ec1fdf9d4b9637cf32179/temporal-sdk/src/main/java/io/temporal/activity/LocalActivityOptions.java#L222) method - but this IllegalArgumentException is somehow swallowed (the next step jumps to this [finally block in CancellationScopeImpl](https://github.com/temporalio/sdk-java/blob/c2b941a0fb8b2cfe907ec1fdf9d4b9637cf32179/temporal-sdk/src/main/java/io/temporal/internal/sync/CancellationScopeImpl.java#L104) ). If this exception ended up being displayed the problem would have been pretty obvious and quick to solve.

## Steps to Reproduce the Problem

  1. Write and run a workflow that uses a Local Activity. (It MAY be necessary to run inside a CancellationScope, haven't tested extensively)
  1. Create a TestWorkflowEnvironment that does not have default LocalActivityOptions configured, and use it with WorkflowReplayer to replay the workflow history.

## Specifications

  - Version: observed in SDK v1.18.2 and 1.20.1
  - Platform: Mac



---

<a id="1825"></a>

### #1825: Support the certificate with linebreak strings from env variable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1825 |
| **State** | OPEN |
| **Author** | masashinak (Masashi Nakane) |
| **Created** | 2023-07-26 18:23:23.000 UTC (2y 5m ago) |
| **Updated** | 2023-07-26 18:25:10.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

We store the temporal cloud cert and private key as env vars opposed to application.yaml/prop.
Because the env var values cannot contain linebreak/linefeed special characters, the ServiceStubOptionsTemaplte fails to load cert/key saying it is not valid cert [ on this line ](https://github.com/temporalio/sdk-java/blob/c2b941a0fb8b2cfe907ec1fdf9d4b9637cf32179/temporal-spring-boot-autoconfigure-alpha/src/main/java/io/temporal/spring/boot/autoconfigure/template/ServiceStubOptionsTemplate.java#L124C16-L124C16).
(It works perfectly with application.yaml/propeties because it converts "\n" to linebreak)

![image](https://github.com/temporalio/sdk-java/assets/96093327/023e7f99-2f40-4933-ab77-0f5c393fc3bf)


**Describe the solution you'd like**
Add a logic to convert "\\n" to "\n" in the cert string if it is there , maybe in ServiceStubOptionsTemplate class.

**Describe alternatives you've considered**
I replaced ServiceStubsAutoConfiguration with our  customized/extended class which  converts  "\\n" to "\n" in mtlsProperties' cert and key.

`@SpringBootApplication(exclude = [ServiceStubsAutoConfiguration::class])
`


---

<a id="1820"></a>

### #1820: Exceptions thrown from ScheduleClient and ScheduleHandle should be wrapped in a TemporalException

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1820 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-07-17 17:48:07.000 UTC (2y 5m ago) |
| **Updated** | 2023-07-17 17:48:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
All exceptions thrown from the SDK should be subclasses of `TemporalException`

## Actual Behavior
`ScheduleClient ` and `ScheduleHandle ` violate this in some cases



---

<a id="1817"></a>

### #1817: RootScheduleClientInvoker.createSchedule swallows errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1817 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-07-14 15:31:55.000 UTC (2y 6m ago) |
| **Updated** | 2023-07-17 23:28:48.000 UTC |
| **Closed** | 2023-07-17 23:28:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior

It appears, as pointed out by [this comment](https://github.com/temporalio/sdk-java/pull/1776/files#r1263855932), that the `RootScheduleClientInvoker.createSchedule` code will swallow all exceptions that don't satisfy the `ScheduleAlreadyRunningException` conditions. We should rethrow others (and change catch clause to the specific type we want to catch).


---

<a id="1815"></a>

### #1815: SpringBoot - setting target to "local" does not register ServiceStubOptionsTemplate

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1815 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2023-07-14 03:36:29.000 UTC (2y 6m ago) |
| **Updated** | 2024-01-22 21:51:08.000 UTC |
| **Closed** | 2024-01-22 21:51:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When using springboot config in local env users are told to set target prop to "local", this however just creates

WorkflowServiceStubs.newLocalServiceStubs();

see https://github.com/temporalio/sdk-java/blob/master/temporal-spring-boot-autoconfigure-alpha/src/main/java/io/temporal/spring/boot/autoconfigure/template/ServiceStubsTemplate.java#L69-L71

We should either change this to also use ServiceStubOptionsTemplate or document that when using local things like 
metricsScope would not be registered.  


---

<a id="1812"></a>

### #1812: Spring support for ScheduleClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1812 |
| **State** | CLOSED |
| **Author** | JonGilmore (Jon Gilmore) |
| **Created** | 2023-07-13 20:28:43.000 UTC (2y 6m ago) |
| **Updated** | 2023-07-17 15:28:31.000 UTC |
| **Closed** | 2023-07-17 15:28:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

When switching from the older style cron workflows to Schedules, I'd like to be able to use `temporal-spring-boot-starter-alpha` to autowire a `ScheduleClient`. This would greatly simplify the cutover for us. 

**Describe the solution you'd like**

Autowire `ScheduleClient` using the spring-boot-starter

**Describe alternatives you've considered**

n/a

**Additional context**

Internal support ticket: https://support.temporal.io/hc/en-us/requests/2331


---

<a id="1808"></a>

### #1808: DataConverter interface does not provide a default implementation for `failureToException` and `exceptionToFailure`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1808 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-07-10 20:27:51.000 UTC (2y 6m ago) |
| **Updated** | 2023-08-28 16:41:42.000 UTC |
| **Closed** | 2023-08-28 16:41:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

## Expected Behavior
A default implementation for `failureToException` and `exceptionToFailure` exist since adding these without one breaks the API of `DataConverter`

## Actual Behavior
no default implementation exist


See also:
https://github.com/temporalio/sdk-java/pull/1645



---

<a id="1797"></a>

### #1797: Expose started time in activity info

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1797 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-06-27 17:37:14.000 UTC (2y 6m ago) |
| **Updated** | 2023-06-27 18:46:20.000 UTC |
| **Closed** | 2023-06-27 18:46:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Quinn-With-Two-Ns |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Expose activity task started time in activity info.



---

<a id="1781"></a>

### #1781: Validate update protocol message type on replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1781 |
| **State** | OPEN |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-06-07 21:41:24.000 UTC (2y 7m ago) |
| **Updated** | 2023-06-07 21:41:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
On replay currently only the `ProtocolMessageCommand` and the `Event` are checked for determinism. For the most accurate coverage the protocol message generated should also be checked.




---

<a id="1770"></a>

### #1770: Timeouts should be detected locally during activity execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1770 |
| **State** | CLOSED |
| **Author** | jeffschoner (Jeff Schoner) |
| **Created** | 2023-05-21 21:22:34.000 UTC (2y 7m ago) |
| **Updated** | 2025-06-02 15:29:43.000 UTC |
| **Closed** | 2025-06-02 15:29:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Activity timeouts are only detectable by activity code when a heartbeat attempt reaches the Temporal server. Heartbeat throttling can significantly delay timeout detection because it prevents or delays some heartbeats from reaching the server. This in turn causes activity attempts to continue running even when any result will be rejected.

**Describe the solution you'd like**

While this exact model isn't directly applicable in Java, the Go SDK sets a context deadline when executing activities in `internal.activity.WithActivityTask` ([source](https://github.com/temporalio/sdk-go/blob/master/internal/activity.go#L251)) that allows for local detection of start-to-close and schedule-to-close timeouts being reached.

Instead, I propose having the `heartbeat` method on the activity context throw a subclass of `ActivityCompletionException` when these timeouts are violated. All the information for calculating this is already present on the activity task (start-to-close timeout, schedule-to-close timeout, task attempt start time, task first scheduled time). This approach is consistent with other exceptions already thrown by this method for worker shutdown and activity cancellation.

**Describe alternatives you've considered**

*Interrupt the activity thread.* While it might be more thorough, this would be a much more invasive change to the existing activity programming model. Developers are already encouraged to catch `ActivityCompletionException` upon heartbeating to detect a need to exit activity execution early.

*Add methods to the activity context for timeout detection.* This could be done in addition to or instead of the above. An exception does not have to be thrown, but is consistent with existing behavior of `heartbeat` around other activity completion actions.

**Additional context**

When I chatted with Maxim a while back about this on the Temporal Community Slack, he was supportive. Unfortunately, the thread appears to have been retentioned away. I don't believe an issue was ever opened for this.


---

<a id="1769"></a>

### #1769: [Test Server] Support speculative workflow tasks for Update

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1769 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-05-19 17:07:31.000 UTC (2y 7m ago) |
| **Updated** | 2024-09-24 19:25:09.000 UTC |
| **Closed** | 2024-09-24 19:25:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Add support for speculative workflow tasks for Update under the appropriate conditions:
* No command events were sent in the WFT
* The response WFT contains no commands
* The response WFT contains only rejected updates requests



---

<a id="1767"></a>

### #1767: Log server-side task failure caused by invalid command in test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1767 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-05-17 20:41:02.000 UTC (2y 7m ago) |
| **Updated** | 2024-11-20 21:04:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Describe the solution you'd like**

Today `io.temporal.internal.testservice.CommandVerifier.verifyCommand` is called on each command to make sure valid or a task failure occurs. Since this is not a task failure caused by caller and there is no UI for Java test server, this is just silently failed. We should log (where it's called from `TestWorkflowMutableStateImpl`). This only applies to search attributes today, because that's the only thing we check command validity on (we don't need to log unhandled command, that's a normal state of operation).


---

<a id="1761"></a>

### #1761: Calling WorkflowLocal.set(null) results in the next call to WorkflowLocal.get() to throw a NullPointerException

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1761 |
| **State** | CLOSED |
| **Author** | dano (Dan O'Reilly) |
| **Created** | 2023-05-03 17:10:48.000 UTC (2y 8m ago) |
| **Updated** | 2023-06-07 15:57:08.000 UTC |
| **Closed** | 2023-06-07 15:57:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, good first issue |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I expect this:
``` java
public static WorkflowLocal<String> wl = WorkflowLocal.withInitial(() -> "value");
...
wl.get();
wl.set(null);
String s = wl.get();
```
To result in the String `s` being initialized to `null`.

## Actual Behavior
The call to `wl.get()` throws an NullPointerException:
```
Caused by: java.lang.NullPointerException
	at java.util.Objects.requireNonNull(Objects.java:221) ~[?:?]
	at java.util.Optional.<init>(Optional.java:107) ~[?:?]
	at java.util.Optional.of(Optional.java:120) ~[?:?]
	at io.temporal.internal.sync.DeterministicRunnerImpl.getRunnerLocal(DeterministicRunnerImpl.java:597) ~[temporal-sdk-1.19.1.jar:?]
	at io.temporal.internal.sync.RunnerLocalInternal.get(RunnerLocalInternal.java:30) ~[temporal-sdk-1.19.1.jar:?]
	at io.temporal.workflow.WorkflowLocal.get(WorkflowLocal.java:68) ~[temporal-sdk-1.19.1.jar:?]
        at <line that called wl.get()>
```

Note that this works fine:
``` java
public static WorkflowLocal<String> wl = WorkflowLocal.withInitial(() -> null);
...
wl.get();
```
The problem only occurs once you've called `set(null)`.

## Steps to Reproduce the Problem
See the code snippet above. The root cause of the bug is that `DeterministicRunnerImpl.getRunnerLocal.getRunnerLocal` returns an `Optional<T>`, which will return `Optional.empty()` if `WorkflowLocal.set` has not been called yet, or use `Optional.of` to wrap whatever was passed to `WorkflowLocal.set` in an `Optional`. When `set(null)` is used, the next `get()` results in a call to `Optional.of(null)`, which throws the NPE. I think that the `Optional<T>` return type just doesn't work here, since this method needs to differentiate between two states: `set` has not been called, or `set` has been called, inclusive of `set` being called with `null`, which `Optional` can't handle.

I also noticed that when `get()` is called for the first time, without `set` being called first, the value returned by the `withInitial` callback is not actually stored anywhere. So repeated calls to `get()` result in repeated calls to the `withInitial` callback. This is surprising behavior to me - not sure if it's intended or not.

## Specifications

  - Version: Java SDK 1.19.1.
  - Platform: Linux



---

<a id="1759"></a>

### #1759: Allow property placeholders in @ActivityImpl and @WorkflowImpl task queue name

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1759 |
| **State** | CLOSED |
| **Author** | FrankShaw (Frank Shaw) |
| **Created** | 2023-04-28 21:49:58.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-02 01:17:45.000 UTC |
| **Closed** | 2023-05-02 01:17:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
In our testing environment we create new environments for each pull request to allow easy testing, but currently there is no way to utilize the worker auto-discovery feature and have a dynamic queue name.

**Describe the solution you'd like**
I would recommend that the `@WorkflowImpl` and `@ActivityImpl` annotations allow for spring property placeholders to be used for the `taskQueues` property value.

For example:
application-prprofile.yaml
```yml
task-queue:
  suffix: "-test-suffix"
```

```java
@WorkflowImpl(taskQueues = "my-task-queue${task-queue.suffix:}")
public class MyWorkflowImpl implements MyWorkflow { ... }
```
This will result in the "my-task-queue-test-suffix" worker being created when the application is started with the `prprofile` spring profile active and, in other environments, the worker would be created as simply "my-task-queue"

**Describe alternatives you've considered**
The workaround without this is to no longer use the auto configuration and to configure the task queue names in spring configuration and utilize the property placeholder values there, but this seems like an easy and relatively harmless way to provide the same functionality while still enabling worker auto-configuration

**Additional context**
N/A



---

<a id="1750"></a>

### #1750: Pass activity in init to ActivityInboundCallInterceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1750 |
| **State** | CLOSED |
| **Author** | vaclavbroz |
| **Created** | 2023-04-18 12:49:32.000 UTC (2y 8m ago) |
| **Updated** | 2025-05-15 02:15:18.000 UTC |
| **Closed** | 2025-05-15 02:15:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

In order to be able to analyse the activity implementation object in an activity interceptor the interceptor needs a reference to the object. This could be done by changing the init(context) method to init(context,activity). The typical use case will be to analyse annotations of the activity method to see what should be the behaviour of the interceptor.

More specifically it may be useful to e.g. raise an alarm in a monitoring system whenever an activity fails for the 10th time while for other activities this is not necessary. A good way to do that e.g. in Java would be to define a new annotation and annotate only some of the activity methods (in the implementation class). To allow reflection to work properly a reference to the real object should be passed to the interceptor, not the proxy.

An alternative would be to provide to the interceptor a limited number of additional information about the activity implementation object, so for instance all annotations of the activity method both at the interface level as well as at the implementation level. But that would be reinventing the wheel in each programming language.

While this proposal seems like breaking the encapsulation of the activity implementation object by temporal, users tend to use interceptors for that type of business logic and need to overcome the challenge by maintaining references to the activity implementations using some other patterns which is in fact worse.


---

<a id="1748"></a>

### #1748: Run update validators in a limited workflow context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1748 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-04-20 05:25:38.000 UTC (2y 8m ago) |
| **Updated** | 2023-07-28 20:53:27.000 UTC |
| **Closed** | 2023-07-28 20:53:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
When running an update validator it should be run in a workflow context (ie have access to workflow info) but be limited in the actions it can take (not be able to use APIs that produce commands)




---

<a id="1745"></a>

### #1745: Support sync update request

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1745 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-04-18 21:47:16.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-19 17:04:40.000 UTC |
| **Closed** | 2023-05-19 17:04:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Add support for sending synchronous update request to external workflows from the java client



---

<a id="1743"></a>

### #1743: Support Async Update Polling

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1743 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-04-18 21:02:14.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-19 17:04:50.000 UTC |
| **Closed** | 2023-05-19 17:04:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Adds support for async updates

See also: https://github.com/temporalio/sdk-go/pull/1088



---

<a id="1742"></a>

### #1742: Add support for workflow update to Test Server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1742 |
| **State** | CLOSED |
| **Author** | Quinn-With-Two-Ns (Quinn Klassen) |
| **Created** | 2023-04-18 20:55:18.000 UTC (2y 8m ago) |
| **Updated** | 2023-05-19 17:05:25.000 UTC |
| **Closed** | 2023-05-19 17:05:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Implement protocol/messages and the update protocol to the test server



---

<a id="1727"></a>

### #1727: inconsistency on MaximumAttempts attribute between local activities and "normal" activities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1727 |
| **State** | OPEN |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2023-03-31 14:01:01.000 UTC (2y 9m ago) |
| **Updated** | 2023-06-02 05:00:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | good first issue |
| **Assignees** | None |
| **Milestone** | 1.20.0 |

#### Description

## Expected Behavior
setting setMaximumAttempts=0 (or not setting any value, default = 0) for local activities should make the activity retry forever.  

I expect the same behavior as "normal" activities, where MaximumAttempts=0  implies retry forever. 

## Actual Behavior

when MaximumAttempts is set to 0, local activities do not retry


## Steps to Reproduce the Problem
[HelloLocalActivity.java.zip](https://github.com/temporalio/sdk-java/files/11122584/HelloLocalActivity.java.zip)


## Specifications

  - Version:
  - Platform:



---

<a id="1712"></a>

### #1712: Test server not accessible

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1712 |
| **State** | CLOSED |
| **Author** | cv65kr (Kajetan) |
| **Created** | 2023-03-23 15:38:43.000 UTC (2y 9m ago) |
| **Updated** | 2023-03-23 20:17:26.000 UTC |
| **Closed** | 2023-03-23 20:17:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.19.1 |

#### Description

## Actual Behavior

```
Exception in thread "grpc-default-executor-60" java.lang.ExceptionInInitializerError
        at io.temporal.failure.DefaultFailureConverter.<clinit>(DefaultFailureConverter.java:69)
        at io.temporal.common.converter.PayloadAndFailureDataConverter.<init>(PayloadAndFailureDataConverter.java:51)
        at io.temporal.common.converter.DefaultDataConverter.<init>(DefaultDataConverter.java:84)
        at io.temporal.common.converter.DefaultDataConverter.newDefaultInstance(DefaultDataConverter.java:75)
        at io.temporal.common.converter.DefaultDataConverter.<clinit>(DefaultDataConverter.java:61)
        at io.temporal.internal.common.SearchAttributePayloadConverter.decodeAsType(SearchAttributePayloadConverter.java:135)
        at io.temporal.internal.common.SearchAttributesUtil.decodeAsType(SearchAttributesUtil.java:107)
        at io.temporal.internal.testservice.TestVisibilityStoreImpl.validateSearchAttributes(TestVisibilityStoreImpl.java:122)
        at io.temporal.internal.testservice.TestVisibilityStoreImpl.upsertSearchAttributesForExecution(TestVisibilityStoreImpl.java:96)
        at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.lambda$startWorkflow$27(TestWorkflowMutableStateImpl.java:1529)
        at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.update(TestWorkflowMutableStateImpl.java:336)
        at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.update(TestWorkflowMutableStateImpl.java:305)
        at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.startWorkflow(TestWorkflowMutableStateImpl.java:1527)
        at io.temporal.internal.testservice.TestWorkflowService.startWorkflowExecutionNoRunningCheckLocked(TestWorkflowService.java:361)
        at io.temporal.internal.testservice.TestWorkflowService.startWorkflowExecutionImpl(TestWorkflowService.java:269)
        at io.temporal.internal.testservice.TestWorkflowService.startWorkflowExecution(TestWorkflowService.java:202)
        at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$MethodHandlers.invoke(WorkflowServiceGrpc.java:5165)
        at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
        at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:355)
        at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:867)
        at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
        at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
        at java.base@17.0.6/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
        at java.base@17.0.6/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
        at java.base@17.0.6/java.lang.Thread.run(Thread.java:833)
        at org.graalvm.nativeimage.builder/com.oracle.svm.core.thread.PlatformThreads.threadStartRoutine(PlatformThreads.java:775)
        at org.graalvm.nativeimage.builder/com.oracle.svm.core.posix.thread.PosixPlatformThreads.pthreadStartRoutine(PosixPlatformThreads.java:203)
Caused by: java.lang.RuntimeException: Reflection code that publishes the methods signatures is out of sync with actual method signatures. Class 'io.temporal.internal.activity.ActivityTaskExecutors.POJOActivityImplementation' is expected to have method 'execute' with parameters {interface io.temporal.internal.activity.ActivityInfoInternal, interface com.uber.m3.tally.Scope}
        at io.temporal.internal.common.env.ReflectionUtils.getMethodNameForStackTraceCutoff(ReflectionUtils.java:39)
        at io.temporal.internal.activity.ActivityTaskHandlerImpl.<clinit>(ActivityTaskHandlerImpl.java:55)
        ... 27 more
```


## Steps to Reproduce the Problem

  1../temporal-test-server 7236 --enable-time-skipping

## Specifications

  - Version: 1.19.0
  - Platform: Mac



---

<a id="1711"></a>

### #1711: Start of child workflow from a cancelled workflow context needs test code coverage

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1711 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-22 16:01:21.000 UTC (2y 9m ago) |
| **Updated** | 2025-05-14 15:31:30.000 UTC |
| **Closed** | 2025-05-14 15:31:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A situation where we attempt to start a child workflow from a workflow scope that is already cancelled is not covered with unit tests.

See
https://coveralls.io/builds/57953701/source?filename=temporal-sdk%2Fsrc%2Fmain%2Fjava%2Fio%2Ftemporal%2Finternal%2Fsync%2FSyncWorkflowContext.java#L586


---

<a id="1694"></a>

### #1694: Make Serialization Context available for PayloadCodecs and PayloadConverters

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1694 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-09 05:21:53.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-15 21:20:41.000 UTC |
| **Closed** | 2023-03-15 21:20:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.19.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Some users need to have an access to some basic info like workflow id and activity id and task queue names in their `PayloadConverter` or `PayloadCodec`.
One of the typical scenarios is implementing a custom data conversion for a specific task queue or incorporating a `workflowId` into an encrypting codec as salt to sign payloads to be used in this workflow execution only. 


---

<a id="1692"></a>

### #1692: Implement workflow_start_delay in test server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1692 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2023-03-08 03:39:50.000 UTC (2y 10m ago) |
| **Updated** | 2025-03-31 17:06:30.000 UTC |
| **Closed** | 2025-03-31 17:06:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See API PR here: https://github.com/temporalio/api/pull/264


---

<a id="1685"></a>

### #1685: Add API to count workflows

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1685 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2023-03-03 21:55:48.000 UTC (2y 10m ago) |
| **Updated** | 2025-05-14 16:31:25.000 UTC |
| **Closed** | 2025-05-14 16:31:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

See parent issue for reference.


---

<a id="1682"></a>

### #1682: Add support for TerminateIfRunning WorkflowIdReusePolicy in Test Server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1682 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-03-01 01:17:27.000 UTC (2y 10m ago) |
| **Updated** | 2023-03-01 03:28:36.000 UTC |
| **Closed** | 2023-03-01 03:27:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | 1.19.0 |

#### Description

Test Server doesn't respect `WorkflowIdReusePolicy` `WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING`.
Test Server should terminate the running workflow and create a new one with this `WorkflowIdReusePolicy`.


---

<a id="1672"></a>

### #1672: LongLocalActivityFailsWhileHeartbeatingMeteringTest flakes in codecoverage runs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1672 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-23 16:42:04.000 UTC (2y 10m ago) |
| **Updated** | 2023-02-23 17:20:18.000 UTC |
| **Closed** | 2023-02-23 17:20:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

```
io.temporal.workflow.activityTests.LongLocalActivityFailsWhileHeartbeatingMeteringTest > testLongLocalActivityFailsWhileHeartbeatingMetering FAILED
    java.lang.AssertionError: expected:<[0, 2, 3, 1]> but was:<[0, 3, 3, 2]>
        at org.junit.Assert.fail(Assert.java:89)
        at org.junit.Assert.failNotEquals(Assert.java:835)
        at org.junit.Assert.assertEquals(Assert.java:120)
        at org.junit.Assert.assertEquals(Assert.java:146)
        at io.temporal.workflow.activityTests.LongLocalActivityFailsWhileHeartbeatingMeteringTest.testLongLocalActivityFailsWhileHeartbeatingMetering(LongLocalActivityFailsWhileHeartbeatingMeteringTest.java:92)
```

https://github.com/temporalio/sdk-java/actions/runs/4253865339/jobs/7399314593


---

<a id="1668"></a>

### #1668: Subsequent MutableSideEffect calls inside one Workflow Task may explode with non-determinism on replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1668 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-22 18:25:52.000 UTC (2y 10m ago) |
| **Updated** | 2024-12-17 21:19:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior

Consider a workflow that has 3 calls to the same ID back to back
...
encodedValue1 := workflow.MutableSideEffect(ctx, "id", ...)
encodedValue2 := workflow.MutableSideEffect(ctx, "id", ...)
encodedValue3 := workflow.MutableSideEffect(ctx, "id", ...)
...
And say encodedValue1==encodedValue2  and encodedValue3 are different on the original run. 
This makes 2 markers will be in history.
On replay the marker created by the third mutable side effect call will be applied to a second call instead causing a non-deterministic replay.

# Context

GoSDK: https://github.com/temporalio/sdk-go/issues/1014


---

<a id="1655"></a>

### #1655: Utilize Signal requestId field for signal gRPC retries deduplication

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1655 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-15 01:35:36.000 UTC (2y 10m ago) |
| **Updated** | 2024-12-27 17:43:27.000 UTC |
| **Closed** | 2024-12-27 17:43:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Temporal Server API exposes `SignalWorkflowExecutionRequest#request_id` that allows deduplicating (without guarantees) signal retry attempts. This allows deduplicating signal requests if the signal request experiences a gRPC error, but comes through from the Server point of view and gets retried.
Currently, JavaSDK doesn't utilize this mechanic

**Describe the solution you'd like**
Generate a unique UUID for each user-facing signal API and utilize `SignalWorkflowExecutionRequest#request_id`


---

<a id="1644"></a>

### #1644: ContextPropagator redesign

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1644 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-08 16:23:26.000 UTC (2y 11m ago) |
| **Updated** | 2025-05-13 16:51:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
The current Context propagator interface doesn't have an access to a reference to an entity it propagates to. For example a workflow or an activity instance. This doesn't allow the Context Propagator to get access to setters in the class.
ContextPropagator also is not aware if it propagates into a workflow or an activity at all, which makes it impossible to decide it `WorkflowThreadLocal` (`WorkflowLocal`) or a regular `ThreadLocal` should be used. 
See 
If `ThreadLocal` is used, ContextPropagator should have a lifecycle method to be able to clean the `ThreadLocal`. For example, a method that will be triggered at the end of an activity method.

**Describe the solution you'd like**
`ContextPropagator` should be reimplemented as Interceptors from scratch and its design should be reimplemented taking into account the points mentioned above.
See #525 for a proposed alternative to having `ContextPropagator` form a separate context that is accessible from Workflow and Activity code.

**Additional context**
The right approach would be a creation of a completely new `ContextPropagator` interface while leaving the old `ContextPropagator` in place, and deprecating it.


---

<a id="1642"></a>

### #1642: Add history pagination to Test Server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1642 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-06 19:52:52.000 UTC (2y 11m ago) |
| **Updated** | 2024-12-17 21:26:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior

Currently, Test Server never paginates the history and returns it always in one chunk. This makes the SDK internals that are getting triggered only if the server paginates testable only with the real server. 

## Expected Behavior

Pagination of the Test Server doesn't have to match the behavior of the real server, but it should be present and it should be configurable, so SDK developers can set a mode with aggressive pagination to improve test coverage.

Related to: #1639 #1638


---

<a id="1639"></a>

### #1639: Workers with java-sdk 1.18.0 experience "required property congestionInitialInterval not set"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1639 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-02-02 22:03:00.000 UTC (2y 11m ago) |
| **Updated** | 2023-02-02 22:04:03.000 UTC |
| **Closed** | 2023-02-02 22:04:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.1 |

#### Description

## Actual Behavior

Workers experience the following exception when starting processing workflow tasks for workflow that require pagination to fetch the whole workflow history from the Server.
This causes stuck workflows as Workers are unable to finish replay.

```
IllegalStateException("required property congestionInitialInterval not set")

io.temporal.serviceclient.RpcRetryOptions.validate(RpcRetryOptions.java:486)
io.temporal.internal.retryer.GrpcRetryer$GrpcRetryerOptions.validate(GrpcRetryer.java:97)
io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:42)
io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:60)
io.temporal.internal.replay.ServiceWorkflowHistoryIterator.queryWorkflowExecutionHistory(ServiceWorkflowHistoryIterator.java:122)
io.temporal.internal.replay.ServiceWorkflowHistoryIterator.hasNext(ServiceWorkflowHistoryIterator.java:87)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.applyServerHistory(ReplayWorkflowRunTaskHandler.java:218)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:204)
io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:153)
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:131)
io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:96)
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:337)
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:247)
io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:189)
io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:103)
java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
java.base/java.lang.Thread.run(Unknown Source),
```

Introduced in java-sdk v1.18.1


---

<a id="1634"></a>

### #1634: Add support for interceptor beans to Spring Boot

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1634 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-01-31 01:07:46.000 UTC (2y 11m ago) |
| **Updated** | 2025-05-05 21:45:40.000 UTC |
| **Closed** | 2025-05-05 21:45:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Users should be able to register interceptor beans in the Spring Boot context and these interceptors should be used for Workers and Client configuration.


---

<a id="1621"></a>

### #1621: Allow setting *additional* memo values in ContinueAsNewOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1621 |
| **State** | OPEN |
| **Author** | natthu-stripe (Natthu Bharambe) |
| **Created** | 2023-01-25 22:51:59.000 UTC (2y 11m ago) |
| **Updated** | 2023-01-25 22:51:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We have an abstraction for starting workflows that sets some standard memo values. I have a new use case where I'd like to continue-as-new a workflow execution (started using the above mentioned abstraction) but when doing so, set a few additional memo values that the next run would read. Today, `ContinueAsNewOptions` allows setting the entire memo map (using `ContinueAsNewOptions.newBuilder().setMemo()`). Thus, in order to *add* new memo values to the next run while preserving existing values, we need to extract all the values (which requires knowing the entire key set) and then merging those with the new values. There is currently no API to either list all keys present in the memo, or to fetch the entire memo structure.

**Describe the solution you'd like**
Ideally, `ContinueAsNewOptions.Builder` should provide an `addMemo(key, value)` method which overrides the value in the current execution's memo if present, or else, adds it to the next workflow execution.

**Describe alternatives you've considered**
Alternative approaches:
1/ add the memo values to the next workflow's arguments (leaky abstraction) 
2/ maintain a list of all known memo keys and use that to extract the entire memo when building `ContinueAsNewOptions`.



---

<a id="1619"></a>

### #1619: Support for Spring Boot 3.0 in integration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1619 |
| **State** | CLOSED |
| **Author** | jrogers (Jeff Rogers) |
| **Created** | 2023-01-25 20:32:54.000 UTC (2y 11m ago) |
| **Updated** | 2023-01-26 18:52:27.000 UTC |
| **Closed** | 2023-01-26 18:52:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Temporal Spring Boot Integration is not compatible with Spring Boot 3.0. One specific issue is that `spring.factories` is no longer supported for enabling autoconfiguration, it was deprecated in 2.7 and removed in 3.0 - see https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide#auto-configuration-files. However there may be other issues.

**Describe the solution you'd like**

Adding support, making changes where necessary (backwards compatibility may be possible).




---

<a id="1618"></a>

### #1618: Test server with child workflow and signal is timing out when attemping unlock-with-sleep

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1618 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-25 20:14:13.000 UTC (2y 11m ago) |
| **Updated** | 2024-11-19 19:01:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Steps to Reproduce the Problem

Take this Python program:

```python
import asyncio
import logging
from datetime import timedelta
import time

from temporalio import workflow
from temporalio.testing import WorkflowEnvironment
from temporalio.worker import Worker


@workflow.defn
class SubWorkflow:
    def __init__(self) -> None:
        self.signal_received = False

    @workflow.run
    async def run(self) -> bool:
        try:
            await workflow.wait_condition(
                lambda: self.signal_received, timeout=timedelta(days=2)
            )
            return True
        except asyncio.TimeoutError:
            return False

    @workflow.signal
    def some_signal(self) -> None:
        self.signal_received = True


@workflow.defn
class TopWorkflow:
    def __init__(self) -> None:
        self.signal_received = False

    @workflow.run
    async def run(self) -> bool:
        try:
           # test passes if child workflow is not started.
            await workflow.start_child_workflow(
                SubWorkflow.run, id="swf1", task_queue="tq1"
            )
            await workflow.wait_condition(
                lambda: self.signal_received, timeout=timedelta(days=3)
            )
            return True
        except asyncio.TimeoutError:
            return False

    @workflow.signal
    def some_signal(self) -> None:
        self.signal_received = True


async def main():
    logging.info("Starting time skipping")
    async with await WorkflowEnvironment.start_time_skipping() as env:
        logging.info("Disabling auto time skipping")
        with env.auto_time_skipping_disabled():
            logging.info("Starting worker")
            async with Worker(
                env.client,
                task_queue="tq1",
                workflows=[TopWorkflow, SubWorkflow],
                debug_mode=True,
            ):
                logging.info("Starting workflow")
                handle = await env.client.start_workflow(
                    TopWorkflow.run, id="wf1", task_queue="tq1"
                )

                logging.info("Sleeping 1 day")
                await env.sleep(timedelta(days=1))

                logging.info("Signalling workflow")
                await handle.signal(TopWorkflow.some_signal)

                logging.info("Sleeping 1 day again")
                await env.sleep(timedelta(days=1))

                logging.info("Sleeping 2 days")
                await env.sleep(timedelta(days=2))

                logging.info("Sleeping 3 days")
                await env.sleep(timedelta(days=3))

                logging.info("Done")

if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    asyncio.run(main())
```

What that does is start a parent workflow that starts a child (but doesn't wait on completion) and then completes itself when a signal is sent. Those `env.sleep` calls are `UnlockTimeSkippingWithSleep`. When run including the core "activations" (events to handle) and "completions" (the commands to send to server), the logs from my Windows scratch run are:

```
DEBUG:asyncio:Using proactor: IocpProactor
INFO:root:Starting time skipping
INFO:root:Disabling auto time skipping
INFO:root:Starting worker
INFO:root:Starting workflow
INFO:root:Sleeping 1 day
DEBUG:temporalio.worker._workflow:Received workflow activation:
run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
timestamp {
  seconds: 1674677060
  nanos: 338000000
}
history_length: 3
jobs {
  start_workflow {
    workflow_type: "TopWorkflow"
    workflow_id: "wf1"
    randomness_seed: 14816511849120529847
    identity: "19760@cretz-laptop"
    workflow_execution_timeout {
      seconds: 315360000
    }
    workflow_run_timeout {
      seconds: 315360000
    }
    workflow_task_timeout {
      seconds: 10
    }
    first_execution_run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
    attempt: 1
    start_time {
      seconds: 1674677060
      nanos: 338000000
    }
  }
}

DEBUG:temporalio.worker._workflow:Sending workflow completion:
run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
successful {
  commands {
    start_child_workflow_execution {
      seq: 1
      namespace: "default"
      workflow_id: "swf1"
      workflow_type: "SubWorkflow"
      task_queue: "tq1"
      parent_close_policy: PARENT_CLOSE_POLICY_TERMINATE
      workflow_id_reuse_policy: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
      cancellation_type: WAIT_CANCELLATION_COMPLETED
    }
  }
}

DEBUG:temporalio.worker._workflow:Received workflow activation:
run_id: "de8567d0-7f5b-4447-a16d-d21c64db9b81"
timestamp {
  seconds: 1674677060
  nanos: 350000000
}
history_length: 3
jobs {
  start_workflow {
    workflow_type: "SubWorkflow"
    workflow_id: "swf1"
    randomness_seed: 15491585649214177938
    parent_workflow_info {
      namespace: "default"
      workflow_id: "wf1"
      run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
    }
    workflow_execution_timeout {
      seconds: 315360000
    }
    workflow_run_timeout {
      seconds: 315360000
    }
    workflow_task_timeout {
      seconds: 10
    }
    first_execution_run_id: "de8567d0-7f5b-4447-a16d-d21c64db9b81"
    attempt: 1
    memo {
    }
    search_attributes {
    }
    start_time {
      seconds: 1674677060
      nanos: 350000000
    }
  }
}

DEBUG:temporalio.worker._workflow:Received workflow activation:
run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
timestamp {
  seconds: 1674677060
  nanos: 350000000
}
history_length: 8
jobs {
  resolve_child_workflow_execution_start {
    seq: 1
    succeeded {
      run_id: "de8567d0-7f5b-4447-a16d-d21c64db9b81"
    }
  }
}

DEBUG:temporalio.worker._workflow:Sending workflow completion:
run_id: "de8567d0-7f5b-4447-a16d-d21c64db9b81"
successful {
  commands {
    start_timer {
      seq: 1
      start_to_fire_timeout {
        seconds: 172800
      }
    }
  }
}

DEBUG:temporalio.worker._workflow:Sending workflow completion:
run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
successful {
  commands {
    start_timer {
      seq: 1
      start_to_fire_timeout {
        seconds: 259200
      }
    }
  }
}

INFO:root:Signalling workflow
INFO:root:Sleeping 1 day again
DEBUG:temporalio.worker._workflow:Received workflow activation:
run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
timestamp {
  seconds: 1674763460
  nanos: 341000000
}
history_length: 13
jobs {
  signal_workflow {
    signal_name: "some_signal"
    identity: "19760@cretz-laptop"
  }
}

DEBUG:temporalio.worker._workflow:Sending workflow completion:
run_id: "dd5d5ce5-81be-46cc-86b3-046d6ab3a027"
successful {
  commands {
    cancel_timer {
      seq: 1
    }
  }
  commands {
    complete_workflow_execution {
      result {
        metadata {
          key: "encoding"
          value: "json/plain"
        }
        data: "true"
      }
    }
  }
}

INFO:root:Sleeping 2 days
DEBUG:temporalio.worker._workflow:Received workflow activation:
run_id: "de8567d0-7f5b-4447-a16d-d21c64db9b81"
timestamp {
  seconds: 1674849860
  nanos: 360000000
}
history_length: 8
jobs {
  fire_timer {
    seq: 1
  }
}

DEBUG:temporalio.worker._workflow:Sending workflow completion:
run_id: "de8567d0-7f5b-4447-a16d-d21c64db9b81"
successful {
  commands {
    complete_workflow_execution {
      result {
        metadata {
          key: "encoding"
          value: "json/plain"
        }
        data: "false"
      }
    }
  }
}

INFO:temporalio.worker._worker:Beginning worker shutdown, will wait 0:00:00 before cancelling activities
Traceback (most recent call last):
  File "c:\work\tem\tem-discover\scratch-python\.venv\Lib\site-packages\temporalio\service.py", line 723, in _rpc_call
    resp = await client.call(
           ^^^^^^^^^^^^^^^^^^
  File "c:\work\tem\tem-discover\scratch-python\.venv\Lib\site-packages\temporalio\bridge\client.py", line 126, in call
    resp.ParseFromString(await resp_fut)
                         ^^^^^^^^^^^^^^
temporal_sdk_bridge.RPCError: (1, 'Timeout expired', b'')

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\work\tem\tem-discover\scratch-python\scratch6\scratch.py", line 91, in <module>
    asyncio.run(main())
  File "C:\Users\user\AppData\Local\Programs\Python\Python311\Lib\asyncio\runners.py", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File "C:\Users\user\AppData\Local\Programs\Python\Python311\Lib\asyncio\runners.py", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\user\AppData\Local\Programs\Python\Python311\Lib\asyncio\base_events.py", line 650, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "c:\work\tem\tem-discover\scratch-python\scratch6\scratch.py", line 82, in main
    await env.sleep(timedelta(days=2))
  File "c:\work\tem\tem-discover\scratch-python\.venv\Lib\site-packages\temporalio\testing\_workflow.py", line 425, in sleep
    await self._client.test_service.unlock_time_skipping_with_sleep(req)
  File "c:\work\tem\tem-discover\scratch-python\.venv\Lib\site-packages\temporalio\service.py", line 658, in __call__
    return await self.service_client._rpc_call(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\work\tem\tem-discover\scratch-python\.venv\Lib\site-packages\temporalio\service.py", line 738, in _rpc_call
    raise RPCError(message, RPCStatusCode(status), details)
temporalio.service.RPCError: Timeout expired
```

What seems to be happening is the child is started, the signal is sent causing the parent workflow to complete, but the child is not cancelled or whatever. Then the 2 day sleep properly causes the child timeout timer to trigger causing it to complete as expected, but that `env.sleep(timedelta(days=2))` doesn't return for several seconds before test service gRPC times it out.

If you remove the sending of the signal or the starting of the child workflow there are no errors. Sorry it's in Python and may be a big replication, I can probably write in Java if needed.

Sorry if this is the same #1540, I did not dig into that one.


---

<a id="1615"></a>

### #1615: TemporalFailure thrown from Signal method should fail Workflow Execution 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1615 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-01-24 21:59:03.000 UTC (2y 11m ago) |
| **Updated** | 2023-01-25 18:01:38.000 UTC |
| **Closed** | 2023-01-25 18:01:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

## Expected Behavior

`ActivityFailure` or `ApplicationFailure` that are thrown from a signal method should fail Workflow Execution the same way it works with Workflow Method code.

## Actual Behavior

Currently any TemporalFailure thrown from Signal fails Workflow Task leading to an infinite loop

## Reproduction

https://github.com/Spikhalskiy/java-sdk/commit/f65023cead1d60f17c209af44d1600ed268b00ff



---

<a id="1601"></a>

### #1601: Query on a stub used to start a workflow unexpectedly targets only the first run

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1601 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2023-01-13 18:04:32.000 UTC (2y 12m ago) |
| **Updated** | 2023-01-23 20:32:09.000 UTC |
| **Closed** | 2023-01-23 20:32:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | 1.18.0 |

#### Description

## Expected Behavior

The query for a WorkflowStub that wasn't created for a specific runId should target the latest run of the workflow and follow ContinueAsNew chain.

## Actual Behavior

The expected behavior holds for a WorkflowStub explicitly created without a runId. But if this stub is used to start a workflow, after this start call the query targets the specific run that was started by this stub.


---

<a id="1587"></a>

### #1587: Fix javadoc for ActivityExecutionContext.getHeartbeatDetails‚Äã and consider adding getLastHeartbeatDetails‚Äã

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1587 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-05 13:23:56.000 UTC (3 years ago) |
| **Updated** | 2025-05-27 20:36:30.000 UTC |
| **Closed** | 2025-05-27 20:36:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

The javadoc for `ActivityExecutionContext.getHeartbeatDetails` says:

> Extracts Heartbeat details from the last failed attempt

But code reveals this is actually updated for each heartbeat call within the activity. So we should update that javadoc.

Also, to match other SDKs, we should probably have a `getLastHeartbeatDetails` that does not get updated on each heartbeat call.


---

<a id="1586"></a>

### #1586: Opt-in to having stack trace query use custom data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1586 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2023-01-05 13:17:59.000 UTC (3 years ago) |
| **Updated** | 2023-08-30 18:53:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | 1.20.0 |

#### Description

**Describe the solution you'd like**

Make a new worker option that lets the custom data converter (encoder, etc) be used for `__stack_trace` queries like it is for the rest of the queries if `true`, otherwise can leave current behavior of default converter if `false` (the default).



---

<a id="1579"></a>

### #1579: [Feature Request] Improving replay issue for Timers

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1579 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-12-22 18:35:13.000 UTC (3 years ago) |
| **Updated** | 2022-12-22 18:35:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently timers create a different execution history if timer / sleep duration is <=0 or > 0. A number of users a running into problems on internal workflow replay for this. It would be nice to add some checks to reduce the number of non-deterministic errors timer duration can lead to. 


---

<a id="1563"></a>

### #1563: Local Activity Execution should stop making attempts if Workflow Task or subsequent heartbeat fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1563 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-12-08 05:59:54.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-08 05:59:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Right now Local Activity Execution is not aware of the lifecycle of the Workflow Task that started this execution.
If Workflow Task (or one of its subsequent heartbeats) is already failed, Local Activity will continue execution.
If there is no `scheduleToClose` timeout set or `scheduleToClose` is long, such an orphan local activity can retry for a long time. 

**Describe the solution you'd like**
Local Activity Execution should stop making new attempts if the workflow task caused this execution is failed.

**Additional context**
This task should likely be coupled with the implementation of Local Activity Cancelations: #1303


---

<a id="1562"></a>

### #1562: Please return OriginalExecutionRunID in Workflow info

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1562 |
| **State** | CLOSED |
| **Author** | lexi-indeed |
| **Created** | 2022-12-08 00:50:44.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-27 18:24:13.000 UTC |
| **Closed** | 2023-01-27 18:24:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
I would like to fetch the OriginalExecutionRunID but I can't get it either by searchable attributes or workflow info.

**Describe the solution you'd like**
Please return OriginalExecutionRunID in Workflow info





---

<a id="1561"></a>

### #1561: Unregistered Local Activity should fail Workflow Task

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1561 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-12-07 00:58:27.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-30 20:58:09.000 UTC |
| **Closed** | 2023-01-30 20:58:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
We should fail workflow task if workflow code requests the execution of a local activity that is not registered with the worker.
Such a scenario shouldn't fail activity execution.


---

<a id="1553"></a>

### #1553: FailureConverter API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1553 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-12-01 13:28:03.000 UTC (3y 1m ago) |
| **Updated** | 2023-02-14 23:26:22.000 UTC |
| **Closed** | 2023-02-14 23:26:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | mjameswh |
| **Milestone** | None |

#### Description

Add public `FailureConverter` API to allow customizing error <-> failure conversion and `DefaultFailureConverter` implementation that supports encrypting common failure attributes (`message`, `stack_trace`).

This API was added to the other 3 major SDKs already.


---

<a id="1549"></a>

### #1549: Metric scope for workflow instance should ignore metrics written after a destruction of the instance is requested

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1549 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-11-30 02:48:53.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-30 02:48:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Users should be able to use Workflow's `MetricScope` obtained from `Workflow.getMetricsScope()` in a workflow's `finally` blocks without accounting for `DestroyWorkflowThreadError` that may happen unexpectedly and uncontrollably.

## Actual Behavior

`DestroyWorkflowThreadError` triggers finally blocks and lead to double-reporting of metrics on workflow instance eviction.

## Solution

Temporal SDK should make workflow's `MetricsScope` aware of the fact that the instance destruction is requested and not allow any new metric's reporting in this case.


---

<a id="1538"></a>

### #1538: Test service continue-as-new implementation is not atomic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1538 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-11-26 19:54:48.000 UTC (3y 1m ago) |
| **Updated** | 2025-05-15 02:20:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
No signal is rejected when sent to a workflow that calls continue as new.

## Actual Behavior
Signal sender can receive NOT_FOUND if it is sent while target workflow is executing continue-as-new.



## Steps to Reproduce the Problem

See https://github.com/temporalio/sdk-java/pull/1537 for reproduction.




---

<a id="1535"></a>

### #1535: Improve diagnostic message printed by TestWorkflowRule on timeout.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1535 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-11-26 03:33:34.000 UTC (3y 1m ago) |
| **Updated** | 2022-11-26 04:03:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When JUnit test timeouts (because a timeout was specified), the TestWorkflowRule prints out a diagnostic message that contains
histories of all workflows started by the test. This is useful, but misses a lot of useful information that could be used to troubleshoot a stuck test problem. 

Some of the potential additions:

* Result of DescribeWorkflowExecution call for each workflow. Especially useful information about activities and workflow tasks in retry.
* Stack trace query result for each open workflow.
* I would also improve the formatting of the printed history


---

<a id="1533"></a>

### #1533: Error in a local activity should fail the WorkflowTask instead of failing an activity execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1533 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-11-23 20:51:32.000 UTC (3y 1m ago) |
| **Updated** | 2023-01-09 18:45:02.000 UTC |
| **Closed** | 2023-01-09 18:45:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Current behavior

Currently, Local Activities lack graceful support for Errors that may happen in the Activity thread. If this happens we fail the local activity execution with `RetryState.RETRY_STATE_INTERNAL_SERVER_ERROR`. 

# Expected behavior

If Local Activity throws an `Error`, it should immediately fail Workflow Task. Java Error signals a problem with the Worker and shouldn't lead to a failure of a Local Activity execution or a Workflow.


---

<a id="1532"></a>

### #1532: io.temporal.api is not included in the distributed javadoc.jar for temporal-serviceclient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1532 |
| **State** | CLOSED |
| **Author** | antmendoza (Antonio Mendoza P√©rez) |
| **Created** | 2022-11-23 14:35:32.000 UTC (3y 1m ago) |
| **Updated** | 2022-12-06 22:12:43.000 UTC |
| **Closed** | 2022-12-06 22:12:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | 1.18.0 |

#### Description

**Is your feature request related to a problem? Please describe.**

The artifact temporal-serviceclient.jar contains classes in the package io.temporal.api, however the javadoc.jar artifact does not contain documentation for the mentioned package (io.temporal.api)  
https://www.javadoc.io/doc/io.temporal/temporal-serviceclient/

It would be nice to have the same content for compiled, source and javadoc artifacts.


---

<a id="1512"></a>

### #1512: Add scheduleToStart to LocalActivityOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1512 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-11-10 03:30:07.000 UTC (3y 2m ago) |
| **Updated** | 2022-12-09 02:38:14.000 UTC |
| **Closed** | 2022-12-09 02:38:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Local Activities Workers can be saturated in the same way as a regular Activity Workers. 
Temporal SDK should provide a way to set and limit `scheduleToStart` for Local Activities.


---

<a id="1510"></a>

### #1510: Investigate and fix graceful shutdown problems 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1510 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-11-09 16:11:00.000 UTC (3y 2m ago) |
| **Updated** | 2025-05-15 02:13:30.000 UTC |
| **Closed** | 2025-05-15 02:13:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | Next |

#### Description

## Actual Behavior

From the investigation of a user problem:
- [x] `worker.suspendPolling` stops local activity worker from polling. This leads to workflow tasks with local activities getting stuck in a heartbeat loop without making progress. Local activity poller should never stop polling. Local activity poller is an implementation detail and the only source it polls from is an internal worker queue.
- [ ] User reported fact: During worker shutdown some activities are getting distributed to the worker (server registers the dispatch and an attempt), but never start execution on this worker that is shutting down. Theory: Worker long-poll thread can be interrupted when the server has already registered an attempt and already sent the task to the worker, but the worker didn't receive the task yet. Potential mitigation to think through: Server in this scenario should've to get CANCELLED (https://gitter.im/grpc/grpc?at=5afd98b79ad18967b9f2c464) and may register an activity failure.


---

<a id="1494"></a>

### #1494: Multi-history replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1494 |
| **State** | CLOSED |
| **Author** | Sushisource (Spencer Judge) |
| **Created** | 2022-10-24 21:48:09.000 UTC (3y 2m ago) |
| **Updated** | 2022-10-26 16:58:11.000 UTC |
| **Closed** | 2022-10-26 16:58:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

Multi-history replay support a-la what's already been done in TS/Python


---

<a id="1463"></a>

### #1463: Spring Boot - auto configured TestWorkflowEnvironment not registering data converter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1463 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-09-27 04:25:58.000 UTC (3y 3m ago) |
| **Updated** | 2023-01-26 17:27:01.000 UTC |
| **Closed** | 2023-01-26 17:27:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

          @Autowired
          TestWorkflowEnvironment testWorkflowEnvironment;

In tests testWorkflowEnvironment does not take in account any test configuration beans of type DataConverter
and does not register them in its WorkflowClientOptions


---

<a id="1457"></a>

### #1457: State machine exception during termination

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1457 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-09-25 20:28:34.000 UTC (3y 3m ago) |
| **Updated** | 2024-12-17 21:26:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Actual Behavior

During a load test, the following exception happened once:

```
‚îÇ 19:42:15.247 [Workflow Executor taskQueue="xxx", namespace="yyy": 311] WARN  i.t.i.r.ReplayWorkflowTaskHandler - Workflow task processing failure. startedEventId=17, WorkflowId=89ecf1a ‚îÇ
‚îÇ io.temporal.internal.statemachines.InternalWorkflowTaskException: Failure handling event 19 of type 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED' during replay. {WorkflowTaskStartedEventId=17, CurrentStartedEventId=1 ‚îÇ
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.createEventProcessingException(WorkflowStateMachines.java:257)                                                                
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:236)                                                                                   
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:208)                                                                                                
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.applyServerHistory(ReplayWorkflowRunTaskHandler.java:208)                                                                                          
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:192)                                                                                
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:147)                                                                              
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:132)                                                      
‚îÇ     at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:97)                                                 
‚îÇ     at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:336)                                                                                     
‚îÇ     at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:246)                                                                         
‚îÇ     at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:188)                                                                                      
‚îÇ     at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)                                                                   
‚îÇ     at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)                                          
‚îÇ     at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)                                            
‚îÇ     at java.base/java.lang.Thread.run(Thread.java:829)                                                                                                                    
‚îÇ Caused by: java.lang.IllegalArgumentException: Unexpected event:event_id: 19                                                                              
‚îÇ event_time {                                                                                                                                              
‚îÇ   seconds: 1664134935                                                                                                                              
‚îÇ   nanos: 131416185                                                                                                                                 
‚îÇ }                                                                                                                                                                 
‚îÇ event_type: EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED                                                                          
‚îÇ version: 1023                                                                                                                                                
‚îÇ task_id: 186665257                                                                                                                                     
‚îÇ workflow_execution_terminated_event_attributes {                                                                                                 
‚îÇ }                                                                                                                                                                                  
‚îÇ                                                                                                                                                                               
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleNonStatefulEvent(WorkflowStateMachines.java:521)                                       
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleSingleEvent(WorkflowStateMachines.java:282)                                                  
‚îÇ     at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:234)                                                 
‚îÇ     ... 13 common frames omitted
```

The history of this execution wasn't saved, but there are two full normal histories of Parent and Child workflows from that test attached.
[histories.zip](https://github.com/temporalio/sdk-java/files/9641719/histories.zip)



---

<a id="1456"></a>

### #1456: Pollers should use just one thread to perform async gRPC requests

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1456 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-09-25 20:12:41.000 UTC (3y 3m ago) |
| **Updated** | 2025-06-11 20:30:47.000 UTC |
| **Closed** | 2025-06-11 20:30:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, we allocate a lot of physical threads to perform blocking gRPC long poll requests. This doesn't make sense as it creates a lot of semi-active threads with a lot of context switching that just does a blocking io inside.

**Describe the solution you'd like**
We should have two threads for Pollers. One for Workflow Task Pollers, one for Activity Task Pollers. They should handle all corresponding long poll requests in an async manner.


---

<a id="1440"></a>

### #1440: Reflect activity vs local activity difference in tracing spans

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1440 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-09-16 16:43:46.000 UTC (3y 3m ago) |
| **Updated** | 2022-09-16 16:43:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now tracing spans created for normal and local activities have the same exact prefix like "startactivity" and "runactivity".
Looking at the spans themselves it may be tricky to understand which ones are local and which ones are remote.



---

<a id="1429"></a>

### #1429: Test server does not error on already-started child workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1429 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-14 15:35:38.000 UTC (3y 3m ago) |
| **Updated** | 2024-11-19 19:01:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Should be able to start a child workflow, then when I try to start it again, it should error

## Actual Behavior

Nothing comes back erroring on the second child start attempt. This may also be related to #1220 since it may be using `WorkflowExecutionAlreadyStartedFailure` internally, but I don't see any error in stdout/stderr.


---

<a id="1427"></a>

### #1427: Test server heartbeat timeout issue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1427 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-14 14:37:35.000 UTC (3y 3m ago) |
| **Updated** | 2022-11-15 16:23:34.000 UTC |
| **Closed** | 2022-11-15 16:23:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

An activity with a heartbeat timeout of 1s that does a heartbeat then sleeps for 3s should give the workflow a heartbeat timeout

## Actual Behavior

Does not heartbeat timeout


---

<a id="1425"></a>

### #1425: Test server not populating DescribeWorkflowExecutionResponse.workflow_execution_info.task_queue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1425 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-09-14 13:52:39.000 UTC (3y 3m ago) |
| **Updated** | 2024-12-23 12:55:08.000 UTC |
| **Closed** | 2024-12-23 12:55:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Populate `DescribeWorkflowExecutionResponse.workflow_execution_info.task_queue`. I know `DescribeWorkflowExecutionResponse.execution_config.task_queue` is populated, but this should be too.


---

<a id="1413"></a>

### #1413: Deduplicate getResultAsync calls inside WorkflowClient or WorkflowStub

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1413 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-09-10 22:30:31.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-10 22:30:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
If users call getResultAsync on the same stub several times or if they call getResultAsync on different stubs for the same workflow execution, SDK will open a new long poll for each such request.

**Describe the solution you'd like**
SDK should deduplicate such calls and open only one long poll under the hood as an optimization, so users don't have to think about it in their code.

**Additional context**
This task should likely be paired with https://github.com/temporalio/sdk-java/issues/1212, as both require changes in the internal structure of the same area of SDK code.



---

<a id="1412"></a>

### #1412: Setting MetricsScope on TestEnvironmentOptions is confusing 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1412 |
| **State** | CLOSED |
| **Author** | pratyoosh (prat) |
| **Created** | 2022-09-09 22:33:49.000 UTC (3y 4m ago) |
| **Updated** | 2022-11-18 14:47:07.000 UTC |
| **Closed** | 2022-11-18 14:47:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

## Expected Behavior
Create TestEnvironmentOptions with you MeterRegistry 
```
TestEnvironmentOptions testEnvironmentOptions = TestEnvironmentOptions.newBuilder().setWorkflowServiceStubsOptions(
                        WorkflowServiceStubsOptions.newBuilder()
                                .setMetricsScope(new RootScopeBuilder()
                                        .reporter(new MicrometerClientStatsReporter(meterRegistry))
                                        .reportEvery(com.uber.m3.util.Duration.ofSeconds(10)))
                                .build()
                )...
```
                
Create TestEnvironment for your tests using `TestWorkflowEnvironment.newInstance(testEnvironmentOptions);`
Execute your tests, check metrics for Worker & Client were reported to your MeterRegistry.
## Actual Behavior
Worker & Client are not reported to your MeterRegistry, unless MeterRegistry is registered using 
```
testEnvironmentOptions = TestEnvironmentOptions.newBuilder()
                .setMetricsScope(new RootScopeBuilder()
                        .reporter(new MicrometerClientStatsReporter(temporalConfig.getTelemetryConfig().getMeterRegistry()))
                        .reportEvery(com.uber.m3.util.Duration.ofSeconds(10)))

```
This is different that documented behavior where Metrics scope must be supplied via WorkflowServiceOptions

## Specifications

  - Version: SDK 1.14
  - Platform: Mac OS 12.5/ Open JDK 11 



---

<a id="1408"></a>

### #1408: addWorkflowImplementationFactory with no ImplementationOptions fails workflow execution on any Throwable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1408 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-09-07 19:18:59.000 UTC (3y 4m ago) |
| **Updated** | 2022-09-08 15:48:22.000 UTC |
| **Closed** | 2022-09-08 15:48:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.17.0 |

#### Description

## Expected Behavior

The default behavior of Temporal Workers, if there is non-`TemporalFailure` exception thrown in the workflow, is to fail a workflow task.
This is configured by `WorkflowImplementationOptions#setFailWorkflowExceptionTypes`.

## Actual Behavior

If users use
```
Worker#registerWorkflowImplementationTypes(Class<?>... workflowImplementationClasses)
Worker#registerWorkflowImplementationTypes(WorkflowImplementationOptions options, Class<?>... workflowImplementationClasses)
Worker#addWorkflowImplementationFactory(WorkflowImplementationOptions options, Class<R> workflowInterface, Func<R> factory)
```
the methods behave as expected and if the user doesn't override `WorkflowImplementationOptions#setFailWorkflowExceptionTypes` non-`TemporalFailure` exceptions in Workflow code don't fail a workflow execution.

But if
```
addWorkflowImplementationFactory(Class<R> workflowInterface, Func<R> factory)
```

if used, `Throwable` is set into `WorkflowImplementationOptions#setFailWorkflowExceptionTypes` by the underlying implementation.

this difference is completely unexpected by users and undocumented and I guess it was done for a backwards compatibility in the future, but now it leads to great confusion.


---

<a id="1403"></a>

### #1403: Test Server should add warning logging if no workers listen on a task queue with tasks

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1403 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-31 22:37:27.000 UTC (3y 4m ago) |
| **Updated** | 2024-11-19 19:04:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
A typical user mistake in unit tests which may be a little tricky for users to realize is forgetting to register workers on all the queues that participate in a unit test. This situation typically leads to a test timeout that has no useful information to understand the root cause.

**Describe the solution you'd like**
The test server may print warning log messages if there are tasks getting scheduled on a task queue that nobody listens on.


---

<a id="1398"></a>

### #1398: Align Test Server behavior with the real one if WorkflowExecutionCompleted is not the last command

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1398 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-30 20:08:35.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-31 00:15:54.000 UTC |
| **Closed** | 2022-08-31 00:15:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.17.0 |

#### Description

## Expected Behavior

If a workflow (or an SDK) is written in the way that the workflow is completed before some other operations (like an asynchronous local activity), the Test Server should reject such a workflow task with a text message aligned with a real Temporal server. 

## Actual Behavior

TestServer actually accepts this workflow and completes the workflow.



---

<a id="1396"></a>

### #1396: Set larger maxInboundMetadataSize to accommodate unbounded Server error messages

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1396 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-30 19:52:01.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-31 22:43:51.000 UTC |
| **Closed** | 2022-08-31 22:43:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.17.0 |

#### Description

Server [sometimes sends unbounded error messages](https://github.com/temporalio/temporal/issues/3284) that don't fit into a standard HTTP/2 headers limit.
The solution proposed in https://github.com/temporalio/sdk-features/issues/122 is to set the `maxInboundMetadataSize` to 4Mb (from the default 8Kb) to accommodate these scenarios.


---

<a id="1377"></a>

### #1377: Predictable log statement when test server is ready for use

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1377 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2022-08-18 18:41:23.000 UTC (3y 4m ago) |
| **Updated** | 2024-11-20 21:01:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

External SDKs need to know when the test server is up and ready to use. Today SDKs just continually try to open a socket until it succeeds. Also, users might want to know also.

**Describe the solution you'd like**

Create some kind of output (stdout or stderr) that is somewhat predictable (e.g. starts with a common string or something) and would be the _first_ output of the test server process when the server is successfully started and ready for use. This way an SDK can wait for the first bit of stdout or stderr to know whether something failed or server has started.


---

<a id="1370"></a>

### #1370: Add an ability to register custom DataConverter in Spring Boot Autoconfiguration

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1370 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-16 05:07:26.000 UTC (3y 4m ago) |
| **Updated** | 2022-08-17 18:08:53.000 UTC |
| **Closed** | 2022-08-17 18:08:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | 1.16.0 |

#### Description

**Describe the solution you'd like**
Spring Boot Starter should provide the ability to register custom data converters


---

<a id="1354"></a>

### #1354: Unit Test for  ActivityCompletionClient methods that don't use taskToken

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1354 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-10 03:18:17.000 UTC (3y 5m ago) |
| **Updated** | 2024-12-17 21:20:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

All the methods of `ActivityCompletionClient` that don't use task token and use `String workflowId, Optional<String> runId, String activityId` instead are unused and untested.
The same is `ManualActivityCompletionClientImpl` codepaths that work when `workflowId` + `activityId` are specified instead of `taskToken`.

These methods should be covered with basic unit tests.


---

<a id="1350"></a>

### #1350: Wire #reason parameter in workflow cancellation request

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1350 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-08 15:58:53.000 UTC (3y 5m ago) |
| **Updated** | 2025-05-14 17:19:23.000 UTC |
| **Closed** | 2025-05-14 17:19:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Server added RequestCancelWorkflowExecutionRequest#reason field for cancellation requests. 
JavaSDK should allow this field to be set the same way it's allowed for termination requests.


---

<a id="1348"></a>

### #1348: Query to a workflow that was failed by the workflow code produces noisy Error log with not enough context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1348 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-05 23:28:53.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-08 21:38:28.000 UTC |
| **Closed** | 2022-08-08 21:38:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |

#### Description

If a workflow code throws an exception that is failing the workflow, it's getting logged by the worker.
If such a completed with a failure workflow is getting queried, the replay produces the same exact log with an ERROR level and without any additional context that would allow understanding that this exception was effectively "replayed" by the query.

An exception header:

```
2022-08-05 13:22:09.172 [ERROR] 21413 --- [af-5dce1629454d] al.internal.sync.WorkflowExecuteRunnable : Workflow execution failure WorkflowId=entityUrn=urn:indeed:icims-requisition-id:39410&&jobseekerUrn=urn:indeed:icims-candidate-id:testingWithApplicationFailureWithoutAnnotation, RunId=645d1209-6c95-4d06-aeaf-5dce1629454d, WorkflowType=HiringProfessionalWorkflow
io.temporal.failure.ApplicationFailure: message='Unsupported Chart: chartId', type='com.indeed.wayfinder.expedition.host.workflows.hiring.professional.exception.UnsupportedChartException', nonRetryable=true
```

History structure:
```
WorkflowExecutionStarted
WorkflowTaskScheduled
WorkflowTaskStarted
WorkflowTaskCompleted
MarkerRecorded (Version)
MarkerRecorded (Local Activity)
WorkflowExecutionFailed
```

**Describe the solution you'd like**

The original exception should be transformed into Warning from the Error.
The exception that happens in a query-only execution should be on Debug level and contain an additional context that allows to at least track back a query that causes this execution.


---

<a id="1345"></a>

### #1345: Data Converters should have method deserializing all the Payloads at once

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1345 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-08-04 20:37:42.000 UTC (3y 5m ago) |
| **Updated** | 2023-04-21 16:03:06.000 UTC |
| **Closed** | 2023-04-21 16:03:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.20.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently `DataConverter` interface has a random access method that allows deserializing an object on the specific index:
```
  <T> T fromPayloads(
      int index, Optional<Payloads> content, Class<T> valueType, Type valueGenericType)
```
And an additional static helper method that allows reading all the objects from `Payloads`:
```
static Object[] arrayFromPayloads(
      DataConverter converter,
      Optional<Payloads> content,
      Class<?>[] parameterTypes,
      Type[] genericParameterTypes)
```

With an arrival of `PayloadCodec` and especially Remote Data Encoder, this approach is not acceptable as a main code path to read all input parameters of a Workflow or an Activity as it will require 1 call to the encoder for EACH parameter.

**Describe the solution you'd like**
`DataConverter` interface has to evolve to support encoding all the Payloads at once.


---

<a id="1339"></a>

### #1339: Eager activity dispatch

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1339 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-08-03 17:03:14.000 UTC (3y 5m ago) |
| **Updated** | 2022-11-27 17:44:28.000 UTC |
| **Closed** | 2022-09-22 23:11:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | mjameswh |
| **Milestone** | 1.17.0 |

#### Description

Add support for an eager activity dispatch in java-sdk.

More context: https://github.com/temporalio/sdk-features/issues/55


---

<a id="1331"></a>

### #1331: Jacoco fails to produce report due to tests failing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1331 |
| **State** | CLOSED |
| **Author** | nvogety (Neeharika V) |
| **Created** | 2022-07-29 14:50:01.000 UTC (3y 5m ago) |
| **Updated** | 2022-08-10 16:27:22.000 UTC |
| **Closed** | 2022-08-10 16:27:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.16.0 |

#### Description

## Expected Behavior
All tests pass and Jacoco generates a coverage report

## Actual Behavior
Jacoco fails and is not able to generate a report, since tests which used to be successful now fail after importing jacoco into build.gradle. 

Running `./gradlew test` always results in `‚Äúorg.gradle.api.tasks.TaskExecutionException: Execution failed for task '<classified-task>:test'‚Äù` which is caused by: `‚Äúorg.gradle.api.GradleException: There were failing tests‚Äù`.  

Running `./gradlew jacocoTestReport` doesn't generate a report, either with a successful build or with an explicit failure, depending on if 'dependsOn test' is included under 'jacocoTestReport' in build.gradle. Regardless of build status, no reports are generated.

I believe that synthetic methods (which jacoco may be creating) are not currently getting checked under getWorkflowInterfaceMethods in the POJOWorkflowInterfaceMetadata class, which is what is causing the failure. My test calls io.temporal.worker.Worker.addWorkflowImplementationFactory(). 

## Stacktrace
Note: Some classified info has been obscured in the stack trace

> Missing @WorkflowMethod, @SignalMethod or @QueryMethod annotation on private static boolean[] <classified-package>.$jacocoInit(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.Class)
> java.lang.IllegalArgumentException: Missing @WorkflowMethod, @SignalMethod or @QueryMethod annotation on private static boolean[] <classified-package>.$jacocoInit(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.Class)
> at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.getWorkflowInterfaceMethods(POJOWorkflowInterfaceMetadata.java:203)
> at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.<init>(POJOWorkflowInterfaceMetadata.java:136)
> at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newInstance(POJOWorkflowInterfaceMetadata.java:109)
> at io.temporal.common.metadata.POJOWorkflowInterfaceMetadata.newInstance(POJOWorkflowInterfaceMetadata.java:83)
> at io.temporal.internal.sync.POJOWorkflowImplementationFactory.addWorkflowImplementationFactory(POJOWorkflowImplementationFactory.java:127)
> at io.temporal.internal.sync.POJOWorkflowImplementationFactory.addWorkflowImplementationFactory(POJOWorkflowImplementationFactory.java:111)
> at io.temporal.internal.sync.SyncWorkflowWorker.addWorkflowImplementationFactory(SyncWorkflowWorker.java:147)
> at io.temporal.worker.Worker.addWorkflowImplementationFactory(Worker.java:289)
> at<classified-package>.TestWorkflowFacade.getWorkflowClient(TestWorkflowFacade.java:252)
> at <classified-package>.<test-class>.setup(<test-class>.java:310)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
> at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
> at java.base/java.lang.reflect.Method.invoke(Method.java:566)
> at org.junit.internal.runners.MethodRoadie.runBefores(MethodRoadie.java:133)
> at org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:96)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.executeTest(PowerMockJUnit44RunnerDelegateImpl.java:310)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.executeTestInSuper(PowerMockJUnit47RunnerDelegateImpl.java:131)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.access$100(PowerMockJUnit47RunnerDelegateImpl.java:59)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner$TestExecutorStatement.evaluate(PowerMockJUnit47RunnerDelegateImpl.java:147)
> at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:61)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.evaluateStatement(PowerMockJUnit47RunnerDelegateImpl.java:107)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.executeTest(PowerMockJUnit47RunnerDelegateImpl.java:82)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.runBeforesThenTestThenAfters(PowerMockJUnit44RunnerDelegateImpl.java:298)
> at org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:87)
> at org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:50)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.invokeTestMethod(PowerMockJUnit44RunnerDelegateImpl.java:218)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.runMethods(PowerMockJUnit44RunnerDelegateImpl.java:160)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$1.run(PowerMockJUnit44RunnerDelegateImpl.java:134)
> at org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:34)
> at org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:44)
> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.run(PowerMockJUnit44RunnerDelegateImpl.java:136)
> at org.powermock.modules.junit4.common.internal.impl.JUnit4TestSuiteChunkerImpl.run(JUnit4TestSuiteChunkerImpl.java:117)
> at org.powermock.modules.junit4.common.internal.impl.AbstractCommonPowerMockRunner.run(AbstractCommonPowerMockRunner.java:57)
> at org.powermock.modules.junit4.PowerMockRunner.run(PowerMockRunner.java:59)
> at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
> at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
> at org.junit.vintage.engine.execution.RunnerExecutor.execute(RunnerExecutor.java:43)
> at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
> at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195)
> at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
> at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
> at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
> at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
> at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
> at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
> at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
> at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497)
> at org.junit.vintage.engine.VintageTestEngine.executeAllChildren(VintageTestEngine.java:82)
> at org.junit.vintage.engine.VintageTestEngine.execute(VintageTestEngine.java:73)
> at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)
> at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
> at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
> at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
> at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
> at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
> at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
> at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
> at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
> at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99)
> at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79)
> at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75)
> at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
> at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
> at java.base/java.lang.reflect.Method.invoke(Method.java:566)
> at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
> at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
> at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
> at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
> at com.sun.proxy.$Proxy5.stop(Unknown Source)
> at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:133)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
> at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
> at java.base/java.lang.reflect.Method.invoke(Method.java:566)
> at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
> at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
> at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
> at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
> at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414)
> at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
> at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
> at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
> at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
> at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
> at java.base/java.lang.Thread.run(Thread.java:829)

## Specifications
  - Version: 1.11.0



---

<a id="1319"></a>

### #1319: TestServer erroneously propagates timeouts of the parent workflow to the child 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1319 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-07-22 21:51:32.000 UTC (3y 5m ago) |
| **Updated** | 2022-07-22 23:48:00.000 UTC |
| **Closed** | 2022-07-22 23:47:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |

#### Description

## Expected Behavior

A parent workflow with a short timeout should be able to start and abandon a child workflow without explicitly specifying a timeout and such a child can take a long time to finish on its own.

## Actual Behavior

If a parent workflow doesn't specify a timeout on a child, test server propagates parent timeout to the child and times it out shortly after the parent.


---

<a id="1318"></a>

### #1318: Cleanup and improve ApplicationFailure javadoc

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1318 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-07-22 00:00:15.000 UTC (3y 5m ago) |
| **Updated** | 2025-05-13 16:51:08.000 UTC |
| **Closed** | 2025-05-13 16:51:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Cleanup and improve ApplicationFailure javadoc. 
Include how `ApplicationFailure.newNonRetryableFailure()` works together with `ActivityOptions#retryOptions#setDoNotRetry` and `WorkflowImplementationOptions#setFailWorkflowExceptionTypes`.
Consider adding additional methods that allow the creation of non-retryable ApplicationFailure from an exception directly without wrapping to simplify handling on the receiving side.



---

<a id="1315"></a>

### #1315: Client and Workers shouldn't retry INTERNAL errors with newer versions of Server 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1315 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-07-21 02:51:25.000 UTC (3y 5m ago) |
| **Updated** | 2022-07-21 19:40:20.000 UTC |
| **Closed** | 2022-07-21 19:37:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |

#### Description

## Expected Behavior

See https://github.com/temporalio/sdk-features/issues/6 for more details.
In newer versions of Server Internal errors are considered non-retryable. This logic has to depend on the Server version and specifically it's defined by the Server Capabilities.


---

<a id="1312"></a>

### #1312: Call getSystemInfo before a first client call to obtain server capabilities

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1312 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-07-19 23:13:16.000 UTC (3y 5m ago) |
| **Updated** | 2022-07-20 18:47:46.000 UTC |
| **Closed** | 2022-07-20 18:47:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.15.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Temporal Server API provides new `getSystemInfo` call that returns a set of features supported by the server. 

**Describe the solution you'd like**
This call needs to be performed by the stubs or client before any other client call.


---

<a id="1301"></a>

### #1301: Implement an ability to disable deadlock detector for data converters performing IO

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1301 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-07-06 17:44:25.000 UTC (3y 6m ago) |
| **Updated** | 2023-03-30 08:16:22.000 UTC |
| **Closed** | 2023-03-30 08:16:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.20.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Some users have data converters that perform an IO and they sometimes trigger deadline detector. 

**Describe the solution you'd like**
JavaSDK should have a way to disable deadline detector for a piece of code (under `WorkflowUnsafe`) and for a specific data converter.
See implementation in GoSDK as a reference: https://github.com/temporalio/sdk-go/pull/772


---

<a id="1288"></a>

### #1288: Test Server is unstable for child workflows reporting completion fast

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1288 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-27 19:51:52.000 UTC (3y 6m ago) |
| **Updated** | 2022-06-27 21:44:34.000 UTC |
| **Closed** | 2022-06-27 21:44:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.13.0 |

#### Description

## Actual Behavior

```
**Invalid Transition{from=INITIATED, action=COMPLETE}, history: [Transition{from=NONE, action=INITIATE}]
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16283)
    	at io.grpc.Status.asRuntimeException(Status.java:526)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16284)
    	at io.temporal.internal.testservice.StateMachine.action(StateMachine.java:230)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16285)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.lambda$childWorkflowCompleted$18(TestWorkflowMutableStateImpl.java:1140)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16286)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.update(TestWorkflowMutableStateImpl.java:331)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16287)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.update(TestWorkflowMutableStateImpl.java:300)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16288)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.childWorkflowCompleted(TestWorkflowMutableStateImpl.java:1137)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16289)
    	at io.temporal.internal.testservice.TestWorkflowMutableStateImpl.lambda$processCompleteWorkflowExecution$23(TestWorkflowMutableStateImpl.java:1364)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16290)
    	at java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1426)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16291)
    	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16292)
    	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16293)
    	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16294)
    	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594)
[20:02:50](https://tinycicd.temporal.io/?csrf_token=f528d0f5c84279b41e9738a7416ecb73410dd20d64bb6e77f0f95d12de542f28#L62032862:16295)
    	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)**
```

Some tests especially in loaded test environments fail with this stacktrace showing that Test Server observes Completion of child workflow before Start of this workflow.


---

<a id="1273"></a>

### #1273: provide an option to print trace-id and span-id on java-sdk 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1273 |
| **State** | OPEN |
| **Author** | hema-kishore-gunda (Hema Kishore Gunda) |
| **Created** | 2022-06-21 13:00:40.000 UTC (3y 6m ago) |
| **Updated** | 2022-06-21 13:00:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Yes. currently trace-id and span-id are not being printed on logs with OpenTracingWorkerInterceptor.

**Describe the solution you'd like**
Add trace-id and span-id to MDC-context.

**Describe alternatives you've considered**
Workaround: Implement custom OpenTracingWorkerInterceptor, OpenTracingWorkflowInboundCallsInterceptor and OpenTracingActivityInboundCallsInterceptor

**Additional context**
This feature has been discussed in slack channel thread
https://temporalio.slack.com/archives/CTT84KXK9/p1655727317596189.



---

<a id="1272"></a>

### #1272: Add toString method to ActivityInfo and WorkflowInfo

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1272 |
| **State** | CLOSED |
| **Author** | AndreevDm (Dmitry Andreev) |
| **Created** | 2022-06-21 12:15:59.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-07 16:41:50.000 UTC |
| **Closed** | 2022-06-21 20:31:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | 1.13.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
It is often necessary (especially in interceptors) to log all info about workflow or activity. 

In this case you just want to write something like 
```java
log.info("Got failing Activity:  {}", activityInfo)'
```
But instead you need to something like 
```java
log.info(
    "Got failing Activity: workflowId {}, activityId {}, runId {}, attempt {}.",
    info.getWorkflowId(), info.getActivityId(), info.getRunId(), info.getAttempt()
);
```

**Describe the solution you'd like**
subj





---

<a id="1266"></a>

### #1266: Add unit test covering scenario of Server outage during Worker sending workflow task execution result

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1266 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-17 21:29:00.000 UTC (3y 6m ago) |
| **Updated** | 2024-12-17 21:20:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
https://github.com/temporalio/sdk-java/pull/1265 fixed a bug that happens if Temporal Server is down when workers are reporting the results to the Server. But right now there is no ability to test the scenario of such an outage. 

**Describe the solution you'd like**
Temporal SDK should add support for such tests to Test Server. Also, a unit test for this bug and fix should be implemented.


---

<a id="1262"></a>

### #1262: Workflows stuck on local activity call

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1262 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-16 01:41:57.000 UTC (3y 6m ago) |
| **Updated** | 2022-07-04 16:56:45.000 UTC |
| **Closed** | 2022-07-02 00:27:02.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.14.0 |

#### Description

There are user reports pointing to workflows stuck on waiting for local activity results while activity is not actually in progress judging by the thread dump.

Workflow method stuck with stack dump:

```
"workflow-method-571893c0-821b-30e3-a437-80ce798dff42-1e8ec9fd-6426-4fd0-bc6d-8604beb6375d" #54994 prio=5 os_prio=0 cpu=1.70ms elapsed=559.87s tid=0x00007fa6a4004450 nid=0x58ac waiting on condition  [0x00007fa6e1ddf000]
   java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@11.0.15/Native Method)
	- parking to wait for  <0x0000000773341a78> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(java.base@11.0.15/LockSupport.java:194)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(java.base@11.0.15/AbstractQueuedSynchronizer.java:2081)
	at io.temporal.internal.sync.WorkflowThreadContext.yield(WorkflowThreadContext.java:89)
	at io.temporal.internal.sync.WorkflowThreadImpl.yield(WorkflowThreadImpl.java:412)
	at io.temporal.internal.sync.WorkflowThread.await(WorkflowThread.java:45)
	at io.temporal.internal.sync.CompletablePromiseImpl.getImpl(CompletablePromiseImpl.java:84)
	at io.temporal.internal.sync.CompletablePromiseImpl.get(CompletablePromiseImpl.java:74)
	at io.temporal.internal.sync.ActivityStubBase.execute(ActivityStubBase.java:44)
	at io.temporal.internal.sync.LocalActivityStubImpl.execute(LocalActivityStubImpl.java:29)
	at io.temporal.internal.sync.LocalActivityInvocationHandler.lambda$getActivityFunc$0(LocalActivityInvocationHandler.java:72)
	at io.temporal.internal.sync.LocalActivityInvocationHandler$$Lambda$1955/0x00000008012df440.apply(Unknown Source)
	at io.temporal.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:70)
	at com.sun.proxy.$Proxy128.publishPayload(Unknown Source)
```

History doesn't contain a marker for "publishPayload" local activity. History does contain workflow task completion with other local activity markers that were supposed to be executed before the activity in question.
Thread dump doesn't show "publishPayload" local activity currently in progress.

## Root cause analysis

If Worklfow Task contains a sequence of Local Activitiues that don't fit into Workflow Task Timeout (10s by default, limited to 8s to accommodate network and other latencies), Temporal SDK performs a Workflow Task Heartbeat. It closes the workflow task and immediately opens a new one if there is an outstanding work to be done.

Now consider a scenario: 
Workflow task executes a sequence of local activities synchronously one by one. Execution of the whole chain of local activities doesn't fit into one Workflow Task. The last event loop (workflow code unblocking by the SDK) that fits before the heartbeat schedules a new local activity. 

Because of a `break` here: https://github.com/temporalio/sdk-java/blob/5079086e065adc64aa3d17e505482785f0f51dfe/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowRunTaskHandler.java#L284
this local activity command will never be taken by the state machines and accounted for in the outstanding local activities counter.

This leads to a counter of outstanding local activities to be 0, while there are outstanding local activities, we just didn't fetch them because of the mentioned `break`. As the result, Instead of performing a heartbeat, we close the workflow task, which leads to a stuck workflow.

## Reproduction

The problem is tough to reproduce. To make it happen, Workflow Task Heartbeat Timeout should happen DURING execution of workflow code (during eventLoop call) and this execution should schedule a local activity and this local activity should be the only outstanding local activity.

Reproduction uses Thread.sleep inside workflow code (should never be used in production code) to increase the chances of hitting the expiration of workflow task heartbeat during execution of workflow code.

This test reproduces the problem reliably:
https://github.com/temporalio/sdk-java/pull/1295/files#diff-4de8883f4907196541556af22f075c6f22cb0c7b2eb0622d3d7be45417d82243R43

## Context

Related user posts:
https://community.temporal.io/t/workflow-timedout-due-to-activity-blocked-on-feature-get/5136
https://community.temporal.io/t/activity-execution-is-stuck-on-blocked-on-feature-get/4247
https://community.temporal.io/t/activity-execution-is-blocked-on-blocked-on-feature-get/4391


---

<a id="1261"></a>

### #1261: Local Activities fail and don't retry after reaching LocalRetryThreshold

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1261 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-16 01:35:28.000 UTC (3y 6m ago) |
| **Updated** | 2022-12-06 05:52:31.000 UTC |
| **Closed** | 2022-12-06 05:52:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

## Expected Behavior

Local Activity should schedule a timer on the server when it reaches LocalActivityThreshold according to its backoff strategy.

## Actual Behavior

Instead, if Local Activity fails after LocalActivityThreshold is reached, the fail propagates to the workflow

## Steps to Reproduce the Problem

Unit test https://github.com/Spikhalskiy/java-sdk/commit/ea6252a66012d0cdf3f29af1ed78ab0ae95a762d#diff-b74049b45234315b43ae6729f80ee4c54cca4cbb081f97ef9ab42cc77e9e3264R39 is expected to pass, but instead, it fails. 

## Additional context

It looks like the code that was scheduling the timer was removed by mistake in the PR from the earliest days of Temporal that was reimplementing errors handling, specifically here: https://github.com/temporalio/sdk-java/pull/101/files#diff-f6a342e5baa618f03fdb6a83c6e070e5b57b9a9d9f3e1460b928149faa12b57cR237

It wasn't caught because the unit test testing La backoff that falls back to the server timers is not tested by the existing tests.



---

<a id="1258"></a>

### #1258: Make activity heartbeats more robust to network outages by retrying them

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1258 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-09 18:01:28.000 UTC (3y 7m ago) |
| **Updated** | 2023-05-23 17:45:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Right now we don't retry failed heartbeats and just ignore the error.
This may create a problem if heartbeat timeout is, for example, 20 seconds and activity heartbeats every 15 seconds. If we get a network blip, such an activity will be terminated with heartbeat timeout.
We should use heartbeatExecutor to schedule an asynchronous retry for a failed heartbeat. We can utilize an exponential backoff throttling strategy for it. ActivityContext.heartbeat() shouldn't be kept blocked because we retry.



---

<a id="1257"></a>

### #1257: Cached activity heartbeat prevents worker from a quick shutdown

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1257 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-09 17:52:04.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-09 17:52:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Scheduled throttled activity heartbeats shouldn't delay worker shutdown. The worker shutdown should drain such heartbeats.

## Actual Behavior
Worker shutdown is delayed on the shutdown of activity heartbeat executor because there are scheduled heartbeat tasks.

## Steps to Reproduce the Problem

See ActivityTimeoutTest#testActivityStartToCloseTimeout that should be taking about 2 seconds, but takes 10 seconds and has
```
13:39:55.206 [TemporalShutdownManager: 1] WARN  i.t.internal.worker.ShutdownManager - Wait for a graceful shutdown of SyncActivityWorker{namespace=default, taskQueue=test-activities, identity=81008@Dmitrys-Temporal-MacBook.local}#heartbeatExecutor timed out, fallback to shutdownNow()
```
in the shutdown log.


---

<a id="1243"></a>

### #1243: getResultAsync with test environment leads to unbalanced time locking

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1243 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-02 05:52:43.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-02 17:20:51.000 UTC |
| **Closed** | 2022-06-02 17:20:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.13.0 |

#### Description

## Expected Behavior

`WorkflowStub.getResultAsync` performs balanced unlcoking/locking of time skipping.

## Actual Behavior

`WorkflowStub.getResultAsync` performs the sequence of unlock-lock-lock in test environment with time-skipping, leading to a leak and retaining a time lock.

## Specifications

Introduced in Java SDK 1.12.0 in #1210



---

<a id="1242"></a>

### #1242: Revisit history pagination 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1242 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-01 21:23:54.000 UTC (3y 7m ago) |
| **Updated** | 2024-12-17 21:20:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
`WorkflowHistoryIterator` implementation related to deadline (using calculations on curentTimeMilles), exceptions handling and error/expiration reporting requires a revisit and polishing.
Logging should include more information about the workflow task timeout and how much time elapsed.

As a part of this task it's also a good idea to build-in protection from the server returning events in a loop that never ends that we have in Core:
https://github.com/temporalio/sdk-core/blob/a72ebed19ec1e7b3fe37fbcbe846deafb1820f33/core/src/worker/workflow/history_update.rs#L281


---

<a id="1239"></a>

### #1239: getVersion call with a range that doesn't include DEFAULT_VERSION tolerates unversioned code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1239 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-06-01 04:12:49.000 UTC (3y 7m ago) |
| **Updated** | 2022-06-01 17:33:33.000 UTC |
| **Closed** | 2022-06-01 17:33:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.13.0 |

#### Description

## Expected Behavior

1. During the initial execution workflow doesn't have `getVersion` call at all, code it unversioned.
2. Workflow code is modified with a getVersion range that doesn't include `DEFAULT_VERSION`.
3. Trying to replay a history created in 1. with code from 2. should fail with `UnsupportedVersion`

## Actual Behavior

Code versioned with `DEFAULT_VERSION` is supported by the code from 2.
`Workflow.getVersion("changeId", 1, 2)` returns `DEFAULT_VERSION`


---

<a id="1238"></a>

### #1238: Improve Worker start logging with more diagnostic information

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1238 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-31 18:36:53.000 UTC (3y 7m ago) |
| **Updated** | 2025-05-15 02:22:51.000 UTC |
| **Closed** | 2025-05-15 02:22:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

1. Worker should explicitly report if it does or especially DOESN'T start a poller on the workflow task queue. It should help users start a worker without any workflow implementations registered and expecting the worker to be visible in UI/tctl output.
2. Workflow and activity types registered with the worker.


---

<a id="1237"></a>

### #1237: Workflow.getWorkflowExecution fails if stub created via Workflow.newExternalWorkflowStub 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1237 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-05-31 17:44:09.000 UTC (3y 7m ago) |
| **Updated** | 2025-05-16 14:52:34.000 UTC |
| **Closed** | 2025-05-16 14:52:34.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

          GreetingWorkflow parentWorkflow = Workflow.newExternalWorkflowStub(GreetingWorkflow.class,
              Workflow.getInfo().getParentWorkflowId().get());
          Promise<WorkflowExecution> parentExec = Workflow.getWorkflowExecution(parentWorkflow);

throws 
       
       Caused by: java.lang.ClassCastException: class io.temporal.internal.sync.ExternalWorkflowStubImpl cannot be cast to class io.temporal.workflow.ChildWorkflowStub (io.temporal.internal.sync.ExternalWorkflowStubImpl and io.temporal.workflow.ChildWorkflowStub are in unnamed module of loader 'app')

per javadoc it should also work with externalworkflow stub


---

<a id="1234"></a>

### #1234: Provide default implementation of Prometheus scrape endpoint

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1234 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-24 20:34:55.000 UTC (3y 7m ago) |
| **Updated** | 2023-05-23 17:41:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Right now users who want to export metrics into Prometheus have to implement a scrape endpoint to publish metrics from micrometer reporter following one of the ways described here: https://tanzu.vmware.com/developer/learningpaths/application-observability/exposing-metrics-java-prometheus/

**Describe the solution you'd like**
For the convenience of users, Temporal JavaSDK should have a built-in implementation of a scrape endpoint for prometheus. This endpoint should allow port/url configuration to be passed to avoid any port conflicts with other instances of scraping endpoints that may be running on the host.



---

<a id="1233"></a>

### #1233: Javadocs for ActivityCompletionClient

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1233 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-24 19:29:20.000 UTC (3y 7m ago) |
| **Updated** | 2025-01-06 22:57:57.000 UTC |
| **Closed** | 2025-01-06 22:57:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Next |

#### Description

`ActivityCompletionClient` is a public user-facing interface and it is currently undocumented.

## Context
Consider pairing together with #1354 


---

<a id="1221"></a>

### #1221: Test Server does not populate `WorkflowExecutionStartedEventAttributes.FirstExecutionRunId` in the history.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1221 |
| **State** | CLOSED |
| **Author** | macrogreg (macrogreg) |
| **Created** | 2022-05-17 21:02:28.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-18 20:52:12.000 UTC |
| **Closed** | 2022-05-18 14:10:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

This tests passes on the "normal" Temporal server, but fails on the Test Server.

* Start a workflow.
* Request its history using `GetWorkflowExecutionHistory(..)` gRPC call.
* The first history even is of type `WorkflowExecutionStartedEventAttributes`. If contains the field the field `FirstExecutionRunId`.

* On the "normal" server, it is a non-null, non-whitespace string that is the same as the run-id just of the run started.
* On Test Server it is empty.




---

<a id="1216"></a>

### #1216: Log activity thread stack trace if it times out or fails to heartbeat

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1216 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2022-05-16 16:40:52.000 UTC (3y 7m ago) |
| **Updated** | 2022-05-16 16:40:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
It is common for activities to fail to heartbeat on time or complete an activity on time. Troubleshooting this problem is not simple. 

**Describe the solution you'd like**
Automatically log the stack of the activity thread if an activity didn't heartbeat within heartbeat interval or an activity failed to complete for the start to close timeout.




---

<a id="1212"></a>

### #1212: Cancel long poll if a Future returned from getResultAsync is not referenced anymore by the user code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1212 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-13 18:24:22.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-13 18:24:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

If we hit WorkflowStub#getResultAsync and after that, we either don't wait on the result at all or wait for a bit and discard after, the long poll continues to run.
This creates a need for an unpleasant, unconventional `WorkflowStub#getResultAsync(resultType, timeout)`.
Why do users need to pass a timeout to `getResultAsync` if they pass it into `Future.get(timeout)`.
Most users just use `WorkflowStub#getResultAsync(resultType)` not understanding that they create a leak if the workflows don't finish fast.

**Describe the solution you'd like**
Instead of that, Temporal Java SDK code should maintain a weak or phantom reference on the CompletableFuture that we return to the users and cancel the background long poll when it's discarded by the user code.


---

<a id="1208"></a>

### #1208: Remove verbose exceptions logging from GrpcRetryer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1208 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-12 16:48:21.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-19 00:57:06.000 UTC |
| **Closed** | 2022-05-19 00:57:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

`GrpcRetryer` shouldn't log the errors happening, even the final ones. 
It may do it on a Trace level for debugging purposes, but it shouldn't be higher than that.
Code that uses `GrpcRetryer` should take care of handling the exceptions propagated from there.
GrpcRetryer doesn't have a context to understand which exception is a problem and which is not, only the calling code does.


---

<a id="1206"></a>

### #1206: Implement immediate dispatch of new Workflow Task in a workflow task completion response

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1206 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-12 02:47:12.000 UTC (3y 8m ago) |
| **Updated** | 2023-09-29 00:08:45.000 UTC |
| **Closed** | 2023-09-29 00:08:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Temporal Server implemented a new optimization. It supported an immediate local dispatch of a new workflow task to the same Worker as a part of a response to Workers's workflow task completion request.

This feature should be supported in JavaSDK.


---

<a id="1205"></a>

### #1205: Test server throws a null pointer if query without a deadline

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1205 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-11 21:56:38.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-12 16:37:00.000 UTC |
| **Closed** | 2022-05-12 16:37:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

## Expected Behavior

Not having a gRPC deadline in the request doesn't cause a problem for query. 

## Actual Behavior

NullPointer is thrown:

```
SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed@55b5e64c
java.lang.NullPointerException
       at io.temporal.internal.testservice.TestWorkflowService.queryWorkflow(TestWorkflowService.java:953)
        at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$MethodHandlers.invoke(WorkflowServiceGrpc.java:3938)
        at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
        at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:340)
```


---

<a id="1198"></a>

### #1198: WorkflowStub#cancel and #terminate throw StatusRuntimeException instead of WorkflowNotFoundException

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1198 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-10 04:18:49.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-18 17:41:47.000 UTC |
| **Closed** | 2022-05-18 17:41:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

## Expected Behavior

If a workflow doesn't exist, `WorkflowStub#cancel` and `WorkflowStub#terminate` should throw a `WorkflowNotFoundException` like other methods of `WorkflowStub` like `#signal`.

## Actual Behavior

Raw gRPC `StatusRuntimeException` with NOT_FOUND code is thrown.


---

<a id="1197"></a>

### #1197: getResultAsync long poll request gets terminated by rpcTimeout

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1197 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-10 04:14:54.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-11 21:06:08.000 UTC |
| **Closed** | 2022-05-11 21:06:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

## Expected Behavior

getResultAsync behaves the same way as getResult performing a long poll for up to 60 seconds.

## Actual Behavior

getResultAsync long poll requests get terminated after 10 seconds (default rpcTimeout)



---

<a id="1194"></a>

### #1194: Start with signal does not add search attributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1194 |
| **State** | CLOSED |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2022-05-09 17:40:16.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-10 22:19:52.000 UTC |
| **Closed** | 2022-05-10 22:19:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

## Expected Behavior

When starting a workflow with `startWithSignal`, I would expect any search attributes defined on the workflow stub to be applied to the workflow.

## Actual Behavior

The workflow is started, but without search attributes attached.

## Steps to Reproduce the Problem

```kotlin
val stub = client.newWorkflowStub(
  HelloWorld::class.java,
  WorkflowOptions.newBuilder()
    .setTaskQueue("task-queue")
    .setWorkflowId("hello")
    .setSearchAttributes(
      mapOf(
        "testing" to "example"
      )
    )
    .build()
)

val request = client.newSignalWithStartRequest().apply {
  add(
    stub::sayHello,
    HelloWorldRequest("hi temporal")
  )
}

client.signalWithStart(request)
```

## Specifications

  - Version: v1.10.0
  - Platform: v1.15.2 (and 1.16.0)



---

<a id="1190"></a>

### #1190: Test Server Query for non-cached execution causes SDK state machines problem

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1190 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-06 20:31:13.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-09 18:42:46.000 UTC |
| **Closed** | 2022-05-09 18:42:46.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | 1.12.0 |

#### Description

## Actual Behavior
```
io.temporal.client.WorkflowQueryException: workflowId='f2454b12-fcb1-4b3e-9b29-2f02e33a6543', runId='c5e13f9c-0e3c-454f-adb7-e7dd5fea844d', workflowType='TestWorkflowWithQuery'}

	at io.temporal.internal.sync.WorkflowStubImpl.query(WorkflowStubImpl.java:331)
	at io.temporal.testing.TimeLockingInterceptor$TimeLockingWorkflowStub.query(TimeLockingInterceptor.java:172)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.queryWorkflow(WorkflowInvocationHandler.java:309)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:272)
	at io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)
	at com.sun.proxy.$Proxy18.query(Unknown Source)
	at io.temporal.workflow.queryTests.LocalActivityAndQueryInvestigationTest.testLocalActivityAndQuery(LocalActivityAndQueryInvestigationTest.java:68)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:299)
	at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:293)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: io.grpc.StatusRuntimeException: INVALID_ARGUMENT: io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 5 of type 'EVENT_TYPE_MARKER_RECORDED' during execution. {PreviousStartedEventId=3, workflowTaskStartedEventId=3, Currently Processing StartedEventId=3}
	at io.temporal.internal.statemachines.WorkflowStateMachines.createEventProcessingException(WorkflowStateMachines.java:244)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:223)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:197)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:180)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleQueryWorkflowTask(ReplayWorkflowRunTaskHandler.java:247)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:118)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:97)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handleTask(WorkflowWorker.java:277)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:231)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:173)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.lang.IllegalArgumentException: LocalActivity: invalid REQUEST_PREPARED->MARKER_RECORDED, transition history is [CREATED->CHECK_EXECUTION_STATE, EXECUTING->SCHEDULE]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:140)
	at io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:101)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:67)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleLocalActivityMarker(WorkflowStateMachines.java:482)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleCommandEvent(WorkflowStateMachines.java:292)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleSingleEvent(WorkflowStateMachines.java:250)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:221)
	... 12 more

	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:271)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:252)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:165)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.queryWorkflow(WorkflowServiceGrpc.java:3135)
	at io.temporal.internal.client.external.GenericWorkflowClientExternalImpl.lambda$query$5(GenericWorkflowClientExternalImpl.java:220)
	at io.temporal.internal.retryer.GrpcSyncRetryer.retry(GrpcSyncRetryer.java:61)
	at io.temporal.internal.retryer.GrpcRetryer.retryWithResult(GrpcRetryer.java:51)
	at io.temporal.internal.client.external.GenericWorkflowClientExternalImpl.query(GenericWorkflowClientExternalImpl.java:213)
	at io.temporal.internal.client.RootWorkflowClientInvoker.query(RootWorkflowClientInvoker.java:141)
	at io.temporal.internal.sync.WorkflowStubImpl.query(WorkflowStubImpl.java:324)
	... 18 more
```

## Root cause

The way Test Server forms a `PollWorkflowTaskResponse` for a legacy query during replay makes SDK state machines think that the last workflow task is actually getting executed for the first time instead of being replayed (`previousStartedEventId` and `startedEventId` have the same values as the last executed workflow task) causing a failure when SDK tries to actually match already existing events with commands. This issue appears specifically with the LocalActivity state machine.


---

<a id="1187"></a>

### #1187: LocalActivity completion advances workflow task timestamp to the current time instead of using an offset

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1187 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-05-04 05:13:36.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-09 23:54:14.000 UTC |
| **Closed** | 2022-05-09 23:54:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

## Expected Behavior

Finished LocalActivity execution advances workflow task timestamp by the execution time. If test framework is used and initial timestamp is overridden, it should be respected through the whole execution and not get discarded by a completion of a local activity. 

## Actual Behavior
`TestEnvironment` that has an initial time set to something other than the current time.
When LocalActivity runs, `Workflow.currentTimeMillis()` gets updated to the current DateTime that is nothing around the time set on TestEnv.


---

<a id="1179"></a>

### #1179: workflow_active_thread_count metric should not be tagged with WORKFLOW_TYPE

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1179 |
| **State** | CLOSED |
| **Author** | pfrolov (Pavel Frolov) |
| **Created** | 2022-04-29 22:37:11.000 UTC (3y 8m ago) |
| **Updated** | 2022-05-04 03:52:36.000 UTC |
| **Closed** | 2022-05-04 03:52:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

## Expected Behavior

Every workflow per worker [emits](https://github.com/temporalio/sdk-java/blob/3db50b6d9dd60b17a3b516353cf19ddb9065abd7/temporal-sdk/src/main/java/io/temporal/internal/sync/WorkflowThreadImpl.java#L244) `workflow_active_thread_count` which is the number of active threads in the shared `ThreadPoolExecutor`.

This metric should not contain the `WORKFLOW_TYPE` tag to avoid double-counting of `workflow_active_thread_count` given that every workflow share the same `ThreadPoolExecutor`.

## Actual Behavior

This metric **contains** the `WORKFLOW_TYPE` tag which leads to double-counting, when aggregated by the host, of `workflow_active_thread_count` given that every workflow shared the same `ThreadPoolExecutor`.

## Steps to Reproduce the Problem

  1. Run a 1 worker with 2 workflows
  1. Check `workflow_active_thread_count` metric. It will contain the `WORKFLOW_TYPE` tag

## Specifications

  - Version: v1.10.0



---

<a id="1162"></a>

### #1162: Open Tracing interceptor logs failure for internal temporal errors

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1162 |
| **State** | CLOSED |
| **Author** | bdartt |
| **Created** | 2022-04-21 17:34:32.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-22 17:56:11.000 UTC |
| **Closed** | 2022-04-22 17:56:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.11.0 |

#### Description

Hi Temporal team,

We are using the open tracing module to send trace information to DataDog. It works great, but we get a LOT of workflow spans getting marked as an error for `DestroyWorkflowThreadError`.

As I understand it, this is an internal error that the SDK uses for thread cleanup, and does NOT indicate a failure in the workflow. 

This appears to be a bug, as the code catches `Throwable` here (and isn't catching `Throwable` or `Error` a no-no?):  [OpenTracingWorkflowInboundCallsInterceptor](https://github.com/temporalio/sdk-java/blob/master/temporal-opentracing/src/main/java/io/temporal/opentracing/internal/OpenTracingWorkflowInboundCallsInterceptor.java#L73)

A na√Øve approach may be to only catch `Exception` to `logFail`... but I'm not sure if y'all will want (or need) to do something different for `Error` classes.


---

<a id="1153"></a>

### #1153: temporal-test-server pom seems incorrect

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1153 |
| **State** | CLOSED |
| **Author** | jrpedrianes (Jorge Rodr√≠guez Pedrianes) |
| **Created** | 2022-04-19 13:15:12.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-19 18:34:54.000 UTC |
| **Closed** | 2022-04-19 18:34:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.10.0 |

#### Description

## Expected Behavior

Compile project using maven 3.8.x and temporal-testing as dependency without warnings

## Actual Behavior

When compiling the project including the dependency `io.temporal:temporal-testing:jar:1.9.1`, maven shows a warning indicating that the dependant dependency `io.temporal:temporal-test-server:jar:1.9.1` has something wrong in its pom file.

```
[WARNING] The POM for io.temporal:temporal-test-server:jar:1.9.1 is invalid, transitive dependencies (if any) will not be available: 2 problems were encountered while building the effective model for io.temporal:temporal-test-server:1.9.1
[ERROR] 'dependencies.dependency.version' for io.grpc:grpc-core:jar is missing. @ 
[ERROR] 'dependencies.dependency.version' for io.grpc:grpc-services:jar is missing. @ 
```

## Specifications

  - Version: 1.9.1
  - Apache Maven 3.8.1
  - Java version: 17.0.1, vendor: Eclipse Adoptium



---

<a id="1146"></a>

### #1146: Code using WorkflowRunLockManager may release locks that are owned by other threads

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1146 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-04-16 22:50:17.000 UTC (3y 8m ago) |
| **Updated** | 2022-04-19 15:03:11.000 UTC |
| **Closed** | 2022-04-19 15:03:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.10.0 |

#### Description

WorkflowWorker.TaskHandlerImpl#handle:

```
if (...) {
        runLock = runLocks.getLockForLocking(task.getWorkflowExecution().getRunId());
        // Acquiring a lock with a timeout to avoid having lots of workflow tasks for the same run
        // id waiting for a lock and consuming threads in case if lock is unavailable.
        if (!runLock.tryLock(1, TimeUnit.SECONDS)) {
          throw new UnableToAcquireLockException(
              "Workflow lock for the run id hasn't been released by one of previous execution attempts, "
                  + "consider increasing workflow task timeout.");
        }
      }
      ...
      } finally {
        if (runLock != null) {
          System.out.println("released a lock for: " + task.getWorkflowExecution().getRunId());
          runLocks.unlock(task.getWorkflowExecution().getRunId());
        }
      }
```

If the exception is thrown and the lock is not taken
- it means that another thread acquired the lock and still processing this runId
- the `finally` block will actually release the lock while another thread is still working on the task
If the task gets distributed to the same worker after that, two threads will start working on the same instance of the workflow, which will lead to all kinds of problems, because workflow state machines are expected to be managed by one thread only.

This scenario is not happening on a normal happy path. This scenario usually doesn't happen on a bad path too, because if JavaSDL detects blocking of workflow task, it kills it with DeadlockDetector. Situations where local activities keep Workflow Task open also have special handling. But it may happen if something causes blocking of workflow tasks that are not getting detected by the Deadlock Detector.



---

<a id="1141"></a>

### #1141: Deadlock Detector unexpectedly firing on a cold JVM

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1141 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-04-14 06:44:58.000 UTC (3y 9m ago) |
| **Updated** | 2024-12-17 21:19:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | ‚ù§Ô∏è 1 |

#### Description

Cold JVM is very vulnerable to JavaSDK Potential Deadlock fiting. Below there is a stacktrace with PotentialDeadlockException fires on workflow-root thread which doesn't have any user code at all and it fails on classloading and instrumentation.

JavaSDK should implement a relaxed Deadlock Detector during the start of workers.
The most straightforward solution is to multiple the Deadlock detector by N for the first execution of a workflow of each type.

```
Caused by: io.temporal.internal.sync.PotentialDeadlockException: Potential deadlock detected: workflow thread "workflow-root" didn't yield control for over a second. Other workflow threads:
‚Äã
‚Äã
‚Äã
	at app//org.jacoco.agent.rt.internal_3570298.asm.ByteVector.enlarge(ByteVector.java:357)
	at app//org.jacoco.agent.rt.internal_3570298.asm.ByteVector.putByte(ByteVector.java:77)
	at app//org.jacoco.agent.rt.internal_3570298.asm.SymbolTable.addConstantUtf8(SymbolTable.java:774)
	at app//org.jacoco.agent.rt.internal_3570298.asm.SymbolTable.addConstantNameAndType(SymbolTable.java:740)
	at app//org.jacoco.agent.rt.internal_3570298.asm.SymbolTable.addConstantMemberReference(SymbolTable.java:572)
	at app//org.jacoco.agent.rt.internal_3570298.asm.SymbolTable.addConstantMethodref(SymbolTable.java:542)
	at app//org.jacoco.agent.rt.internal_3570298.asm.MethodWriter.visitMethodInsn(MethodWriter.java:1035)
	at app//org.jacoco.agent.rt.internal_3570298.core.internal.instr.DuplicateFrameEliminator.visitMethodInsn(DuplicateFrameEliminator.java:78)
	at app//org.jacoco.agent.rt.internal_3570298.core.internal.instr.ClassFieldProbeArrayStrategy.storeInstance(ClassFieldProbeArrayStrategy.java:55)
	at app//org.jacoco.agent.rt.internal_3570298.core.internal.instr.ProbeInserter.visitCode(ProbeInserter.java:96)
	at app//org.jacoco.agent.rt.internal_3570298.asm.MethodVisitor.visitCode(MethodVisitor.java:232)
	at app//org.jacoco.agent.rt.internal_3570298.asm.MethodVisitor.visitCode(MethodVisitor.java:232)
	at app//org.jacoco.agent.rt.internal_3570298.asm.MethodVisitor.visitCode(MethodVisitor.java:232)
	at app//org.jacoco.agent.rt.internal_3570298.asm.tree.MethodNode.accept(MethodNode.java:742)
	at app//org.jacoco.agent.rt.internal_3570298.core.internal.flow.MethodProbesVisitor.accept(MethodProbesVisitor.java:165)
	at app//org.jacoco.agent.rt.internal_3570298.core.internal.flow.ClassProbesAdapter$2.visitEnd(ClassProbesAdapter.java:89)
	at app//org.jacoco.agent.rt.internal_3570298.asm.ClassReader.readMethod(ClassReader.java:1495)
	at app//org.jacoco.agent.rt.internal_3570298.asm.ClassReader.accept(ClassReader.java:721)
	at app//org.jacoco.agent.rt.internal_3570298.asm.ClassReader.accept(ClassReader.java:401)
	at app//org.jacoco.agent.rt.internal_3570298.core.instr.Instrumenter.instrument(Instrumenter.java:90)
	at app//org.jacoco.agent.rt.internal_3570298.core.instr.Instrumenter.instrument(Instrumenter.java:108)
	at app//org.jacoco.agent.rt.internal_3570298.CoverageTransformer.transform(CoverageTransformer.java:92)
	at java.instrument@13.0.2/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
	at java.instrument@13.0.2/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at java.instrument@13.0.2/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:563)
	at java.base@13.0.2/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base@13.0.2/java.lang.ClassLoader.defineClass(ClassLoader.java:1016)
	at java.base@13.0.2/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:151)
	at java.base@13.0.2/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:821)
	at java.base@13.0.2/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:719)
	at java.base@13.0.2/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:642)
	at java.base@13.0.2/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:600)
	at java.base@13.0.2/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base@13.0.2/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.MemberDeserializer.loadProperty(MemberDeserializer.kt:92)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedMemberScope$OptimizedImplementation.computeProperties(DeserializedMemberScope.kt:314)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedMemberScope$OptimizedImplementation.access$computeProperties(DeserializedMemberScope.kt:228)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedMemberScope$OptimizedImplementation$properties$1.invoke(DeserializedMemberScope.kt:253)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedMemberScope$OptimizedImplementation$properties$1.invoke(DeserializedMemberScope.kt:253)
	at app//kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$MapBasedMemoizedFunction.invoke(LockBasedStorageManager.java:578)
	at app//kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$MapBasedMemoizedFunctionToNotNull.invoke(LockBasedStorageManager.java:651)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedMemberScope$OptimizedImplementation.getContributedVariables(DeserializedMemberScope.kt:338)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedMemberScope$OptimizedImplementation.addFunctionsAndPropertiesTo(DeserializedMemberScope.kt:352)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedMemberScope.computeDescriptors(DeserializedMemberScope.kt:115)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor$DeserializedClassMemberScope$allDescriptors$1.invoke(DeserializedClassDescriptor.kt:257)
	at app//kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor$DeserializedClassMemberScope$allDescriptors$1.invoke(DeserializedClassDescriptor.kt:256)
	at app//kotlin.reflect.jvm.internal.impl.storage.Loc...
```


---

<a id="1113"></a>

### #1113: Unbalance external workflow configuration?

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1113 |
| **State** | OPEN |
| **Author** | javiercanillas (Javier Canillas) |
| **Created** | 2022-03-29 13:34:18.000 UTC (3y 9m ago) |
| **Updated** | 2022-04-01 22:02:06.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Workflow configuration can be achieved in two different ways. The first one, descrived on docs is through the Workflow implementation constructor, like the following (snipped code taken from [tutorial](https://github.com/temporalio/money-transfer-project-template-java/blob/master/src/main/java/moneytransferapp/MoneyTransferWorkflowImpl.java#L12)):

```java
public class MoneyTransferWorkflowImpl implements MoneyTransferWorkflow {
    private static final String WITHDRAW = "Withdraw";
    // RetryOptions specify how to automatically handle retries when Activities fail.
    private final RetryOptions retryoptions = RetryOptions.newBuilder()
            .setInitialInterval(Duration.ofSeconds(1))
            .setMaximumInterval(Duration.ofSeconds(100))
            .setBackoffCoefficient(2)
            .setMaximumAttempts(500)
            .build();
    private final ActivityOptions defaultActivityOptions = ActivityOptions.newBuilder()
            // Timeout options specify when to automatically timeout Activities if the process is taking too long.
            .setStartToCloseTimeout(Duration.ofSeconds(5))
            // Optionally provide customized RetryOptions.
            // Temporal retries failures by default, this is simply an example.
            .setRetryOptions(retryoptions)
            .build();
```

By doing this, configuration seems a little *hardcoded*. But I can have 3 levels of `ActivityOptions`:

1. **A default one that applies to all non-configured activities**, by giving `defaultActivityOptions` to all activities during creation time except those that requires a particular configuration, method to be used `Workflow.newActivityStub(Class<T> activityInterface, ActivityOptions options)`

2. **A particular Option to all methods on a particular Activity**, by creating a particular `ActivityOptions` instead of default and passing it as argument to `Workflow.newActivityStub(Class<T> activityInterface, ActivityOptions options)` when creating the activity instance.
3. **A method base option map**, further configuration might be achieved by using  `Workflow.newActivityStub(Class<T> activityInterface, ActivityOptions options, Map<String, ActivityOptions> activityMethodOptions)`, where each method of the activity can have its own `ActivityOptions`. (This approach is a little tricky since it doesn't support polymorphism)


On the other way, to avoid *hardcoding* configuration, We can use `Worker.registerWorkflowImplementationTypes(WorkflowImplementationOptions options, Class<?>... workflowImplementationClasses)`, by doing so, we need to pass `WorkflowImplementationOptions` containing `defaultActivityOptions` that matches point 1 and also `activityOptions` that matches point 3 of the other approach. But this strategy misses the second point of the above approach, leaving only a default activity option for the whole workflow activities and expose limitation over method polymorphism inside the same activity class (same problem as the method above) and adds a new unique limitation that requires not activities sharing method names.

**Describe the solution you'd like**
Leaving the local method polymorphism method limitation aside, it would be awesome to balance this two configuration strategies to be able to achieve the same without sacrificing functionality.

**Describe alternatives you've considered**
Not much, I have been struggling with this for a while now.

**Additional context**
None so far.



---

<a id="1098"></a>

### #1098: Provide ActivityStub#fromTyped

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1098 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-03-24 21:58:20.000 UTC (3y 9m ago) |
| **Updated** | 2022-03-24 21:58:20.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

As we have `WorkflowStub#fromTyped`, we should have `ActivityStub#fromTyped`. Untyped activity stubs have significantly limited usage in comparison with WorkflowStub, but there is no reason why there shouldn't be a unified experience.


---

<a id="1081"></a>

### #1081: Test flakes with Real Temporal Server leading to infinite activity retry

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1081 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-03-17 22:11:09.000 UTC (3y 9m ago) |
| **Updated** | 2025-05-15 02:24:28.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

`io.temporal.internal.testing.WorkflowTestingTest > testActivityFailure`

fails with 

```
io.temporal.internal.testing.WorkflowTestingTest > testActivityFailure STANDARD_OUT

    21:11:19.001 [Activity Executor taskQueue="test-workflow", namespace="default": 1] WARN  i.t.i.a.POJOActivityTaskHandler - Activity failure. ActivityId=38334385-1f57-30b4-bc10-97377255f018, activityType=Execute, attempt=1

    java.lang.IllegalThreadStateException: Execute-input1
    	at io.temporal.internal.testing.WorkflowTestingTest$FailingActivityImpl.execute(WorkflowTestingTest.java:596)
    	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    	at java.lang.reflect.Method.invoke(Method.java:498)
    	at io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:214)
    	at io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityImplementation.execute(POJOActivityTaskHandler.java:180)
    	at io.temporal.internal.activity.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:120)
    	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:204)
    	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:14)
    	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:750)
.......

    21:20:04.797 [Activity Executor taskQueue="test-workflow", namespace="default": 21] WARN  i.t.i.a.POJOActivityTaskHandler - Activity failure. ActivityId=38334385-1f57-30b4-bc10-97377255f018, activityType=Execute, attempt=78094

    java.lang.IllegalThreadStateException: Execute-input1
    	at io.temporal.internal.testing.WorkflowTestingTest$FailingActivityImpl.execute(WorkflowTestingTest.java:596)
    	at sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
    	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    	at java.lang.reflect.Method.invoke(Method.java:498)
    	at io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:214)
    	at io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityImplementation.execute(POJOActivityTaskHandler.java:180)
    	at io.temporal.internal.activity.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:120)
    	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:204)
    	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:164)
    	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:750)
```

and getting killed by timeout.

It flakes with real Temporal Server only and may manifest a severe server issue.

[java-sdk-public_build_649_docker-unit-test-with-docker-service.log.zip](https://github.com/temporalio/sdk-java/files/8292866/java-sdk-public_build_649_docker-unit-test-with-docker-service.log.zip)



---

<a id="1079"></a>

### #1079: Issue with TestWorkflowEnvironment and ParentClosePolicy

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1079 |
| **State** | OPEN |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-03-17 21:52:46.000 UTC (3y 9m ago) |
| **Updated** | 2024-11-19 19:10:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

It looks as during testing child workflow thats started async, with ChildWorkflowOptions->setParentClosePolicy is TERMINATE
when the parent completes, the child workflow is not terminated, but still is allowed to complete.

Reproducer: https://github.com/tsurdilo/test-reproducer
Clone repo, run "mvn clean install" 
You will see test fail with:

org.junit.ComparisonFailure: 
Expected :WORKFLOW_EXECUTION_STATUS_TERMINATED
Actual   :WORKFLOW_EXECUTION_STATUS_COMPLETED


---

<a id="1069"></a>

### #1069: TestWorkflowEnvironment schedules the first activity retry immediately

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1069 |
| **State** | OPEN |
| **Author** | nagl-stripe |
| **Created** | 2022-03-10 19:36:21.000 UTC (3y 10m ago) |
| **Updated** | 2024-11-19 19:11:07.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
With a retry policy like:
```
      RetryOptions.newBuilder()
          .setInitialInterval(Duration.ofSeconds(10))
          .setBackoffCoefficient(2.0)
          .build();
```

I would expect delays of 10, 20, 40, 80, so attempts (including the first one) run at T0, 10, 30, 70, 150.

## Actual Behavior

Attempts run at T0, 0, 10, 30, 70 - the first retry gets scheduled immediately.

## Steps to Reproduce the Problem

Check out https://github.com/nagl-stripe/sdk-java/commit/b4f764dfdc22102893be1916b325a40322ccd54e - it has a test case that would pass if the actual behavior were the expected behavior

This is very much not-urgent =)

## Specifications

  - Version: latest
  - Platform: TestWorkflowEnviornment


---

<a id="1066"></a>

### #1066: Deadlock Detector leads to workflow code getting "Operation allowed only while eventLoop is running"

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1066 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-03-08 00:24:48.000 UTC (3y 10m ago) |
| **Updated** | 2022-04-11 14:25:24.000 UTC |
| **Closed** | 2022-04-11 14:25:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

## Actual Behavior

If workflow execution was killed and evicted on the worker by the Deadlock Detector initiating `PotentialDeadlockException` in control thread, workflow code is getting IllegalStateException("Operation allowed only while eventLoop is running") on the first arrival into Temporal framework code.
While not dangerous for workflow determinism, this exception may be caught by `catch` and `finally` blocks and lead to side effects in users' code. 

## Expected Behavior

Temporal SDK should throw DestroyWorkflowThreadError or some other kind of Error in this situation that will lead to the killing of the workflow thread.


---

<a id="1050"></a>

### #1050: Activity interface which extends an interface with some method using generic types always throws a ClassCastException when said method is called in a Workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1050 |
| **State** | OPEN |
| **Author** | natalie-zamani (Natalie Zamani) |
| **Created** | 2022-02-21 23:13:33.000 UTC (3y 10m ago) |
| **Updated** | 2023-04-20 17:39:22.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üëÄ 1 |

#### Description

## Expected Behavior
I would expect that an activity interface that extends some other interface with generic types and a method that uses those generic types would have that inherited method be executable as an activity method within a workflow.

## Actual Behavior
A method that's inherited and uses generics in an activity interface always throws a `ClassCastException` when called within a workflow.

An example of the exception (using the repro code included in this issue) is. as follows:
```kotlin
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class issue.repro.Foo (java.util.LinkedHashMap is in module java.base of loader 'bootstrap'; issue.repro.Foo is in unnamed module of loader 'app')
	at issue.repro.MyActivityImpl.run(ActivityIssueReproTest.kt:38)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:214)
	at io.temporal.internal.activity.POJOActivityTaskHandler$POJOActivityImplementation.execute(POJOActivityTaskHandler.java:180)
	at io.temporal.internal.activity.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:120)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:235)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:207)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:196)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:93)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
```

## Steps to Reproduce the Problem
The repro Kotlin code below uses the Temporal Java SDK (with the Kotlin library), and [mockk](https://mockk.io) and [Kotest](https://kotest.io).

```kotlin
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import io.kotest.core.spec.style.ShouldSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import io.temporal.activity.ActivityInterface
import io.temporal.activity.LocalActivityOptions
import io.temporal.client.WorkflowClientOptions
import io.temporal.client.WorkflowOptions
import io.temporal.common.converter.DefaultDataConverter
import io.temporal.common.converter.JacksonJsonPayloadConverter
import io.temporal.internal.logging.LoggerTag
import io.temporal.testing.TestEnvironmentOptions
import io.temporal.testing.TestWorkflowEnvironment
import io.temporal.worker.Worker
import io.temporal.worker.WorkerOptions
import io.temporal.worker.WorkflowImplementationOptions
import io.temporal.workflow.Workflow
import io.temporal.workflow.WorkflowInterface
import io.temporal.workflow.WorkflowMethod
import java.time.Duration

class Foo

class Bar

interface InterfaceWithGenerics<InputT : Any, OutputT : Any> {
    fun run(input: InputT): OutputT
}

@ActivityInterface
interface MyActivity : InterfaceWithGenerics<Foo, Bar>

class MyActivityImpl : MyActivity {
    override fun run(input: Foo): Bar {
        return Bar()
    }
}

@WorkflowInterface
interface MyWorkflow {
    @WorkflowMethod
    fun run(input: Foo): Bar
}

class MyWorkflowImpl : MyWorkflow {
    private val myActivity = Workflow.newLocalActivityStub(
        MyActivity::class.java,
        LocalActivityOptions { setStartToCloseTimeout(Duration.ofSeconds(10)) }
    )

    override fun run(input: Foo): Bar {
        return myActivity.run(input)
    }
}

class ActivityIssueReproTest : ShouldSpec({
    val myActivity = mockk<MyActivityImpl>()

    val testEnv: TestWorkflowEnvironment = run {
        val objectMapper: ObjectMapper = ObjectMapper().also { mapper ->
            mapper.registerKotlinModule()
        }
        val dataConverter = DefaultDataConverter(JacksonJsonPayloadConverter(objectMapper))
        val workflowClientOptions = WorkflowClientOptions.newBuilder()
            .setDataConverter(dataConverter)
            .build()
        val workflowTestEnvironmentOptions = TestEnvironmentOptions.newBuilder()
            .setWorkflowClientOptions(workflowClientOptions)
            .build()

        TestWorkflowEnvironment.newInstance(workflowTestEnvironmentOptions)
    }

    val worker: Worker = run {
        val workerOptions: WorkerOptions = WorkerOptions.newBuilder()
            .setDefaultDeadlockDetectionTimeout(5_000L)
            .validateAndBuildWithDefaults()

        testEnv.newWorker(LoggerTag.TASK_QUEUE, workerOptions).also { worker ->
            // Register the workflow implementation(s)
            worker.registerWorkflowImplementationTypes(
                WorkflowImplementationOptions { setFailWorkflowExceptionTypes(Throwable::class.java) },
                MyWorkflowImpl::class.java
            )
            // Register the activity implementation(s)
            worker.registerActivitiesImplementations(myActivity)
        }
    }

    val defaultWorkflowOptions = WorkflowOptions
        .newBuilder()
        .setTaskQueue(LoggerTag.TASK_QUEUE)
        .build()

    beforeTest {
        testEnv.start()
    }

    should("repro the Temporal issue we're seeing") {
        val response = Bar()
        every { myActivity.run(any()) } returns response

        val myWorkflow = testEnv.workflowClient.newWorkflowStub(
            MyWorkflow::class.java,
            defaultWorkflowOptions
        )

        val foo = Foo()
        val result = myWorkflow.run(foo)

        result shouldBe response
        verify {
            myActivity.run(foo)
        }
    }

    afterTest {
        testEnv.close()
    }
})
```

## Specifications

  - Version: 1.8.0
  - Platform: macOS



---

<a id="1037"></a>

### #1037: Canceling of child workflow schedule command problem

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1037 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-10 18:26:17.000 UTC (3y 11m ago) |
| **Updated** | 2022-06-19 23:53:37.000 UTC |
| **Closed** | 2022-06-19 23:53:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.13.0 |

#### Description

## Expected Behavior

Asynchronously scheduled child workflow that was not yet scheduled on the server can be successfully canceled.

## Actual Behavior

https://community.temporal.io/t/cancel-of-a-cancellationscope-not-working-as-expected/3885/10
It looks like there is a state machines problem:

```
12:34:08.580 [TemporalShutdownManager: 1] WARN  i.t.i.sync.DeterministicRunnerImpl - Promise completed with exception and was never accessed. The ignored exception:
java.lang.RuntimeException: ChildWorkflow: failure executing START_COMMAND_CREATED->CANCEL, transition history is [CREATED->SCHEDULE]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:151)
	at io.temporal.internal.statemachines.StateMachine.handleExplicitEvent(StateMachine.java:91)
	at io.temporal.internal.statemachines.EntityStateMachineBase.explicitEvent(EntityStateMachineBase.java:78)
	at io.temporal.internal.statemachines.ChildWorkflowStateMachine.cancel(ChildWorkflowStateMachine.java:204)
	at io.temporal.internal.statemachines.WorkflowStateMachines.lambda$startChildWorkflow$3c6a4bb6$1(WorkflowStateMachines.java:583)
	at io.temporal.internal.replay.ReplayWorkflowContextImpl.lambda$startChildWorkflow$547d36$1(ReplayWorkflowContextImpl.java:229)
	at io.temporal.internal.sync.SyncWorkflowContext.lambda$executeChildWorkflow$8d8a678d$1(SyncWorkflowContext.java:513)
	at io.temporal.internal.sync.CompletablePromiseImpl.lambda$thenApply$2df5ef44$1(CompletablePromiseImpl.java:210)
	at io.temporal.internal.sync.CompletablePromiseImpl.lambda$handle$6a2a7e3d$1(CompletablePromiseImpl.java:219)
	at io.temporal.internal.sync.CompletablePromiseImpl.lambda$then$16b0e4cc$1(CompletablePromiseImpl.java:268)
	at io.temporal.internal.sync.CompletablePromiseImpl.invokeHandlers(CompletablePromiseImpl.java:276)
	at io.temporal.internal.sync.CompletablePromiseImpl.complete(CompletablePromiseImpl.java:167)
	at io.temporal.internal.sync.CancellationScopeImpl.cancel(CancellationScopeImpl.java:120)
	at io.temporal.workflow.MaximCodeModified$ParentWorkflowImpl.ParentGreeting(MaximCodeModified.java:148)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.execute(POJOWorkflowImplementationFactory.java:317)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:292)
	at io.temporal.internal.sync.WorkflowExecuteRunnable.run(WorkflowExecuteRunnable.java:72)
	at io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:137)
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:101)
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:111)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.lang.NullPointerException: null
	at java.base/java.util.Objects.requireNonNull(Objects.java:221)
	at io.temporal.failure.CanceledFailure.<init>(CanceledFailure.java:32)
Caused by: java.lang.NullPointerException: null

	at io.temporal.internal.statemachines.ChildWorkflowStateMachine.cancelStartChildCommand(ChildWorkflowStateMachine.java:215)
	at io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:45)
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:147)
```


---

<a id="1035"></a>

### #1035: Add metric for time passed from the activity scheduling to the last attempt

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1035 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-08 17:56:18.000 UTC (3y 11m ago) |
| **Updated** | 2024-12-17 21:27:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
If users want to set an alert for activities that keep retrying and failing, there is no appropriate metric to handle that.
`activity_succeed_endtoend_latency` includes only successful executions.
`activity_execution_latency` handles the execution of a single activity task only.

**Describe the solution you'd like**
We should add a metric reporting how much time passed from an activity schedule to the last activity attempt. This metric should have an activity type as a tag and be SDK side.

**Describe alternatives you've considered**
Users can produce their own custom metrics. But it looks like such a common concern, that Temporal SDK should provide a built-in way to detect it.

GoSDK issue: https://github.com/temporalio/sdk-go/issues/718


---

<a id="1033"></a>

### #1033: java-sdk 1.8.0 can't be used with maven

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1033 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-02-07 18:25:44.000 UTC (3y 11m ago) |
| **Updated** | 2022-02-09 18:13:09.000 UTC |
| **Closed** | 2022-02-09 18:13:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

## Actual Behavior

When using java-sdk 1.8.0 with maven 3.8.4, `Could not find artifact com.fasterxml.jackson:jackson-bom:pom:[2.9.0,) in central` exception is thrown.

## Root cause

Temporal JavaSDK switched to using version ranges of dependencies in 1.8.0 and utilizing gradle platforms.
Gradle Platforms with version range are translated effectively into the Maven `dependencyManagement` section that looks like:

```
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>com.fasterxml.jackson</groupId>
      <artifactId>jackson-bom</artifactId>
      <version>[2.9.0,)</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```

It's a long-time Maven bug of not supporting version ranges in dependencyManagement sections.
This bug was fixed and scheduled for 4.0.0 release, which is not available yet.
There is a lot of issues in the Maven bug tracker about this problem, but the most relevant and accurate is https://issues.apache.org/jira/browse/MNG-4463


---

<a id="1019"></a>

### #1019: Log long poll failures (but not too frequently to avoid spamming)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1019 |
| **State** | OPEN |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2022-01-31 18:44:54.000 UTC (3y 11m ago) |
| **Updated** | 2022-01-31 18:44:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

This is already implemented in Core and now in Go.

Java should have the same behavior.

See: https://github.com/temporalio/sdk-go/pull/708


---

<a id="1009"></a>

### #1009: Provide ActivityStub that is bound to the specific activityType or a specific invocation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1009 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-29 21:39:47.000 UTC (3y 11m ago) |
| **Updated** | 2024-12-17 21:19:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Temporal JavaSDK has an untyped `WorkflowStub` that is bound to a specific method invocation (workflow method), while a currently existing ActivityStub is bound to the AcitivityInterface and not to the specific activity type. 

The source of the inconsistency is that one `WorkflowInterface` has always only one "entry" workflow method, while an ActivityInterface can have several `ActivityMethod`.

To keep things consistent, we should have a variation of the ActivityStub that binds an execution of the activity to a specific type the same way as WorkflowStub. There also should be an `ActivityStub.fromTyped` method working similarly with `WorkflowStub.fromTyped` (but probably taking a method reference instead of a pointer to an instance)

The current Activity stub that we have in JavaSDK looks like
```
public interface ActivityStub {
  <R> R execute(String activityName, Class<R> resultClass, Object... args);

  <R> R execute(String activityName, Class<R> resultClass, Type resultType, Object... args);

  <R> Promise<R> executeAsync(String activityName, Class<R> resultClass, Object... args);

  <R> Promise<R> executeAsync(
      String activityName, Class<R> resultClass, Type resultType, Object... args);
}```
which is inconsistent with WorkflowStub and makes it harder to work with untyped ActivityStubs.



---

<a id="1004"></a>

### #1004: Local Activity Worker ignores startToClose and scheduleToClose timeouts

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/1004 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-25 19:54:23.000 UTC (3y 11m ago) |
| **Updated** | 2022-11-24 04:44:52.000 UTC |
| **Closed** | 2022-11-24 04:44:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.18.0 |

#### Description

## Expected Behavior

Local Activity Worker should respect `startToClose` timeout and initiate a new activity execution if the activity call doesn't finish during a user-defined timeout. 
A timed-out execution should be abandoned.

## Actual Behavior

`startToClose` is ignored and not enforced anyhow by JavaSDK. The local activity can run up to scheduleToClose timeout is reached even if much shorter `startToClose` is provided.



---

<a id="998"></a>

### #998: Bring Pollers & Workers on par with Core and Go implementations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/998 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-24 02:17:04.000 UTC (3y 11m ago) |
| **Updated** | 2022-09-16 16:58:09.000 UTC |
| **Closed** | 2022-09-16 16:58:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.17.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, JavaSDK creates one sticky queue per Workflow factory and one sticky poller is shared between all the workers. 
This creates several problems:
- Inability to rate limit WFT
- Inability to implement backpressure from each worker, because it will delay sticky queue for all workers
- Inability to prioritize sticky queue over the normal queue processing
- Other complexities with resources isolation

**Describe the solution you'd like**
A sticky queue and poller per each worker.
This will also open the road to implement the same backpressure semantic we have for activities when pollers don't poll until there is an available processing slot to address #760 

**Additional context**
The counter added in #997 should be reworked to a more strict reporting of a semaphore value, which will be possible after addressing this task.


---

<a id="991"></a>

### #991: Add Jackson jdk8 support in JacksonJsonPayloadConverter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/991 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-01-20 19:11:43.000 UTC (3y 11m ago) |
| **Updated** | 2022-01-24 21:17:49.000 UTC |
| **Closed** | 2022-01-21 18:51:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | tsurdilo |
| **Milestone** | 1.8.0 |

#### Description

Currently our JacksonJsonPayloadConverter does not register Jackson jdk8 support.
Adding would allow workflow / activities to use optional params, for example Optional<MyClass> etc.


---

<a id="988"></a>

### #988: Make WorkflowServiceStubsOptions#rpcLongPollTimeout configurable

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/988 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-19 03:17:03.000 UTC (3y 11m ago) |
| **Updated** | 2022-05-16 03:52:26.000 UTC |
| **Closed** | 2022-05-16 03:52:26.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.12.0 |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now WorkflowServiceStubsOptions#rpcLongPollTimeout has to be 70s or more because Server's default timeout is 60s.
It looks like now Server uses a timeout from the client that initiates the long poll to return the result (empty or non-empty) in time. And 60s is just a cap for this timeout.

> Yimin Chen 
> To be clear, if the context timeout on the connection is less than 60s, server would return empty response before timeout hit.
> there is a small gap server added to make sure the empty response is delivered before actual context timeout when it is less than 60s.
> 

Not allowing users to configure the long polls to be shorter than 70s, Temporal makes configuration tricky for some of the users who may be using middle layers with a strict configuration (like reverse proxies) that may limit the durtion of long polls.

**Describe the solution you'd like**
Taking into account that the Server takes a time limit from the request timeout/deadline to return a response in an amount of time shorter than 60s, we can allow an SDK to accept rpcLongPollTimeout values less than the 70s. that and returns a response in a shorter amount of time.

GoSDK: https://github.com/temporalio/sdk-go/issues/705



---

<a id="986"></a>

### #986: Add metrics for active executors threads

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/986 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-19 01:01:43.000 UTC (3y 11m ago) |
| **Updated** | 2022-01-24 18:30:25.000 UTC |
| **Closed** | 2022-01-24 18:30:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.8.0 |

#### Description

**Is your feature request related to a problem? Please describe.**

Right now metrics that are provided by JavaSDK don't give a direct answer to a question of what percentage of WTF, Activity, or Local Activity executors threads are actually used. 
We have a metric that gives us time between SCHEDULE and PULL of the task (SCHEDULE_TO_START) that can be judged that there are not enough Pollers.
We have a metric that gives us information on how long does it take to process a task (execution_latency)
But we don't have any direct stats helping to understand that we don't have enough executors. We can theoretically have an underloaded host with not enough executor threads and no metric to understand that we utilize the executor pool fully and we should increase its size.

**Describe the solution you'd like**
Report a gauge metric with a number of available threads in Executor ThreadPools.



---

<a id="975"></a>

### #975: Provide WorkflowImplementationOptions.setLocalActivityOptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/975 |
| **State** | CLOSED |
| **Author** | tsurdilo (Tihomir Surdilovic) |
| **Created** | 2022-01-13 20:26:23.000 UTC (3y 12m ago) |
| **Updated** | 2022-01-25 03:58:32.000 UTC |
| **Closed** | 2022-01-25 03:58:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Currently users can supply a Map<String, ActivityOptions> in WorkflowImplementationOptions.setActivityOptions allowing them to define activity options for different types of activities so they don't have to define them in workflow code.

This request is to add 
WorkflowImplementationOptions.setLocalActivityOptions

which would be applied to Workflow.newLocalActivityStub and can be overwritten if specific LocalActivity options are specified (just like how it works with  Workflow.newActivityStub now)


---

<a id="964"></a>

### #964: Version ranges are lost during artifact publication

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/964 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-11 21:51:28.000 UTC (3y 12m ago) |
| **Updated** | 2022-01-12 22:23:30.000 UTC |
| **Closed** | 2022-01-12 22:23:30.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.8.0 |

#### Description

## Expected Behavior

We have wide ranges of versions for supported dependencies to simplify development for the users that we maintain.
These ranges should be published into our Gradle modules that we publish into Nexus.

## Actual Behavior

The version ranges are lost during publication and replaced with strict requirements as may be seen here:
https://repo1.maven.org/maven2/io/temporal/temporal-sdk/1.7.0/temporal-sdk-1.7.0.module
This makes Temporal users struggle with the dependencies matrix



---

<a id="948"></a>

### #948: Local DynamicActivity has a regular activity context

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/948 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2022-01-04 04:44:33.000 UTC (4 years ago) |
| **Updated** | 2022-01-05 02:43:59.000 UTC |
| **Closed** | 2022-01-05 02:43:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.7.0 |

#### Description

## Expected Behavior

DynamicActivity should behave as a normal regular or local activity in respect to heart beating and other concepts. 

## Actual Behavior

DynamicActivity has a regular activity context even if called as a local activity.


---

<a id="925"></a>

### #925: SimpleSslContextBuilder works only with PKCS8 while all Temporal TSL examples and manuals are with PKCS12

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/925 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-12-09 03:30:36.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-29 20:18:47.000 UTC |
| **Closed** | 2021-12-29 20:18:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.7.0 |

#### Description

`SimpleSslContextBuilder` uses and exposes working with PKCS8 only.
Meanwhile, all Temporal server docs and examples like https://github.com/temporalio/samples-server/tree/main/tls/client-only are working with PKCS12 only.
This inconsistency creates unneeded troubles for users in understanding how to put pieces together correctly.
We need:
1. Add code to `SimpleSslContextBuilder` supporting PKCS12 certificates. Users shouldn't have to convert certificates to PKCS8 for JavaSDK only.
2. We should improve javadocs with some more direct usage examples.


---

<a id="922"></a>

### #922: OpenTracing context is not propagated in some cases

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/922 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-12-07 19:20:03.000 UTC (4y 1m ago) |
| **Updated** | 2024-12-23 12:48:47.000 UTC |
| **Closed** | 2024-12-23 12:48:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

- [x] Child workflows as reported in comments in #537
- [x] Async invocation of a function or procedure as lambda (works if we invoke a stub method reference, like `Async.function(activityStub:activityMethod)`), see #537 too
- [x] `continueAsNew` needs a proper wiring of headers and OT implementation #844
- [ ] signal methods (headers on these methods are recently implemented) #1306


---

<a id="912"></a>

### #912: startWithSignal exception with configured opentracing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/912 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-12-03 17:11:53.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-06 06:01:54.000 UTC |
| **Closed** | 2021-12-03 18:38:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |

#### Description

```
Caused by: java.lang.NullPointerException: null value in entry: runId=null
	at com.google.common.collect.CollectPreconditions.checkEntryNotNull(CollectPreconditions.java:33)
	at com.google.common.collect.ImmutableMap.entryOf(ImmutableMap.java:337)
	at com.google.common.collect.ImmutableMap.of(ImmutableMap.java:135)
	at io.temporal.opentracing.internal.ActionTypeAndNameSpanBuilderProvider.getSpanTags(ActionTypeAndNameSpanBuilderProvider.java:84)
	at io.temporal.opentracing.internal.ActionTypeAndNameSpanBuilderProvider.createSpanBuilder(ActionTypeAndNameSpanBuilderProvider.java:48)
	at io.temporal.opentracing.internal.SpanFactory.createSpan(SpanFactory.java:169)
	at io.temporal.opentracing.internal.SpanFactory.createWorkflowStartSpan(SpanFactory.java:63)
	at io.temporal.opentracing.internal.OpenTracingWorkflowClientCallsInterceptor.createWorkflowStartSpanBuilder(OpenTracingWorkflowClientCallsInterceptor.java:77)
	at io.temporal.opentracing.internal.OpenTracingWorkflowClientCallsInterceptor.createAndPassWorkflowStartSpan(OpenTracingWorkflowClientCallsInterceptor.java:70)
	at io.temporal.opentracing.internal.OpenTracingWorkflowClientCallsInterceptor.signalWithStart(OpenTracingWorkflowClientCallsInterceptor.java:59)
	at io.temporal.internal.sync.WorkflowStubImpl.signalWithStartWithOptions(WorkflowStubImpl.java:148)
```


---

<a id="906"></a>

### #906: Heartbeat throttling interval should be configurable and default interval should be greater than 0

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/906 |
| **State** | CLOSED |
| **Author** | bergundy (Roey Berman) |
| **Created** | 2021-11-30 02:20:21.000 UTC (4y 1m ago) |
| **Updated** | 2022-01-03 18:44:09.000 UTC |
| **Closed** | 2022-01-03 18:44:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.7.0 |

#### Description

The Java SDK should implement the new heartbeat throttling behavior:

Add 2 new `WorkerOption`s:

- `maxHeartbeatThrottleInterval` - default 60s
- `defaultHeartbeatThrottleInterval` - default 30s

`throttleInterval` = `min`(

`heartbeat_timeout * .8` if `heartbeat_timeout` is provided

else `defaultHeartbeatThrottleInterval`

, `maxHeartbeatThrottleInterval`)

## Rationale

- Make the behavior explicit and configurable
- Keep the behavior backwards compatible
    - Java currently has an implicit maximum (30s) and default (0)
    - Go has an implicit default (10m) and no maximum
    - Core is not yet stable, from user feedback the behavior is confusing
- Not heartbeating means no cancellations, need a default value
- Consistency between the SDKs 

GoSDK equivalent task: https://github.com/temporalio/sdk-go/issues/656


---

<a id="902"></a>

### #902: Exception in one of several "parallel" workflow async functions leads to non-deterministic execution

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/902 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-28 20:00:56.000 UTC (4y 1m ago) |
| **Updated** | 2024-12-17 21:21:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

Temporal JavaSDK explicitly supports the idea of fixing a bug leading to an exception in the workflow implementation. Workflow can throw a non `ApplicationFailure` exception and such an exception can be fixed in code, the worker can be redeployed and the workflow should be able to successfully continue the existing execution without resetting the history.

The following code simulates a situation when a second asynchronously triggered procedure throws an exception on the first execution and the problem is getting "fixed" on the second attempt. You would expect that this code will be able to successfully finish on a second attempt. 

```
    public String execute(String input) {
      List<Promise<Void>> processingPromises = new ArrayList<>();
      processingPromises.add(
          Async.procedure(this::procedure, "input1", false, Workflow.isReplaying()));
      processingPromises.add(
          Async.procedure(this::procedure, "input2", true, Workflow.isReplaying()));
      processingPromises.forEach(Promise::get);
      return "done";
    }

    private void procedure(String obj, boolean failingOnTheFirstRun, boolean retrying) {
      ActivityAlphabet activity = Workflow.newActivityStub(ActivityAlphabet.class);
      
      // only the second Async procedure fails and only during the initial run 
      if (failingOnTheFirstRun && !retrying) {
        // emulating fail with some implementation bug
        throw new NullPointerException();
      }
      activity.doA(obj);
      activity.doB(obj);
    }
```

## Actual Behavior

Non-deterministic exception:

```
Caused by: io.temporal.worker.NonDeterministicException: Failure handling event 11 of type 'EVENT_TYPE_ACTIVITY_TASK_SCHEDULED' during replay. Command COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK doesn't match event EVENT_TYPE_ACTIVITY_TASK_SCHEDULED with EventId=11 on check activityType with an expected value name: "DoA"
 and an actual value name: "DoB"
. {PreviousStartedEventId=9, workflowTaskStartedEventId=18, Currently Processing StartedEventId=9}
	at io.temporal.internal.statemachines.WorkflowStateMachines.assertMatch(WorkflowStateMachines.java:887)
	at io.temporal.internal.statemachines.WorkflowStateMachines.validateCommand(WorkflowStateMachines.java:817)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleCommandEvent(WorkflowStateMachines.java:338)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleSingleEvent(WorkflowStateMachines.java:229)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventsBatch(WorkflowStateMachines.java:200)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:176)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:176)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:145)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithQuery(ReplayWorkflowTaskHandler.java:127)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:102)
```

Test reproducing the problem: https://github.com/Spikhalskiy/java-sdk/commit/43ce60f9518fc1acb871a73aafab6df2a57749df#diff-96be05397e0cfb9f8d1bdc02587f70a34e65e1b42b8e908964162f39d27f249aR46

## Root cause analysis

1. Async procedure can't propagate the exception on the main worklow thead when it happens, the exception "stays in the Promise" until it's checked.
2. Workflow code is awaiting for the first promise from the non-failing procedure before starting the await on the second failing promise.
3. Failure of the second procedure is getting ignored for some time and the first procedure gets a chance to advance and be fully complete, produce a couple of completed activity executions before we realize that the second procedure is failed already. 
4. These "unlawfully" advanced first procedure and it's scheduled activities recorded in the history create a history that is incompatible with "fixed" code and can't be replayed by a "fixed" version.

The reason this happens is eager evaluation. As soon as the promises are created they begin evaluating. Now imagine the following sequence of events:

**First execution**
1. Promises 1&2 start running
1. Promise 1 schedules A
1. Promise 2 throws, but exception is not propagated up yet
1. Promise 1 schedules B
1. We send 1A and 1B to server
Next go-round we blow up w/ the exception

**Expected fixed execution**
1. Promises 1&2 start running
1. Promise 1 schedules A
1. Promise 2 schedules A because it is fixed now _//<-- Failing here now_
1. Promise 1 schedules B
1. Promise 2 schedules B

Oops now 2A is out-of-order according to existing history. 2B would be OK since there was nothing before it besides the task failure in history.
So, we are failing after step 3 with non-deterministic error because the command 2A doesn't match the expected event 1B from the history.

## Workaround

1. Using `Promise.allOf` to wait on all the promises doesn't allow the exception to be "ignored" because we wait only on the one promise at a time. Has to be implemented correctly in this way before the problem actually happened and the incorrect history is already produced.
1. Promoting all exceptions happening in Async functions/procedures to Errors solves this by immediately failing the workflow task. This has to be done before the workflow execution and before the incompatible history is already produced.

The only solution if the problem already manifested itself is history reset + one of the workarounds to prevent it from happening again.

## Notes about the original user report

Investigation triggered by:
https://community.temporal.io/t/verifying-error-handling-and-fixing-buggy-code-within-async-procedure-promises/3391/10

Which leaded to creation of simplified flaky reproduction 
https://github.com/Spikhalskiy/java-sdk/commit/eb6b44142fa5f2fb31809dace8aedb435307430b
that flakes about 5% of the time and requires `WorkflowImplZRetriesTestCopy1` to be executed after `WorkflowImplRetriesTest` to increase the chance of the problem happening.

The original flaky reproduction may be very hard to follow and link to the described issue, because the problem occurs there only under a specific ordering of the activity executions and completions that leads to an effective "reordering" of asynchronous procedures execution.




---

<a id="898"></a>

### #898: RetryOptions allows to be built with maximumInterval < minimumInterval and later fails on the server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/898 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-24 01:48:27.000 UTC (4y 1m ago) |
| **Updated** | 2021-12-06 06:01:37.000 UTC |
| **Closed** | 2021-11-24 23:37:36.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |

#### Description

## Expected Behavior

RetryOptions#validateAndBuildWithDefaults performs validation and doesn't allow to build invalid RetryOptions.

## Actual Behavior

```
{"level":"info","ts":"2021-10-29T19:20:04.407Z","msg":"Failing the workflow task.","service":"history","shard-id":2700,"address":"10.254.116.207:7234","shard-item":"0xc04c03ee00","component":"history-engine","value":"BadScheduleActivityAttributes: MaximumInterval cannot be less than InitialInterval on retry policy."
```

on the Server.


---

<a id="888"></a>

### #888: Upgrade gRPC connections configuration and strategies to support round-robin resolving for frontends

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/888 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-18 21:52:43.000 UTC (4y 1m ago) |
| **Updated** | 2025-06-02 15:15:32.000 UTC |
| **Closed** | 2025-06-02 15:15:32.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Go SDK recently implemented changes in gRPC connection and request configurations.

Find more details here: 
https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions
https://github.com/grpc/grpc/blob/master/doc/load-balancing.md

We need to support resolvers, including the one that round-robin between known frontends. This will let us remove hacks like `WorkflowServiceStubsOptions#grpcReconnectFrequency` that forcefully reestablish connections to achieve load balancing.

Internal discussion in company's slack: https://temporaltechnologies.slack.com/archives/C01FG4BRQVB/p1637267948416500

gRPC Load balancing doc:
https://github.com/grpc/grpc/blob/master/doc/load-balancing.md 

Related task in GoSDK:
https://github.com/temporalio/sdk-go/issues/577

Related task: #815


---

<a id="887"></a>

### #887: Expose WorkflowInfo.getCronSchedule

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/887 |
| **State** | CLOSED |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-17 23:40:55.000 UTC (4y 1m ago) |
| **Updated** | 2022-01-24 19:03:41.000 UTC |
| **Closed** | 2022-01-24 19:03:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | tsurdilo |
| **Milestone** | 1.8.0 |

#### Description

**Is your feature request related to a problem? Please describe.**

Go SDK has `WorkflowInfo.CronSchedule` but Java does not

**Describe the solution you'd like**

Add accessor to Java (assuming it's easy enough)


---

<a id="882"></a>

### #882: Allow to register new search attributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/882 |
| **State** | CLOSED |
| **Author** | pdoro (Pablo Domingo Rojo) |
| **Created** | 2021-11-17 15:42:06.000 UTC (4y 1m ago) |
| **Updated** | 2022-03-07 23:23:58.000 UTC |
| **Closed** | 2022-03-07 23:23:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Temporal SDK allows to communicate with temporal server through GRPC calls. Currently you can create workflows with custom search attributes but those attributes must be already registered on Elasticsearch through the `add-search-attributes` sub-command on `tctl`

**Describe the solution you'd like**
Allow to register new search attributes through the SDK

**Describe alternatives you've considered**
The only alternative by now is to run tctl 

**Additional context**
Nope



---

<a id="880"></a>

### #880: Legacy query path leads to thread leaks in case of state machine exceptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/880 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-17 06:07:16.000 UTC (4y 1m ago) |
| **Updated** | 2021-11-18 07:00:40.000 UTC |
| **Closed** | 2021-11-18 07:00:40.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |

#### Description

The following code path leads to an unreleased thread in the case of the worker / state machine exceptions (or RejectedExecutionException):

```
io.temporal.internal.worker.WorkflowExecutionException: java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4176e14b[Not completed, task = java.util.concurrent.Executors$RunnableAdapter@4beb70[Wrapped task = io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper@4747fa1]] rejected from java.util.concurrent.ThreadPoolExecutor@1faac87d[Running, pool size = 600, active threads = 600, queued tasks = 0, completed tasks = 14007]
at io.temporal.internal.sync.POJOWorkflowImplementationFactory.mapToWorkflowExecutionException(POJOWorkflowImplementationFactory.java:359)
at io.temporal.internal.sync.SyncWorkflow.mapUnexpectedException(SyncWorkflow.java:192)
at io.temporal.internal.replay.ReplayWorkflowExecutor.mapUnexpectedException(ReplayWorkflowExecutor.java:152)
at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:191)
at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleQueryWorkflowTask(ReplayWorkflowRunTaskHandler.java:246)
at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleQueryOnlyWorkflowTask(ReplayWorkflowTaskHandler.java:267)
at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:107)
at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:314)
at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:274)
at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
at java.base/java.lang.Thread.run(Thread.java:829)
```


---

<a id="871"></a>

### #871: Deadlock during activity state machine cancelation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/871 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-15 01:36:07.000 UTC (4y 1m ago) |
| **Updated** | 2023-03-07 14:28:01.000 UTC |
| **Closed** | 2023-03-07 14:28:00.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.19.0 |

#### Description

## Expected Behavior

Workflow method (https://github.com/Spikhalskiy/java-sdk/commit/1d6d8584c78df238ab06ff9d48d73b1ec4ad5bff#diff-8e1bd2b4d9c5c5fc5f71b84c7cccbfb73a8396d355e81421b4c2a66d491aa2c8R42):

```java
    @Override
    public String execute() {
      TestActivities.VariousTestActivities activities = ...
      CancellationScope cancellationScope =
          Workflow.newCancellationScope(() -> Async.procedure(activities::activity1, 1));
      cancellationScope.run();
      try {
        // Forcing an end of WFT
        Workflow.sleep(1000);
        throw ApplicationFailure.newNonRetryableFailure("messsage", "type");
      } finally {
        cancellationScope.cancel();
      }
    }
```

Should be able to fail the workflow execution. 

## Actual Behavior

Deadlock with an activity state machine triggering an event loop on cancel:


```
Nov 14, 2021 8:31:17 PM com.google.common.cache.LocalCache processPendingNotifications
WARNING: Exception thrown by removal listener
io.temporal.internal.sync.PotentialDeadlockException: Potential deadlock detected: workflow thread "workflow-method-cdfe6e1a-c034-4f15-b422-f22073c9d5b-e05bc9c6-b9cb-42b1-9661-0a861ee383b1" didn't yield control for over a second. Other workflow threads:

null

	at java.base@11.0.13/jdk.internal.misc.Unsafe.park(Native Method)
	at java.base@11.0.13/java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:234)
	at java.base@11.0.13/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2211)
	at app//io.temporal.internal.sync.WorkflowThreadContext.runUntilBlocked(WorkflowThreadContext.java:243)
	at app//io.temporal.internal.sync.WorkflowThreadImpl.runUntilBlocked(WorkflowThreadImpl.java:317)
	at app//io.temporal.internal.sync.DeterministicRunnerImpl.runUntilAllBlocked(DeterministicRunnerImpl.java:195)
	at app//io.temporal.internal.sync.SyncWorkflow.eventLoop(SyncWorkflow.java:156)
	at app//io.temporal.internal.replay.ReplayWorkflowExecutor.eventLoop(ReplayWorkflowExecutor.java:73)
	at app//io.temporal.internal.replay.ReplayWorkflowRunTaskHandler$StatesMachinesCallbackImpl.eventLoop(ReplayWorkflowRunTaskHandler.java:328)
	at app//io.temporal.internal.statemachines.WorkflowStateMachines.eventLoop(WorkflowStateMachines.java:455)
	at app//io.temporal.internal.statemachines.WorkflowStateMachines.lambda$scheduleActivityTask$ff6e4b43$1(WorkflowStateMachines.java:515)
	at app//io.temporal.internal.statemachines.WorkflowStateMachines$$Lambda$181/0x0000000800374840.apply(Unknown Source)
	at app//io.temporal.internal.statemachines.ActivityStateMachine.notifyCanceled(ActivityStateMachine.java:318)
	at app//io.temporal.internal.statemachines.ActivityStateMachine.cancelCommandNotifyCanceled(ActivityStateMachine.java:288)
	at app//io.temporal.internal.statemachines.ActivityStateMachine$$Lambda$185/0x0000000800373840.apply(Unknown Source)
	at app//io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:45)
	at app//io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:147)
	at app//io.temporal.internal.statemachines.StateMachine.handleExplicitEvent(StateMachine.java:91)
	at app//io.temporal.internal.statemachines.EntityStateMachineBase.explicitEvent(EntityStateMachineBase.java:78)
	at app//io.temporal.internal.statemachines.ActivityStateMachine.cancel(ActivityStateMachine.java:277)
	at app//io.temporal.internal.statemachines.WorkflowStateMachines$$Lambda$201/0x0000000800389040.apply(Unknown Source)
	at app//io.temporal.internal.replay.ReplayWorkflowContextImpl.lambda$scheduleActivityTask$ef6c118$1(ReplayWorkflowContextImpl.java:213)
	at app//io.temporal.internal.replay.ReplayWorkflowContextImpl$$Lambda$202/0x0000000800389440.apply(Unknown Source)
	at app//io.temporal.internal.sync.SyncWorkflowContext.lambda$executeActivityOnce$d79fb25e$1(SyncWorkflowContext.java:225)
	at app//io.temporal.internal.sync.SyncWorkflowContext$$Lambda$203/0x0000000800389840.apply(Unknown Source)
	at app//io.temporal.internal.sync.CompletablePromiseImpl.lambda$thenApply$2df5ef44$1(CompletablePromiseImpl.java:210)
	at app//io.temporal.internal.sync.CompletablePromiseImpl$$Lambda$204/0x0000000800389c40.apply(Unknown Source)
	at app//io.temporal.internal.sync.CompletablePromiseImpl.lambda$handle$6a2a7e3d$1(CompletablePromiseImpl.java:219)
	at app//io.temporal.internal.sync.CompletablePromiseImpl$$Lambda$205/0x000000080038a040.apply(Unknown Source)
	at app//io.temporal.internal.sync.CompletablePromiseImpl.lambda$then$16b0e4cc$1(CompletablePromiseImpl.java:268)
	at app//io.temporal.internal.sync.CompletablePromiseImpl$$Lambda$206/0x000000080038a440.apply(Unknown Source)
	at app//io.temporal.internal.sync.CompletablePromiseImpl.invokeHandlers(CompletablePromiseImpl.java:276)
	at app//io.temporal.internal.sync.CompletablePromiseImpl.complete(CompletablePromiseImpl.java:167)
	at app//io.temporal.internal.sync.CancellationScopeImpl.cancel(CancellationScopeImpl.java:120)
	at app//io.temporal.workflow.determinism.CancelActivityDeadlockTest$ScheduleCancelActivityWorkflow.execute(CancelActivityDeadlockTest.java:63)
	at java.base@11.0.13/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@11.0.13/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base@11.0.13/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@11.0.13/java.lang.reflect.Method.invoke(Method.java:566)
	at app//io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.execute(POJOWorkflowImplementationFactory.java:317)
	at app//io.temporal.common.interceptors.WorkflowInboundCallsInterceptorBase.execute(WorkflowInboundCallsInterceptorBase.java:37)
	at app//io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:292)
	at app//io.temporal.internal.sync.WorkflowExecuteRunnable.run(WorkflowExecuteRunnable.java:72)
	at app//io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:137)
	at app//io.temporal.internal.sync.SyncWorkflow$$Lambda$172/0x0000000800377840.run(Unknown Source)
	at app//io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:101)
	at app//io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:111)
	at java.base@11.0.13/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base@11.0.13/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base@11.0.13/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base@11.0.13/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base@11.0.13/java.lang.Thread.run(Thread.java:829)
```

## Root cause analysis

It probably happens when an activity state machine takes a `SCHEDULE_COMMAND_CREATED --> CANCELED: CANCEL` route with triggering back an event loop on a workflow thread that it's already done. It's just a guess for now.


---

<a id="864"></a>

### #864: Improve documentation for Signal Methods

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/864 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-10 18:19:12.000 UTC (4y 2m ago) |
| **Updated** | 2021-12-06 06:02:28.000 UTC |
| **Closed** | 2021-11-30 19:36:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |

#### Description

This request is related to a user request about a workflow execution reset.

When we reset a workflow to the first workflow task in history, signals that are received by the original run are appended right in front of the first WFT of the new run causing signal methods to be called before the workflow method.

We need to explain this in `@SignalMethod` javadoc and Signal documentation page that the workflow code, signal methods, query code should be written in a way that doesn't assume an ordering. Application developers should not assume that signals will be processed only after an initial trigger of the workflow method.

[Needs verification] Query documentation should also probably get the same clarifications because there are situations when a query has to be processed before the first successful WFT.

Related to a discussion under a user request in a community slack: https://temporalio.slack.com/archives/CTT84KXK9/p1636375128042600



---

<a id="862"></a>

### #862: Make tracing tags consistent across SDKs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/862 |
| **State** | OPEN |
| **Author** | cretz (Chad Retz) |
| **Created** | 2021-11-08 14:34:48.000 UTC (4y 2m ago) |
| **Updated** | 2024-12-17 21:26:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

Tracing tags are not consistent across SDKs.

**Describe the solution you'd like**

Make tracing tags consistent across SDKs.

**Additional context**

* Go: https://github.com/temporalio/sdk-go/issues/619
* TypeScript: https://github.com/temporalio/sdk-typescript/issues/360


---

<a id="860"></a>

### #860: Passing too large blob as an Activity input ends with non-descriptive gRPC error

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/860 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-05 17:55:54.000 UTC (4y 2m ago) |
| **Updated** | 2021-11-05 17:57:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

If we pass a blob as an activity input that is larger than a server limit, we should get a descriptive message from the server about the failure and a clean Activity failure.

## Actual Behavior

We get a broken gRPC channel.

## Related user request:

_while passing blob object into activity calls (say pdf or image files) I am getting the below exception
io.grpc.internal.AbstractClientStream$TransportState.inboundDataReceived Received data on closed stream_



---

<a id="857"></a>

### #857: Expose SignalExternalWorkflowExecutionCommandAttributes.ChildWorkflowOnly in SDK API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/857 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-11-04 16:55:23.000 UTC (4y 2m ago) |
| **Updated** | 2024-12-17 21:26:55.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
`SignalExternalWorkflowExecutionCommandAttributes.ChildWorkflowOnly` is not exposed as a part of any JavaSDK API.
It's also not in the parameters of signal interceptors.

**Describe the solution you'd like**
We should productize on how this flag should be exposed to the user's code. A specific usecase when settings this flag to true is also needed and will be helpful for documentation purposes.

**Additional context**
Parity between SDKs. Go and Typescript SDKs expose this flag as a part of their interceptor implementations.



---

<a id="851"></a>

### #851: Allow more granular setting of QueryRejectCondition 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/851 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-31 16:57:08.000 UTC (4y 2m ago) |
| **Updated** | 2024-12-17 21:27:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

We should be able to specify QueryRejectCondition for each query or at least for each specific workflow stub to have a granular enough control.

## Actual Behavior

Right now the only way to specify `QueryRejectCondition` in JavaSDK is on `WorkflowClientOptions`, which means that once the rejection level is specified, it will be applied for all queries for all workflows queried from the client.


---

<a id="847"></a>

### #847: testCronWorkflowWithIncrementSchedule fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/847 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-10-28 05:42:17.000 UTC (4y 2m ago) |
| **Updated** | 2021-10-28 18:44:09.000 UTC |
| **Closed** | 2021-10-28 18:44:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

io.temporal.workflow.WorkflowWithCronScheduleTest > testCronWorkflowWithIncrementSchedule FAILED

    java.lang.AssertionError: expected:<4> but was:<3>

        at org.junit.Assert.fail(Assert.java:89)

        at org.junit.Assert.failNotEquals(Assert.java:835)

        at org.junit.Assert.assertEquals(Assert.java:647)

        at org.junit.Assert.assertEquals(Assert.java:633)

        at io.temporal.workflow.WorkflowWithCronScheduleTest.testCronWorkflowWithIncrementSchedule(WorkflowWithCronScheduleTest.java:78)


---

<a id="844"></a>

### #844: OpenTracing doesn't work correctly with continueAsNew

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/844 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-26 21:15:22.000 UTC (4y 2m ago) |
| **Updated** | 2022-01-07 16:28:12.000 UTC |
| **Closed** | 2022-01-07 16:28:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.7.0 |

#### Description

`continueAsNew` leads to a disconnected OpenTracing  span.
continueAsNew interception and headers doesn't implement correctly in java-sdk.



---

<a id="836"></a>

### #836: WorkflowExecutionUtils fails reading history jsons produced by newer protocol versions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/836 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-25 00:14:25.000 UTC (4y 2m ago) |
| **Updated** | 2021-10-25 00:54:42.000 UTC |
| **Closed** | 2021-10-25 00:54:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.5.0 |

#### Description

## Expected Behavior
Proto allows adding new fields preserving backwards compatibility.
So, the history jsons that are produced from new history proto objects with added fields should be deserializable into old history proto objects.

## Actual Behavior
Deserialization fails on unknown new fields in the json.



---

<a id="833"></a>

### #833: Cleanup and normalization of interfaces of *Option classes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/833 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-21 20:12:47.000 UTC (4y 2m ago) |
| **Updated** | 2025-05-16 22:31:17.000 UTC |
| **Closed** | 2025-05-16 22:31:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

- [ ] Our users are forced to use Builder#validateBuildWithDefaults everywhere. It's not ideal behavior. What we now do in validateBuildWithDefaults should be done in a standard #build method and what right now is done in #build should be moved under a name #partialBuild
- [ ] We should normalize where do we perform validation of the inputs. Some Options perform validation in Builders on setters, while others don't perform any validation at all other than setting defaults in #validateBuildWithDefaults


---

<a id="832"></a>

### #832: NullPointer in RetryOptions#merge

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/832 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-21 00:35:21.000 UTC (4y 2m ago) |
| **Updated** | 2021-10-25 21:47:04.000 UTC |
| **Closed** | 2021-10-25 21:47:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.5.0 |

#### Description

## Actual behavior

`RetryOptions#merge(RetryOptions o)` calls to merge(getMaximumInterval(), o.getMaximumInterval(), Duration.class) which throws NullPointer for non-primitive values.


---

<a id="830"></a>

### #830: testUntypedChildStubWorkflowAsyncInvoke flake with in-memory service

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/830 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-19 17:49:02.000 UTC (4y 2m ago) |
| **Updated** | 2022-04-23 04:42:35.000 UTC |
| **Closed** | 2022-04-23 04:42:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

[java-sdk_build_2497_java-unit-test-with-in-memory-test-service.log](https://github.com/temporalio/sdk-java/files/7375646/java-sdk_build_2497_java-unit-test-with-in-memory-test-service.log)

This failure looks very similar to #814
They are most likely related and should be evaluated together.


---

<a id="818"></a>

### #818: Automatically supply binaryChecksum

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/818 |
| **State** | OPEN |
| **Author** | yiminc (Yimin Chen) |
| **Created** | 2021-10-13 20:28:42.000 UTC (4y 2m ago) |
| **Updated** | 2023-05-23 16:38:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
SDK worker should automatically supply binary checksum (which is a hash on the worker image) to all calls of RespondWorkflowTaskCompeleted/Failed/etc. 

## Actual Behavior
User has to supply the checksum, or it is empty string.

## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - Version:
  - Platform:



---

<a id="816"></a>

### #816: `Workflow.await(duration, condition)` doesn't work correctly with workflow cancelation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/816 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-12 20:43:39.000 UTC (4y 2m ago) |
| **Updated** | 2021-10-13 17:20:23.000 UTC |
| **Closed** | 2021-10-13 17:20:23.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.5.0 |

#### Description

## Expected Behavior

When `Workflow.await(duration, condition)` is used in workflow code and the workflow gets canceled, `CanceledFailure` should be thrown and if it's not caught, the workflow should be canceled after that.
`WorkflowStub.getResult` should return with `WorkflowFailedException(CanceledFailure)`

## Actual Behavior
The expected behavior is true for `Workflow.await(condition)`, but not for `Workflow.await(duration, condition)`
For `Workflow.await(duration, condition)`, CanceledFailure is thrown but after that, it's followed by:

```
java.lang.RuntimeException: Failure processing workflow task. WorkflowId=6124edb9-11c9-4af4-94d4-920c7a8eca3a, RunId=135d7fa9-c4be-42a4-8c35-55fa7400bcbd, Attempt=2
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:349)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:279)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.lang.Error: closed
	at io.temporal.internal.sync.DeterministicRunnerImpl.checkClosed(DeterministicRunnerImpl.java:351)
	at io.temporal.internal.sync.DeterministicRunnerImpl.executeInWorkflowThread(DeterministicRunnerImpl.java:437)
	at io.temporal.internal.sync.SyncWorkflowContext.lambda$newTimer$d7d857c6$1(SyncWorkflowContext.java:540)
	at io.temporal.internal.replay.ReplayWorkflowContextImpl.handleTimerCallback(ReplayWorkflowContextImpl.java:291)
	at io.temporal.internal.replay.ReplayWorkflowContextImpl.lambda$newTimer$114ed502$1(ReplayWorkflowContextImpl.java:277)
	at io.temporal.internal.statemachines.WorkflowStateMachines.lambda$newTimer$4b87b190$1(WorkflowStateMachines.java:483)
	at io.temporal.internal.statemachines.TimerStateMachine.notifyCancellation(TimerStateMachine.java:148)
	at io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:45)
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:147)
	at io.temporal.internal.statemachines.StateMachine.handleCommand(StateMachine.java:111)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleCommand(EntityStateMachineBase.java:55)
	at io.temporal.internal.statemachines.CancellableCommand.handleCommand(CancellableCommand.java:63)
	at io.temporal.internal.statemachines.WorkflowStateMachines.prepareImpl(WorkflowStateMachines.java:352)
	at io.temporal.internal.statemachines.WorkflowStateMachines.prepareCommands(WorkflowStateMachines.java:335)
	at io.temporal.internal.statemachines.WorkflowStateMachines.eventLoop(WorkflowStateMachines.java:404)
	at io.temporal.internal.statemachines.WorkflowStateMachines.access$500(WorkflowStateMachines.java:68)
	at io.temporal.internal.statemachines.WorkflowStateMachines$WorkflowTaskCommandsListener.workflowTaskStarted(WorkflowStateMachines.java:816)
	at io.temporal.internal.statemachines.WorkflowTaskStateMachine.handleCompleted(WorkflowTaskStateMachine.java:126)
	at io.temporal.internal.statemachines.WorkflowTaskStateMachine.handleStarted(WorkflowTaskStateMachine.java:116)
	at io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:45)
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:147)
	at io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:101)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:67)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventImpl(WorkflowStateMachines.java:203)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:171)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleEvent(ReplayWorkflowRunTaskHandler.java:139)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:179)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:149)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:201)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:114)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:319)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:279)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 3 common frames omitted
```

Also `WorkflowStub.getResult` never returns for await with duration.

## Reproduction

See passing `WorkflowAwaitCancellationTest`: https://github.com/Spikhalskiy/java-sdk/commit/24717c252f7b6725cf1cf5009cce7479558a2792#diff-55aafba49213a140f44c29e66d260fce5ee1f80c45111dae78788b56e7544f9eR35

and failing `WorkflowAwaitWithDurationCancellationTest`: https://github.com/Spikhalskiy/java-sdk/commit/24717c252f7b6725cf1cf5009cce7479558a2792#diff-0f7d9c0a6e2232c47c8c11568d0a621b9562c49407c96369ea8f0a279b3ed62aR36

while they expected to behave the same.
Reproduces for both test service and dockerized Temporal


---

<a id="799"></a>

### #799: activity_endtoend_latency is a latency of one activity run instead of the whole sequence of retries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/799 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-06 20:04:27.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-06 20:32:34.000 UTC |
| **Closed** | 2021-10-06 20:31:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

## Expected Behavior

activity_endtoend_latency should be a time from the start of the activity to its successful execution.

## Actual Behavior

activity_endtoend_latency is the latency of one execution and doesn't matter if it's a success or a failure.

Related: https://github.com/temporalio/sdk-go/issues/573


---

<a id="794"></a>

### #794: Report replay metrics

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/794 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-05 05:35:42.000 UTC (4y 3m ago) |
| **Updated** | 2024-12-17 21:19:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
We don't report the completion of workflows during replays. This is a good default behavior for these main completion counters, but we are lacking any reporting of replays counters.

**Describe the solution you'd like**
Replay metrics could be important for detecting the anomaly behavior of the system. We should discuss how do we want to report replays metric. 
- Do we want to report them by status codes? 
- Do we want to just report a total number of replays? 
- Only full replays or partial too?



---

<a id="793"></a>

### #793: IdentityInPendingActivityTest#testPendingActivityHasIdentity flakes for both in-memory and dockerized server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/793 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-10-05 04:43:35.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-05 21:45:59.000 UTC |
| **Closed** | 2021-10-05 21:45:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

`IdentityInPendingActivityTest.testPendingActivityHasIdentity` flakes for both I'm-memory and dockerized service in buildkite.

[java-sdk_build_2366_java-unit-test-with-in-memory-test-service.log](https://github.com/temporalio/sdk-java/files/7282788/java-sdk_build_2366_java-unit-test-with-in-memory-test-service.log)

[java-sdk_build_2368_java-unit-test-with-docker-service.log](https://github.com/temporalio/sdk-java/files/7282811/java-sdk_build_2368_java-unit-test-with-docker-service.log)


---

<a id="765"></a>

### #765: Tests checking worker identity are failing with docker-compose Temporal server

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/765 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-24 23:35:58.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-29 20:17:18.000 UTC |
| **Closed** | 2021-09-29 20:17:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | vkoby |
| **Milestone** | 1.4.0 |

#### Description

`DescribeTest:testSuccessfulActivity`and `PendingActivityHeartbeatTest::testActivityHeartbeatHasIdentity` fail with dockerized temporal server.
Failure was introduced in #698

last_worker_identity is missing from the result of `describeWorkflow` with dockerized temporal.

Also `recordActivityTaskHeartbeatById` is missing the worker identity added in #698


---

<a id="759"></a>

### #759: Querying a completed workflow increments "temporal_workflow_completed_total" metrics counter

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/759 |
| **State** | CLOSED |
| **Author** | HaakonRav (Haakon Wilhelm Ravik) |
| **Created** | 2021-09-23 13:49:37.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-05 05:17:19.000 UTC |
| **Closed** | 2021-10-05 05:16:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | 1.4.0 |

#### Description

My impression is that this metric should reflect the number of workflows completed for a specific combination of `namespace`, `task_queue` and `workflow_type` tags. If this assumption is incorrect, please describe what this metric reflects and disregard this report.

## Expected Behavior
Querying a completed workflow should not affect the `temporal_workflow_completed_total` metric counter for a `workflow_type`.

## Actual Behavior
Querying a completed workflow increments the `temporal_workflow_completed_total` for the relevant `workflow_type` by 1 per Query request.

## Steps to Reproduce the Problem
Worker setup:
```java
MicrometerClientStatsReporter reporter = new MicrometerClientStatsReporter(
        new PrometheusMeterRegistry(
                PrometheusConfig.DEFAULT,
                CollectorRegistry.defaultRegistry,
                Clock.SYSTEM
        )
);

Scope metricScope = new RootScopeBuilder()
        .reporter(reporter)
        .reportEvery(Duration.ofSeconds(10));

HTTPServer metricsServer = new HTTPServer(9090);

WorkflowServiceStubs service = WorkflowServiceStubs.newInstance(
        WorkflowServiceStubsOptions.newBuilder()
                .setMetricsScope(metricScope)
                .build()
);
```
1. Start a workflow, let it complete.
2. Verify that the `temporal_workflow_completed_total` metric counter for that workflow is now 1.
3. Perform one or more queries for the completed workflow (via tctl / sdk).
4. The `temporal_workflow_completed_total` metric should now have increased beyond 1, without any new workflows completed.

## Specifications

  - micrometer-registry-prometheus version: 1.6.4
  - Prometheus simpleclient version: 0.12.0
  - SDK Version: 1.3.1
  - Platform: macOS / Java 15



---

<a id="756"></a>

### #756: AbandonOnCancelActivityTest flake

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/756 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-22 21:13:07.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-22 22:06:24.000 UTC |
| **Closed** | 2021-09-22 22:06:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

`AbandonOnCancelActivityTest` flakes in build pipelines

```
io.temporal.workflow.activityTests.AbandonOnCancelActivityTest > testAbandonOnCancelActivity STANDARD_ERROR
    Exception in thread "pool-1-thread-1" java.lang.NullPointerException
    	at io.temporal.workflow.shared.TestActivities$TestActivitiesImpl.lambda$activityWithDelay$0(TestActivities.java:234)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
```


---

<a id="753"></a>

### #753: Offer ActivityOptions via Supplier to support dynamic configs

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/753 |
| **State** | OPEN |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2021-09-22 17:17:11.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-22 17:17:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Tuning activity timeouts in workflows involves rebuilding and deploying an application, which can be an unacceptably long turnaround time depending on the urgency of the timeout change (e.g. in response to an incident). Some workers may also have a long startup / awaitTermination cycle, so the current methodology of updating a dynamic config and then redeploying is also too long of a loop.

**Describe the solution you'd like**
`ActivityOptions` provided via `WorkerImplementationOptions` to support a `Supplier<ActivityOptions>` would help allow us to plugin a dynamic config store to update workers' activity options, specifically the timeouts, on a faster cycle.

**Describe alternatives you've considered**
- Changing the configs in code, redeploying
- Changing configs and then restarting the workers



---

<a id="748"></a>

### #748: Provide a way to inject options into Workflow instances

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/748 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-21 20:03:12.000 UTC (4y 3m ago) |
| **Updated** | 2024-12-17 21:27:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

If injection to Workflow instances is discouraged, we should have a way to provide options to the workflow instances.
These options can be provided by external code (built based on configuration or modified for unit tests).
This at least is related to RetryOptions and ActivityOptions.


---

<a id="747"></a>

### #747: Support for unit testing of Workflows code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/747 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-21 19:51:06.000 UTC (4y 3m ago) |
| **Updated** | 2025-05-13 17:05:17.000 UTC |
| **Closed** | 2025-05-13 17:05:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

We should provide JUnit Test Rules that allow writing unit tests for Workflow code.
These test rules should execute the code in a workflow method context to provide a full usage of Temporal APIs.

We also should provide a way to make methods like `Workflow.randomUUID` to return some specific predefined values or to mock them to make code non-random and verifiable.

These pieces should be written in a way that allows reusing the code and implementation to create rules/toolchains for testing frameworks other than JUnit. 


---

<a id="746"></a>

### #746: Reuse of ActivityStubs from another workflow should produce a usable diagnostic or be allowed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/746 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-21 17:45:07.000 UTC (4y 3m ago) |
| **Updated** | 2024-12-17 21:20:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
ActivityStubs should be created for each workflow instance / execution separately.

But if somebody uses Dependency Injection frameworks with Temporal it's very easy to misconfigure the wiring (for example, by making them lazily initialized on first usage singletons) in a way that activity stubs will be leaking between workflow instances.
We should detect or provide better protection or diagnostic if this happens that actually helps to understand the problem.

## Actual Behavior

Cryptic Event Loop error that makes to look in a completely wrong direction.

```
        Caused by:
        io.temporal.failure.ApplicationFailure: message='Operation allowed only while eventLoop is running', type='java.lang.IllegalStateException', nonRetryable=false
            at io.temporal.internal.statemachines.WorkflowStateMachines.checkEventLoopExecuting(WorkflowStateMachines.java:915)
            at io.temporal.internal.statemachines.WorkflowStateMachines.randomUUID(WorkflowStateMachines.java:611)
            at io.temporal.internal.replay.ReplayWorkflowContextImpl.randomUUID(ReplayWorkflowContextImpl.java:93)
            at io.temporal.internal.sync.SyncWorkflowContext.constructExecuteLocalActivityParameters(SyncWorkflowContext.java:351)
            at io.temporal.internal.sync.SyncWorkflowContext.executeLocalActivityOnce(SyncWorkflowContext.java:292)
            at io.temporal.internal.sync.SyncWorkflowContext.executeLocalActivityOnce(SyncWorkflowContext.java:275)
            at io.temporal.internal.sync.SyncWorkflowContext.lambda$executeLocalActivity$a6925f48$1(SyncWorkflowContext.java:269)
            at io.temporal.internal.sync.WorkflowRetryerInternal.retryAsync(WorkflowRetryerInternal.java:232)
            at io.temporal.internal.sync.SyncWorkflowContext.executeLocalActivity(SyncWorkflowContext.java:268)
            at io.temporal.common.interceptors.WorkflowOutboundCallsInterceptorBase.executeLocalActivity(WorkflowOutboundCallsInterceptorBase.java:48)
            at io.temporal.opentracing.internal.OpenTracingWorkflowOutboundCallsInterceptor.executeLocalActivity(OpenTracingWorkflowOutboundCallsInterceptor.java:70)
            at io.temporal.internal.sync.LocalActivityStubImpl.executeAsync(LocalActivityStubImpl.java:50)
            at io.temporal.internal.sync.ActivityStubBase.execute(ActivityStubBase.java:38)
            at io.temporal.internal.sync.LocalActivityStubImpl.execute(LocalActivityStubImpl.java:29)
            at io.temporal.internal.sync.LocalActivityInvocationHandler.lambda$getActivityFunc$0(LocalActivityInvocationHandler.java:72)
            at io.temporal.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:70)
            at com.sun.proxy.$Proxy158.execute(Unknown Source:0)
            <!-- a project specific workflow code -->
            at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method:0)
            at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
            at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
            at java.base/java.lang.reflect.Method.invoke(Method.java:566)
            at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.execute(POJOWorkflowImplementationFactory.java:321)
            at io.temporal.common.interceptors.WorkflowInboundCallsInterceptorBase.execute(WorkflowInboundCallsInterceptorBase.java:37)
            at io.temporal.opentracing.internal.OpenTracingWorkflowInboundCallsInterceptor.execute(OpenTracingWorkflowInboundCallsInterceptor.java:72)
            at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.execute(POJOWorkflowImplementationFactory.java:295)
            at io.temporal.internal.sync.WorkflowExecuteRunnable.run(WorkflowExecuteRunnable.java:53)
            at io.temporal.internal.sync.SyncWorkflow.lambda$start$0(SyncWorkflow.java:131)
            at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:101)
            at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:110)
            at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
            at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
            at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
            at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
            at java.base/java.lang.Thread.run(Thread.java:829)
```

This specific issue happened with DI wiring using Dagger

# Alternative

There is no reason for ActivityStub that is a pair of ActivityType, ActivityOptions to don't be workflow context-independent. We can make internal changes to make them safely shareable, which is probably a better user experience.


---

<a id="738"></a>

### #738: Non-conventional SNAPSHOT version, lack of support for versions with suffixes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/738 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-20 01:36:49.000 UTC (4y 3m ago) |
| **Updated** | 2021-10-06 22:04:48.000 UTC |
| **Closed** | 2021-10-06 22:04:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

## Expected Behavior
If an already released version is x.y.z, the snapshot version should be x.y+1.0-SNAPSHOT
External forks can easily make an own branch and add a postfix to version, like x.y.z-<COMPANY NAME> or x.y.z-<PATCHED_FEATURE>

## Actual Behavior
If the last released version if 1.3.1, the SNAPSHOT version is 1.3.1-SNAPSHOT which is contradicting with a common practice in Java/Maven repos.
If the tag has any kind of postfixes - they are ignored by versioning.gradle functions, which doesn't allow an external fork to make own branch and release x.y.z-<COMPANY NAME> versions without hacking of versioning.gradle.


---

<a id="732"></a>

### #732: Remove TestWorkflowRule#testTimeoutSeconds

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/732 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-16 20:44:20.000 UTC (4y 3m ago) |
| **Updated** | 2024-12-17 21:26:56.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | java |
| **Assignees** | None |
| **Milestone** | Next |

#### Description

We deprecated `TestWorkflowRule#testTimeoutSeconds` in https://github.com/temporalio/sdk-java/pull/719
and removed the default timeout for user-facing Rule. 
Deprecation will be released as a part of 1.4
We should clean up the implementation from TestWorkflowRule in 1.5


---

<a id="731"></a>

### #731: Activities that return with interrupted flag should be successfully reported as Completed

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/731 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-16 19:03:01.000 UTC (4y 3m ago) |
| **Updated** | 2024-12-17 21:27:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, good first issue |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

If Activity 
- never noticed and interrupted flag or
-  caught an interrupted exception, restored the interrupted flag, and continued to run or returned a result
should be reported as Completed with its returned value.

## Actual Behavior

According to https://github.com/temporalio/sdk-java/pull/722#discussion_r707879325
if activity returns with an interrupted flag turned on, subsequent gRPC calls fail and the Activity result never gets reported.

## Proposed solution

- We should write a stable reproducible test close to a test that was changed in https://github.com/temporalio/sdk-java/pull/722
- When Activity returns with interrupted flag = "true", we should hide the flag, report the result of Activity execution to the server, and return the flag back after that allowing the thread pool to stop.


---

<a id="726"></a>

### #726: SelfAdvancingTimerImplTest flakes when test machine is under load

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/726 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-14 21:36:57.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-16 20:47:11.000 UTC |
| **Closed** | 2021-09-16 18:10:19.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

SelfAdvancingTimerImplTest flakes in pipelines sometimes with:

```
io.temporal.internal.testservice.SelfAdvancingTimerImplTest > testOrdering FAILED
    java.lang.AssertionError: expected:<20000.0> but was:<20055.0>
        at org.junit.Assert.fail(Assert.java:89)
        at org.junit.Assert.failNotEquals(Assert.java:835)
        at org.junit.Assert.assertEquals(Assert.java:555)
        at org.junit.Assert.assertEquals(Assert.java:685)
        at io.temporal.internal.testservice.SelfAdvancingTimerImplTest.testOrdering(SelfAdvancingTimerImplTest.java:82)
```



---

<a id="721"></a>

### #721: CleanWorkerShutdownTest::testShutdownNow[Docker]

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/721 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-09-14 02:27:29.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-16 21:24:52.000 UTC |
| **Closed** | 2021-09-16 21:24:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | 1.4.0 |

#### Description

Fails with docker


---

<a id="716"></a>

### #716: DynamicWorkflow does not handle ApplicationFailure.newNonRetryableFailure correclty

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/716 |
| **State** | CLOSED |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2021-09-13 19:58:08.000 UTC (4y 3m ago) |
| **Updated** | 2021-09-16 20:47:55.000 UTC |
| **Closed** | 2021-09-16 18:23:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | mfateev |
| **Milestone** | 1.4.0 |

#### Description

## Expected Behavior

A dynamic workflow that throws `ApplicationFailure.newNonRetryableFailure` should fail immediately.

## Actual Behavior

The workflow does not fail and eventually times out.

## Steps to Reproduce the Problem

See above!

## Specifications

  - Version: 1.0.9
  - Platform:



---

<a id="708"></a>

### #708: Regression on GrpcRetryer + GrpcDeadlineInterceptor

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/708 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-09-11 00:20:56.000 UTC (4y 4m ago) |
| **Updated** | 2021-09-13 17:18:51.000 UTC |
| **Closed** | 2021-09-11 16:57:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | v.1.3.1 |

#### Description

Our GrpcDeadlineInterceptor is located on the lowest level, lower GrpcAsyncRetryer and it sets more granular deadlines then root gRPC context. And these requests were previously expected to be retried.
A recent modification of GrpcRetryer to respect DEADLINE_EXCEEDED causes a situation when an underlying request fails with DEADLINE_EXCEEDED and is not being retried anymore, while the root gRPC context is not expired yet.
This may cause 1.3.0 release of java-sdk to throw when the previous release was rightfully retrying. 



---

<a id="693"></a>

### #693: Flaky LocalActivitiesWorkflowTaskHeartbeatTest#testLocalActivitiesWorkflowTaskHeartbeat

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/693 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-31 21:12:16.000 UTC (4y 4m ago) |
| **Updated** | 2021-09-03 18:51:03.000 UTC |
| **Closed** | 2021-09-03 18:51:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

`LocalActivitiesWorkflowTaskHeartbeatTest#testLocalActivitiesWorkflowTaskHeartbeat` often flakes in buildkite with 
org.junit.runners.model.TestTimedOutException: test timed out after 15 seconds


---

<a id="677"></a>

### #677: Memo serialization implemented inconsistently

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/677 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-27 18:59:20.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-31 20:11:33.000 UTC |
| **Closed** | 2021-08-31 20:11:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior

Memo Payloads should be serialized/deserialized with a user-defined data converter. So it should be a converter specified on WorkflowClientOptions if one is provided.

## Actual Behavior
Now SDK has a mix of serialization styles for Memo.
We have WorkflowInternal that uses the user-defined converter which is correct: https://github.com/temporalio/sdk-java/pull/611/files#diff-fb38530e603dcfb32354887ad8db985665c82ef0e6f38e9016415b528a07e16aR434
But we also have `HeaderUtils#intoPayloadMapWithDefaultConverter` used in the whole bunch of places for Memo serialization that uses Default Converter:
https://github.com/temporalio/sdk-java/blob/192f0c44f577286187ff382284fb3bc63a34ae26/temporal-sdk/src/main/java/io/temporal/internal/common/HeaderUtils.java#L52

## Proposal:
Serialization of Memo shouldn't use `HeaderUtils#intoPayloadMapWithDefaultConverter`


---

<a id="673"></a>

### #673: SearchAttributesTest fails against docker due to LocalDateTime serialization problem

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/673 |
| **State** | CLOSED |
| **Author** | nagl-stripe |
| **Created** | 2021-08-26 20:35:51.000 UTC (4y 4m ago) |
| **Updated** | 2022-04-12 21:24:18.000 UTC |
| **Closed** | 2022-04-12 21:24:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

## Expected Behavior
Not sure actually... either [this javadoc](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/WorkflowOptions.java#L212-L216) needs to change, or there's a bug around how the server `json.Unmarshal`s strings like `2021-08-26T13:21:52.059738` as a `time.Time`.

## Actual Behavior
Using a LocalDateTime as a SearchAttribute value fails with a message like `INVALID_ARGUMENT: 2021-08-26T13:21:52.059738 is not a valid value for search attribute CustomDatetimeField of type Datetime`

## Steps to Reproduce the Problem
`export USE_DOCKER_SERVICE=true`, remove [these lines](https://github.com/temporalio/sdk-java/blob/5d8734be38648c9c1837832fb4fc424f26136ecb/temporal-sdk/src/test/java/io/temporal/workflow/SearchAttributesTest.java#L82-L84), and run SearchAttributesTest.testSearchAttributes().

## Specifications

  - Version: [1.11.4](https://github.com/temporalio/docker-compose/commit/ff95bcdf8371fbc10b5f4230fd4c0f46a450cfc8) in docker-compose.
  - Platform: cassandra



---

<a id="672"></a>

### #672: [Flaky] LongLocalActivityWorkflowTaskHeartbeatFailureTest

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/672 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-08-26 17:55:37.000 UTC (4y 4m ago) |
| **Updated** | 2021-09-15 18:47:42.000 UTC |
| **Closed** | 2021-09-15 18:47:42.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | None |

#### Description

Currently fails in buildkite:

io.temporal.workflow.activityTests.LongLocalActivityWorkflowTaskHeartbeatFailureTest > testLongLocalActivityWorkflowTaskHeartbeatFailure FAILED
    java.lang.AssertionError: io.temporal.workflow.shared.TestActivities$TestActivitiesImpl@1c77e505 expected:<2> but was:<3>
        at org.junit.Assert.fail(Assert.java:89)
        at org.junit.Assert.failNotEquals(Assert.java:835)
        at org.junit.Assert.assertEquals(Assert.java:647)
        at io.temporal.workflow.activityTests.LongLocalActivityWorkflowTaskHeartbeatFailureTest.testLongLocalActivityWorkflowTaskHeartbeatFailure(LongLocalActivityWorkflowTaskHeartbeatFailureTest.java:64


---

<a id="666"></a>

### #666: GrpcRetryer could lose a real cause in case of DEADLINE_EXCEEDED

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/666 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-24 22:23:14.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-31 01:48:12.000 UTC |
| **Closed** | 2021-08-26 21:18:45.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

If GrpcRetryer gets some retryable exception enough times that it ends in DEADLINE_EXCEEDED, it will throw DEADLINE_EXCEEDED as the main exception outside, losing information about previous exceptions that actually made us continue retrying and this can hurt debuggability and ease of investigations for our users. Because most application developers will be actually interested in the underlying exception that made us retrying all this time.

Proposed solution:
If DEADLINE_EXCEEDED happened during retries, we can discard DEADLINE_EXCEEDED and return a previous exception if it exists. 
It's probably the cleanest way because it simulates what happens during a normal timeout. 
But what if the code that uses GrpcRetryer relies on DEADLINE_EXCEEDED exception to detect the expiration of GRPC deadline? It will quickly get DEADLINE_EXCEEDED on the next GRPC operation. We need to discuss if it's good enough and if this approach is safe.




---

<a id="665"></a>

### #665: Allow users to specify or influence RpcRetryOptions for all kinds of GrpcRetries

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/665 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-24 21:46:44.000 UTC (4y 4m ago) |
| **Updated** | 2024-12-17 21:19:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Temporal strives to provide reasonable defaults for Retry options.
Also, we try to not expose `RpcRetryOptions` because of how easy they are to misconfigure.
But in some cases, our default choices don't work and there is no one value that fits all use cases. 
The initial retry period is an example of a property that requires very different values for 
- microservice orchestration usecase (we want to keep it really low) 
- more traditional workflow or batch processing usecase where we want to avoid a snowball effect of retries and we can afford to wait.

We should come up with some ability to influence/specify RpcRetryOptions for our users to allow them to tune Temporal for their specific use case, but keeping a balance with incapsulation and enforcing the retry options to be safe.


---

<a id="663"></a>

### #663: Failing DefaultActivityOptionsSetOnWorkflowTest#testSetWorkflowImplementationOptions with Dockerized Temporal

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/663 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-08-23 21:18:17.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-25 21:43:21.000 UTC |
| **Closed** | 2021-08-25 21:43:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

DefaultActivityOptionsSetOnWorkflowTest#testSetWorkflowImplementationOptions consistently fails when run as part of unit tests with docker in buildkite:

io.temporal.activity.DefaultActivityOptionsSetOnWorkflowTest > testSetWorkflowImplementationOptions FAILED
    java.lang.AssertionError: expected:<PT3S> but was:<PT2S>
        at org.junit.Assert.fail(Assert.java:89)
        at org.junit.Assert.failNotEquals(Assert.java:835)
        at org.junit.Assert.assertEquals(Assert.java:120)
        at org.junit.Assert.assertEquals(Assert.java:146)
        at io.temporal.activity.DefaultActivityOptionsSetOnWorkflowTest.testSetWorkflowImplementationOptions(DefaultActivityOptionsSetOnWorkflowTest.java:79)


---

<a id="661"></a>

### #661: Sync versions of GrpcRetryer should throw InterruptedException 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/661 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-23 15:58:47.000 UTC (4y 4m ago) |
| **Updated** | 2024-12-17 21:18:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

GrpcRetryer retry method by its nature is expected to throw InterruptedException because they
1. perform waiting on a timer 
2. could get an Interrupted flag from GRPC calls with a StatusRuntimeException exception with CANCELLED status

Now handling of InterruptedExceptions is brittle:
1. we hide the Interrupted exceptions from the timer and we raise an Interrupted flag instead.
2. We consider StatusRuntimeException with CANCELLED from GRPC as non-retryable.

So, code that uses GrpcRetryer should expect a non-Interrupted Exception + Interrupted flag if interruption happens.
There is nothing wrong with the model per se if the users are very aware of the potential interrupted flag and process it correctly.
But to make code more idiomatic and enforce the correct handling of InterruptedException and awareness of its possibility inside GrpcRetryer, we should change GrpcRetryer methods to throw explicit InterruptedExceptions.



---

<a id="653"></a>

### #653: WorkflowExecutionUtils  and GrpcRetryer don't respect reaching deadline from GRPC context and downstream DEADLINE_EXCEEDED exceptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/653 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-20 00:59:51.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-31 01:48:19.000 UTC |
| **Closed** | 2021-08-24 21:54:12.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

GRPC has a concept of gRPC deadline propagation when an absolute deadline is passed and propagated through chained GRPC calls using thread-local `io.grpc.Context`

Read more here:
https://docs.microsoft.com/en-us/aspnet/core/grpc/deadlines-cancellation?view=aspnetcore-5.0#propagating-deadlines

`WorkflowExecutionUtils` calculates the Deadline (https://github.com/temporalio/sdk-java/blob/25da5d2064a6c024148e236e060c34d286283b56/temporal-sdk/src/main/java/io/temporal/internal/common/WorkflowExecutionUtils.java#L250-L253) using a timeout value passed as an argument and ignores the fact that the calculated deadline or even the current moment can already be after the absolute Deadline in the context.
GRPC ignores these new deadlines that are later than the current deadline already presented in the GRPC Context: https://github.com/grpc/grpc-java/blob/master/context/src/main/java/io/grpc/Context.java#L316-L320
 `GrpcRetryer` doesn't check the fact that the current moment passed the absolute deadline from GRPC Context and continues to calculate the new deadline, make a call, ignore DEADLINE_EXCEEDED happening immediately later in the chain of calls, rinse and repeat.

There are two unit tests with the reproduction of this problem.
In one of the tests the deadline is reached before the workflow completes and we ignore this fact and keep retrying till the workflow is actually finished.
In another test, the deadline is reached before the workflow is even started and we end up in a cycle of Integer.MAX_VALUE milliseconds of retries (24 days)

https://github.com/Spikhalskiy/java-sdk/commit/d8d21d3b76edf8af7b4f843115e8f57ec1b831b2#diff-41b99c4ace946461232f6ec43784563e243168821f47d1807ae1962e856cfe0fR40


---

<a id="651"></a>

### #651: Change the default behavior of retries in WorkflowExecutionUtils#getInstanceCloseEvent

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/651 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-19 18:43:58.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-31 01:48:26.000 UTC |
| **Closed** | 2021-08-26 04:42:27.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

We have no exponential backoff on `WorkflowExecutionUtils#getInstanceCloseEvent` and we should add it to avoid clients hammering the server in case of server/network outage.

Proposal:
add backoffCoefficient
set maximumInterval into a reasonable value to limit the backoff
implement #652 to allow users who are using workflow stub proxies to pass reasonable timeout into WorkflowExecutionUtils#getInstanceCloseEvent


---

<a id="648"></a>

### #648: Version StateMachine causes different in workflow task structure in replays breaking cancelations and leading to incorrect command-event matches

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/648 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-18 23:18:20.000 UTC (4y 4m ago) |
| **Updated** | 2021-10-27 19:13:51.000 UTC |
| **Closed** | 2021-10-27 19:13:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.5.0 |

#### Description

## Expected Behavior

Test https://github.com/Spikhalskiy/java-sdk/commit/81e25cd16e651f1b3150d9a35874a0a9d48f87c7#diff-a0367d38077edb107a1ef33f815c2f2122cdb2fe9f3d4572cd4a2aacd0cf4545R35 passes without any error

## Actual Behavior

The unit test fails with 

```
Caused by: io.temporal.internal.replay.InternalWorkflowTaskException: Failure handling event 7 of 'EVENT_TYPE_TIMER_STARTED' type. IsReplaying=true, PreviousStartedEventId=3, workflowTaskStartedEventId=20, Currently Processing StartedEventId=3
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:188)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleEvent(ReplayWorkflowRunTaskHandler.java:140)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTaskImpl(ReplayWorkflowRunTaskHandler.java:180)
	at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler.handleWorkflowTask(ReplayWorkflowRunTaskHandler.java:150)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTaskWithEmbeddedQuery(ReplayWorkflowTaskHandler.java:201)
	at io.temporal.internal.replay.ReplayWorkflowTaskHandler.handleWorkflowTask(ReplayWorkflowTaskHandler.java:114)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:319)
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:279)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 4 common frames omitted
Caused by: java.lang.IllegalArgumentException: Timer: invalid CANCEL_TIMER_COMMAND_SENT->TIMER_STARTED, transition history is [CREATED->SCHEDULE, START_COMMAND_CREATED->START_TIMER, START_COMMAND_CREATED->TIMER_STARTED, START_COMMAND_RECORDED->CANCEL, CANCEL_TIMER_COMMAND_CREATED->CANCEL_TIMER]
	at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:130)
	at io.temporal.internal.statemachines.StateMachine.handleHistoryEvent(StateMachine.java:91)
	at io.temporal.internal.statemachines.EntityStateMachineBase.handleEvent(EntityStateMachineBase.java:63)
	at io.temporal.internal.statemachines.CancellableCommand.handleEvent(CancellableCommand.java:72)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleCommandEvent(WorkflowStateMachines.java:250)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEventImpl(WorkflowStateMachines.java:194)
	at io.temporal.internal.statemachines.WorkflowStateMachines.handleEvent(WorkflowStateMachines.java:173)
	... 12 common frames omitted
```

## Root cause analysis

`Workflow.getVersion` call during replays causes the end of workflow task every single time. We wait till the end of the workflow task (the return from the event lopp) to perform a match with events from history and return the result. Without that the callback publishing the result to the workflow thread is not getting called and workflow code blocks on getVersion. This causes a difference in the structure of workflow tasks in the original run and its replays.

Let's see an example of how it can lead to problems when mixed with cancelations.

### Original execution

A sequence of operations in the original execution:
```
START-OF-WORKFLOW-TASK
create_timer_1
getVersion
cancel_timer_1
create_timer_2
END-OF-WORKFLOW-TASK
```

commands:
```
COMMAND_TYPE_RECORD_MARKER              //for getVersion
COMMAND_TYPE_START_TIMER                     //for timer_2
```

events on the server created for the commands:
```
EVENT_TYPE_MARKER_RECORDED
EVENT_TYPE_TIMER_STARTED
```

_Note how the cancellation of timer_1 inside the workflow task prevents sending a scheduling command for this timer_

### Now we are performing a replay:

START-OF-WORKFLOW-TASK-1
create_timer_1
getVersion
END-OF-WORKFLOW-TASK-1
START-OF-WORKFLOW-TASK-2
cancel_timer_1
create_timer_2
END-OF-WORKFLOW-TASK-2

commands generated during WORKFLOW-TASK-1:
```
COMMAND_TYPE_START_TIMER                      //for timer_1
COMMAND_TYPE_RECORD_MARKER              //for getVersion
```
commands generated during WORKFLOW-TASK-2:
```
COMMAND_TYPE_CANCEL_TIMER                   //for timer_1
COMMAND_TYPE_START_TIMER                      //for timer_2
```

Now let's see how does this sequence of commands will play with our event history:
```
EVENT_TYPE_MARKER_RECORDED
EVENT_TYPE_TIMER_STARTED
```

Step 1. We handle EVENT_TYPE_MARKER_RECORDED. We try to match it with the command COMMAND_TYPE_START_TIMER for timer_1, we can't match them, we handle the event as a non-matched history event (that can be for deleted getVersion call for example)

Step 2. We handle EVENT_TYPE_TIMER_STARTED. And we match it with COMMAND_TYPE_START_TIMER for timer_1.
But this history event is for timer_2. timer_1 has no events at all because it was canceled originally inside the same workflow task. This way change in workflow task structure causes events history to be matched incorrectly with the replaying commands. 

Step 3. COMMAND_TYPE_CANCEL_TIMER from the second workflow task doesn't find the matching event from the server at all and the replay fails.



---

<a id="647"></a>

### #647: Make `ApplicationFailure#newFromValues` public

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/647 |
| **State** | CLOSED |
| **Author** | jonsie (Chris Smalley) |
| **Created** | 2021-08-18 15:45:08.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-19 01:18:16.000 UTC |
| **Closed** | 2021-08-19 01:18:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

**Is your feature request related to a problem? Please describe.**
Would be nice to have access to `ApplicationFailure#newFromValues` so that we can set the `cause` on the ApplicationFailure.

**Describe the solution you'd like**
Make `ApplicationFailure#newFromValues` public

**Describe alternatives you've considered**
Error log prior to throwing `ApplicationFailure`




---

<a id="641"></a>

### #641: NPE during performance testing

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/641 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-17 02:27:20.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-31 01:48:40.000 UTC |
| **Closed** | 2021-08-17 03:30:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

There was an NPE during performance tests that points to some multithreading issue / race / partial publishing 

```
Caused by: java.lang.NullPointerException: null
at io.temporal.internal.sync.WorkflowThreadContext.runUntilBlocked(WorkflowThreadContext.java:234)
at io.temporal.internal.sync.WorkflowThreadImpl.runUntilBlocked(WorkflowThreadImpl.java:323)
at io.temporal.internal.sync.DeterministicRunnerImpl.runUntilAllBlocked(DeterministicRunnerImpl.java:282)
at io.temporal.internal.sync.SyncWorkflow.eventLoop(SyncWorkflow.java:151)
at io.temporal.internal.replay.ReplayWorkflowExecutor.eventLoop(ReplayWorkflowExecutor.java:74)
at io.temporal.internal.replay.ReplayWorkflowRunTaskHandler$EntityManagerListenerImpl.eventLoop(ReplayWorkflowRunTaskHandler.java:329)
at io.temporal.internal.statemachines.WorkflowStateMachines.eventLoop(WorkflowStateMachines.java:388)
at io.temporal.internal.statemachines.WorkflowStateMachines.lambda$sideEffect$a4cebacf$1(WorkflowStateMachines.java:626)
at io.temporal.internal.statemachines.SideEffectStateMachine.markerResultFromFunc(SideEffectStateMachine.java:164)
at io.temporal.internal.statemachines.FixedTransitionAction.apply(FixedTransitionAction.java:45)
at io.temporal.internal.statemachines.StateMachine.executeTransition(StateMachine.java:137)
... 27 common frames omitted
```


---

<a id="634"></a>

### #634: Global timeout should be relocated from TestWorkflowRule to SDKTestWorkflowRule

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/634 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-15 19:42:08.000 UTC (4y 4m ago) |
| **Updated** | 2021-09-16 20:41:33.000 UTC |
| **Closed** | 2021-09-16 20:41:33.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.4.0 |

#### Description

`TestWorkflowRule` that we provide to our users right now enforces 10 seconds timeout by default.
There is a lot of ways provided by JUnit to enforce test timeouts and that can be used by our users if they need this and our test rule shouldn't be responsible for such basic test framework functionality.
Worse is that by providing 10 seconds by default, we create a productivity problem for our users because they need to figure out how to disable this never-asked-about functionality.

We want to have this enabled and enforced across Temporal tests though and I propose to:
- Move existing global timeout implementation into Temporal internal `SDKTestWorkflowRule`.
- Remove logic of TestWorkflowRule that enforces timeout.
- Mark timeout functionality of public TestWorkflowRule as deprecated and remove in the release after the next one.



---

<a id="632"></a>

### #632: Running in TEMPORAL_DEBUG mode should turn off TestWorkflowRule timeouts

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/632 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-15 17:55:58.000 UTC (4y 4m ago) |
| **Updated** | 2021-08-31 01:48:59.000 UTC |
| **Closed** | 2021-08-16 21:35:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

TestWorkflowRule enforces 10 seconds timeout for tests by default. This is useful during running a build with all tests, but it's annoying for debugging and hurts productivity. We should disable this timeout when we have TEMPORAL_DEBUG env variable present.


---

<a id="625"></a>

### #625: Use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` for non-deterministic workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/625 |
| **State** | CLOSED |
| **Author** | wxing1292 (Wenquan Xing) |
| **Created** | 2021-08-10 21:56:19.000 UTC (4y 5m ago) |
| **Updated** | 2021-11-15 19:47:01.000 UTC |
| **Closed** | 2021-11-15 19:47:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.6.0 |

#### Description

use `WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR` as cause for `RespondWorkflowTaskFailed` if user workflow logic is non-deterministic

Ref: https://github.com/temporalio/temporal/pull/1726



---

<a id="617"></a>

### #617: Deserialize Search Attributes

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/617 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-08-03 06:42:23.000 UTC (4y 5m ago) |
| **Updated** | 2022-04-12 21:24:18.000 UTC |
| **Closed** | 2022-04-12 21:24:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | 1.9.0 |

#### Description

## Expected Behavior
WorkflowInfo.getSearchAttributes return something that can be easily read/interpreted by the user

## Actual Behavior
Returns serialized protobuf



---

<a id="615"></a>

### #615: State Machine fails to handle correctly some corner cases of Workflow Versioning

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/615 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-08-02 02:52:27.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-18 22:55:13.000 UTC |
| **Closed** | 2021-08-18 22:55:13.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

There is a reproduction submitted in https://github.com/temporalio/sdk-java/pull/583 which demonstrates some corner cases with our State Machines fail to handle `Workflow.getVersion` calls correctly.


---

<a id="612"></a>

### #612: JUnit's @test(timeout) annotation should override TestWorkflowRule settings

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/612 |
| **State** | CLOSED |
| **Author** | vkoby (Vera) |
| **Created** | 2021-07-29 07:18:37.000 UTC (4y 5m ago) |
| **Updated** | 2021-08-31 01:49:35.000 UTC |
| **Closed** | 2021-08-16 21:35:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | Spikhalskiy |
| **Milestone** | v1.3.0 |

#### Description

## Expected Behavior
Junit `@Test(timeout)` should override timeouts set on the SDKTestWorkflowRule, which is 10s by default.
As a workaround, you can set a different timeout in the rule, but it would affect all tests in the class:
`SDKTestWorkflowRule.newBuilder().setTestTimeoutSeconds(15).build();
`
## Actual Behavior
Errors

## Steps to Reproduce the Problem
  1. Write a test that uses SDKTestWorkflowRule
  2. Add @Test(timeout=20000) annotation to the test
  3. Run test and observe fail


---

<a id="608"></a>

### #608: GRPC falling into in-process server long polls after interruption breaks graceful Worker Pollers shutdown

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/608 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-07-26 21:56:48.000 UTC (4y 5m ago) |
| **Updated** | 2025-05-17 14:56:04.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

# Problem

An investigation of flaky `InterceptorsExceptionsTests#testExceptionOnStart` test from https://github.com/temporalio/sdk-java/issues/455 ended up inside GRPC code that swallows `InterruptedException` in intention to perform a graceful shutdown, but instead peeking up a long poll task submitted by another poller thread (from another non-shutdown thread pool) and falling into a long poll inside in-memory GRPC server implementation. The stacktrace of the hanging Poller thread AFTER receiving an interruption:
```
"Host Local Workflow Poller: 5@3606" daemon prio=5 tid=0x1c nid=NA waiting
  java.lang.Thread.State: WAITING
	  at jdk.internal.misc.Unsafe.park(Unsafe.java:-1)
	  at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:252)
	  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1661)
	  at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:460)
	  at io.temporal.internal.testservice.TestWorkflowStoreImpl.pollWorkflowTaskQueue(TestWorkflowStoreImpl.java:347)
	  at io.temporal.internal.testservice.TestWorkflowService.pollWorkflowTaskQueue(TestWorkflowService.java:448)
	  at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$MethodHandlers.invoke(WorkflowServiceGrpc.java:3625)
	  at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
	  at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:331)
	  at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:797)
	  at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	  at io.grpc.internal.SerializeReentrantCallsDirectExecutor.execute(SerializeReentrantCallsDirectExecutor.java:49)
	  at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener.halfClosed(ServerImpl.java:808)
	  at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.halfClose(InProcessTransport.java:793)
	  - locked <0xf41> (a io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream)
	  at io.grpc.internal.ForwardingClientStream.halfClose(ForwardingClientStream.java:72)
	  at io.grpc.internal.DelayedStream$9.run(DelayedStream.java:344)
	  at io.grpc.internal.DelayedStream.drainPendingCalls(DelayedStream.java:181)
	  at io.grpc.internal.DelayedStream.access$100(DelayedStream.java:43)
	  at io.grpc.internal.DelayedStream$4.run(DelayedStream.java:147)
	  at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:740)
	  at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	  at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	  at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	  at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	  at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:270)
	  at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:235)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	  at java.lang.Thread.run(Thread.java:832)
```

# Partial notes made during an investigation

https://github.com/grpc/grpc-java/blob/9b803f3/stub/src/main/java/io/grpc/stub/ClientCalls.java#L149
GRPC catches the InterruptedException, puts it into a flag var, and goes to a new iteration of the loop. (based on comments waiting for ‚ÄúonClose‚Äù to be called)
What actually happens at the moment when we experience problems with shutdown - it finds a job that actually calls a long poll inside `waitAndDrain`, starts to execute it, and hangs there, because the interrupted status has been flushed.
This happens only in a case when a long-poll task ends up in this executor AFTER the thread is interrupted. A situation is likely to happen only when we shut down the environment right after the start. That‚Äôs why most tests are ok - they actually take stuff from the server, so long poll is already triggered. 
I made a branch (https://github.com/Spikhalskiy/java-sdk/commit/f543651432f0f7d0173e2461ec00287219c91b12) where I threw a bunch of debug prints inside GRPC code around this waitAndDrain and it shows one more strange/unexpected thing - the long poll task that blocks the intercepted thread is put to the executor of interrupted Poller by another non-yet-interrupted Poller thread.  Basically, we have an intercepted sticky poller thread and the non-intercepted workflow poller thread publishes a long poll task into the intercepted sticky poller executor.

# Assumptions

It looks like this situation is only happening when we have a GRPC client + a GRPC in-process server that performs the long poll. Interruption in the client thread ends up ignored and a Poller thread falls into a long poll inside the in-process GRPC server implementation. Also, timing is very important for it, because the long poll task needs to be submitted right after threads get terminated.
We were unable to reproduce an issue with an actual dockerized Temporal server.
An investigation of this issue is not finished. The best bet right now is: it's a bug in GRPC happening when GRPC client & GRPC in-process server & long polls are used and the right timing is needed for the problem to reproduce.

# Mitigation 

Taking into account that further investigation of this issue is very time-consuming, we decided to mitigate the problem in this specific flaky test by triggering a shutdown of GRPC in-process Temporal server implementation before shutdown of workers. This way GRPC client doesn't have a long poll to fall into after getting an interception. This workaround is implemented in: https://github.com/temporalio/sdk-java/pull/601 and affects only tests code.
The last master commit where `InterceptorsExceptionsTests#testExceptionOnStart` is able to often reproduce the described problem is b4cbaa13f32590e2337a03305dfb6a0af6628bdc.






---

<a id="597"></a>

### #597: Support assertions in `TestWorkflowEnvironment.registerDelayedCallback`

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/597 |
| **State** | OPEN |
| **Author** | zhxnlai (Zhixuan Lai) |
| **Created** | 2021-07-20 17:55:16.000 UTC (4y 5m ago) |
| **Updated** | 2021-07-20 17:55:16.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**

When assertions fail in `TestWorkflowEnvironment.registerDelayedCallback`, the errors in the callback are swallowed. This is counterintuitive.

For instance, I expect the following test to fail.
```kotlin
class MyTest {

  private val testEnv: TestWorkflowEnvironment
  
  @Test
  fun thisShouldFail() {
    testEnv.registerDelayedCallback(Duration.ofSeconds(1)) {
      assertThat(false).isTrue()
    }
    testEnv.sleep(Duration.ofSeconds(10))
  }
}
```

But it succeeds with an error log.
```
10:35:11.197 [Timer task] ERROR i.t.i.t.SelfAdvancingTimerImpl - Unexpected failure in timer callback
org.opentest4j.AssertionFailedError: 
Expecting value to be true but was false
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
```

**Describe the solution you'd like**
Propagate the error to the test method.




---

<a id="591"></a>

### #591: Method overrides should be allowed when signal names are different

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/591 |
| **State** | CLOSED |
| **Author** | robzienert (Rob Zienert) |
| **Created** | 2021-07-17 02:34:18.000 UTC (4y 5m ago) |
| **Updated** | 2021-07-21 18:34:57.000 UTC |
| **Closed** | 2021-07-21 18:34:57.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vitarb |
| **Milestone** | None |

#### Description

## Expected Behavior
I would expect that defining a signal name would allow me to overload signal method names. 

## Actual Behavior
I can give a Signal Method a name via `@SignalMethod(name = "foo")`, but the name is not considered when evaluating if a signal method already exists or not.

```
java.lang.IllegalArgumentException: Duplicated methods (overloads are not allowed): "public abstract void SomeActivities.greet(java.lang.String)" and "public abstract void SomeActivities.greet(java.lang.String,java.lang.Boolean)"
       at SomeActivitiesTest.startTestEnvironment(SomeActivitiesTest.kt:116)
```

## Steps to Reproduce the Problem

```kotlin
interface SomeActivities {
  @SignalMethod
  fun greet(message: String)

  @SignalMethod(name = "greetAndWave")
  fun greet(message: String, wave: Boolean)
}
```

## Specifications

  - Version: 1.0.9
  - Platform: Any



---

<a id="590"></a>

### #590: Worker identity is not recorded during heartbeat

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/590 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-07-14 22:39:57.000 UTC (4y 5m ago) |
| **Updated** | 2021-09-22 17:59:08.000 UTC |
| **Closed** | 2021-09-22 17:59:08.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | vkoby |
| **Milestone** | 1.4.0 |

#### Description

## Expected Behavior
lastWorkerIdentity is not empty

## Actual Behavior
lastWorkerIdentity is empty

![Screen Shot 2021-07-14 at 3 38 59 PM](https://user-images.githubusercontent.com/1463622/125701885-534b77da-d159-477f-96d3-88fd3dfddbc0.png)



---

<a id="577"></a>

### #577: TestEnv: using workflowExecutionTimeout with testEnv.sleep() makes the test hang

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/577 |
| **State** | CLOSED |
| **Author** | rubyhfu |
| **Created** | 2021-07-07 03:52:45.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-22 00:55:47.000 UTC |
| **Closed** | 2021-07-22 00:55:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | Spikhalskiy, vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior
Should be able to set workflowExecutionTimeout on the workflow options as is the case outside of test environment 

## Actual Behavior
Test hangs

## Steps to Reproduce the Problem

  1. WorkflowInterface

```
import io.temporal.workflow.SignalMethod;
import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;

@WorkflowInterface
public interface ExampleWorkflow {

    @WorkflowMethod
    public String execute(String s);

    @SignalMethod
    public void signal(boolean s);
}

```
  2. WorkflowImpl1
 
```
import java.time.Duration;
import io.temporal.workflow.Workflow;

public class ExampleWorkflowImpl implements ExampleWorkflow{
    private boolean signal = false;

    @Override
    public String execute(String s) {
        Workflow.await(Duration.ofMinutes(5L), () -> signal);
        Workflow.sleep(Duration.ofMinutes(10L));
        return s;
    }

    @Override
    public void signal(boolean signal) {
        this.signal = signal;
    }
}
```
  3. Run second test in test class
 
```
public class ExampleWorkflowImplTest {
    private TestWorkflowEnvironment testEnv;
    private Worker worker1, worker2;
    private WorkflowClient client;

    @BeforeEach
    public void setUp() {
        testEnv = TestWorkflowEnvironment.newInstance();
        worker1 = testEnv.newWorker("TEST_QUEUE1");
        worker2 = testEnv.newWorker("TEST_QUEUE2");
        worker1.registerWorkflowImplementationTypes(ExampleWorkflowImpl.class);
        worker2.registerWorkflowImplementationTypes(ExampleWorkflow2Impl.class);
        client = testEnv.getWorkflowClient();
        testEnv.start();
    }

    @Test
    public void testTerminateWorkflowSignalError() {
        ExampleWorkflow workflow1 = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setWorkflowId("abc123")
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        ExampleWorkflow workflow2 = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue("TEST_QUEUE2")
                        .build());

        WorkflowExecution workflow1Execution = WorkflowClient.start(workflow1::execute, "test");

        testEnv.sleep(Duration.ofMinutes(6L));

        WorkflowExecution workflow2Execution = WorkflowClient.start(workflow2::execute, "test");
        WorkflowStub workflowStub1 = WorkflowStub.fromTyped(workflow1);
        workflowStub1.terminate("Mock terminating workflow");

        WorkflowStub workflowStub2 = WorkflowStub.fromTyped(workflow2);
        workflowStub2.getResult(String.class);
    }

    @Test
    public void testSetWorkflowExecutionTimeoutHangs() {
        ExampleWorkflow workflow = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        // setting this makes the test hang... this normally works outside of TestWorkflowEnv
                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10))
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        WorkflowExecution workflowExecution = WorkflowClient.start(workflow::execute, "test");

        // workflow execution timeout seems to clash with testEnv.sleep
        testEnv.sleep(Duration.ofMinutes(5L));

        WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);
        String result = workflowStub.getResult(String.class);
    }

    @Test
    public void testTestEnvSecondTimerSkipped() {
        ExampleWorkflow workflow = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        WorkflowExecution workflowExecution = WorkflowClient.start(workflow::execute, "test");

        testEnv.sleep(Duration.ofMinutes(5L));

        WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);
        String result = workflowStub.getResult(String.class);
        // why is this able to get past 2nd 10min-timer immediately without moving testEnv time further?
        System.out.println(result);
    }
}

```
## Specifications

  - Version: sdk 1.0.0, junit 5
  - Platform: MacOS BigSur



---

<a id="576"></a>

### #576: TestEnv: Failure signalling an *terminated* external workflow execution from another workflow

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/576 |
| **State** | CLOSED |
| **Author** | rubyhfu |
| **Created** | 2021-07-07 03:45:01.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-16 22:00:31.000 UTC |
| **Closed** | 2021-07-16 22:00:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior
Should get ApplicationFailure signaling into a terminated workflow, similar to a closed workflow

## Actual Behavior
22:28:25.463 [ForkJoinPool.commonPool-worker-19] ERROR io.temporal.internal.testservice.TestWorkflowMutableStateImpl - Failure signalling an external workflow execution
io.grpc.StatusRuntimeException: FAILED_PRECONDITION: Attempt to add an eBuilder after a completion eBuilder: event_type: EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED

## Steps to Reproduce the Problem

  1. Workflow Interface

```
import io.temporal.workflow.SignalMethod;
import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;

@WorkflowInterface
public interface ExampleWorkflow {

    @WorkflowMethod
    public String execute(String s);

    @SignalMethod
    public void signal(boolean s);
}

```

  2. WorkflowImpl1
```
import java.time.Duration;
import io.temporal.workflow.Workflow;

public class ExampleWorkflowImpl implements ExampleWorkflow{
    private boolean signal = false;

    @Override
    public String execute(String s) {
        Workflow.await(Duration.ofMinutes(5L), () -> signal);
        Workflow.sleep(Duration.ofMinutes(10L));
        return s;
    }

    @Override
    public void signal(boolean signal) {
        this.signal = signal;
    }
}
```

  3. WorkflowImpl2
```
import io.temporal.failure.ApplicationFailure;
import io.temporal.workflow.Workflow;

public class ExampleWorkflow2Impl implements ExampleWorkflow{
    @Override
    public String execute(String s) {
        try {
            ExampleWorkflow correspondingWorkflow = Workflow.newExternalWorkflowStub(ExampleWorkflow.class, "abc123");
            correspondingWorkflow.signal(true);
        } catch (ApplicationFailure e) {

        }
        return s;
    }

    @Override
    public void signal(boolean s) {

    }
}
```

  4. Run first test in test class
```
public class ExampleWorkflowImplTest {
    private TestWorkflowEnvironment testEnv;
    private Worker worker1, worker2;
    private WorkflowClient client;

    @BeforeEach
    public void setUp() {
        testEnv = TestWorkflowEnvironment.newInstance();
        worker1 = testEnv.newWorker("TEST_QUEUE1");
        worker2 = testEnv.newWorker("TEST_QUEUE2");
        worker1.registerWorkflowImplementationTypes(ExampleWorkflowImpl.class);
        worker2.registerWorkflowImplementationTypes(ExampleWorkflow2Impl.class);
        client = testEnv.getWorkflowClient();
        testEnv.start();
    }

    @Test
    public void testTerminateWorkflowSignalError() {
        ExampleWorkflow workflow1 = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setWorkflowId("abc123")
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        ExampleWorkflow workflow2 = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue("TEST_QUEUE2")
                        .build());

        WorkflowExecution workflow1Execution = WorkflowClient.start(workflow1::execute, "test");

        testEnv.sleep(Duration.ofMinutes(6L));

        WorkflowExecution workflow2Execution = WorkflowClient.start(workflow2::execute, "test");
        WorkflowStub workflowStub1 = WorkflowStub.fromTyped(workflow1);
        workflowStub1.terminate("Mock terminating workflow");

        WorkflowStub workflowStub2 = WorkflowStub.fromTyped(workflow2);
        workflowStub2.getResult(String.class);
    }

    @Test
    public void testSetWorkflowExecutionTimeoutHangs() {
        ExampleWorkflow workflow = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        // setting this makes the test hang... this normally works outside of TestWorkflowEnv
                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10))
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        WorkflowExecution workflowExecution = WorkflowClient.start(workflow::execute, "test");

        // workflow execution timeout seems to clash with testEnv.sleep
        testEnv.sleep(Duration.ofMinutes(5L));

        WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);
        String result = workflowStub.getResult(String.class);
    }

    @Test
    public void testTestEnvSecondTimerSkipped() {
        ExampleWorkflow workflow = client.newWorkflowStub(
                ExampleWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue("TEST_QUEUE1")
                        .build());

        WorkflowExecution workflowExecution = WorkflowClient.start(workflow::execute, "test");

        testEnv.sleep(Duration.ofMinutes(5L));

        WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);
        String result = workflowStub.getResult(String.class);
        // why is this able to get past 2nd 10min-timer immediately without moving testEnv time further?
        System.out.println(result);
    }
}
```



## Specifications

  - Version: sdk 1.0.0, junit 5
  - Platform: MacOS BigSur



---

<a id="555"></a>

### #555: temporal_local_activity_failed never logged

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/555 |
| **State** | CLOSED |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2021-06-25 00:39:20.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-09 06:30:41.000 UTC |
| **Closed** | 2021-07-09 06:30:41.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior

We have a system that uses only local activities and we never see the temporal_local_activity_failed get incremented.

## Actual Behavior

The temporal_activity_execution_failed counter is incremented instead.


## Specifications

  - Version: 1.0.8
  - Platform: java



---

<a id="551"></a>

### #551: ProtobufJsonPayloadConverter not using custom printer

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/551 |
| **State** | CLOSED |
| **Author** | mschielmann |
| **Created** | 2021-06-23 10:40:15.000 UTC (4y 6m ago) |
| **Updated** | 2021-07-02 19:07:09.000 UTC |
| **Closed** | 2021-07-02 19:07:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
`ProtobufJsonPayloadConverter` using predefined (passed through constructor) `JsonFormat.Printer`.

## Actual Behavior
It uses a default one (`JsonFormat.Printer.printer()`), it is being created on line 60 in `ProtobufJsonPayloadConverter`, shadowing the instance field `printer`.

## Steps to Reproduce the Problem

  1. Create `ProtobufJsonPayloadConverter` with custsom JsonFormat.Printer by passing it through constructor.
  2. The custom printer is not used as the default one is used instead.

## Specifications

  - Version: 1.0.9
  - Platform: N/A



---

<a id="521"></a>

### #521: Java SDK 1.0.8 is noisy on shutdown

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/521 |
| **State** | CLOSED |
| **Author** | GreyTeardrop (Mykola Rybak) |
| **Created** | 2021-06-01 13:18:37.000 UTC (4y 7m ago) |
| **Updated** | 2021-06-10 00:41:09.000 UTC |
| **Closed** | 2021-06-10 00:41:09.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior

Graceful worker shutdown should result in no errors in application logs.

## Actual Behavior

As of Java SDK 1.0.8 workers tend to log some errors like

```
java.lang.InterruptedException (Most recent call first)
    at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted (ClientCalls.java:749)
    at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain (ClientCalls.java:732)
    at io.grpc.stub.ClientCalls.blockingUnaryCall (ClientCalls.java:149)
    at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue (WorkflowServiceGrpc.java:2639)
    at io.temporal.internal.worker.WorkflowPollTask.poll (WorkflowPollTask.java:81)
    at io.temporal.internal.worker.WorkflowPollTask.poll (WorkflowPollTask.java:37)
    at io.temporal.internal.worker.Poller$PollExecutionTask.run (Poller.java:283)
    at io.temporal.internal.worker.Poller$PollLoopTask.run (Poller.java:242)
    at java.util.concurrent.ThreadPoolExecutor.runWorker ([unknown]:-1)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run ([unknown]:-1)
    at java.lang.Thread.run ([unknown]:-1)
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted (Most recent call first)
    at io.grpc.stub.ClientCalls.toStatusRuntimeException (ClientCalls.java:262)
    at io.grpc.stub.ClientCalls.getUnchecked (ClientCalls.java:243)
    at io.grpc.stub.ClientCalls.blockingUnaryCall (ClientCalls.java:156)
    at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue (WorkflowServiceGrpc.java:2639)
    at io.temporal.internal.worker.WorkflowPollTask.poll (WorkflowPollTask.java:81)
    at io.temporal.internal.worker.WorkflowPollTask.poll (WorkflowPollTask.java:37)
    at io.temporal.internal.worker.Poller$PollExecutionTask.run (Poller.java:283)
    at io.temporal.internal.worker.Poller$PollLoopTask.run (Poller.java:242)
    at java.util.concurrent.ThreadPoolExecutor.runWorker ([unknown]:-1)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run ([unknown]:-1)
    at java.lang.Thread.run ([unknown]:-1) 
```

## Steps to Reproduce the Problem

1. Start JVM worker.
2. Send it a signal for graceful termination.
3. Watch application logs.

The issue could be reproduced with any sample from the [`samples-java`](https://github.com/temporalio/samples-java/) repository. E.g. with [`HelloActivity`](https://github.com/temporalio/samples-java/blob/84e9f2cf986742c7a0cc56d57a8f7299f18ae0ab/src/main/java/io/temporal/samples/hello/HelloActivity.java):

<details>
<summary>Add factory shutdown code to the example</summary>

```diff
Index: src/main/java/io/temporal/samples/hello/HelloActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/io/temporal/samples/hello/HelloActivity.java b/src/main/java/io/temporal/samples/hello/HelloActivity.java
--- a/src/main/java/io/temporal/samples/hello/HelloActivity.java	(revision 7021fe356c72489c41048774b329054422f42144)
+++ b/src/main/java/io/temporal/samples/hello/HelloActivity.java	(date 1622552592206)
@@ -31,6 +31,7 @@
 import io.temporal.workflow.WorkflowInterface;
 import io.temporal.workflow.WorkflowMethod;
 import java.time.Duration;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Sample Temporal workflow that executes a single workflow activity.
@@ -183,6 +184,10 @@
 
     // Display workflow execution results
     System.out.println(greeting);
+
+    factory.shutdown();
+    factory.awaitTermination(1, TimeUnit.MINUTES);
+
     System.exit(0);
   }
 }    
```
</details>

<details>
<summary>Temporal SDK 1.0.7 logs</summary>

```
16:03:18.562 [main] INFO  i.t.s.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=127.0.0.1:7233}}
16:03:20.878 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=2, pollThreadNamePrefix='Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default"'}, identity=89225@KV0200-Mykola-Rybak}
16:03:20.879 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=1, pollThreadNamePrefix='Local Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default"'}, identity=89225@KV0200-Mykola-Rybak}
16:03:20.881 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default"'}, identity=89225@KV0200-Mykola-Rybak}
16:03:20.882 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Host Local Workflow Poller'}, identity=b8f3f995-bd96-4074-bd05-ec5f7432d50a}
Hello World!
16:03:21.382 [main] INFO  io.temporal.worker.WorkerFactory - shutdown
16:03:21.382 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:21.383 [Host Local Workflow Poller: 1] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.383 [Host Local Workflow Poller: 3] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.383 [Host Local Workflow Poller: 2] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.383 [Host Local Workflow Poller: 5] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.383 [Host Local Workflow Poller: 4] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.384 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:21.384 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.385 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 5] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.385 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 4] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.385 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 3] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.385 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.385 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:21.385 [Local Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.385 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:21.385 [Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.385 [Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2] INFO  io.temporal.internal.worker.Poller - poll loop done
16:03:21.386 [main] INFO  io.temporal.worker.WorkerFactory - awaitTermination begin
16:03:21.386 [main] INFO  io.temporal.worker.WorkerFactory - awaitTermination done
```
</details>

<details>
<summary>Temporal SDK 1.0.8 logs</summary>

```
16:03:49.630 [main] INFO  i.t.s.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=127.0.0.1:7233}}
16:03:51.986 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=2, pollThreadNamePrefix='Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default"'}, identity=89263@KV0200-Mykola-Rybak}
16:03:51.988 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=1, pollThreadNamePrefix='Local Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default"'}, identity=89263@KV0200-Mykola-Rybak}
16:03:51.989 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default"'}, identity=89263@KV0200-Mykola-Rybak}
16:03:51.990 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Host Local Workflow Poller'}, identity=a9903edb-c525-4369-bf3c-926eb856c7d2}
Hello World!
16:03:52.543 [main] INFO  io.temporal.worker.WorkerFactory - shutdown
16:03:52.543 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:53.052 [Host Local Workflow Poller: 5] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 5
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.052 [Host Local Workflow Poller: 1] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 1
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.052 [Host Local Workflow Poller: 4] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 4
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.053 [Host Local Workflow Poller: 5] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.052 [Host Local Workflow Poller: 3] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 3
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.053 [Host Local Workflow Poller: 4] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.052 [Host Local Workflow Poller: 2] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 2
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.053 [Host Local Workflow Poller: 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.053 [Host Local Workflow Poller: 2] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.053 [Host Local Workflow Poller: 3] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.055 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 4] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 4
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 5] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 5
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 5] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.558 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 4] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.559 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 3] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 3
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:53.559 [Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 3] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:53.559 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:54.062 [Local Activity Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:54.062 [main] INFO  io.temporal.internal.worker.Poller - shutdown
16:03:54.565 [Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] ERROR io.temporal.internal.worker.Poller - Failure in thread Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:54.566 [Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:54.566 [Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2] ERROR io.temporal.internal.worker.Poller - Failure in thread Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2
io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.InterruptedException: null
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	... 8 common frames omitted
16:03:54.566 [Workflow Poller taskQueue="HelloActivityTaskQueue", namespace="default": 2] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
16:03:54.566 [main] INFO  io.temporal.worker.WorkerFactory - awaitTermination begin
16:03:54.567 [main] INFO  io.temporal.worker.WorkerFactory - awaitTermination done
```
</details>

**Update**: the same issue is also reproduced by Java SDK builds itself. Here's a part of the build log with `USE_DOCKER_SERVICE=true`:

<details>
<summary>Java SDK build log</summary>

```
io.temporal.workflow.GenericParametersWorkflowTest > testGenericParametersWorkflow STANDARD_OUT
    07:43:48.111 [Test worker] INFO  i.t.s.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=4, target=temporal:7233}}
    07:43:48.862 [Time-limited test] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=2, pollThreadNamePrefix='Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest"'}, identity=3895@e0402adf52a3}
    07:43:48.881 [Time-limited test] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=1, pollThreadNamePrefix='Local Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest"'}, identity=3895@e0402adf52a3}
    07:43:48.896 [Time-limited test] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest"'}, identity=3895@e0402adf52a3}
    07:43:48.902 [Time-limited test] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=5, pollThreadNamePrefix='Host Local Workflow Poller'}, identity=bbd3b7ae-1225-4ce3-bdfe-fd3bdc6b49d2}
    07:43:52.956 [Time-limited test] INFO  io.temporal.worker.WorkerFactory - shutdownNow
    07:43:52.957 [Time-limited test] INFO  io.temporal.internal.worker.Poller - shutdownNow poller=Host Local Workflow Poller
    07:43:53.474 [Host Local Workflow Poller: 4] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 4
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.474 [Host Local Workflow Poller: 3] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 3
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.475 [Host Local Workflow Poller: 2] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 2
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.474 [Host Local Workflow Poller: 5] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 5
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.475 [Host Local Workflow Poller: 4] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.478 [Host Local Workflow Poller: 5] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.476 [Host Local Workflow Poller: 3] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.477 [Host Local Workflow Poller: 2] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.481 [Host Local Workflow Poller: 1] ERROR io.temporal.internal.worker.Poller - Failure in thread Host Local Workflow Poller: 1
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.482 [Host Local Workflow Poller: 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.487 [Time-limited test] INFO  io.temporal.internal.worker.Poller - shutdownNow poller=Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest"
    07:43:53.988 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 3] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 3
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.989 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 2] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 2
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.990 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 2] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.990 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 4] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 4
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.991 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 5] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 5
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.993 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 5] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.990 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 1] ERROR io.temporal.internal.worker.Poller - Failure in thread Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 1
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollActivityTaskQueue(WorkflowServiceGrpc.java:2683)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:99)
    	at io.temporal.internal.worker.ActivityPollTask.poll(ActivityPollTask.java:39)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:53.989 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 3] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.994 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:53.999 [Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 4] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:54.003 [Time-limited test] INFO  io.temporal.internal.worker.Poller - shutdownNow poller=Local Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest"

io.temporal.workflow.MetricsTest > testWorkflowMetrics STANDARD_OUT
    07:43:54.243 [Test worker] INFO  i.t.s.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=directaddress:///1e7752aa-0225-4ff2-be30-240124bc806e}}
    07:43:54.493 [Test worker] INFO  i.t.s.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=5, target=directaddress:///133b8efe-30a7-484a-95c7-6bd988c95170}}

io.temporal.workflow.GenericParametersWorkflowTest > testGenericParametersWorkflow STANDARD_OUT
    07:43:54.504 [Local Activity Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:54.506 [Time-limited test] INFO  io.temporal.internal.worker.Poller - shutdownNow poller=Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest"
    07:43:55.008 [Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 2] ERROR io.temporal.internal.worker.Poller - Failure in thread Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 2
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:55.010 [Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 2] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:55.014 [Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 1] ERROR io.temporal.internal.worker.Poller - Failure in thread Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 1
    io.grpc.StatusRuntimeException: CANCELLED: Thread interrupted
    	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262)
    	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156)
    	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
    	at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
    	at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:283)
    	at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:242)
    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    	at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.InterruptedException: null
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.throwIfInterrupted(ClientCalls.java:749)
    	at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:732)
    	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
    	... 8 common frames omitted
    07:43:55.017 [Workflow Poller taskQueue="WorkflowTest-testGenericParametersWorkflow-867aa9ec-3479-478a-bf63-5fe8a3f87253", namespace="UnitTest": 1] INFO  io.temporal.internal.worker.Poller - poll loop is terminated
    07:43:55.019 [Time-limited test] INFO  io.temporal.worker.WorkerFactory - awaitTermination begin
    07:43:55.024 [Time-limited test] INFO  io.temporal.worker.WorkerFactory - awaitTermination done
    07:43:55.026 [Time-limited test] INFO  i.t.i.t.TestWorkflowService - Shutting down GRPC server
    07:43:55.061 [Time-limited test] INFO  i.t.s.WorkflowServiceStubsImpl - shutdown

io.temporal.workflow.GenericParametersWorkflowTest > testGenericParametersWorkflow PASSED
```
</details>

## Specifications

  - Version: Java SDK 1.0.8
  - Platform: JDK 11.0.11



---

<a id="512"></a>

### #512: Missing getMemo functionality in WorkflowInfo

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/512 |
| **State** | CLOSED |
| **Author** | mobiletoly (Toly Pochkin) |
| **Created** | 2021-05-26 19:22:47.000 UTC (4y 7m ago) |
| **Updated** | 2021-08-26 20:29:59.000 UTC |
| **Closed** | 2021-08-26 20:29:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

### Expected Behavior
WorkflowInfo interface should have getMemo() to return memos

### Steps to Reproduce the Problem
WorkflowOptions.Builder has method `.setMemo` that allows setting memos. There is no corresponding WorkflowInfo method to retrieve this information from running workflow. This makes memo pretty useless when using Temporal Java SDK.

### Version
1.0.7

Conversation in Slack:
https://temporalio.slack.com/archives/CTT84KXK9/p1622042440064800



---

<a id="474"></a>

### #474: Child workflows do not receive search attributes (or memo)

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/474 |
| **State** | CLOSED |
| **Author** | skrul (Steve Krulewitz) |
| **Created** | 2021-05-08 00:17:16.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-19 01:55:03.000 UTC |
| **Closed** | 2021-05-19 01:55:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior

Just like regular workflows, child workflows should be created with search attributes and memo.

## Actual Behavior

Child workflows are not being created with search attributes and memo. This can be seen when you look at the child workflow's `WorkflowExecutionStarted` event in the history -- no search attributes.

I did some debugging on this and it seems that [SyncWorkflowContext::executeChildWorkflow](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/sync/SyncWorkflowContext.java#L375) is missing the code to set this stuff.

  - Version: server 1.6.3 / java sdk 1.7.0
  - Platform:



---

<a id="465"></a>

### #465: Allow passing proxy objects to registerActivitiesImplementations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/465 |
| **State** | CLOSED |
| **Author** | mostafacs (Mostafa) |
| **Created** | 2021-05-03 15:59:40.000 UTC (4y 8m ago) |
| **Updated** | 2021-05-03 16:07:53.000 UTC |
| **Closed** | 2021-05-03 15:59:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

I'm implementing a quarkus extension for temporal and it's about 90% completed. I want to support quarkus interceptors in Activities. quarkus handle interceptor interceptions with Proxy and Invocation Handler

I think supporting a factory method and passing the activity interface too is the solution

This is the link for my extension: https://github.com/mostafacs/quarkus-temporal-extension



---

<a id="456"></a>

### #456: Duplicate concurrent workflow - hangs on completion

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/456 |
| **State** | OPEN |
| **Author** | smax48 (Maxim Chuvilyaev) |
| **Created** | 2021-04-29 01:06:50.000 UTC (4y 8m ago) |
| **Updated** | 2024-11-19 19:12:14.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug, test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
I start 2 workflows (one by one) with the same workflowId and `WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE` option.
I use `execute` method to start exection.

First workflow is still running when I start the second - so the second should just becomes a "proxy" for the first one and should return the same result without starting a new wf instance.

Then I try to wait for CompletableFuture and get the result.
Pseudo-code for illustration:
```
f1 = WorkflowClient.execute(..., options)
f2 = WorkflowClient.execute(..., options)
result1 = f1.get()
result2 = f2.get()
```

The behaviour is very different when I use Test Environment and real docker containers for Temporal.
With "real" Temporal all works as expected.
I expect that in the test environment it works the same way.

## Actual Behaviour

With Test Environment the second f2.get() call hangs forever.

If the first workflow is fully completed before starting the second, all works OK.


## Steps to Reproduce the Problem

I have a test (implemented in Kotlin) that fully reproduces the described issue. See the attached file.
[DuplicateWorkflowIdTest.kt.zip](https://github.com/temporalio/sdk-java/files/6395725/DuplicateWorkflowIdTest.kt.zip)

## Specifications

  - Version: Java SDK 1.0.7, Temporal 1.8.2
  - Platform: Java SDK 1.0.7, Kotlin 



---

<a id="455"></a>

### #455: Flaky test: testExceptionOnStart

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/455 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-04-27 03:18:56.000 UTC (4y 8m ago) |
| **Updated** | 2021-07-26 22:49:59.000 UTC |
| **Closed** | 2021-07-26 22:49:59.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior
Test passes consistently

## Actual Behavior
Test times out intermittently.

## Steps to Reproduce the Problem

Run the test a few times.

## Analysis 

The test fails due to gRPC channel shutdown getting blocked on the long poll emitted from a worker. Here is the stack trace:
```
"Host Local Workflow Poller: 1@3179" daemon prio=5 tid=0x1d nid=NA waiting
  java.lang.Thread.State: WAITING
	 blocks Time-limited test@3166
	  at sun.misc.Unsafe.park(Unsafe.java:-1)
	  at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
	  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
	  at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)
	  at io.temporal.internal.testservice.TestWorkflowStoreImpl.pollWorkflowTaskQueue(TestWorkflowStoreImpl.java:346)
	  at io.temporal.internal.testservice.TestWorkflowService.pollWorkflowTaskQueue(TestWorkflowService.java:382)
	  at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$MethodHandlers.invoke(WorkflowServiceGrpc.java:3625)
	  at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
	  at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:331)
	  at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:797)
	  at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	  at io.grpc.internal.SerializeReentrantCallsDirectExecutor.execute(SerializeReentrantCallsDirectExecutor.java:49)
	  at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener.halfClosed(ServerImpl.java:808)
	  at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.halfClose(InProcessTransport.java:793)
	  - locked <0xda8> (a io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream)
	  at io.grpc.internal.ForwardingClientStream.halfClose(ForwardingClientStream.java:72)
	  at io.grpc.internal.DelayedStream$9.run(DelayedStream.java:344)
	  at io.grpc.internal.DelayedStream.drainPendingCalls(DelayedStream.java:181)
	  at io.grpc.internal.DelayedStream.access$100(DelayedStream.java:43)
	  at io.grpc.internal.DelayedStream$4.run(DelayedStream.java:147)
	  at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:740)
	  at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:149)
	  at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.pollWorkflowTaskQueue(WorkflowServiceGrpc.java:2639)
	  at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:81)
	  at io.temporal.internal.worker.WorkflowPollTask.poll(WorkflowPollTask.java:37)
	  at io.temporal.internal.worker.Poller$PollExecutionTask.run(Poller.java:265)
	  at io.temporal.internal.worker.Poller$PollLoopTask.run(Poller.java:241)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	  at java.lang.Thread.run(Thread.java:748)

"Time-limited test@3166" daemon prio=5 tid=0x1a nid=NA waiting for monitor entry
  java.lang.Thread.State: BLOCKED
	 waiting for Host Local Workflow Poller: 1@3179 to release lock on <0xda8> (a io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream)
	  at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.internalCancel(InProcessTransport.java:766)
	  at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.cancel(InProcessTransport.java:757)
	  at io.grpc.inprocess.InProcessTransport.shutdownNow(InProcessTransport.java:298)
	  at io.grpc.internal.ForwardingConnectionClientTransport.shutdownNow(ForwardingConnectionClientTransport.java:43)
	  at io.grpc.internal.CallCredentialsApplyingTransportFactory$CallCredentialsApplyingTransport.shutdownNow(CallCredentialsApplyingTransportFactory.java:196)
	  at io.grpc.internal.ForwardingConnectionClientTransport.shutdownNow(ForwardingConnectionClientTransport.java:43)
	  at io.grpc.internal.InternalSubchannel$8.run(InternalSubchannel.java:478)
	  at io.grpc.SynchronizationContext.drain(SynchronizationContext.java:95)
	  at io.grpc.SynchronizationContext.execute(SynchronizationContext.java:127)
	  at io.grpc.internal.ManagedChannelImpl.shutdownNow(ManagedChannelImpl.java:841)
	  at io.grpc.internal.ManagedChannelImpl.shutdownNow(ManagedChannelImpl.java:117)
	  at io.grpc.internal.ForwardingManagedChannel.shutdownNow(ForwardingManagedChannel.java:52)
	  at io.grpc.internal.ManagedChannelOrphanWrapper.shutdownNow(ManagedChannelOrphanWrapper.java:65)
	  at io.temporal.serviceclient.WorkflowServiceStubsImpl.shutdownNow(WorkflowServiceStubsImpl.java:245)
	  at io.temporal.testing.TestWorkflowEnvironmentInternal.close(TestWorkflowEnvironmentInternal.java:156)
	  at io.temporal.testing.TestWorkflowRule.shutdown(TestWorkflowRule.java:268)
	  at io.temporal.testing.TestWorkflowRule$2.evaluate(TestWorkflowRule.java:246)
	  at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:299)
	  at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:293)
	  at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	  at java.lang.Thread.run(Thread.java:748)
```


---

<a id="432"></a>

### #432: MicrometerClientStatsReporter overrides registry's naming convention

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/432 |
| **State** | CLOSED |
| **Author** | GreyTeardrop (Mykola Rybak) |
| **Created** | 2021-04-08 23:34:04.000 UTC (4y 9m ago) |
| **Updated** | 2021-04-10 20:01:49.000 UTC |
| **Closed** | 2021-04-10 20:01:49.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

`MicrometerClientStatsReporter` uses the naming convention that is native to the `MeterRegistry` it is provided with.

## Actual Behavior

`MicrometerClientStatsReporter` always overrides `MeterRegistry`'s naming convention with `snakeCase`.

## Background

We have recently plugged Temporal client and worker into our main application metrics that report metrics to the Datadog. Datadog's native naming convention is "dot-separated". After we've plugged Temporal client into the application's `MeterRegistry` we've noticed that all application metric names got renamed into snake case convention. Ideally, Temporal's SDK metrics should follow the convention of the host application.


---

<a id="392"></a>

### #392: TimeLockingFuture implementation is incorrect and easy to break 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/392 |
| **State** | OPEN |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2021-03-20 03:50:43.000 UTC (4y 9m ago) |
| **Updated** | 2024-12-17 21:26:58.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior

CompletableFuture returned from ```WorkflowStub#getResult``` and ```WorkflowStub#getResultAsync``` that has time skipping functionality built-in can correctly work with all CompletableFuture methods without losing time skipping functionality.

## Actual Behavior

CompletableFuture that is returned from ```#getResultAsync``` when we use ```TestWorkflowService``` is ```TimeLockingFuture```. It overrides ```CompletableFuture#get``` and ```CompletableFuture#join``` to provide time skipping functionality.
This implementation is extremely brittle because any chaining of this CompletableFuture will not call the overridden ```#get``` and ```#join```. So even trivial chaining completely and unexpectedly breaks the time-skipping feature.

## Steps to Reproduce the Problem

1. Use TestWorkflowService
2. Perform any trivial chaining on the result returning from getResultAsync
3. Time skipping doesn't work on ```#get``` call on a chained CompletableFuture from step 2.

Demonstration of the problem: https://github.com/Spikhalskiy/java-sdk/commit/e73d574428a7001534601c3bebabb60a23612bff
Adding a trivial ```result = result.thenApply(s -> s);``` chaining breaks the test and it hangs.

## Proposed solution
The current solution with intercepting stub methods and extending ```CompletableFuture``` looks like a hack and I'm not sure if it's possible to make it work correctly with ```CompletableFuture``` implementation.
My proposal is to completely remove built-in time skipping from ```WorkflowStub``` and ```TimeLockingFuture```.
One of the correct and nice ways to give time-skipping to tests developers can be through exposing of method ```.skipTime``` on some helper object that would return an ```AutoCloseable``` object that will trigger disabling of time-skipping at the end. It could be used by the test writers using the following pattern:

```
try (TimeSkipUtils.forStub(worflowStub).skipTimeSegment()) {
    result = resultFuture.get()
}

TimeSkipUtils.forStub can dig into worflowStub and make a helper that is aware of specific TestWorkflowService and provides 
.skipTimeSegment() that returns our ```AutoCloseable``` resource described above.
```

## Specifications

  - Version: Current master (5f2ac6133c6560984eff35cc85faafb85cbf2c94)



---

<a id="370"></a>

### #370: Add per method activity options

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/370 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-03-01 01:39:41.000 UTC (4y 10m ago) |
| **Updated** | 2021-04-27 02:29:05.000 UTC |
| **Closed** | 2021-04-27 02:29:05.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
From a[ forum post:](https://community.temporal.io/t/activities-requiring-different-options/752)

> Hello, Temporal!
I have an activity interface that defines three different (but related) activities, and each requires different options to be specified (e.g., timeouts). From the Java documentation:
Activity options are needed only if some of the required timeouts are not specified through the @ActivityMethod annotation.
This seems to suggest that @ActivityMethod annotations could be used to specify different options for each activity in a common interface. At the moment, it looks like ActivityMethod.java only supports overriding of the activity‚Äôs name.
So, is the only option for achieving different timeouts for different activities to instantiate multiple activity stubs within a workflow (each with its own ActivityOptions instance? And in this case, would distinct task queues be required for each stub?
Thanks!
Peter

**Describe the solution you'd like**
Support per activity type options when configuring activity stub instance. Consider adding ActivityOptions annotation to the activity method.

**Describe alternatives you've considered**
Keep the current implementation that would require a separate stub per activity type.



---

<a id="325"></a>

### #325: Javadoc for WorkflowClient refers to wrong API

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/325 |
| **State** | CLOSED |
| **Author** | sivasamyk (Siva Kaliappan) |
| **Created** | 2021-01-29 03:39:16.000 UTC (4y 11m ago) |
| **Updated** | 2021-07-16 01:01:54.000 UTC |
| **Closed** | 2021-06-05 03:19:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | vkoby |
| **Milestone** | None |

#### Description

## Expected Behavior

The Javadoc for WorkflowClient class refers to `WorkflowClient.newInstance(temporalServiceHost, temporalServicePort, namespace)` API here - https://github.com/temporalio/sdk-java/blob/2d9ef366807d3fe870e06d98c9eabdf3a93c1207/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java#L52 This `newInstance` method signature is not available.

## Actual Behavior

The docs should refer to the correct method.

## Steps to Reproduce the Problem

N/A

## Specifications

 N/A


---

<a id="321"></a>

### #321: check-updates is deprecated

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/321 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-01-27 01:30:40.000 UTC (4y 11m ago) |
| **Updated** | 2022-01-21 00:01:35.000 UTC |
| **Closed** | 2022-01-21 00:01:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

> Configure project :temporal-sdk
project ':temporal-sdk': Plugin name.remal.check-updates is deprecated: Use automatic dependency updates software like Renovate, Dependabot, etc...
project ':temporal-sdk': Plugin name.remal.check-dependency-updates is deprecated: Use automatic dependency updates software like Renovate, Dependabot, etc...
project ':temporal-sdk': Plugin name.remal.check-gradle-updates is deprecated: Use automatic dependency updates software like Renovate, Dependabot, etc...




---

<a id="301"></a>

### #301: Worker.replayWorkflowExecution does not report replay failures

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/301 |
| **State** | CLOSED |
| **Author** | GreyTeardrop (Mykola Rybak) |
| **Created** | 2021-01-11 14:46:50.000 UTC (4y 12m ago) |
| **Updated** | 2021-01-17 22:47:51.000 UTC |
| **Closed** | 2021-01-17 22:47:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Overview & Expected Behavior

This issue is a "follow-up" for issue #300. With some manual tweaks described in that ticket, I got a workflow history JSON that Java SDK was able to parse, and the test below succeeded. I expected the test to fail if I made any significant or non-backward-compatible changes to the workflow.

```java
import io.temporal.testing.WorkflowReplayer;
import org.junit.jupiter.api.Test;

public class SubmissionWorkflowReplayTest {

    @Test
    public void replayTest() throws Exception {
        WorkflowReplayer.replayWorkflowExecutionFromResource(
            "submission_workflow.json",
            SubmissionWorkflowImpl.class
        );
    }
}
```

## Actual Behavior

The replay test with Java SDK never fails given it can successfully parse the workflow history, regardless of what changes are made to the workflow or history JSON.

This seems to be caused by the [`Worker.replayWorkflowExecution()`](https://github.com/temporalio/sdk-java/blob/24a55be08d8cfaf0b8bb2bb49aab38e8344ce08c/temporal-sdk/src/main/java/io/temporal/worker/Worker.java#L386-L397) method that swallows all exceptions, including those that should signal that the replay has failed.

```java
public void replayWorkflowExecution(WorkflowExecutionHistory history) throws Exception {
  try {
    workflowWorker.queryWorkflowExecution(
        history,
        WorkflowClient.QUERY_TYPE_REPLAY_ONLY,
        String.class,
        String.class,
        new Object[] {});
  } catch (Exception e) {

  }
}
```

## Steps to Reproduce the Problem

  1. Create any workflow and execute it on a local Temporal server.
  2. Export workflow execution history as JSON.
  3. Tweak it so Java SDK could read it (required until #300 is fixed).
  4. Run replay test and check that it succeeds.
  5. Make any breaking change to the workflow logic.
  6. Run the test again.
  7. Observe that it still succeeds.

## Specifications

  - Version: Temporal Java SDK 1.0.4
  - Platform: macOS



---

<a id="294"></a>

### #294: Support Workflow.getInfo from query method body

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/294 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2021-01-07 17:29:50.000 UTC (5 years ago) |
| **Updated** | 2025-06-02 15:32:01.000 UTC |
| **Closed** | 2025-06-02 15:32:01.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |
| **Reactions** | üöÄ 1 |

#### Description

## Expected Behavior
Workflow.getInfo returns workflow information

## Actual Behavior
Call fails as query thread is not a workflow thread.




---

<a id="262"></a>

### #262: TestWorkflowEnvironment: Set close time on the visibility record

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/262 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-11-20 01:19:18.000 UTC (5y 1m ago) |
| **Updated** | 2024-12-17 21:27:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | test server |
| **Assignees** | None |
| **Milestone** | None |

#### Description

https://community.temporal.io/t/testworkflowenvironment-does-not-set-workflowexecutioninfo-closetime/1048


---

<a id="245"></a>

### #245: Support dynamic activity and workflow implementations

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/245 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-11-06 23:46:03.000 UTC (5y 2m ago) |
| **Updated** | 2020-12-29 21:51:47.000 UTC |
| **Closed** | 2020-12-29 21:51:47.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
In some cases, activity and workflow implementations should be loaded dynamically. It is similar to the way the Java app engines load applications using class loaders.

**Describe the solution you'd like**
Expose an extension point for dynamic activity loading. While the SDK might not provide the explicit loading mechanism it should provide a factory interface that is called with activity or workflow type to provide an untyped activity implementation. 

**Additional context**
https://community.temporal.io/t/dynamic-activities-registration-at-runtime-and-worker-splitting/930/7


---

<a id="235"></a>

### #235: Make PollerOptions.uncaughtExceptionHandler from workflowOptions etc.

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/235 |
| **State** | OPEN |
| **Author** | maxnilz (maxnilz) |
| **Created** | 2020-10-28 08:26:31.000 UTC (5y 2m ago) |
| **Updated** | 2020-10-28 08:26:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Hi, 

## Problem
I'm struggling with the "uncaught exception" which throws from "io.temporal.internal.worker.PollerOptions",  I was tried to check if is there any chance that I can configure the PollerOptions.uncaughtExceptionHandler via the workflow options or any other way,  but it turns out there is no such way that allows me to configure my own uncaughtExceptionHandler if I didn't miss any useful information 

## Expected behavior 
It would be good if I can configure my own uncaughtExceptionHandler from workflowOptions or somewhere else.

## An example "uncaught exception" stack
```
06:12:20.021 [Workflow Executor taskQueue="snapshot", namespace="default": 175] ERROR io.temporal.internal.worker.PollerOptions - uncaught exception
java.lang.RuntimeException: Failure processing workflow task. WorkflowId=snapshot-992, RunId=38b6ca3c-df38-4df8-9028-f025583fe251
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:337) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:275) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79) ~[temporal-sdk-1.0.0.jar:?]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_262]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_262]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_262]
Caused by: io.grpc.StatusRuntimeException: NOT_FOUND: Workflow task not found.
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262) ~[grpc-stub-1.32.1.jar:1.32.1]
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243) ~[grpc-stub-1.32.1.jar:1.32.1]
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156) ~[grpc-stub-1.32.1.jar:1.32.1]
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.respondWorkflowTaskCompleted(WorkflowServiceGrpc.java:2673) ~[temporal-serviceclient-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.lambda$sendReply$0(WorkflowWorker.java:369) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.common.GrpcRetryer.lambda$retry$0(GrpcRetryer.java:109) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:127) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.common.GrpcRetryer.retry(GrpcRetryer.java:106) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.sendReply(WorkflowWorker.java:362) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:313) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:275) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73) ~[temporal-sdk-1.0.0.jar:?]
	... 3 more
06:12:20.042 [Workflow Executor taskQueue="snapshot", namespace="default": 172] ERROR io.temporal.internal.worker.PollerOptions - uncaught exception
java.lang.RuntimeException: Failure processing workflow task. WorkflowId=snapshot-603, RunId=82e8b23a-24f9-4411-9b2b-b3db5a6a12bc
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:337) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.wrapFailure(WorkflowWorker.java:275) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79) ~[temporal-sdk-1.0.0.jar:?]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_262]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_262]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_262]
Caused by: io.grpc.StatusRuntimeException: NOT_FOUND: Workflow task not found.
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:262) ~[grpc-stub-1.32.1.jar:1.32.1]
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:243) ~[grpc-stub-1.32.1.jar:1.32.1]
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:156) ~[grpc-stub-1.32.1.jar:1.32.1]
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.respondWorkflowTaskCompleted(WorkflowServiceGrpc.java:2673) ~[temporal-serviceclient-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.lambda$sendReply$0(WorkflowWorker.java:369) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.common.GrpcRetryer.lambda$retry$0(GrpcRetryer.java:109) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:127) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.common.GrpcRetryer.retry(GrpcRetryer.java:106) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.sendReply(WorkflowWorker.java:362) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:313) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:275) ~[temporal-sdk-1.0.0.jar:?]
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73) ~[temporal-sdk-1.0.0.jar:?]
	... 3 more

```



---

<a id="232"></a>

### #232: Support building with JDK 9 or later

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/232 |
| **State** | CLOSED |
| **Author** | shyamalprasad (Shyamal Prasad) |
| **Created** | 2020-10-23 15:50:02.000 UTC (5y 2m ago) |
| **Updated** | 2020-11-07 02:43:54.000 UTC |
| **Closed** | 2020-11-07 02:43:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

The temporal-serviceclient  library cannot be compiled with JDK 15 (actually, JDK 9 or later), while temporal-sdk works fine.

```
/Users/sprasad/src/java-sdk/temporal-serviceclient/build/generated/main/java/io/temporal/api/workflowservice/v1/WorkflowServiceGrpc.java:28: error: cannot find symbol
@javax.annotation.Generated(
                 ^
  symbol:   class Generated
  location: package javax.annotation
```

The solution is to add the JSR-250 javax.annotation package as a dependency when not running with JDK 8 to the temporal-servicelcient's build.gradle file.

See https://github.com/temporalio/sdk-java/pull/231 for a fix.



---

<a id="227"></a>

### #227: Enable Serialization on WorkflowQueue 

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/227 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-10-06 16:55:53.000 UTC (5y 3m ago) |
| **Updated** | 2020-10-06 16:55:53.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Java-SDK
In the following community thread.
https://community.temporal.io/t/workflow-await-does-it-release-thread/252
To continually process events on a specific entity in the order we received the events, we can use WorkflowQueue. To implement this solution, we need WorkflowQueue to be serializable. At this time we can not use this technique as the WorkflowQueue is not implementing Serializable. The main purpose of this technique is to avoid long running workflows.

**Describe the solution you'd like**
Enable Serialization on WorkflowQueue 

**Describe alternatives you've considered**
Using Java Queue for now

**Additional context**
I received the above details from @maxim in one of my conversation in slack channel. Creating this ticket to make sure this requirement is addressed as part of the future releases.

Created from https://github.com/temporalio/temporal/issues/792



---

<a id="193"></a>

### #193: Update all state machines to avoid self transitions and hidden logic

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/193 |
| **State** | OPEN |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-08-22 23:39:12.000 UTC (5y 4m ago) |
| **Updated** | 2024-12-17 21:18:11.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | Sushisource |
| **Milestone** | None |

#### Description

Some workflow state machines have self transitions and additional conditional logic which is not part of the modeled state machine. For example, ActivityStateMachine has  these self transitions:

```
SCHEDULE_COMMAND_CREATED --> SCHEDULE_COMMAND_CREATED: SCHEDULE_ACTIVITY_TASK
STARTED_ACTIVITY_CANCEL_COMMAND_CREATED --> STARTED_ACTIVITY_CANCEL_COMMAND_CREATED: REQUEST_CANCEL_ACTIVITY_TASK
SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED --> SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED: REQUEST_CANCEL_ACTIVITY_TASK
```
These should be eliminated by introducing additional states as each of the events that cause state transition can be applied only once.

Activity `cancellationType` is modeled using if/else conditions in ActivityStateMachine. This should be converted to additional states in the state machine itself.

The goal of these changes is to make sure that all of the complex logic related to activity execution is explicitly modeled. This would simplify the understanding of the logic and help with the creation of additional SDKs.


---

<a id="187"></a>

### #187: ClassCastException interfering with error propagation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/187 |
| **State** | CLOSED |
| **Author** | ilmn-aeolus |
| **Created** | 2020-08-20 23:31:30.000 UTC (5y 4m ago) |
| **Updated** | 2020-08-21 16:34:37.000 UTC |
| **Closed** | 2020-08-21 16:34:37.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Activity fails (and failure is logged).

## Actual Behavior
The activity failure is not propagated due to a `ClassCastException`:
```
Caused by: io.temporal.failure.ApplicationFailure: message='java.lang.Error cannot be cast to java.lang.Exception', type='java.lang.ClassCastException', nonRetryable=false
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOActivityInboundCallsInterceptor.execute(POJOActivityTaskHandler.java:263)
	at io.temporal.internal.sync.POJOActivityTaskHandler$POJOActivityImplementation.execute(POJOActivityTaskHandler.java:220)
	at io.temporal.internal.sync.POJOActivityTaskHandler.handle(POJOActivityTaskHandler.java:185)
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:194)
	at io.temporal.internal.worker.ActivityWorker$TaskHandlerImpl.handle(ActivityWorker.java:154)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 3 common frames omitted
```

## Steps to Reproduce the Problem

  1. Reference `Workflow.getInfo().getWorkflowId()` from an Activity (yes, you aren't supposed to do this, but I didn't realize that at first, and the resulting behavior did not lend itself to my finding the root issue).

## Specifications

  - Version: 0.28.0
  - Platform: Windows



---

<a id="174"></a>

### #174: Not specifying optional maxInterval in RetryOptions causes an cryptic exception if activity fails

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/174 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2020-08-12 04:53:03.000 UTC (5y 5m ago) |
| **Updated** | 2020-08-23 19:51:21.000 UTC |
| **Closed** | 2020-08-23 19:51:21.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Test
```
@WorkflowInterface
  public interface TestWorkflow {
    @WorkflowMethod
    String workflow(String input);
  }

  @ActivityInterface
  public interface TestActivity {
    String activity(String input);
  }

  public static class ActivityWorkflow implements TestWorkflow {
    private final TestActivity activity =
        Workflow.newLocalActivityStub(TestActivity.class,
            LocalActivityOptions.newBuilder()
                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())
                .build());

    @Override
    public String workflow(String input) {return activity.activity(input);}
  }

  private static class ActivityImpl implements TestActivity {
    @Override
    public String activity(String input) {throw new RuntimeException();}
  }

  @Test
  public void trivialTest() {
    Worker worker = testEnvironment.newWorker(TASK_QUEUE);
    worker.registerWorkflowImplementationTypes(ActivityWorkflow.class);
    worker.registerActivitiesImplementations(new ActivityImpl());

    testEnvironment.start();
    WorkflowClient client = testEnvironment.getWorkflowClient();
    WorkflowOptions options = WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE)
            .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())
            .build();

    TestWorkflow workflow = client.newWorkflowStub(TestWorkflow.class, options);
    String result = workflow.workflow(UUID.randomUUID().toString());
  }
```

## Actual Behavior

Execution of this test completely hangs after temporal client internal exception:
```
0:44:31.648 [Local Activity Executor taskQueue="test-workflow", namespace="default": 1] ERROR i.t.internal.worker.PollerOptions - uncaught exception
java.lang.RuntimeException: Failure processing local activity task.
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.wrapFailure(LocalActivityWorker.java:232)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.wrapFailure(LocalActivityWorker.java:191)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.IllegalArgumentException: Invalid interval: PT0S
	at io.temporal.common.RetryOptions$Builder.setMaximumInterval(RetryOptions.java:202)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:264)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:202)
	at io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:191)
	at io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)
	... 3 common frames omitted
```

Which after 2 minutes is followed by:

```
00:46:32.565 [Test worker] WARN  i.t.internal.common.GrpcRetryer - Retrying after failure
io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: ClientCall was cancelled at or after deadline. []
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:244)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:225)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:142)
	at io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.getWorkflowExecutionHistory(WorkflowServiceGrpc.java:2644)
	at io.temporal.internal.common.WorkflowExecutionUtils.lambda$getInstanceCloseEvent$1(WorkflowExecutionUtils.java:250)
	at io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:127)
	at io.temporal.internal.common.WorkflowExecutionUtils.getInstanceCloseEvent(WorkflowExecutionUtils.java:238)
	at io.temporal.internal.common.WorkflowExecutionUtils.getWorkflowExecutionResult(WorkflowExecutionUtils.java:131)
	at io.temporal.internal.sync.WorkflowStubImpl.getResult(WorkflowStubImpl.java:346)
	at io.temporal.internal.sync.WorkflowStubImpl.getResult(WorkflowStubImpl.java:328)
	at io.temporal.internal.sync.TestWorkflowEnvironmentInternal$TimeLockingInterceptor$TimeLockingWorkflowStub.getResult(TestWorkflowEnvironmentInternal.java:289)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.startWorkflow(WorkflowInvocationHandler.java:315)
	at io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:270)
	at io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)
	at com.sun.proxy.$Proxy13.workflow(Unknown Source)
	at io.temporal.workflow.IncorrectRetryPolicyTest.trivialTest(IncorrectRetryPolicyTest.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)
	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:119)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
	at java.lang.Thread.run(Thread.java:748)
```

and the workflow stub call just never returns back.

There are two problems here:
1. `maxInterval` defined as optional explicitly in javadoc: "Maximum interval between retries. Exponential backoff leads to interval increase. This value is the cap of the increase. Default is 100x of initial interval." But right now it causes the exception if not specified explicitly.
2. [less important] Not specifying `initialInterval` that defined as "required" doesn't cause any exception and is not validated anyhow.

This is especially bad because this happens and can be caught only if the activity throws an exception and fails. Without that there is no chance you realize that you supplied an incorrect RetryOptions configuration. And even this exception is cryptic.

You maybe would expect that `RetryOptions#validateBuildWithDefaults` solves the problem, but no, it doesn't set maximumInterval explicitly, only `initialInterval` and `backoffCoefficient`.

## Workaround

The only way to make a test like this work is to call an explicit `.setMaximumInterval(Duration.ofMinutes(1))` on every `RetryOptions` you create. Also, you need to explicitly define `RetryOptions` to each workflow or activity, otherwise it will fail internally the same way if case of any exception. 

## Expected Behavior

RetryOptions.build javadoc states "Build RetryOptions without performing validation as validation should be done after merging with {@link MethodRetry}." Obviously no validation is happening and we get an internal exception at the moment when the retry policy is actually used.

## Steps to Reproduce the Problem

You can find the unit test here: https://github.com/Spikhalskiy/java-sdk/commit/54466378e9dcff6af057c70bd04ef7a08364f4e5

## Specifications

  - Version: current master (https://github.com/temporalio/java-sdk/commit/35abfd425c13e86f16b81e26c85c07b17ee3448f) and 0.28.0



---

<a id="171"></a>

### #171: Failing to mark Activity or Workflow interface as public is hard to diagnose

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/171 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2020-08-05 00:14:43.000 UTC (5y 5m ago) |
| **Updated** | 2020-08-05 00:16:50.000 UTC |
| **Closed** | 2020-08-05 00:16:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | mastermanu |
| **Milestone** | None |

#### Description

## Expected Behavior
A nice error message indicating that the interface needs to be marked as "public" during registration / worker start

## Actual Behavior
An esoteric runtime error that complains about not being able to invoke a public abstract method.

## Steps to Reproduce the Problem

  1. Create a workflow, but don't add the public modifier in front of the interface definition





---

<a id="165"></a>

### #165: Regression with a workflow implementing an empty marker interface

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/165 |
| **State** | CLOSED |
| **Author** | Spikhalskiy (Dmitry Spikhalsky) |
| **Created** | 2020-07-31 23:58:54.000 UTC (5y 5m ago) |
| **Updated** | 2020-08-05 00:16:50.000 UTC |
| **Closed** | 2020-08-05 00:16:50.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | mastermanu |
| **Milestone** | None |

#### Description

## Expected Behavior

In temporal 0.26.0 java-sdk the following structure worked just fine:
```
interface WorkflowMarker {
}

@WorkflowInterface
interface MyWorkflow {
    @WorkflowMethod
    fun execute(req: Req): Resp
}

MyWorkflowImpl : MyWorkflow, WorkflowMarker
```

## Actual Behavior

In temporal 0.28.0 it doesn't work and calling a stub causing:
```
Caused by: io.temporal.failure.ApplicationFailure: message='Interface doesn't contain any methods: WorkflowMarker', type='java.lang.IllegalArgumentException', nonRetryable=false
	at io.temporal.internal.sync.POJOWorkflowInterfaceMetadata.newInstance(POJOWorkflowInterfaceMetadata.java:125)
	at io.temporal.internal.sync.POJOWorkflowInterfaceMetadata.newInstanceSkipWorkflowAnnotationCheck(POJOWorkflowInterfaceMetadata.java:107)
	at io.temporal.internal.sync.POJOWorkflowImplMetadata.<init>(POJOWorkflowImplMetadata.java:93)
	at io.temporal.internal.sync.POJOWorkflowImplMetadata.newListenerInstance(POJOWorkflowImplMetadata.java:75)
	at io.temporal.internal.sync.WorkflowInternal.registerListener(WorkflowInternal.java:111)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation$RootWorkflowInboundCallsInterceptor.init(POJOWorkflowImplementationFactory.java:318)
	at io.temporal.internal.sync.POJOWorkflowImplementationFactory$POJOWorkflowImplementation.initialize(POJOWorkflowImplementationFactory.java:237)
	at io.temporal.internal.sync.SyncWorkflow.lambda$start$1(SyncWorkflow.java:117)
	at io.temporal.internal.sync.CancellationScopeImpl.run(CancellationScopeImpl.java:104)
	at io.temporal.internal.sync.WorkflowThreadImpl$RunnableWrapper.run(WorkflowThreadImpl.java:107)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
```

## Rootcause analysis

In 0.26.0 `POJOWorkflowImplMetadata` had a permissive implementation:
```
POJOWorkflowInterfaceMetadata interfaceMetadata =
    POJOWorkflowInterfaceMetadata.newImplementationInterface(anInterface);
List<POJOWorkflowMethodMetadata> methods = interfaceMetadata.getMethodsMetadata();
for (POJOWorkflowMethodMetadata methodMetadata : methods) {
...
}
```
If there is no methods in the interface - we do nothing and go to the next interface.

`POJOWorkflowInterfaceMetadata.newImplementationInterface(anInterface)` doesn‚Äôt throw an exception if there is no methods.

Now in 0.28.0 for each interface that the workflow implements we have

`POJOWorkflowInterfaceMetadata.newInstanceSkipWorkflowAnnotationCheck(anInterface);`
which throws an exception if the interface is empty even if the interface has no Temporal annotations at all.

## Specifications

  - Version: 0.26.0 vs 0.28.0 regression



---

<a id="155"></a>

### #155: Java SDK payload headers is out of sync with what go SDK / server uses

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/155 |
| **State** | CLOSED |
| **Author** | mastermanu |
| **Created** | 2020-07-25 06:27:15.000 UTC (5y 5m ago) |
| **Updated** | 2020-07-27 15:25:43.000 UTC |
| **Closed** | 2020-07-27 15:25:43.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | mfateev, mastermanu |
| **Milestone** | Initial Temporal Release |

#### Description

This PR: https://github.com/temporalio/go-sdk/commit/70e845523e6ef2cb26ea931f06caf4b22e06aeed changed the protocol for how payloads are described on the wire. The change has been landed in the Go SDK and is used by the server/the CLI, but the Java SDK is out of date.

This issue tracks getting the SDK back into re-alignment with Go / the Server


---

<a id="146"></a>

### #146: Block workflow instead of failing on unexpected exceptions

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/146 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-07-09 17:17:51.000 UTC (5y 6m ago) |
| **Updated** | 2020-11-25 01:49:54.000 UTC |
| **Closed** | 2020-11-25 01:49:54.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
Currently, an exception that is thrown from a workflow method fails the workflow. In a lot of cases, it is not desirable. For example, a NullPointerException usually means a bug that should be fixed. After the bug is fixed manual steps like reset are needed to restart workflows that failed. 

An Error thrown from a workflow method already doesn't fail workflow, but fails a decision task, essentially blocking the workflow execution until the error is fixed. As soon as the error is fixed (usually through a code deployment) the workflows continue from the place they were blocked without any additional manual intervention.

**Describe the solution you'd like**
The proposal is to change the default behavior to block workflow not only on Error, but also on any exception which is not specified in the "FailList".

**Describe alternatives you've considered**
Keep the current behavior and rely on reset to restart failed workflows.




---

<a id="135"></a>

### #135: Include local activity input into its marker decision

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/135 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-06-26 14:30:49.000 UTC (5y 6m ago) |
| **Updated** | 2021-04-20 19:09:52.000 UTC |
| **Closed** | 2021-04-20 19:09:52.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

**Is your feature request related to a problem? Please describe.**
For troubleshooting having activity input available in the event history is very useful.

**Describe the solution you'd like**
Include the input into the marker decision/event. Make it configurable through LocalActivityOptions as for some use cases inputs can be large and increase history size beyond acceptable.






---

<a id="98"></a>

### #98: NPE on null input when calling continue as new

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/98 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-06-04 22:18:52.000 UTC (5y 7m ago) |
| **Updated** | 2020-06-22 04:52:25.000 UTC |
| **Closed** | 2020-06-22 04:52:25.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

## Expected Behavior
Should support continue as new with methods without arguments.

    @Override
    public void run() {
        .....
        continueAsNewWorkflow.run();
    }


## Actual Behavior
"java.lang.NullPointerException\\n\\tat io.temporal.proto.decision.ContinueAsNewWorkflowExecutionDecisionAttributes$Builder.setInput(ContinueAsNewWorkflowExecutionDecisionAttributes.java:1494)\\n\\tat io.temporal.internal.replay.DecisionsHelper.continueAsNewWorkflowExecution(DecisionsHelper.java:442)

## Steps to Reproduce the Problem
Call continue as new on a workflow with @WorkflowMethod without arguments.

## Specifications
0.23.1 release of Java SDK

## Solution



---

<a id="80"></a>

### #80: Workflow versioning marker not respected on replay

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/80 |
| **State** | CLOSED |
| **Author** | chris-rcn |
| **Created** | 2020-05-07 03:20:17.000 UTC (5y 8m ago) |
| **Updated** | 2020-05-11 18:33:24.000 UTC |
| **Closed** | 2020-05-11 18:33:24.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | bug |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Take the following trivial example:
```
  public interface FooWorkflow {
    @WorkflowMethod
    void exec();
    @SignalMethod
    void input(int value);
  }
```
With V1 implementation:
```
  public static class FooWorkflowImpl implements FooWorkflow {
    private static final Logger LOGGER = LoggerFactory.getLogger(FooWorkflowImpl.class);
    private int reincarnation;
    @Override
    public void exec() {
      int changeFoo = Workflow.getVersion("changeFoo", Workflow.DEFAULT_VERSION, 1);
      LOGGER.info("changeFoo version {}", changeFoo);
      Workflow.await(() -> reincarnation > 0);
    }
    @Override
    public void input(int value) {
      this.reincarnation = value;
    }
  }
```
As expected, this prints:
```
changeFoo version 1
```

Now imagine a V2 implementation that looks as follows:
```
    @Override
    public void exec() {
      int changeBar = Workflow.getVersion("changeBar", Workflow.DEFAULT_VERSION, 1);
      LOGGER.info("changeBar version {}", changeBar);
      int changeFoo = Workflow.getVersion("changeFoo", Workflow.DEFAULT_VERSION, 1);
      LOGGER.info("changeFoo version {}", changeFoo);
      Workflow.await(() -> reincarnation > 0);
    }
```
If I update the worker code and signal the existing workflow. Then the output it prints is:
```
changeBar version -1
changeFoo version -1
```
Why did changeFoo not reuse the previous version 1 from the marker?

It is falling into here, in DecisionsHelper:
```
    // If we have a version marker in history event but not in decisions, let's add one.
    RecordMarkerDecisionAttributes marker =
        new RecordMarkerDecisionAttributes()
            .setMarkerName(ClockDecisionContext.VERSION_MARKER_NAME)
            .setHeader(event.getMarkerRecordedEventAttributes().getHeader())
            .setDetails(event.getMarkerRecordedEventAttributes().getDetails());
    Decision markerDecision =
        new Decision()
            .setDecisionType(DecisionType.RecordMarker)
            .setRecordMarkerDecisionAttributes(marker);
    DecisionId markerDecisionId = new DecisionId(DecisionTarget.MARKER, nextDecisionEventId);
    decisions.put(
        markerDecisionId, new MarkerDecisionStateMachine(markerDecisionId, markerDecision));
    nextDecisionEventId++;
```
Based on the comment, it should not be executing this code.


---

<a id="55"></a>

### #55: Support @SignalMethod and @QueryMethod in independent interfaces

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/55 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-04-01 16:00:28.000 UTC (5y 9m ago) |
| **Updated** | 2020-04-07 04:38:18.000 UTC |
| **Closed** | 2020-04-07 04:38:18.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | enhancement |
| **Assignees** | None |
| **Milestone** | None |

#### Description

Support registering handlers for signal and query independently from the main workflow interface.
The same for invocation. 
The strawman:

```
public interface MySignal {
   @SignalMethod
   foo(String arg);
}

Workflow.registerHandler(new MySignalImpl());
```

Then to invoke signal or query from outside:
```

h = client.new..Stub(MySignal.class, workflowId);
h.foo("bar");
```
This would allow implementing independent reusable libraries which could be shared by multiple workflows.


---

<a id="23"></a>

### #23: Change Activity.getTask to Activity.getInfo

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/23 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-19 21:42:53.000 UTC (5y 10m ago) |
| **Updated** | 2020-08-23 19:37:29.000 UTC |
| **Closed** | 2020-08-23 19:37:29.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

ActivityTask is protobuf which is too low level to expose to the activity code.

Also add Activity.getTimeUntilTimeout() to give simple indication when activity is going to timeout.


---

<a id="19"></a>

### #19: Expose RPC timeout to the client code

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/19 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-15 02:17:36.000 UTC (5y 11m ago) |
| **Updated** | 2020-08-23 19:37:51.000 UTC |
| **Closed** | 2020-08-23 19:37:51.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

From the customer:

_It seems that the Worker and WorkflowClient classes from the Java client do not expose a way to set the RPC timeout.  It defaults to 1 second, which was not enough in some of my testing scenarios.  Would be nice if this can be set by the client code._



---

<a id="15"></a>

### #15: Fix CancellationException stack trace

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/15 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-09 23:29:14.000 UTC (5y 11m ago) |
| **Updated** | 2020-04-07 04:06:03.000 UTC |
| **Closed** | 2020-04-07 04:06:03.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | None |

#### Description

When an activity is cancelled the thrown CancellationException contains stack trace of the `handleActivityTaskCanceled`, not the caller of the activity:

```
[{"detailMessage":null,"stackTrace":"com.uber.cadence.internal.replay.ActivityDecisionContext.handleActivityTaskCanceled(ActivityDecisionContext.java:134)
com.uber.cadence.internal.replay.DecisionContextImpl.handleActivityTaskCanceled(DecisionContextImpl.java:280)
com.uber.cadence.internal.replay.ReplayDecider.processEvent(ReplayDecider.java:113)
com.uber.cadence.internal.replay.ReplayDecider.decideImpl(ReplayDecider.java:407)
com.uber.cadence.internal.replay.ReplayDecider.decide(ReplayDecider.java:359)
com.uber.cadence.internal.replay.ReplayDecisionTaskHandler.processDecision(ReplayDecisionTaskHandler.java:145)
com.uber.cadence.internal.replay.ReplayDecisionTaskHandler.handleDecisionTaskImpl(ReplayDecisionTaskHandler.java:125)
com.uber.cadence.internal.replay.ReplayDecisionTaskHandler.handleDecisionTask(ReplayDecisionTaskHandler.java:86)
com.uber.cadence.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:257)
com.uber.cadence.internal.worker.WorkflowWorker$TaskHandlerImpl.handle(WorkflowWorker.java:229)
com.uber.cadence.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:71)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
java.lang.Thread.run(Thread.java:748)
","suppressedExceptions":[],"class":"java.util.concurrent.CancellationException"}],
```



---

<a id="12"></a>

### #12: Remove InterruptedException from WorkflowQueue

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/12 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-02-01 22:02:07.000 UTC (5y 11m ago) |
| **Updated** | 2020-04-07 04:05:39.000 UTC |
| **Closed** | 2020-04-07 04:05:39.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

Workflow code should never throw InterruptedException as CancellationScope should be used for cancellation.


---

<a id="7"></a>

### #7: Migrate Java Client from Thrift/TChannel to gRPC

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/7 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-01-18 18:06:59.000 UTC (5y 11m ago) |
| **Updated** | 2020-03-29 01:19:35.000 UTC |
| **Closed** | 2020-03-29 01:19:35.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

*No description provided.*


---

<a id="6"></a>

### #6: Implement temporal gRPC code generation

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/6 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-01-18 18:06:32.000 UTC (5y 11m ago) |
| **Updated** | 2020-04-07 04:05:17.000 UTC |
| **Closed** | 2020-04-07 04:05:17.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

Add dependency on https://github.com/temporalio/temporal-proto and Gradle rules to build Java bindings.


---

<a id="5"></a>

### #5: Enable Buildkite for Java Client

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/5 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-01-18 18:04:43.000 UTC (5y 11m ago) |
| **Updated** | 2020-03-05 17:54:13.000 UTC |
| **Closed** | 2020-02-11 00:47:31.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

Any PR should be tested automatically using [buildkite](https://buildkite.com/).


---

<a id="4"></a>

### #4: Move code from com.uber.cadence to io.temporal packages

| Field | Value |
|-------|-------|
| **URL** | https://github.com/temporalio/sdk-java/issues/4 |
| **State** | CLOSED |
| **Author** | mfateev (Maxim Fateev) |
| **Created** | 2020-01-18 18:01:28.000 UTC (5y 11m ago) |
| **Updated** | 2020-03-29 01:19:48.000 UTC |
| **Closed** | 2020-03-29 01:19:48.000 UTC |
| **Upvotes** | 0 |
| **Comments** | 0 |
| **Priority Score** | 0 |
| **Labels** | None |
| **Assignees** | None |
| **Milestone** | Initial Temporal Release |

#### Description

*No description provided.*


