{"assignees":[],"author":{"id":"U_kgDOCrnpNg","is_bot":false,"login":"hansen-jake","name":""},"body":"When starting multiple async activities within a workflow, references to the activity inputs are never null’d out so the inputs are never garbage collected, leading to a memory leak. This has caused our workers to run out of memory.\r\n\r\n## Expected Behavior\r\n\r\nThe expectation/assumption is that as activities within a workflow complete, references to their inputs are null’d out, making them eligible for garbage collection.\r\n\r\n## Actual Behavior\r\n\r\nAfter running the below code for a while, a heap dump shows that a strong reference to each activity input is held by the class `WorkflowOutboundCallsInterceptor$ActivityInput`, even after each activity completes, causing a memory leak.\r\n\r\n## Steps to Reproduce the Problem\r\n\r\nSee below code for reproduction.\r\n\r\n## Specifications\r\n\r\n  - Version: Java SDK 1.25.1\r\n\r\n```java\r\n// NOT A CONTRIBUTION\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\r\n        WorkflowClient client = WorkflowClient.newInstance(service);\r\n        WorkerFactory factory = WorkerFactory.newInstance(client);\r\n        Worker worker = factory.newWorker(\"task_queue\");\r\n        worker.registerWorkflowImplementationTypes(EventLoopWorkflowImpl.class);\r\n        worker.registerActivitiesImplementations(new ProcessingActivityImpl(client));\r\n        factory.start();\r\n\r\n        EventLoopWorkflow workflow = client.newWorkflowStub(\r\n                EventLoopWorkflow.class,\r\n                WorkflowOptions.newBuilder()\r\n                        .setWorkflowId(UUID.randomUUID().toString())\r\n                        .setTaskQueue(\"task_queue\")\r\n                        .build());\r\n\r\n        workflow.startEventLoop();\r\n    }\r\n\r\n    @WorkflowInterface\r\n    public interface EventLoopWorkflow {\r\n\r\n        @WorkflowMethod\r\n        void startEventLoop();\r\n\r\n        @SignalMethod\r\n        void addBatch(List<String> batch);\r\n    }\r\n\r\n    public static class EventLoopWorkflowImpl implements EventLoopWorkflow {\r\n\r\n        private final ConcurrentLinkedQueue<Supplier<?>> eventQueue = new ConcurrentLinkedQueue<>();\r\n\r\n        private final ProcessingActivity activity = Workflow.newActivityStub(\r\n                ProcessingActivity.class,\r\n                ActivityOptions.newBuilder()\r\n                        .setStartToCloseTimeout(Duration.ofHours(24))\r\n                        .build());\r\n\r\n        @Override\r\n        public void startEventLoop() {\r\n            var getBatches = Async.procedure(activity::getBatches);\r\n\r\n            do {\r\n                Workflow.await(() -> getBatches.isCompleted() || !eventQueue.isEmpty());\r\n\r\n                Supplier<?> event;\r\n                while ((event = eventQueue.poll()) != null) {\r\n                    event.get();\r\n                }\r\n\r\n            } while (!getBatches.isCompleted());\r\n        }\r\n\r\n        @Override\r\n        public void addBatch(List<String> batch) {\r\n            eventQueue.add(() -> Async.procedure(activity::processBatch, batch));\r\n        }\r\n    }\r\n\r\n    @ActivityInterface\r\n    public interface ProcessingActivity {\r\n\r\n        void getBatches();\r\n\r\n        void processBatch(List<String> items);\r\n    }\r\n\r\n    public static class ProcessingActivityImpl implements ProcessingActivity {\r\n\r\n        private final WorkflowClient workflowClient;\r\n\r\n        public ProcessingActivityImpl(WorkflowClient workflowClient) {\r\n            this.workflowClient = workflowClient;\r\n        }\r\n\r\n\r\n        @Override\r\n        public void getBatches() {\r\n            var ctx = Activity.getExecutionContext();\r\n            var workflow = workflowClient.newWorkflowStub(EventLoopWorkflow.class, ctx.getInfo().getWorkflowId());\r\n            int batchId = 0;\r\n\r\n            while (true) {\r\n                try {\r\n                    workflow.addBatch(List.of(String.valueOf(batchId++)));\r\n                    Thread.sleep(1000);\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void processBatch(List<String> items) {\r\n            System.out.println(\"Processing batch \" + items.get(0));\r\n        }\r\n    }\r\n}\r\n```\r\n","closedAt":"2024-10-15T15:05:31Z","comments":[{"id":"IC_kwDODN12PM6KfmUm","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Thank you for the detailed reproduction. Running the provided code and looking at a memory snapshot it looks like the activity input is being held because the internal `ActivityStateMachine` holds it and the state machine is being held by the cancellation callback in the `CancellationScope`. We could make the cancellation callback hold a weak reference to the state machine or remove the cancellation callback once the `ActivityStateMachine` is in an terminal state.","createdAt":"2024-09-01T23:30:08Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2203#issuecomment-2323539238","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6KsqHt","author":{"login":"hansen-jake"},"authorAssociation":"NONE","body":"What are the tradeoffs of doing one over the other?","createdAt":"2024-09-03T16:32:54Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2203#issuecomment-2326962669","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6Ku_EZ","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"From the user perspective very little. Either would remove the reference to the StateMachine and let the input be GC'd","createdAt":"2024-09-03T22:49:47Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2203#issuecomment-2327572761","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6K2u2e","author":{"login":"hansen-jake"},"authorAssociation":"NONE","body":"Is there a target version where this fix can be included? ","createdAt":"2024-09-04T17:20:06Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2203#issuecomment-2329603486","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6LJM0Z","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Yes I hope to have some improvements here for the next minor SDK release . ","createdAt":"2024-09-06T16:45:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2203#issuecomment-2334444825","viewerDidAuthor":false}],"createdAt":"2024-08-31T03:41:59Z","labels":[],"milestone":null,"number":2203,"reactionGroups":[],"state":"CLOSED","title":"Async activity inputs potential memory leak","updatedAt":"2024-10-15T15:05:31Z","url":"https://github.com/temporalio/sdk-java/issues/2203"}
