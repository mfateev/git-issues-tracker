{"assignees":[],"author":{"id":"MDQ6VXNlcjcyOTc0MA==","is_bot":false,"login":"scoplin","name":"Scott Coplin"},"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nIf the `Async.function` (or similar) methods is called in an attempt to dispatch a child workflow from a Scala class, it fails to properly detect the attempt to call a workflow method on a temporal stub, and instead falls back to submitting the function to a new workflow thread in `AsyncInternal`.  As a result, we saw excessive threads being created and consumed in workers, eventually resulting in `RejectedExectionException` being thrown from the underlying executor.\r\n\r\nFor reference, the structure of the Scala code to demonstrate the problem is:\r\n\r\n    val stub = Workflow.newChildWorkflowStub(classOf[MyWorkflow], workflowOptions)\r\n    val result = Async.function(stub.performMyWorkflow, workflowInput)  // Problem occurs here\r\n\r\n**Describe the solution you'd like**\r\n\r\nThe logic in `MethodReferenceDisassembler.isAsync(Object)` should be modified to account for Scala method references.  When I investigated this with a debugger, I saw that [this line](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/internal/async/MethodReferenceDisassembler.java#L57) in `isAsyncJava` appeared to be where a modification could be made:\r\n\r\n    && lambda.getImplMethodKind() == MethodHandleInfo.REF_invokeInterface);\r\n\r\nWith a Scala method reference, the implementation method kind is equal to `MethodHandleInfo.REF_invokeStatic`.  In my particular case, both Java and Scala are giving me a target reference of type `AsyncInternal.AsyncMarker`.  I'm hoping that a fix is as simple as allowing both types of method implementation kinds may be all that's required here.\r\n\r\nThis is substantially less than the request for full Scala support covered by #1007.  That is obviously a lot more work.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nI was able to work around this issue by creating a small java shim class to call `Async.function` using a Java method reference.\r\n\r\n**Additional context**\r\n\r\nMy local debugging was done against Scala 2.12.  I am not sure to what degree these behaviors differ across Scala versions.\r\n\r\nIt appears to me that the [vitaliihonta/ztemporal](https://github.com/vitaliihonta/ztemporal) project _may_ also run afoul of this introspection problem based upon how it uses `Async` in its [ZPromise](https://github.com/vitaliihonta/zio-temporal/blob/9e21f23857ebd376e35ed7c6622029487b64c60b/core/src/main/scala/zio/temporal/promise/ZPromise.scala#L86).","closedAt":"2025-06-02T15:20:35Z","comments":[{"id":"IC_kwDODN12PM5VC2su","author":{"login":"ploddi"},"authorAssociation":"NONE","body":"@scoplin can you share you Java workaround?","createdAt":"2023-02-11T16:13:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1489#issuecomment-1426811694","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5VEE2H","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"I solved the same problem for Kotlin here: [KotlinMethodReferenceDisassemblyService](https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-kotlin/src/main/kotlin/io/temporal/internal/async/KotlinMethodReferenceDisassemblyService.kt#L28)\r\n\r\nThere is a handy abstraction that can be implemented for Scala (if at all possible to do) to support their method references as natively as Java ones: [MethodReferenceDisassemblyService](https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/internal/async/spi/MethodReferenceDisassemblyService.java#L31)\r\n\r\nThere are also tests in KotlinAsyncChildWorkflowTest, KotlinAsyncCompanionFunctionTest, KotlinAsyncLambdaTest that may give a framework for the same tests for Scala.\r\n\r\nIf you are interested in researching and disassembling Scala's method references, we would be open to getting a `temporal-scala` module that will bring the method reference disassembly service for Scala.","createdAt":"2023-02-12T21:00:54Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1489#issuecomment-1427131783","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5VN09g","author":{"login":"ploddi"},"authorAssociation":"NONE","body":"@Spikhalskiy I believe that Scala can use same `DisassemblyService` as Java, with the only difference that Scala compiler generates different implementation method kinds for lambdas, so actual `stub` checking method should be adjusted for Scala specific method references.","createdAt":"2023-02-14T12:42:41Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1489#issuecomment-1429688160","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5VN1st","author":{"login":"ploddi"},"authorAssociation":"NONE","body":"Do we even need this check?\r\n```java\r\n&& lambda.getImplMethodKind() == MethodHandleInfo.REF_invokeInterface);\r\n```\r\nBecause without it Scala method references will work.","createdAt":"2023-02-14T12:45:19Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1489#issuecomment-1429691181","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5VOtYE","author":{"login":"scoplin"},"authorAssociation":"NONE","body":"@ploddi My workaround was method-specific.  I simply took this line:\r\n```\r\nval result = Async.function(stub.performMyWorkflow, workflowInput)  // Problem occurs here\r\n``` \r\nAnd wrote/compiled it in java instead as a trivial static method.  Then I called that wrapper method from scala.","createdAt":"2023-02-14T15:20:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-java/issues/1489#issuecomment-1429919236","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6utxaS","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"This would be covered when/if we add a dedicated scala module","createdAt":"2025-06-02T15:20:35Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1489#issuecomment-2931234450","viewerDidAuthor":false}],"createdAt":"2022-10-20T15:58:35Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzE5ODQ0","name":"enhancement","description":"User experience","color":"a2eeef"}],"milestone":null,"number":1489,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}},{"content":"EYES","users":{"totalCount":1}}],"state":"CLOSED","title":"Support Scala references to workflow methods","updatedAt":"2025-06-02T15:20:36Z","url":"https://github.com/temporalio/sdk-java/issues/1489"}
