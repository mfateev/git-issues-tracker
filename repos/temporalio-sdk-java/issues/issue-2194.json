{"assignees":[],"author":{"id":"MDQ6VXNlcjgzODMwMA==","is_bot":false,"login":"nikoncode","name":"Mikita Karaliou"},"body":"# Steps to reproduce \r\n\r\n* use `spring.temporal.start-workers = false` or just don't start worker\r\n* terminate application (`io.temporal.worker.WorkerFactory#shutdown`)  - `LocalActivitySlotSupplierQueue` remains working and blocks jvm from exiting\r\n\r\nReproduced on last available temporal version 1.25.0\r\n\r\n# Possible explanation\r\n\r\n* `io.temporal.internal.worker.LocalActivitySlotSupplierQueue#LocalActivitySlotSupplierQueue` created during initialization of `io.temporal.internal.worker.LocalActivityWorker#LocalActivityWorker`\r\n* `io.temporal.internal.worker.LocalActivityWorker#activityAttemptTaskExecutor` became null until `start` called - we don't do this\r\n* `io.temporal.internal.worker.LocalActivityWorker#shutdown` expect `activityAttemptTaskExecutor` to be not null and doesn't call  `slotQueue.shutdown()`\r\n\r\n# Possible fix\r\n* Since this thread created in constructor we should probably move `slotQueue.shutdown()` one line higher to stop this thread indepenendly of worker start call.\r\n* Or initialize it in start, not in the constructor.\r\n\r\n# Use cases \r\n\r\nWe want to have support of \"management commands\" inside our applications. This is separate run mode, which requires disable of all external services (kafka, Temporal, grpc, etc).","closedAt":"2024-08-20T20:13:05Z","comments":[{"id":"IC_kwDODN12PM6JBx_w","author":{"login":"nikoncode"},"authorAssociation":"NONE","body":"Snippet to reproduce:\r\n\r\n```\r\n        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\r\n        WorkflowClient client = WorkflowClient.newInstance(service);\r\n        WorkerFactory factory = WorkerFactory.newInstance(client);\r\n        Worker worker = factory.newWorker(\"test\");\r\n\r\n        factory.shutdown();\r\n```","createdAt":"2024-08-20T14:03:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2194#issuecomment-2298945520","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6JBz0H","author":{"login":"nikoncode"},"authorAssociation":"NONE","body":"It's also strange that `io.temporal.internal.worker.LocalActivityWorker#shutdown` call interrupt for this thread conditionally, but `io.temporal.internal.worker.LocalActivityWorker#awaitTermination` not.","createdAt":"2024-08-20T14:06:48Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2194#issuecomment-2298952967","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6JCKQZ","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Thank you for the detailed bug report:\r\n* `LocalActivitySlotSupplierQueue` should only create a thread if the worker is started\r\n* `awaitTermination` should not call `slotQueue.shutdown()`, but should verify the shutdown has finished. If the queue was never started it can return immediately ","createdAt":"2024-08-20T14:46:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2194#issuecomment-2299044889","viewerDidAuthor":false}],"createdAt":"2024-08-20T13:55:46Z","labels":[],"milestone":null,"number":2194,"reactionGroups":[],"state":"CLOSED","title":"Thread `LocalActivitySlotSupplierQueue` prevent JVM from termination","updatedAt":"2024-08-20T20:13:05Z","url":"https://github.com/temporalio/sdk-java/issues/2194"}
