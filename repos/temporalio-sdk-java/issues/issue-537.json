{"assignees":[{"id":"MDQ6VXNlcjUzMjEwOA==","login":"Spikhalskiy","name":"Dmitry Spikhalsky","databaseId":0}],"author":{"id":"MDQ6VXNlcjU4MTc4NTk=","is_bot":false,"login":"smax48","name":"Maxim Chuvilyaev"},"body":"## Expected Behavior\r\n\r\nGiven a workflow that invokes some activities and/or child workflows in an async way, trace context should correctly propagate into those async activities/child WF. Also the result trace should not be broken into multiple unrelated chunks\r\n\r\n## Actual Behavior\r\n\r\nResult trace for the main WF doesn't contain spans for async activities / child WF - their execution is represented in isolated traces instead.\r\n\r\n## Steps to Reproduce the Problem\r\n\r\nThe easiest way to reproduce is to use SpanContextPropagationTest from temporal-opentracing and change activity invocation to Async.function {...}.get()\r\n\r\n## Specifications\r\n\r\n  - Version: Temporal Java SDK 1.0.9\r\n","closedAt":"2022-01-05T15:13:31Z","comments":[{"id":"MDEyOklzc3VlQ29tbWVudDg1OTIzMDI1Mw==","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"@smax48 thanks for the report, it does look like a bug.\r\n\r\nFailing unit test: https://github.com/Spikhalskiy/java-sdk/commit/1811aa0818df841ee97d4d44d857335662e24c83#diff-b6c10900bd776516302d896d09b7946aaf53b70297ec46c5f75eb0d76b212998R124","createdAt":"2021-06-11T03:12:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-859230253","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1OTIzNjk4Mw==","author":{"login":"smax48"},"authorAssociation":"NONE","body":"@Spikhalskiy , thanks for confirming this!\r\nAsync execution is always a problem for things like tracing where you need to preserve the single context across multiple threads... \r\nFor example, in Armeria framework they use their own request context to store the trace context - so it correctly flows across threads.\r\nFor temporal, I think that if \"normal\" workflow context propagation (`ContextPropagator` interface) works correctly with async (I do hope, but need to check that) - that can be potentially used in the open tracing scenario. \r\nBut it might be an easier way - you definitely know this better! :) \r\n","createdAt":"2021-06-11T03:32:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-859236983","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1OTI2OTM5Mw==","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"A little bit more context after an initial investigation.\r\n\r\nIf workflow triggers an async activity using method reference like this:\r\n``` \r\nAsync.function(activity::activity, input).get();\r\n```\r\nInterceptors and propagation actually work correctly. Here is the unit test verifying it:\r\nhttps://github.com/Spikhalskiy/java-sdk/commit/59d620a2c319659c447e72a6617a74b4cf20c8e9#diff-b6c10900bd776516302d896d09b7946aaf53b70297ec46c5f75eb0d76b212998R146\r\n\r\nBut if workflow triggers the activity asynchronously using lambda:\r\n```\r\nAsync.function(() -> activity.activity(input)).get();\r\n```\r\nthe context is lost and interceptors don't see the context of the original thread. Here is a failing unit test verifying it:\r\nhttps://github.com/Spikhalskiy/java-sdk/commit/59d620a2c319659c447e72a6617a74b4cf20c8e9#diff-b6c10900bd776516302d896d09b7946aaf53b70297ec46c5f75eb0d76b212998R186\r\n\r\nThe difference comes from how differently these two cases are processed inside `AsyncInternal`:\r\n```\r\n  private static <R> Promise<R> execute(boolean async, Functions.Func<R> func) {\r\n    if (async) {\r\n      initAsyncInvocation();\r\n      try {\r\n        func.apply();\r\n        return getAsyncInvocationResult();\r\n      } catch (Exception e) {\r\n        return Workflow.newFailedPromise(Workflow.wrap(e));\r\n      } finally {\r\n        closeAsyncInvocation();\r\n      }\r\n    } else {\r\n      CompletablePromise<R> result = Workflow.newPromise();\r\n      WorkflowInternal.newThread(\r\n              false,\r\n              () -> {\r\n                try {\r\n                  result.complete(func.apply());\r\n                } catch (Exception e) {\r\n                  result.completeExceptionally(Workflow.wrap(e));\r\n                }\r\n              })\r\n          .start();\r\n      return result;\r\n    }\r\n  }\r\n```\r\n\r\nMethod reference-based implementation (correctly working) goes to the first branch (`async = true`) because temporal code is able to understand that it's a call to a temporal activity stub and we are able to execute it asynchronously.\r\nThe second (incorrectly working) execution goes to the second branch (`async = false`) and actually schedules the execution of the lambda on a new thread because it's just a piece of code. And as the result, it doesn't have thread locals of the original thread or the state of tracer scope.\r\nIt's not an OpenTracing bug, it probably affects any Interceptors and potentially ContextPropagators or something more don't work correctly in this case too, while I didn't verify it.\r\n\r\n@smax48 You can use this information to make a workaround. If you trigger activity asynchronously using method reference - you will be fine. This is not a trivial bug and fixing it properly will take some time.","createdAt":"2021-06-11T05:09:19Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-859269393","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1OTQwMjE0NQ==","author":{"login":"smax48"},"authorAssociation":"NONE","body":"@Spikhalskiy , thanks a lot, that's a very interesting info! \r\n\r\nBut the problem is that we are using kotlin... :-D \r\n\r\nSo for some reason even when I use this invocation: `Async.function(activity::activity, input).get();` , I get `async`  false inside `execute()`  (`toSerializedLambda` returns null) !!! \r\n\r\nSeems like I need to dig a bit deeper into how kotlin compiler works in this case.\r\nI will update you when I find more info.\r\n\r\n**UPDATE**\r\nLooks like kotlin compiler happily ignores the fact that functional interface extends Serializable... So the resulting object doesn't have all those expected methods, checked in `toSerializedLambda` ...\r\n\r\nThe quickest workaround I found is to use a Java wrapper method like this:\r\n```\r\n    public static Promise<String> activity1Function(SpanContextPropagationTest.TestActivity activity) {\r\n        return Async.function(activity::activity1);\r\n    }\r\n```\r\n\r\nKotlin test works when I call the activity this way!\r\n\r\nThanks again!\r\n\r\n**PS**\r\nI am not sure what Temporal does with serialized lamdas, but having better support for Kotlin would be much appreciated :-) \r\n\r\n","createdAt":"2021-06-11T08:56:09Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-859402145","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1OTU5NTU4Mg==","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"@smax48 This is a known problem. Kotlin generates \"method references\" differently than java, as the result Temporal code responsible for detecting a method reference to a temporal stub can't do its job correctly. I made an attempt to tackle this problem in this PR: https://github.com/temporalio/sdk-java/pull/319 bit I never got a chance to finalize it to any decent state.\r\nPlease use the workarounds for now while these two issues are not resolved.\r\n\r\nUPDATE\r\nhttps://github.com/temporalio/sdk-java/pull/319 with the Kotlin/Async fix is polished is merged into master.\r\n","createdAt":"2021-06-11T13:49:03Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-859595582","viewerDidAuthor":false},{"id":"IC_kwDODN12PM43GrFZ","author":{"login":"smax48"},"authorAssociation":"NONE","body":"Hi @Spikhalskiy , what is the current state of this bug? I can see that Kotlin async support is added in v1.3.x - is there anything else that left to finish this? I briefly tested with 1.3, kotlin method references work OK now - but kotlin lambdas still don't. Is that what you plan to fix before 1.4 ? :)\r\n\r\nBasically, `Async.function(activity::activity1).get()` works OK\r\n`Async.function { activity.activity1() }.get()` - doesn't work \r\n\r\nThanks!\r\n\r\nUPDATE\r\nI re-read this thread, looks like you mentioned that lambdas do not work correctly even with Java...","createdAt":"2021-09-22T00:57:46Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-924496217","viewerDidAuthor":false},{"id":"IC_kwDODN12PM43Gruo","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"@smax48 Hey. Didn't work on it. Not because it's hard, the hard part is done as a part of #557, just didn't have hands for it. We can fix it in 1.4 scope if it affects you.","createdAt":"2021-09-22T01:04:47Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-924498856","viewerDidAuthor":false},{"id":"IC_kwDODN12PM43Gr2C","author":{"login":"smax48"},"authorAssociation":"NONE","body":"Working method references with Kotlin are OK for us at the moment, so no rush :) \r\nThanks!","createdAt":"2021-09-22T01:06:00Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-924499330","viewerDidAuthor":false},{"id":"IC_kwDODN12PM45cCa2","author":{"login":"smax48"},"authorAssociation":"NONE","body":"Some update on this issue - it seems that the span context is NOT propagated into child workflows when they are started asynchronously this way in kotlin:\r\n```\r\n        Async.procedure(childWorkflow::method, request)\r\n        // Wait for child to start\r\n        Workflow.getWorkflowExecution(childWorkflow).get()\r\n```\r\nIn this case I have a fully separate trace for the child workflow which is very inconvenient...\r\n\r\nNot sure if this is related to kotlin or something has changed in the trace propagation logic with child workflows (as it worked at some (long) time ago)\r\n","createdAt":"2021-11-08T23:02:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-963651254","viewerDidAuthor":false},{"id":"IC_kwDODN12PM476hoD","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"> Some update on this issue - it seems that the span context is NOT propagated into child workflows when they are started asynchronously this way in kotlin:\r\n> \r\n> ```\r\n>         Async.procedure(childWorkflow::method, request)\r\n>         // Wait for child to start\r\n>         Workflow.getWorkflowExecution(childWorkflow).get()\r\n> ```\r\n> \r\n> In this case I have a fully separate trace for the child workflow which is very inconvenient...\r\n> \r\n> Not sure if this is related to kotlin or something has changed in the trace propagation logic with child workflows (as it worked at some (long) time ago)\r\n\r\n@smax48\r\nI can't reproduce this.\r\nPlease see tests in https://github.com/Spikhalskiy/java-sdk/commit/da1a4327e5ded29c1cecdf7c4db85725a1dae237\r\nOT context is passing correctly to a child workflow triggered the way you propose in Kotlin. I also tested on kotlin 1.4 and 1.6.","createdAt":"2022-01-04T21:53:05Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-1005197827","viewerDidAuthor":false},{"id":"IC_kwDODN12PM47617V","author":{"login":"smax48"},"authorAssociation":"NONE","body":"@Spikhalskiy - Well, something is very strange... I checked several traces in our production just before Christmas / NY holidays - and they were broken.\r\n\r\nBut when I just randomly checked histories right now - I cannot find a broken one anymore.... All WFs have the full history, including the child WF activities (temporal sdk was not updated over holiday period).\r\n\r\nI think that could be possible because I previously checked those workflows that had some other issues (like big s2s latencies etc) - maybe there was something wrong there...\r\n\r\nI will try to find something today.","createdAt":"2022-01-05T00:36:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-1005280981","viewerDidAuthor":false},{"id":"IC_kwDODN12PM478wig","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"@smax48 I closed this issue because both propagations into stub method references in Kotlin and propagation into async lambdas are fixed now. If you are able to make a reproduction for propagation into child workflows, please feel free to open a new issue with details.","createdAt":"2022-01-05T15:18:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-java/issues/537#issuecomment-1005783200","viewerDidAuthor":false}],"createdAt":"2021-06-11T01:59:52Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzE5ODQx","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":{"number":8,"title":"1.7.0","description":"","dueOn":"2022-01-11T00:00:00Z"},"number":537,"reactionGroups":[],"state":"CLOSED","title":"Open tracing span context not propagated when activity or child workflow invoked asynchronously ","updatedAt":"2022-01-05T15:18:52Z","url":"https://github.com/temporalio/sdk-java/issues/537"}
