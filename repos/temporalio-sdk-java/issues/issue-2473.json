{"assignees":[],"author":{"id":"MDQ6VXNlcjMxNzQxMA==","is_bot":false,"login":"sajkol","name":""},"body":"## Description of problem\nI have a workflow that uses cancellation scopes and a timer to handle expiration, which can be reduced to something like this (using Java SDK):\n```\nvar scope = Workflow.newCancellationScope(() -> {\n    activity.doActivity();\n});\n\nAsync.procedure(() -> {\n    Workflow.sleep(Duration.ofMinutes(5));\n    scope.cancel();\n});\n\nscope.run();\n```\nHowever, when this workflow is canceled during activity execution, it seems that the order in which the pending activity and the timer are canceled is not deterministic, which sometimes causes `NonDeterministicException` when replaying.\n\n## Steps to Reproduce the Problem\nHere's the issue reproduced in a unit test. Test is repeated because the result is random - sometimes the history generated in the replay happens to match the one resulting from initial execution.\n\n```\npackage com.example;\n\nimport io.temporal.activity.ActivityInterface;\nimport io.temporal.activity.ActivityOptions;\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.client.WorkflowOptions;\nimport io.temporal.client.WorkflowStub;\nimport io.temporal.testing.TestWorkflowEnvironment;\nimport io.temporal.testing.WorkflowReplayer;\nimport io.temporal.worker.Worker;\nimport io.temporal.workflow.Async;\nimport io.temporal.workflow.Workflow;\nimport io.temporal.workflow.WorkflowInterface;\nimport io.temporal.workflow.WorkflowMethod;\nimport java.time.Duration;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.RepeatedTest;\n\n@Slf4j\npublic class WorkflowCanceledTimerTest {\n\n    @WorkflowInterface\n    public interface TestWorkflow {\n        @WorkflowMethod\n        void start();\n    }\n\n    @ActivityInterface\n    public interface TestActivity {\n        void doActivity();\n    }\n\n    public static class TestActivityImpl implements TestActivity {\n        @Override\n        public void doActivity() {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    public static class TestWorkflowImpl implements TestWorkflow {\n\n        TestActivity activity = Workflow.newActivityStub(TestActivity.class,\n                ActivityOptions.newBuilder().setScheduleToCloseTimeout(Duration.ofSeconds(60)).build());\n\n        @Override\n        public void start() {\n            var scope = Workflow.newCancellationScope(() -> {\n                activity.doActivity();\n            });\n\n            Async.procedure(() -> {\n                Workflow.sleep(Duration.ofMinutes(5));\n                scope.cancel();\n            });\n\n            scope.run();\n        }\n    }\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    @BeforeEach\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(\"test\");\n        worker.registerWorkflowImplementationTypes(TestWorkflowImpl.class);\n        worker.registerActivitiesImplementations(new TestActivityImpl());\n\n        client = testEnv.getWorkflowClient();\n        testEnv.start();\n    }\n\n    @RepeatedTest(20)\n    void replayCanceledWorkflow() throws Exception {\n        var testWorkflow = client.newWorkflowStub(TestWorkflow.class, WorkflowOptions.newBuilder()\n                .setWorkflowId(\"test-workflow-id\")\n                .setTaskQueue(\"test\")\n                .build());\n\n        WorkflowClient.start(testWorkflow::start);\n\n        var stub = WorkflowStub.fromTyped(testWorkflow);\n        stub.cancel();\n        try {\n            stub.getResult(Void.class);\n        } catch (Exception e) {\n            // ignore; just blocking to make sure workflow is actually finished\n        }\n\n        var history = client.fetchHistory(\"test-workflow-id\");\n        WorkflowReplayer.replayWorkflowExecution(history, worker);\n    }\n}\n\n```\n\nThe two history variants that this generates are:\n```\n1.\tEVENT_TYPE_WORKFLOW_EXECUTION_STARTED\n2.\tEVENT_TYPE_WORKFLOW_TASK_SCHEDULED\n3.\tEVENT_TYPE_WORKFLOW_TASK_STARTED\n4.\tEVENT_TYPE_WORKFLOW_TASK_COMPLETED\n5.\tEVENT_TYPE_ACTIVITY_TASK_SCHEDULED\n6.\tEVENT_TYPE_TIMER_STARTED\n7.\tEVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED\n8.\tEVENT_TYPE_WORKFLOW_TASK_SCHEDULED\n9.\tEVENT_TYPE_WORKFLOW_TASK_STARTED\n10.\tEVENT_TYPE_WORKFLOW_TASK_COMPLETED\n11.\tEVENT_TYPE_TIMER_CANCELED\n12.\tEVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED\n13.\tEVENT_TYPE_WORKFLOW_EXECUTION_CANCELED\n```\n\n```\n1.\tEVENT_TYPE_WORKFLOW_EXECUTION_STARTED\n2.\tEVENT_TYPE_WORKFLOW_TASK_SCHEDULED\n3.\tEVENT_TYPE_WORKFLOW_TASK_STARTED\n4.\tEVENT_TYPE_WORKFLOW_TASK_COMPLETED\n5.\tEVENT_TYPE_ACTIVITY_TASK_SCHEDULED\n6.\tEVENT_TYPE_TIMER_STARTED\n7.\tEVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED\n8.\tEVENT_TYPE_WORKFLOW_TASK_SCHEDULED\n9.\tEVENT_TYPE_WORKFLOW_TASK_STARTED\n10.\tEVENT_TYPE_WORKFLOW_TASK_COMPLETED\n11.\tEVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED\n12.\tEVENT_TYPE_TIMER_CANCELED\n13.\tEVENT_TYPE_WORKFLOW_EXECUTION_CANCELED\n```\n\nNote events 11 and 12 which are swapped between runs.\n\n## Specifications\n\n  - Temporal server version: 1.27.1\n  - Java SDK version 1.28.4\n","closedAt":"2025-05-09T18:09:05Z","comments":[{"id":"IC_kwDODN12PM6mCRm1","author":{"login":"sajkol"},"authorAssociation":"NONE","body":"For this particular case a workaround is possible by moving the async procedure inside the cancellation scope:\n```\nvar scope = Workflow.newCancellationScope(s -> {\n    Async.procedure(() -> {\n        Workflow.sleep(Duration.ofMinutes(5));\n        s.cancel();\n    });\n\n    activity.doActivity();\n});\n\nscope.run();\n```\nThis results in the timer being consistently canceled before the activity. But it's very likely that there are other cases where mixing cancelation scopes causes non-determinism due to the same underlying issue.","createdAt":"2025-04-08T08:15:07Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2473#issuecomment-2785614261","viewerDidAuthor":false},{"id":"IC_kwDODN12PM6q6vNP","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Thanks for filing this! confirmed this is an SDK issue due to the SDK iterating over a `HashSet` which is not deterministic. Due to some backwards compatibility concerns this fix won't be enabled until 2 minor releases.","createdAt":"2025-05-09T18:12:47Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2473#issuecomment-2867524431","viewerDidAuthor":false}],"createdAt":"2025-04-07T12:22:46Z","labels":[],"milestone":null,"number":2473,"reactionGroups":[],"state":"CLOSED","title":"Cancellation scopes and async procedures are canceled in non-deterministic order when workflow is canceled","updatedAt":"2025-05-09T18:12:49Z","url":"https://github.com/temporalio/sdk-java/issues/2473"}
