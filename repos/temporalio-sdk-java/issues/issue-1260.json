{"assignees":[],"author":{"id":"MDQ6VXNlcjEwODc0MQ==","is_bot":false,"login":"robzienert","name":"Rob Zienert"},"body":"## Expected Behavior\r\nI would expect that when using `Workflow.getMetricScope().gauge(\"foo\")` within a long-lived workflow execution, only a single worker would report this metric.\r\n\r\n## Actual Behavior\r\nIf the workflow that emits a gauge is scheduled across multiple nodes, then each node is emitting a gauge value but all nodes except the latest one to report gauge are continuing to report outdated gauge values.\r\n\r\nIt's possible that this is an issue in [spectator](https://github.com/Netflix/spectator). If that is indeed the case, it would be great if the Java SDK could add a listener interface around workflow scheduling (e.g. being able to to listen for when workflows stop running on a worker) so we can evict metric gauges from the registry.\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n  1. Define a gauge, set a value in a `Workflow.await`\r\n  1. Reschedule the workflow to a different worker\r\n\r\n## Specifications\r\n\r\n  - Version: 1.12.0\r\n  - Platform: 1.16.2 \r\n","closedAt":"2022-06-14T02:48:59Z","comments":[{"id":"IC_kwDODN12PM5E0l0v","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"We don't really implement metrics. The gauge that you access is just a standard direct micrometer gauge.\r\n\r\n> If the workflow that emits a gauge is scheduled across multiple nodes, then each node is emitting a gauge value but all nodes except the latest one to report gauge are continuing to report outdated gauge values.\r\n\r\nThis does sound like the correct behavior of a gauge. Each of these nodes has its own gauge and it's reporting its node's last value.\r\nWhat is a typical example of a gauge? It's an amount of available ram for example. Each node emits its own metric. Or for Temporal workers, an example of a gauge is the number of available executor threads. This gauge is also host-specific.\r\n\r\n> I would expect that when using Workflow.getMetricScope().gauge(\"foo\") within a long-lived workflow execution, only a single worker would report this metric.\r\n\r\nIt's not expected behavior. If workflow moves to another worker, that worker will be reporting its own gauge with the same name that is created for that worker.\r\nThis gauge is not some magic Temporal Workflow aware Gauge. It's a standard gauge in this host's metrics set. The only additional functionality that we have in JavaSDK is deduping metrics during replay. https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java#L946\r\n\r\n> I would expect that when using Workflow.getMetricScope().gauge(\"foo\") within a long-lived workflow execution, only a single worker would report this metric.\r\n\r\nThe text of this issue looks like you are emitting a unique gauge for each workflow. This is a bad idea and an antipattern. You will kill your metric system if you have any decent amount of workflows. You will also get a memory leak in tally / java-sdk. See https://github.com/temporalio/sdk-java/blob/37a0e463fae2312882b5c946f423a0dbf85f9666/temporal-sdk/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L52\r\nThe set of metrics should be static and limited per worker / JVM process, not per workflow.\r\n\r\nYou should approach these gauges as a per-worker construct.\r\n\r\nI never heard about global gauges that synchronize value across nodes, it's not how metric systems work to my knowledge. \r\nIn Prometheus (let's say) metrics are collected per reporting process, including gauges. Temporal has no intention to go into redesigning this part, it's way too far from our business. If you want to aggregate/process the gauges values across worker nodes - you need to write your own logic/query for your metric system.","createdAt":"2022-06-14T02:22:02Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1260#issuecomment-1154637103","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5E0pD6","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"Described behavior is aligned with expected behavior of a worker gauge. \r\n`Workflow.getMetricScope().gauge()` returns a gauge of a current WORKER. The described behavior is aligned with the normal behavior of a host metric's gauge.\r\n`Workflow.getMetricScope().gauge()` doesn't return a gauge isolated to a specific workflow. This abstraction doesn't exist and it's not a goal of this method. ","createdAt":"2022-06-14T02:48:59Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1260#issuecomment-1154650362","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5E0qSW","author":{"login":"Spikhalskiy"},"authorAssociation":"CONTRIBUTOR","body":"@robzienert feel free to reach out to me on the community Slack to discuss it if you disagree and it looks off.","createdAt":"2022-06-14T02:59:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1260#issuecomment-1154655382","viewerDidAuthor":false}],"createdAt":"2022-06-13T23:41:34Z","labels":[{"id":"MDU6TGFiZWwzMTgwNzE1ODU0","name":"invalid","description":"This doesn't seem right","color":"e4e669"},{"id":"LA_kwDODN12PM7NRayD","name":"wontfix","description":"This will not be worked on","color":"BFD4F2"}],"milestone":null,"number":1260,"reactionGroups":[],"state":"CLOSED","title":"Multiple workers reporting workflow gauges","updatedAt":"2022-06-14T03:09:18Z","url":"https://github.com/temporalio/sdk-java/issues/1260"}
