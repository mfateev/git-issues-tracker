{"assignees":[{"id":"MDQ6VXNlcjIwNTA0MDQ5","login":"Quinn-With-Two-Ns","name":"Quinn Klassen","databaseId":0}],"author":{"id":"MDQ6VXNlcjE2MTY5NzMy","is_bot":false,"login":"osialr","name":"Ryan Osial"},"body":"**Is your feature request related to a problem? Please describe.**\r\nHi there :wave:!\r\n\r\nAfter #1614, users must put `applicationContext.start()` in unit tests and main methods.  Invoking `start()` is not idiomatic Spring Boot and leads to confusion when workers haven't started. (#1648).  Even Spring Boot's [Sample Application](https://spring.io/guides/gs/spring-boot/) does not use `start()`\r\n\r\n**Describe the solution you'd like**\r\nUse Spring Boot's `ApplicationReadyEvent` instead of Spring's `ContextStartedEvent`.  \r\n\r\nAs described in [Application Events and Listeners](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners), _An ApplicationReadyEvent is sent after any application and command-line runners have been called._  \r\n\r\nThis represents the same application state as when `SpringApplication.run()` has returned and where users are instructed to manually add a call `start()`.\r\n\r\nAdditionally, using `ApplicationReadyEvent` removes the need for every test to contain the boilerplate \r\n```java\r\n  @Autowired ConfigurableApplicationContext applicationContext;\r\n\r\n  @BeforeEach\r\n  void setUp() {\r\n    applicationContext.start();\r\n  }\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n* Put big bold text at the top of the README calling out this unusual requirement of a spring-boot library.\r\n* Detect when the user should have put in a call `.start()` and emit a warning.\r\n\r\n**Additional context**\r\n\r\nI have a PR ready to submit if the feature is approved.","closedAt":"2023-10-11T14:47:13Z","comments":[{"id":"IC_kwDODN12PM5jhpes","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Looking at this issue on the Spring Boot github https://github.com/spring-projects/spring-boot/issues/35936 I think your right that the current approach is not correct.\r\n\r\nIs `ApplicationReadyEvent` the idiomatic Spring Boot way? I looked at the Spring Boot included http servers and did not see it being used there. From the description it sounds too late in the lifecyle to be starting the workers.\r\n\r\n>This represents the same application state as when SpringApplication.run() has returned and where users are instructed to manually add a call start().\r\n\r\nCan you point me towards the docs that suggest this?","createdAt":"2023-08-08T14:46:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1837#issuecomment-1669765036","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5jj2Bb","author":{"login":"osialr"},"authorAssociation":"NONE","body":"> Is ApplicationReadyEvent the idiomatic Spring Boot way? I looked at the Spring Boot included http servers and did not see it being used there. From the description it sounds too late in the lifecyle to be starting the workers. \r\n\r\nI suggested `ApplicationReadyEvent` to as closely preserve the existing behavior.  It may not be the right phase over something like `ApplicationStartedEvent`.\r\n\r\nOne example in spring-boot that uses `ApplicationReadyEvent` is [BackgroundPreinitializer](https://github.com/spring-projects/spring-boot/blob/647b20bb30ebef0f428129390470c53470736422/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L84-L91).  It starts a thread after `ApplicationEnvironmentPreparedEvent` then at `ApplicationReadyEvent` waits for the the initialization to finish if it hasn't already.\r\n\r\n>> This represents the same application state as when SpringApplication.run() has returned and where users are instructed to manually add a call start().\r\n\r\n> Can you point me towards the docs that suggest this?\r\n\r\nIn the docs for [ApplicationReadyEvent](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/event/ApplicationReadyEvent.html) \r\n_Event published as late as conceivably possible to indicate that the application is ready to service requests._\r\n\r\nThere is also a comment in [spring-boot#33935](https://github.com/spring-projects/spring-boot/issues/33935#issuecomment-1400247823):\r\n _The ApplicationReadyEvent is published to indicate within the application that it is now ready to service requests. This readiness should include all of your application's own components which should have got ready during bean initialization or as application or command-line runners. Once this event has been published and all listeners are aware that servicing of requests may now begin, the AvailabilityChangeEvent is published to make this readiness visible externally so that requests are routed to the application._\r\n\r\nI ran an empty `spring-boot-starter` project with some event handlers and debug logging. The filtered output is\r\n\r\n```\r\ncom.example.springboot.Application       : Invoking SpringApplication::run\r\ncom.example.springboot.Application       : Starting Application using Java 17.0.8 with PID 730127\r\ncom.example.springboot.Application       : Started Application in 0.779 seconds (process running for 1.237)\r\ncom.example.springboot.Application       : Received ApplicationStartedEvent\r\no.s.b.a.ApplicationAvailabilityBean      : Application availability state LivenessState changed to CORRECT\r\ncom.example.springboot.Application       : Received AvailabilityChangeEvent\r\ncom.example.springboot.Application       : Received ApplicationReadyEvent\r\no.s.b.a.ApplicationAvailabilityBean      : Application availability state ReadinessState changed to ACCEPTING_TRAFFIC\r\ncom.example.springboot.Application       : Received AvailabilityChangeEvent\r\ncom.example.springboot.Application       : SpringApplication::run has completed.  Invoking ConfigurableApplicationContext::start\r\ncom.example.springboot.Application       : Received ContextStartedEvent\r\ncom.example.springboot.Application       : ConfigurableApplicationContext::start has completed\r\n```\r\n\r\nWhether `ApplicationReadyEvent` or `ApplicationStartedEvent` is better depends on whether the application LivenessState should be updated before or after the connection has been attempted.\r\n","createdAt":"2023-08-08T21:35:49Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1837#issuecomment-1670340699","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5jrWp9","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"My concern with [ApplicationReadyEvent](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/event/ApplicationReadyEvent.html) is this part \r\n\r\n```\r\nThe ApplicationReadyEvent is published to indicate within the application that it is now ready to service requests.\r\n```\r\n\r\nSince workers service requests I believe they should be started before this event. Looking at the spring integration with http servers, like tomcat, it looks like they don't listen for either of these events, they just assume people will use sprint bean lifecycles to make sure there beans start before the server if there is a dependency. Perhaps temporal workers autostart should work the same.","createdAt":"2023-08-09T23:24:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1837#issuecomment-1672309373","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5jxiOP","author":{"login":"osialr"},"authorAssociation":"NONE","body":"There's upsides and downsides to invoking `workferFactory.start()` within a bean lifecycle instead of on a application event.  \r\n\r\n\r\nThe upside is that it's fail-fast and the application will quit if on connection failure.  The downside is that there are cases where I want the web servlet to start up even when temporal connection fails.  The main one is the [`/health` endpoint](https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/#health)) plus custom Health Indicators to monitor system state. \r\n\r\nIf the application aborts at startup then that I have to dig through the logs instead of using the health endpoint to see what's going wrong.  Additionally, external monitoring tools expect to have a health check endpoint.  A good connection at startup could always enter a bad state later.\r\n\r\nSo if you were to go that route, I'd make aborting a configuration option, something like `continue-on-failure: true/false`.  Where the two states are\r\n1) When `continue-on-failure` is false, call `workerFactory.start()` in a spring-bean initialization and allow exceptions to propagate.\r\n2) When `continue-on-failure` is true:,  call workerFactory.start() with a try/catch that only logs.\r\n\r\nRegardless of the decisions in this ticket, adding a [HealthIndicator](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/actuate/health/HealthIndicator.html) to this repo would be helpful.\r\n\r\n\r\nI couldn't deduce why there's a deferred startup, the Starter goes all the way back to the initial project commit. If the goal was to delay start to allow external configurations, the code could be modified to like [WebMvcConfigurer](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html).\r\n\r\nSomething like:\r\n```java\r\nWorkerFactory createWorkerFactory(Collection<WorkerFactoryConfigurer> configurer) {\r\n  WorkerFactory workerFactory = ...; // existing codebase\r\n  \r\n  // Apply custom configuration\r\n  for (var c : configurer) {\r\n     c.doConfig(workerFactory);\r\n  }\r\n  \r\n  // Start factory, no more configuration.\r\n  try {\r\n     workerFactaory.start();\r\n  } catch (Exception e) {\r\n    if (!config.continueOnFailure) {\r\n      throw e;\r\n    }\r\n    LOG.warn(\"Failed to start temporal\", e);\r\n  }\r\n\r\n  return workerFactory;\r\n}\r\n```\r\n\r\nSorry for the long post if you were simply debating `ApplicationReadyEvent` vs `ApplicationStartedEvent` :sweat_smile: ","createdAt":"2023-08-10T21:14:54Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1837#issuecomment-1673929615","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5jxlGH","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"No I appreciate the long response.\r\n\r\n I was debating `ApplicationReadyEvent` vs `ApplicationStartedEvent` vs using bean lifecycle. I think another benefit of using bean lifecycles is if a users has beans they want to start after the worker starts that would be easy to setup. That being said I think the inverse (beans start before workers) is more common and all options support that.\r\n \r\n Yeah adding some sort of `HealthIndicator` for temporal spring is reasonable, could you open a separate ticket for that?","createdAt":"2023-08-10T21:25:57Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1837#issuecomment-1673941383","viewerDidAuthor":false},{"id":"IC_kwDODN12PM5kFkFK","author":{"login":"osialr"},"authorAssociation":"NONE","body":"> another benefit of using bean lifecycles is if a users has beans they want to start after the worker starts that would be easy to setup\r\n\r\nTrue, the event system is kind of a kludge; there's an implicit bound.\r\n\r\nBut with current spring-boot library deferring `.start()` until an event, I can add more workers dynamically like in the [base example](https://docs.temporal.io/dev-guide/java/foundations#run-a-dev-worker)\r\n\r\n```java\r\n    WorkerFactory factory = WorkerFactory.newInstance(client);\r\n    Worker yourWorker = factory.newWorker(\"your_task_queue\");\r\n\r\n    // Register Workflow\r\n    // and/or register Activities\r\n\r\n    factory.start();\r\n```\r\n\r\nwith\r\n```java\r\n@Configuration\r\npublic class CustomWorkerConfig {\r\n   @AutoWired\r\n   FactoryWorker factoryWorker;\r\n\r\n   @PostConstruct\r\n   void addMyWorker() {\r\n     var worker = factoryWorker.newWorker(\"other_task_queue\");\r\n    // Register Workflow\r\n    // and/or register Activities\r\n   }\r\n}\r\n```\r\n\r\nI needed this capability because I am implementing the host specific task queue like in the [File Processing](https://github.com/temporalio/samples-java/blob/main/core/src/main/java/io/temporal/samples/fileprocessing/FileProcessingWorker.java) example.\r\n\r\nIf the WorkerFactory is started at the time it becomes a bean, then the above wouldn't work.  I'm unsure if there is a lifecycle phase that can call `start()` and have the bean available to others.\r\n\r\n(Also, I opened #1839 about health indicators.)","createdAt":"2023-08-15T15:53:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-java/issues/1837#issuecomment-1679180106","viewerDidAuthor":false}],"createdAt":"2023-08-07T20:33:29Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzE5ODQ0","name":"enhancement","description":"User experience","color":"a2eeef"}],"milestone":null,"number":1837,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":3}}],"state":"CLOSED","title":"Use Spring Boot ApplicationReadyEvent to start workers","updatedAt":"2023-10-11T14:47:14Z","url":"https://github.com/temporalio/sdk-java/issues/1837"}
