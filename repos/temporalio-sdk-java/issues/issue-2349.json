{"assignees":[],"author":{"id":"MDQ6VXNlcjUxNzY4Mw==","is_bot":false,"login":"Sushisource","name":"Spencer Judge"},"body":"## Expected Behavior\r\nLocal activities should be kept in the queue if a thread can't be allocated to run them\r\n\r\n## Actual Behavior\r\nSilent lock up\r\n\r\n## Steps to Reproduce the Problem\r\n1. When a local activity task was taken off the LocalActivitySlotSupplierQueue in #processQueue [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L79-L102), it was passed to the afterReservedCallback [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L97)\r\n2. This callback is set up [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivityWorker.java#L94-L96) in LocalActivityWorker, where it forwards each task to the PollTaskExecutor#process method [defined here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/PollTaskExecutor.java#L98-L118)\r\n3. That method calls ThreadPoolExecutor#execute [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/PollTaskExecutor.java#L101), which [may spin up a new thread](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html#execute-java.lang.Runnable-)\r\n4. The creation up of that thread failed (see [0]), which thankfully our JVM deployment seems to always log (since I don't believe this comes from the Temporal SDK)\r\nWe suspect that this is due to the process running out of memory used for allocating thread stacks\r\n5. That call to ThreadPoolExecutor#execute raises a java.lang.OutOfMemoryError, which unwinds back up the call stack and ends up back in #processQueue. The line where the callback is applied is only guarded by a catch block for InterruptedException, so the exception unwinds out of the #processQueue call, which is the \"root\" runnable of the thread inside the queueThreadService started [here ](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L106C10-L106C28)(where the thread \"service\" is a single-thread threadpool, initialized [here](https://github.com/temporalio/sdk-java/blob/53a8af7ec44b262fdd00efa6358893f5e2e7a13c/temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivitySlotSupplierQueue.java#L75-L76))\r\n6. No uncaught exception handler is installed on the queueThreadService, and no log is emitted from any SDK code when this happens. Instead, the local activity task queue stops processing any tasks that go into it, and the overall local activity worker machinery deadlocks. The activity and workflow workers remain functional and keep processing work. The process continues in this half-deadlocked state, without crashing early (which we'd strongly prefer over the current behavior).\r\n\r\n[0] except a single pair of log lines:\r\n```\r\n[warning][os,thread      ] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 2040k, guardsize: 0k, detached.\r\n[warning][os,thread      ] Failed to start the native thread for java.lang.Thread \"Local Activity Executor taskQueue=\"...\", namespace=\"...\": ...\"\r\n```\r\n\r\n","closedAt":"2025-01-17T22:58:59Z","comments":[],"createdAt":"2024-12-17T18:50:05Z","labels":[],"milestone":null,"number":2349,"reactionGroups":[],"state":"CLOSED","title":"Failure to allocate thread can lock up local activities","updatedAt":"2025-01-17T22:58:59Z","url":"https://github.com/temporalio/sdk-java/issues/2349"}
