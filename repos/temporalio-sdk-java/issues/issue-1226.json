{"assignees":[{"id":"MDQ6VXNlcjUzMjEwOA==","login":"Spikhalskiy","name":"Dmitry Spikhalsky","databaseId":0}],"author":{"id":"MDQ6VXNlcjI5NjI2MjQ=","is_bot":false,"login":"riomus","name":"Roman Bartusiak"},"body":"We have some tests that are checking the correctness of integration between Kafka and our workflow implementation. In 1.8.1 we had to disable to time-skipping for them (that is ok as we have some async actions that are executed by Kafka listeners so temporal should not play with time). When upgraded to 1.11.0 those tests stopped working as it seems time skipping is used even though we are explicitly disabling it. By inspecting diagnostics i can see that workflow is timing out immediately with the event that happens 315359999 seconds after the last event (so explicit disabling of time-skipping seems to be ignored) \r\n\r\n# Expected Behavior\r\n\r\nWhen running a test environment with disabled time-skipping, time should not be magically incremented by the test environment.\r\n\r\n\r\n## Actual Behavior\r\n\r\nThe temporal test environment is using time skipping even though it is disabled.\r\n\r\n\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n```\r\nimport io.temporal.client.WorkflowClient\r\nimport io.temporal.client.WorkflowOptions\r\nimport io.temporal.testing.TestEnvironmentOptions\r\nimport io.temporal.testing.TestWorkflowEnvironment\r\nimport io.temporal.workflow.SignalMethod\r\nimport io.temporal.workflow.Workflow\r\nimport io.temporal.workflow.WorkflowInterface\r\nimport io.temporal.workflow.WorkflowMethod\r\nimport org.junit.Assert\r\nimport java.time.Duration\r\nimport java.util.concurrent.CompletableFuture\r\n\r\nobject SignaledWorkflowImlTest {\r\n    @JvmStatic\r\n    fun main(args: Array<String>) {\r\n        testSignal()\r\n    }\r\n\r\n    fun testSignal() {\r\n        val testEnvironment =\r\n            TestWorkflowEnvironment.newInstance(TestEnvironmentOptions.newBuilder().setUseTimeskipping(false).build())\r\n\r\n        // Creates a worker that polls tasks from the service owned by the testEnvironment.\r\n        val worker = testEnvironment.newWorker(\"default\")\r\n        worker.registerWorkflowImplementationTypes(SignaledWorkflowImpl::class.java)\r\n        testEnvironment.start()\r\n\r\n        // Creates a WorkflowClient that interacts with the server owned by the testEnvironment.\r\n        val client = testEnvironment.workflowClient\r\n        val workflow = client.newWorkflowStub(SignaledWorkflow::class.java,\r\n            WorkflowOptions.newBuilder().setTaskQueue(\"default\").setWorkflowRunTimeout(Duration.ofDays(1))\r\n                .setWorkflowTaskTimeout(\r\n                    Duration.ofDays(1)).setWorkflowExecutionTimeout(Duration.ofDays(1)).build())\r\n\r\n        // Starts a workflow execution\r\n        val result: CompletableFuture<String> = WorkflowClient.execute<String, String>({ input: String ->\r\n            workflow.workflow1(input)\r\n        }, \"input1\")\r\n\r\n        // The sleep forwards the service clock for 65 minutes without blocking.\r\n        // This ensures that the signal is sent after the one hour sleep in the workflow code.\r\n        workflow.processSignal(\"signalInput\")\r\n\r\n        // Blocks until workflow is complete. Workflow sleep forwards clock for one hour and\r\n        // this call returns almost immediately.\r\n        val resultValue: String = result.get()\r\n        println(\"got result $resultValue\")\r\n        Assert.assertEquals(\"signalInput-input1\", resultValue)\r\n\r\n        // Closes workers and releases in-memory service.\r\n        testEnvironment.close()\r\n    }\r\n\r\n    @WorkflowInterface\r\n    internal interface SignaledWorkflow {\r\n        @WorkflowMethod\r\n        fun workflow1(input: String): String\r\n\r\n        @SignalMethod\r\n        fun processSignal(input: String)\r\n    }\r\n\r\n    class SignaledWorkflowImpl : SignaledWorkflow {\r\n        private var signalInput: String? = null\r\n        override fun workflow1(input: String): String {\r\n            Workflow.sleep(Duration.ofMinutes(1))\r\n            Workflow.await { signalInput != null }\r\n            return \"$signalInput-$input\"\r\n        }\r\n\r\n        override fun processSignal(input: String) {\r\n            signalInput = input\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWith Java SDK 1.8.1 that code takes 1minute to run (as expected) with 1.11.0 it ends immediately because time-skipping is used while it was disabled explicitly (the same behaviour is in 1.8.1 with enabled time-skipping) \r\n## Specifications\r\n\r\n  - Version: 1.11.0\r\n  - Platform: Arch Linux, Adoptium Java 17\r\n","closedAt":"2022-05-18T07:43:55Z","comments":[{"id":"IC_kwDODN12PM5DVZBU","author":{"login":"riomus"},"authorAssociation":"NONE","body":"I see it was already fixed: https://github.com/temporalio/sdk-java/issues/1219#issuecomment-1128893187","createdAt":"2022-05-18T07:43:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/1226#issuecomment-1129680980","viewerDidAuthor":false}],"createdAt":"2022-05-18T07:36:57Z","labels":[{"id":"MDU6TGFiZWwxNjIyNzE5ODQx","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":{"number":14,"title":"1.12.0","description":"","dueOn":"2022-05-19T00:00:00Z"},"number":1226,"reactionGroups":[],"state":"CLOSED","title":"Disabling time skipping in 1.11.0 is not working?","updatedAt":"2022-05-18T20:54:21Z","url":"https://github.com/temporalio/sdk-java/issues/1226"}
