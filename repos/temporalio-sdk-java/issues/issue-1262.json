{"assignees":[{"id":"MDQ6VXNlcjUzMjEwOA==","login":"Spikhalskiy","name":"Dmitry Spikhalsky","databaseId":0}],"author":{"id":"MDQ6VXNlcjUzMjEwOA==","is_bot":false,"login":"Spikhalskiy","name":"Dmitry Spikhalsky"},"body":"There are user reports pointing to workflows stuck on waiting for local activity results while activity is not actually in progress judging by the thread dump.\r\n\r\nWorkflow method stuck with stack dump:\r\n\r\n```\r\n\"workflow-method-571893c0-821b-30e3-a437-80ce798dff42-1e8ec9fd-6426-4fd0-bc6d-8604beb6375d\" #54994 prio=5 os_prio=0 cpu=1.70ms elapsed=559.87s tid=0x00007fa6a4004450 nid=0x58ac waiting on condition  [0x00007fa6e1ddf000]\r\n   java.lang.Thread.State: WAITING (parking)\r\n\tat jdk.internal.misc.Unsafe.park(java.base@11.0.15/Native Method)\r\n\t- parking to wait for  <0x0000000773341a78> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\r\n\tat java.util.concurrent.locks.LockSupport.park(java.base@11.0.15/LockSupport.java:194)\r\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(java.base@11.0.15/AbstractQueuedSynchronizer.java:2081)\r\n\tat io.temporal.internal.sync.WorkflowThreadContext.yield(WorkflowThreadContext.java:89)\r\n\tat io.temporal.internal.sync.WorkflowThreadImpl.yield(WorkflowThreadImpl.java:412)\r\n\tat io.temporal.internal.sync.WorkflowThread.await(WorkflowThread.java:45)\r\n\tat io.temporal.internal.sync.CompletablePromiseImpl.getImpl(CompletablePromiseImpl.java:84)\r\n\tat io.temporal.internal.sync.CompletablePromiseImpl.get(CompletablePromiseImpl.java:74)\r\n\tat io.temporal.internal.sync.ActivityStubBase.execute(ActivityStubBase.java:44)\r\n\tat io.temporal.internal.sync.LocalActivityStubImpl.execute(LocalActivityStubImpl.java:29)\r\n\tat io.temporal.internal.sync.LocalActivityInvocationHandler.lambda$getActivityFunc$0(LocalActivityInvocationHandler.java:72)\r\n\tat io.temporal.internal.sync.LocalActivityInvocationHandler$$Lambda$1955/0x00000008012df440.apply(Unknown Source)\r\n\tat io.temporal.internal.sync.ActivityInvocationHandlerBase.invoke(ActivityInvocationHandlerBase.java:70)\r\n\tat com.sun.proxy.$Proxy128.publishPayload(Unknown Source)\r\n```\r\n\r\nHistory doesn't contain a marker for \"publishPayload\" local activity. History does contain workflow task completion with other local activity markers that were supposed to be executed before the activity in question.\r\nThread dump doesn't show \"publishPayload\" local activity currently in progress.\r\n\r\n## Root cause analysis\r\n\r\nIf Worklfow Task contains a sequence of Local Activitiues that don't fit into Workflow Task Timeout (10s by default, limited to 8s to accommodate network and other latencies), Temporal SDK performs a Workflow Task Heartbeat. It closes the workflow task and immediately opens a new one if there is an outstanding work to be done.\r\n\r\nNow consider a scenario: \r\nWorkflow task executes a sequence of local activities synchronously one by one. Execution of the whole chain of local activities doesn't fit into one Workflow Task. The last event loop (workflow code unblocking by the SDK) that fits before the heartbeat schedules a new local activity. \r\n\r\nBecause of a `break` here: https://github.com/temporalio/sdk-java/blob/5079086e065adc64aa3d17e505482785f0f51dfe/temporal-sdk/src/main/java/io/temporal/internal/replay/ReplayWorkflowRunTaskHandler.java#L284\r\nthis local activity command will never be taken by the state machines and accounted for in the outstanding local activities counter.\r\n\r\nThis leads to a counter of outstanding local activities to be 0, while there are outstanding local activities, we just didn't fetch them because of the mentioned `break`. As the result, Instead of performing a heartbeat, we close the workflow task, which leads to a stuck workflow.\r\n\r\n## Reproduction\r\n\r\nThe problem is tough to reproduce. To make it happen, Workflow Task Heartbeat Timeout should happen DURING execution of workflow code (during eventLoop call) and this execution should schedule a local activity and this local activity should be the only outstanding local activity.\r\n\r\nReproduction uses Thread.sleep inside workflow code (should never be used in production code) to increase the chances of hitting the expiration of workflow task heartbeat during execution of workflow code.\r\n\r\nThis test reproduces the problem reliably:\r\nhttps://github.com/temporalio/sdk-java/pull/1295/files#diff-4de8883f4907196541556af22f075c6f22cb0c7b2eb0622d3d7be45417d82243R43\r\n\r\n## Context\r\n\r\nRelated user posts:\r\nhttps://community.temporal.io/t/workflow-timedout-due-to-activity-blocked-on-feature-get/5136\r\nhttps://community.temporal.io/t/activity-execution-is-stuck-on-blocked-on-feature-get/4247\r\nhttps://community.temporal.io/t/activity-execution-is-blocked-on-blocked-on-feature-get/4391","closedAt":"2022-07-02T00:27:02Z","comments":[],"createdAt":"2022-06-16T01:41:57Z","labels":[],"milestone":{"number":16,"title":"1.14.0","description":"","dueOn":"2022-07-05T00:00:00Z"},"number":1262,"reactionGroups":[],"state":"CLOSED","title":"Workflows stuck on local activity call","updatedAt":"2022-07-04T16:56:45Z","url":"https://github.com/temporalio/sdk-java/issues/1262"}
