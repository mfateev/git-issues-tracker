{"assignees":[],"author":{"id":"MDQ6VXNlcjE0NjM2MjI=","is_bot":false,"login":"mfateev","name":"Maxim Fateev"},"body":"> We've run into this issue when trying to use Spring beans as activity implementations - if they're proxied with transactional support or other Spring stuff, Cadence gets upset.  Would be great to have an @Activity or @ActivityMethod annotation that controlled activity discovery\r\n\r\nSo it looks like having explicit @ActivityInterface and @WorkflowInterface would resolve these issues. It would also help with issue when two activity interfaces extend the same interface.","closedAt":"2020-04-25T16:28:18Z","comments":[{"id":"MDEyOklzc3VlQ29tbWVudDYwNDgwMjkxNw==","author":{"login":"mfateev"},"authorAssociation":"MEMBER","body":"Thinking about it I believe we should solve this with another common requirement to support multiple implementations of the same interface for activities.\r\n\r\nSo it looks like there is a need to implement many to many relationship between interfaces and activity implementations and use only some of the interfaces for workflow->activity implementation calls.\r\n\r\nCurrently an activity interface is used to define two distinct properties of an activity. It defines a strongly typed interface for calling and implementing activities and it defines activity type name string. This string is used to convert calls on the activity stub to ScheduleActivityTask <activityName, input> decision. And then by an activity worker to locate an appropriate implementation. The implementation is found by registering it with the name of activities extracted from the interfaces the implementation implements.\r\n\r\nAs an activity interface by design defines only one activity type for each method it is not possible to have multiple implementations of this interface to share the same activity worker listening on a common task list. Also as currently there is no @ActivityInterface annotation then every interface a class implements becomes an activity interface when registered with an activity worker. This is known problem when the same mixin interface is implemented by multiple activity implementations.\r\n\r\nLet's look at the possible solutions. \r\n\r\n1. Keep one interface to one activity type per method mapping, but introduce @ActivityInterface annotation to mark interfaces that are used to define activity types. \r\nCode example:\r\n\r\n```java\r\npublic interface Base {\r\n    void foo();\r\n}\r\n\r\n// Defines MyActivity1_bar and MyActivity1_foo activity types\r\n@ActivityInterface\r\npublic interface MyActivity1 extends Base {\r\n    void bar();\r\n}\r\n\r\n// Defines MyActivity2_foo activity type\r\n@ActivityInterface\r\npublic interface MyActivity2 extends Base {\r\n}\r\n\r\npublic class MyActivityImpl1 implements MyActivity1, Runnable {\r\n    public void foo() {\r\n        // activity impl\r\n    }\r\n    \r\n    public void bar() {\r\n        // activity impl\r\n    }\r\n    \r\n    public void run() {\r\n        // this is not activity method as Runnable is not an activity\r\n    }\r\n}\r\n\r\npublic class MyActivityImpl2 implements MyActivity2 {\r\n    public void foo() {\r\n        // activity impl\r\n    }\r\n}\r\n\r\nworker.registerActivitiesImplementations(new MyActivityImpl1(), new MyActivityImpl2());\r\n\r\n\r\npublic interface MyWorkflow {\r\n    @WorkflowMethod\r\n    void execute();\r\n}\r\n\r\npublic class MyWorkflowImpl implements MyWorklfow {\r\n    MyActivity1 a = Workflow.newActivityStub(MyActivity1.class);\r\n    MyActivity2 b = Workflow.newActivityStub(MyActivity2.class);\r\n    // The following is going to fail at runtime as Runnable is not annotated with @ActivityInterface\r\n    Runnable invalid = Workflow.newActivityStub(Runnable.class); \r\n    // The following is going to fail at runtime as Base is not annotated with @ActivityInterface\r\n    Base invalid2 = Workflow.newActivityStub(Base.class); \r\n\r\n    // This is fine as both MyActivity1 and MyActivity2 extend Base\r\n    Base[] all = new Base[] {a, b};\r\n    \r\n    public void execute() {\r\n        a.bar(); \r\n        for(Base b:all) {\r\n            b.foo();\r\n        }\r\n    }\r\n}\r\n```","createdAt":"2020-03-27T04:00:46Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/43#issuecomment-604802917","viewerDidAuthor":true},{"id":"MDEyOklzc3VlQ29tbWVudDYwNDgwNTM2Ng==","author":{"login":"mfateev"},"authorAssociation":"MEMBER","body":"2. Another option is to allow multiple implementations of an activity interface and use additional qualifier (which defaults to implementation class name) to distinguish between multiple implementations when necessary. \r\nExample:\r\n\r\n```java\r\n@ActivityInterface\r\npublic interface MyActivity {\r\n    void foo();\r\n}\r\n\r\npublic class MyActivityImpl1 implements MyActivity, Runnable {\r\n    // This is registered as MyActivity_foo activity name with the worker\r\n    // This is exactly the current behavior\r\n    public void foo() {\r\n        // whatever\r\n    }\r\n    // This is not an activity method\r\n    public void run() {\r\n        //whatever\r\n    }\r\n}\r\n\r\n@ActivityImplementation(type=\"MyActivity2\")\r\npublic class MyActivityImpl2 implements MyActivity {\r\n    // This is registered as MyActivity2_foo activity name with the worker\r\n    public void foo() {\r\n        // whatever\r\n    }\r\n\r\n}\r\n\r\nworker.registerActivitiesImplementations(new MyActivityImpl1(), new MyActivityImpl2());\r\n\r\n\r\n@WorkflowInterface\r\npublic interface MyWorkflow {\r\n    @WorkflowMethod\r\n    void execute();\r\n}\r\n\r\npublic class MyWorkflowImpl implements MyWorklfow {\r\n\r\n    MyActivity a1 = Workflow.newActivityStub(MyActivity.class);\r\n    MyActivity a2 = Workflow.newActivityStub(MyActivity.class, \"MyActivity2\");\r\n    // This is not valid as Runnable is not annotated with @ActivityInterface\r\n    Runnable invalid = Workflow.newActivityStub(Runnable.class, \"foo\");\r\n    MyActivity[] activities = new MyActivity[] {a1, a2};\r\n    \r\n    public void execute() {\r\n        a1.foo(); // calls MyActivity_foo\r\n        a2.foo(); // calls MyActivity2_foo\r\n        for(MyActivity a: activities) {\r\n           a.foo();  // Ends up calling MyActivity_foo and MyActivity2_foo activity names.\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nNote that both of the approaches are almost backwards compatible with the current implementation. The only incompatible change is requirement to annotate all activity definition interfaces with @ActivityInterface.","createdAt":"2020-03-27T04:13:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/43#issuecomment-604805366","viewerDidAuthor":true},{"id":"MDEyOklzc3VlQ29tbWVudDYwNjEwMzM0NQ==","author":{"login":"sdwr98"},"authorAssociation":"CONTRIBUTOR","body":"Is there a reason that you're looking solely at putting `@ActivityImplementation` at the class level rather than having an `@ActivityMethod` interface?  I ask because for people coming to Cadence with existing code that they might be refactoring it might be helpful to mark just some of the methods in an interface as an available activity. \r\n\r\nRegarding the qualifier for different activity implementations - we don't have a need for that, but it seems like a good idea for those who do. ","createdAt":"2020-03-30T16:27:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/43#issuecomment-606103345","viewerDidAuthor":false}],"createdAt":"2020-03-26T19:47:57Z","labels":[],"milestone":{"number":1,"title":"Initial Temporal Release","description":"","dueOn":null},"number":43,"reactionGroups":[],"state":"CLOSED","title":"Require explicit annotation for Workflow and Activity interfaces.","updatedAt":"2020-04-25T16:28:18Z","url":"https://github.com/temporalio/sdk-java/issues/43"}
