{"assignees":[],"author":{"id":"MDQ6VXNlcjUzMjEwOA==","is_bot":false,"login":"Spikhalskiy","name":"Dmitry Spikhalsky"},"body":"## Test\r\n```\r\n@WorkflowInterface\r\n  public interface TestWorkflow {\r\n    @WorkflowMethod\r\n    String workflow(String input);\r\n  }\r\n\r\n  @ActivityInterface\r\n  public interface TestActivity {\r\n    String activity(String input);\r\n  }\r\n\r\n  public static class ActivityWorkflow implements TestWorkflow {\r\n    private final TestActivity activity =\r\n        Workflow.newLocalActivityStub(TestActivity.class,\r\n            LocalActivityOptions.newBuilder()\r\n                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\r\n                .build());\r\n\r\n    @Override\r\n    public String workflow(String input) {return activity.activity(input);}\r\n  }\r\n\r\n  private static class ActivityImpl implements TestActivity {\r\n    @Override\r\n    public String activity(String input) {throw new RuntimeException();}\r\n  }\r\n\r\n  @Test\r\n  public void trivialTest() {\r\n    Worker worker = testEnvironment.newWorker(TASK_QUEUE);\r\n    worker.registerWorkflowImplementationTypes(ActivityWorkflow.class);\r\n    worker.registerActivitiesImplementations(new ActivityImpl());\r\n\r\n    testEnvironment.start();\r\n    WorkflowClient client = testEnvironment.getWorkflowClient();\r\n    WorkflowOptions options = WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE)\r\n            .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\r\n            .build();\r\n\r\n    TestWorkflow workflow = client.newWorkflowStub(TestWorkflow.class, options);\r\n    String result = workflow.workflow(UUID.randomUUID().toString());\r\n  }\r\n```\r\n\r\n## Actual Behavior\r\n\r\nExecution of this test completely hangs after temporal client internal exception:\r\n```\r\n0:44:31.648 [Local Activity Executor taskQueue=\"test-workflow\", namespace=\"default\": 1] ERROR i.t.internal.worker.PollerOptions - uncaught exception\r\njava.lang.RuntimeException: Failure processing local activity task.\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.wrapFailure(LocalActivityWorker.java:232)\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.wrapFailure(LocalActivityWorker.java:191)\r\n\tat io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:79)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.IllegalArgumentException: Invalid interval: PT0S\r\n\tat io.temporal.common.RetryOptions$Builder.setMaximumInterval(RetryOptions.java:202)\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handleLocalActivity(LocalActivityWorker.java:264)\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:202)\r\n\tat io.temporal.internal.worker.LocalActivityWorker$TaskHandlerImpl.handle(LocalActivityWorker.java:191)\r\n\tat io.temporal.internal.worker.PollTaskExecutor.lambda$process$0(PollTaskExecutor.java:73)\r\n\t... 3 common frames omitted\r\n```\r\n\r\nWhich after 2 minutes is followed by:\r\n\r\n```\r\n00:46:32.565 [Test worker] WARN  i.t.internal.common.GrpcRetryer - Retrying after failure\r\nio.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: ClientCall was cancelled at or after deadline. []\r\n\tat io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:244)\r\n\tat io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:225)\r\n\tat io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:142)\r\n\tat io.temporal.api.workflowservice.v1.WorkflowServiceGrpc$WorkflowServiceBlockingStub.getWorkflowExecutionHistory(WorkflowServiceGrpc.java:2644)\r\n\tat io.temporal.internal.common.WorkflowExecutionUtils.lambda$getInstanceCloseEvent$1(WorkflowExecutionUtils.java:250)\r\n\tat io.temporal.internal.common.GrpcRetryer.retryWithResult(GrpcRetryer.java:127)\r\n\tat io.temporal.internal.common.WorkflowExecutionUtils.getInstanceCloseEvent(WorkflowExecutionUtils.java:238)\r\n\tat io.temporal.internal.common.WorkflowExecutionUtils.getWorkflowExecutionResult(WorkflowExecutionUtils.java:131)\r\n\tat io.temporal.internal.sync.WorkflowStubImpl.getResult(WorkflowStubImpl.java:346)\r\n\tat io.temporal.internal.sync.WorkflowStubImpl.getResult(WorkflowStubImpl.java:328)\r\n\tat io.temporal.internal.sync.TestWorkflowEnvironmentInternal$TimeLockingInterceptor$TimeLockingWorkflowStub.getResult(TestWorkflowEnvironmentInternal.java:289)\r\n\tat io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.startWorkflow(WorkflowInvocationHandler.java:315)\r\n\tat io.temporal.internal.sync.WorkflowInvocationHandler$SyncWorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:270)\r\n\tat io.temporal.internal.sync.WorkflowInvocationHandler.invoke(WorkflowInvocationHandler.java:178)\r\n\tat com.sun.proxy.$Proxy13.workflow(Unknown Source)\r\n\tat io.temporal.workflow.IncorrectRetryPolicyTest.trivialTest(IncorrectRetryPolicyTest.java:84)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)\r\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)\r\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\r\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\r\n\tat org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)\r\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)\r\n\tat org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)\r\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)\r\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)\r\n\tat org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)\r\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)\r\n\tat org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\r\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:413)\r\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110)\r\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)\r\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)\r\n\tat org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62)\r\n\tat org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\r\n\tat org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)\r\n\tat org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)\r\n\tat com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\r\n\tat org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:119)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)\r\n\tat org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\r\n\tat org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)\r\n\tat org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)\r\n\tat org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414)\r\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\r\n\tat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```\r\n\r\nand the workflow stub call just never returns back.\r\n\r\nThere are two problems here:\r\n1. `maxInterval` defined as optional explicitly in javadoc: \"Maximum interval between retries. Exponential backoff leads to interval increase. This value is the cap of the increase. Default is 100x of initial interval.\" But right now it causes the exception if not specified explicitly.\r\n2. [less important] Not specifying `initialInterval` that defined as \"required\" doesn't cause any exception and is not validated anyhow.\r\n\r\nThis is especially bad because this happens and can be caught only if the activity throws an exception and fails. Without that there is no chance you realize that you supplied an incorrect RetryOptions configuration. And even this exception is cryptic.\r\n\r\nYou maybe would expect that `RetryOptions#validateBuildWithDefaults` solves the problem, but no, it doesn't set maximumInterval explicitly, only `initialInterval` and `backoffCoefficient`.\r\n\r\n## Workaround\r\n\r\nThe only way to make a test like this work is to call an explicit `.setMaximumInterval(Duration.ofMinutes(1))` on every `RetryOptions` you create. Also, you need to explicitly define `RetryOptions` to each workflow or activity, otherwise it will fail internally the same way if case of any exception. \r\n\r\n## Expected Behavior\r\n\r\nRetryOptions.build javadoc states \"Build RetryOptions without performing validation as validation should be done after merging with {@link MethodRetry}.\" Obviously no validation is happening and we get an internal exception at the moment when the retry policy is actually used.\r\n\r\n## Steps to Reproduce the Problem\r\n\r\nYou can find the unit test here: https://github.com/Spikhalskiy/java-sdk/commit/54466378e9dcff6af057c70bd04ef7a08364f4e5\r\n\r\n## Specifications\r\n\r\n  - Version: current master (https://github.com/temporalio/java-sdk/commit/35abfd425c13e86f16b81e26c85c07b17ee3448f) and 0.28.0\r\n","closedAt":"2020-08-23T19:51:21Z","comments":[],"createdAt":"2020-08-12T04:53:03Z","labels":[],"milestone":null,"number":174,"reactionGroups":[],"state":"CLOSED","title":"Not specifying optional maxInterval in RetryOptions causes an cryptic exception if activity fails","updatedAt":"2020-08-23T19:51:21Z","url":"https://github.com/temporalio/sdk-java/issues/174"}
