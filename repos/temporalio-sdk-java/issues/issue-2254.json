{"assignees":[],"author":{"id":"MDQ6VXNlcjM2NzEzMg==","is_bot":false,"login":"ghaskins","name":"Gregory Haskins"},"body":"## Expected Behavior\r\n\r\nThe default RetryOptions or explicitly setting RetryOption.setMaximumAttempts(0) for a local activity is suggested to mean \"unlimited retries\"\r\n\r\n## Actual Behavior\r\n\r\nLocal activities will not retry with default RetryOptions or explicitly setting RetryOptions.setMaxiumAttempts(0).  Instead, they will error out after 0 retry attempts.  This is inconsistent with the documentation, and I believe it is also inconsistent with normal activitiy behavior\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n Run the following code snippet modified from the HelloActivity sample.  The primary changes are\r\n \r\n 1) We now explicitly set RetryOption.setMaximumAttempts(0)\r\n 2) We are calling a LocalActivity instead of a normal activity\r\n 3) The activity intentionally sleeps as to trigger the StartToClose timeout\r\n \r\n If you run this code as is, it will fail after 1 second.  The expected behavior is that it would run indefinitely due to \"unlimited\" retries.\r\n \r\n You can confirm that the general test structure is suited to reproduction by changing the setMaximumAttempts to a positive integer (e.g. 10) and confirming that it does retry N times when it is positive.  However, the default/0 case for unlimited does not seem to work.\r\n \r\n ```\r\n /*\r\n *  Copyright (c) 2020 Temporal Technologies, Inc. All Rights Reserved\r\n *\r\n *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n *\r\n *  Modifications copyright (C) 2017 Uber Technologies, Inc.\r\n *\r\n *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\r\n *  use this file except in compliance with the License. A copy of the License is\r\n *  located at\r\n *\r\n *  http://aws.amazon.com/apache2.0\r\n *\r\n *  or in the \"license\" file accompanying this file. This file is distributed on\r\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\r\n *  express or implied. See the License for the specific language governing\r\n *  permissions and limitations under the License.\r\n */\r\n\r\npackage org.example;\r\n\r\nimport io.temporal.activity.ActivityInterface;\r\nimport io.temporal.activity.ActivityMethod;\r\nimport io.temporal.activity.ActivityOptions;\r\nimport io.temporal.activity.LocalActivityOptions;\r\nimport io.temporal.client.WorkflowClient;\r\nimport io.temporal.client.WorkflowOptions;\r\nimport io.temporal.common.RetryOptions;\r\nimport io.temporal.serviceclient.WorkflowServiceStubs;\r\nimport io.temporal.worker.Worker;\r\nimport io.temporal.worker.WorkerFactory;\r\nimport io.temporal.workflow.Workflow;\r\nimport io.temporal.workflow.WorkflowInterface;\r\nimport io.temporal.workflow.WorkflowMethod;\r\nimport java.time.Duration;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/** Sample Temporal Workflow Definition that executes a single Activity. */\r\npublic class HelloActivity {\r\n\r\n    // Define the task queue name\r\n    static final String TASK_QUEUE = \"HelloActivityTaskQueue\";\r\n\r\n    // Define our workflow unique id\r\n    static final String WORKFLOW_ID = \"HelloActivityWorkflow\";\r\n\r\n    /**\r\n     * The Workflow Definition's Interface must contain one method annotated with @WorkflowMethod.\r\n     *\r\n     * <p>Workflow Definitions should not contain any heavyweight computations, non-deterministic\r\n     * code, network calls, database operations, etc. Those things should be handled by the\r\n     * Activities.\r\n     *\r\n     * @see io.temporal.workflow.WorkflowInterface\r\n     * @see io.temporal.workflow.WorkflowMethod\r\n     */\r\n    @WorkflowInterface\r\n    public interface GreetingWorkflow {\r\n\r\n        /**\r\n         * This is the method that is executed when the Workflow Execution is started. The Workflow\r\n         * Execution completes when this method finishes execution.\r\n         */\r\n        @WorkflowMethod\r\n        String getGreeting(String name);\r\n    }\r\n\r\n    /**\r\n     * This is the Activity Definition's Interface. Activities are building blocks of any Temporal\r\n     * Workflow and contain any business logic that could perform long running computation, network\r\n     * calls, etc.\r\n     *\r\n     * <p>Annotating Activity Definition methods with @ActivityMethod is optional.\r\n     *\r\n     * @see io.temporal.activity.ActivityInterface\r\n     * @see io.temporal.activity.ActivityMethod\r\n     */\r\n    @ActivityInterface\r\n    public interface GreetingActivities {\r\n\r\n        // Define your activity method which can be called during workflow execution\r\n        @ActivityMethod(name = \"greet\")\r\n        String composeGreeting(String greeting, String name);\r\n    }\r\n\r\n    // Define the workflow implementation which implements our getGreeting workflow method.\r\n    public static class GreetingWorkflowImpl implements GreetingWorkflow {\r\n\r\n        /**\r\n         * Define the GreetingActivities stub. Activity stubs are proxies for activity invocations that\r\n         * are executed outside of the workflow thread on the activity worker, that can be on a\r\n         * different host. Temporal is going to dispatch the activity results back to the workflow and\r\n         * unblock the stub as soon as activity is completed on the activity worker.\r\n         *\r\n         * <p>In the {@link ActivityOptions} definition the \"setStartToCloseTimeout\" option sets the\r\n         * overall timeout that our workflow is willing to wait for activity to complete. For this\r\n         * example it is set to 2 seconds.\r\n         */\r\n        private final GreetingActivities activities =\r\n                Workflow.newLocalActivityStub(\r\n                        GreetingActivities.class,\r\n                        LocalActivityOptions.newBuilder()\r\n                                .setStartToCloseTimeout(Duration.ofSeconds(1))\r\n                                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(0).build())\r\n                                .build());\r\n\r\n        @Override\r\n        public String getGreeting(String name) {\r\n            return activities.composeGreeting(\"Hello\", name);\r\n        }\r\n    }\r\n\r\n    /** Simple activity implementation, that concatenates two strings. */\r\n    static class GreetingActivitiesImpl implements GreetingActivities {\r\n        private static final Logger log = LoggerFactory.getLogger(GreetingActivitiesImpl.class);\r\n\r\n        @Override\r\n        public String composeGreeting(String greeting, String name) {\r\n            log.info(\"Composing greeting...\");\r\n\r\n            System.out.println(\"getGreeting\");\r\n            try {\r\n                Thread.sleep(1000000000);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n            return greeting + \" \" + name + \"!\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With our Workflow and Activities defined, we can now start execution. The main method starts\r\n     * the worker and then the workflow.\r\n     */\r\n    public static void main(String[] args) {\r\n\r\n        // Get a Workflow service stub.\r\n        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\r\n\r\n        /*\r\n         * Get a Workflow service client which can be used to start, Signal, and Query Workflow Executions.\r\n         */\r\n        WorkflowClient client = WorkflowClient.newInstance(service);\r\n\r\n        /*\r\n         * Define the workflow factory. It is used to create workflow workers for a specific task queue.\r\n         */\r\n        WorkerFactory factory = WorkerFactory.newInstance(client);\r\n\r\n        /*\r\n         * Define the workflow worker. Workflow workers listen to a defined task queue and process\r\n         * workflows and activities.\r\n         */\r\n        Worker worker = factory.newWorker(TASK_QUEUE);\r\n\r\n        /*\r\n         * Register our workflow implementation with the worker.\r\n         * Workflow implementations must be known to the worker at runtime in\r\n         * order to dispatch workflow tasks.\r\n         */\r\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\r\n\r\n        /*\r\n         * Register our Activity Types with the Worker. Since Activities are stateless and thread-safe,\r\n         * the Activity Type is a shared instance.\r\n         */\r\n        worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\r\n\r\n        /*\r\n         * Start all the workers registered for a specific task queue.\r\n         * The started workers then start polling for workflows and activities.\r\n         */\r\n        factory.start();\r\n\r\n        // Create the workflow client stub. It is used to start our workflow execution.\r\n        GreetingWorkflow workflow =\r\n                client.newWorkflowStub(\r\n                        GreetingWorkflow.class,\r\n                        WorkflowOptions.newBuilder()\r\n                                .setWorkflowId(WORKFLOW_ID)\r\n                                .setTaskQueue(TASK_QUEUE)\r\n                                .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\r\n                                .build());\r\n\r\n        /*\r\n         * Execute our workflow and wait for it to complete. The call to our getGreeting method is\r\n         * synchronous.\r\n         *\r\n         * See {@link io.temporal.samples.hello.HelloSignal} for an example of starting workflow\r\n         * without waiting synchronously for its result.\r\n         */\r\n        String greeting = workflow.getGreeting(\"World\");\r\n\r\n        // Display workflow execution results\r\n        System.out.println(greeting);\r\n        System.exit(0);\r\n    }\r\n}\r\n```\r\n\r\n","closedAt":"2024-10-05T02:54:27Z","comments":[{"id":"IC_kwDODN12PM6OvuKm","author":{"login":"Quinn-With-Two-Ns"},"authorAssociation":"MEMBER","body":"Duplicate of https://github.com/temporalio/sdk-java/issues/1727","createdAt":"2024-10-05T02:54:28Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-java/issues/2254#issuecomment-2394874534","viewerDidAuthor":false}],"createdAt":"2024-10-05T02:47:22Z","labels":[],"milestone":null,"number":2254,"reactionGroups":[],"state":"CLOSED","title":"RetryOption.setMaximumAttempts(0) seems broken for LocalActivities","updatedAt":"2024-10-05T02:54:28Z","url":"https://github.com/temporalio/sdk-java/issues/2254"}
