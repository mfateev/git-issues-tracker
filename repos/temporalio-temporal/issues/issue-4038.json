{"assignees":[],"author":{"id":"MDQ6VXNlcjE1MjMxODc=","is_bot":false,"login":"p4p4","name":"Patrick Klampfl"},"body":"**Is your feature request related to a problem? Please describe.**\nTasks on an activityTaskqueue are randomly fetched by competing activity workers reading from the same queue.\nIn case of subsequent activity calls on different activity workers, caching per pod does not work effectively.\n\nFor Workflow workers, temporal takes care for their cache performance using [sticky exectution](https://docs.temporal.io/tasks#sticky-execution). For activity workers, a similar concept does not exist without custom code.\n\nThe typical workflows that I usually come up with consist of multiple activities which all operate on one entity (e.g. order workflow with activities operating on 1 ecommerce order, user workflow on 1 user, uber driver workflow on 1 driver entity).\n\nThe problem exists in the following scenario\n\n\n* there is a set of activities on the same task queue, all operating on the same entity (e.g. Order)\n* when the state of the entity is not fully owned by the workflow history alone (but instead e.g. in some data base, and temporal is only passing identifiers)\n* and when there’s a node(/pod)-specific entity cache in place (which is probably not the case for smaller services), for example [Ehcache](https://www.ehcache.org/)\n\n**Describe the solution you'd like**\nPartition activity task queues based on workflowId, and assign partitions to specific worker instances (similar to partition assignment within a kafka consumer group).\n\nThe number of partitions could be either fixed, or dynamic. \nA limitation  to have smaller or equal number of workers than queue partitions is not strictly required. If the number of consumer exceeds the number of partitions, it would still improve caching if let’s say only 2 worker instances are competing for tasks on the same partition, as opposed to all worker instances read from all partitions.\n\nSuch a taskQueue feature should be only optional, and not the default, as only systems with a cache would benefit from it. Otherwise, random or round-robin dispatching would lead to a better load-balancing across the workers\n\n**Describe alternatives you've considered**\n set custom task queue names in workflow code using activity options, like in the [fileprocessing](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/fileprocessing) example, which requires to have custom logic in\n\n\n1. worker setup (to start the activity worker on  aunique taskqueue)\n1. workflow code (to set the acivityOptions in workflowmethod dynamically, instead of when creating the Workflow worker)\n1. activity code (to return a unique taskqueue)\n\n","closedAt":null,"comments":[{"id":"IC_kwDODNqesM5liywG","author":{"login":"yiminc"},"authorAssociation":"MEMBER","body":"It seems what you needed is https://docs.temporal.io/workers#worker-session","createdAt":"2023-09-02T01:26:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4038#issuecomment-1703619590","viewerDidAuthor":false}],"createdAt":"2023-03-09T20:27:01Z","labels":[{"id":"MDU6TGFiZWwxNjIxMDMwNzg3","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":4038,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"state":"OPEN","title":"partitioned activity taskQueue based on workflowId, for better caching performance in activity workers","updatedAt":"2023-09-02T01:26:25Z","url":"https://github.com/temporalio/temporal/issues/4038"}
