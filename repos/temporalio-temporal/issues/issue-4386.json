{"assignees":[],"author":{"id":"MDQ6VXNlcjM4NTY0Njg=","is_bot":false,"login":"jsjeannotte","name":""},"body":"**Is your feature request related to a problem? Please describe.**\r\nN/A\r\n\r\n**Describe the solution you'd like**\r\nCurrently, when a duplicate Workflow ID is submitted and the \"Reject Duplicate\" policy is used (default), the SDK raises an exception, which is the desired behavior. It would be useful to add a new reuse policy like \"Queue Duplicate\" where the workflow would be queued (with a new state like \"Queued\"). \r\n\r\n**Describe alternatives you've considered**\r\nThe alternative is to use the \"master-workflow + signal + child-workflow\" recipe, which reduces the observability (i.e. the UI can't be used to see what workflows are queued) and increases the design complexity for simple use-cases.\r\n\r\n**Additional context**\r\nN/A\r\n","closedAt":null,"comments":[{"id":"IC_kwDODNqesM5o1yKR","author":{"login":"samarabbas"},"authorAssociation":"MEMBER","body":"@jsjeannotte can you provide more details about the use case?  You referenced `Reject Duplicate` which guarantees a single execution for that WorkflowID irrespective of the Close Status.  Why can't you use `Allow Duplicate` which would allow a new execution regardless of how the previous execution closed.  Or the scenario you have in mind is to allow queuing up multiple executions simultaneously and then process then sequentially one after another.  \r\nCan you provide more details about the source where the StartWorkflowExecution requests are coming from?","createdAt":"2023-10-12T05:21:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-1758929553","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5o7DCe","author":{"login":"jsjeannotte"},"authorAssociation":"NONE","body":"I can't use `Allow Duplicate` because I don't want to allow duplicates, but instead, want to queue them. We're trying to replicate a feature we leverage on Jenkins and our Spinnaker Pipelines where we can configure our executions to \"Queue concurrent requests\". Without that feature in Temporal, we'll have to build a queueing system ourselves and keep trying to submit new executions until Temporal completes the pending one. \r\n\r\nSo yes, the scenario is exactly that: Allow queuing up multiple executions simultaneously and then process them sequentially one after another.\r\n\r\n> Can you provide more details about the source where the StartWorkflowExecution requests are coming from?\r\nMostly from a user requesting a Workflow execution to be queued. \r\n\r\nSimplified fictional example: Letâ€™s say we have a Temporal Workflow to perform an Offline maintenance on a Database node. Assume we can only have one Database node at a time. Assume the Workflow ID is \"offline-replace-node-database-<name_of_database_here>\". The user makes a request to trigger the Offline maintenance on Database A for Node X. All good. Another user makes a request to trigger an offline maintenance of Node Y on the same Database A. Since we use `Reject Duplicate`, the user gets a warning and the only options are to try again later.\r\n\r\nOptions for us are:\r\n1) Build a queuing system so the second user receives an \"All good, your request was queued\" message instead of a `429` ...\r\n2) Temporal supports `Queue Duplicate` so the second user receives the same \"All good, your request was queued\" response, but we didn't have to build a queuing system :)\r\n\r\n","createdAt":"2023-10-12T20:17:01Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-1760309406","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5o72W8","author":{"login":"samarabbas"},"authorAssociation":"MEMBER","body":"Have you considered modeling this using SignalWithStart?  Basically the idea would be any operation on a Node will be communicated to a workflow through a signal.  SignalWithStart will allow a workflow execution to be created if none exists.  If a workflow execution already exists and there is an operation in flight you just queue up new operation within the workflow itself.  I might actual try and build a sample which showcases this approach.  Basically you are building a serialization mechanism for a resource, and doing it within a single execution is much simpler than spreading it across multiple executions.\r\n\r\nI also want to clarify some confusions around `Allow Duplicate`. \r\n\r\n- If no policy is specified then the default should be `Allow Duplicate` instead of `Reject Duplicate`.  Here are the [docs](https://docs.temporal.io/workflows#workflow-id-reuse-policy).\r\n- Can you clarify what you meant by this comment `because I don't want to allow duplicates, but instead, want to queue them`?  From my understanding of the ticket, you want even a more loose version of `Allow Duplicate` where we allow another execution (queue'ed up) when there is already one in flight.  Where today `Allow Duplicate` only allows the execution when the current one finishes.\r\n\r\n\r\n\r\n","createdAt":"2023-10-12T23:19:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-1760519612","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5pCC5M","author":{"login":"jsjeannotte"},"authorAssociation":"NONE","body":"Yes, I often get confused about `Allow Duplicate` vs `Reject Duplicate` and the fact that `Allow Duplicate` actually means: `Allow Duplicate but fail if that workflow ID is still running`. So yes, it would be more like `Allow Duplicate with Queueing` (loose version of `Allow Duplicate`).\r\n\r\n> Have you considered modeling this using SignalWithStart?\r\nI haven't. Having an example might help me wrap my head around what you are suggesting indeed. \r\n\r\nFor example, you mention that \"you just queue up a new operation ...\" which if I understand correctly means that I still need to build and maintain queues right? \r\n\r\nI also failed to mention that I provide a platform that includes Temporal as a way for our users to write their Ops automation (and more) and so having the simplest interface possible helps them onboard to Temporal (for example, not having to understand Signals or Long Running Workflow with ContinueAsNew for doing very basic things). A lot of their use-cases would be solved by a single activity wrapped in a workflow (since these use-cases are each using a single Jenkins job running a single Python script). \r\n\r\nWe've even build an abstraction that allows them to wrap a single Python function into a Schedule + Workflow + Activity so that for extremely simple use-cases, our users don't even have to understand how Temporal works:\r\n\r\nThe user only writes this:\r\n```\r\nregister_periodic_worker(\r\n        PeriodicWorker(\r\n            name=\"demo_test_hourly_with_arg\",\r\n            interval=timedelta(hours=1),\r\n            start_to_close_timeout=timedelta(minutes=5),\r\n            task=partial(test_callable_with_arg, \"param1\"),\r\n            maximum_attempts=3,\r\n        )\r\n ```\r\n \r\n So having the ability for them to do something like:\r\n ```\r\n register_queued_worker(\r\n        QueuedWorker(\r\n            name=\"demo_test_hourly_with_arg\",\r\n            start_to_close_timeout=timedelta(minutes=5),\r\n            task=partial(test_callable_with_arg, \"param1\"),\r\n            maximum_attempts=3,\r\n        )\r\n```\r\n... which would configure the Workflow Id Reuse Policy to `Allow Duplicate with Queuing`, would be extremely useful.","createdAt":"2023-10-13T20:12:13Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-1762143820","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5pNOlh","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"First thing first: you mention that these Workflows only get started from Schedules. If that's correct, then the easiest way to serialize Workflow execution so that no more than one execution is running at any time would be to simply set that schedule's `policy.overlap` option to `ScheduleOverlapPolicy.BUFFER_ALL` ([see docs](https://python.temporal.io/temporalio.client.ScheduleOverlapPolicy.html#BUFFER_ALL)).\r\n\r\nNow, I understand this might not be sufficient for your needs, as the Schedules API currently provides no way to inspect buffered executions. I opened a feature request for this [here](https://github.com/temporalio/temporal/issues/4984).\r\n\r\nRegarding implementing execution queuing by yourself, I would generally recommend the approach mentioned by Samar (that is a single workflow on which you do `signalWithStart`, and everything happens in that unique workflow, or in child workflows started by that single workflow), but I again understand that this doesn't cover some of your needs.\r\n\r\nInstead, it may make sense to reverse this pattern: start a different workflow execution for each task, then have each workflow do `signalWithStart` on a controller Workflow, and wait for the controller to signal back when its ok to proceed. That obviously means the task workflow need to signal the controller again when it completes. That approach adds some of overhead compared to the single workflow pattern described previously, but that overhead pays off in improved visibility, as queued tasks are now visible in workflow listing.\r\n\r\nFor example, you could have something like this:\r\n\r\n```\r\nWorkflow Id                            Workflow Type                Status\r\n-------------------------------------  ---------------------------  ---------\r\nreplace-database-mydb-20231012-045623  ReplaceNodeDatabaseWorkflow  Completed\r\nreplace-database-mydb-20231012-051276  ReplaceNodeDatabaseWorkflow  Running...\r\nreplace-database-mydb-20231012-051276  ReplaceNodeDatabaseWorkflow  Running...\r\nreplace-database-mydb-20231012-064712  ReplaceNodeDatabaseWorkflow  Running...\r\nreplace-database-mydb                  OneAtATimeCoordinator        Running...\r\n```\r\n\r\nThis also makes it possible for users to interact directly with task Workflows, so they can for example cancel a queued execution, or inspect result/history of a specific completed task. This pattern also works better with Schedules than the previous suggestion.\r\n\r\nTo avoid making it harder for your users to write their own workflows, you may easily extract that coordination work (ie. `signalWithStart` the coordination workflow, wait for a signal from it, and sent it back an unlock signal once the task workflow completes), for example by moving this to a Workflow interceptor, having them wrapping their own workflow code into some wrapper function, or using the dynamic Workflow feature.\r\n\r\nDoes that make sense to you?","createdAt":"2023-10-16T18:40:18Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-1765075297","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5qNQBj","author":{"login":"jsjeannotte"},"authorAssociation":"NONE","body":"> First thing first: you mention that these Workflows only get started from Schedules\r\n\r\nNo. Could be on a Schedule, or could be on-demand.\r\n\r\n> Instead, it may make sense to reverse this pattern: start a different workflow execution for each task, then have each workflow do signalWithStart on a controller Workflow, and wait for the controller to signal back when its ok to proceed. That obviously means the task workflow need to signal the controller again when it completes. That approach adds some of overhead compared to the single workflow pattern described previously, but that overhead pays off in improved visibility, as queued tasks are now visible in workflow listing.\r\n\r\nThat's something I was thinking about this week :) This would indeed help with visibility. And it might be easier to extract as a building block. I'll play with this a bit.\r\n\r\nThanks all! But again, would still appreciate if `Allow Duplicate with Queueing` was supported ;) \r\n","createdAt":"2023-10-26T20:34:50Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-1781858403","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5qNQjl","author":{"login":"jsjeannotte"},"authorAssociation":"NONE","body":"@mjameswh By the way, I'm also from Montreal :)","createdAt":"2023-10-26T20:36:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HOORAY","users":{"totalCount":1}}],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-1781860581","viewerDidAuthor":false},{"id":"IC_kwDODNqesM6hXQbU","author":{"login":"MrTravisB"},"authorAssociation":"NONE","body":"Bump this.\n\nOur use case for this is we are processing messages from users. Like conversations. But processing one messages requires context from all previous messages. So we need each user (or thread) to be processed serially. Would be nice if we could just use the user/thread id as the workflow id and queue to that.\n\nThis needs to work for millions of users (and growing).","createdAt":"2025-03-07T19:19:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-2707228372","viewerDidAuthor":false},{"id":"IC_kwDODNqesM6hmbuW","author":{"login":"paul-paliychuk"},"authorAssociation":"NONE","body":"+1","createdAt":"2025-03-10T16:43:10Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-2711206806","viewerDidAuthor":false},{"id":"IC_kwDODNqesM6369OH","author":{"login":"hippasus"},"authorAssociation":"NONE","body":"+1","createdAt":"2025-07-17T22:18:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-3085685639","viewerDidAuthor":false},{"id":"IC_kwDODNqesM7QkYBq","author":{"login":"savic1231"},"authorAssociation":"NONE","body":"+1","createdAt":"2025-11-06T20:05:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4386#issuecomment-3499196522","viewerDidAuthor":false}],"createdAt":"2023-05-23T22:30:39Z","labels":[{"id":"MDU6TGFiZWwxNjIxMDMwNzg3","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":4386,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":6}}],"state":"OPEN","title":"Add new Workflow Id Reuse Policy: Allow Duplicate with Queueing","updatedAt":"2025-11-06T20:05:38Z","url":"https://github.com/temporalio/temporal/issues/4386"}
