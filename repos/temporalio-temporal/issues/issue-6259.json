{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"**Describe the solution you'd like**\r\n\r\nUsers send encrypted payloads, but server accepts all forms of payloads. Many users want to restrict payloads to only ones they create.\r\n\r\nThis can be done a few ways. To me the most obvious/simplest approach is that we have server/namespace-level public keys from a user (w/ full CRUD API, RSA or ECDSA only at first probably) with an identifier for each key and if any have been configured, use https://pkg.go.dev/go.temporal.io/api/proxy#VisitPayloads via interceptor to ensure that every non-search-attribute payload has a `keyId` payload metadata entry for a known key, and a `signature` payload metadata entry that uses that public key to validate that signature against the `data` contents. Cloud can have its own way to configure server/namespace-level keys.","closedAt":null,"comments":[],"createdAt":"2024-07-10T15:22:51Z","labels":[{"id":"MDU6TGFiZWwxNjIxMDMwNzg3","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":6259,"reactionGroups":[],"state":"OPEN","title":"Support validated/authenticated payloads","updatedAt":"2024-07-10T15:35:18Z","url":"https://github.com/temporalio/temporal/issues/6259"}
