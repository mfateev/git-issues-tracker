{"assignees":[{"id":"MDQ6VXNlcjQ2NjcyMw==","login":"dnr","name":"David Reiss","databaseId":0},{"id":"MDQ6VXNlcjg3NjI4OTM=","login":"wxing1292","name":"Wenquan Xing","databaseId":0}],"author":{"id":"MDQ6VXNlcjg3NjI4OTM=","is_bot":false,"login":"wxing1292","name":"Wenquan Xing"},"body":"**Is your feature request related to a problem? Please describe.**\r\nCurrently, most locks used within Temporal are non reentrant lock, meaning when the same coroutine trying to acquire the same lock twice, deadlock will occur.\r\n\r\n**Describe the solution you'd like**\r\nTemporal service (frontend / matching / history / worker) should investigate existing reentrant lock lib and possibly substitute all non-reentrant to reentrant lock\r\n\r\n**Describe alternatives you've considered**\r\nAnother possibility is to reuse [PriorityMutex](https://github.com/temporalio/temporal/blob/v1.11.0/common/locks/priority_mutex.go#L32) or a variant of lock with timeout to prevent against deadlock situation\r\n\r\nYet another possibility is to fully adopt channels, instead of using locks\r\n","closedAt":"2023-11-11T05:41:38Z","comments":[],"createdAt":"2021-07-22T20:39:50Z","labels":[{"id":"MDU6TGFiZWwxNjIxMDMwNzg3","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1753,"reactionGroups":[],"state":"CLOSED","title":"Investigate possibility to introduce reentrant lock","updatedAt":"2023-11-11T05:41:38Z","url":"https://github.com/temporalio/temporal/issues/1753"}
