{"assignees":[],"author":{"id":"MDQ6VXNlcjY2MzAwNTY=","is_bot":false,"login":"dbarbashov","name":"Daniil Barbashov"},"body":"## Expected Behavior\r\nHave Temporal up and running and have its persistence configured to work with Scylla. When [`child-workflow`](https://github.com/temporalio/samples-go/tree/main/child-workflow) sample is ran twice in a row, child workflow finishes twice.\r\n\r\n## Actual Behavior\r\nTemporal [`child-workflow`](https://github.com/temporalio/samples-go/tree/main/child-workflow) sample couldn't be executed twice in a row. Child workflow only finishes once and is never created second time. Seems like Temporal gets into some loop as it consumes more than 200% cpu (according to Macs' Activity Monitor). Web UI becomes unresponsive.\r\n\r\nAlso there is following error in temporal logs:\r\n```json\r\n{\r\n  \"level\":\"error\",\r\n  \"ts\":\"2022-03-30T17:20:42.225Z\",\r\n  \"msg\":\"Persistent store operation Failure\",\r\n  \"shard-id\":1,\r\n  \"address\":\"127.0.0.1:7234\",\r\n  \"wf-namespace-id\":\"1e16cd9f-097d-4e81-8969-05fce5865111\",\r\n  \"wf-id\":\"ABC-SIMPLE-CHILD-WORKFLOW-ID\",\r\n  \"wf-run-id\":\"e4b9f903-85dc-4b1f-ab83-77e3e321775c\",\r\n  \"store-operation\":\"create-wf-execution\",\r\n  \"error\":\"Encounter shard ownership lost, request range ID: 55456, actual range ID: 0\",\r\n  \"logging-call-at\":\"transaction_impl.go:344\",\r\n  \"stacktrace\":\"go.temporal.io/server/common/log.(*zapLogger).Error\\n\\t/temporal/common/log/zap_logger.go:142\\ngo.temporal.io/server/service/history/workflow.createWorkflowExecutionWithRetry\\n\\t/temporal/service/history/workflow/transaction_impl.go:344\\ngo.temporal.io/server/service/history/workflow.(*ContextImpl).CreateWorkflowExecution\\n\\t/temporal/service/history/workflow/context.go:343\\ngo.temporal.io/server/service/history.(*historyEngineImpl).StartWorkflowExecution\\n\\t/temporal/service/history/historyEngine.go:580\\ngo.temporal.io/server/service/history.(*Handler).StartWorkflowExecution\\n\\t/temporal/service/history/handler.go:527\\ngo.temporal.io/server/api/historyservice/v1._HistoryService_StartWorkflowExecution_Handler.func1\\n\\t/temporal/api/historyservice/v1/service.pb.go:931\\ngo.temporal.io/server/common/rpc/interceptor.(*RateLimitInterceptor).Intercept\\n\\t/temporal/common/rpc/interceptor/rate_limit.go:84\\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1116\\ngo.temporal.io/server/common/rpc/interceptor.(*TelemetryInterceptor).Intercept\\n\\t/temporal/common/rpc/interceptor/telemetry.go:108\\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\\ngo.temporal.io/server/common/metrics.NewServerMetricsTrailerPropagatorInterceptor.func1\\n\\t/temporal/common/metrics/grpc.go:113\\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\\ngo.temporal.io/server/common/metrics.NewServerMetricsContextInjectorInterceptor.func1\\n\\t/temporal/common/metrics/grpc.go:66\\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\\ngo.temporal.io/server/common/rpc.ServiceErrorInterceptor\\n\\t/temporal/common/rpc/grpc.go:131\\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1.1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1119\\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1121\\ngo.temporal.io/server/api/historyservice/v1._HistoryService_StartWorkflowExecution_Handler\\n\\t/temporal/api/historyservice/v1/service.pb.go:933\\ngoogle.golang.org/grpc.(*Server).processUnaryRPC\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1282\\ngoogle.golang.org/grpc.(*Server).handleStream\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:1616\\ngoogle.golang.org/grpc.(*Server).serveStreams.func1.2\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.44.0/server.go:921\"\r\n}\r\n```\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n  1. Clone [reproduction repo](https://github.com/dbarbashov/temporal-scylla-bug-repro)\r\n  1. Follow `Steps to reproduce` section\r\n\r\n## Specifications\r\n\r\n  - Version: 1.15.2\r\n  - Platform: Mac OS Monterey 12.2.1 (M1)\r\n","closedAt":"2022-07-15T17:31:49Z","comments":[{"id":"IC_kwDODNqesM5AtA_7","author":{"login":"v0id3r"},"authorAssociation":"NONE","body":"Some investigation:\r\nWe have https://github.com/temporalio/temporal/blob/6d90f6540ff3813ab83810b788e661ca29436e22/service/history/historyEngine.go#L504\r\nIt tries to create brand new WF:\r\n```\r\ncreateMode := persistence.CreateWorkflowModeBrandNew\r\n\tprevRunID := \"\"\r\n\tprevLastWriteVersion := int64(0)\r\n\terr = weContext.CreateWorkflowExecution(\r\n\t\tnow,\r\n\t\tcreateMode,\r\n\t\tprevRunID,\r\n\t\tprevLastWriteVersion,\r\n\t\tmutableState,\r\n\t\tnewWorkflow,\r\n\t\tnewWorkflowEventsSeq,\r\n\t)\r\n```\r\nand on specific error continues with reuse:\r\n```\r\nif t, ok := err.(*persistence.CurrentWorkflowConditionFailedError); ok {\r\n...\r\ncreateMode = persistence.CreateWorkflowModeWorkflowIDReuse\r\n\t\t\tprevRunID = t.RunID\r\n\t\t\tprevLastWriteVersion = t.LastWriteVersion\r\n\t\t\tif err = e.applyWorkflowIDReusePolicyHelper(\r\n\t\t\t\tt.RequestID,\r\n\t\t\t\tprevRunID,\r\n\t\t\t\tt.State,\r\n\t\t\t\tt.Status,\r\n\t\t\t\texecution,\r\n\t\t\t\tstartRequest.StartRequest.GetWorkflowIdReusePolicy(),\r\n\t\t\t); err != nil {\r\n\t\t\t\treturn nil, err\r\n\t\t\t}\r\n\t\t\terr = weContext.CreateWorkflowExecution(\r\n\t\t\t\tnow,\r\n\t\t\t\tcreateMode,\r\n\t\t\t\tprevRunID,\r\n\t\t\t\tprevLastWriteVersion,\r\n\t\t\t\tmutableState,\r\n\t\t\t\tnewWorkflow,\r\n\t\t\t\tnewWorkflowEventsSeq,\r\n\t\t\t)\r\n...\r\n}\r\n```\r\nOn the first call to `weContext.CreateWorkflowExecution` we have an error, but the one returned is `shard ownership lost`, as https://github.com/temporalio/temporal/blob/6d90f6540ff3813ab83810b788e661ca29436e22/common/persistence/cassandra/errors.go#L59 does sorting by priority and `shard ownership lost` has priority 0:\r\n```\r\nerrors = sortErrors(errors)\r\nreturn errors[0]\r\n```\r\n  \r\nWhy do we have `shard ownership lost` errors at all?\r\nLooks like `conflictIter.MapScan(conflictRecord)` has records with `type = 0` (for some reason) when batch fails.\r\nIn this case call to https://github.com/temporalio/temporal/blob/6d90f6540ff3813ab83810b788e661ca29436e22/common/persistence/cassandra/errors.go#L114 succeeds at https://github.com/temporalio/temporal/blob/6d90f6540ff3813ab83810b788e661ca29436e22/common/persistence/cassandra/errors.go#L124 and appends this kind of error.\r\n\r\nAs a PoC fix worked: \r\n- return a combined error (with the help of e.g. multierr) \r\n```\r\nreturn multierr.Combine(errors...)\r\n```\r\n- assert error type with `errors.As`\r\n```\r\nvar t *persistence.CurrentWorkflowConditionFailedError\r\nif !errors.As(err, &t) {\r\n    return nil, err\r\n}\r\n```\r\nIn this case, everything works fine.\r\n\r\nBut I am still worried about error extraction logic and what side effects this change might introduce.\r\nOne is that any direct error type assertion should be refactored to use `errors.As`, another - including `shard ownership lost` is wrong and some other place might do wrong branching if it detects this type is also present. \r\nDo we need to assert iterator at all in case an error is found in the record itself?","createdAt":"2022-04-01T07:44:06Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"ROCKET","users":{"totalCount":1}}],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1085542395","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5AtBZo","author":{"login":"v0id3r"},"authorAssociation":"NONE","body":"@wxing1292 Looks like you might know better (found your commits touching mentioned parts). Would be great if you can help us!","createdAt":"2022-04-01T07:46:33Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1085544040","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5AtZkw","author":{"login":"wxing1292"},"authorAssociation":"CONTRIBUTOR","body":"> Why do we have `shard ownership lost` errors at all?\r\n\r\ncassandra persistence layer will issue a batch of queries, asserting shard ownership & create mutable states & insert tasks\r\n\r\n>As a PoC fix worked:\r\n>\r\n>return a combined error (with the help of e.g. multierr)\r\n>return multierr.Combine(errors...)\r\n>assert error type with errors.As\r\n>var t *persistence.CurrentWorkflowConditionFailedError\r\n>if !errors.As(err, &t) {\r\n>    return nil, err\r\n>}\r\n>...\r\n>But I am still worried about error extraction logic and what side effects this change might introduce.\r\n>One is that any direct error type assertion should be refactored to use errors.As\r\n\r\nthe reason not to wrap the error ( and parse later ) but to filter & return the most relevant error is to reduce complexity:\r\nif seeing shard ownership lost error, then simply give up the shard\r\nif seeing current workflow condition error, then current run ID mismatch is encountered\r\n...\r\nplus, persistence layer is responsible of parsing the result ( and error ) returned from DB\r\n\r\n\r\n>another - including shard ownership lost is wrong and some other place might do wrong branching if it detects this type is also present.\r\n\r\nwhat do you mean? why returning shard ownership error is wrong?","createdAt":"2022-04-01T09:02:46Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1085643056","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5AtaHV","author":{"login":"wxing1292"},"authorAssociation":"CONTRIBUTOR","body":"currently scylla is not supported by temporal, but if you want to check the compatibility ( using our cassandra driver ), then try [this](https://github.com/temporalio/temporal/blob/master/common/persistence/tests/cassandra_test.go)","createdAt":"2022-04-01T09:04:06Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1085645269","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5AvR_A","author":{"login":"v0id3r"},"authorAssociation":"NONE","body":"> currently scylla is not supported by temporal, but if you want to check the compatibility ( using our cassandra driver ), then try [this](https://github.com/temporalio/temporal/blob/master/common/persistence/tests/cassandra_test.go)\r\n\r\nI found the cause finally.\r\nBatch result rows/iterator has slightly different behaviour:\r\n- Cassandra: returns only 2 rows with values\r\n<img width=\"1177\" alt=\"Снимок экрана 2022-04-01 в 14 13 17\" src=\"https://user-images.githubusercontent.com/1104575/161308745-0cb509c8-4d30-4d8b-92da-edc4b89ace31.png\">\r\n- Scylla: returns 5 rows (as we have 5 queries in batch) with corresponding ones (2 rows) containing values and others - not, all columns nulls. \r\n<img width=\"1168\" alt=\"Снимок экрана 2022-04-01 в 14 13 10\" src=\"https://user-images.githubusercontent.com/1104575/161308765-7d61dd40-8e21-429c-b0af-7babeea044e0.png\">\r\n\r\nNot sure if there are conditions when Cassandra might also return nullable rows.\r\n\r\nAll error extraction helpers rely on `type` column comparing with predefined consts/enum:\r\nhttps://github.com/temporalio/temporal/blob/306eda8049a0ec958c185b7d44716faad6ac0746/common/persistence/cassandra/errors.go#L175-L182\r\n\r\nBy-default scanner uses zero-value for nullable columns and defaults our `type` to `0` (`rowTypeShard`).\r\nhttps://github.com/gocql/gocql/blob/a3457c7b31fe9738d2df4891fc3d6c554711b586/marshal.go#L280-L284\r\n\r\nAnd we have false-erroring about `ownership lost` (as `range_id` is also unmarshalled from `null` to `0` integer)  on all-null rows:\r\nhttps://github.com/temporalio/temporal/blob/306eda8049a0ec958c185b7d44716faad6ac0746/common/persistence/cassandra/errors.go#L184-L185\r\n\r\nI successfully tested it working on both engines if we scan `type` column as nullable (`*int`) and check if it is actually set:\r\n```\r\n// helper to initialize dest for scanning\r\n// it is a feature of gocql to reuse keys in map during scanning already\r\nfunc newConflictRecord() map[string]interface{}{ {\r\n\ttyp := new(int)\r\n\treturn map[string]interface{}{\r\n\t\t\"type\": &typ,\r\n\t}\r\n} \r\n// use nullable type column\r\nrowType, ok := conflictRecord[\"type\"].(*int)\r\nif !ok || rowType == nil { ... }\r\n```   \r\n\r\nWill it be possible to accept such a small change if I prepare PR and verify tests are all fine? \r\nWe don't have any other issues with Scylla and it would help not to maintain fork just for this small fix.","createdAt":"2022-04-01T16:56:39Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1086136256","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5A7pgr","author":{"login":"wxing1292"},"authorAssociation":"CONTRIBUTOR","body":">Will it be possible to accept such a small change if I prepare PR and verify tests are all fine?\r\n\r\nplz send out the PR, thank you for the contribution :)\r\n\r\ncc @yiminc ","createdAt":"2022-04-05T21:29:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":3}}],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1089378347","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5A7xwA","author":{"login":"v0id3r"},"authorAssociation":"NONE","body":"> >Will it be possible to accept such a small change if I prepare PR and verify tests are all fine?\n> \n> \n> \n> plz send out the PR, thank you for the contribution :)\n> \n> \n> \n> cc @yiminc \n\nWill do, thank you for assistance!","createdAt":"2022-04-05T21:56:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":3}}],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1089412096","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5Fmie8","author":{"login":"PenguinToast"},"authorAssociation":"CONTRIBUTOR","body":"We're also running Temporal on top of ScyllaDB, so I went ahead and made a PR since I didn't see one submitted yet for this issue (https://github.com/temporalio/temporal/pull/3027). Happy to close mine if there's already an existing PR out for this.","createdAt":"2022-06-27T18:33:47Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1167730620","viewerDidAuthor":false},{"id":"IC_kwDODNqesM528LzA","author":{"login":"tdeebswihart"},"authorAssociation":"MEMBER","body":"@PenguinToast and @v0id3r: are either of you still running Temporal on top of ScyllaDB? If so I'd like to reach out and talk to y'all about it","createdAt":"2024-03-13T19:26:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"EYES","users":{"totalCount":1}}],"url":"https://github.com/temporalio/temporal/issues/2683#issuecomment-1995488448","viewerDidAuthor":false}],"createdAt":"2022-03-30T17:38:49Z","labels":[{"id":"MDU6TGFiZWwyMDE5ODE3MzQ2","name":"potential-bug","description":"","color":"66b9cc"}],"milestone":null,"number":2683,"reactionGroups":[{"content":"ROCKET","users":{"totalCount":1}},{"content":"EYES","users":{"totalCount":1}}],"state":"CLOSED","title":"Temporal fails to create workflow with the same ID as previous one when Scylla is used as persistence","updatedAt":"2024-03-13T19:26:29Z","url":"https://github.com/temporalio/temporal/issues/2683"}
