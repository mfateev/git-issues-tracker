{"assignees":[],"author":{"id":"MDQ6VXNlcjMzMDM5NDA1","is_bot":false,"login":"andreclaro","name":"André"},"body":"## Expected Behavior\r\nRegister/Update Namespace and other methods should be allow to be performed by connecting to the internal-frontend.\r\n\r\n## Actual Behavior\r\nCurrently several actions can only be done by the Frontend service. It we try to connect to the internal-frontend and perform those actions, such as, Register/Update Namespace, we will get the following error: `unable to find bootstrap container for the given service name`\r\n\r\nAs @MichaelSnowden mentioned: \r\n\r\n```\r\nHi, André. That’s an interesting issue. To me, it looks like this is caused by the fact that the RegisterNamespace workflow service API’s implementation is using a hard-coded service name of primitives.FrontendService instead of fetching the current service name (which may be primitives.InternalFrontendService) [here](https://github.com/temporalio/temporal/blob/f1ef4db6783f11fa29c8f6e11f307959b3b23079/service/frontend/namespace_handler.go#L852) . We register the bootstrap container dynamically based on the service name, but it looks like, when reading it, we always assume that the caller is the frontend service. As you can imagine, there’s a lot of code shared between the two services, but there are some small differences, so it’s easy for bugs like this to crop up. This is all just my deduction from reading the code, but I’m not too familiar with it, since I didn’t write it. In the meantime, might I ask why you want to use the internal frontend service?\r\n\r\nBtw, running all services together locally, I do not see this issue.\r\nThat is likely because the frontend service will write the bootstrap container to the shared registry that the internal frontend service will erroneously look into with the frontend service’s key when you run them together. If you just run the internal frontend service on its own, the bootstrap container won’t be there because the regular frontend service didn’t write it\r\n```\r\n\r\n\r\nFull error logs:\r\n```\r\n{\r\n    \"level\": \"error\",\r\n    \"ts\": \"2023-09-28T15:25:12.080Z\",\r\n    \"msg\": \"service failures\",\r\n    \"operation\": \"RegisterNamespace\",\r\n    \"wf-namespace\": \"test\",\r\n    \"error\": \"unable to find bootstrap container for the given service name\",\r\n    \"logging-call-at\": \"telemetry.go:328\",\r\n    \"stacktrace\": \"go.temporal.io/server/common/log.(*zapLogger).Error\\n\\t/home/builder/temporal/common/log/zap_logger.go:156\\ngo.temporal.io/server/common/rpc/interceptor.(*TelemetryInterceptor).handleError\\n\\t/home/builder/temporal/common/rpc/interceptor/telemetry.go:328\\ngo.temporal.io/server/common/rpc/interceptor.(*TelemetryInterceptor).UnaryIntercept\\n\\t/home/builder/temporal/common/rpc/interceptor/telemetry.go:169\\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1179\\ngo.temporal.io/server/service/frontend.(*RedirectionInterceptor).handleLocalAPIInvocation\\n\\t/home/builder/temporal/service/frontend/redirection_interceptor.go:214\\ngo.temporal.io/server/service/frontend.(*RedirectionInterceptor).Intercept\\n\\t/home/builder/temporal/service/frontend/redirection_interceptor.go:188\\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1179\\ngo.temporal.io/server/common/metrics.NewServerMetricsContextInjectorInterceptor.func1\\n\\t/home/builder/temporal/common/metrics/grpc.go:66\\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1179\\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.UnaryServerInterceptor.func1\\n\\t/go/pkg/mod/go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc@v0.42.0/interceptor.go:344\\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1179\\ngo.temporal.io/server/common/rpc/interceptor.(*NamespaceLogInterceptor).Intercept\\n\\t/home/builder/temporal/common/rpc/interceptor/namespace_logger.go:84\\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1179\\ngo.temporal.io/server/common/rpc/interceptor.(*NamespaceValidatorInterceptor).NamespaceValidateIntercept\\n\\t/home/builder/temporal/common/rpc/interceptor/namespace_validator.go:111\\ngoogle.golang.org/grpc.getChainUnaryHandler.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1179\\ngo.temporal.io/server/common/rpc.ServiceErrorInterceptor\\n\\t/home/builder/temporal/common/rpc/grpc.go:145\\ngoogle.golang.org/grpc.chainUnaryInterceptors.func1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1170\\ngo.temporal.io/api/workflowservice/v1._WorkflowService_RegisterNamespace_Handler\\n\\t/go/pkg/mod/go.temporal.io/api@v1.24.0/workflowservice/v1/service.pb.go:1537\\ngoogle.golang.org/grpc.(*Server).processUnaryRPC\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1360\\ngoogle.golang.org/grpc.(*Server).handleStream\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:1737\\ngoogle.golang.org/grpc.(*Server).serveStreams.func1.1\\n\\t/go/pkg/mod/google.golang.org/grpc@v1.57.0/server.go:982\"\r\n}\r\n```\r\n\r\n## Steps to Reproduce the Problem\r\n\r\n  1. Perform RegisterNamespace or UpdateNamespace to the internal-frontend\r\n \r\n## Specifications\r\n\r\n  - Version: 1.22\r\n  - Platform: Temporal-server \r\n","closedAt":null,"comments":[{"id":"IC_kwDODNqesM5n5lmX","author":{"login":"dnr"},"authorAssociation":"MEMBER","body":"1. Internal-frontend is for use by the server worker role and history/matching roles only. All calls from clients should go through the normal frontend for proper authorization. In particular, there are no internal calls to RegisterNamespace so that just should't be happening.<br><br>I see the migration workflow (running on server worker) uses UpdateNamespace, which would trigger this. Are you using the migration workflow?\r\n\r\n2. It looks this is only a problem if archival is enabled on the namespace.\r\n\r\n","createdAt":"2023-10-02T14:41:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4919#issuecomment-1743149463","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5n6QSN","author":{"login":"MichaelSnowden"},"authorAssociation":"CONTRIBUTOR","body":"> All calls from clients should go through the normal frontend for proper authorization.\r\n\r\nIn this case, I think André read the patch notes [here](https://github.com/temporalio/temporal/releases/tag/v1.20.0) about the internal frontend role and thought that it meant you could use it to bypass auth for admin requests as well. However, it seems like this is something we didn't intend to support because this was originally just for simplifying intern-node auth.\r\n\r\nI think I see two ways we can go about this:\r\n\r\n1. We can support this use case (not sure if we want to, though, as it seems insecure). This would mean making some code changes [here](https://github.com/temporalio/temporal/blob/f1ef4db6783f11fa29c8f6e11f307959b3b23079/service/frontend/namespace_handler.go#L852).\r\n2. We can say that we don't support this use case, and we can help you find another solution, André. \r\n\r\nTo me, this originally looked like a bug because we were propagating the \"wrong\" service name around, but if that's because we have, as a policy, that no one should be calling these APIs on the internal frontend, then it's not a bug. I think we should have a clearer error message, though. Maybe we can do something like check the request metadata to see if calls to the internal-frontend are from another service, and, if not, return an error message? Not as a method of protection, because it could obviously be spoofed, but as a way to detect misuse and inform the user.\r\n\r\nIn addition, it seems like no other nodes are calling RegisterNamespace on the internal-frontend (which makes sense because this is not something I see us automating). However, if we do in the future, it might make sense to fix this service name issue now (separately from the internal-frontend misuse error message change).\r\n\r\nSo, @dnr , I think we should do this:\r\n- Not support this use case (because it's insecure)\r\n- Return a descriptive error message if it looks like someone is calling the internal frontend from a non-internal service (because it might clear up misconceptions earlier)\r\n- Dynamically get the service name instead of using the hard-coded one [here](https://github.com/temporalio/temporal/blob/f1ef4db6783f11fa29c8f6e11f307959b3b23079/service/frontend/namespace_handler.go#L852) (because it would make it possible for this API to be called by other services later, if we decide to do so). Or, add it to a list of APIs which the internal-frontend does not support.\r\n\r\nAlso, @andreclaro , would you mind elaborating on your use case? Why don't you want to use the frontend service here?","createdAt":"2023-10-02T16:20:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4919#issuecomment-1743324301","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5n6aas","author":{"login":"dnr"},"authorAssociation":"MEMBER","body":"The point about the migration workflow using UpdateNamespace means we do need to fix this.\r\n\r\nBut to be clear, external clients must not be making calls to internal-frontend, that must be prevented (with network restrictions or mTLS or both), or else there's no point to it.","createdAt":"2023-10-02T16:45:09Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4919#issuecomment-1743365804","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5n8SJZ","author":{"login":"andreclaro"},"authorAssociation":"NONE","body":"First of all, thank you for the quick response!\r\n\r\nWe are using TLS (mTLS to be enabled later), network policies and we are now enabling authorization. We also have archival enabled for both history and visibility.\r\n\r\nI totally understand that we shouldn't allow external service to access the internal-frontend.\r\n\r\nMy initial idea was to use the internal-frontend for administration tasks whenever required (only accessible by administrators with access to exec to the internal-frontend service), however we are planning to build a service to perform that by getting a JTW token from our authorization service. \r\n\r\nThe other new use case is to use the [temporal-operator](https://github.com/alexandrevilain/temporal-operator) to manage namespaces but it seems that currently this operator does not support JTW token. ","createdAt":"2023-10-02T22:26:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4919#issuecomment-1743856217","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5n8X_W","author":{"login":"dnr"},"authorAssociation":"MEMBER","body":"I see. I don't think we'd go out of our way to break calling internal-frontend with tctl/temporal cli, but it's not what it's intended for, in the same way that you generally wouldn't do RPC calls directly to history or matching services. I'd recommend setting up proper authorization and doing administrative tasks through the regular frontend.","createdAt":"2023-10-02T22:51:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4919#issuecomment-1743880150","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5n8jLo","author":{"login":"andreclaro"},"authorAssociation":"NONE","body":"Yes, that makes sense. What about point 2 (`It looks this is only a problem if archival is enabled on the namespace.`)? Are you going to fix this? thanks!","createdAt":"2023-10-02T23:42:45Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4919#issuecomment-1743925992","viewerDidAuthor":false}],"createdAt":"2023-10-02T09:48:09Z","labels":[{"id":"MDU6TGFiZWwyMDE5ODE3MzQ2","name":"potential-bug","description":"","color":"66b9cc"}],"milestone":null,"number":4919,"reactionGroups":[],"state":"OPEN","title":"Allow Internal-Frontend to Register/Update Namespace (and other methods)","updatedAt":"2023-10-02T23:42:45Z","url":"https://github.com/temporalio/temporal/issues/4919"}
