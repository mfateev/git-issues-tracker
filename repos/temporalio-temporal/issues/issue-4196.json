{"assignees":[{"id":"MDQ6VXNlcjE2NjExODc=","login":"samanbarghi","name":"Saman Barghi","databaseId":0}],"author":{"id":"MDQ6VXNlcjc3NTQxMjA=","is_bot":false,"login":"yycptt","name":"Yichao Yang"},"body":"Currently if entire context timeout will be used to lock the workflow to perform operations. However, if workflow is super busy and workflow can't be locked within the given context timeout, caller side will see a context deadline exceeded error and has no clue why the API call times out.\r\n\r\nWe should return early with a special error type (or maybe just resource exhausted with workflow busy cause?) if workflow can not be locked.\r\n\r\nThen the user latency calculation can also function properly across API calls.","closedAt":"2023-05-23T23:43:07Z","comments":[{"id":"IC_kwDODNqesM5b_otl","author":{"login":"yycptt"},"authorAssociation":"MEMBER","body":"In addition, if the call is a background call (starts by temporal system instead of user), e.g. task processing, there's no reason to block on the workflow lock for too long, which also holds a goroutine in the task scheduler. So if the context says the `caller-type` is `background`, we should use a very low timeout (e.g. 500ms) when grabbing workflow lock.","createdAt":"2023-05-11T06:26:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/4196#issuecomment-1543408485","viewerDidAuthor":false}],"createdAt":"2023-04-20T08:40:04Z","labels":[{"id":"MDU6TGFiZWwxNjIxMDMwNzg3","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":4196,"reactionGroups":[],"state":"CLOSED","title":"Do not let API call timeout if workflow can't be locked","updatedAt":"2023-05-23T23:43:07Z","url":"https://github.com/temporalio/temporal/issues/4196"}
