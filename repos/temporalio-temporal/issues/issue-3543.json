{"assignees":[{"id":"MDQ6VXNlcjg0NDExMDE0","login":"yiminc","name":"Yimin Chen","databaseId":0}],"author":{"id":"MDQ6VXNlcjEzNzY4MjM1","is_bot":false,"login":"nagl-temporal","name":"Nathan Glass"},"body":"**Is your feature request related to a problem? Please describe.**\r\nThe `zap` framework can consume an unbounded amount of memory, and often consumes more memory than it \"needs to\" due to naive use of `sync.Pool`.\r\n\r\nFor context, see [this golang issue](https://github.com/golang/go/issues/23199) for a discussion of best (and worst!) practices around `sync.Pool`. Zap follows the bad practice of [putting variable-sized buffers in its pool](https://github.com/uber-go/zap/issues/1130).\r\n\r\nI've seen this cause bad behavior in temporal when it is frequently logging small lines but infrequently logging large lines. This pattern leads to an unnecessarily large zap buffer pool (in practice, I've seen up to 2.5gb). The golang issue discusses this scenario specifically [here](https://github.com/golang/go/issues/23199#issuecomment-353193866).\r\n\r\n**Describe the solution you'd like**\r\nSee below - it's nothing but alternatives!\r\n\r\n**Describe alternatives you've considered**\r\nThere's a lot we could do about this. Off the top of my head:\r\n* Dedup recent logs with long lines (e.g. ones with stack traces)\r\n* Commit any/several of the suggestions from the golang issue to `zap`:\r\n  * Sometimes don't return large buffers to the pool.\r\n  * Use a tiered pool (small vs. large).\r\n  * Implement a real upper bound on pool size (and don't return buffers over that bound to the pool).","closedAt":null,"comments":[],"createdAt":"2022-10-29T01:02:35Z","labels":[{"id":"MDU6TGFiZWwxNjIxMDMwNzg3","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":3543,"reactionGroups":[],"state":"OPEN","title":"Better memory management for zap logger","updatedAt":"2023-03-03T20:18:05Z","url":"https://github.com/temporalio/temporal/issues/3543"}
