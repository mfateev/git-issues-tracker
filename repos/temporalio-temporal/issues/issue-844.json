{"assignees":[{"id":"MDQ6VXNlcjgyNDg4MDY=","login":"sergeybykov","name":"Sergey Bykov","databaseId":0}],"author":{"id":"MDQ6VXNlcjEzNTE5OTE3","is_bot":false,"login":"randomswdev","name":""},"body":"**Is your feature request related to a problem? Please describe.**\r\nI'm under the impression that the authorization interface requires user to recompile Temporal.io in order to add an implementation.\r\n\r\nhttps://github.com/temporalio/temporal/blob/master/common/authorization/authorizer.go\r\n\r\n**Describe the solution you'd like**\r\nI would like to implement a generic authorizer that loads a plugin using the golang plugin interface. Or a generic authorizer that calls an external Open Policy Agent server.\r\nThis way I can plugin authorization rules wthout having to rebuild the cadence code.\r\n\r\nWhat do you think? I'm available to contribute a merge request if you think it could be a valuable change. I would include i nthe merge request also support for checking the TaskQueue (extending the [Attributes](https://github.com/temporalio/temporal/blob/master/common/authorization/authorizer.go#L41) struct).","closedAt":"2021-04-15T01:57:15Z","comments":[{"id":"MDEyOklzc3VlQ29tbWVudDcwNzk1NzY1MA==","author":{"login":"sergeybykov"},"authorAssociation":"MEMBER","body":"Thank you for your suggestion. Our current thinking is that Go plugins are too fragile to be used as an extensibility mechanism. Instead, we moved forward with server options. Here's an [example](https://github.com/temporalio/temporal/blob/25291a54dc573bbb575a45abc8c54e267f69afd0/cmd/server/main.go#L104) of how we'll support injecting a low level authorization plugin.\r\n\r\nWe consider Authorizer a stop-gap solution until we have a more comprehensive authorization story. A plugin for an Open Policy Agent server is on our radar. If you can contribute code for it, that would definitely be appreciated.\r\n\r\nYour suggestions for extending `Attributes` are valuable as well, as they'll us with defining the full authorization story.","createdAt":"2020-10-13T19:24:26Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-707957650","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcwNzk2OTE5Ng==","author":{"login":"randomswdev"},"authorAssociation":"NONE","body":"> Thank you for your suggestion. Our current thinking is that Go plugins are too fragile to be used as an extensibility mechanism. Instead, we moved forward with server options. Here's an [example](https://github.com/temporalio/temporal/blob/25291a54dc573bbb575a45abc8c54e267f69afd0/cmd/server/main.go#L104) of how we'll support injecting a low level authorization plugin.\r\n> \r\nIf I understand correctly I can leverage a configuration option to “activate” an authorizer compiled into the code (like the NoOpAuthorizer) that connects to an open policy agent.\r\n\r\nI assume that, if temporal is configured with certificates, the ctx passed to the authorized would contain such certificate, so that I can forward this to OPA for checking the identity. Is it correct?\r\n\r\n","createdAt":"2020-10-13T19:48:02Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-707969196","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcwODA1MDEyMg==","author":{"login":"sergeybykov"},"authorAssociation":"MEMBER","body":">If I understand correctly I can leverage a configuration option to “activate” an authorizer compiled into the code (like the NoOpAuthorizer) that connects to an open policy agent.\r\n\r\nCorrect.\r\n\r\n>I assume that, if temporal is configured with certificates, the ctx passed to the authorized would contain such certificate, so that I can forward this to OPA for checking the identity. Is it correct?\r\n\r\nNot yet, but we are working towards that.","createdAt":"2020-10-13T22:46:53Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-708050122","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcwODM3MDY4Ng==","author":{"login":"randomswdev"},"authorAssociation":"NONE","body":"> > I assume that, if temporal is configured with certificates, the ctx passed to the authorized would contain such certificate, so that I can forward this to OPA for checking the identity. Is it correct?\r\n> \r\n> Not yet, but we are working towards that.\r\n\r\nIf needed I can help with this.","createdAt":"2020-10-14T12:32:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-708370686","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcwODYzODQzNg==","author":{"login":"sergeybykov"},"authorAssociation":"MEMBER","body":"That would be great. Let us formulate our plans (soonish), and let's collaborate after that.","createdAt":"2020-10-14T20:20:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-708638436","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDczODMyODgzNQ==","author":{"login":"randomswdev"},"authorAssociation":"NONE","body":"> Not yet, but we are working towards that.\r\n\r\nReviewing yesterday the Authorizer interface with a colleague, we noticed that you added support for passing either the certificate issuer or the JWT token claims to the Authorize. I think this is what you were mentioning in your comment above.\r\n\r\nDo you think it could be a rigth time to start discussing and working on this issue?\r\n\r\nOne additional point we where thinking about yesterday was the possibility to pass the whole request (the req interface) to the authorizer so that it can also authorize based on the content of the request, including for example the queue today but also any other field tomorrow.\r\n\r\nWhat do you think? Do you see any risk in passing the whole request to the Authorizer?","createdAt":"2020-12-03T21:25:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-738328835","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDczODMyOTEwNA==","author":{"login":"randomswdev"},"authorAssociation":"NONE","body":"@dihedron FYI","createdAt":"2020-12-03T21:25:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-738329104","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDczOTA4NDQ3NQ==","author":{"login":"sergeybykov"},"authorAssociation":"MEMBER","body":"@randomswdev Yes, this is a good time to continue the discussion. Sorry about not advertising here all the relevant changes that've been happening recently.\r\n\r\nPersonally, I'm a bit hesitant to add request to `CallTarget`. That would provide full flexibility, but I'm concerned it would make it very ambiguous what authorizer is expected to consider. I think it would be better to include specific fields, such as TaskQueue or WorkflowType, so that data is explicitly structured instead of passing a full request to authorizer. But I'm open to be convinced otherwise.","createdAt":"2020-12-05T00:05:31Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-739084475","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDgxOTk2NjY4Ng==","author":{"login":"sergeybykov"},"authorAssociation":"MEMBER","body":"`Request` was added to `CallTarget` as part of #1432. This can be closed now.","createdAt":"2021-04-15T01:57:15Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HEART","users":{"totalCount":1}}],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-819966686","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDgyMzYyMjA4MA==","author":{"login":"dihedron"},"authorAssociation":"NONE","body":"Cool, thanks a lot.","createdAt":"2021-04-20T21:48:47Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-823622080","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5P5HMs","author":{"login":"nickwilliams-codynamic"},"authorAssociation":"NONE","body":"Apologies for commenting on a year old issue but I was interested in why this was closed. As I understood the original post here was to have an option where authorization evaluation could be external to the temporal server binary. OPA was suggested which I feel is a good choice.\r\n\r\nWas this closed because there was no longer a desire to implement it? Or because there was no activity?\r\n\r\nI'd be keen on having this available from temporal and would be happy to contribute a PR.  From the look of it all that would be needed would be to add a new authorizer implementation which could be selected - something like\r\n\r\n```go\r\nfunc GetAuthorizerFromConfig(config *config.Authorization) (Authorizer, error) {\r\n\r\n\tswitch strings.ToLower(config.Authorizer) {\r\n\tcase \"\":\r\n\t\treturn NewNoopAuthorizer(), nil\r\n\tcase \"default\":\r\n\t\treturn NewDefaultAuthorizer(), nil\r\n\tcase \"opa\":\r\n\t        return NewOpaAuthroizer(config), nil\r\n\t}\r\n\treturn nil, fmt.Errorf(\"unknown authorizer: %s\", config.Authorizer)\r\n}\r\n``` \r\n\r\nWhere the implementation looked something like\r\n\r\n```go\r\nvar resultAllow = Result{Decision: DecisionAllow}\r\nvar resultDeny = Result{Decision: DecisionDeny}\r\n\r\ntype OpaResult struct { \r\n    Allow bool `json:\"allow\"`\r\n}\r\n\r\nfunc (a *opaAuthorizr) Authorize(_ context.Context, claims *Claims, target *CallTarget) (Result, error) {\r\n       policyData := []byte(`{\r\n\t\t\"input\": {\r\n                    // TODO: Serialize claims and target\r\n                }\r\n\t}`)\r\n\r\n        resp, err := http.Put(\"http://opa-endpoint/v1/policy/example1\", \"application/json\", policyData)\r\n        if (err != null) {\r\n            return resultDeny, err\r\n        }\r\n\r\n        defer resp.Body.Close() \r\n        val result OpaResult \r\n        json.NewDecoder(resp.Body).Decode(result)\r\n\r\n       if (result.Allow) {\r\n            return resultAllow, nil\r\n       }\r\n\r\n\treturn resultDeny, nil\r\n}\r\n```","createdAt":"2022-12-07T04:54:05Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-1340371756","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5QF95D","author":{"login":"dnr"},"authorAssociation":"MEMBER","body":"If the implementation is really that simple, I think we'd accept a PR for a built-in OPA authorizer. @sergeybykov ?","createdAt":"2022-12-09T02:05:16Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-1343741507","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5QGFkk","author":{"login":"nickwilliams-codynamic"},"authorAssociation":"NONE","body":"Awesome, thanks @dnr. I'll wait for @sergeybykov to have a look too before starting.\r\n\r\nI don't think it would be much more complicated than the above, the only parts I believe I missed out were:\r\n\r\n- An extra property in `config.Authorization` to allow you to set the OPA endpoint\r\n- A `ClaimMapper` implementation which effectively just passes through the `AuthInfo`\r\n\r\nI believe these two points plus the above POC would allow all authn/authz to be achieved in OPA with whatever requirements a user may have. As an example something like:\r\n\r\n```rego\r\npackage temporal.auth\r\n\r\ndefault allow := false\r\n\r\nallow {\r\n   token.isValid   # Token must be valid\r\n   token.payload.roles[_] = input.CallTarget.Namespace    # User is in a role which matches the namespace being accessed\r\n}\r\n\r\ntoken = { \"isValid\": isValid, \"header\": header, \"payload\": payload } {\r\n     [isValid, header, payload] := io.jwt.decode_verify( input.authInfo.authToken, { \"cert\": jwks, \"iss\": \"xxx\", })\r\n}\r\n```","createdAt":"2022-12-09T02:50:00Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-1343772964","viewerDidAuthor":false},{"id":"IC_kwDODNqesM5QNWXh","author":{"login":"nickwilliams-codynamic"},"authorAssociation":"NONE","body":"@dnr / @sergeybykov - I ended up having an hour or so free over the weekend so decided I would just finish up the OPA implementation. I think this should be pretty close, if it is something you're willing to take onboard that would be great.\r\n\r\nPR: https://github.com/temporalio/temporal/pull/3702\r\n","createdAt":"2022-12-11T22:39:28Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/temporal/issues/844#issuecomment-1345676769","viewerDidAuthor":false}],"createdAt":"2020-10-13T17:18:38Z","labels":[{"id":"MDU6TGFiZWwxNjIxMDMwNzg3","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":844,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"CLOSED","title":"Support for pluggable authorizers","updatedAt":"2022-12-11T22:39:29Z","url":"https://github.com/temporalio/temporal/issues/844"}
