{"assignees":[],"author":{"id":"MDQ6VXNlcjExNDc5MzI5","is_bot":false,"login":"robcao","name":"Robert Cao"},"body":"### What are you really trying to do?\n\n<!-- \nTell us at a high level what you're doing, to avoid XY problem (https://en.wikipedia.org/wiki/XY_problem) \n-->\n\nI have a workflow that continues as new, and also receives signals. We see that sometimes when the workflow tries to continue as new while new signals come in for that workflow, the continue as new output from the workflow does not contain all of the signals\n\n### Describe the bug\n\nThe problem is that the main workflow function is completing before all of the signal handlers run. Admittedly, I am not certain if this is a bug in the SDK or in the workflow implementation, but if it is the latter, this is very unintuitive behavior.\n\nThe problem happens when multiple signals come in when the workflow sends the continue as new command back to the server. \n\nThis causes the workflow to replay after receiving all of the new signals, but wait conditions are being checked after every individual signal handlers runs.\n\nThis can cause the following sequence of events.\n\n- Workflow main function is blocked on a wait condition\n- First signal handler runs\n- Workflow main function is now unblocked, workflow main function runs to completion\n- Second signal handler runs\n  - Because the workflow main function is already completed, the results of this handler will not be included in scenarios like Continue as New\n\n### Minimal Reproduction\n\nI created a repository here with the reproduction steps. There is a README file with instructions.\n\nhttps://github.com/robcao/temporal-dotnet-missing-signal-sample\n\nFor ease of viewing, here is the workflow definition:\n\nWhat appears to be happening is after the first signal handler runs, both of the wait conditions in the main function body are re-evaluated, both evaluate to true, and so the main function body runs before the second signal handler:\n\n```csharp\nawait Workflow.WhenAnyAsync(Workflow.DelayAsync(TimeSpan.FromSeconds(5)), Workflow.WaitConditionAsync(() => Signals.Count > 0));\nawait Workflow.WaitConditionAsync(() => Workflow.AllHandlersFinished);\n```\n\n```csharp\n[Workflow]\npublic class SleepThenReturn\n{\n\tinternal List<string> Signals { get; init; } = new();\n\n\t[WorkflowRun]\n\tpublic async Task<string[]> RunAsync(string[] input)\n\t{\n\t\tif (!string.IsNullOrWhiteSpace(Workflow.Info.ContinuedRunId))\n\t\t{\n\t\t\tWorkflow.Logger.LogInformation(\"Now continuing as new, there are {count} signals.\", input.Length);\n\n\t\t\treturn input;\n\t\t}\n\n\t\tawait Workflow.WhenAnyAsync(Workflow.DelayAsync(TimeSpan.FromSeconds(5)), Workflow.WaitConditionAsync(() => Signals.Count > 0));\n\n\t\tawait Workflow.WaitConditionAsync(() => Workflow.AllHandlersFinished);\n\n\t\tList<string> next = new();\n\n\t\tforeach (string signal in Signals)\n\t\t{\n\t\t\tnext.Add(signal);\n\t\t}\n\n\t\tthrow Workflow.CreateContinueAsNewException<SleepThenReturn>(wf => wf.RunAsync(next.ToArray()));\n\t}\n\n\t[WorkflowSignal]\n\tpublic Task SendSignal(string signal)\n\t{\n\t\tWorkflow.Logger.LogInformation(\"Handling signal input {signal}.\", signal);\n\t\tSignals.Add(signal);\n\t\treturn Task.CompletedTask;\n\t}\n}\n\n```\n\n### Environment/Versions\n\n<!-- Please complete the following information where relevant. -->\n\n- OS and processor: x64 Windows\n- Temporal Version: 1.5.0\n- Are you using Docker or Kubernetes or building Temporal from source? Running directly on Windows\n\n### Additional context\n\n<!-- Add any other context about the problem here. -->\n\nIt seems like what we desire here is for handlers to be marked in progress earlier than they currently are, before the event loop runs, perhaps somewhere here: https://github.com/temporalio/sdk-dotnet/blob/main/src/Temporalio/Worker/WorkflowInstance.cs#L562\n\nAnother user noticed similar behavior to what we see in this Slack thread: https://temporalio.slack.com/archives/C012SHMPDDZ/p1738636421721339\n","closedAt":"2025-03-19T19:10:09Z","comments":[{"id":"IC_kwDOInL6Hs6h3nLm","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"So after digging, this is primarily due to the fact that we run the event loop after every signal which is not the correct behavior. We will be fixing this soon (but will make sure it only applies to new code, not replayed code). It will be mostly reviving #384.","createdAt":"2025-03-11T21:07:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-dotnet/issues/427#issuecomment-2715710182","viewerDidAuthor":false}],"createdAt":"2025-03-11T16:23:06Z","labels":[{"id":"LA_kwDOInL6Hs8AAAABJH7zkA","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":427,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Replay after UnhandledCommand can cause main workflow body to complete before signals are handled","updatedAt":"2025-03-19T19:10:09Z","url":"https://github.com/temporalio/sdk-dotnet/issues/427"}
