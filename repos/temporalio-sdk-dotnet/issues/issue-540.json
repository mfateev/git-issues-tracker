{"assignees":[],"author":{"id":"MDQ6VXNlcjExNDc5MzI5","is_bot":false,"login":"robcao","name":"Robert Cao"},"body":"### What are you really trying to do?\n\n<!-- \nTell us at a high level what you're doing, to avoid XY problem (https://en.wikipedia.org/wiki/XY_problem) \n-->\n\nI am using the Temporal client to start workflows, and noticing that inside the process, there exists an ever growing amount of objects of type `Temporalio.Bridge.CancellationToken` and `CancellationTokenSource+CallbackNode` (which typically represents a callback to be invoked when the token is cancelled)\n\n### Describe the bug\n\nhttps://github.com/temporalio/sdk-dotnet/blob/main/src/Temporalio/Bridge/CancellationToken.cs#L40\n\n`CancellationToken.Register` registers a callback on the token and returns a `CancellationTokenRegistration` that should be disposed of once the callback is no longer needed. It doesn't look like the `CancellationTokenRegistration` is getting disposed of\n\nhttps://github.com/temporalio/sdk-dotnet/blob/main/src/Temporalio/Bridge/Scope.cs#L164\n\n`Temporalio.Bridge.CancellationToken` is not evaluating to true in the conditional `if (v is GCHandle handle)` , and thus the `Temporalio.Bridge.CancellationToken.ReleaseHandle` method is never being invoked\n\nI am not certain if there are any other types that should be getting disposed of that are not\n\n<img width=\"1370\" height=\"522\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/611a3143-5e16-44ad-afe9-2fb4777d1b0d\" />\n\n### Minimal Reproduction\n\n<!-- \nModify our hello world templates to demonstrate:\n\n- TypeScript: https://github.com/temporalio/samples-typescript/tree/main/hello-world\n- Go: https://github.com/temporalio/money-transfer-project-template-go\n- Java: https://github.com/temporalio/money-transfer-project-template-java\n- PHP: https://github.com/temporalio/samples-php#samples\n-->\n\nIn the root directory of this repository, create a new project like this\n\n```\ndotnet new console --output test/MemoryLeak  \n```\n\nUse the following csproj and Program.cs file\n\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <ProjectReference Include=\"..\\..\\src\\Temporalio\\Temporalio.csproj\" />\n  </ItemGroup>\n\n</Project>\n\n```\n\n```csharp\nusing Temporalio.Client;\n\nusing CancellationTokenSource cts = new();\n\nTemporalClient client = await TemporalClient.ConnectAsync(new TemporalClientConnectOptions(\"localhost:7233\")).ConfigureAwait(false);\n\nawait client.WorkflowService.GetSystemInfoAsync(new(), new RpcOptions() { CancellationToken = cts.Token }).ConfigureAwait(false);\n\n```\n\nStart a Temporal server: `temporal server start-dev`\n\nStep through the program and validate that [ReleaseHandle](https://github.com/temporalio/sdk-dotnet/blob/main/src/Temporalio/Bridge/CancellationToken.cs#L56) is not called for the `GetSystemInfo` rpc\n\nIf you inspect the [registrations](https://github.com/dotnet/runtime/blob/1d1bf92fcf43aa6981804dc53c5174445069c9e4/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationTokenSource.cs#L47) on the cancellation token source, you can see that there is still a callback attached as well\n\n### Environment/Versions\n\n<!-- Please complete the following information where relevant. -->\n\n- OS and processor: x64 Windows 11\n- Temporal Version: 1.9.0\n- Are you using Docker or Kubernetes or building Temporal from source? Running Temporal directly on host\n\n### Additional context\n\n<!-- Add any other context about the problem here. -->\n\nI modified the SDK locally like below and validated that this seemed to address the memory leakage (although the implementation may be a bit naive)\n\n```csharp\n// src/Temporalio/Bridge/CancellationToken.cs\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\nnamespace Temporalio.Bridge\n{\n    /// <summary>\n    /// Core-owned cancellation token.\n    /// </summary>\n    internal class CancellationToken : SafeHandle\n    {\n        private CancellationTokenRegistration? cancellationCallback;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"CancellationToken\"/> class.\n        /// </summary>\n        public CancellationToken()\n            : base(IntPtr.Zero, true)\n        {\n            unsafe\n            {\n                Ptr = Interop.Methods.temporal_core_cancellation_token_new();\n                SetHandle((IntPtr)Ptr);\n            }\n        }\n\n        /// <inheritdoc/>\n        public override unsafe bool IsInvalid => Ptr == null;\n\n        /// <summary>\n        /// Gets internal token pointer.\n        /// </summary>\n        internal unsafe Interop.TemporalCoreCancellationToken* Ptr { get; private init; }\n\n        /// <summary>\n        /// Create a core cancellation token from the given cancellation token.\n        /// </summary>\n        /// <param name=\"token\">Threading token.</param>\n        /// <returns>Created cancellation token.</returns>\n        public static CancellationToken FromThreading(System.Threading.CancellationToken token)\n        {\n            var ret = new CancellationToken();\n            ret.cancellationCallback = token.Register(ret.Cancel);\n\n            return ret;\n        }\n\n        /// <summary>\n        /// Cancel this token.\n        /// </summary>\n        public void Cancel()\n        {\n            unsafe\n            {\n                Interop.Methods.temporal_core_cancellation_token_cancel(Ptr);\n            }\n        }\n\n        /// <inheritdoc/>\n        protected override unsafe bool ReleaseHandle()\n        {\n            // I suspect that the callback needs to be unregistered before freeing the core owned cancellation token to prevent any access issues\n            cancellationCallback?.Dispose();\n            Interop.Methods.temporal_core_cancellation_token_free(Ptr);\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// src/Temporalio/Bridge/Scope.cs\n\n/// <inheritdoc />\n        public void Dispose()\n        {\n            foreach (var v in toKeepAlive)\n            {\n                if (v is GCHandle handle)\n                {\n                    handle.Free();\n                }\n                else if (v is CancellationToken cancellationToken)\n                {\n                    cancellationToken.Dispose();\n                }\n            }\n            // This keep alive does nothing obviously, but it's good documentation to understand the\n            // purpose of this separate dispose call\n            GC.KeepAlive(toKeepAlive);\n            GC.SuppressFinalize(this);\n        }\n```","closedAt":"2025-10-27T18:40:37Z","comments":[],"createdAt":"2025-10-17T18:15:43Z","labels":[{"id":"LA_kwDOInL6Hs8AAAABJH7zkA","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":540,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Memory Leak in Temporalio.Bridge.CancellationToken","updatedAt":"2025-10-27T18:40:37Z","url":"https://github.com/temporalio/sdk-dotnet/issues/540"}
