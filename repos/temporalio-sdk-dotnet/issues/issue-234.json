{"assignees":[],"author":{"id":"MDQ6VXNlcjExNDc5MzI5","is_bot":false,"login":"robcao","name":"Robert Cao"},"body":"### What are you really trying to do?\r\n\r\n<!-- \r\nTell us at a high level what you're doing, to avoid XY problem (https://en.wikipedia.org/wiki/XY_problem) \r\n-->\r\n\r\nI'm writing a payload codec that attaches metadata to headers. I am noticing that for some specific workflow failure scenarios around `ApplicationFailureException` with `Details` objects, that under certain circumstances, the instance of the payload object passed to the payload codec is re-used from a previous payload.\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n<!-- If applicable, add screenshots or code blocks to help explain your problem. You can also use [Loom](http://loom.com/) to do short, free video bug reports. -->\r\n\r\nI have a very simple workflow that only contains an activity.\r\n\r\nMy sample activity always throws an `ApplicationFailureException` with a single details payload. My workflow just propagates the same exception and fails.\r\n\r\nI believe there should be four payloads here in this scenario:\r\n\r\n1. The workflow input.\r\n2. The activity input.\r\n3. The activity output (in this case failure details).\r\n4. The workflow output (in this case failure details).\r\n\r\nI am noticing that (what seems to be the same instance of) the payload that is being passed to the payload codec to encode both the failure from the activity, and the failure from the workflow.\r\n\r\nI've created a payload codec implementation in `MetadataExaminingPayloadCodec.cs` that adds a uuid to the `X-My-Metadata` header in the payload metadata during encoding only if a value does not already exist on the payload, and during decoding, reads the value of the `X-My-Metadata` header in the payload metadata.\r\n\r\n### Minimal Reproduction\r\n\r\n<!-- \r\nModify our hello world templates to demonstrate:\r\n\r\n- TypeScript: https://github.com/temporalio/samples-typescript/tree/main/hello-world\r\n- Go: https://github.com/temporalio/money-transfer-project-template-go\r\n- Java: https://github.com/temporalio/money-transfer-project-template-java\r\n- PHP: https://github.com/temporalio/samples-php#samples\r\n-->\r\n\r\nhttps://github.com/robcao/temporal-sdk-dotnet-payload-repro/tree/main\r\n\r\nThe reproduction runs as a NUnit test case for simplicity, and can be run by using the `dotnet test` command.\r\n\r\nThe output of the codec is as below. When trying to encode the payload for the workflow failure details, the payload being passed to the payload codec already has a `X-My-Metadata` header, indicating some sort of re-use.\r\n\r\n```\r\n  Standard Output Messages:\r\n Successfully added metadata 229a20b0-9b33-4053-b4b8-f3471b9cdae9...\r\n Now reading metadata 229a20b0-9b33-4053-b4b8-f3471b9cdae9...\r\n Successfully added metadata d5566faf-ce58-4917-92e5-86250da83fc8...\r\n Now reading metadata d5566faf-ce58-4917-92e5-86250da83fc8...\r\n Successfully added metadata 9fb8cb67-e8ec-41c8-b9b9-71ad6c639b95...\r\n Now reading metadata 9fb8cb67-e8ec-41c8-b9b9-71ad6c639b95...\r\n WARN: tried to add metadata, but metadata already exists with a value of 9fb8cb67-e8ec-41c8-b9b9-71ad6c639b95...\r\n Now reading metadata 9fb8cb67-e8ec-41c8-b9b9-71ad6c639b95...\r\n```\r\n\r\n### Environment/Versions\r\n\r\n<!-- Please complete the following information where relevant. -->\r\n\r\n- OS and processor: Windows 10 Enterprise 10.0.19045 x64\r\n- Temporal Version: Temporal 1.22.5, sdk-dotnet 1.0.0\r\n- Are you using Docker or Kubernetes or building Temporal from source? No\r\n\r\n### Additional context\r\n\r\nSo far, I've only noticed this happening for this specific scenario around failure details, but I'm not sure if it can happen under any other scenarios.\r\n\r\nI looked at the [encryption sample](https://github.com/temporalio/samples-dotnet/blob/main/src/Encryption/Codec/EncryptionCodec.cs), and I see that this implementation is wrapping the original payload as the data of a new payload.\r\n\r\n```\r\n Task.FromResult<IReadOnlyCollection<Payload>>(payloads.Select(p =>\r\n        {\r\n            return new Payload()\r\n            {\r\n                Metadata =\r\n                {\r\n                    [\"encoding\"] = EncodingByteString,\r\n                    [\"encryption-key-id\"] = keyIDByteString,\r\n                },\r\n                // TODO(cretz): Not clear here how to prevent copy\r\n                Data = ByteString.CopyFrom(Encrypt(p.ToByteArray())),\r\n            };\r\n        }).ToList());\r\n```\r\n\r\nHowever, it's unclear in the documentation if this is actually necessary (or why if so).\r\n\r\nThis behavior is kind of strange.\r\n\r\nIf I change the workflow code to the below, the same problem is happening.\r\n\r\n```\r\n\t\t[WorkflowRun]\r\n\t\tpublic async Task<WorkflowOutput> RunAsync(WorkflowInput input)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tawait Temporalio.Workflows.Workflow.ExecuteActivityAsync(\r\n\t\t\t\t\t() => Activities.FailureActivityWithDetails(new ActivityInput()),\r\n\t\t\t\t\tnew()\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tStartToCloseTimeout = TimeSpan.FromMinutes(5),\r\n\t\t\t\t\t}).ConfigureAwait(true);\r\n\t\t\t}\r\n\r\n\t\t\tcatch (ApplicationFailureException)\r\n\t\t\t{\r\n\t\t\t\tthrow new NonRetryableWithDetailsException(new FailureDetails());\r\n\t\t\t}\r\n\r\n\r\n\t\t\treturn new WorkflowOutput();\r\n\t\t}\r\n```\r\n\r\nHowever, if I modify the above code to catch a generic `Exception`, instead of an `ApplicationFailureException`, the payload instance no longer appears to be re-used.\r\n\r\n```\r\n\t\t[WorkflowRun]\r\n\t\tpublic async Task<WorkflowOutput> RunAsync(WorkflowInput input)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tawait Temporalio.Workflows.Workflow.ExecuteActivityAsync(\r\n\t\t\t\t\t() => Activities.FailureActivityWithDetails(new ActivityInput()),\r\n\t\t\t\t\tnew()\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tStartToCloseTimeout = TimeSpan.FromMinutes(5),\r\n\t\t\t\t\t}).ConfigureAwait(true);\r\n\t\t\t}\r\n\r\n\t\t\tcatch (Exception)\r\n\t\t\t{\r\n\t\t\t\tthrow new NonRetryableWithDetailsException(new FailureDetails());\r\n\t\t\t}\r\n\r\n\r\n\t\t\treturn new WorkflowOutput();\r\n\t\t}\r\n```","closedAt":null,"comments":[{"id":"IC_kwDOInL6Hs578xF3","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Your payload codec should not mutate the payload being passed in or try to maintain a reference to it in any way. Rather, you should always create a new payload. I will make a note to make this very clear in the codec documentation.\r\n\r\nYes https://github.com/temporalio/samples-dotnet/blob/main/src/Encryption/Codec/EncryptionCodec.cs works by creating a new payload. We don't clone before every invocation because some invocations may do nothing to the object and that would affect performance unnecessarily. If there was an easy way to \"freeze\" the object just for the life of the call we would.\r\n\r\nArguably we could have wrapped the raw proto payload object in an immutable container/interface, but this is more of an advanced API with certain implementation expectations. We will clarify in the documentation.","createdAt":"2024-04-26T14:39:29Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-dotnet/issues/234#issuecomment-2079527287","viewerDidAuthor":false},{"id":"IC_kwDOInL6Hs579DQq","author":{"login":"robcao"},"authorAssociation":"CONTRIBUTOR","body":"Got it, thank you.\r\n\r\nTo be clear, when you say \"you should always create a new payload\", you do not mean just a deep clone via something like `payload.Clone()`, but rather setting the original payload (allocated into a new byte array) as the data of an outer payload wrapper?\r\n\r\n```\r\nnew Payload()\r\n{\r\n    Data = ByteString.CopyFrom(payload.ToByteArray()),\r\n};\r\n```","createdAt":"2024-04-26T15:18:59Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-dotnet/issues/234#issuecomment-2079601706","viewerDidAuthor":false},{"id":"IC_kwDOInL6Hs579Fc8","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Literally just always creating a new instance of the payload object. How you \"wrap\" or \"convert\" the other one into the payload is up to you. A \"clone\" is probably fine, though I usually recommend against that because you usually do not want all of the previous payload's metadata as your own. Rather usually you want to serialize/wrap the entire other payload into the data of the new one, and do the inverse on decode. But technically all that matters is that no fields in the parameter are mutated or referenced beyond the life of the method.","createdAt":"2024-04-26T15:24:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-dotnet/issues/234#issuecomment-2079610684","viewerDidAuthor":false}],"createdAt":"2024-04-26T14:10:14Z","labels":[{"id":"LA_kwDOInL6Hs8AAAABJH7zkA","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":234,"reactionGroups":[],"state":"OPEN","title":"[Bug] Unexpected reuse of payload instances in payload codec for specific workflow failure scenarios.","updatedAt":"2024-04-26T15:24:26Z","url":"https://github.com/temporalio/sdk-dotnet/issues/234"}
