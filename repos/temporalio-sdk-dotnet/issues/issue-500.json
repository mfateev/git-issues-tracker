{"assignees":[],"author":{"id":"MDQ6VXNlcjIwNjM5Ng==","is_bot":false,"login":"cretz","name":"Chad Retz"},"body":"### Describe the bug\n\nReplication that can be in a test case with access to a `Client`:\n\n```csharp\n    [Workflow]\n    public class CustomFuncWorkflow\n    {\n        private readonly Func<Task> func;\n\n        public CustomFuncWorkflow(Func<Task> func) => this.func = func;\n\n        [WorkflowRun]\n        public Task RunAsync() => func();\n    }\n\n    [Fact]\n    public async Task CauseSegfault()\n    {\n        await RunInWorkflowAsync(\n            new($\"tq-{Guid.NewGuid()}\"),\n            async () => { /*do nothing*/ });\n    }\n\n    private Task<WorkflowHandle> RunInWorkflowAsync(TemporalWorkerOptions workerOptions, Func<Task> func)\n    {\n        workerOptions.AddWorkflow(WorkflowDefinition.Create(\n            typeof(CustomFuncWorkflow),\n            null,\n            _args => new CustomFuncWorkflow(func)));\n        using var worker = new TemporalWorker(Client, workerOptions);\n        return worker.ExecuteAsync(async () =>\n        {\n            var handle = await Client.StartWorkflowAsync(\n                (CustomFuncWorkflow wf) => wf.RunAsync(),\n                new($\"wf-{Guid.NewGuid()}\", workerOptions.TaskQueue!));\n            await handle.GetResultAsync();\n            return handle as WorkflowHandle;\n        });\n    }\n```\n\nCan give different forms of segfault/crash issues from hard crash to something like this:\n```\nFatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\nRepeat 2 times:\n--------------------------------\n   at Temporalio.Bridge.Interop.Methods.worker_poll_workflow_activation(Temporalio.Bridge.Interop.Worker*, Void*, IntPtr)\n--------------------------------\n   at Temporalio.Bridge.Worker+<PollWorkflowActivationAsync>d__15.MoveNext()\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.__Canon ByRef)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.__Canon ByRef)\n   at Temporalio.Bridge.Worker.PollWorkflowActivationAsync()\n   at Temporalio.Worker.WorkflowWorker+<ExecuteAsync>d__10.MoveNext()\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.__Canon ByRef)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.__Canon ByRef)\n   at Temporalio.Worker.WorkflowWorker.ExecuteAsync()\n   at Temporalio.Worker.TemporalWorker+<ExecuteInternalAsync>d__35.MoveNext()\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ExecutionContextCallback(System.Object)\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\n   at System.Runtime.CompilerServices.TaskAwaiter+<>c.<OutputWaitEtwEvents>b__12_0(System.Action, System.Threading.Tasks.Task)\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()\n   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean)\n   at System.Threading.Tasks.Task.RunContinuations(System.Object)\n   at System.Threading.Tasks.Task.FinishContinuations()\n   at System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TrySetResult(System.Threading.Tasks.VoidTaskResult)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetExistingTaskResult(System.Threading.Tasks.Task`1<System.Threading.Tasks.VoidTaskResult>, System.Threading.Tasks.VoidTaskResult)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()\n   at Temporalio.Bridge.Worker+<ValidateAsync>d__13.MoveNext()\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ExecutionContextCallback(System.Object)\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\n   at System.Runtime.CompilerServices.TaskAwaiter+<>c.<OutputWaitEtwEvents>b__12_0(System.Action, System.Threading.Tasks.Task)\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()\n   at System.Threading.Tasks.AwaitTaskContinuation.System.Threading.IThreadPoolWorkItem.Execute()\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()\n   at System.Threading.Thread.StartCallback()\n```\n\nBut strangely if you change `RunInWorkflowAsync` to be `async` and change its `return` to `return await` the problem goes away. There is something in the worker execute code or interop code or something that does not have proper lifetime for the worker `ExecuteAsync` body.","closedAt":"2025-08-07T13:34:48Z","comments":[{"id":"IC_kwDOInL6Hs67gUQa","author":{"login":"maciejdudko"},"authorAssociation":"MEMBER","body":"> using var worker = new TemporalWorker(Client, workerOptions);\n\nThe `using` here causes `Dispose()` to be called at the end of function. If the function is NOT marked async, this will happen before the completion of the future. The crash happens because the future polls workflow activations for a worker that's already been disposed. Switching to `async` fixes the crash because the scope of `using` is then extended until completion of the future and `Dispose()` doesn't get called early.\n\nSo I guess the actual bug is that we continue to poll workflow activations after worker is already disposed.","createdAt":"2025-08-01T21:25:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-dotnet/issues/500#issuecomment-3145810970","viewerDidAuthor":false},{"id":"IC_kwDOInL6Hs67zwFQ","author":{"login":"cretz"},"authorAssociation":"MEMBER","body":"Yes, makes sense and that seems to be the issue, or alternatively the issue is that the worker is being disposed without calling shutdown. It'd be a backwards incompatible change to make the worker async dispose that calls shutdown (and we wouldn't want that anyways probably because we don't want to hang dispose). I wonder if we can lodge some warning to the user when they attempt to dispose a worker that was not shutdown properly. Another approach may be to not make `ExecuteAsync` actually `async`, but instead synchronous that \"captures\" the worker and now doesn't do those dispose things until shutdown.\n\nI imagine it'd be complicated to add \"is disposed\" everywhere, and really even that may not help as we're freeing Rust-side resources I think. May just have to at the bridge worker level disregard anything after dispose with this warning.\n\nThoughts? Can discuss in Slack if easier.","createdAt":"2025-08-04T14:15:15Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-dotnet/issues/500#issuecomment-3150905680","viewerDidAuthor":false}],"createdAt":"2025-07-18T15:32:27Z","labels":[{"id":"LA_kwDOInL6Hs8AAAABJH7zkA","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":500,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Segfault/crash occurs when using tasks without await","updatedAt":"2025-08-07T13:34:48Z","url":"https://github.com/temporalio/sdk-dotnet/issues/500"}
