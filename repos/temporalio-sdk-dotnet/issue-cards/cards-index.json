{
  "generatedAt": "2026-01-13T00:09:16.384Z",
  "totalCards": 290,
  "cards": [
    {
      "summary": "A test for Nexus operation timeout handling is flaking due to a CancellationTokenSource being disposed prematurely. The test fails with ObjectDisposedException when trying to access the WaitHandle of an already-disposed cancellation token source.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteNexusOperationAsync"
      ],
      "components": [
        "test-framework",
        "nexus-worker",
        "cancellation-handling"
      ],
      "concepts": [
        "timeout",
        "cancellation-token",
        "test-flake",
        "resource-disposal",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "This test flake indicates a potential race condition or premature disposal issue that could affect the reliability of Nexus operation timeout handling in production scenarios.",
      "rootCause": "A CancellationTokenSource is being disposed before the test completes, likely due to a race condition in timeout handling or resource cleanup.",
      "proposedFix": null,
      "workaround": null,
      "related": [],
      "resolution": null,
      "resolutionDetails": null,
      "keyQuote": "System.ObjectDisposedException : The CancellationTokenSource has been disposed.",
      "number": 592,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-13T00:09:16.343Z"
    },
    {
      "summary": "Task failures during child workflow startup, particularly those occurring in failure conversion logic within QueueNewTaskAsync, may not be properly caught and logged, resulting in lost error information. The issue affects StartChildWorkflowAsync and potentially other callsites.",
      "category": "bug",
      "subcategory": "child-workflows",
      "apis": [
        "StartChildWorkflowAsync",
        "QueueNewTaskAsync"
      ],
      "components": [
        "child-workflow-executor",
        "task-queuing",
        "error-handling"
      ],
      "concepts": [
        "task-failure",
        "error-conversion",
        "exception-handling",
        "failure-logging",
        "activation-exception"
      ],
      "severity": "high",
      "userImpact": "Users may lose visibility into workflow task failures, making it difficult to diagnose and troubleshoot issues in child workflows.",
      "rootCause": "QueueNewTaskAsync callers are not catching all errors that occur in lambda/task execution, particularly failure conversion errors, and not setting currentActivationException or logging them appropriately.",
      "proposedFix": "Implement comprehensive error catching for all QueueNewTaskAsync callsites to set currentActivationException and ensure adequate logging of task failures, either at individual callsites or at a general level.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        492
      ],
      "keyQuote": "if an error on failure conversion occurs in there, we are not logging it because we are not logging/catching all errors for QueueNewTaskAsync",
      "number": 588,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:38:58.371Z"
    },
    {
      "summary": "Refactor Bridge.Client from SafeHandle to IDisposable pattern to match Bridge.Worker implementation and eliminate duplicate SafeHandle wrappers for unmanaged Interop.TemporalCoreClient pointers.",
      "category": "feature",
      "subcategory": "interop-refactoring",
      "apis": [],
      "components": [
        "Bridge.Client",
        "SafeHandle",
        "Interop.TemporalCoreClient"
      ],
      "concepts": [
        "resource-management",
        "disposal-pattern",
        "unmanaged-memory",
        "interop",
        "lifetime-management"
      ],
      "severity": "low",
      "userImpact": "Improves consistency of resource disposal patterns in the SDK interop layer without direct user-facing changes.",
      "rootCause": "PR #583 introduced SafeHandle separation but deferred full conversion of Bridge.Client to IDisposable for later work.",
      "proposedFix": "Convert Bridge.Client to implement IDisposable pattern matching the Bridge.Worker class design.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        583
      ],
      "keyQuote": "This conversion should be done to match the pattern established for the `Bridge.Worker` class so that there aren't two SafeHandle implementations",
      "number": 587,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:38:21.080Z"
    },
    {
      "summary": "Extend SafeHandle implementations to manage unmanaged pointer lifecycles across all .NET bridge classes, following the pattern established in #583 for Client and Worker. This requires centralizing pointer lifetime management through SafeHandle types and providing a Scope.Pointer method for controlled pointer access.",
      "category": "feature",
      "subcategory": "memory-management",
      "apis": [],
      "components": [
        "SafeHandle",
        "pointer-lifecycle",
        "bridge-interop",
        "Client",
        "Worker"
      ],
      "concepts": [
        "memory-safety",
        "use-after-free",
        "unmanaged-pointers",
        "reference-counting",
        "interop",
        "lifetime-management"
      ],
      "severity": "high",
      "userImpact": "Prevents use-after-free bugs and ensures safe management of unmanaged pointers across all .NET SDK bridge classes.",
      "rootCause": "Inconsistent pointer lifecycle management across different bridge wrapper classes creates risk of use-after-free bugs.",
      "proposedFix": "Implement SafeHandle for all classes managing unmanaged pointers and add Scope.Pointer method to properly add-ref and return unmanaged pointer values.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        583
      ],
      "keyQuote": "Pointer lifetime management should be exclusively maintained by `SafeHandle` types for each unmanaged pointer type.",
      "number": 586,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:38:20.976Z"
    },
    {
      "summary": "Nexus operation was retrying every 10 seconds instead of respecting the configured 2-hour ScheduleToCloseTimeout. The issue occurred because the Nexus operation implementation was synchronous and didn't complete quickly enough, causing the start to retry after 10 seconds.",
      "category": "bug",
      "subcategory": "nexus-operations",
      "apis": [
        "NexusClient",
        "ExecuteWorkflowAsync"
      ],
      "components": [
        "nexus-handler",
        "worker",
        "workflow-executor"
      ],
      "concepts": [
        "timeout",
        "retry",
        "asynchronous-operations",
        "nexus-architecture",
        "long-running-processes"
      ],
      "severity": "medium",
      "userImpact": "Users configuring long-running Nexus operations with multi-hour timeouts experience unexpected retries every 10 seconds due to misunderstanding Nexus synchronous vs asynchronous operation requirements.",
      "rootCause": "Nexus operations have a built-in 10-second timeout for starting. Synchronous operations must complete within this window. For long-running operations, an asynchronous Nexus operation backed by a workflow is required, but the user implemented it as synchronous.",
      "proposedFix": "Migrate the Nexus operation handler to use an asynchronous pattern that starts a backing workflow immediately (completing the handler in <10 seconds) and returns an operation handle, allowing the actual work to run for hours with ScheduleToCloseTimeout.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "User acknowledged the need to migrate to an asynchronous Nexus operation handler pattern with workflow backing after community explanation of sync vs async requirements.",
      "related": [],
      "keyQuote": "Starting a Nexus operation has a built-in timeout of 10 seconds before the start is retried. This is mostly unrelated to operation timeout (i.e. schedule to close).",
      "number": 585,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:38:22.077Z"
    },
    {
      "summary": "The .NET SDK's TLS certificate loading from file paths doesn't work for Temporal Cloud mTLS authentication. When using the TEMPORAL_TLS_CLIENT_CERT_PATH environment variable, connection fails with a certificate error, but the same certificate works when provided via TEMPORAL_TLS_CLIENT_CERT_DATA.",
      "category": "bug",
      "subcategory": "tls-configuration",
      "apis": [
        "TemporalClient.ConnectAsync",
        "ClientEnvConfig.LoadClientConnectOptions"
      ],
      "components": [
        "ClientEnvConfig",
        "TLS",
        "connection-options"
      ],
      "concepts": [
        "TLS",
        "mTLS",
        "certificate-loading",
        "file-path",
        "environment-variables",
        "authentication"
      ],
      "severity": "high",
      "userImpact": "Users cannot connect to Temporal Cloud using mTLS authentication when providing certificates via file paths, forcing them to use less convenient environment variable alternatives.",
      "rootCause": "ClientEnvConfig.Tls.ToTlsOptions only reads the Data property of DataSource and ignores the Path property, preventing file-based certificate loading.",
      "proposedFix": null,
      "workaround": "Use TEMPORAL_TLS_CLIENT_CERT_DATA environment variable instead of TEMPORAL_TLS_CLIENT_CERT_PATH to provide the certificate content directly.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Looks like `ClientEnvConfig.Tls.ToTlsOptions` only reads `Data` and ignores `Path` property of `DataSource`",
      "number": 584,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:37:41.721Z"
    },
    {
      "summary": "SIGSEGV crash occurs intermittently in temporal_core_worker_poll_workflow_activation on Linux during workflow polling, preceded by activity heartbeat failures. The crash is environment-specific, occurring only in Linux CI but not on local Windows development.",
      "category": "bug",
      "subcategory": "native-bridge-crash",
      "apis": [],
      "components": [
        "temporal_core_worker",
        "native-bridge",
        "worker-polling",
        "activity-heartbeat"
      ],
      "concepts": [
        "segmentation-fault",
        "platform-specific",
        "intermittent-crash",
        "heartbeat-failure",
        "interop",
        "memory-safety"
      ],
      "severity": "high",
      "userImpact": "Integration tests crash randomly on Linux CI environments, making the SDK unusable for Linux-based continuous integration pipelines.",
      "rootCause": "Likely memory safety issue in the native Rust bridge's poll_workflow_activation function, potentially related to activity heartbeat handling or platform-specific memory management differences between Windows and Linux.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        577
      ],
      "keyQuote": "The crash occurs in the native Rust bridge during poll_workflow_activation, not during execution of any user workflow/activity code.",
      "number": 579,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:37:42.570Z"
    },
    {
      "summary": "Add tests to verify Nexus support in the time-skipping test server environment for .NET SDK. This addresses a gap in test coverage introduced when Nexus was initially added, with a known dependency on resolving a blocker issue in the Java SDK.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "nexus",
        "test-server",
        "time-skipping"
      ],
      "concepts": [
        "testing",
        "time-skipping",
        "nexus-support",
        "test-coverage",
        "integration-testing"
      ],
      "severity": "medium",
      "userImpact": "Users relying on time-skipping test server environments cannot currently verify that Nexus functionality works correctly in those conditions.",
      "rootCause": null,
      "proposedFix": "Add at least one common test confirming time skipping test server works with Nexus",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2592
      ],
      "keyQuote": "At least a common test confirming time skipping test server works with Nexus should be added.",
      "number": 578,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:37:40.428Z"
    },
    {
      "summary": "Test host process crashes intermittently on CI with SIGSEGV occurring in the P/Invoke layer during workflow activation completion. Root cause identified as premature destruction of ByteArrayRef objects during process shutdown, freeing native-visible resources that are still in use by Rust code.",
      "category": "bug",
      "subcategory": "test-infrastructure",
      "apis": [],
      "components": [
        "bridge-interop",
        "worker",
        "byte-array-ref"
      ],
      "concepts": [
        "memory-management",
        "process-shutdown",
        "use-after-free",
        "P/Invoke",
        "finalizers",
        "GC-destructors"
      ],
      "severity": "high",
      "userImpact": "CI tests flake unpredictably due to crashes in the .NET/Rust interop layer, affecting test reliability and blocking development.",
      "rootCause": "ByteArrayRef destructor is freeing native-visible resources (memory pointers) during .NET process shutdown that may still be in use by Rust code on the C side, causing use-after-free and SIGSEGV.",
      "proposedFix": "Stop freeing resources in destructors for Scope and ByteArrayRef. Use explicit Dispose() calls only and do not call Dispose() from destructors. Ensure resources are only freed when explicitly released, not during unmanaged process shutdown.",
      "workaround": "Intentionally leak ByteArrayRef memory to prevent premature deallocation, or add ByteArrayRef.Empty to byteArrayRefs tracking to ensure proper lifetime management.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was identified as P/Invoke interop problem where destructors were freeing native-visible resources during process shutdown while still in use by Rust code.",
      "related": [],
      "keyQuote": "A finalizer must never release native-visible resources whose premature release can crash the process.",
      "number": 577,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:37:03.409Z"
    },
    {
      "summary": "Request for a Roslyn analyzer tool for .NET to detect workflow constraint violations at compile-time, similar to existing analyzers in Go and Java SDKs. The analyzer should transitively check for invalid actions within workflows, display call graph stacks for violations, and integrate with the Temporalio NuGet package.",
      "category": "feature",
      "subcategory": "workflow-analysis",
      "apis": [],
      "components": [
        "roslyn-analyzer",
        "workflow-validation",
        "diagnostic-tools"
      ],
      "concepts": [
        "static-analysis",
        "workflow-constraints",
        "call-graph",
        "determinism",
        "code-generation"
      ],
      "severity": "medium",
      "userImpact": "Users lack compile-time validation of workflow constraint violations, requiring runtime discovery of issues that other SDKs can detect statically.",
      "rootCause": null,
      "proposedFix": "Build a Roslyn analyzer that transitively checks workflow methods for invalid actions, displays call stacks, disables inapplicable warnings, and optionally ships with the Temporalio NuGet package.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        2356
      ],
      "keyQuote": "Should transitively check known-yet-configurable invalid actions occurring in a workflow... The error needs to show the call graph stack since many times the issue is several calls deep from the workflow itself.",
      "number": 576,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:37:01.557Z"
    },
    {
      "summary": "Allow custom meter implementations to disable the tracing event listener when emitting metrics from workflows. Users with custom meters that use non-deterministic threading should be able to wrap meter calls with Workflow.Unsafe.WithTracingEventListenerDisabled to prevent tracing violations.",
      "category": "feature",
      "subcategory": "metrics-tracing",
      "apis": [
        "Workflow.Unsafe.WithTracingEventListenerDisabled",
        "Workflow.InWorkflow",
        "CustomMetricMeter"
      ],
      "components": [
        "metrics",
        "tracing",
        "workflow-execution",
        "custom-meter"
      ],
      "concepts": [
        "metrics",
        "tracing",
        "determinism",
        "threading",
        "custom-implementation",
        "listener-disabling"
      ],
      "severity": "medium",
      "userImpact": "Users with custom metric meters using non-deterministic threading can avoid tracing event listener violations when emitting metrics from workflows.",
      "rootCause": "Custom metric meters may use threads/tasks in non-deterministic ways, causing metrics emission to trigger tracing event listener violations during workflow execution.",
      "proposedFix": "Add an option to CustomMetricMeter that wraps underlying Meter calls with Workflow.Unsafe.WithTracingEventListenerDisabled when Workflow.InWorkflow is true, likely enabled by default.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to allow disabling tracing event listener for custom meter implementations",
      "related": [],
      "keyQuote": "Allow custom meter implementation to disable tracing event listener when calling the underlying Meter inside workflows",
      "number": 573,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:37:01.696Z"
    },
    {
      "summary": "Feature request to enable executing activities outside of workflow context. This requires both client and worker support for new server APIs that manage activity lifecycle independently of workflows.",
      "category": "feature",
      "subcategory": "activity-execution",
      "apis": [],
      "components": [
        "worker",
        "activity-executor",
        "client",
        "server-api"
      ],
      "concepts": [
        "activity-lifecycle",
        "out-of-workflow-execution",
        "activity-management",
        "async-execution",
        "server-integration"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to execute activities without requiring a parent workflow, enabling new architectural patterns and use cases.",
      "rootCause": null,
      "proposedFix": "Implement support for starting, managing, and retrieving results of activities through new server APIs, with corresponding client and worker changes.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        640
      ],
      "keyQuote": "Allow executing activities without a workflow. The clients must support the new (upcoming) server APIs for starting, managing and getting results of activities.",
      "number": 568,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:36:22.990Z"
    },
    {
      "summary": "Proposal to refactor test workflows into separate files following a `*.workflow.cs` naming pattern to enable removal of inline code analysis suppressions and use `.editorconfig` recommendations for the test suite.",
      "category": "other",
      "subcategory": "test-organization",
      "apis": [],
      "components": [
        "test-suite",
        "code-analysis",
        "editor-config"
      ],
      "concepts": [
        "code-organization",
        "test-structure",
        "static-analysis",
        "style-guidelines"
      ],
      "severity": "low",
      "userImpact": "Improves test code organization and maintainability for SDK developers but does not affect runtime functionality for SDK users.",
      "rootCause": null,
      "proposedFix": "Refactor workflows in tests into separate source code files matching the pattern `*.workflow.cs` to allow removal of inline suppressions of code analysis rules.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer decided against the refactoring, preferring to keep tests colocated with workflow/activity implementations for better comprehension and test authoring.",
      "related": [
        562
      ],
      "keyQuote": "I think tests right next to their workflow/activity implementations is ideal for comprehension and test authoring.",
      "number": 565,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:36:23.452Z"
    },
    {
      "summary": "Request to add a global.json file to centralize .NET SDK version specification across the repository. Currently, the SDK version is scattered across multiple build pipelines and GitHub workflows with no single source of truth.",
      "category": "feature",
      "subcategory": "build-infrastructure",
      "apis": [],
      "components": [
        "build-pipeline",
        "github-workflows",
        "dotnet-tooling"
      ],
      "concepts": [
        "version-management",
        "build-consistency",
        "dependency-management",
        "developer-experience",
        "automation",
        "centralization"
      ],
      "severity": "low",
      "userImpact": "Developers and CI/CD systems would have a clear, centralized specification of the required .NET SDK version, reducing confusion and maintenance overhead when upgrading SDK versions.",
      "rootCause": null,
      "proposedFix": "Add a global.json file at the repository root that specifies the .NET SDK version, allowing .NET tooling and GitHub actions to automatically discover and enforce the correct version.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Using a global.json file makes it clear as to what version is necessary and provides a user experience when that requirement is not met",
      "number": 563,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:36:23.089Z"
    },
    {
      "summary": "The Envconfig implementation incorrectly uses a TemporalClientConnectOptions constructor that requires a non-null target host string, forcing users to supply an empty string which results in a client unable to connect to a server.",
      "category": "bug",
      "subcategory": "client-configuration",
      "apis": [
        "TemporalClientConnectOptions"
      ],
      "components": [
        "envconfig",
        "client-connection",
        "client-options"
      ],
      "concepts": [
        "configuration",
        "connection",
        "constructor",
        "target-host",
        "null-handling"
      ],
      "severity": "high",
      "userImpact": "Users cannot properly configure temporal client connections through envconfig when the target host should be optional or null.",
      "rootCause": "TemporalClientConnectOptions constructor used in envconfig implementation requires a non-null string parameter for target host, preventing support for optional/null address values.",
      "proposedFix": "Use the correct TemporalClientConnectOptions constructor that allows for possibly null address/target host values.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Corrected the constructor call to use the appropriate overload that accepts null target host values.",
      "related": [],
      "keyQuote": "Use the correct `TemporalClientConnectOptions` constructor when creating connection options that allows for possibly null address/target host value.",
      "number": 559,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:35:43.035Z"
    },
    {
      "summary": "Users need the ability to override the target deployment version when invoking a child workflow from within a worker, similar to how version override works when creating workflows from a client.",
      "category": "feature",
      "subcategory": "child-workflow-execution",
      "apis": [
        "ExecuteChildWorkflow"
      ],
      "components": [
        "worker",
        "child-workflow-executor",
        "deployment-versioning"
      ],
      "concepts": [
        "version-override",
        "deployment-testing",
        "child-workflow",
        "pre-deployment",
        "version-targeting"
      ],
      "severity": "medium",
      "userImpact": "Users cannot test pre-deployment versions when invoking child workflows, limiting testing capabilities for versioned workflows.",
      "rootCause": null,
      "proposedFix": "Allow version override parameter on child workflow invocation methods, consistent with client-side workflow creation API.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Users want to override the target version on a workflow, especially when doing pre-deployment testing.",
      "number": 558,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:35:42.324Z"
    },
    {
      "summary": "User requests that OperatorService and WorkflowService RPC methods be marked virtual or extracted to interfaces to enable mocking with NSubstitute for unit testing Kubernetes operators. The discussion explores alternatives like using ephemeral dev servers and subclassing with public delegator methods.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "OperatorService",
        "WorkflowService",
        "ITemporalClient",
        "ITemporalConnection"
      ],
      "components": [
        "OperatorService",
        "WorkflowService",
        "RpcClient",
        "testing"
      ],
      "concepts": [
        "mocking",
        "unit-testing",
        "testability",
        "virtual-methods",
        "interfaces",
        "dependency-injection",
        "nsubstitute"
      ],
      "severity": "medium",
      "userImpact": "Users cannot effectively mock OperatorService and WorkflowService for unit testing without using ephemeral dev servers, limiting test flexibility for Kubernetes operator development.",
      "rootCause": "OperatorService.Rpc and WorkflowService.Rpc methods are not virtual and do not expose public APIs that NSubstitute can mock; InvokeRpcAsync is protected rather than public.",
      "proposedFix": "Mark methods in OperatorService.Rpc and WorkflowService.Rpc as virtual, or extract them into interfaces. Alternatively, create public abstract subclasses that delegate InvokeRpcAsync to public methods.",
      "workaround": "Use ephemeral dev server via WorkflowEnvironment.StartLocalAsync for testing instead of mocking; or create custom subclasses of WorkflowService/OperatorService that expose InvokeRpcAsync through public delegator methods.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        419
      ],
      "keyQuote": "We usually discourage mocking these kinds of things instead of using an ephemeral dev server in your tests since that will truly test your calls as opposed to assuming how Temporal server behavior is.",
      "number": 553,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:35:44.804Z"
    },
    {
      "summary": "Worker heartbeating needs to be enabled in the .NET SDK by allowing users to specify the worker heartbeat interval when initializing Core Runtime. This feature is already implemented in Core but not exposed to .NET users.",
      "category": "feature",
      "subcategory": "worker-heartbeat",
      "apis": [],
      "components": [
        "worker",
        "core-runtime"
      ],
      "concepts": [
        "heartbeating",
        "worker-initialization",
        "core-runtime",
        "connection-management",
        "health-monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure worker heartbeat intervals, limiting their ability to manage worker health and connection stability in long-running scenarios.",
      "rootCause": null,
      "proposedFix": "Allow users to specify the worker heartbeat interval as a parameter when initializing Core Runtime.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker heartbeating was implemented in Core and the feature was enabled in the .NET SDK to allow users to specify the heartbeat interval during Core Runtime initialization.",
      "related": [],
      "keyQuote": "Worker heartbeating is implemented in Core, need to enable worker heartbeating by allowing users to specify the worker heartbeat interval when initializing Core Runtime",
      "number": 551,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:35:05.320Z"
    },
    {
      "summary": "The test `CanRunWith_CustomSlotSupplier` flakes intermittently with an assertion failure (expected 27 but got 28) and a worker finalization error indicating an unexpected reference count during shutdown.",
      "category": "bug",
      "subcategory": "test-flakiness",
      "apis": [],
      "components": [
        "worker",
        "slot-supplier",
        "test-framework",
        "worker-shutdown"
      ],
      "concepts": [
        "test-flakiness",
        "race-condition",
        "reference-counting",
        "worker-lifecycle",
        "concurrency",
        "shutdown"
      ],
      "severity": "medium",
      "userImpact": "Intermittent test failures reduce confidence in the worker tuning implementation and may indicate a subtle concurrency or resource management issue.",
      "rootCause": "Likely a race condition or incorrect reference counting in worker shutdown when using a custom slot supplier, as evidenced by the 'expected 1 reference, got 2' error during finalization.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        569
      ],
      "keyQuote": "Cannot finalize, expected 1 reference, got 2",
      "number": 550,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:35:05.308Z"
    },
    {
      "summary": "The `ExecuteWorkflowAsync_PollingBehavior_Autoscaling` test flakes intermittently with an empty collection error, indicating a race condition or timing issue in the worker's polling autoscaling behavior.",
      "category": "bug",
      "subcategory": "test-flakiness",
      "apis": [],
      "components": [
        "worker",
        "polling",
        "test-framework"
      ],
      "concepts": [
        "autoscaling",
        "polling-behavior",
        "race-condition",
        "test-flakiness",
        "timing-issue"
      ],
      "severity": "medium",
      "userImpact": "Test failures reduce confidence in SDK stability and can block CI/CD pipelines.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The collection was expected to contain a single element, but it was empty.",
      "number": 549,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:35:04.852Z"
    },
    {
      "summary": "Move ClientEnvConfig from the client-specific namespace (Temporalio.Client.EnvConfig) to the common namespace (Temporalio.Common.EnvConfig) to align with other SDKs and improve API organization. This is a backwards-incompatible change that is acceptable since the SDK is not yet GA.",
      "category": "feature",
      "subcategory": "api-organization",
      "apis": [],
      "components": [
        "client-config",
        "namespace",
        "api-structure"
      ],
      "concepts": [
        "namespace-organization",
        "backwards-compatibility",
        "api-consistency",
        "SDK-alignment",
        "pre-GA-changes"
      ],
      "severity": "low",
      "userImpact": "Users will need to update their imports when upgrading to use ClientEnvConfig from the new common namespace location.",
      "rootCause": null,
      "proposedFix": "Move ClientEnvConfig class from Temporalio.Client.EnvConfig namespace to Temporalio.Common.EnvConfig namespace.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The namespace change was implemented as requested, moving ClientEnvConfig to align with other SDKs.",
      "related": [],
      "keyQuote": "We don't need it in client-specific namespace even though it is only for client things. This matches other SDKs and it's not GA yet so even though this is a backwards-incompatible change, it's acceptable.",
      "number": 543,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:34:25.648Z"
    },
    {
      "summary": "Implement a Plugin system for .NET SDK to allow users to self-serve creating integrations with Temporal Workflows, following the pattern already established in the Python SDK.",
      "category": "feature",
      "subcategory": "plugin-system",
      "apis": [],
      "components": [
        "plugin-system",
        "sdk-core",
        "integration-framework"
      ],
      "concepts": [
        "extensibility",
        "integration",
        "self-service",
        "customization",
        "modularity"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to create custom integrations with Temporal Workflows without modifying the SDK itself.",
      "rootCause": null,
      "proposedFix": "Copy the plugin implementation approach from the Python SDK to the .NET SDK.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Plugin system implemented for .NET SDK based on Python SDK pattern.",
      "related": [],
      "keyQuote": "Implement Plugins so that users can self-serve creating integrations with Temporal Workflows.",
      "number": 542,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:34:24.641Z"
    },
    {
      "summary": "Memory leak in CancellationToken callbacks where CancellationTokenRegistration objects are not being disposed, causing accumulation of CallbackNode objects in memory. The ReleaseHandle method is never invoked because CancellationToken instances are not properly identified in the Scope disposal logic.",
      "category": "bug",
      "subcategory": "memory-management",
      "apis": [
        "GetSystemInfoAsync"
      ],
      "components": [
        "CancellationToken",
        "Scope",
        "Bridge"
      ],
      "concepts": [
        "memory-leak",
        "resource-disposal",
        "cancellation",
        "callbacks",
        "GC-handles"
      ],
      "severity": "high",
      "userImpact": "Long-running applications using Temporal client workflows experience unbounded memory growth due to accumulated CancellationToken objects that are never garbage collected.",
      "rootCause": "CancellationTokenRegistration objects created by CancellationToken.Register() are not disposed, and the type check in Scope.Dispose() does not recognize CancellationToken instances (checking only for GCHandle), preventing ReleaseHandle() from being called.",
      "proposedFix": "Store CancellationTokenRegistration in CancellationToken class and dispose it in ReleaseHandle(). Add explicit type check for CancellationToken in Scope.Dispose() to call Dispose() on CancellationToken instances.",
      "workaround": "Locally modified CancellationToken class to store and dispose cancellationCallback, and updated Scope.Dispose() to handle CancellationToken type explicitly.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the proposed fix was implemented in the SDK.",
      "related": [],
      "keyQuote": "CancellationToken.Register registers a callback on the token and returns a CancellationTokenRegistration that should be disposed of once the callback is no longer needed.",
      "number": 540,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:34:27.253Z"
    },
    {
      "summary": "Remove the erroneous `OperationName` property from `Temporalio.Workflows.NexusOperationOptions` as it is not used and should not be part of the API.",
      "category": "bug",
      "subcategory": "nexus-operations",
      "apis": [
        "NexusOperationOptions"
      ],
      "components": [
        "nexus-operation-client",
        "workflow-sdk",
        "api-surface"
      ],
      "concepts": [
        "api-cleanup",
        "unused-property",
        "nexus-integration",
        "code-maintenance"
      ],
      "severity": "low",
      "userImpact": "Users may be confused by the presence of an unused property in the NexusOperationOptions API.",
      "rootCause": "The OperationName property was included in NexusOperationOptions but is not utilized anywhere in the codebase.",
      "proposedFix": "Remove the OperationName property from the NexusOperationOptions class.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Property was removed from the NexusOperationOptions API.",
      "related": [],
      "keyQuote": "`Temporalio.Workflows.NexusOperationOptions.OperationName` should not be there, it is not used",
      "number": 537,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:33:47.109Z"
    },
    {
      "summary": "Feature request to add Nexus service support within the Temporalio.Extensions.Hosting dependency injection framework for .NET SDK.",
      "category": "feature",
      "subcategory": "nexus-integration",
      "apis": [],
      "components": [
        "Temporalio.Extensions.Hosting",
        "Nexus",
        "dependency-injection"
      ],
      "concepts": [
        "service-registration",
        "dependency-injection",
        "nexus-services",
        "hosting-extension",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily register and configure Nexus services using the standard .NET dependency injection patterns provided by the Hosting extension.",
      "rootCause": null,
      "proposedFix": "Extend Temporalio.Extensions.Hosting to support Nexus service registration and configuration through the DI container.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Nexus support was implemented in the Temporalio.Extensions.Hosting extension.",
      "related": [],
      "keyQuote": "Support Nexus services with DI and such in `Temporalio.Extensions.Hosting`.",
      "number": 536,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:33:46.909Z"
    },
    {
      "summary": "Feature request to ensure Nexus slot info and custom slot supplier are fully implemented and tested in the .NET SDK.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [],
      "components": [
        "nexus",
        "slot-supplier"
      ],
      "concepts": [
        "nexus",
        "custom-slots",
        "testing",
        "implementation",
        "slot-info"
      ],
      "severity": "medium",
      "userImpact": "Users need Nexus custom slot supplier capabilities to be available and properly tested in the .NET SDK.",
      "rootCause": null,
      "proposedFix": "Implement and test Nexus slot info and custom slot supplier functionality.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed after the requested Nexus slot info and custom slot supplier were implemented and tested.",
      "related": [],
      "keyQuote": "Make sure Nexus slot info and custom slot supplier are implemented/tested",
      "number": 528,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:33:46.718Z"
    },
    {
      "summary": "KeywordList search attributes cannot be resolved from WorkflowExecutionDescription.TypedSearchAttributes despite being present in the workflow. The TryGetValue method returns false even when the value exists as a List<object> type.",
      "category": "bug",
      "subcategory": "search-attributes",
      "apis": [
        "DescribeAsync",
        "TryGetValue",
        "TypedSearchAttributes"
      ],
      "components": [
        "search-attributes",
        "workflow-description",
        "type-resolution"
      ],
      "concepts": [
        "search-attributes",
        "type-resolution",
        "KeywordList",
        "workflow-metadata",
        "data-types"
      ],
      "severity": "medium",
      "userImpact": "Users cannot retrieve custom KeywordList search attributes from completed workflows, breaking the ability to access this metadata.",
      "rootCause": "Type resolution issue where KeywordList values are stored as List<object> internally but the TryGetValue lookup fails to match the expected type.",
      "proposedFix": "Fix the type resolution logic in TypedSearchAttributes to properly handle KeywordList types (PR #529).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #529 which improved type resolution for KeywordList search attributes.",
      "related": [
        529
      ],
      "keyQuote": "When executing a code as following, the `TryGetValue` returns `false` even the value is there, but of a `List<object>` type.",
      "number": 526,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:33:08.172Z"
    },
    {
      "summary": "Serialization context is being incorrectly applied to all workflow calls in .NET SDK, but should only be selectively applied based on specific situations to match Java SDK behavior. This requires a backwards-incompatible change decision.",
      "category": "bug",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "payload-converter",
        "failure-converter",
        "payload-codec",
        "workflow-context"
      ],
      "concepts": [
        "serialization",
        "data-conversion",
        "context-application",
        "backwards-compatibility",
        "sdk-parity"
      ],
      "severity": "high",
      "userImpact": "Workflows may fail or behave incorrectly due to improper serialization context being applied to all workflow calls instead of selectively.",
      "rootCause": "Over-generalization from #446 where serialization context was assumed to be needed for all data conversion use cases in workflow context, but Java SDK only applies it selectively.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Serialization context application was corrected to selectively apply based on situation context rather than applying to all workflow calls.",
      "related": [
        446
      ],
      "keyQuote": "every use of data conversion in a .NET workflow context needed a .NET workflow context. But to match Java, we actually need to only selectively apply contexts based on their situation",
      "number": 523,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:33:07.557Z"
    },
    {
      "summary": "Update .NET SDK test framework to target .NET 10 instead of .NET 6, and remove the dotNetVersionOverride concept from CI configuration. Discussion needed on whether to maintain .NET 6 compatibility for backward compatibility testing.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-infrastructure",
        "ci-configuration",
        "build-system"
      ],
      "concepts": [
        "dotnet-version",
        "target-framework",
        "compatibility",
        "lts-release",
        "ci-pipeline"
      ],
      "severity": "low",
      "userImpact": "Users benefit from updated test coverage on latest .NET versions, ensuring the SDK works reliably with current .NET LTS releases.",
      "rootCause": null,
      "proposedFix": "Update TargetFramework to net10.0 in Temporalio.Tests.csproj and remove dotNetVersionOverride from ci.yml",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was addressed by upgrading tests to .NET 10 when LTS release became available, as indicated by the comment from maciejdudko.",
      "related": [
        517
      ],
      "keyQuote": "We should probably update tests/Temporalio.Tests/Temporalio.Tests.csproj to use <TargetFramework>net10.0</TargetFramework>",
      "number": 522,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:33:08.547Z"
    },
    {
      "summary": "Feature request to add tests confirming that custom Nexus slot supplier slot info has proper fields, ensuring integration with the broader Temporal feature set.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-suite",
        "nexus",
        "slot-supplier"
      ],
      "concepts": [
        "slot-info",
        "custom-supplier",
        "nexus-integration",
        "field-validation",
        "test-coverage"
      ],
      "severity": "low",
      "userImpact": "Ensures custom slot supplier implementations are properly tested and validated, improving reliability for users implementing custom Nexus slot suppliers.",
      "rootCause": null,
      "proposedFix": "Create tests to verify that custom slot supplier slot info contains all required and proper fields.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tests were implemented to validate custom slot supplier slot info fields.",
      "related": [
        672
      ],
      "keyQuote": "Make sure Nexus is included.",
      "number": 519,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:32:29.830Z"
    },
    {
      "summary": "Request to add OpenTelemetry (OTel) support to the .NET SDK, similar to the tracing work implemented in the Java SDK. This would enable distributed tracing and observability for Temporal workflows in .NET applications.",
      "category": "feature",
      "subcategory": "observability",
      "apis": [],
      "components": [
        "telemetry",
        "tracing",
        "instrumentation"
      ],
      "concepts": [
        "observability",
        "distributed-tracing",
        "opentelemetry",
        "instrumentation",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users can better monitor and troubleshoot Temporal workflows in .NET applications with distributed tracing integration.",
      "rootCause": null,
      "proposedFix": "Implement OpenTelemetry support following the pattern established in the Java SDK PR #2278.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "OTel support was implemented in the .NET SDK following the Java SDK implementation pattern.",
      "related": [
        2278
      ],
      "keyQuote": "Like tracing work done at https://github.com/temporalio/sdk-java/pull/2278, but for OTel .NET",
      "number": 515,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:32:29.515Z"
    },
    {
      "summary": "Add support for Nexus cancellation type in the .NET SDK, mirroring the implementation from the Python SDK. This feature request is dependent on a Core SDK fix that was being tracked separately.",
      "category": "feature",
      "subcategory": "nexus-cancellation",
      "apis": [],
      "components": [
        "nexus",
        "cancellation"
      ],
      "concepts": [
        "cancellation-type",
        "nexus-operations",
        "sdk-alignment",
        "cross-language-parity"
      ],
      "severity": "medium",
      "userImpact": "Users of the .NET SDK will be unable to properly handle Nexus operation cancellations until this feature is implemented.",
      "rootCause": "Missing implementation of Nexus cancellation type support in the .NET SDK; also blocked by a Core SDK issue #1026.",
      "proposedFix": "Implement Nexus cancellation type support following the approach taken in the Python SDK PR #981.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented by referencing the Python SDK implementation pattern.",
      "related": [
        981,
        1026
      ],
      "keyQuote": "Need to do https://github.com/temporalio/sdk-python/pull/981, but for .NET",
      "number": 514,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:32:29.780Z"
    },
    {
      "summary": "User deployed Temporal server behind an Istio gateway with TLS termination at the gateway but plain HTTP to the backend. The .NET SDK failed with an unknown certificate issuer error because the server certificate CA was not trusted by default.",
      "category": "question",
      "subcategory": "tls-configuration",
      "apis": [],
      "components": [
        "tls-client",
        "transport-layer",
        "connection-handling"
      ],
      "concepts": [
        "tls",
        "certificate-validation",
        "gateway",
        "authentication",
        "ca-certificate"
      ],
      "severity": "low",
      "userImpact": "Users deploying Temporal behind TLS-terminating gateways need to provide custom CA certificates to establish connections.",
      "rootCause": "Server certificate was signed by a CA not in the system's default trusted root store, causing certificate validation to fail.",
      "proposedFix": "Set TlsOptions.ServerRootCACert with the appropriate CA certificate that signed the gateway's TLS certificate.",
      "workaround": "Download and provide the root certificate from your CA when creating TlsOptions.",
      "resolution": "fixed",
      "resolutionDetails": "User resolved the issue by downloading the root CA certificate from DigiCert and setting it as ServerRootCACert in TlsOptions.",
      "related": [],
      "keyQuote": "downloading the root certficate and setting it as `ServerRootCACert` worked",
      "number": 513,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:31:51.913Z"
    },
    {
      "summary": "Add support for gRPC binary metadata headers in the .NET SDK. This feature requires base64 encoding of binary values and coordination with sdk-core to handle dictionary values as bytes without breaking existing users.",
      "category": "feature",
      "subcategory": "grpc-metadata",
      "apis": [],
      "components": [
        "grpc",
        "metadata",
        "headers"
      ],
      "concepts": [
        "binary-metadata",
        "encoding",
        "grpc-headers",
        "data-serialization",
        "compatibility"
      ],
      "severity": "medium",
      "userImpact": "Users need to pass binary data in gRPC metadata headers, which currently requires workarounds or is not supported.",
      "rootCause": null,
      "proposedFix": "Support dictionary values as bytes with base64 encoding for -bin suffix headers, pending sdk-core changes",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support gRPC binary metadata headers with proper encoding",
      "related": [
        671,
        991
      ],
      "keyQuote": "Probably needs https://github.com/temporalio/sdk-core/issues/991 first, and then probably needs to support dictionary values as bytes",
      "number": 512,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:31:50.673Z"
    },
    {
      "summary": "Feature request to reclassify benign application errors in OpenTelemetry spans, following the pattern established in the Python SDK issue #1041.",
      "category": "feature",
      "subcategory": "observability",
      "apis": [],
      "components": [
        "opentelemetry",
        "span-recording",
        "error-handling"
      ],
      "concepts": [
        "observability",
        "error-classification",
        "instrumentation",
        "benign-errors",
        "span-attributes"
      ],
      "severity": "low",
      "userImpact": "Users can better distinguish between actual failures and expected application errors in their distributed traces and monitoring dashboards.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed, likely implemented following the Python SDK solution",
      "related": [
        1041
      ],
      "keyQuote": "See issue description here: https://github.com/temporalio/sdk-python/issues/1041",
      "number": 510,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:31:50.262Z"
    },
    {
      "summary": "Feature request to add plugin support to the .NET SDK, as part of the broader Temporal plugin architecture initiative referenced in the features repository.",
      "category": "feature",
      "subcategory": "plugin-system",
      "apis": [],
      "components": [
        "sdk-core",
        "extension-system"
      ],
      "concepts": [
        "extensibility",
        "plugin-architecture",
        "modularity",
        "integration-points",
        "custom-extensions"
      ],
      "severity": "medium",
      "userImpact": "Users would be able to extend SDK functionality through a plugin mechanism, enabling custom integrations and behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Plugin support was implemented as part of the broader SDK extension architecture",
      "related": [
        652
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/652",
      "number": 507,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:31:08.896Z"
    },
    {
      "summary": "Duplicate activity and workflow registration does not throw an error, causing silent failures where the worker doesn't register on the task queue. The issue occurs when using TemporalWorkerService with start/stop instead of the recommended host building approach.",
      "category": "bug",
      "subcategory": "worker-initialization",
      "apis": [
        "AddAllActivities",
        "TemporalWorker",
        "TemporalWorkerService",
        "ExecuteAsync"
      ],
      "components": [
        "worker",
        "activity-worker",
        "workflow-worker",
        "worker-service"
      ],
      "concepts": [
        "duplicate-detection",
        "error-handling",
        "startup-validation",
        "background-service",
        "task-queue-registration"
      ],
      "severity": "high",
      "userImpact": "Workers silently fail to register when duplicate activities or workflows are registered, causing tasks to not be processed without visible error messages.",
      "rootCause": "TemporalWorkerService defers worker instantiation to ExecuteAsync rather than constructor to support async client connection. Exceptions thrown in ExecuteAsync are swallowed when using start/stop pattern instead of IHost.",
      "proposedFix": "Use .NET host building approach (IHost) or directly call ExecuteAsync instead of start/stop pattern to ensure exceptions are properly propagated.",
      "workaround": "Wrap ExecuteAsync in a try-catch block or use the .NET host pattern (IHost) which properly handles ExecuteAsync failures by stopping the application.",
      "resolution": "wontfix",
      "resolutionDetails": "The behavior is by design. TemporalWorkerService intentionally doesn't throw in constructor due to async requirements. Users must use proper .NET hosting patterns to see exceptions.",
      "related": [],
      "keyQuote": "TemporalWorkerService intentionally does not instantiate the worker in its constructor, it does it as part of ExecuteAsync since it may have to also connect a client",
      "number": 506,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:31:12.255Z"
    },
    {
      "summary": "Request to add the first execution run ID to the workflow info exposed in the .NET SDK. This feature is being tracked in the features repository to ensure parity across SDKs.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-context",
        "runtime-info"
      ],
      "concepts": [
        "workflow-execution",
        "execution-history",
        "run-id",
        "metadata"
      ],
      "severity": "low",
      "userImpact": "Users can access the first execution run ID to better understand workflow execution history and replay behavior.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was implemented to add first execution run ID to the WorkflowInfo class.",
      "related": [
        29
      ],
      "keyQuote": "Add first execution run ID to workflow info",
      "number": 505,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:31:08.565Z"
    },
    {
      "summary": "User asks if there's a way to start workflows from a separate client application without requiring the full workflow type definition and dependency tree. They want to use a string-based workflow name instead of a typed lambda expression, similar to how the CLI works.",
      "category": "question",
      "subcategory": "client-worker-separation",
      "apis": [
        "StartWorkflowAsync"
      ],
      "components": [
        "client",
        "workflow-invocation",
        "api-design"
      ],
      "concepts": [
        "dependency-injection",
        "type-safety",
        "distributed-architecture",
        "workflow-registration",
        "task-queue",
        "decoupling"
      ],
      "severity": "low",
      "userImpact": "Users needing separate worker and client applications must either duplicate workflow/activity code or pull in large dependency trees to use the type-safe API.",
      "rootCause": null,
      "proposedFix": "Use string-based workflow type names with object argument collections instead of lambda expressions.",
      "workaround": "Use the existing overloads of StartWorkflowAsync that accept string workflow type names and object collections of arguments.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was a question about API capabilities. The maintainer confirmed that string-based overloads for StartWorkflowAsync already exist as an alternative to lambda expressions.",
      "related": [],
      "keyQuote": "Absolutely. See the overloads for `StartWorkflowAsync`. One accepts a string workflow type name and an object collection of arguments.",
      "number": 502,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:30:31.110Z"
    },
    {
      "summary": "A segmentation fault or access violation occurs when using tasks without proper await patterns in workflows. The issue stems from the worker being disposed before asynchronous operations complete, causing the bridge to poll workflow activations on an already-disposed worker.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [
        "ExecuteAsync",
        "StartWorkflowAsync",
        "GetResultAsync"
      ],
      "components": [
        "worker",
        "bridge-interop",
        "workflow-execution"
      ],
      "concepts": [
        "task-awaiting",
        "resource-disposal",
        "lifetime-management",
        "async-synchronization",
        "memory-safety",
        "dispose-timing"
      ],
      "severity": "critical",
      "userImpact": "Users writing certain workflow patterns without proper async/await can experience segmentation faults, crashes, and corrupted memory that may be difficult to diagnose.",
      "rootCause": "When ExecuteAsync is not awaited properly (function not marked as async), the using statement disposes the worker before the returned Task completes, causing subsequent bridge calls to attempt operations on disposed resources.",
      "proposedFix": "Either add disposal guards at the bridge worker level to disregard operations after dispose with a warning, or restructure ExecuteAsync to not be async so it captures the worker and doesn't release resources until proper shutdown.",
      "workaround": "Mark the containing function as async and use await on the ExecuteAsync call to extend the using scope until the operation completes.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was identified as a resource lifecycle problem where the worker was disposed prematurely. The solution involved proper handling of worker disposal and ensuring it doesn't occur before async operations complete.",
      "related": [],
      "keyQuote": "The using here causes Dispose() to be called at the end of function. If the function is NOT marked async, this will happen before the completion of the future.",
      "number": 500,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:30:31.373Z"
    },
    {
      "summary": "Request to add a Summary field to LocalActivityOptions for better tracking and identification of local activities in the .NET SDK.",
      "category": "feature",
      "subcategory": "local-activities",
      "apis": [
        "LocalActivityOptions"
      ],
      "components": [
        "local-activity-executor",
        "options-builder"
      ],
      "concepts": [
        "local-activity",
        "summary",
        "metadata",
        "activity-tracking"
      ],
      "severity": "low",
      "userImpact": "Users would have better visibility and control over local activity metadata in the .NET SDK.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented as part of SDK enhancement to align with features repository specification.",
      "related": [],
      "keyQuote": "See `features` repo issue for more info",
      "number": 499,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:30:27.600Z"
    },
    {
      "summary": "The workflow logger uses 'RunId' for the workflow run identifier, while the activity logger uses 'WorkflowRunId' for the same information. This naming inconsistency causes confusion when filtering logs, though the maintainer notes this is intentional to match property names in ActivityInfo and WorkflowInfo objects.",
      "category": "question",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "logger",
        "workflow-context",
        "activity-context",
        "structured-logging"
      ],
      "concepts": [
        "naming-consistency",
        "log-properties",
        "structured-logs",
        "workflow-identifier",
        "activity-logging",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers experience confusion when filtering logs across workflow and activity contexts due to inconsistent property names for the same workflow run identifier.",
      "rootCause": "The logger scope field names are intentionally matched to property names in ActivityInfo and WorkflowInfo objects, which have different naming conventions for the run identifier.",
      "proposedFix": null,
      "workaround": "Create a workflow interceptor that surrounds workflow execution with BeginScope to add additional scope values with consistent naming.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "It is intentional that we match the field names in the logger scope with the property names in the respective \"info\" objects.",
      "number": 496,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:29:49.709Z"
    },
    {
      "summary": "Request to implement environment configuration support for the .NET SDK, following the cross-SDK specification for external client configuration.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [],
      "components": [
        "client",
        "configuration",
        "environment"
      ],
      "concepts": [
        "environment-configuration",
        "external-client",
        "cross-sdk-feature",
        "client-setup"
      ],
      "severity": "medium",
      "userImpact": "Users need standardized environment-based configuration for Temporal clients in .NET, consistent with other SDK implementations.",
      "rootCause": null,
      "proposedFix": "Implement environment configuration following the specification in the external-client-configuration proposal and alignment with temporalio/features#441.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        441
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/441 and https://github.com/temporalio/proposals/blob/master/all-sdk/external-client-configuration.md",
      "number": 490,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:29:48.442Z"
    },
    {
      "summary": "Feature request to provide last result and last failure information to workflows. This has already been implemented in PR #136.",
      "category": "feature",
      "subcategory": "workflow-state",
      "apis": [],
      "components": [
        "workflow-runtime",
        "workflow-context"
      ],
      "concepts": [
        "state-persistence",
        "error-handling",
        "workflow-history",
        "retry-logic"
      ],
      "severity": "low",
      "userImpact": "Workflows can now access the last execution result and failure information for better error recovery and conditional logic.",
      "rootCause": null,
      "proposedFix": "See feature issue #635 in the features repository",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Implementation already completed in PR #136",
      "related": [
        635,
        136
      ],
      "keyQuote": "Already done in #136",
      "number": 489,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:29:48.897Z"
    },
    {
      "summary": "Activity heartbeater is incorrectly accessing the current context to get the task token, but heartbeating should be allowed outside of context. The interceptor needs the task token provided through a different mechanism.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [
        "Heartbeat"
      ],
      "components": [
        "activity-heartbeater",
        "interceptor",
        "context-management"
      ],
      "concepts": [
        "heartbeat",
        "task-token",
        "context",
        "interceptor",
        "activity-execution"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably heartbeat activities outside of the activity context, limiting heartbeating flexibility and reliability.",
      "rootCause": "The outbound activity heartbeater retrieves the task token from the current activity context, which is not always available when heartbeating occurs outside of context.",
      "proposedFix": "Pass the task token to the interceptor through an alternative mechanism instead of requiring current context access.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        279
      ],
      "keyQuote": "we allow heartbeating outside of context. So we should give the interceptor the task token another way.",
      "number": 487,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:29:10.198Z"
    },
    {
      "summary": "OpenTelemetry TracingInterceptor doesn't create spans for workflow run methods, preventing trace ID correlation for workflow-level logs. While activities receive trace IDs, the workflow execution itself lacks tracing context.",
      "category": "bug",
      "subcategory": "opentelemetry-tracing",
      "apis": [
        "ExecuteActivityAsync",
        "WorkflowRun"
      ],
      "components": [
        "TracingInterceptor",
        "OpenTelemetry",
        "workflow-execution"
      ],
      "concepts": [
        "distributed-tracing",
        "trace-correlation",
        "activity-context",
        "span-creation",
        "workflow-replay",
        "deterministic-execution"
      ],
      "severity": "medium",
      "userImpact": "Users cannot correlate logs from workflow execution with activities using trace IDs, hindering observability and debugging of distributed workflows.",
      "rootCause": "The TracingInterceptor creates spans for activities but not for the workflow run method itself, leaving Activity.Current null in workflow execution context.",
      "proposedFix": null,
      "workaround": "Users can manually create ActivitySource spans and set parent ID using diaAct.Context.TraceId and diaAct.Context.SpanId within the workflow method.",
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by implementing span creation in the TracingInterceptor for workflow run methods to maintain consistent tracing context.",
      "related": [],
      "keyQuote": "OpenTelemetry span is not created by TracingInterceptor in workflow run methods.",
      "number": 480,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:29:11.429Z"
    },
    {
      "summary": "Implement a high-level client API for worker deployment control plane operations in the .NET SDK, following patterns from the Go SDK implementation.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "worker",
        "client",
        "control-plane"
      ],
      "concepts": [
        "worker-deployment",
        "versioning",
        "client-api",
        "control-plane",
        "high-level-client"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to manage worker deployments and versions through a high-level client API in the .NET SDK.",
      "rootCause": null,
      "proposedFix": "Create high-level client for worker deployment operations, using Go SDK implementation as reference",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Create the high-level client for control plane operations concerning worker deployments. See the Go one as an example",
      "number": 479,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:29:10.466Z"
    },
    {
      "summary": "Test flake detected in `CanRunWith_CustomSlotSupplier` where an assertion expects 20 but occasionally gets 21. The issue appears related to slot supplier behavior during worker shutdown and is suspected to be caused by a race condition in sdk-core.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "worker-tuning",
        "slot-supplier",
        "activity-worker"
      ],
      "concepts": [
        "test-flake",
        "race-condition",
        "slot-management",
        "worker-shutdown",
        "concurrency",
        "timing"
      ],
      "severity": "medium",
      "userImpact": "Intermittent test failures reduce confidence in the test suite and may block CI/CD pipelines.",
      "rootCause": "Almost certainly related to a race condition in sdk-core (issue temporalio/sdk-core#894) affecting slot supplier behavior during shutdown.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        894
      ],
      "keyQuote": "Almost certainly because of https://github.com/temporalio/sdk-core/issues/894",
      "number": 478,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:28:30.820Z"
    },
    {
      "summary": "Auto-time-skipping in WorkflowEnvironment may have a logic error where an assignment or conditional is reversed, potentially causing improper reset behavior.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "WorkflowEnvironment",
        "time-skipping",
        "test-utilities"
      ],
      "concepts": [
        "auto-time-skipping",
        "reset",
        "test-framework",
        "timing",
        "workflow-testing"
      ],
      "severity": "medium",
      "userImpact": "Tests using auto-time-skipping may not properly reset time state between test runs, leading to timing-related test failures.",
      "rootCause": "Assignment or conditional logic in WorkflowEnvironment.cs lines 323-338 appears to be reversed.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Specifically, https://github.com/temporalio/sdk-dotnet/blob/d48377d698b2a2cb7a8c58d181959df473875314/src/Temporalio/Testing/WorkflowEnvironment.cs#L323-L338 might have its assignment/conditional backwards.",
      "number": 471,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:28:29.659Z"
    },
    {
      "summary": "Update result serialization exceptions are silently swallowed due to the use of `task.ContinueWith`, preventing proper error surfacing. This needs to be fixed to surface serialization failures as task failures similar to regular update failures.",
      "category": "bug",
      "subcategory": "update-serialization",
      "apis": [],
      "components": [
        "update-handler",
        "task-continuation",
        "serialization"
      ],
      "concepts": [
        "error-handling",
        "exception-swallowing",
        "task-failure",
        "serialization",
        "async-continuation"
      ],
      "severity": "high",
      "userImpact": "Silent failures in update result serialization prevent developers from detecting and debugging serialization issues in their update handlers.",
      "rootCause": "The use of `task.ContinueWith` in the update implementation causes exceptions during result serialization to be swallowed rather than propagated.",
      "proposedFix": "Surface serialization failures as task failures following the same rules as regular update failures.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the serialization error handling was addressed to properly surface failures.",
      "related": [
        142
      ],
      "keyQuote": "when an exception occurs in update result serialization, it is swallowed. We need to make sure to surface this as a failure",
      "number": 465,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:28:30.002Z"
    },
    {
      "summary": "Feature request to add activity reset support to the .NET SDK, tracking alignment with a cross-SDK features issue.",
      "category": "feature",
      "subcategory": "activity-management",
      "apis": [],
      "components": [
        "activity-executor",
        "worker",
        "sdk-core"
      ],
      "concepts": [
        "activity-reset",
        "state-management",
        "feature-parity",
        "cross-sdk-support"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to reset activities in .NET SDK workflows, a capability available in other Temporal SDKs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Activity reset support was implemented in the .NET SDK as part of cross-SDK feature parity work.",
      "related": [
        620
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/620",
      "number": 464,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:27:48.982Z"
    },
    {
      "summary": "Unregistered local activities should cause workflow task failures instead of being silently ignored. This issue tracks a bug where the .NET SDK doesn't properly validate that local activities are registered before execution.",
      "category": "bug",
      "subcategory": "activity-execution",
      "apis": [
        "ExecuteLocalActivity"
      ],
      "components": [
        "workflow-executor",
        "activity-registry",
        "local-activity-handler"
      ],
      "concepts": [
        "activity-registration",
        "validation",
        "error-handling",
        "workflow-task-failure",
        "local-activities"
      ],
      "severity": "high",
      "userImpact": "Users may experience silent failures or unexpected behavior when workflows attempt to execute unregistered local activities, making debugging difficult.",
      "rootCause": "The SDK does not properly validate local activity registration before execution in workflow tasks.",
      "proposedFix": "Add validation to fail the workflow task when an unregistered local activity is encountered.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed via PR #472",
      "related": [
        221
      ],
      "keyQuote": "Unregistered Local Activity should fail Workflow Task",
      "number": 463,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:27:48.860Z"
    },
    {
      "summary": "Workflow info start time is using activation/task start time instead of the actual workflow start time from the initialize job. The team decided to document the current behavior and add a new field for workflow start time rather than changing the existing behavior for backwards compatibility.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "Workflow.Info",
        "StartTime",
        "WorkflowStartTime"
      ],
      "components": [
        "workflow-info",
        "task-execution",
        "initialization"
      ],
      "concepts": [
        "start-time",
        "workflow-lifecycle",
        "task-processing",
        "backwards-compatibility",
        "api-design"
      ],
      "severity": "medium",
      "userImpact": "Developers relying on Workflow.Info.StartTime get the task activation time instead of the actual workflow start time, which may cause timing-related bugs in their applications.",
      "rootCause": "The initialization process uses activation/task start time to populate workflow info start time instead of the start time from the initialize job.",
      "proposedFix": "Add a new Workflow.Info.WorkflowStartTime field representing the actual workflow start time while documenting that the existing StartTime field represents task start time.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Team decided to document that Workflow.Info.StartTime is the task start time and add a new Workflow.Info.WorkflowStartTime field for the actual workflow start time, avoiding a breaking change.",
      "related": [
        849
      ],
      "keyQuote": "we will document that `Workflow.Info.StartTime` is the task start time and add a new `Workflow.Info.WorkflowStartTime` representing workflow start time",
      "number": 462,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:27:51.155Z"
    },
    {
      "summary": "Update the .NET SDK's binary build GitHub workflow to use the native GH ARM runner instead of the BuildJet ARM runner, consistent with the change made for CI in issue #308.",
      "category": "feature",
      "subcategory": "ci-cd",
      "apis": [],
      "components": [
        "github-actions",
        "binary-build",
        "ci-workflow"
      ],
      "concepts": [
        "arm-architecture",
        "ci-cd",
        "build-automation",
        "github-runners"
      ],
      "severity": "low",
      "userImpact": "Users building on ARM architectures will benefit from improved build pipeline consistency and potentially reduced build times.",
      "rootCause": null,
      "proposedFix": "Replace BuildJet ARM runner with GH ARM runner in the build-binary workflow step, similar to the change made in #308 for CI.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The binary build workflow was updated to use the native GH ARM runner instead of BuildJet, aligning with CI infrastructure changes.",
      "related": [
        308
      ],
      "keyQuote": "#308 replaced BuildJet ARM runner for CI, but we didn't replace it for build-binary step",
      "number": 461,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:27:10.243Z"
    },
    {
      "summary": "Change workflow summary and details retrieval in the .NET client from eager decoding to lazy loading upon request for better performance.",
      "category": "feature",
      "subcategory": "client-api",
      "apis": [],
      "components": [
        "client",
        "workflow-execution",
        "data-deserialization"
      ],
      "concepts": [
        "lazy-loading",
        "performance-optimization",
        "memory-efficiency",
        "decoding",
        "client-api"
      ],
      "severity": "low",
      "userImpact": "Users will experience improved performance and reduced memory usage when retrieving workflow information in the .NET client.",
      "rootCause": null,
      "proposedFix": "Implement lazy decoding of workflow summary and details instead of eagerly decoding them.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Changed to lazy decoding of workflow summary/details on request.",
      "related": [],
      "keyQuote": "Today we eagerly decode these, change to be lazy upon request",
      "number": 460,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:27:09.642Z"
    },
    {
      "summary": "Feature request to add a warning when the server-provided task start time differs significantly from when the SDK begins processing the task.",
      "category": "feature",
      "subcategory": "task-processing",
      "apis": [],
      "components": [
        "task-processor",
        "time-tracking"
      ],
      "concepts": [
        "task-timing",
        "time-synchronization",
        "server-client-time-drift",
        "warning-system"
      ],
      "severity": "low",
      "userImpact": "Users would be warned when task processing time diverges from server expectations, potentially indicating timing issues.",
      "rootCause": null,
      "proposedFix": "Add warning mechanism when server-provided task start time differs significantly from SDK processing start time.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Deemed too niche for implementation.",
      "related": [
        616
      ],
      "keyQuote": "We're not gonna do this. Too niche.",
      "number": 459,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:27:10.568Z"
    },
    {
      "summary": "Memory corruption and segmentation faults occurring in ReserveCtxFromBridge when the server sends error responses (e.g., namespace not found), causing AccessViolationException and ArgumentNullException in .NET code that handles C bridge interop.",
      "category": "bug",
      "subcategory": "bridge-interop",
      "apis": [],
      "components": [
        "CustomSlotSupplier",
        "ByteArrayRef",
        "C-bridge-client"
      ],
      "concepts": [
        "memory-corruption",
        "segfault",
        "error-handling",
        "interop",
        "null-pointer",
        "array-bounds"
      ],
      "severity": "critical",
      "userImpact": "Workers crash with AccessViolationException or ArgumentNullException when the server returns error responses like namespace not found, making the SDK unstable in production.",
      "rootCause": "ReserveCtxFromBridge is not properly handling null or invalid pointers from the C bridge when error responses are received from the server, causing attempts to dereference protected memory or convert null byte arrays to strings.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by fixing the null pointer handling and validation in ReserveCtxFromBridge to properly handle error responses from the server.",
      "related": [],
      "keyQuote": "Fatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.",
      "number": 458,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:26:31.579Z"
    },
    {
      "summary": "Feature request to expose retry policy information on the ActivityInfo object, allowing users to inspect what retry policy is configured for an activity.",
      "category": "feature",
      "subcategory": "activity-info",
      "apis": [
        "ActivityInfo"
      ],
      "components": [
        "activity-executor",
        "worker",
        "activity-context"
      ],
      "concepts": [
        "retry-policy",
        "activity-configuration",
        "failure-handling",
        "observability",
        "activity-metadata"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently inspect the retry policy for an activity at runtime, limiting visibility into how failures will be handled.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, likely implemented based on the referenced feature issue #615 in temporalio/features repository.",
      "related": [
        615
      ],
      "keyQuote": "Show retry policy on activity info",
      "number": 457,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:26:30.348Z"
    },
    {
      "summary": "Apply application failure logging and metrics behavior according to ApplicationErrorCategory in the .NET SDK. This requires implementing corresponding logging behavior as core SDK handles metrics.",
      "category": "feature",
      "subcategory": "logging-metrics",
      "apis": [],
      "components": [
        "logging",
        "error-handling",
        "metrics"
      ],
      "concepts": [
        "application-errors",
        "error-categorization",
        "logging-behavior",
        "metrics",
        "failure-handling"
      ],
      "severity": "medium",
      "userImpact": "Users need consistent logging and metrics behavior for application failures based on error categories across SDKs.",
      "rootCause": null,
      "proposedFix": "Implement logging behavior according to ApplicationErrorCategory specification, coordinating with core SDK metrics handling.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed with logging behavior applied according to ApplicationErrorCategory, coordinated with core SDK.",
      "related": [
        614,
        897
      ],
      "keyQuote": "Core-based SDKs only need to apply corresponding logging behaviour, core handles metrics.",
      "number": 448,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:26:31.220Z"
    },
    {
      "summary": "Go SDK child workflows that return no value (nil/missing result) cause .NET parent workflows to hang indefinitely when awaiting completion. The issue stems from Go SDK omitting the result field entirely when a child workflow has no return value, which .NET SDK doesn't handle properly.",
      "category": "bug",
      "subcategory": "child-workflow-execution",
      "apis": [
        "ExecuteChildWorkflowAsync",
        "DelayAsync"
      ],
      "components": [
        "child-workflow-executor",
        "workflow-completion-handler",
        "sdk-interoperability"
      ],
      "concepts": [
        "cross-sdk-compatibility",
        "async-await",
        "event-serialization",
        "workflow-return-values",
        "task-completion"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably call Go child workflows from .NET parent workflows if the child returns no value, causing parent workflows to hang indefinitely.",
      "rootCause": "Go SDK omits the result field in ChildWorkflowExecutionCompleted events when a workflow returns nil, but .NET SDK expects this field to be present and fails to complete the async task when it's missing.",
      "proposedFix": "Go SDK should include an empty or null result payload in ChildWorkflowExecutionCompleted events even when the workflow returns no value, ensuring compatibility with other SDKs.",
      "workaround": "Child workflows in Go should return a non-null value (e.g., struct{}{}) when called from .NET parent workflows.",
      "resolution": "fixed",
      "resolutionDetails": "Go SDK was fixed to properly include result payloads in completion events to ensure cross-SDK compatibility.",
      "related": [],
      "keyQuote": "It looks like the Go SDK is omitting the result field when the Child Workflow return a nil value and that the .NET SDK is not expecting this field to be missing",
      "number": 445,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:25:52.719Z"
    },
    {
      "summary": "User wants to set an explicit Build ID on workers without enforcing the full UseWorkerVersioning validation checks. The SDK currently prevents setting a Build ID unless UseWorkerVersioning is explicitly enabled.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "TemporalWorkerService",
        "worker-configuration",
        "dependency-injection"
      ],
      "concepts": [
        "worker-versioning",
        "build-id",
        "configuration-validation",
        "semantic-versioning"
      ],
      "severity": "low",
      "userImpact": "Users cannot set explicit Build IDs for workers with semantic versioning without enabling the full UseWorkerVersioning feature.",
      "rootCause": "Strict validation in TemporalWorkerService.cs that requires UseWorkerVersioning to be enabled when a Build ID is provided.",
      "proposedFix": "Remove or relax the validation check that prevents setting Build ID without UseWorkerVersioning enabled.",
      "workaround": "Use ConfigureOptions() with custom Configure calls to bypass the DI integration restrictions, though this is complex and undocumented.",
      "resolution": "fixed",
      "resolutionDetails": "The strict validation check was removed, allowing Build ID to be set independently of UseWorkerVersioning.",
      "related": [],
      "keyQuote": "I have a stable semantic versioning and want to show the worker version via `Build Id`, but I don't want to use `UseWorkerVersioning`",
      "number": 442,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:25:52.292Z"
    },
    {
      "summary": "Activities should be interrupted when paused, including their heartbeating mechanisms. This issue tracks the need to ensure heartbeat operations respect the paused state of activities.",
      "category": "bug",
      "subcategory": "activity-heartbeat",
      "apis": [],
      "components": [
        "activity-executor",
        "heartbeat",
        "activity-lifecycle"
      ],
      "concepts": [
        "heartbeat",
        "activity-pause",
        "interruption",
        "activity-state",
        "lifecycle-management"
      ],
      "severity": "medium",
      "userImpact": "Activities continue heartbeating even when paused, potentially causing unnecessary communication and masking state management issues.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue has been closed, indicating the heartbeat interruption for paused activities has been resolved.",
      "related": [
        602
      ],
      "keyQuote": "Heartbeating activities should be interrupted when the activities are paused.",
      "number": 441,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:25:50.760Z"
    },
    {
      "summary": "Feature request to add support for passing arbitrary user data through the forwarded log callback in the C bridge. Currently, the logging callback doesn't support user data context similar to other callbacks, limiting functionality for low-level C bridge users.",
      "category": "feature",
      "subcategory": "c-bridge-logging",
      "apis": [],
      "components": [
        "c-bridge",
        "logging",
        "callback-system"
      ],
      "concepts": [
        "user-data",
        "callback-context",
        "c-interop",
        "logging-bridge",
        "extensibility"
      ],
      "severity": "low",
      "userImpact": "Low-level C bridge users cannot pass contextual user data through log callbacks, requiring workarounds for stateful logging scenarios.",
      "rootCause": null,
      "proposedFix": "Add `forward_to_user_data: *mut libc::c_void` field to `LoggingOptions` and update `ForwardedLogCallback` to support passing user data through the callback chain.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        423
      ],
      "keyQuote": "the ability to pass arbitrary user data through the callback similar to how done in other callbacks would be ideal",
      "number": 440,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:25:10.041Z"
    },
    {
      "summary": "User requests a helper method `ActivityDefinition.CreateWithoutAttribute` to allow custom runtime naming of activities without needing to subclass the sealed `ActivityAttribute`. This would enable reusable activity contract patterns using generics and custom naming logic.",
      "category": "feature",
      "subcategory": "activity-definition",
      "apis": [
        "ActivityDefinition.Create",
        "ActivityAttribute"
      ],
      "components": [
        "activity-definition",
        "activity-attributes",
        "reflection"
      ],
      "concepts": [
        "naming-strategy",
        "runtime-customization",
        "activity-contracts",
        "generics",
        "sealed-attributes",
        "reflection-based-invocation"
      ],
      "severity": "low",
      "userImpact": "Users wanting to implement reusable activity patterns with custom naming logic are currently forced to manually replicate internal helper methods or use dynamic approaches, reducing code maintainability.",
      "rootCause": "The `ActivityAttribute` is sealed per CA1813 recommendations, preventing subclassing for custom naming logic. The `ActivityDefinition.Create` overload requires manual parameter handling that duplicates internal logic.",
      "proposedFix": "Expose a helper method `ActivityDefinition.CreateWithoutAttribute(string? name, MethodInfo method, Func<object?[], object?> invoker)` that provides the same functionality as the reflection-based `Create` method but without requiring the attribute, similar to existing `WorkflowSignalDefinition.CreateWithoutAttribute`.",
      "workaround": "Users can use the `ActivityDefinition.Create` overload that accepts name and other parameters directly, though this requires manually handling parameter defaults and other internal logic.",
      "resolution": "fixed",
      "resolutionDetails": "The feature was accepted by the maintainers. They agreed to expose `ActivityDefinition.CreateWithoutAttribute` as a helper method to support custom runtime naming without attribute subclassing, accepting attribute options as parameters similar to existing patterns.",
      "related": [],
      "keyQuote": "We would be ok exposing a helper like: public static ActivityDefinition CreateWithoutAttribute(string? name, MethodInfo method, Func<object?[], object?> invoker)",
      "number": 439,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:25:13.054Z"
    },
    {
      "summary": "Feature request to add serialization context for codecs and converters in the .NET SDK, enabling better control over serialization behavior during workflow execution.",
      "category": "feature",
      "subcategory": "serialization",
      "apis": [],
      "components": [
        "codecs",
        "converters",
        "serialization"
      ],
      "concepts": [
        "serialization-context",
        "codec-customization",
        "converter-extension",
        "payload-handling"
      ],
      "severity": "medium",
      "userImpact": "Users need more control and context awareness when implementing custom serialization logic through codecs and converters.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented serialization context support for codecs and converters as requested in features issue #434",
      "related": [
        434
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/434",
      "number": 438,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:25:09.871Z"
    },
    {
      "summary": "Add support for the new Worker Versioning API to .NET SDK by implementing annotations on workflows. This feature request references the Go SDK implementation and design specifications for consistent cross-language support.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "workflow",
        "annotations",
        "worker"
      ],
      "concepts": [
        "versioning",
        "api-design",
        "worker-versioning",
        "cross-language-consistency",
        "sdk-feature-parity"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to leverage new worker versioning capabilities in .NET applications, enabling safer deployment and version management strategies.",
      "rootCause": null,
      "proposedFix": "Add workflow annotations to support the new versioning APIs as designed in the cross-language specification document and implemented in the Go SDK.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented with support for worker versioning API annotations in the .NET SDK.",
      "related": [
        548
      ],
      "keyQuote": "We need to add annotations to workflows to support the new versioning APIs. Refer to temporalio/features#548 for the Go equivalents.",
      "number": 437,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:24:31.469Z"
    },
    {
      "summary": "Feature request to add the ability to temporarily disable tracing event listener in workflows. Users need a way to selectively opt-out of tracing checks for small bits of code, such as a static method `WithTracingEventListenerDisabled<T>` in `Temporalio.Workflows.Workflow.Unsafe`.",
      "category": "feature",
      "subcategory": "tracing",
      "apis": [],
      "components": [
        "workflow",
        "tracing",
        "event-listener"
      ],
      "concepts": [
        "tracing",
        "event-listener",
        "workflow-execution",
        "instrumentation",
        "performance-optimization"
      ],
      "severity": "medium",
      "userImpact": "Users can now selectively disable tracing for performance-sensitive code sections without losing tracing for the rest of their workflows.",
      "rootCause": null,
      "proposedFix": "Add `static T WithTracingEventListenerDisabled<T>(Func<T>)` and `Action` equivalent methods to `Temporalio.Workflows.Workflow.Unsafe` class",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to allow temporary disabling of tracing event listeners in workflows",
      "related": [],
      "keyQuote": "Need something like `static T WithTracingEventListenerDisabled<T>(Func<T>)` so users can selectively opt-out of the tracing checks",
      "number": 436,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:24:31.119Z"
    },
    {
      "summary": "NLog async calls in workflows trigger non-determinism errors due to thread transfer tasks. A request for an unsafe API method to allow async logging without breaking workflow determinism.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "worker",
        "workflow-tracing",
        "event-listener"
      ],
      "concepts": [
        "logging",
        "non-determinism",
        "async-calls",
        "NLog",
        "HTTP-target",
        "thread-safety"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use async logging frameworks like NLog with HTTP targets in workflows without triggering non-determinism errors.",
      "rootCause": "NLog's AsyncTaskTarget.Write() performs thread transfer operations that violate workflow determinism requirements.",
      "proposedFix": "Expose an unsafe method in the .NET SDK for bypassing non-determinism checks specifically for logging purposes.",
      "workaround": "Set TemporalWorkerOptions.DisableWorkflowTracingEventListener to true, though this disables tracing protection globally.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        436
      ],
      "keyQuote": "Workflow attempted to perform a thread transfer task which is non-deterministic. This can be caused by timers or other non-deterministic async calls.",
      "number": 435,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:24:31.674Z"
    },
    {
      "summary": "Allow users to construct metric meter instances for testing purposes. Currently, MetricMeter is abstract with internal constructors, preventing users from creating test instances in ActivityEnvironment.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "MetricMeter",
        "ActivityEnvironment"
      ],
      "components": [
        "testing",
        "metrics",
        "activity-environment"
      ],
      "concepts": [
        "testing",
        "metrics",
        "constructors",
        "abstraction",
        "user-extensibility"
      ],
      "severity": "low",
      "userImpact": "Users cannot construct metric meter instances for testing activities, limiting test flexibility.",
      "rootCause": "MetricMeter abstract methods have internal constructors that prevent user construction.",
      "proposedFix": "Make protected constructors on MetricMeter that accept (string name, string? unit, string? description) and delegate to internal ones using MetricDetails.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Protected constructors were added to allow user construction of metric meters for testing.",
      "related": [],
      "keyQuote": "make `protected` constructors on each that accept `string name, string? unit, string? description`",
      "number": 430,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:23:50.865Z"
    },
    {
      "summary": "Feature request to add a summary field to Nexus operations in the .NET SDK, similar to functionality available in other Temporal SDKs. This would provide better documentation and visibility into operation metadata.",
      "category": "feature",
      "subcategory": "nexus",
      "apis": [
        "Nexus"
      ],
      "components": [
        "nexus",
        "operation",
        "sdk-dotnet"
      ],
      "concepts": [
        "nexus-operations",
        "metadata",
        "summary",
        "documentation",
        "operation-definition"
      ],
      "severity": "low",
      "userImpact": "Users would be able to document and describe Nexus operations with summary information, improving code clarity and API documentation.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to add summary support to Nexus operations",
      "related": [
        610
      ],
      "keyQuote": "Add summary to Nexus operation",
      "number": 428,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:23:49.730Z"
    },
    {
      "summary": "Workflow main body completes before all signal handlers finish when multiple signals arrive during continue-as-new, causing signal results to be lost. The issue occurs because event loop runs after each individual signal instead of batching signal processing.",
      "category": "bug",
      "subcategory": "signal-handling",
      "apis": [
        "WaitConditionAsync",
        "WhenAnyAsync",
        "CreateContinueAsNewException"
      ],
      "components": [
        "workflow-execution",
        "event-loop",
        "signal-handler"
      ],
      "concepts": [
        "signal-processing",
        "workflow-replay",
        "continue-as-new",
        "race-condition",
        "event-batching",
        "handler-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Users lose signal data when multiple signals arrive during continue-as-new operations, breaking workflow logic that depends on processing all signals.",
      "rootCause": "Event loop executes after every individual signal handler instead of batching all signals before evaluating wait conditions, allowing workflow main body to complete prematurely before subsequent handlers run.",
      "proposedFix": "Defer event loop execution until all pending signal handlers are marked in progress, rather than running event loop after each signal (relates to #384 revival).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue will be fixed by reviving #384 to ensure event loop doesn't run after every signal, with special handling to only apply to new code not replayed code.",
      "related": [
        384
      ],
      "keyQuote": "we run the event loop after every signal which is not the correct behavior. We will be fixing this soon (but will make sure it only applies to new code, not replayed code)",
      "number": 427,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:23:51.307Z"
    },
    {
      "summary": "Temporal .NET SDK needs Nexus implementation alongside the Nexus .NET SDK. This feature request references the cross-SDK Nexus specification work being tracked in the features repository.",
      "category": "feature",
      "subcategory": "nexus-integration",
      "apis": [],
      "components": [
        "sdk-core",
        "nexus-service"
      ],
      "concepts": [
        "nexus",
        "service-communication",
        "cross-sdk-feature",
        "api-integration"
      ],
      "severity": "high",
      "userImpact": "Users cannot use Nexus features in .NET SDK until the Temporal-specific implementation is completed alongside the Nexus .NET SDK.",
      "rootCause": null,
      "proposedFix": "Implement Temporal-specific Nexus support in the .NET SDK as specified in the features repository issue #609.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented Temporal-specific Nexus support in .NET SDK following the specification from the features repository.",
      "related": [
        609
      ],
      "keyQuote": "Alongside Nexus .NET SDK, need Temporal-specific implementation in this SDK.",
      "number": 426,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:23:09.879Z"
    },
    {
      "summary": "Move the Rust C bridge implementation from the .NET SDK to sdk-core to allow other language SDKs to reuse it without duplicating the C interfacing code.",
      "category": "feature",
      "subcategory": "sdk-core-integration",
      "apis": [],
      "components": [
        "c-bridge",
        "rust-interop",
        "sdk-core"
      ],
      "concepts": [
        "code-sharing",
        "interoperability",
        "rust-binding",
        "c-interface",
        "sdk-architecture"
      ],
      "severity": "low",
      "userImpact": "Enables other Temporal SDKs to leverage the existing Rust C bridge without maintaining separate implementations.",
      "rootCause": null,
      "proposedFix": "Move the Rust parts of the C bridge from the .NET SDK repository to the sdk-core repository.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was implemented and closed, moving the Rust bridge to sdk-core as requested.",
      "related": [],
      "keyQuote": "Move the Rust parts of the bridge to Core. There is nothing .NET related in the C bridge.",
      "number": 423,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:23:09.373Z"
    },
    {
      "summary": "Feature request to add ActivityOptions provider capability for testing in .NET SDK, similar to Java SDK. The request was closed after discussion clarified that cross-SDK approach is to set activity options in workflow at runtime rather than externally.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ActivityOptions"
      ],
      "components": [
        "workflow-runtime",
        "activity-executor",
        "test-framework"
      ],
      "concepts": [
        "activity-options",
        "testing",
        "test-isolation",
        "configuration-override",
        "cross-sdk-consistency"
      ],
      "severity": "low",
      "userImpact": "Users requesting ability to override activity options during testing without modifying production workflow code.",
      "rootCause": "Architectural decision to keep activity options configuration in workflow code at runtime rather than externally, unlike Java SDK.",
      "proposedFix": "Alter workflow input to opt-in to different options for test runs (e.g., 'test mode' flag) instead of external override capability.",
      "workaround": "Pass test mode configuration through workflow input parameters to conditionally apply different activity options.",
      "resolution": "wontfix",
      "resolutionDetails": "Intentional design decision: Java's external option setting approach can cause SDK inconsistencies. Recommended pattern is to control options through workflow input parameters.",
      "related": [],
      "keyQuote": "Java is the only SDK that allows setting default activity options outside of the workflow run itself... you set your activity options in the workflow at runtime.",
      "number": 421,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:23:12.246Z"
    },
    {
      "summary": "User requests a synchronous Run method for ActivityEnvironment in the testing API to unit test synchronous activity methods that use ActivityExecutionContext.Current.Logger without resorting to workarounds like mocking or async wrappers.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ActivityExecutionContext.Current.Logger",
        "ActivityEnvironment.RunAsync"
      ],
      "components": [
        "testing",
        "activity-environment",
        "activity-execution-context"
      ],
      "concepts": [
        "unit-testing",
        "synchronous-code",
        "logging",
        "test-utilities",
        "activity-testing"
      ],
      "severity": "low",
      "userImpact": "Users with synchronous activity helper methods cannot easily unit test them without workarounds like creating mock interfaces or converting methods to async.",
      "rootCause": "ActivityEnvironment only provides an async API (RunAsync) to support potential future asynchronous internal operations and consistency with TemporalWorker's async-only design.",
      "proposedFix": "Add a synchronous Run method to ActivityEnvironment that wraps the async RunAsync method for testing synchronous code.",
      "workaround": "Use myEnv.RunAsync(myActivity).GetAwaiter().GetResult() to run async code synchronously from a sync context.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "While internally in this testing framework thus far we do not use asynchronous pieces, we may in the future do so.",
      "number": 420,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:22:30.408Z"
    },
    {
      "summary": "WorkflowHandle is not mockable in unit tests because it's a record without virtual methods or interface implementation, preventing dynamic interceptors like FakeItEasy from mocking calls to SignalAsync and other methods.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "WorkflowHandle",
        "SignalAsync",
        "GetResultAsync"
      ],
      "components": [
        "WorkflowHandle",
        "client-interceptor",
        "test-support"
      ],
      "concepts": [
        "mocking",
        "testability",
        "unit-testing",
        "dynamic-interception",
        "interface-design",
        "virtual-methods"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot write unit tests with mocked WorkflowHandle dependencies, forcing them to use integration tests instead of isolated unit tests.",
      "rootCause": "WorkflowHandle is a sealed record without virtual methods or interface abstraction, preventing dynamic proxy-based mocking frameworks from intercepting method calls.",
      "proposedFix": "Mark WorkflowHandle methods as virtual or have WorkflowHandle implement an interface to enable dynamic interception.",
      "workaround": "Use client interceptors for SignalAsync interception; GetResultAsync non-typesafe overload is already virtual.",
      "resolution": "fixed",
      "resolutionDetails": "Maintainers indicated they would make the non-typesafe overload of SignalAsync virtual, and mentioned client interceptors as an existing solution for SignalAsync.",
      "related": [],
      "keyQuote": "the final non-typesafe overload of GetResultAsync is virtual, but SignalAsync can be intercepted using a client interceptor",
      "number": 419,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:22:30.712Z"
    },
    {
      "summary": "Codec implementations that return the original unaltered payload cause a KeyNotFoundException in the SDK. The issue occurs because the SDK assumes payloads are always mutated and doesn't check if the returned payload is the same object as the input.",
      "category": "bug",
      "subcategory": "codec-payload-handling",
      "apis": [],
      "components": [
        "codec",
        "payload-converter",
        "workflow-instance"
      ],
      "concepts": [
        "payload-mutation",
        "object-identity",
        "codec-design",
        "serialization",
        "reference-equality"
      ],
      "severity": "high",
      "userImpact": "Users cannot write codecs that return unaltered payloads without cloning, forcing unnecessary payload copying and causing runtime errors.",
      "rootCause": "WorkflowCodecHelper.cs lines 280-282 assume the encoded payload is always mutated and track it without checking if the returned payload is the same object reference as the input payload.",
      "proposedFix": "Add an `if (!Object.ReferenceEquals(encoded, payload))` check before the lines that assume the payload was mutated, allowing identity equality to bypass the mutation tracking.",
      "workaround": "Clone the payload before returning it from the codec, even if it wasn't actually modified.",
      "resolution": "fixed",
      "resolutionDetails": "Contributor provided a PR implementing reference equality check as suggested by maintainer to allow unaltered payloads to be returned without errors.",
      "related": [
        234
      ],
      "keyQuote": "I agree there is mixed messaging in that sample allows ignoring payloads but the SDK does not. So this is for sure a bug IMO.",
      "number": 417,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:22:31.197Z"
    },
    {
      "summary": "Feature request to expose custom histogram metric bucket size overrides in the .NET SDK, as implemented in sdk-core and already available in other SDKs via the features specification.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "histogram"
      ],
      "concepts": [
        "metric-customization",
        "histogram-buckets",
        "observability",
        "monitoring"
      ],
      "severity": "low",
      "userImpact": "Users cannot customize histogram bucket sizes for metrics in the .NET SDK, limiting observability customization compared to other SDKs.",
      "rootCause": null,
      "proposedFix": "Expose histogram bucket overrides made available in sdk-core PR #844",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [
        606
      ],
      "keyQuote": "Need to expose histogram bucket overrides made available in https://github.com/temporalio/sdk-core/pull/844",
      "number": 416,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:21:51.268Z"
    },
    {
      "summary": "Feature request to expose root workflow execution in the .NET SDK, dependent on upstream work in sdk-core and the features repository.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-execution",
        "sdk-core"
      ],
      "concepts": [
        "root-workflow",
        "execution-context",
        "workflow-hierarchy"
      ],
      "severity": "low",
      "userImpact": "Users need access to root workflow execution information for advanced workflow composition patterns.",
      "rootCause": null,
      "proposedFix": "Expose root workflow execution as per feature specification once sdk-core support is available.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed after dependent work in sdk-core and features repository was completed.",
      "related": [
        605,
        881
      ],
      "keyQuote": "Expose root workflow execution",
      "number": 415,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:21:51.762Z"
    },
    {
      "summary": "Feature request to ensure built-in query responses use 'RawValue' in the .NET SDK, as outlined in the cross-repository features issue #604.",
      "category": "feature",
      "subcategory": "queries",
      "apis": [
        "ExecuteQuery"
      ],
      "components": [
        "query-handler",
        "response-serialization"
      ],
      "concepts": [
        "queries",
        "raw-value",
        "response-format",
        "built-in-queries",
        "serialization"
      ],
      "severity": "low",
      "userImpact": "Users need built-in query responses to consistently use RawValue format for proper interoperability.",
      "rootCause": null,
      "proposedFix": "Implement RawValue usage in built-in query responses to match cross-repository specifications.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Built-in query responses were updated to use RawValue format.",
      "related": [
        604
      ],
      "keyQuote": "Make sure built-in queries return a raw value",
      "number": 414,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:21:51.248Z"
    },
    {
      "summary": "The .NET SDK should expose the cancel cause/reason field from WorkflowExecutionCancelRequestedEventAttributes when workflows receive cancellations, and allow users to specify this field when issuing cancellations from clients or commands.",
      "category": "feature",
      "subcategory": "workflow-cancellation",
      "apis": [
        "WorkflowExecutionCancelRequestedEventAttributes"
      ],
      "components": [
        "workflow-runtime",
        "client-api",
        "command-handler"
      ],
      "concepts": [
        "cancellation",
        "workflow-lifecycle",
        "event-attributes",
        "cause-tracking",
        "user-input"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access or provide cancellation reasons when cancelling workflows, limiting visibility into why workflows were terminated.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "WorkflowExecutionCancelRequestedEventAttributes has a cause field that should be exposed when workflows receive cancels",
      "number": 412,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:21:12.142Z"
    },
    {
      "summary": "Remove the experimental warning from the `RequestEagerStart` API option for eager workflow start in the .NET SDK. This is a documentation cleanup that depends on eager workflow start being officially marked as GA.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "RequestEagerStart",
        "StartWorkflow"
      ],
      "components": [
        "workflow-client",
        "documentation"
      ],
      "concepts": [
        "eager-start",
        "experimental-api",
        "ga-readiness",
        "workflow-options"
      ],
      "severity": "low",
      "userImpact": "Users currently see experimental warnings when using eager workflow start, which may cause confusion despite the feature being ready for general use.",
      "rootCause": null,
      "proposedFix": "Remove experimental doc warning from `RequestEagerStart` option once eager workflow start is officially GA",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by removing the experimental warning documentation from RequestEagerStart after eager workflow start was marked GA",
      "related": [],
      "keyQuote": "Remove experimental doc warning from eager workflow start option",
      "number": 409,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:21:13.137Z"
    },
    {
      "summary": "Feature request to include musl-based build in the NuGet package for the .NET SDK, referencing a cross-repository feature issue for standardization.",
      "category": "feature",
      "subcategory": "build-distribution",
      "apis": [],
      "components": [
        "nuget-package",
        "build-system"
      ],
      "concepts": [
        "musl",
        "alpine-linux",
        "binary-compatibility",
        "cross-platform-build",
        "package-distribution"
      ],
      "severity": "medium",
      "userImpact": "Users running Temporal .NET SDK in musl-based environments (Alpine Linux containers) cannot use the standard NuGet package.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed, indicating musl-based build support was added to the NuGet package distribution.",
      "related": [
        594
      ],
      "keyQuote": "Include musl-based build in NuGet package",
      "number": 408,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:21:12.420Z"
    },
    {
      "summary": "Add comprehensive tests to verify that signal handlers execute before workflow code wakes up and that multiple signals in the same task are processed correctly. The issue addresses concerns about signal processing order and timing in the .NET SDK's scheduler.",
      "category": "feature",
      "subcategory": "signal-handling",
      "apis": [
        "WaitConditionAsync",
        "WorkflowSignal",
        "WorkflowRun"
      ],
      "components": [
        "scheduler",
        "signal-handler",
        "workflow-execution",
        "task-queue"
      ],
      "concepts": [
        "signal-processing",
        "task-ordering",
        "FIFO-scheduling",
        "handler-execution",
        "workflow-state",
        "concurrency"
      ],
      "severity": "medium",
      "userImpact": "Users need assurance that signal handlers execute in the correct order and that multiple signals in a single task are fully processed before the workflow's main logic resumes.",
      "rootCause": "Uncertainty about whether multiple signals in the same task execute before workflow wake-up and whether the handlers-finished check is needed to guarantee this behavior.",
      "proposedFix": "Implement comprehensive tests covering: (1) two signals in same task result in expected count, (2) handlers-finished check effectiveness, (3) same assertions hold with unhandled commands like local activities.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed after feature request was addressed with test implementation",
      "related": [],
      "keyQuote": "If two signals are in the same task, is the workflow result `2`? With where wait conditions are checked this should be true in .NET",
      "number": 406,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:20:33.842Z"
    },
    {
      "summary": "Request to update the .NET SDK with the latest Cloud Operations API definitions, which are 8 months outdated. Users currently face namespace conflicts when trying to use newer Cloud Operations API versions alongside the .NET SDK, particularly needing the usage API for billing and activity tracking.",
      "category": "feature",
      "subcategory": "cloud-operations-api",
      "apis": [],
      "components": [
        "cloud-operations-api",
        "protobuf-definitions",
        "api-cloud"
      ],
      "concepts": [
        "api-versioning",
        "protobuf-management",
        "namespace-conflicts",
        "cloud-integration",
        "billing-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily use the latest Cloud Operations API versions with the .NET SDK without manual protobuf editing and compilation workarounds.",
      "rootCause": "The .NET SDK's bundled Cloud Operations API definitions become stale between SDK releases, and compiled protobuf definitions cause namespace conflicts with newer upstream versions.",
      "proposedFix": "Refresh Cloud Operations API definitions during .NET SDK releases, similar to how OSS API definitions are updated.",
      "workaround": "Users can manually edit and selectively compile Cloud Operations protobuf messages to avoid namespace conflicts.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was updated in #407 and released as version 1.5.0 of the .NET SDK.",
      "related": [
        407
      ],
      "keyQuote": "The current version of the Cloud Operations API included in the .NET SDK is 8 months old",
      "number": 404,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:20:34.339Z"
    },
    {
      "summary": "Feature request to add support for attaching priority levels to workflows and activities in the .NET SDK. This aligns with a cross-repository features initiative to enable priority-based task scheduling.",
      "category": "feature",
      "subcategory": "workflow-priority",
      "apis": [],
      "components": [
        "workflow-engine",
        "activity-executor",
        "task-routing"
      ],
      "concepts": [
        "priority",
        "scheduling",
        "task-management",
        "workflow-configuration",
        "resource-allocation"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to assign priority levels to workflows and activities, enabling more sophisticated task scheduling and resource management strategies.",
      "rootCause": null,
      "proposedFix": "Implement priority annotation support following the specification in temporalio/features#593",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support priority annotations on workflows and activities",
      "related": [
        593
      ],
      "keyQuote": "Add support for attaching priority to workflows/activities",
      "number": 403,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:20:32.704Z"
    },
    {
      "summary": "Feature request to expose read-only headers to activity info, similar to how headers are exposed in workflow info for use in interceptors like the update handler tracing interceptor.",
      "category": "feature",
      "subcategory": "activity-metadata",
      "apis": [
        "ActivityInfo"
      ],
      "components": [
        "activity-executor",
        "interceptors",
        "metadata-access"
      ],
      "concepts": [
        "headers",
        "metadata",
        "activity-info",
        "interceptors",
        "tracing",
        "read-only-access"
      ],
      "severity": "low",
      "userImpact": "Users working with activity interceptors would be able to access request headers for tracing and observability purposes.",
      "rootCause": null,
      "proposedFix": "Expose headers as read-only property on ActivityInfo, consistent with existing workflow info implementation.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "since we did it in workflow info (needed inside update handler tracing interceptor), we might as well for activities",
      "number": 402,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:19:54.408Z"
    },
    {
      "summary": "TLS connectivity fails in .NET 8 when using the latest SDK with AWS or Azure .NET images, showing 'native TLS certs not found' error. The issue only occurs when all three conditions are met: latest SDK, AWS/Azure image, and .NET 8.",
      "category": "bug",
      "subcategory": "tls-certificate-handling",
      "apis": [],
      "components": [
        "tls-certificate-resolution",
        "platform-integration",
        "aws-lambda",
        "azure-functions"
      ],
      "concepts": [
        "tls",
        "certificate-resolution",
        "native-certificates",
        "platform-images",
        "dotnet-8",
        "connectivity"
      ],
      "severity": "high",
      "userImpact": "Users deploying .NET 8 applications to AWS Lambda or Azure Functions with the latest SDK encounter TLS connectivity failures preventing deployment.",
      "rootCause": "Native TLS certificates are not properly resolved in AWS/Azure .NET 8 images when using the latest SDK version",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1973
      ],
      "keyQuote": "If you use the latest .NET SDK _and_ AWS/Azure .NET images _and_ use .NET 8, there is a TLS connectivity issue with 'native TLS certs not found'",
      "number": 401,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:19:54.792Z"
    },
    {
      "summary": "The WorkflowCodecHelper assumes a timer summary is non-null, but this assumption is incorrect. The code needs to be fixed and test coverage added.",
      "category": "bug",
      "subcategory": "codec",
      "apis": [],
      "components": [
        "WorkflowCodecHelper",
        "worker",
        "codec"
      ],
      "concepts": [
        "timer",
        "summary",
        "null-safety",
        "codec-handling",
        "test-coverage"
      ],
      "severity": "medium",
      "userImpact": "Workflows using codecs with timers may fail due to unhandled null summary values.",
      "rootCause": "WorkflowCodecHelper.cs line 196 assumes timer summary is non-null without validation.",
      "proposedFix": "Add null-check for summary before use and ensure proper handling of null case.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "At line 196, we assume the summary is non-null which is not correct. We need to fix this and we need to ensure coverage.",
      "number": 400,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:19:53.981Z"
    },
    {
      "summary": "Add explicit memoization support to the Patched() API by introducing a memoized argument while maintaining backward compatibility. The implementation should delegate memoization handling to Core.",
      "category": "feature",
      "subcategory": "workflow-patching",
      "apis": [
        "Patched",
        "DeprecatePatch"
      ],
      "components": [
        "patching-api",
        "core-delegation",
        "backward-compatibility"
      ],
      "concepts": [
        "memoization",
        "workflow-patching",
        "api-evolution",
        "deprecation",
        "core-integration"
      ],
      "severity": "low",
      "userImpact": "Enables developers to explicitly control memoization behavior in patched workflows, improving control over workflow versioning and upgrade strategies.",
      "rootCause": null,
      "proposedFix": "Add memoized argument to Patched and DeprecatePatch APIs, deprecate non-specifying signatures, update documentation with conversion guidance, and delegate logic handling to Core.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        591
      ],
      "keyQuote": "Add a `memoized` argument to the `Patched` and `DeprecatePatch` APIs.",
      "number": 398,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:19:15.693Z"
    },
    {
      "summary": "Feature request to allow customization of the development server UI port in the .NET SDK. This is a follow-up to a cross-SDK features discussion.",
      "category": "feature",
      "subcategory": "dev-server",
      "apis": [],
      "components": [
        "dev-server",
        "ui"
      ],
      "concepts": [
        "customization",
        "configuration",
        "port",
        "development",
        "server-ui"
      ],
      "severity": "low",
      "userImpact": "Developers would have more flexibility in configuring the development server UI port instead of using the default.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, likely implemented as part of the .NET SDK development server enhancements.",
      "related": [
        588
      ],
      "keyQuote": "Allow customization of dev server UI port",
      "number": 396,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:19:14.529Z"
    },
    {
      "summary": "RpcException with 'operation was canceled' error when calling DescribeNamespaceAsync in health check, occurring immediately without timeout. User questions whether sharing TemporalClient across threads is safe.",
      "category": "bug",
      "subcategory": "client-rpc",
      "apis": [
        "DescribeNamespaceAsync",
        "ConnectAsync"
      ],
      "components": [
        "temporal-client",
        "rpc-connection",
        "health-check"
      ],
      "concepts": [
        "cancellation",
        "concurrency",
        "threading",
        "connection-pooling",
        "rpc-error"
      ],
      "severity": "high",
      "userImpact": "Health check operations fail immediately with cancellation errors, preventing proper monitoring of Temporal connectivity in production environments.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Considering this timeout exception is being thrown immediately, should I not be sharing my TemporalClient across threads?",
      "number": 395,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:19:15.370Z"
    },
    {
      "summary": "Feature request to append workflow custom search attributes to activity tags in OpenTelemetry tracing to enable filtering traces by those attributes.",
      "category": "feature",
      "subcategory": "tracing-attributes",
      "apis": [
        "UpsertTypedSearchAttributes"
      ],
      "components": [
        "tracing-interceptor",
        "activity-tags",
        "opentelemetry"
      ],
      "concepts": [
        "search-attributes",
        "tracing",
        "span-tags",
        "opentelemetry",
        "workflow-context",
        "filtering"
      ],
      "severity": "low",
      "userImpact": "Users cannot easily filter traces by workflow search attributes, limiting observability and debugging capabilities.",
      "rootCause": "Search attributes are updated during workflow execution, but span tags are created upfront and not automatically updated with search attributes.",
      "proposedFix": "Extend TracingInterceptor to append workflow search attributes to RunWorkflow activity tags, with customization options via TracingInterceptorOptions.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Closed as not planned. SDK maintainers decided this should be a user responsibility via custom interceptor logic, potentially demonstrated in a sample.",
      "related": [
        393
      ],
      "keyQuote": "The ability to do this makes sense, yes, but not necessarily sure it's something we should do in the SDK.",
      "number": 394,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:18:37.573Z"
    },
    {
      "summary": "Request to expose ability for Core OTel metrics to use HTTP protocol instead of the default gRPC. This is a feature request to add a simple boolean flag to enable HTTP-based metrics collection.",
      "category": "feature",
      "subcategory": "observability",
      "apis": [],
      "components": [
        "metrics",
        "otel",
        "core"
      ],
      "concepts": [
        "observability",
        "metrics",
        "protocol",
        "http",
        "otel",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users will be able to configure OpenTelemetry metrics to be exported over HTTP instead of gRPC, providing more flexibility in observability setups.",
      "rootCause": null,
      "proposedFix": "Add a simple default-false http boolean configuration option to expose HTTP protocol support for Core OTel metrics",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        820
      ],
      "keyQuote": "Expose ability to have Core OTel metrics use HTTP instead of default gRPC protocol. Would recommend a simple default-false http boolean.",
      "number": 392,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:18:36.878Z"
    },
    {
      "summary": "Request for special handling of Temporal built-in prefixes in the .NET SDK, as defined in a cross-SDK features issue.",
      "category": "feature",
      "subcategory": "naming-conventions",
      "apis": [],
      "components": [
        "sdk-core",
        "workflow-runtime",
        "naming"
      ],
      "concepts": [
        "prefix-handling",
        "naming-convention",
        "built-in-types",
        "sdk-standardization"
      ],
      "severity": "low",
      "userImpact": "Users may encounter inconsistent behavior when using Temporal built-in prefixes across SDK implementations.",
      "rootCause": null,
      "proposedFix": "Implement special behavior for Temporal built-in prefixes as specified in temporalio/features#576",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented following standardization defined in cross-SDK features issue",
      "related": [
        576
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/576",
      "number": 391,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:18:37.356Z"
    },
    {
      "summary": "Feature request for F# samples and documentation in the .NET SDK to lower the barrier of entry for F# users. Users have encountered challenges with serialization of F# unions and need guidance on F# compatibility with Temporal.",
      "category": "feature",
      "subcategory": "samples-documentation",
      "apis": [],
      "components": [
        "samples",
        "documentation",
        "serialization",
        "data-converter"
      ],
      "concepts": [
        "F#-support",
        "language-interoperability",
        "documentation",
        "onboarding",
        "serialization",
        "async-integration"
      ],
      "severity": "low",
      "userImpact": "F# developers face higher barriers to entry and encounter undocumented serialization issues when working with Temporal workflows.",
      "rootCause": "Lack of F#-specific samples, documentation, and helper libraries; F# union serialization not supported by default JSON converter.",
      "proposedFix": "Create F#-specific samples and documentation; consider creating a `Temporalio.Extensions.FSharp` package with serialization helpers and workarounds for F# lambda expressions.",
      "workaround": "Use `FSharp.SystemTextJson` with custom `JsonFSharpConverter` and custom `DataConverter` configuration with explicit converter ordering.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        10
      ],
      "keyQuote": "Full featured F# support would be more than a sample probably, it'd be a `Temporalio.Extensions.FSharp` package with some helpers",
      "number": 390,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:17:59.555Z"
    },
    {
      "summary": "Feature request to allow users to access a Temporal client instance from within an activity by adding a Client property to ActivityExecutionContext, enabling activities to interact with the Temporal service.",
      "category": "feature",
      "subcategory": "activity-context",
      "apis": [
        "ActivityExecutionContext",
        "Client"
      ],
      "components": [
        "activity-executor",
        "client",
        "context"
      ],
      "concepts": [
        "client-access",
        "activity-execution",
        "context-properties",
        "inter-activity-communication"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently access the Temporal client from within activities, limiting their ability to interact with the Temporal service from activity code.",
      "rootCause": null,
      "proposedFix": "Add a Client instance property on ActivityExecutionContext to provide access to the Temporal client",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and the issue was closed",
      "related": [
        203
      ],
      "keyQuote": "Allow users to access Temporal client from within an activity. This is likely a `Client` instance property on `ActivityExecutionContext`.",
      "number": 389,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:17:58.895Z"
    },
    {
      "summary": "Feature request to expose workflow and activity instances through static properties (`Workflow.Instance` and `ActivityExecutionContext.Instance`) to enable access to the current execution context from within user code.",
      "category": "feature",
      "subcategory": "context-access",
      "apis": [
        "Workflow",
        "ActivityExecutionContext"
      ],
      "components": [
        "workflow-runtime",
        "activity-executor",
        "hosting-extensions"
      ],
      "concepts": [
        "instance-access",
        "context-binding",
        "async-local",
        "dependency-injection",
        "execution-context"
      ],
      "severity": "medium",
      "userImpact": "Users cannot easily access the current workflow or activity instance from within their code, limiting ability to introspect or interact with the execution context.",
      "rootCause": null,
      "proposedFix": "Add `Workflow.Instance` static property and `ActivityExecutionContext.Instance` instance property (possibly as extension method) to expose current instances during execution.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented - workflow and activity instances are now accessible via context properties.",
      "related": [
        572
      ],
      "keyQuote": "The created instance of the workflow class should be made available as `Workflow.Instance` static property.",
      "number": 388,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:17:59.511Z"
    },
    {
      "summary": "Add WorkflowLocal<T> feature to provide workflow-scoped variables similar to AsyncLocal, allowing users to store workflow-specific state that is isolated to each workflow execution.",
      "category": "feature",
      "subcategory": "workflow-state",
      "apis": [],
      "components": [
        "workflow-runtime",
        "context-management"
      ],
      "concepts": [
        "workflow-scoping",
        "thread-local-storage",
        "state-isolation",
        "workflow-context",
        "variable-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to efficiently manage workflow-local state without polluting the workflow context or managing manual state containers.",
      "rootCause": null,
      "proposedFix": "Implement WorkflowLocal<T> class that works similar to AsyncLocal, allowing public static readonly declarations that automatically scope to the current workflow",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        571
      ],
      "keyQuote": "a user can have `public static readonly WorkflowLocal<string> MyValue = new()`, and it works like `AsyncLocal`",
      "number": 387,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:17:19.290Z"
    },
    {
      "summary": "WaitConditionAsync currently wakes up all satisfied conditions simultaneously, making it impossible to guarantee a condition remains true after the wait. The request is to wake only a single condition at a time and re-evaluate the loop, enabling safe patterns like acquiring locks within wait conditions.",
      "category": "feature",
      "subcategory": "workflow-synchronization",
      "apis": [
        "WaitConditionAsync"
      ],
      "components": [
        "workflow-engine",
        "condition-evaluation",
        "async-coordination"
      ],
      "concepts": [
        "synchronization",
        "condition-semantics",
        "lock-safety",
        "race-conditions",
        "loop-reevaluation"
      ],
      "severity": "medium",
      "userImpact": "Users cannot safely implement atomic check-then-act patterns in workflows, such as acquiring locks within wait conditions, due to race conditions from simultaneous condition evaluation.",
      "rootCause": "Current implementation wakes all satisfied conditions at once rather than sequentially, preventing guarantee that conditions remain true after wake-up.",
      "proposedFix": "Modify WaitConditionAsync to wake only a single condition when satisfied, then re-run the entire loop to allow re-evaluation of all conditions.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        375,
        618
      ],
      "keyQuote": "We should only wake up a _single_ wait condition when satisfied and then run the entire loop again. This will allow you to implement things like acquiring locks atomically.",
      "number": 386,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:17:19.804Z"
    },
    {
      "summary": "Feature request to add support for Windows ARM64 (win-arm64) architecture in the .NET SDK. Users are increasingly using Windows on ARM devices, and the library should provide native support similar to Linux and macOS distributions.",
      "category": "feature",
      "subcategory": "platform-support",
      "apis": [],
      "components": [
        "native-bridge",
        "runtime-binaries",
        "nuget-package"
      ],
      "concepts": [
        "architecture-support",
        "platform-compatibility",
        "native-libraries",
        "arm64",
        "windows-runtime",
        "package-distribution"
      ],
      "severity": "high",
      "userImpact": "Windows ARM64 users currently cannot use the SDK natively and must manually install prebuilt DLLs from external sources or compile the bridge themselves.",
      "rootCause": "The win-arm64 native bridge DLL is not included in the NuGet package distribution, requiring manual workarounds for ARM64 users.",
      "proposedFix": "Include the win-arm64 native bridge DLL in the NuGet package by default. Alternatively, offer it as a separate NuGet package. Utilize GitHub Windows ARM runners for CI/CD integration.",
      "workaround": "Users can manually download the prebuilt win-arm64 bridge DLL from OneDrive and place it in the NuGet package cache at runtimes/win-arm64/native/ directory.",
      "resolution": "fixed",
      "resolutionDetails": "Support was added in version 1.7.0 and later releases (1.8.0, 1.9.0) with the win-arm64 native bridge DLL included in the package. GitHub Windows ARM runners became available for CI integration.",
      "related": [],
      "keyQuote": "Almost every other development tool works natively on ARM out of the box. Why the hesitation to include it by default when Linux and OSX both get it?",
      "number": 385,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:17:21.233Z"
    },
    {
      "summary": "Align .NET SDK's activation job application with TypeScript changes to apply all jobs to state before running the event loop, rather than waking up the event loop after each job.",
      "category": "feature",
      "subcategory": "event-loop-scheduling",
      "apis": [],
      "components": [
        "event-loop",
        "job-applicator",
        "activation-handler"
      ],
      "concepts": [
        "job-ordering",
        "event-loop-scheduling",
        "state-application",
        "activation",
        "synchronization"
      ],
      "severity": "medium",
      "userImpact": "Potential optimization of event loop behavior and alignment with TS SDK implementation patterns, though actual behavioral impact unclear.",
      "rootCause": "Difference in job application strategy between .NET and TypeScript SDKs; TS changed to batch job application before event loop execution.",
      "proposedFix": "Apply all jobs to state first, then run the event loop once, potentially gated behind a feature flag.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Decided to implement this change in #432, potentially gated behind the same flag as #386.",
      "related": [
        386,
        432,
        606,
        1488
      ],
      "keyQuote": "In TS, we changed this to apply jobs to state and then run the event loop",
      "number": 375,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:16:41.167Z"
    },
    {
      "summary": "GitHub Actions deprecated Node16-based actions in favor of Node20, which is incompatible with GLIBC 2.27 or earlier. This breaks .NET SDK CI workflows that rely on older Linux distros with GLIBC 2.24 for backward compatibility with customer environments.",
      "category": "bug",
      "subcategory": "ci-build",
      "apis": [],
      "components": [
        "ci-workflows",
        "docker-images",
        "native-artifacts"
      ],
      "concepts": [
        "compatibility",
        "glibc",
        "node-version",
        "github-actions",
        "linux-distros",
        "ci-cd"
      ],
      "severity": "high",
      "userImpact": "CI builds are failing and SDK releases may not work on customers' older Linux distributions that lack GLIBC 2.27 support.",
      "rootCause": "GitHub Actions Runner agent now enforces Node20 for all actions, deprecating Node16 support. Node20 requires GLIBC 2.27+, breaking compatibility with older Linux distros previously supported via GLIBC 2.24 Docker images.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by updating CI configuration to use Node20-compatible approaches or alternative build methods.",
      "related": [],
      "keyQuote": "Node20 is incompatible with GLIBC 2.27 or earlier, this no longer works, and our CI workflows are now failing.",
      "number": 373,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:16:41.653Z"
    },
    {
      "summary": "WorkflowAlreadyStartedException constructor incorrectly places workflow type in the run ID parameter position and doesn't properly accept workflow type. The exception needs a separate constructor that accepts workflow type with a nullable run ID, and the run ID property should be made nullable.",
      "category": "bug",
      "subcategory": "child-workflow-execution",
      "apis": [
        "WorkflowAlreadyStartedException"
      ],
      "components": [
        "exception-handling",
        "child-workflow-manager",
        "workflow-execution"
      ],
      "concepts": [
        "exception-design",
        "constructor-overloading",
        "child-workflows",
        "type-safety",
        "API-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users encounter confusing exception behavior when child workflows are already started, with incorrect parameter positioning making error handling and debugging difficult.",
      "rootCause": "WorkflowAlreadyStartedException constructor design places workflow type value in the run ID parameter, creating an API mismatch between the exception's purpose and its implementation.",
      "proposedFix": "Create a separate constructor that accepts workflow type with nullable run ID; expose workflow type property; make run ID property nullable.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by restructuring the exception constructor to properly accept workflow type and nullable run ID parameters.",
      "related": [],
      "keyQuote": "Child workflow already started throws WorkflowAlreadyStartedException, but not only does that not accept a workflow type, but it _requires_ a run ID and is accidentally putting the workflow type in the run ID's place.",
      "number": 371,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:16:41.147Z"
    },
    {
      "summary": "Feature request to add .NET runtime support information directly in the README instead of requiring users to check NuGet package details.",
      "category": "docs",
      "subcategory": "documentation",
      "apis": [],
      "components": [
        "readme",
        "documentation"
      ],
      "concepts": [
        "compatibility",
        "runtime-versions",
        "platform-support",
        "documentation",
        "user-guidance",
        "discoverability"
      ],
      "severity": "low",
      "userImpact": "Users need to check NuGet instead of finding .NET version support information in the README.",
      "rootCause": null,
      "proposedFix": "Add supported .NET runtimes list to README",
      "workaround": "Check NuGet package page for supported runtimes",
      "resolution": "fixed",
      "resolutionDetails": "README was updated to list supported .NET runtimes",
      "related": [],
      "keyQuote": "README should list supported .NET runtimes instead of requiring user to look at NuGet.",
      "number": 368,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:16:02.471Z"
    },
    {
      "summary": "Feature request to expose optional MethodInfo property on ActivityDefinition to allow users to perform reflection operations like checking attributes on the underlying method.",
      "category": "feature",
      "subcategory": "activity-definition",
      "apis": [
        "ActivityDefinition"
      ],
      "components": [
        "activity-definition",
        "reflection-api"
      ],
      "concepts": [
        "reflection",
        "metadata-access",
        "attributes",
        "method-info"
      ],
      "severity": "low",
      "userImpact": "Users who need to inspect activity method attributes or perform reflection-based operations will have direct access to MethodInfo without workarounds.",
      "rootCause": null,
      "proposedFix": "Add a MethodInfo? property to ActivityDefinition that exposes the underlying method when the definition was built from a method.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "MethodInfo property was added to ActivityDefinition to expose the underlying method when available.",
      "related": [],
      "keyQuote": "If the ActivityDefinition was built via a method, there should be no harm in exposing this method to callers (e.g. via a MethodInfo? property).",
      "number": 367,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:16:02.466Z"
    },
    {
      "summary": "Add DisableEagerExecution option to WorkerOptions to allow users to disable eager activity dispatch, enabling proper rate limiting via MaxTaskQueueActivitiesPerSecond since eager dispatch bypasses task queue rate limits.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "WorkerOptions"
      ],
      "components": [
        "worker",
        "activity-dispatcher",
        "task-queue"
      ],
      "concepts": [
        "eager-execution",
        "rate-limiting",
        "activity-dispatch",
        "task-queue",
        "configuration",
        "performance"
      ],
      "severity": "medium",
      "userImpact": "Users cannot properly apply rate limits to activities when eager dispatch is enabled, limiting their ability to control resource consumption.",
      "rootCause": null,
      "proposedFix": "Add DisableEagerExecution configuration option to WorkerOptions",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and added to WorkerOptions",
      "related": [],
      "keyQuote": "This is really needed in order to be able to use MaxTaskQueueActivitiesPerSecond, as current service can apply rate limits only from matching task queue",
      "number": 365,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:16:01.887Z"
    },
    {
      "summary": "ActivityInboundInterceptor needs access to the scoped IServiceProvider to handle cross-cutting concerns that depend on injected services. Currently, only Activities can use constructor injection, preventing interceptors from accessing scoped dependencies.",
      "category": "feature",
      "subcategory": "dependency-injection",
      "apis": [
        "ExecuteActivityAsync"
      ],
      "components": [
        "ActivityInboundInterceptor",
        "ServiceProvider",
        "dependency-injection",
        "interceptors"
      ],
      "concepts": [
        "dependency-injection",
        "cross-cutting-concerns",
        "scoped-services",
        "service-locator",
        "interceptor-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users cannot implement interceptors that depend on scoped services, forcing them to choose between using interceptors or injected dependencies.",
      "rootCause": "ActivityInboundInterceptor lacks access to the scoped IServiceProvider instance during ExecuteActivityAsync invocation, and the Temporalio.Worker.Interceptors namespace is intentionally agnostic of Microsoft.Extensions.DependencyInjection.",
      "proposedFix": "Implement a mechanism similar to ASP.NET's HttpContextAccessor to provide access to the scoped IServiceProvider within the interceptor context, keeping the knowledge about IServiceProvider separate from the agnostic interceptor components.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        364
      ],
      "keyQuote": "if a given cross-cutting concern depends on a service provided by the scoped IServiceProvider instance, this insulation can't be maintained because only Activities can have dependencies injected via constructor injection",
      "number": 363,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:15:16.439Z"
    },
    {
      "summary": "Request to improve error messaging when attempting to register workflows with dependency injection, which is not supported. The error message should explicitly clarify that DI is not supported and explain why workflows must be deterministic and self-contained.",
      "category": "feature",
      "subcategory": "error-messages",
      "apis": [],
      "components": [
        "workflow-registration",
        "error-handling"
      ],
      "concepts": [
        "dependency-injection",
        "determinism",
        "error-messaging",
        "workflow-instantiation"
      ],
      "severity": "low",
      "userImpact": "Users attempting to use dependency injection in workflows receive a cryptic error message that doesn't explain why DI is unsupported or what constraints workflows have.",
      "rootCause": null,
      "proposedFix": "Update the ArgumentException message to include: 'Dependency injection is not supported in workflows. Workflows must be deterministic and self-contained with a lifetime controlled by Temporal.'",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Error message was enhanced to clarify that DI is intentionally not supported and explain the determinism requirement.",
      "related": [],
      "keyQuote": "Dependency injection is not supported in workflows. Workflows must be deterministic and self-contained with a lifetime controlled by Temporal.",
      "number": 361,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:15:16.368Z"
    },
    {
      "summary": "Add automatic time-skipping for update results in the test framework, similar to the existing auto-skip behavior for workflow results. This improves testing experience in time-skipping testing environments.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "update-handler",
        "time-skipping"
      ],
      "concepts": [
        "time-skipping",
        "testing",
        "workflow-updates",
        "async-waiting",
        "test-utilities"
      ],
      "severity": "medium",
      "userImpact": "Users testing with the time-skipping feature must manually handle time advancement when waiting on update results, creating inconsistent and cumbersome test code.",
      "rootCause": null,
      "proposedFix": "Implement automatic time-skipping when waiting on update results, mirroring the existing implementation for workflow results.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        551
      ],
      "keyQuote": "We auto-skip time when waiting on workflow result, we need to do the same when waiting on update result.",
      "number": 360,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:15:23.994Z"
    },
    {
      "summary": "Add support for user metadata in .NET SDK by accepting optional static summary/details when starting workflows and timers, and optional summary for activities. Implement __temporal_workflow_metadata query handler to match feature parity with other SDKs.",
      "category": "feature",
      "subcategory": "user-metadata",
      "apis": [
        "StartWorkflow",
        "SignalWithStart",
        "Schedule",
        "CreateChildWorkflow",
        "CreateTimer",
        "ExecuteActivity"
      ],
      "components": [
        "workflow-client",
        "metadata-handler",
        "query-handler",
        "activity-executor"
      ],
      "concepts": [
        "user-metadata",
        "workflow-summary",
        "activity-summary",
        "metadata-query",
        "feature-parity"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently attach custom metadata to workflows, timers, and activities in the .NET SDK, limiting visibility and debugging capabilities compared to other SDKs.",
      "rootCause": null,
      "proposedFix": "Add optional parameters for static summary/details across all workflow start methods, summary for timers/activities, and implement __temporal_workflow_metadata query handler",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support user metadata across workflow starts, timers, and activities with __temporal_workflow_metadata query handling",
      "related": [
        486,
        830,
        1597
      ],
      "keyQuote": "Accept optional \"static summary\" and \"static details\" on all ways to start a workflow and populate user metadata with them",
      "number": 359,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:02:13.231Z"
    },
    {
      "summary": "Update Cargo dependencies to use a newer version of Tonic (newer than 0.12.1) to enable system CA certificate usage by default for secure connections.",
      "category": "feature",
      "subcategory": "dependencies",
      "apis": [],
      "components": [
        "tonic",
        "cargo-dependencies",
        "grpc-client"
      ],
      "concepts": [
        "certificate-management",
        "system-ca",
        "dependencies",
        "tls",
        "grpc",
        "security"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use system CA certificates by default with the current Tonic version, requiring manual certificate configuration.",
      "rootCause": "Tonic 0.12.1 does not use system CAs by default for certificate validation.",
      "proposedFix": "Update to a newer version of Tonic that supports system CA usage by default.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Tonic dependency was updated to a newer version supporting system CA certificates.",
      "related": [],
      "keyQuote": "Need to get the latest Tonic since we are on 0.12.1 and it is not using system CAs by default",
      "number": 358,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:02:11.964Z"
    },
    {
      "summary": "Activity returning Task<WorkflowHandle> causes unexpected serialization of the workflow handle (including sensitive client credentials) to workflow history. The issue occurs because WorkflowHandle contains a reference to TemporalClient with API keys and TLS options.",
      "category": "bug",
      "subcategory": "activity-serialization",
      "apis": [
        "StartWorkflowAsync",
        "WorkflowHandle"
      ],
      "components": [
        "activity-executor",
        "serialization",
        "client"
      ],
      "concepts": [
        "serialization",
        "credentials-leakage",
        "security",
        "task-return-types",
        "workflow-history"
      ],
      "severity": "high",
      "userImpact": "Developers may inadvertently leak sensitive Temporal client credentials (API keys, TLS certificates) to workflow history when activities return Task<WorkflowHandle>.",
      "rootCause": "WorkflowHandle is not intended to be serializable but becomes serializable through System.Text.Json. When returned from an activity, it serializes the entire handle including the embedded TemporalClient with sensitive configuration.",
      "proposedFix": "Rewrite activities to return Task instead of Task<WorkflowHandle>, using ContinueWith() for fire-and-forget patterns: startTask.ContinueWith(_ => Task.CompletedTask, TaskContinuationOptions.OnlyOnRanToCompletion).",
      "workaround": "Avoid returning WorkflowHandle from activities. Use async/await pattern without returning the handle, or use ContinueWith() for non-awaited operations.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "WorkflowHandle is not meant to be serializable (just coincidence that it works with System.Text.Json)",
      "number": 357,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T15:02:13.919Z"
    },
    {
      "summary": "Request to include update handler information and update ID in logging context for better observability when handling workflow state updates in .NET SDK.",
      "category": "feature",
      "subcategory": "logging-observability",
      "apis": [],
      "components": [
        "logging",
        "update-handler",
        "context"
      ],
      "concepts": [
        "observability",
        "logging-context",
        "update-handler",
        "debugging",
        "traceability"
      ],
      "severity": "low",
      "userImpact": "Users have better visibility into which update handler is being executed and its associated update ID when reviewing logs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Update handler and ID are now included in the logging context.",
      "related": [
        466
      ],
      "keyQuote": "Show update handler and ID in logging context",
      "number": 351,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:52:03.179Z"
    },
    {
      "summary": "Generic activity methods are not supported and fail at runtime with a reflection error. The issue should be caught eagerly during worker creation rather than failing at execution time.",
      "category": "bug",
      "subcategory": "activity-definition",
      "apis": [
        "ActivityDefinition"
      ],
      "components": [
        "activity-executor",
        "worker",
        "service-provider-extensions"
      ],
      "concepts": [
        "generic-types",
        "reflection",
        "runtime-validation",
        "worker-creation",
        "type-checking"
      ],
      "severity": "high",
      "userImpact": "Users cannot define activities with generic type parameters, causing runtime failures instead of early validation errors.",
      "rootCause": "Generic type parameters are not resolved at reflection time, causing late-bound operations to fail when the method is invoked.",
      "proposedFix": "Add eager validation at worker creation to detect and reject generic activity methods with a clear error message.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by adding validation to detect generic activity methods during worker initialization.",
      "related": [],
      "keyQuote": "Late bound operations cannot be performed on types or methods for which ContainsGenericParameters is true.",
      "number": 350,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:52:02.677Z"
    },
    {
      "summary": "Exception handling in ActivityWorker's failure processing catch block doesn't log the exception or set the task token, potentially swallowing critical failures that occur while handling other failures.",
      "category": "bug",
      "subcategory": "activity-error-handling",
      "apis": [
        "ActivityExecutionContext"
      ],
      "components": [
        "ActivityWorker",
        "error-handling",
        "task-token-management"
      ],
      "concepts": [
        "exception-handling",
        "error-recovery",
        "logging",
        "task-completion",
        "cancellation"
      ],
      "severity": "medium",
      "userImpact": "Critical failures occurring during error handling in activities may be silently swallowed, making debugging difficult and potentially leaving tasks in an incomplete state.",
      "rootCause": "The outer catch block in ActivityWorker doesn't properly handle exceptions that occur during failure processing (e.g., during cancellation token callbacks), missing both logging and task token assignment.",
      "proposedFix": "Log the exception and ensure the task token is set in the outer catch block that handles failures during failure processing.",
      "workaround": "Wrap cancellation token callbacks in try-catch to prevent exceptions from propagating into the failure handler.",
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we are not logging nor are we setting the task token... try to fail while processing a failure",
      "number": 349,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:52:03.306Z"
    },
    {
      "summary": "NuGet package vulnerability warnings are being treated as errors due to TreatWarningsAsErrors setting, causing dotnet build to fail when System.Text.Json and other system packages have known vulnerabilities.",
      "category": "bug",
      "subcategory": "dependency-management",
      "apis": [],
      "components": [
        "build-system",
        "nuget-package-management",
        "project-configuration"
      ],
      "concepts": [
        "security-vulnerability",
        "build-failure",
        "dependency-resolution",
        "compiler-warnings",
        "package-management"
      ],
      "severity": "high",
      "userImpact": "Developers cannot build the SDK solution due to NuGet audit warnings being converted to build errors when vulnerable dependencies are detected.",
      "rootCause": "System.Text.Json 8.0.4 and other system packages have known high-severity vulnerabilities; combined with TreatWarningsAsErrors=true, this causes NU1903 warnings to fail the build.",
      "proposedFix": "Update System.Text.Json dependency to a patched version and use <WarningsNotAsErrors>NU1903</WarningsNotAsErrors> in project configuration to allow builds to succeed while maintaining awareness of vulnerabilities.",
      "workaround": "Use <WarningsNotAsErrors>NU1903</WarningsNotAsErrors> in csproj to suppress treating NuGet audit warnings as errors.",
      "resolution": "fixed",
      "resolutionDetails": "Updated System.Text.Json dependency to a patched version and configured project to handle NuGet audit warnings appropriately.",
      "related": [
        356
      ],
      "keyQuote": "I wonder if a fresh build is pulling in fixed versions of those dependencies? Or is there some other setting governing this?",
      "number": 347,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:35:01.803Z"
    },
    {
      "summary": "Request to expose update-with-start operations via the .NET SDK, allowing workflows to be updated or created in a single operation.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [
        "UpdateWithStart"
      ],
      "components": [
        "client",
        "workflow-client",
        "update-handler"
      ],
      "concepts": [
        "workflow-update",
        "start-workflow",
        "idempotency",
        "operation-composition"
      ],
      "severity": "medium",
      "userImpact": "Users cannot efficiently update existing workflows or create them if they don't exist using a single API call.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Update-with-start operations were implemented and exposed in the .NET SDK.",
      "related": [],
      "keyQuote": "Expose update-with-start operations via the SDK",
      "number": 346,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:34:59.797Z"
    },
    {
      "summary": "Payload data is not properly cleared before being replaced in workflow codec operations. When incoming data is null or empty, the merge logic fails to replace existing data, leaving stale payload information.",
      "category": "bug",
      "subcategory": "payload-codec",
      "apis": [],
      "components": [
        "WorkflowCodecHelper",
        "payload-handling",
        "codec"
      ],
      "concepts": [
        "payload-clearing",
        "data-replacement",
        "merge-logic",
        "null-handling",
        "codec-processing"
      ],
      "severity": "medium",
      "userImpact": "Users may experience data leakage or incorrect payload handling when null/empty data is merged with existing payload state.",
      "rootCause": "The merge logic in WorkflowCodecHelper only clears metadata but relies on merge operations to replace Data. When incoming Data is null/empty, the merge fails to clear the existing data field.",
      "proposedFix": "Explicitly clear the Data field by setting it to ByteString.Empty (for proto) in addition to the existing metadata clearing logic at lines 326 and 225.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We need to be clearing the data too (for proto this will be `Data = payload.Data = ByteString.Empty`)",
      "number": 342,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:35:00.282Z"
    },
    {
      "summary": "OpenTelemetry metrics export to New Relic failed after upgrading to SDK version 1.3.0 due to a TLS configuration issue. The error 'Connecting to HTTPS without TLS enabled' was logged at DEBUG level instead of a higher level, making it invisible in production environments.",
      "category": "bug",
      "subcategory": "metrics-telemetry",
      "apis": [],
      "components": [
        "metrics-exporter",
        "opentelemetry",
        "tls-configuration",
        "logging"
      ],
      "concepts": [
        "metrics",
        "telemetry",
        "opentelemetry",
        "tls",
        "https",
        "error-handling",
        "logging-levels"
      ],
      "severity": "high",
      "userImpact": "Users cannot export metrics to New Relic via OpenTelemetry in version 1.3.0, and the error is silently logged at DEBUG level, making it undetectable in production.",
      "rootCause": "TLS configuration issue in the OpenTelemetry metrics exporter when connecting to HTTPS endpoints, introduced between versions 1.2.0 and 1.3.0.",
      "proposedFix": "Fix the TLS handling in the OpenTelemetry metrics exporter to properly support HTTPS connections and ensure errors are logged at appropriate levels.",
      "workaround": "Use SDK version 1.2.0 or rebuild from PR #344 branch to test the fix.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in version 1.3.1 release, as confirmed by maintainer comment.",
      "related": [
        344
      ],
      "keyQuote": "Connecting to HTTPS without TLS enabled",
      "number": 340,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:17:16.101Z"
    },
    {
      "summary": "RpcException failures from client_rpc_call invocations lack detailed error information compared to connection failures. The exception only contains a generic 'transport error' message without the underlying gRPC status code or detailed error source information that would aid debugging.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "Bridge",
        "RpcException",
        "client_rpc_call",
        "error-handling"
      ],
      "concepts": [
        "error-details",
        "gRPC-status",
        "transport-error",
        "debugging",
        "exception-messages",
        "error-context"
      ],
      "severity": "medium",
      "userImpact": "Users receive generic error messages from RPC failures that lack sufficient detail for effective debugging of connection and transport issues.",
      "rootCause": "The failureDetails from Tonic errors is not being properly extracted and included in RpcException messages; non-status errors from Tonic lack detailed source information in their fmt::Display representation.",
      "proposedFix": "Extract more detailed information from Tonic transport errors including gRPC status codes and underlying error sources (e.g., hyper::Error details) and include them in RpcException messages similar to how connection errors are formatted.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Having this kind of additional context available is very helpful for debugging problems. Doing a cursory search shows that `transport error` can have multiple different root causes.",
      "number": 337,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:17:16.897Z"
    },
    {
      "summary": "Cloud tests are not actually running on cloud due to a mismatch between expected and actual environment variable names. The CLI cloud tests use `TEMPORAL_CLIENT_*` env vars but the code expects `TEMPORAL_TEST_CLIENT_*` env vars.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "cloud-tests",
        "cli"
      ],
      "concepts": [
        "environment-variables",
        "configuration",
        "cloud-connectivity",
        "test-execution",
        "alignment"
      ],
      "severity": "high",
      "userImpact": "Cloud tests fail to execute against actual cloud environments because of environment variable name mismatches, preventing validation of SDK functionality in production-like conditions.",
      "rootCause": "Environment variable naming inconsistency between the test CLI and the test code expecting different prefixes (TEMPORAL_CLIENT_* vs TEMPORAL_TEST_CLIENT_*)",
      "proposedFix": "Bring the environment variable names into alignment by standardizing on one naming convention across the CLI and test code",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The environment variable naming was standardized to align the CLI cloud tests with the expected variable names in the code",
      "related": [],
      "keyQuote": "The CLI cloud tests are using env vars `TEMPORAL_CLIENT_TARGET_HOST`, `TEMPORAL_CLIENT_NAMESPACE`, `TEMPORAL_CLIENT_CERT`, and `TEMPORAL_CLIENT_KEY`. But the code is expecting env vars `TEMPORAL_TEST_CLIENT_TARGET_HOST`, `TEMPORAL_TEST_CLIENT_NAMESPACE`, `TEMPORAL_TEST_CLIENT_CERT`, and `TEMPORAL_TEST_CLIENT_KEY`.",
      "number": 333,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:17:15.076Z"
    },
    {
      "summary": "Add a `limit` parameter to `ReplayWorkflowsAsync` method to control the number of workflows replayed, improving performance when replaying large workflow histories. This aligns with similar functionality in the Python SDK.",
      "category": "feature",
      "subcategory": "workflow-replay",
      "apis": [
        "ReplayWorkflowsAsync"
      ],
      "components": [
        "replay-engine",
        "workflow-executor",
        "async-enumerable"
      ],
      "concepts": [
        "replay",
        "limit",
        "performance",
        "batch-processing",
        "workflow-history"
      ],
      "severity": "medium",
      "userImpact": "Users replaying workflows will be able to control throughput and memory usage by limiting the number of concurrent or processed replays.",
      "rootCause": null,
      "proposedFix": "Add a `limit` parameter to both overloads of `ReplayWorkflowsAsync`, with the `IAsyncEnumerable` version being the primary use case.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to add limit parameter to ReplayWorkflowsAsync method for consistency with Python SDK.",
      "related": [
        610
      ],
      "keyQuote": "ReplayWorkflowsAsync should take limit parameter - same justification as Python SDK issue #610",
      "number": 332,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:01:14.995Z"
    },
    {
      "summary": "The WorkflowUpdateOptions RPC documentation has a copy-paste error that incorrectly states 'for starting the workflow' when it should say 'for sending the update'. This misleading documentation needs correction.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [
        "WorkflowUpdateOptions"
      ],
      "components": [
        "documentation",
        "api-reference",
        "client-sdk"
      ],
      "concepts": [
        "documentation-accuracy",
        "copy-paste-error",
        "api-docs",
        "workflow-update",
        "clarity"
      ],
      "severity": "low",
      "userImpact": "Developers reading the API documentation may be confused about the purpose of RPC options in WorkflowUpdateOptions.",
      "rootCause": "Copy-paste error in documentation where the description was duplicated from a different method without updating the context.",
      "proposedFix": "Update the docstring to read 'Gets or sets RPC options for sending the update' instead of 'for starting the workflow'.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation string corrected to accurately reflect that RPC options apply to sending updates, not starting workflows.",
      "related": [],
      "keyQuote": "This should be more like 'for sending the update'.",
      "number": 331,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:01:15.517Z"
    },
    {
      "summary": "Non-determinism error occurring during fuzzing with KitchenSinkWorkflow where activity machine fails to handle HistoryEvent. The issue was identified through the OMES fuzzer and reproduced via workflow replayer with specific seed.",
      "category": "bug",
      "subcategory": "workflow-replay",
      "apis": [
        "WorkflowReplayer",
        "WorkflowHistory"
      ],
      "components": [
        "workflow-replayer",
        "activity-machine",
        "history-handler"
      ],
      "concepts": [
        "non-determinism",
        "fuzzing",
        "history-replay",
        "event-handling",
        "workflow-execution",
        "activity-lifecycle"
      ],
      "severity": "high",
      "userImpact": "Users cannot reliably replay workflows that were generated through fuzzing, causing workflow replayer to fail with non-determinism exceptions.",
      "rootCause": "Activity machine does not handle certain HistoryEvent types (HistoryEvent id: 1182, StartChildWorkflowExecutionInitiated) during replay, causing non-deterministic behavior.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in sdk-core version 1.3.1 release. The issue was identified as a core problem in sdk-core/issues/803.",
      "related": [
        803
      ],
      "keyQuote": "Activity machine does not handle this event: HistoryEvent(id: 1182, StartChildWorkflowExecutionInitiated)",
      "number": 330,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T14:01:15.429Z"
    },
    {
      "summary": "Request to clarify in README that CancellationTokenSource.CancelAsync (added in .NET 8) uses the default scheduler and is unsafe for Temporal workflows. Users should use Cancel instead.",
      "category": "docs",
      "subcategory": "documentation",
      "apis": [],
      "components": [
        "cancellation-handling",
        "readme"
      ],
      "concepts": [
        "cancellation-token",
        "scheduler",
        "thread-safety",
        ".net8",
        "documentation"
      ],
      "severity": "low",
      "userImpact": "Users may incorrectly use CancellationTokenSource.CancelAsync in their Temporal workflows, leading to potentially unsafe behavior due to the default scheduler.",
      "rootCause": "CancellationTokenSource.CancelAsync uses the default scheduler, which is incompatible with Temporal's threading model.",
      "proposedFix": "Add clarification to README documenting that CancellationTokenSource.CancelAsync is unsafe and users should use Cancel instead.",
      "workaround": "Users should use CancellationTokenSource.Cancel instead of CancelAsync.",
      "resolution": "fixed",
      "resolutionDetails": "Documentation was clarified in README to warn against using CancellationTokenSource.CancelAsync.",
      "related": [],
      "keyQuote": "CancellationTokenSource.CancelAsync was added in .NET 8 and it uses the default scheduler. Users should use Cancel instead.",
      "number": 327,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:54:58.870Z"
    },
    {
      "summary": "Request to suppress warnings for unfinished handlers when a workflow fails, while continuing to warn for cancelled or continued-as-new workflows.",
      "category": "feature",
      "subcategory": "error-handling",
      "apis": [],
      "components": [
        "workflow-executor",
        "error-handler"
      ],
      "concepts": [
        "workflow-failure",
        "handler-lifecycle",
        "warning-suppression",
        "workflow-cancellation"
      ],
      "severity": "low",
      "userImpact": "Users experience unnecessary warnings when workflows fail, reducing signal quality for actual issues with cancelled or continued-as-new workflows.",
      "rootCause": null,
      "proposedFix": "Modify the handler completion warning logic to exclude failed workflow scenarios while maintaining warnings for cancelled and continued-as-new cases.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented selective warning suppression for workflow failures while preserving warnings for cancellation and continued-as-new scenarios.",
      "related": [
        294
      ],
      "keyQuote": "we need to not warn on failed workflow (not to be confused with cancelled or continued-as-new which we _do_ want to continue to warn on)",
      "number": 325,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:54:58.010Z"
    },
    {
      "summary": "Request to document the default RPC timeout values in RPC options documentation. The .NET SDK applies internally-set default timeouts per RPC call, but these defaults are not documented, making it unclear what timeout is used when RPC options are left null/unset.",
      "category": "docs",
      "subcategory": "rpc-configuration",
      "apis": [],
      "components": [
        "rpc-options",
        "documentation"
      ],
      "concepts": [
        "rpc-timeout",
        "default-values",
        "configuration",
        "long-poll",
        "documentation",
        "api-clarity"
      ],
      "severity": "low",
      "userImpact": "Users are unaware of the actual RPC timeout values applied when they don't explicitly set RPC options, leading to confusion about request timing behavior.",
      "rootCause": null,
      "proposedFix": "Document the default RPC timeout values in the RPC options documentation, noting that different values apply for long poll calls versus other calls.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "There is a max RPC timeout that is on each call (different value for long poll calls). Try to document it generally in the RPC options",
      "number": 321,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:54:57.699Z"
    },
    {
      "summary": "Add support for WorkflowIdConflictPolicy parameter to the Signal-With-Start API in the .NET SDK, following the implementation already added to StartWorkflow in PR #304.",
      "category": "feature",
      "subcategory": "signal-with-start",
      "apis": [
        "SignalWithStart",
        "StartWorkflow"
      ],
      "components": [
        "signal-with-start",
        "workflow-client",
        "api"
      ],
      "concepts": [
        "workflow-id-conflict",
        "idempotency",
        "signal",
        "workflow-start",
        "policy"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to specify conflict resolution behavior when signaling workflows that may not exist, enabling more flexible workflow initiation patterns.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implementation completed to match StartWorkflow API capabilities",
      "related": [
        304,
        437
      ],
      "keyQuote": "This is a follow-up to #304 which added it to StartWorkflow.",
      "number": 316,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:38:43.847Z"
    },
    {
      "summary": "Feature request to add support for schedule search attribute updates in the .NET SDK, following the pattern established in the Go SDK implementation.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [],
      "components": [
        "search-attributes",
        "schedule-api"
      ],
      "concepts": [
        "search-attributes",
        "schedule",
        "workflow-execution",
        "temporal-features"
      ],
      "severity": "medium",
      "userImpact": "Users cannot update search attributes on schedules in the .NET SDK, limiting visibility and queryability of scheduled workflows.",
      "rootCause": null,
      "proposedFix": "Implement schedule search attribute update support following the Go SDK implementation pattern",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support schedule search attribute updates in .NET SDK",
      "related": [
        512,
        1561
      ],
      "keyQuote": "Support schedule search attribute update",
      "number": 314,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:38:43.915Z"
    },
    {
      "summary": "Update the SDK's command reordering logic to align with Core's new approach of moving the first workflow completion command last, while properly handling multiple completion commands and maintaining backward compatibility.",
      "category": "feature",
      "subcategory": "workflow-completion",
      "apis": [],
      "components": [
        "command-reordering",
        "workflow-executor",
        "completion-handler"
      ],
      "concepts": [
        "command-reordering",
        "workflow-completion",
        "backward-compatibility",
        "command-sequencing"
      ],
      "severity": "medium",
      "userImpact": "Users will benefit from more efficient and correct command ordering during workflow completion, matching Core's implementation.",
      "rootCause": null,
      "proposedFix": "Align SDK command reordering to move first completion command last instead of truncating after last completion, and properly handle multiple completion commands.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation updated to match Core's command reordering approach for workflow completion handling.",
      "related": [],
      "keyQuote": "Core now has command reordering to move first workflow completion last. We had a poor attempt at this before in two ways: first was only truncate after _last_ completion command (as opposed to new Core which is after _first_ completion command), and second didn't account for multiple completion commands.",
      "number": 312,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:38:43.423Z"
    },
    {
      "summary": "Update the default schedule policy timeout value from the current value to 1 year to match the server default, as specified in the Temporal API changes. The team decided to update the client-side default value rather than making it fully optional.",
      "category": "feature",
      "subcategory": "schedules",
      "apis": [],
      "components": [
        "SchedulePolicy",
        "schedules-client"
      ],
      "concepts": [
        "default-values",
        "schedule-timeout",
        "api-alignment",
        "server-defaults"
      ],
      "severity": "low",
      "userImpact": "Users will have a corrected default schedule timeout value that matches server expectations, ensuring consistent behavior.",
      "rootCause": null,
      "proposedFix": "Change SchedulePolicy.cs default timeout value to 1 year to match server default",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Default value was updated to match the server default",
      "related": [
        308
      ],
      "keyQuote": "For now it was decided to just change this default value to match server default",
      "number": 311,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:21:48.161Z"
    },
    {
      "summary": "Request to replace the current time handling in workflows with .NET's System.TimeProvider API, which provides a standard abstraction for timers and time retrieval. The feature should expose a Workflow.TimeProvider property for testing purposes while maintaining the default behavior without magic.",
      "category": "feature",
      "subcategory": "time-provider",
      "apis": [
        "Workflow.TimeProvider"
      ],
      "components": [
        "workflow-runtime",
        "time-handling",
        "testing-framework"
      ],
      "concepts": [
        "time-provider",
        "timers",
        "testing",
        "abstraction",
        "dependency-injection"
      ],
      "severity": "medium",
      "userImpact": "Enables users to write more testable workflows by providing access to a standard .NET TimeProvider abstraction for mocking time in tests.",
      "rootCause": null,
      "proposedFix": "Leverage System.TimeProvider API to provide a Workflow.TimeProvider property and consider support for Microsoft.Extensions.TimeProvider.Testing for backward compatibility with .NET 6.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Leverage it. See https://learn.microsoft.com/en-us/dotnet/api/system.timeprovider. Will have to see how it may affect versions we release packages for.",
      "number": 307,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:21:48.661Z"
    },
    {
      "summary": "The .NET SDK incorrectly handles multiple completion commands by truncating non-query commands that appear after completion commands. This needs to be fixed to send all commands to core, allowing the core runtime to properly handle interleaved completion and non-completion commands.",
      "category": "bug",
      "subcategory": "command-handling",
      "apis": [],
      "components": [
        "command-handler",
        "completion-logic",
        "core-integration"
      ],
      "concepts": [
        "completion-commands",
        "command-ordering",
        "command-truncation",
        "core-sync",
        "workflow-execution"
      ],
      "severity": "medium",
      "userImpact": "Users with workflows that have multiple completion commands may experience incorrect command handling and execution.",
      "rootCause": "The logic added in PR #270 incorrectly truncates non-query commands that appear after completion commands, which is now being fixed in core.",
      "proposedFix": "Send all commands to core with potentially multiple completion commands interleaved with non-completions, rather than truncating post-completion commands.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        270,
        778
      ],
      "keyQuote": "send all commands to core i.e. with (potentially multiple) completion commands interleaved with non-completions",
      "number": 305,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:21:47.905Z"
    },
    {
      "summary": "Feature request to create wrapper methods on the Workflow class for commonly-used async task functions like WhenAllAsync and StartNewTask, similar to existing WhenAnyAsync and DelayAsync wrappers, to provide users with confidence in using these standard library calls.",
      "category": "feature",
      "subcategory": "workflow-api",
      "apis": [
        "WhenAllAsync",
        "WhenAnyAsync",
        "DelayAsync",
        "StartNewTask"
      ],
      "components": [
        "workflow-class",
        "async-wrappers",
        "task-methods"
      ],
      "concepts": [
        "async-safety",
        "workflow-api-design",
        "developer-confidence",
        "standard-library-wrappers",
        "task-composition"
      ],
      "severity": "low",
      "userImpact": "Users have to use standard library task functions directly instead of having safe wrapper methods on the Workflow class, reducing confidence in their usage.",
      "rootCause": null,
      "proposedFix": "Add Workflow wrapper methods for WhenAllAsync, StartNewTask, and other common/popular standard library task functions as one-liners to the underlying implementations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Wrapper methods were implemented to provide safe alternatives to standard library async calls.",
      "related": [],
      "keyQuote": "We might as well add Workflow.WhenAllAsync, Workflow.StartNewTask, and any other common/popular standard library task functions",
      "number": 303,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:04:36.950Z"
    },
    {
      "summary": "Feature request to add query support when listing schedules in the .NET SDK, matching the existing functionality available for listing workflows.",
      "category": "feature",
      "subcategory": "schedule-listing",
      "apis": [
        "ListSchedules"
      ],
      "components": [
        "schedule-client",
        "list-schedules",
        "query-support"
      ],
      "concepts": [
        "query",
        "filtering",
        "schedule-listing",
        "api-parity",
        "workflow-equivalence"
      ],
      "severity": "low",
      "userImpact": "Users cannot filter schedules using query parameters when listing, reducing discoverability and management capabilities compared to workflow listing.",
      "rootCause": null,
      "proposedFix": "Add query option parameter to the ListSchedules API call, matching the implementation pattern used for ListWorkflows.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Query support was implemented for schedule listing to achieve API parity with workflow listing functionality.",
      "related": [],
      "keyQuote": "Need to support the query option when listing schedules same as we do when listing workflows.",
      "number": 300,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:04:36.630Z"
    },
    {
      "summary": "Feature request to throw RpcException with gRPC details when the initial GetSystemInfo call fails during client connection, rather than a generic connection failure exception.",
      "category": "feature",
      "subcategory": "client-connection",
      "apis": [
        "GetSystemInfo"
      ],
      "components": [
        "client",
        "connection-handler",
        "grpc-client"
      ],
      "concepts": [
        "error-handling",
        "grpc-details",
        "connection-failure",
        "exception-types",
        "permission-errors"
      ],
      "severity": "medium",
      "userImpact": "Developers will receive more specific gRPC error details when initial client connection fails due to permission or other gRPC issues, enabling better debugging and error handling.",
      "rootCause": null,
      "proposedFix": "Distinguish between TCP connection failures and gRPC call failures; return RpcException with gRPC details when GetSystemInfo call fails after successful TCP connection.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "If the TCP connection succeeds but the gRPC call fails (e.g. permission denied), throw the `RpcException` with gRPC details instead of a common exception",
      "number": 299,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:04:36.140Z"
    },
    {
      "summary": "Add a Mutex class as a thin facade over Semaphore with a single-count configuration, matching .NET threading mutex method names like WaitOne and ReleaseMutex.",
      "category": "feature",
      "subcategory": "workflow-synchronization",
      "apis": [
        "Semaphore"
      ],
      "components": [
        "workflows-module",
        "synchronization-primitives"
      ],
      "concepts": [
        "mutex",
        "semaphore",
        "locking",
        "concurrency",
        "facade-pattern",
        "thread-safety"
      ],
      "severity": "low",
      "userImpact": "Developers working with workflows can use a simpler, more intuitive Mutex API that aligns with familiar .NET threading conventions.",
      "rootCause": null,
      "proposedFix": "Create Temporalio.Workflows.Mutex class as a wrapper around Semaphore initialized with count=1, implementing WaitOne and ReleaseMutex methods.",
      "workaround": "Use Semaphore directly with a single-count initialization.",
      "resolution": "fixed",
      "resolutionDetails": "Mutex facade was implemented as a thin wrapper over single-count Semaphore.",
      "related": [],
      "keyQuote": "Add Temporalio.Workflows.Mutex as thin facade over single-count Temporalio.Workflows.Semaphore",
      "number": 297,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:03:57.745Z"
    },
    {
      "summary": "Request to replace BuildJet ARM runner with GitHub's native ARM runner now that it's available.",
      "category": "feature",
      "subcategory": "ci-cd",
      "apis": [],
      "components": [
        "ci-infrastructure",
        "github-actions"
      ],
      "concepts": [
        "arm-runner",
        "ci-pipeline",
        "github-actions",
        "build-infrastructure",
        "cost-optimization"
      ],
      "severity": "low",
      "userImpact": "Simplifies CI/CD pipeline maintenance and potentially reduces build costs by using GitHub's native runners instead of third-party alternatives.",
      "rootCause": null,
      "proposedFix": "Replace BuildJet ARM runner with GitHub's native ARM runner.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "GitHub's native ARM runner is now available and can replace BuildJet.",
      "related": [],
      "keyQuote": "Now that GH has ARM runners, might as well",
      "number": 292,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:03:56.996Z"
    },
    {
      "summary": "The .NET SDK needs enhanced test workflow replay capabilities. Currently tests don't replay workflows or run without cache, which could miss issues. The request is to auto-replay workflows that complete in tests to improve test coverage.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "workflow-replay",
        "cache-management"
      ],
      "concepts": [
        "test-replay",
        "workflow-execution",
        "cache-invalidation",
        "test-coverage",
        "determinism",
        "reproducibility"
      ],
      "severity": "medium",
      "userImpact": "Users cannot thoroughly test their workflows, leaving potential issues undetected due to missing replay and cache validation during test runs.",
      "rootCause": null,
      "proposedFix": "Implement auto-replay of workflows that complete in tests and add option to run tests without cache.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "We need to replay our test workflows more. Today we don't replay nor do we run without cache, both of which could catch issues.",
      "number": 291,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T13:03:58.065Z"
    },
    {
      "summary": "Worker service crashes and takes down the entire .NET application when connection to Temporal server fails, instead of retrying. This is especially problematic in .NET 6+ where background service exceptions propagate to the host.",
      "category": "bug",
      "subcategory": "worker-lifecycle",
      "apis": [],
      "components": [
        "worker-service",
        "hosting-extensions",
        "connection-management"
      ],
      "concepts": [
        "retry",
        "connection-failure",
        "graceful-degradation",
        "background-service",
        "exception-handling",
        "resilience"
      ],
      "severity": "high",
      "userImpact": "Applications crash completely when the Temporal worker fails to connect, making it unsuitable for running as a background service alongside other services.",
      "rootCause": "Worker service does not retry on connection failures and throws unhandled exceptions, which in .NET 6+ causes the entire host to terminate due to changed background service behavior.",
      "proposedFix": null,
      "workaround": "Write a custom worker service wrapper around the normal workers with custom reliability and retry logic, similar to the existing TemporalWorkerService helper.",
      "resolution": "wontfix",
      "resolutionDetails": "The maintainers clarified that intentional failure on worker startup is by design for visibility, and users can implement custom worker services if different behavior is needed.",
      "related": [],
      "keyQuote": "We intentionally fail if the worker cannot start...users have requested that if the worker cannot start it should fail which seems reasonable.",
      "number": 290,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:48:06.210Z"
    },
    {
      "summary": "Request to add trimming annotations to the .NET SDK to support publishing trimmed and AOT-compatible applications. Currently, attempting to publish with `<PublishTrimmed>true</PublishTrimmed>` produces errors due to missing metadata.",
      "category": "feature",
      "subcategory": "aot-trimming",
      "apis": [],
      "components": [
        "sdk-core",
        "pinvoke-bindings",
        "reflection-usage"
      ],
      "concepts": [
        "trimming",
        "aot-compatibility",
        "dead-code-elimination",
        "runtime-metadata",
        "deployment",
        "performance"
      ],
      "severity": "medium",
      "userImpact": "Users cannot publish trimmed or AOT-compiled .NET applications using the Temporal SDK without errors.",
      "rootCause": "The SDK lacks trimming annotations required by the .NET runtime to preserve types and members needed for PInvoke and reflection during trimming.",
      "proposedFix": "Add trimming annotations to the SDK and run tests with trimming enabled to ensure ongoing compatibility.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporalio (and other packages) don't have trimming annotations included which produces errors when publishing with trimming enabled.",
      "number": 286,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:48:05.068Z"
    },
    {
      "summary": "Feature request to allow users to configure search attributes when starting the dev server, which should translate to --search-attribute command-line arguments based on changes deployed in the CLI.",
      "category": "feature",
      "subcategory": "dev-server",
      "apis": [],
      "components": [
        "dev-server",
        "search-attributes",
        "server-configuration"
      ],
      "concepts": [
        "search-attributes",
        "dev-server-startup",
        "configuration",
        "cli-integration"
      ],
      "severity": "low",
      "userImpact": "Users will be able to configure search attributes directly in dev server options without manual CLI flag management.",
      "rootCause": null,
      "proposedFix": "Implement support for setting search attributes in dev server startup options that map to --search-attribute CLI calls",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to accept search attributes in dev server startup options",
      "related": [
        494
      ],
      "keyQuote": "users should be allowed to set search attributes in dev server option that translate to `--search-attribute` calls",
      "number": 282,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:48:04.299Z"
    },
    {
      "summary": "Need a reentrant and deterministic concurrency control mechanism (mutex/semaphore) for use within workflow coroutines, signal handlers, and update handlers that fits naturally with the .NET language.",
      "category": "feature",
      "subcategory": "workflow-concurrency",
      "apis": [],
      "components": [
        "workflow-coroutine",
        "signal-handler",
        "update-handler"
      ],
      "concepts": [
        "concurrency",
        "mutex",
        "semaphore",
        "reentrancy",
        "determinism",
        "synchronization",
        "coroutine"
      ],
      "severity": "medium",
      "userImpact": "Users lack a proper way to safely manage concurrent access to shared resources within workflows, requiring workarounds or unsafe patterns.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by issue #287 which implemented the concurrency control mechanism.",
      "related": [
        287
      ],
      "keyQuote": "We need a mechanism for concurrency control (mutex/semaphore) that fits with the language but is reentrant and deterministic within workflow coroutines.",
      "number": 281,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:30:05.114Z"
    },
    {
      "summary": "TaskQueue is not being forwarded when using the Test Environment, causing ContinueAsNew operations to hang due to a missing TaskQueue error. The TaskQueue should be auto-assigned by the workflow if not explicitly provided.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "StartWorkflowAsync",
        "ContinueAsNewException"
      ],
      "components": [
        "test-environment",
        "workflow-execution",
        "task-queue-routing"
      ],
      "concepts": [
        "task-queue",
        "continue-as-new",
        "workflow-continuation",
        "test-server",
        "auto-assignment"
      ],
      "severity": "high",
      "userImpact": "Users cannot use ContinueAsNew in test environments as workflows hang waiting for a properly forwarded TaskQueue.",
      "rootCause": "TaskQueue is not being automatically forwarded/assigned during workflow continuation in the test environment, causing the core SDK to report a missing TaskQueue error.",
      "proposedFix": null,
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        1424
      ],
      "keyQuote": "The TaskQueue should really be getting auto-assigned by the Workflow if not provided explicitly.",
      "number": 280,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:30:05.234Z"
    },
    {
      "summary": "Minimal testing-related issue with no details provided. The issue contains only the word 'testing' with no description of what testing problem, feature, or request is being addressed.",
      "category": "other",
      "subcategory": "testing",
      "apis": [],
      "components": [],
      "concepts": [
        "testing"
      ],
      "severity": "low",
      "userImpact": "Unclear - insufficient information provided to determine user impact.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue closed as invalid due to insufficient detail - no actionable information provided.",
      "related": [],
      "keyQuote": "testing",
      "number": 278,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:30:04.639Z"
    },
    {
      "summary": "Minimal issue with just the word 'testing' as content. Appears to be a placeholder or incomplete issue submission.",
      "category": "other",
      "subcategory": "testing",
      "apis": [],
      "components": [],
      "concepts": [
        "testing"
      ],
      "severity": "low",
      "userImpact": "Unclear impact due to minimal issue description.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed as it appears to be incomplete or a test submission with insufficient context.",
      "related": [],
      "keyQuote": "testing",
      "number": 277,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:12:46.976Z"
    },
    {
      "summary": "A minimal testing issue with no description provided. The issue appears to be a placeholder or draft.",
      "category": "question",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "testing"
      ],
      "concepts": [
        "testing",
        "validation",
        "quality-assurance"
      ],
      "severity": "low",
      "userImpact": "Impact is unclear due to insufficient issue description.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was closed likely due to insufficient information or being a placeholder.",
      "related": [],
      "keyQuote": "testing",
      "number": 276,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:12:46.640Z"
    },
    {
      "summary": "Multiple classes in the .NET SDK have incorrect type casting in their Clone() methods. ScheduleOptions casts to WorkflowOptions instead of ScheduleOptions, and similar issues exist in ScheduleTriggerOptions, WorkflowHistoryFetchOptions, ScheduleListOptions, and WorkflowCancelOptions.",
      "category": "bug",
      "subcategory": "type-casting",
      "apis": [],
      "components": [
        "ScheduleOptions",
        "ScheduleTriggerOptions",
        "WorkflowHistoryFetchOptions",
        "ScheduleListOptions",
        "WorkflowCancelOptions"
      ],
      "concepts": [
        "type-casting",
        "clone-method",
        "object-serialization",
        "code-quality",
        "dotnet-sdk"
      ],
      "severity": "medium",
      "userImpact": "Incorrect type casting in Clone() methods could cause runtime errors or unexpected behavior when cloning schedule and workflow option objects.",
      "rootCause": "Copy-paste error where Clone() methods cast to incorrect parent or unrelated classes instead of their own types.",
      "proposedFix": "Correct each Clone() method to cast to the appropriate class type (e.g., ScheduleOptions.Clone() should cast to ScheduleOptions, not WorkflowOptions).",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Acknowledged by maintainer as an obvious bug that would be fixed shortly.",
      "related": [],
      "keyQuote": "This is an obvious (embarrassing) bug on our part and we will fix shortly.",
      "number": 274,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:12:49.095Z"
    },
    {
      "summary": "Request to expose UpdateID in update handlers to allow users to use it as a unique idempotent primary key for their handler logic.",
      "category": "feature",
      "subcategory": "update-handler",
      "apis": [
        "UpdateHandler"
      ],
      "components": [
        "update-handler",
        "idempotency"
      ],
      "concepts": [
        "idempotency",
        "unique-identifier",
        "handler-context",
        "primary-key",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access UpdateID within update handlers, limiting their ability to implement idempotent operations with unique primary keys.",
      "rootCause": null,
      "proposedFix": "Expose UpdateID as a field or property accessible within update handler context",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "UpdateID was exposed in update handler implementation",
      "related": [],
      "keyQuote": "This will allow users to use it when they want a unique idempotent primary key for handlers",
      "number": 265,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:00:12.562Z"
    },
    {
      "summary": "Workflow.WaitConditionAsync hangs indefinitely in Temporal 1.1.1 even when the condition becomes true, affecting unit tests. The issue was introduced in PR #242 and is resolved in version 1.1.2.",
      "category": "bug",
      "subcategory": "workflow-synchronization",
      "apis": [
        "WaitConditionAsync"
      ],
      "components": [
        "workflow-runtime",
        "condition-handling",
        "threading"
      ],
      "concepts": [
        "deadlock",
        "thread-blocking",
        "workflow-signals",
        "async-coordination",
        "regression"
      ],
      "severity": "high",
      "userImpact": "Users upgrading to Temporal 1.1.1 experience hanging workflows when using WaitConditionAsync, blocking test execution and potentially production workloads.",
      "rootCause": "Changes introduced in PR #242 caused a threading issue that blocks WaitConditionAsync indefinitely even when conditions are satisfied.",
      "proposedFix": null,
      "workaround": "Downgrade to Temporal 1.1.0 or earlier until patch release 1.1.2 is available.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed in version 1.1.2 when PR #259 was merged.",
      "related": [
        242,
        259
      ],
      "keyQuote": "Workflow.WaitConditionAsync sometimes hangs probably by a blocked thread caused by this pull request",
      "number": 263,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:00:13.413Z"
    },
    {
      "summary": "Users need a way to await or ignore all remaining handlers when a workflow continues as new or exits. The feature provides an all-handlers-finished property to give users control over this behavior.",
      "category": "feature",
      "subcategory": "workflow-lifecycle",
      "apis": [],
      "components": [
        "workflow-handler",
        "workflow-execution",
        "lifecycle-management"
      ],
      "concepts": [
        "handler-completion",
        "workflow-continuation",
        "async-waiting",
        "graceful-shutdown"
      ],
      "severity": "medium",
      "userImpact": "Users can now properly manage handler completion when transitioning workflows, preventing resource leaks or incomplete operations.",
      "rootCause": null,
      "proposedFix": "Implement an all-handlers-finished property to allow users to wait for or ignore remaining handlers",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved as part of issue #294 by implementing an all-handlers-finished property",
      "related": [
        294
      ],
      "keyQuote": "Users want to easily await (or ignore) all their remaining handlers when they continue as new or exit the workflow",
      "number": 262,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T12:00:12.524Z"
    },
    {
      "summary": "Need to warn or error when update handlers don't complete before workflow exit (cancellation, failure, or success). The .NET SDK should implement a handler completion policy allowing users to wait for handlers to finish or explicitly abandon them.",
      "category": "feature",
      "subcategory": "update-handlers",
      "apis": [
        "workflow.all_handlers_finished()"
      ],
      "components": [
        "worker",
        "workflow-runtime",
        "update-handler"
      ],
      "concepts": [
        "handler-lifecycle",
        "workflow-exit",
        "cancellation",
        "resource-cleanup",
        "policy-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users may accidentally leave update handlers dangling when workflows exit, potentially causing data loss or resource leaks, without being warned.",
      "rootCause": "Update handlers that are not awaited or explicitly abandoned can remain incomplete when workflows exit through cancellation, failure, or success.",
      "proposedFix": "Implement a HandlerUnfinishedPolicy with WARN_AND_ABANDON as default, providing an all_handlers_finished() method, and emitting warnings when handlers are unfinished at workflow exit.",
      "workaround": "Users can manually wait for all handlers before workflow completion or explicitly set unfinished policy to ABANDON per handler.",
      "resolution": "fixed",
      "resolutionDetails": "Python SDK PR #556 merged with proposed spec. Implementation involves handler lifecycle management, policy configuration, and completion tracking across workflow exit scenarios.",
      "related": [],
      "keyQuote": "Workflow code can wait on a method named similarly to `workflow.all_handlers_finished()`",
      "number": 261,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:54:02.707Z"
    },
    {
      "summary": "Add support for updating the worker client when using generic host in .NET SDK. Users need a ClientUpdater pattern that allows them to push client updates to all workers via DI or manual instantiation.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [],
      "components": [
        "worker",
        "generic-host",
        "dependency-injection",
        "client-management"
      ],
      "concepts": [
        "client-update",
        "dependency-injection",
        "worker-service",
        "options-monitoring",
        "event-subscription"
      ],
      "severity": "medium",
      "userImpact": "Users can now dynamically update the worker client when using generic host integration, improving flexibility in worker configuration management.",
      "rootCause": null,
      "proposedFix": "Implement a ClientUpdater class that users can instantiate or use from DI, set on worker service options, and use to push client updates to all workers through internal subscription to update events.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in version 1.1.2 via PR #258",
      "related": [
        258
      ],
      "keyQuote": "A better pattern would be a ClientUpdater which the user can instantiate (or use from DI) and set on the worker service options.",
      "number": 257,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:54:01.177Z"
    },
    {
      "summary": "The README for the DiagnosticSource extension needs clarification about what ICustomMetricMeter is used for and its role in runtime options.",
      "category": "docs",
      "subcategory": "documentation-clarity",
      "apis": [],
      "components": [
        "diagnostics-extension",
        "metrics",
        "runtime-options"
      ],
      "concepts": [
        "metrics",
        "diagnostics",
        "documentation",
        "API-clarity",
        "configuration"
      ],
      "severity": "low",
      "userImpact": "Users reading the README are confused about the purpose and usage of ICustomMetricMeter in the context of runtime options.",
      "rootCause": null,
      "proposedFix": "Clarify in the initial paragraph of the README what ICustomMetricMeter is for and explain its relationship to runtime options.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "it is unclear to readers of the initial paragraph what the `ICustomMetricMeter` is for. Clarify it is for runtime options and what it's used for.",
      "number": 256,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:53:59.991Z"
    },
    {
      "summary": "Add a call to the Core worker.validate function on worker start/run to validate worker configuration and surface errors to the user. This function was added to sdk-core to provide validation capabilities.",
      "category": "feature",
      "subcategory": "worker-validation",
      "apis": [],
      "components": [
        "worker",
        "core-integration"
      ],
      "concepts": [
        "validation",
        "configuration",
        "error-handling",
        "initialization",
        "worker-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users will receive clear validation errors if their worker configuration is incorrect, preventing runtime failures.",
      "rootCause": null,
      "proposedFix": "Call the validate function from sdk-core on worker start/run and propagate any errors to the user.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker validation was implemented to call the Core worker.validate function during startup.",
      "related": [],
      "keyQuote": "validate added in https://github.com/temporalio/sdk-core/pull/750, make sure to call it on worker start/run and if it errors, error to the user",
      "number": 253,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:37:42.756Z"
    },
    {
      "summary": "Wrap gRPC CANCELED and DEADLINE_EXCEEDED errors in an SDK-specific timeout exception for the Update API, so users only need to catch one predictable exception type instead of handling raw gRPC errors.",
      "category": "feature",
      "subcategory": "exception-handling",
      "apis": [
        "Update"
      ],
      "components": [
        "grpc-client",
        "exception-handling",
        "update-executor"
      ],
      "concepts": [
        "timeout",
        "deadline-exceeded",
        "error-wrapping",
        "exception-hierarchy",
        "user-experience"
      ],
      "severity": "medium",
      "userImpact": "Users must currently catch multiple exception types (gRPC CANCELED and DEADLINE_EXCEEDED) when handling update timeouts; this change would provide a single, predictable SDK exception to catch.",
      "rootCause": "Raw gRPC exceptions expose implementation details instead of providing a consistent SDK abstraction.",
      "proposedFix": "Wrap gRPC CANCELED and DEADLINE_EXCEEDED errors in an SDK timeout exception; implementation details referenced in temporalio/features#483.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation completed by wrapping gRPC exceptions in SDK timeout exception per feature specification.",
      "related": [
        483
      ],
      "keyQuote": "So that users only have to catch one predictable exception",
      "number": 250,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:37:43.737Z"
    },
    {
      "summary": "Request to delay workflow completion until all coroutines have settled in the task, preventing premature completion before all async operations finish.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "workflow-executor",
        "coroutine-manager",
        "task-completion"
      ],
      "concepts": [
        "coroutine-settlement",
        "workflow-completion",
        "async-operations",
        "timing",
        "task-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Workflows may complete prematurely before all async operations have finished, causing data loss or incomplete execution.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation of coroutine settlement check before workflow completion in the task completion logic.",
      "related": [
        481
      ],
      "keyQuote": "Do not set workflow completion until after all coroutines have settled in the task",
      "number": 249,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:37:43.313Z"
    },
    {
      "summary": "Client hangs when Task.WaitAll() is used on the main thread to wait for schedule creation tasks. The issue occurs because TaskCompletionSource can deadlock on the same thread without proper async continuation scheduling.",
      "category": "bug",
      "subcategory": "client-deadlock",
      "apis": [
        "CreateScheduleAsync",
        "DescribeAsync"
      ],
      "components": [
        "client",
        "schedule-handle",
        "task-completion"
      ],
      "concepts": [
        "deadlock",
        "threading",
        "async-continuation",
        "main-thread",
        "synchronization"
      ],
      "severity": "high",
      "userImpact": "Users experience application hangs when using synchronous Task.WaitAll() on the main thread to wait for client operations, blocking all further execution.",
      "rootCause": "TaskCompletionSource was not configured with TaskCreationOptions.RunContinuationsAsynchronously, causing deadlock when continuations are scheduled on the same thread.",
      "proposedFix": "Supply TaskCreationOptions.RunContinuationsAsynchronously to the TaskCompletionSource constructor to ensure continuations are scheduled asynchronously rather than executing on the current thread.",
      "workaround": "Use Task.WhenAll() instead of Task.WaitAll(), or wrap Task.WaitAll() in Task.Run() to execute it off the main thread.",
      "resolution": "fixed",
      "resolutionDetails": "TaskCompletionSource constructor updated to use TaskCreationOptions.RunContinuationsAsynchronously to prevent same-thread deadlock.",
      "related": [
        44
      ],
      "keyQuote": "TaskCompletionSource can deadlock on same thread, need to supply TaskCreationOptions.RunContinuationsAsynchronously to the constructor",
      "number": 248,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:20:26.320Z"
    },
    {
      "summary": "Request for .NET SDK support for Windows 32-bit (win-x86) architecture to enable direct integration with legacy 32-bit SDKs in activities without requiring wrapper APIs.",
      "category": "feature",
      "subcategory": "platform-support",
      "apis": [],
      "components": [
        "nuget-package",
        "runtime",
        "native-bindings"
      ],
      "concepts": [
        "32-bit architecture",
        "platform support",
        "legacy integration",
        "package size",
        "cross-platform"
      ],
      "severity": "low",
      "userImpact": "Users with legacy 32-bit systems cannot directly use Temporal activities with their existing 32-bit SDKs and must use wrapper APIs instead.",
      "rootCause": "NuGet package size constraints (50MB compressed) and lack of 32-bit testing infrastructure make adding win-x86 support impractical currently.",
      "proposedFix": "Possible future separate NuGet package dedicated to 32-bit support, or user can build and package SDK independently for 32-bit targets.",
      "workaround": "Wrap the 32-bit library in an API that the activity calls out to, or build the SDK on 32-bit and create a custom package.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The NuGet package is already 50MB compressed and each shared library we add is ~30MB (~10MB compressed).",
      "number": 247,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:20:26.607Z"
    },
    {
      "summary": "Request to expose internal RawInfo and RawDescription properties on WorkflowExecution and WorkflowExecutionDescription to provide access to raw proto objects and pending activities information.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowExecution",
        "WorkflowExecutionDescription"
      ],
      "components": [
        "workflow-execution",
        "proto-bindings"
      ],
      "concepts": [
        "raw-proto-objects",
        "pending-activities",
        "api-exposure",
        "internal-visibility"
      ],
      "severity": "low",
      "userImpact": "Users cannot access detailed pending activities and raw proto information currently hidden behind internal properties.",
      "rootCause": null,
      "proposedFix": "Expose RawInfo and RawDescription as public properties on WorkflowExecution and WorkflowExecutionDescription types.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Right now `RawInfo` and `RawDescription` are `internal` and should be exposed to see things like pending activities",
      "number": 246,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:20:25.073Z"
    },
    {
      "summary": "Add a separate Cloud Operations API client for the .NET SDK using cloud protos, marked as experimental. This feature is dependent on sdk-core issue #737.",
      "category": "feature",
      "subcategory": "cloud-operations-client",
      "apis": [],
      "components": [
        "cloud-client",
        "protos",
        "client-library"
      ],
      "concepts": [
        "cloud-operations",
        "experimental-api",
        "separate-client",
        "proto-definitions"
      ],
      "severity": "medium",
      "userImpact": "Users will be able to interact with Temporal Cloud Operations through a dedicated .NET client library.",
      "rootCause": null,
      "proposedFix": "Create a separate cloud client using cloud protos, marked experimental, following patterns established in Go SDK PR #1426.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Cloud Operations API client was implemented for .NET SDK.",
      "related": [
        440,
        1426,
        737
      ],
      "keyQuote": "We need a separate cloud client using the cloud protos (they are separate today). The client should be marked experimental.",
      "number": 244,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:02:44.270Z"
    },
    {
      "summary": "Feature request to enforce restrictions preventing wait condition callbacks, update validators, and queries from adding commands in read-only contexts within .NET SDK.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "wait-conditions",
        "update-validators",
        "queries",
        "workflow-context"
      ],
      "concepts": [
        "read-only-context",
        "command-restrictions",
        "validation",
        "enforcement",
        "workflow-safety"
      ],
      "severity": "medium",
      "userImpact": "Users need guaranteed enforcement of no-command restrictions in read-only contexts to prevent accidental workflow state mutations.",
      "rootCause": null,
      "proposedFix": "Add validation/enforcement in wait condition callbacks, update validators, and queries to fail when attempting to add commands",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Wait condition callbacks, update validators, and queries should fail if they try to add commands",
      "number": 243,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:02:43.463Z"
    },
    {
      "summary": "WaitConditionAsync callback is executed outside the workflow event loop, causing the task scheduler to not be the workflow instance, which makes calls to the Workflow object within the callback fail.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "WaitConditionAsync"
      ],
      "components": [
        "workflow-instance",
        "event-loop",
        "task-scheduler"
      ],
      "concepts": [
        "context",
        "event-loop",
        "task-scheduling",
        "async-callback",
        "workflow-execution"
      ],
      "severity": "high",
      "userImpact": "Users cannot safely call Workflow methods from within WaitConditionAsync callbacks, severely limiting the utility of the API.",
      "rootCause": "The callback for WaitConditionAsync is executed outside of the event loop instead of within the workflow instance's task scheduler context.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "The callback for WaitConditionAsync is run outside of the event loop, so the current task scheduler is not the workflow instance.",
      "number": 240,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T11:02:43.633Z"
    },
    {
      "summary": "System.InvalidOperationException thrown when calling AddHostedTemporalWorker after registering a keyed service descriptor to the DI container. This issue was introduced in v1.1.0 and stems from code that doesn't properly handle keyed services in the service provider.",
      "category": "bug",
      "subcategory": "dependency-injection",
      "apis": [
        "AddHostedTemporalWorker"
      ],
      "components": [
        "TemporalWorkerServiceOptionsBuilderExtensions",
        "dependency-injection",
        "service-provider"
      ],
      "concepts": [
        "keyed-services",
        "dependency-injection",
        "service-descriptor",
        "runtime-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users cannot start their application if they use keyed service descriptors in their DI container alongside AddHostedTemporalWorker.",
      "rootCause": "The TemporalWorkerServiceOptionsBuilderExtensions code introduced in PR #216 does not properly handle keyed service descriptors, causing an InvalidOperationException when the service provider receives keyed services.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The issue was resolved by updating the code to properly support keyed service descriptors in the service provider.",
      "related": [
        216
      ],
      "keyQuote": "System.InvalidOperationException: This service descriptor is keyed. Your service provider may not support keyed services",
      "number": 238,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:46:38.198Z"
    },
    {
      "summary": "Feature request to enable replacing the worker client with a new client that may be connected with different options, such as a new TLS certificate. This allows dynamic client updates without recreating the worker.",
      "category": "feature",
      "subcategory": "client-management",
      "apis": [
        "Client"
      ],
      "components": [
        "worker",
        "client",
        "connection"
      ],
      "concepts": [
        "client-replacement",
        "tls-certificate",
        "connection-options",
        "dynamic-update",
        "worker-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users need the ability to update worker clients with different connection options at runtime, particularly for certificate rotation.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to allow client replacement in worker with different connection options",
      "related": [
        11
      ],
      "keyQuote": "Need to be able to replace the worker client with a new client that may be connected with different options (e.g. a new TLS cert)",
      "number": 235,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:46:37.273Z"
    },
    {
      "summary": "Payload codec receives reused payload instances in specific workflow failure scenarios involving ApplicationFailureException with Details objects, causing the same codec instance to be passed multiple times instead of unique instances for each payload.",
      "category": "bug",
      "subcategory": "payload-codec",
      "apis": [
        "ExecuteActivityAsync"
      ],
      "components": [
        "payload-codec",
        "failure-handling",
        "exception-serialization"
      ],
      "concepts": [
        "payload-reuse",
        "instance-mutation",
        "codec-isolation",
        "failure-details",
        "object-lifecycle",
        "memory-efficiency"
      ],
      "severity": "medium",
      "userImpact": "Developers writing payload codecs that track state or metadata per payload cannot rely on receiving unique instances, leading to unexpected behavior when encoding failure details.",
      "rootCause": "Payload instances are not cloned before being passed to the codec to avoid unnecessary performance overhead, allowing the same underlying object to be reused across multiple codec invocations in certain failure scenarios.",
      "proposedFix": "Documentation should clearly state that payload codecs must always create new payload instances and never mutate or maintain references to input payloads beyond the method lifecycle.",
      "workaround": "Always create a new Payload instance in the codec (e.g., wrapping the original payload's bytes as data of a new payload) rather than mutating or referencing the input payload.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Your payload codec should not mutate the payload being passed in or try to maintain a reference to it in any way. Rather, you should always create a new payload.",
      "number": 234,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:46:39.907Z"
    },
    {
      "summary": "The StartUpdateAsync method should make users aware that it's synchronous with the worker and the wait stage parameter shouldn't be optional. Documentation needs to clarify availability and behavior.",
      "category": "feature",
      "subcategory": "api-design",
      "apis": [
        "StartUpdateAsync"
      ],
      "components": [
        "WorkflowHandle",
        "client-api",
        "documentation"
      ],
      "concepts": [
        "synchronous-behavior",
        "worker-interaction",
        "api-clarity",
        "optional-parameters",
        "update-workflow"
      ],
      "severity": "medium",
      "userImpact": "Users may be confused about the synchronous nature of StartUpdateAsync with the worker and may incorrectly use optional parameters.",
      "rootCause": "API design doesn't clearly communicate synchronous behavior with worker; wait stage parameter optionality is misleading.",
      "proposedFix": "Make wait stage parameter non-optional and improve documentation to clarify availability and synchronous behavior with worker.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Enhanced API documentation and parameter handling to clarify synchronous behavior with worker.",
      "related": [
        469
      ],
      "keyQuote": "wait stage shouldn't be optional here, and docs should clarify availability.",
      "number": 231,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:30:46.772Z"
    },
    {
      "summary": "Request to decouple Temporalio.Testing from the main Temporalio NuGet package into a separate package to avoid distributing test code to production environments.",
      "category": "feature",
      "subcategory": "package-structure",
      "apis": [],
      "components": [
        "testing-framework",
        "nuget-packaging"
      ],
      "concepts": [
        "separation-of-concerns",
        "dependency-management",
        "production-vs-test",
        "package-distribution"
      ],
      "severity": "low",
      "userImpact": "Users currently receive test utilities as part of the production package, which could be avoided by separating testing into an optional NuGet package.",
      "rootCause": null,
      "proposedFix": "Create a separate Temporalio.Testing NuGet package and remove the reference to Temporalio.Testing from the main Temporalio package.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Temporalio.Testing is currently a part of the Temporalio package. I think it is better to decouple so we don't distribute test code to production",
      "number": 229,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:30:47.144Z"
    },
    {
      "summary": "Request to make all client response classes user-instantiable and mockable by adding parameterless constructors and property setters. Currently some responses like workflow list results only have internal constructors, making testing difficult.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "client-responses",
        "workflow-list",
        "test-utilities"
      ],
      "concepts": [
        "testability",
        "mocking",
        "instantiation",
        "property-access",
        "user-testing"
      ],
      "severity": "medium",
      "userImpact": "Users cannot mock or instantiate client response objects for testing, limiting their ability to write comprehensive unit tests.",
      "rootCause": null,
      "proposedFix": "Add parameterless constructors and property setters to all client response classes to match patterns used by other SDK clients like Azure clients.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the feature was implemented to allow user instantiation and mocking of client responses.",
      "related": [],
      "keyQuote": "Make their classes simple classes with parameterless constructors and have all properties also have setters.",
      "number": 228,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:30:46.844Z"
    },
    {
      "summary": "Request to make DefaultPayloadConverter protected constructors public to allow users to instantiate converter classes directly, now that the SDK no longer requires converter classes to be inherited.",
      "category": "feature",
      "subcategory": "payload-converter",
      "apis": [
        "DefaultPayloadConverter"
      ],
      "components": [
        "payload-converter",
        "serialization"
      ],
      "concepts": [
        "extensibility",
        "constructor-visibility",
        "payload-handling",
        "converter-instantiation"
      ],
      "severity": "low",
      "userImpact": "Users who want to customize payload conversion cannot instantiate DefaultPayloadConverter directly due to protected constructors.",
      "rootCause": null,
      "proposedFix": "Expose the protected DefaultPayloadConverter constructors as public.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Constructors were made public to allow direct instantiation of converter classes.",
      "related": [],
      "keyQuote": "now since we let people instantiate the converter, we might as well expose these",
      "number": 225,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:14:15.945Z"
    },
    {
      "summary": "Feature request to expose manual pagination controls for workflow list operations, allowing users to specify page size and retrieve next page tokens. This enables stateless pagination for UIs that cannot maintain async iterators in memory.",
      "category": "feature",
      "subcategory": "workflow-list-pagination",
      "apis": [
        "ListWorkflowsAsync"
      ],
      "components": [
        "list-interceptor",
        "pagination",
        "async-iterator"
      ],
      "concepts": [
        "pagination",
        "stateless",
        "page-token",
        "user-interface",
        "memory-management",
        "async-iteration"
      ],
      "severity": "medium",
      "userImpact": "Users need manual pagination controls to power stateless UIs that cannot keep async iterators in memory.",
      "rootCause": "Current implementation only provides async iterators with internal paging, not exposed pagination controls.",
      "proposedFix": "Surface paging to users by exposing page size and next page token parameters, possibly through a new single-page interceptor or tailoring the existing ListWorkflowsAsync interceptor.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Reopened and scoped to workflow list only after identifying stateless pagination use cases for UI implementations.",
      "related": [],
      "keyQuote": "Reopening issue because there are use cases that involve stateless pagination, e.g. to power user UIs that can't keep async iterator in memory.",
      "number": 221,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:14:16.289Z"
    },
    {
      "summary": "Documentation needed for Temporalio.Extensions.Hosting about a caveat where host.Run() (synchronous) doesn't poll for workers while host.RunAsync() (asynchronous) does, and about a known issue from dotnet/runtime that confuses users.",
      "category": "docs",
      "subcategory": "hosting-extensions",
      "apis": [
        "TemporalClient.ConnectAsync",
        "StartWorkflowAsync",
        "AddHostedTemporalWorker",
        "ExecuteAsync"
      ],
      "components": [
        "hosting-extensions",
        "worker",
        "client"
      ],
      "concepts": [
        "async-sync-behavior",
        "host-builder",
        "polling",
        "dependency-injection",
        "runtime-caveat"
      ],
      "severity": "low",
      "userImpact": "Users are confused when using host.Run() with the host builder pattern because workers don't poll, requiring them to discover that host.RunAsync() is needed instead.",
      "rootCause": "Difference in behavior between synchronous host.Run() and asynchronous host.RunAsync() methods, compounded by a known dotnet/runtime issue",
      "proposedFix": "Document in Temporalio.Extensions.Hosting README the caveat about using host.RunAsync() instead of host.Run(), and reference the known dotnet/runtime issue #36063",
      "workaround": "Use host.RunAsync() instead of host.Run() when using the host builder pattern with Temporal workers",
      "resolution": "fixed",
      "resolutionDetails": "Documentation was added to clarify the async/sync behavior difference and the dotnet/runtime caveat",
      "related": [],
      "keyQuote": "Change next line to \"await host.RunAsync();\" and it will start working",
      "number": 220,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T10:14:16.797Z"
    },
    {
      "summary": "Request to expose a defaultConnection() method in the .NET SDK that switches between localhost and cloud environments based on configuration, enabling samples to run flexibly in both environments.",
      "category": "feature",
      "subcategory": "connection-management",
      "apis": [],
      "components": [
        "connection",
        "client",
        "samples"
      ],
      "concepts": [
        "environment-configuration",
        "cloud-connectivity",
        "localhost-development",
        "connection-switching",
        "sample-infrastructure"
      ],
      "severity": "low",
      "userImpact": "Users and sample maintainers can more easily switch between local and cloud-based Temporal deployments without code changes.",
      "rootCause": null,
      "proposedFix": "Expose a defaultConnection() method that reads an environment variable to determine whether to connect to localhost or cloud",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to expose defaultConnection() method for environment-based connection switching",
      "related": [
        454
      ],
      "keyQuote": "Expose a defaultConnection() method or similar that switches between localhost (default) and cloud based on some environment variable",
      "number": 219,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:58:09.261Z"
    },
    {
      "summary": "Feature request to add a documentation link to visibility concepts in the .NET SDK's list workflow method XML documentation. The request sparked discussion about URL stability and whether to link to the general visibility documentation or a more specific list filter section.",
      "category": "docs",
      "subcategory": "xml-documentation",
      "apis": [
        "ListWorkflow"
      ],
      "components": [
        "documentation",
        "xml-docs",
        "sdk-dotnet"
      ],
      "concepts": [
        "visibility",
        "list-workflows",
        "documentation-links",
        "developer-guidance"
      ],
      "severity": "low",
      "userImpact": "Developers using the list workflow method would have easier access to visibility documentation and better understanding of the feature.",
      "rootCause": null,
      "proposedFix": "Add a link to https://docs.temporal.io/visibility in the list workflow method XML documentation",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature request was accepted and implemented, with discussion about linking to general visibility documentation versus specific anchored sections.",
      "related": [],
      "keyQuote": "Link https://docs.temporal.io/visibility from the list workflow method XML doc",
      "number": 218,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:58:07.486Z"
    },
    {
      "summary": "Request to support WorkflowIdConflictPolicy in the .NET SDK. This is a cross-SDK feature that needs to be implemented for parity with other Temporal SDKs.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowIdConflictPolicy"
      ],
      "components": [
        "workflow-client",
        "workflow-options",
        "sdk-api"
      ],
      "concepts": [
        "workflow-id",
        "conflict-handling",
        "duplicate-prevention",
        "execution-policy",
        "sdk-parity"
      ],
      "severity": "medium",
      "userImpact": "Users cannot configure how the SDK handles workflow ID conflicts, limiting their ability to manage workflow execution behavior in specific scenarios.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support WorkflowIdConflictPolicy in the .NET SDK",
      "related": [
        437
      ],
      "keyQuote": "Support for WorkflowIdConflictPolicy",
      "number": 217,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:58:07.522Z"
    },
    {
      "summary": "Add HTTP CONNECT proxy support to the .NET SDK, matching the implementation in sdk-core and following the pattern established by the Python SDK.",
      "category": "feature",
      "subcategory": "http-proxy",
      "apis": [],
      "components": [
        "client",
        "grpc-transport",
        "connection-options"
      ],
      "concepts": [
        "proxy",
        "http-connect",
        "networking",
        "transport",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users requiring HTTP CONNECT proxy support for enterprise network configurations cannot connect to Temporal Server.",
      "rootCause": null,
      "proposedFix": "Implement HTTP CONNECT proxy options following sdk-core PR #714 pattern, mirroring the Python SDK implementation from PR #501.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented to support HTTP CONNECT proxy options in the .NET SDK, with tests added to the features repository.",
      "related": [],
      "keyQuote": "Support HTTP connect proxy options added in https://github.com/temporalio/sdk-core/pull/714",
      "number": 215,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:57:50.183Z"
    },
    {
      "summary": "Feature request to document asynchronous activity completion in the .NET SDK README, allowing activities to return early while completion is handled via the Temporal Client using heartbeating and manual completion.",
      "category": "docs",
      "subcategory": "activity-completion",
      "apis": [
        "GetAsyncActivityHandle",
        "CompleteAsyncException",
        "ActivityExecutionContext"
      ],
      "components": [
        "activity-executor",
        "client",
        "documentation"
      ],
      "concepts": [
        "asynchronous-completion",
        "activity-heartbeat",
        "task-token",
        "manual-completion"
      ],
      "severity": "low",
      "userImpact": "Users are unaware that asynchronous activity completion is supported, leading to confusion about available patterns.",
      "rootCause": null,
      "proposedFix": "Document asynchronous activity completion feature in the README with examples of using CompleteAsyncException and GetAsyncActivityHandle.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Closed in favor of comprehensive async activity completion documentation in the official Temporal docs.",
      "related": [],
      "keyQuote": "You can `throw new Temporalio.Activities.CompleteAsyncException()` to tell the activity you'll be completing outside of the function",
      "number": 214,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:57:55.612Z"
    },
    {
      "summary": "DI container cannot register multiple workflow versions with the same workflow name but different build IDs. The versioning support added later conflicted with the single-worker-per-task-queue constraint that predates it.",
      "category": "bug",
      "subcategory": "dependency-injection",
      "apis": [
        "AddHostedTemporalWorker",
        "AddWorkflow",
        "ConfigureOptions"
      ],
      "components": [
        "dependency-injection",
        "worker-service",
        "workflow-registration"
      ],
      "concepts": [
        "versioning",
        "build-id",
        "task-queue",
        "worker-versioning",
        "dependency-injection"
      ],
      "severity": "high",
      "userImpact": "Users cannot deploy multiple versions of the same workflow using DI with different build IDs, blocking progressive deployment strategies.",
      "rootCause": "DI setup predates versioning and only supports one worker per task queue in a service collection. The uniqueness constraint for options set in the container does not include build ID.",
      "proposedFix": "Change what uniquely identifies options set in the container to include build ID as part of the key.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved in #451 where behavior was changed to no longer assume non-GA versioning form when build ID is present.",
      "related": [
        451
      ],
      "keyQuote": "We need to change what we uniquely identify options set as on the container to include build ID",
      "number": 212,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:57:53.251Z"
    },
    {
      "summary": "User requests adding search functionality to the .NET SDK API reference documentation. Currently, the filter only works for some elements and doesn't include methods, making it difficult to find specific APIs like `Workflow.DelayAsync`.",
      "category": "feature",
      "subcategory": "documentation",
      "apis": [],
      "components": [
        "documentation",
        "api-reference"
      ],
      "concepts": [
        "search",
        "discoverability",
        "navigation",
        "api-documentation",
        "filtering"
      ],
      "severity": "low",
      "userImpact": "Users struggle to locate specific API methods in the .NET SDK documentation, requiring workarounds like Google site searches.",
      "rootCause": "The documentation generator (DocFX) has limited search and filtering capabilities that don't cover all API elements.",
      "proposedFix": "Add a search box to the API reference page or improve the existing filter to work with methods.",
      "workaround": "Use Google site search: `site:https://dotnet.temporal.io delayasync`",
      "resolution": "wontfix",
      "resolutionDetails": "Closed as not feasible since the .NET SDK uses DocFX (language-standard documentation generator) which has inherent limitations.",
      "related": [],
      "keyQuote": "Closing as not something we can reasonably do since we use the language-standard documentation generator",
      "number": 211,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:57:39.307Z"
    },
    {
      "summary": "Feature request to enable macOS M1/ARM runners for all SDK CI/CD pipelines, referencing a similar request in the features repository.",
      "category": "feature",
      "subcategory": "ci-infrastructure",
      "apis": [],
      "components": [
        "ci-pipeline",
        "build-system",
        "macos-runner"
      ],
      "concepts": [
        "continuous-integration",
        "arm-architecture",
        "macos-support",
        "ci-runner",
        "build-optimization"
      ],
      "severity": "medium",
      "userImpact": "Enables faster and more efficient CI builds on modern Apple Silicon hardware for SDK development.",
      "rootCause": null,
      "proposedFix": "Configure CI runners to support macOS M1/ARM architecture",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "CI infrastructure was updated to include M1/ARM runners",
      "related": [
        396
      ],
      "keyQuote": null,
      "number": 210,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:57:37.571Z"
    },
    {
      "summary": "Request to expose the `use_seconds_for_duration` metric option from sdk-core PR #706 on Prometheus metrics in the .NET SDK, with potential additional updates needed due to other changes in that PR.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "prometheus-metrics",
        "metrics-configuration"
      ],
      "concepts": [
        "duration-units",
        "metric-options",
        "prometheus-integration",
        "sdk-core-alignment"
      ],
      "severity": "medium",
      "userImpact": "Users need access to the seconds-based duration metric option that was added to sdk-core but is not yet exposed in the .NET SDK.",
      "rootCause": null,
      "proposedFix": "Expose `use_seconds_for_duration` option on Prometheus metrics and apply other metric-related changes from sdk-core PR #706",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to expose the metric option",
      "related": [
        706
      ],
      "keyQuote": "Need to at least expose `use_seconds_for_duration` option on Prometheus metrics from https://github.com/temporalio/sdk-core/pull/706",
      "number": 209,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:41:47.793Z"
    },
    {
      "summary": "Feature request to support IAsyncDisposable activity classes with async scopes for dependency injection in .NET 6+. Currently the SDK only creates synchronous scopes which prevents proper async disposal patterns.",
      "category": "feature",
      "subcategory": "dependency-injection",
      "apis": [],
      "components": [
        "ServiceProviderExtensions",
        "Hosting",
        "dependency-injection"
      ],
      "concepts": [
        "async-disposal",
        "resource-management",
        "dependency-injection",
        "dotnet-6",
        "scoping"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use IAsyncDisposable activities with the hosting DI container, limiting modern .NET resource management patterns.",
      "rootCause": "ServiceProviderExtensions creates synchronous scopes instead of async scopes, incompatible with IAsyncDisposable pattern in .NET 6+.",
      "proposedFix": "Change ServiceProviderExtensions.cs line 64 to use 'await using (var scope = provider.CreateAsyncScope())' with compiler directives for .NET 6+ compatibility.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Handled with #207",
      "related": [
        207
      ],
      "keyQuote": "Change to 'await using (var scope = provider.CreateAsyncScope())', but there may need to be compiler directives since it's .NET 6+",
      "number": 204,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:41:36.159Z"
    },
    {
      "summary": "SDK should not return an update handle if the update has not reached the desired state, as referenced in the cross-repository features issue #432.",
      "category": "feature",
      "subcategory": "update-handling",
      "apis": [
        "UpdateHandle"
      ],
      "components": [
        "update-executor",
        "workflow-engine",
        "client-sdk"
      ],
      "concepts": [
        "update-state",
        "handle-lifecycle",
        "state-validation",
        "async-operations"
      ],
      "severity": "medium",
      "userImpact": "Users may receive invalid update handles for updates that haven't completed, leading to incorrect state management and failed update tracking.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed, indicating the feature was implemented or resolved",
      "related": [
        432
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/432",
      "number": 199,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:41:30.403Z"
    },
    {
      "summary": "SDK clients should automatically generate and set an UpdateID on update requests even when the user doesn't explicitly specify one. The update options constructor should also allow setting the update ID.",
      "category": "feature",
      "subcategory": "update-operations",
      "apis": [
        "UpdateOptions"
      ],
      "components": [
        "update-client",
        "update-handler",
        "options-builder"
      ],
      "concepts": [
        "update-id",
        "request-identification",
        "update-semantics",
        "idempotency",
        "user-options"
      ],
      "severity": "medium",
      "userImpact": "Users benefit from automatic update ID generation, ensuring proper identification and idempotency of update requests without manual specification.",
      "rootCause": null,
      "proposedFix": "Auto-generate UpdateID in SDK clients when not provided by user, and expose UpdateID configuration in update options constructor",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to auto-generate UpdateID on update requests and made configurable via options constructor",
      "related": [
        431
      ],
      "keyQuote": "SDK clients should set a UpdateID on any update request even if the user did not specify one",
      "number": 198,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:41:32.794Z"
    },
    {
      "summary": "User requests clarification and documentation of the .NET SDK release cycle to help them anticipate when features and bug fixes will be available. The maintainers clarified that they don't have a fixed release cycle and release as issues warrant.",
      "category": "question",
      "subcategory": "release-process",
      "apis": [],
      "components": [
        "release-management",
        "documentation"
      ],
      "concepts": [
        "release-cycle",
        "versioning",
        "feature-planning",
        "community-communication",
        "expectations"
      ],
      "severity": "low",
      "userImpact": "Users cannot plan their adoption of the SDK without knowing the release cadence and timing for features or fixes.",
      "rootCause": null,
      "proposedFix": "Describe the release cycle using GitHub projects or milestones to set expectations.",
      "workaround": "Users can request releases on Slack in the #dotnet-sdk channel.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers decided not to implement a formal release cycle with public milestones, instead releasing as issues warrant. They clarified that a single 'next' milestone with no specific time would have no real value.",
      "related": [],
      "keyQuote": "We don't have a fixed release cycle since there are not enough changes to justify one...we tend to release as issues warrant.",
      "number": 197,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:41:19.329Z"
    },
    {
      "summary": "Feature request to expose max poller options for .NET workers, matching Python and TypeScript SDKs. Also requests exposure of sticky to non-sticky ratio configuration.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "Worker"
      ],
      "components": [
        "worker",
        "poller",
        "configuration"
      ],
      "concepts": [
        "poller-options",
        "max-poller",
        "sticky-ratio",
        "worker-tuning",
        "sdk-parity"
      ],
      "severity": "low",
      "userImpact": "Users cannot configure advanced poller behavior in .NET SDK, limiting their ability to tune worker performance compared to other SDKs.",
      "rootCause": null,
      "proposedFix": "Expose max poller options and sticky to non-sticky ratio configuration in .NET worker API, matching existing Python and TypeScript implementations.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to expose max poller options for .NET workers, achieving parity with Python and TypeScript SDKs.",
      "related": [],
      "keyQuote": "We expose this in Python and TypeScript, we should expose in .NET. Also sticky to nonsticky ratio.",
      "number": 196,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:25:49.018Z"
    },
    {
      "summary": "Coverlet.collector dependency has a vulnerability (CVE-2024-21907) in Newtonsoft.Json before 13.0.1 that can cause denial of service via StackOverflow when deserializing crafted data. The vulnerability is rated High (CVSS 7.5) and requires upgrading the transitive dependency.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "test-framework",
        "dependencies",
        "nuget-packages"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "dependency-upgrade",
        "deserialization"
      ],
      "severity": "high",
      "userImpact": "Users running tests could experience denial of service if test data is crafted maliciously, or if the vulnerable deserialization path is exercised in test scenarios.",
      "rootCause": "Newtonsoft.Json versions before 13.0.1 improperly handle exceptional conditions during JSON deserialization, allowing StackOverflow exceptions.",
      "proposedFix": "Upgrade Newtonsoft.Json dependency to version 13.0.1 or later through the coverlet.collector dependency update.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Newtonsoft.Json before version 13.0.1 is affected by a mishandling of exceptional conditions vulnerability. Crafted data that is passed to the JsonConvert.DeserializeObject method may trigger a StackOverflow exception resulting in denial of service.",
      "number": 194,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:41:18.206Z"
    },
    {
      "summary": "Feature request to add API key client option support to the .NET SDK, aligning with cross-SDK feature implementation discussed in temporalio/features#426.",
      "category": "feature",
      "subcategory": "client-options",
      "apis": [],
      "components": [
        "client",
        "authentication",
        "connection-options"
      ],
      "concepts": [
        "api-key",
        "authentication",
        "client-configuration",
        "security",
        "credentials"
      ],
      "severity": "medium",
      "userImpact": "Users need a standardized way to configure API key authentication when connecting to Temporal services.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "API key client option was implemented as part of the cross-SDK feature initiative",
      "related": [
        426
      ],
      "keyQuote": "See https://github.com/temporalio/features/issues/426",
      "number": 191,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:25:38.000Z"
    },
    {
      "summary": "SignalWithStart functionality is not clearly documented in the .NET SDK README or API docs. The request asks to clarify that SignalWithStart is implemented as the start signal on options.",
      "category": "docs",
      "subcategory": "documentation",
      "apis": [
        "SignalWithStart"
      ],
      "components": [
        "documentation",
        "readme",
        "api-docs"
      ],
      "concepts": [
        "signaling",
        "workflow-start",
        "api-discoverability",
        "developer-experience"
      ],
      "severity": "low",
      "userImpact": "Developers unfamiliar with SignalWithStart cannot easily find or understand how to use this feature in the .NET SDK.",
      "rootCause": null,
      "proposedFix": "Clarify in README and API documentation that SignalWithStart is available as the start signal on options",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was clarified to explain SignalWithStart availability in .NET SDK",
      "related": [],
      "keyQuote": "Clarify that is what the start signal is on options",
      "number": 190,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:25:36.666Z"
    },
    {
      "summary": "User expected that specifying NonRetryableErrorTypes as an empty list would follow default no-retry behavior, but instead the workflow always retries. Request to clarify documentation that an empty NonRetryableErrorTypes list results in always retrying.",
      "category": "docs",
      "subcategory": "retry-policy",
      "apis": [
        "StartWorkflowAsync",
        "WorkflowOptions",
        "RetryPolicy"
      ],
      "components": [
        "retry-policy",
        "workflow-execution",
        "error-handling"
      ],
      "concepts": [
        "retry-behavior",
        "default-policy",
        "non-retryable-errors",
        "error-classification",
        "workflow-options",
        "documentation-clarity"
      ],
      "severity": "low",
      "userImpact": "Users may be confused about retry behavior when explicitly setting an empty NonRetryableErrorTypes list, leading to unexpected workflow retries.",
      "rootCause": "Documentation does not clearly explain that providing a non-null RetryPolicy value overrides defaults, and that an empty NonRetryableErrorTypes means all errors are retryable.",
      "proposedFix": "Clarify in the documentation that specifying NonRetryableErrorTypes as an empty list will cause the workflow to always retry, as this overrides the null default.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Closed as question/documentation clarification request. Maintainer clarified that null retry policy means no retry, but providing a non-null RetryPolicy overrides defaults. Existing documentation covers this but could be clearer.",
      "related": [],
      "keyQuote": "This is unrelated to NonRetryableErrorTypes. null is the default retry policy, but you are changing that default by providing a non-null value.",
      "number": 189,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:25:34.858Z"
    },
    {
      "summary": "AddAllActivities method fails to recognize mock activities when the [Activity] attribute is only placed on the implementation class. The attribute must also be present on interface methods for the activities to be discovered.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "AddAllActivities",
        "TemporalWorker"
      ],
      "components": [
        "worker",
        "activity-registration",
        "test-utilities"
      ],
      "concepts": [
        "activity-discovery",
        "attribute-inheritance",
        "mock-testing",
        "interface-implementation",
        "reflection",
        "unit-testing"
      ],
      "severity": "medium",
      "userImpact": "Unit testing workflows with mock activities fails with unclear error message about missing activities.",
      "rootCause": "The [Activity] attribute is not inherited from implementation to interface; it must be explicitly added to both the interface method signature and the implementation method.",
      "proposedFix": "Add the [Activity] attribute to both the interface method and the implementation method.",
      "workaround": "Place [Activity] attributes on both interface and implementation class methods.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was self-resolved by the reporter who discovered the attribute must be on both interface and implementation. Maintainer agreed to improve documentation to clarify that attributes are not inherited.",
      "related": [],
      "keyQuote": "The [Activity] attribute must not only be added to the method, but also the interface should the Activity Class implement the interface",
      "number": 187,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:25:20.710Z"
    },
    {
      "summary": "Add support for exposing the next retry delay field from ApplicationFailureInfo across all SDKs. This field was recently added to the API to allow activities to specify custom retry delays on failure.",
      "category": "feature",
      "subcategory": "activity-retry",
      "apis": [
        "ApplicationFailureInfo"
      ],
      "components": [
        "activity-executor",
        "failure-handling",
        "api-bindings"
      ],
      "concepts": [
        "retry",
        "failure",
        "delay",
        "activity",
        "error-handling",
        "configuration"
      ],
      "severity": "medium",
      "userImpact": "Users can now specify custom retry delays when activities fail, enabling more granular control over retry behavior.",
      "rootCause": null,
      "proposedFix": "Expose the next retry delay field from ApplicationFailureInfo in the .NET SDK to match other SDKs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was implemented to expose the ApplicationFailureInfo retry delay field in the .NET SDK.",
      "related": [],
      "keyQuote": "We recently added the ability for an activity to specify the next retry delay on failure via a field on ApplicationFailureInfo.",
      "number": 186,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:25:21.567Z"
    },
    {
      "summary": "Feature request to add support for workflow metadata queries in the .NET SDK, enabling users to retrieve and inspect workflow metadata during execution.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [],
      "components": [
        "workflow-context",
        "metadata-api"
      ],
      "concepts": [
        "metadata",
        "workflow-query",
        "introspection",
        "runtime-information"
      ],
      "severity": "medium",
      "userImpact": "Users can query workflow metadata to access information about workflow execution state and properties.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented in PR #359",
      "related": [
        51,
        359
      ],
      "keyQuote": "Support workflow metadata query",
      "number": 185,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:25:17.365Z"
    },
    {
      "summary": "System.Diagnostics.Process.GetCurrentProcess() is not supported in Blazor WebAssembly, causing exceptions when starting workflows. User suggests using System.Environment.ProcessId instead.",
      "category": "bug",
      "subcategory": "platform-compatibility",
      "apis": [],
      "components": [
        "TemporalConnection",
        "identity-resolution"
      ],
      "concepts": [
        "platform-compatibility",
        "webassembly",
        "process-identification",
        "blazor",
        "environment-detection"
      ],
      "severity": "medium",
      "userImpact": "Users cannot use the .NET SDK with Blazor WebAssembly applications due to unsupported System.Diagnostics.Process API calls.",
      "rootCause": "The SDK uses System.Diagnostics.Process.GetCurrentProcess().Id which relies on P/Invoke and is incompatible with WebAssembly execution environment.",
      "proposedFix": "Use System.Environment.ProcessId (available in newer .NET versions) or add compiler directives to support multiple .NET versions.",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "The maintainer determined that the SDK uses a Rust-based core via P/Invoke which is fundamentally incompatible with WASM. The issue was closed as not applicable because the entire SDK cannot support Blazor/WASM at this time.",
      "related": [],
      "keyQuote": "We use a Rust-based core for this library via P/Invoke and therefore it won't be Blazor/WASM compatible anyways.",
      "number": 184,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:44.257Z"
    },
    {
      "summary": "Add support for Eager Workflow Start (EWS) in the .NET SDK to reduce workflow startup latency. EWS allows clients to directly schedule the first workflow task to a local worker, already implemented in Java, Python, Core, and Go SDKs.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "client",
        "workflow-starter",
        "core-integration"
      ],
      "concepts": [
        "latency-reduction",
        "eager-execution",
        "task-scheduling",
        "local-worker",
        "workflow-initialization"
      ],
      "severity": "medium",
      "userImpact": "Users can reduce workflow startup latency by enabling Eager Workflow Start through an optional flag when starting workflows.",
      "rootCause": null,
      "proposedFix": "Add an optional flag to the workflow start mechanism to enable EWS using the Core implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Eager Workflow Start support was implemented in the .NET SDK using the Core implementation.",
      "related": [
        242
      ],
      "keyQuote": "Support for Eager Workflow Start (EWS) was added in the server in 1.20, and is currently supported in Java, Python, Core, and Go SDKs.",
      "number": 183,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:46.360Z"
    },
    {
      "summary": "Request to make Workflow instances testable like minimal APIs instead of static classes. User argues the static design prevents true TDD/unit testing and goes against software principles.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "workflow-class",
        "testing-framework"
      ],
      "concepts": [
        "testability",
        "dependency-injection",
        "static-context",
        "mocking",
        "TDD",
        "unit-testing"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot perform true unit testing of workflows using standard TDD practices due to static class design.",
      "rootCause": "Workflow class uses static context model similar to ASP.NET classic HttpContext, intentionally designed to prevent mocking and inheritance.",
      "proposedFix": "Refactor Workflow to be instance-based with abstractions/interfaces, similar to minimal APIs approach with dependency injection.",
      "workaround": "Use the Temporal testing framework provided in the SDK documentation as an alternative to mocking.",
      "resolution": "wontfix",
      "resolutionDetails": "Maintainers declined the request, explaining the static design is intentional and necessary because the Workflow represents the entire environment (similar to System.Environment), not just individual methods. The design rationale is documented in the SDK phase 2 proposal.",
      "related": [],
      "keyQuote": "The Workflow is part of the environment, not just part of specific methods. Think of it like System.Environment or System.Threading.ThreadPool.",
      "number": 182,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:43.688Z"
    },
    {
      "summary": "User requested dependency injection support for workflows, but the maintainer explained that workflows must be deterministic and self-contained, so DI is not supported by design.",
      "category": "feature",
      "subcategory": "dependency-injection",
      "apis": [],
      "components": [
        "workflow-construction",
        "hosting-extensions",
        "service-collection"
      ],
      "concepts": [
        "dependency-injection",
        "determinism",
        "workflow-constraints",
        "service-lifetime",
        "self-contained"
      ],
      "severity": "low",
      "userImpact": "Users cannot inject dependencies into workflows even when using the dependency injection package, limiting flexibility in workflow construction.",
      "rootCause": "Workflows must be deterministic and event-sourced to support durable resumption, which precludes external dependency injection.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Maintainer closed as not an issue, explaining that workflow determinism constraints prevent DI support by design, similar to Azure Durable Functions.",
      "related": [],
      "keyQuote": "Workflows are inherently self-contained, deterministic units of work and therefore should never call anything external.",
      "number": 181,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:31.262Z"
    },
    {
      "summary": "Workflow updates hang indefinitely when called in time-skipping test environments. The update method never completes even though it should immediately return, causing the workflow to become unresponsive.",
      "category": "bug",
      "subcategory": "workflow-update",
      "apis": [
        "ExecuteUpdateAsync",
        "StartWorkflowAsync",
        "DelayAsync"
      ],
      "components": [
        "workflow-update",
        "time-skipping",
        "test-framework"
      ],
      "concepts": [
        "workflow-execution",
        "time-skipping",
        "async-blocking",
        "test-environment",
        "update-handler"
      ],
      "severity": "high",
      "userImpact": "Developers cannot reliably test workflows with updates in time-skipping environments, blocking workflow update functionality testing.",
      "rootCause": "Time-skipping environment does not properly handle workflow update execution, causing the update handler to block indefinitely instead of returning.",
      "proposedFix": null,
      "workaround": "Use a normal local Temporal server for testing updates instead of time-skipping environment.",
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Updates are experimental/unstable currently, but in the meantime you should be able to use a normal local server if you must use them and need to test them.",
      "number": 179,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:29.542Z"
    },
    {
      "summary": "Child workflows cancelled before being scheduled return ChildWorkflowFailureException instead of CanceledFailureException, inconsistent with other cancellation scenarios.",
      "category": "bug",
      "subcategory": "child-workflow-cancellation",
      "apis": [
        "ExecuteChildWorkflow",
        "CanceledFailureException",
        "ChildWorkflowFailureException"
      ],
      "components": [
        "workflow-instance",
        "child-workflow-handler",
        "core-interop"
      ],
      "concepts": [
        "cancellation",
        "error-handling",
        "workflow-scheduling",
        "exception-mapping"
      ],
      "severity": "medium",
      "userImpact": "Users receive inconsistent exception types when cancelling child workflows depending on timing, making error handling and cancellation detection unreliable.",
      "rootCause": "Code that attempts to handle pre-scheduled cancellations may not execute before the call is handed off to Core, resulting in improper exception type being returned.",
      "proposedFix": "Document that calling with an already-cancelled token may have different exceptions than if cancelled before/after start, and recommend using TemporalException.IsCanceledException helper for cancellation detection.",
      "workaround": "Use TemporalException.IsCanceledException helper method to reliably detect cancelled exceptions regardless of type.",
      "resolution": "wontfix",
      "resolutionDetails": "Resolved as documentation issue. The behavior is consistent with .NET patterns (eager cancellation exceptions), so users should use the IsCanceledException helper for reliable cancellation detection.",
      "related": [],
      "keyQuote": "After discussion, throwing cancellation exceptions eagerly if a call is made with an already-cancelled token is the .NET way",
      "number": 178,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:31.337Z"
    },
    {
      "summary": "Handle updates that arrive before workflow start by implementing a buffer-for-life-of-task approach for update handlers. This allows dynamically registered handlers to receive updates even when the update activation event precedes the start event.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [],
      "components": [
        "activation-processing",
        "update-handler",
        "event-ordering"
      ],
      "concepts": [
        "update-before-start",
        "dynamic-handler-registration",
        "event-buffering",
        "activation-job-events",
        "task-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users cannot reliably register update handlers dynamically on start when updates arrive in the same activation task before the start event.",
      "rootCause": "Activation job events are ordered with updates before starts, but dynamically registered handlers on start miss these buffered updates.",
      "proposedFix": "Implement a buffer-for-life-of-task approach to store updates so dynamically registered handlers can receive them on workflow start.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        462
      ],
      "keyQuote": "We likely need some buffer-for-life-of-task approach to updates so dynamic handlers work on start.",
      "number": 176,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:17.343Z"
    },
    {
      "summary": ".NET SDK does not ignore unknown fields when parsing history JSON for replay, unlike Python and Go SDKs. The issue notes that a JsonParser ignore-unknown-fields setting exists but is not being used.",
      "category": "bug",
      "subcategory": "history-parsing",
      "apis": [],
      "components": [
        "json-parser",
        "history-parsing",
        "replay"
      ],
      "concepts": [
        "serialization",
        "json-parsing",
        "unknown-fields",
        "cross-sdk-compatibility",
        "history-replay"
      ],
      "severity": "medium",
      "userImpact": "Replay fails when history contains unknown fields that other SDKs handle gracefully, causing inconsistent behavior across SDK implementations.",
      "rootCause": ".NET JsonParser settings not configured to ignore unknown fields during history JSON deserialization, unlike other SDK implementations.",
      "proposedFix": "Enable the ignore-unknown-fields setting on JsonParser when parsing history proto from JSON.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "JsonParser ignore-unknown-fields setting was enabled for history parsing to match behavior of other SDKs.",
      "related": [],
      "keyQuote": "Python and Go and others ignore unknown fields when parsing JSON for history proto, but .NET doesn't.",
      "number": 173,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:14.764Z"
    },
    {
      "summary": "Feature request to add automatic tracing span creation when scheduling workflows with the tracing interceptor enabled, with opt-out capability in tracing options.",
      "category": "feature",
      "subcategory": "tracing-instrumentation",
      "apis": [
        "CreateSchedule",
        "StartWorkflow"
      ],
      "components": [
        "tracing-interceptor",
        "schedule-client",
        "workflow-header"
      ],
      "concepts": [
        "tracing",
        "spans",
        "instrumentation",
        "observability",
        "schedule-creation"
      ],
      "severity": "medium",
      "userImpact": "Users need manual workarounds to create tracing spans for schedules when using the tracing interceptor, reducing automatic observability coverage.",
      "rootCause": null,
      "proposedFix": "Default behavior: create spans for schedule creation and set on workflow header when action starts workflow. Allow opt-out via tracing interceptor options.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [
        394
      ],
      "keyQuote": "When the tracing interceptor is in use, by default creating a schedule should create a span for the schedule and set it on the workflow header if the action is starting a workflow.",
      "number": 171,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:11.562Z"
    },
    {
      "summary": "User questions why the .NET SDK doesn't build for .NET 6 LTS and suggests that keeping each framework version aligned (6 on 6, 7 on 7, 8 on 8) would prevent compatibility issues with transitive dependencies like System.Diagnostics.DiagnosticSource.",
      "category": "question",
      "subcategory": "build-configuration",
      "apis": [],
      "components": [
        "extensions-opentelemetry",
        "extensions-hosting",
        "nuget-package"
      ],
      "concepts": [
        "dependency-management",
        "framework-targeting",
        "version-compatibility",
        "lts-support"
      ],
      "severity": "low",
      "userImpact": "Users on .NET 6 LTS may experience compatibility issues if the SDK targets .NET 7 dependencies without providing dedicated .NET 6 builds.",
      "rootCause": "Misunderstanding about how framework targeting works; the maintainers clarified the SDK already supports .NET 6 and their tests run on it.",
      "proposedFix": "Ensure dedicated .NET 6 builds in the project configuration, or maintain strict version alignment between framework target and dependencies.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Maintainers clarified that the SDK already supports .NET 6 with proper test coverage; the concern was based on a misunderstanding of framework targeting and dependency version compatibility.",
      "related": [],
      "keyQuote": "When on net 6, it is best to keep everything on .net6. Trust me, you think this ddl and that dll are safe, then it ends up using something else, and no longer safe.",
      "number": 169,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:00.522Z"
    },
    {
      "summary": "Add the System.DllNotFoundException error message to the native-library README section to help users discover the solution for DLL loading failures.",
      "category": "docs",
      "subcategory": "native-library",
      "apis": [],
      "components": [
        "native-library",
        "README",
        "documentation"
      ],
      "concepts": [
        "DLL loading",
        "native dependencies",
        "error discoverability",
        "troubleshooting",
        "setup"
      ],
      "severity": "medium",
      "userImpact": "Users encountering DLL loading errors have difficulty finding the relevant documentation section that explains how to resolve the issue.",
      "rootCause": null,
      "proposedFix": "Include the System.DllNotFoundException error message in the native-library README section",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to include the error message for easier discoverability",
      "related": [],
      "keyQuote": "Include that error in that section for easier finding",
      "number": 167,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:06:57.195Z"
    },
    {
      "summary": "Add ability to configure which exception types should fail the workflow rather than just the activity. Implement WorkflowFailureExceptionTypes on TemporalWorkerOptions and FailureExceptionTypes on WorkflowAttribute/Definition, while blocking InvalidWorkflowOperationException pending core SDK changes.",
      "category": "feature",
      "subcategory": "workflow-failure-handling",
      "apis": [
        "TemporalWorkerOptions",
        "WorkflowAttribute",
        "WorkflowDefinition"
      ],
      "components": [
        "worker",
        "workflow-executor",
        "exception-handling",
        "configuration"
      ],
      "concepts": [
        "failure-propagation",
        "exception-types",
        "workflow-lifecycle",
        "error-handling",
        "task-failure",
        "exception-filtering"
      ],
      "severity": "medium",
      "userImpact": "Users need control over which exception types terminate the workflow versus being handled as activity failures, enabling better error handling strategies.",
      "rootCause": null,
      "proposedFix": "Add IReadOnlyCollection<Type> WorkflowFailureExceptionTypes to TemporalWorkerOptions; add Type[] FailureExceptionTypes to WorkflowAttribute and IReadOnlyCollection<Type> FailureExceptionTypes to WorkflowDefinition",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature implemented with necessary API additions to support workflow failure exception type configuration",
      "related": [
        322,
        656
      ],
      "keyQuote": "Need ability for certain task failure types to fail workflow",
      "number": 166,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T09:07:00.419Z"
    },
    {
      "summary": "User encountered a JSON deserialization error when passing a JSON string as an activity parameter. The issue was resolved when user corrected their parameter type to match the expected format.",
      "category": "question",
      "subcategory": "data-conversion",
      "apis": [
        "ExecuteActivity"
      ],
      "components": [
        "activity-worker",
        "data-converter",
        "json-serialization"
      ],
      "concepts": [
        "parameter-passing",
        "deserialization",
        "type-mismatch",
        "json-conversion"
      ],
      "severity": "low",
      "userImpact": "Users may experience parameter deserialization failures if they pass data in the wrong format to activities.",
      "rootCause": "User was sending a JSON string as a parameter when the activity expected the actual object type, causing the JSON deserializer to fail when it received a string token instead of an object.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "User confirmed they were using incorrect parameter types; resolved by sending the proper object type instead of a pre-serialized JSON string.",
      "related": [],
      "keyQuote": "If you're sending a string as a parameter, the parameter type needs to be string. If you're sending an object, you send the object and the data converter converts it to JSON for you.",
      "number": 165,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:50:13.174Z"
    },
    {
      "summary": "README workflow testing samples are missing worker execution, causing tests to timeout. The documentation shows incomplete example code that doesn't actually run the worker before executing the workflow.",
      "category": "docs",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflowAsync",
        "WorkflowEnvironment",
        "TemporalWorker"
      ],
      "components": [
        "test-framework",
        "worker",
        "documentation"
      ],
      "concepts": [
        "workflow-testing",
        "time-skipping",
        "worker-execution",
        "timeout",
        "test-setup",
        "mocking"
      ],
      "severity": "high",
      "userImpact": "Users following the README examples cannot run workflow tests successfully and experience test timeouts, blocking their ability to test workflows.",
      "rootCause": "The README sample code omits the required worker execution step before calling ExecuteWorkflowAsync, leaving the worker idle.",
      "proposedFix": "Update the README examples to include the actual worker execution/starting before executing the workflow.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Author committed to updating the README with corrected sample code that includes the missing worker execution step.",
      "related": [
        179
      ],
      "keyQuote": "In the sample code you are not actually running/executing the worker which you must do. I will update shortly.",
      "number": 162,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:50:11.928Z"
    },
    {
      "summary": "Feature request to allow continue-as-new workflow transitions from update handlers in the .NET SDK. This capability was evaluated but ultimately decided against by the team.",
      "category": "feature",
      "subcategory": "workflow-execution",
      "apis": [
        "ContinueAsNew"
      ],
      "components": [
        "workflow-executor",
        "update-handler",
        "runtime"
      ],
      "concepts": [
        "workflow-continuation",
        "update-handler",
        "state-transition",
        "workflow-control",
        "feature-request"
      ],
      "severity": "low",
      "userImpact": "Users cannot use continue-as-new functionality from within update handlers, limiting workflow control options in certain scenarios.",
      "rootCause": null,
      "proposedFix": "Enable continue-as-new to be callable from update handler context",
      "workaround": null,
      "resolution": "wontfix",
      "resolutionDetails": "Feature request was decided against by the team",
      "related": [],
      "keyQuote": "This feature request was decided against",
      "number": 161,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:50:10.162Z"
    },
    {
      "summary": "User requested support for Temporal Schedule feature in the .NET SDK. The feature was already fully implemented but not mentioned in the blog post, so this was essentially a documentation/awareness issue that has been resolved.",
      "category": "docs",
      "subcategory": "schedules",
      "apis": [
        "Schedule"
      ],
      "components": [
        "schedules-client",
        "documentation"
      ],
      "concepts": [
        "scheduling",
        "cron",
        "temporal-schedules",
        "reliable-scheduling"
      ],
      "severity": "low",
      "userImpact": "Users were unaware that the .NET SDK already had full schedules support, potentially leading them to implement workarounds or seek the feature elsewhere.",
      "rootCause": "Blog post did not mention that .NET SDK had schedules support, creating a documentation gap.",
      "proposedFix": "Update the blog post to mention .NET SDK schedules support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The .NET SDK already had full schedules support. The blog post was updated to reflect this.",
      "related": [],
      "keyQuote": "The DotNet SDK has full schedules support https://dotnet.temporal.io/api/Temporalio.Client.Schedules.html",
      "number": 160,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:49:58.511Z"
    },
    {
      "summary": "TemporalClient loses connection to Temporal Cloud after 1-2 days, timing out on workflow start operations. The connection doesn't recover automatically despite keep-alive being enabled, requiring application restart.",
      "category": "bug",
      "subcategory": "client-connection",
      "apis": [
        "StartWorkflowAsync"
      ],
      "components": [
        "TemporalClient",
        "TemporalConnection",
        "gRPC client"
      ],
      "concepts": [
        "timeout",
        "connection-loss",
        "keep-alive",
        "recovery",
        "idle-timeout",
        "cloud-networking"
      ],
      "severity": "high",
      "userImpact": "Users experience timeout errors when starting workflows after 1-2 days, and the connection doesn't automatically recover even with configured retry logic, requiring manual application restart.",
      "rootCause": "Likely idle connection timeout from Azure cloud environment closing outbound connections; keep-alive mechanism not preventing disconnection in this scenario",
      "proposedFix": "Update to SDK version with improved keep-alive mechanism; monitor for connection state and implement automatic reconnection",
      "workaround": "Configure exponential retry logic on workflow start calls; manually restart application when timeouts occur",
      "resolution": "fixed",
      "resolutionDetails": "Issue was resolved by updating to beta2 with improved keep-alive mechanism. Azure environment idle timeouts were identified as root cause; keep-alive enabled by default in newer versions prevents this.",
      "related": [],
      "keyQuote": "After a day or two we have noticed that Temporal client loses connection with temporal Cloud and is unable to start any new Workflow(s)",
      "number": 158,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:49:56.528Z"
    },
    {
      "summary": "Feature request to automatically default TemporalWorkerOptions.DebugMode to the value of Debugger.IsAttached, while still allowing explicit overrides to true or false.",
      "category": "feature",
      "subcategory": "worker-configuration",
      "apis": [
        "TemporalWorkerOptions"
      ],
      "components": [
        "worker",
        "configuration",
        "debug-mode"
      ],
      "concepts": [
        "debugging",
        "developer-experience",
        "configuration-defaults",
        "debugger-integration"
      ],
      "severity": "low",
      "userImpact": "Developers can have debug mode automatically enabled when a debugger is attached, reducing manual configuration.",
      "rootCause": null,
      "proposedFix": "Default TemporalWorkerOptions.DebugMode to Debugger.IsAttached value",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was closed after feature implementation",
      "related": [],
      "keyQuote": "Default `TemporalWorkerOptions.DebugMode` to `Debugger.IsAttached`. Still must be explicitly overridable to true/false of course.",
      "number": 157,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:49:55.686Z"
    },
    {
      "summary": "Request to clarify in ITemporalClient documentation that the client is thread-safe and should be reused across threads to effectively leverage connection pooling.",
      "category": "docs",
      "subcategory": "documentation",
      "apis": [
        "ITemporalClient"
      ],
      "components": [
        "client",
        "documentation"
      ],
      "concepts": [
        "thread-safety",
        "connection-pooling",
        "client-reuse",
        "concurrency"
      ],
      "severity": "low",
      "userImpact": "Developers may not understand that ITemporalClient is thread-safe and can be safely shared across threads, potentially missing optimization opportunities.",
      "rootCause": null,
      "proposedFix": "Add clarification to ITemporalClient documentation stating it is thread-safe and should be reused across threads for effective connection pooling.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated to clarify that ITemporalClient is thread-safe and should be reused across threads.",
      "related": [],
      "keyQuote": "clarify that it is thread safe and not only meant for multithreaded use, but encouraged so it can leverage connection pooling effectively",
      "number": 156,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:34:04.885Z"
    },
    {
      "summary": "Workflow update handles should automatically use the run ID returned from the start operation, ensuring consistency. The issue also calls for better documentation about the consequences of not using a workflow handle with a specific run ID.",
      "category": "feature",
      "subcategory": "workflow-updates",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-handle",
        "update-handler",
        "workflow-execution"
      ],
      "concepts": [
        "run-id",
        "workflow-updates",
        "handle-management",
        "state-consistency"
      ],
      "severity": "medium",
      "userImpact": "Users must manually manage run IDs when using workflow update handles, which can lead to inconsistencies if not done correctly.",
      "rootCause": null,
      "proposedFix": "Automatically set the run ID from the start operation result for update handles, and improve documentation about run ID requirements.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in PR #382",
      "related": [
        382
      ],
      "keyQuote": "Updates only ever apply to one run, so we should always set the run ID as what comes back from start, regardless of input.",
      "number": 155,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:49:32.988Z"
    },
    {
      "summary": "StartUpdateAsync throws AggregateException instead of unwrapping the actual exception when called on a non-existent workflow handle, due to improper exception handling in the ContinueWith implementation.",
      "category": "bug",
      "subcategory": "workflow-updates",
      "apis": [
        "StartUpdateAsync"
      ],
      "components": [
        "workflow-handle",
        "update-client",
        "exception-handling"
      ],
      "concepts": [
        "exception-unwrapping",
        "async-operations",
        "aggregateexception",
        "task-continuations"
      ],
      "severity": "medium",
      "userImpact": "Users receive wrapped AggregateException instead of the original exception when updating non-existent workflows, making error handling and debugging more difficult.",
      "rootCause": "ContinueWith usage in update internals was not properly unwrapping exceptions from the task.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The internals of update have been rewritten since this issue was filed, resolving the exception handling problem.",
      "related": [],
      "keyQuote": "The internals of update have been rewritten since this so this no longer applies",
      "number": 151,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:49:43.549Z"
    },
    {
      "summary": "Remove the PollWorkflowUpdateAsync method from ClientOutboundInterceptor as it doesn't need to be interceptable, similar to how getting a workflow result is not interceptable.",
      "category": "feature",
      "subcategory": "interceptor-api",
      "apis": [
        "PollWorkflowUpdateAsync"
      ],
      "components": [
        "client",
        "interceptor",
        "workflow-update"
      ],
      "concepts": [
        "interception",
        "api-design",
        "workflow-updates",
        "client-outbound"
      ],
      "severity": "low",
      "userImpact": "Simplifies the interceptor API by removing an unnecessary interception point that adds complexity without practical value.",
      "rootCause": null,
      "proposedFix": "Remove ClientOutboundInterceptor.PollWorkflowUpdateAsync method",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The method was removed from the ClientOutboundInterceptor as it was determined to not need interception capability",
      "related": [],
      "keyQuote": "This does not need to be interceptable any more than getting a workflow result does",
      "number": 148,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:33:51.705Z"
    },
    {
      "summary": "Remove the timeout parameter from WorkflowUpdateHandle.GetResultAsync as it's redundant when users can achieve the same behavior using cancellation tokens, and the timeout is not present on WorkflowHandle.GetResultAsync for consistency.",
      "category": "feature",
      "subcategory": "workflow-updates",
      "apis": [
        "WorkflowUpdateHandle.GetResultAsync",
        "WorkflowHandle.GetResultAsync"
      ],
      "components": [
        "workflow-client",
        "update-handle",
        "async-api"
      ],
      "concepts": [
        "timeout",
        "cancellation-token",
        "api-consistency",
        "backwards-compatibility"
      ],
      "severity": "low",
      "userImpact": "Users will need to migrate from using timeout parameters to cancellation tokens for controlling GetResultAsync timeouts, reducing API surface inconsistency.",
      "rootCause": "Timeout parameter exists on WorkflowUpdateHandle.GetResultAsync but not on WorkflowHandle.GetResultAsync, creating inconsistency and redundancy since cancellation tokens provide equivalent functionality.",
      "proposedFix": "Remove the timeout parameter from WorkflowUpdateHandle.GetResultAsync and rely on cancellation tokens for timeout control.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Timeout parameter was removed from WorkflowUpdateHandle.GetResultAsync to align with WorkflowHandle.GetResultAsync and leverage cancellation token functionality.",
      "related": [],
      "keyQuote": "Users can do this with the cancellation token if they want, no reason to have this if we're not also gonna have it on WorkflowHandle.GetResultAsync",
      "number": 147,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:33:49.667Z"
    },
    {
      "summary": "Request to expose the StartDelay option in Workflow Options, allowing users to delay the start of workflow execution.",
      "category": "feature",
      "subcategory": "workflow-options",
      "apis": [
        "StartWorkflow"
      ],
      "components": [
        "workflow-options",
        "workflow-client"
      ],
      "concepts": [
        "delay",
        "scheduling",
        "workflow-execution",
        "start-time"
      ],
      "severity": "low",
      "userImpact": "Users cannot currently delay workflow execution start time and must implement external scheduling workarounds.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "StartDelay was added to Workflow Options",
      "related": [],
      "keyQuote": "Expose StartDelay in Workflow Options",
      "number": 145,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:33:53.811Z"
    },
    {
      "summary": "The DeleteWorkflowExecution gRPC service call is not properly exposed in the .NET SDK. Additionally, there's a need for comprehensive unit tests to ensure all workflow and operator service calls are tested going forward.",
      "category": "bug",
      "subcategory": "grpc-service-exposure",
      "apis": [
        "DeleteWorkflowExecution"
      ],
      "components": [
        "grpc-client",
        "workflow-service",
        "operator-service"
      ],
      "concepts": [
        "service-exposure",
        "grpc-calls",
        "unit-testing",
        "api-completeness",
        "test-coverage"
      ],
      "severity": "medium",
      "userImpact": "Users cannot delete workflow executions through the .NET SDK, limiting workflow management capabilities.",
      "rootCause": "DeleteWorkflowExecution call not exposed in the SDK's service client wrapper",
      "proposedFix": "Expose the DeleteWorkflowExecution call and implement reflective unit tests that call every workflow and operator service method against a fake gRPC server",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The DeleteWorkflowExecution service call was exposed in the SDK and comprehensive tests were added",
      "related": [],
      "keyQuote": "Not only do we need to, but we need a unit test to make sure no calls are ever missed going forward.",
      "number": 143,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:33:36.480Z"
    },
    {
      "summary": "Feature request to support dynamic TLS/SSL certificate refresh on the Temporal .NET client without restarting workers. Users need the ability to update TLS options at runtime to handle short-lived certificates required by compliance policies.",
      "category": "feature",
      "subcategory": "tls-certificates",
      "apis": [],
      "components": [
        "client",
        "tls-options",
        "grpc-connection"
      ],
      "concepts": [
        "certificate-refresh",
        "dynamic-configuration",
        "security",
        "compliance",
        "connection-management"
      ],
      "severity": "medium",
      "userImpact": "Users with short-lived TLS certificates must restart workers when certificates expire instead of refreshing them dynamically, causing service disruptions.",
      "rootCause": "gRPC connection lives in unmanaged Rust, preventing standard .NET certificate refresh approaches from working.",
      "proposedFix": "Implement DynamicTlsOptions class with async callback mechanism to retrieve updated TLS options, with guaranteed minimum callback frequency.",
      "workaround": "Create new clients with different TLS options and set them on workers for successive client calls to use newer client.",
      "resolution": "fixed",
      "resolutionDetails": "Completed by allowing new clients to be created with different TLS options and set on workers for successive calls.",
      "related": [
        477
      ],
      "keyQuote": "We would like the ability to dynamically refresh the TLS options on the Temporal client instead of having to restart the Temporal worker itself",
      "number": 141,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:33:38.185Z"
    },
    {
      "summary": "Add support for log forwarding from core to language side in .NET SDK, similar to existing TypeScript implementation. Currently, a log forwarding export layer is registered in Bridge but never polled, making it effectively a no-op.",
      "category": "feature",
      "subcategory": "logging",
      "apis": [],
      "components": [
        "bridge",
        "log-exporter",
        "runtime"
      ],
      "concepts": [
        "log-forwarding",
        "observability",
        "core-lang-communication",
        "metrics-forwarding",
        "push-based-export"
      ],
      "severity": "medium",
      "userImpact": "Users cannot currently forward logs from Temporal core to the .NET language layer for centralized logging and observability.",
      "rootCause": "Log forwarding registration exists in runtime.rs but the language side never polls for log entries, making the exporter non-functional.",
      "proposedFix": "Implement push-based log forwarding similar to metrics forwarding to avoid FFI overhead, depending on sdk-core issue #618 for core-side support.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide push-based log forwarding matching the metrics forwarding behavior.",
      "related": [
        618
      ],
      "keyQuote": "we'd surely want this push based in .NET where there is not as much FFI overhead as there is in other languages",
      "number": 140,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:33:35.291Z"
    },
    {
      "summary": "Document and clarify that the .NET NuGet package doesn't support Windows ARM, 32-bit, or Linux MUSL architectures. Consider building separate runtime packages for these alternative architectures if GitHub runners become available.",
      "category": "feature",
      "subcategory": "documentation",
      "apis": [],
      "components": [
        "nuget-package",
        "build-system",
        "runtime-support"
      ],
      "concepts": [
        "architecture-support",
        "cross-platform",
        "distribution",
        "documentation",
        "build-configuration"
      ],
      "severity": "low",
      "userImpact": "Users attempting to use the SDK on unsupported architectures encounter missing documentation and cannot use the package on Windows ARM, 32-bit, or Linux MUSL systems.",
      "rootCause": null,
      "proposedFix": "Better document lack of support in README; optionally create separate architecture-specific runtime packages similar to ephemeral-mongo's approach",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Support limitations clarified in the README",
      "related": [],
      "keyQuote": "Do a better job of documenting that our NuGet package doesn't support Windows ARM, 32-bit, or Linux MUSL",
      "number": 139,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:19:26.730Z"
    },
    {
      "summary": "The .NET SDK needs to ensure that when metrics config is not present, a no-op metric meter is used instead of failing to create one, matching the behavior implemented in the Python SDK.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "configuration",
        "meter"
      ],
      "concepts": [
        "metrics",
        "observability",
        "no-op pattern",
        "configuration",
        "SDK consistency"
      ],
      "severity": "low",
      "userImpact": "Users who don't configure metrics may experience inconsistent behavior across SDKs, potentially leading to missing observability features.",
      "rootCause": "The metric meter creation logic may fail or not be initialized when metrics configuration is absent, unlike the Python SDK implementation.",
      "proposedFix": "Implement a no-op metric meter that is returned when metrics config is not present, consistent with the Python SDK approach.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to ensure no-op metric meter is used when metrics config is absent.",
      "related": [],
      "keyQuote": "When developing this feature in Python, it appeared that the metric meter was not created when metrics config is not present. So we need to use a no-op one",
      "number": 135,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:19:28.667Z"
    },
    {
      "summary": "Request for a type-safe helper method on options for signal with start functionality. Currently uses an untyped approach; the feature request seeks a lambda expression-based alternative that provides compile-time type safety.",
      "category": "feature",
      "subcategory": "signal-with-start",
      "apis": [
        "SignalWithStart"
      ],
      "components": [
        "options",
        "signal-handling",
        "type-safety"
      ],
      "concepts": [
        "type-safety",
        "lambda-expressions",
        "helper-methods",
        "signals",
        "workflow-start"
      ],
      "severity": "medium",
      "userImpact": "Users currently lack type-safe options for signal with start operations, requiring untyped approaches that increase runtime errors.",
      "rootCause": null,
      "proposedFix": "Add a helper method on options that accepts lambda expressions for type-safe signal with start configuration.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to provide type-safe lambda expression support for signal with start options.",
      "related": [],
      "keyQuote": "Need a helper on options that will accept lambda expression approach for signal with start instead of the untyped approach in use today.",
      "number": 134,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:19:25.413Z"
    },
    {
      "summary": "Add LastFailure and LastResult properties to WorkflowInfo in the .NET SDK to match functionality available in other Temporal SDKs. These properties are useful for workflow retries and cron/schedule workflows.",
      "category": "feature",
      "subcategory": "workflow-info",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "dotnet-sdk"
      ],
      "concepts": [
        "workflow-retry",
        "cron-workflows",
        "schedule-workflows",
        "failure-handling",
        "result-tracking"
      ],
      "severity": "medium",
      "userImpact": "Users cannot access last failure and result information in .NET SDK workflows, limiting debugging and retry logic capabilities compared to other SDKs.",
      "rootCause": null,
      "proposedFix": "Add LastFailure and LastResult properties to the WorkflowInfo class to provide parity with other SDKs.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented and added to WorkflowInfo class in .NET SDK.",
      "related": [],
      "keyQuote": "These are present on other SDKs. LastResult is mostly only for cron/schedule, but LastFailure can also have value for workflow retry.",
      "number": 133,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:19:09.104Z"
    },
    {
      "summary": "Feature request for typed search attributes in the .NET SDK. This was a proposal to implement typed search attributes similar to other Temporal SDKs, and has already been implemented in the .NET SDK.",
      "category": "feature",
      "subcategory": "search-attributes",
      "apis": [],
      "components": [
        "search-attributes",
        "type-system"
      ],
      "concepts": [
        "type-safety",
        "search",
        "attributes",
        "workflow-query"
      ],
      "severity": "low",
      "userImpact": "Users can now use type-safe search attributes in the .NET SDK for better code safety and IDE support.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Typed search attributes feature was already implemented in the .NET SDK, so the request is complete.",
      "related": [],
      "keyQuote": "Typed search attributes is already implemented in .NET",
      "number": 132,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:19:14.415Z"
    },
    {
      "summary": "Feature request to support building NuGet packages locally for a single platform, rather than requiring the full multi-platform build that currently only works in GitHub workflows.",
      "category": "feature",
      "subcategory": "build-packaging",
      "apis": [],
      "components": [
        "nuget-build",
        "build-system",
        "packaging"
      ],
      "concepts": [
        "local-build",
        "single-platform",
        "package-distribution",
        "developer-workflow",
        "build-automation"
      ],
      "severity": "low",
      "userImpact": "Developers can now build NuGet packages locally for development and testing purposes without needing access to the full multi-platform GitHub workflow infrastructure.",
      "rootCause": null,
      "proposedFix": "Implement a local build script or configuration that supports building NuGet packages for a single platform, as an alternative to the multi-platform GitHub workflow.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "But some people want to build the NuGet package locally, so we should support it, even if it is for only one platform.",
      "number": 131,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:19:11.630Z"
    },
    {
      "summary": "Security vulnerabilities detected in tonic-0.9.2 dependency chain, specifically CPU denial of service vulnerabilities in rustls-webpki-0.101.3 transitive dependency. The highest severity vulnerability (CVE-7.5) could allow network-based DoS attacks.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "bridge",
        "tonic",
        "rustls",
        "tokio-rustls"
      ],
      "concepts": [
        "security",
        "vulnerability",
        "dependency",
        "denial-of-service",
        "certificate-verification",
        "cpu-exhaustion"
      ],
      "severity": "high",
      "userImpact": "Applications using the SDK are vulnerable to CPU denial of service attacks through malicious certificate chains.",
      "rootCause": "Transitive dependency rustls-webpki-0.101.3 in tonic-0.9.2 lacks limits on certificate path building work, allowing pathological inputs to cause CPU exhaustion.",
      "proposedFix": "Upgrade rustls-webpki to version 0.100.2 or 0.101.4, which includes fixes for both WS-2023-0305 and CVE-2018-16875.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend after the vulnerable library was either marked as ignored or removed from the inventory.",
      "related": [],
      "keyQuote": "rustls-webpki: CPU denial of service in certificate path building",
      "number": 130,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:18:58.096Z"
    },
    {
      "summary": "Transitive dependency vulnerability in atty-0.2.14 (CVSS 5.3) affecting cbindgen-0.24.5 through clap. The issue involves potential pointer misalignment on Windows, though practically mitigated by the system allocator.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "cbindgen",
        "cargo-dependencies",
        "bridge-library"
      ],
      "concepts": [
        "security-vulnerability",
        "transitive-dependency",
        "pointer-alignment",
        "windows-specific",
        "memory-safety"
      ],
      "severity": "medium",
      "userImpact": "Users of the .NET SDK are exposed to a medium-severity vulnerability in a transitive dependency that could affect application stability on Windows systems.",
      "rootCause": "atty-0.2.14 dereferences a potentially unaligned pointer on Windows, though the System allocator's HeapAlloc guarantees sufficient alignment in practice.",
      "proposedFix": "Disable cbindgen default features to remove the atty dependency, or upgrade transitive dependencies to patched versions.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Bridge library was moved to sdk-core repo and cbindgen default features were disabled, eliminating the atty dependency.",
      "related": [],
      "keyQuote": "Bridge library has been moved to sdk-core repo. Also, `cbindgen` default features were disabled so the library doesn't depend on `atty` anymore.",
      "number": 128,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:44.070Z"
    },
    {
      "summary": "Feature request to implement advanced metrics support in the .NET SDK following sdk-core updates, including Prometheus options, OpenTelemetry options, and access to metrics from runtime, activity, and workflow contexts. Most items are completed, with .NET-provided metric implementation remaining as a non-trivial task.",
      "category": "feature",
      "subcategory": "metrics",
      "apis": [],
      "components": [
        "metrics",
        "runtime",
        "activity",
        "workflow"
      ],
      "concepts": [
        "observability",
        "prometheus",
        "opentelemetry",
        "metrics-collection",
        "monitoring",
        "instrumentation"
      ],
      "severity": "medium",
      "userImpact": "Enables users to integrate advanced metrics collection and monitoring capabilities into their .NET-based Temporal workflows.",
      "rootCause": null,
      "proposedFix": "Support .NET provided metric implementation for advanced metrics integration.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Most items completed including Prometheus options, OpenTelemetry options, metrics access from runtime/activity/workflow. Remaining .NET metric implementation task addressed in follow-up work.",
      "related": [
        129
      ],
      "keyQuote": "Support .NET provided metric implementation (interesting...)",
      "number": 126,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:18:55.509Z"
    },
    {
      "summary": "Feature request to expose client keep-alive functionality once the design is finalized in sdk-core. This is a dependency on upstream architecture decisions.",
      "category": "feature",
      "subcategory": "client-connection",
      "apis": [],
      "components": [
        "client",
        "connection-management"
      ],
      "concepts": [
        "keep-alive",
        "connection-persistence",
        "client-lifecycle",
        "heartbeat"
      ],
      "severity": "low",
      "userImpact": "Users need client keep-alive support to maintain stable long-lived connections with the Temporal server.",
      "rootCause": null,
      "proposedFix": "Expose the keep-alive mechanism once sdk-core issue #585 is resolved with a final design.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented after upstream sdk-core issue #585 was resolved with a finalized design.",
      "related": [
        585
      ],
      "keyQuote": "Expose whatever is decided at https://github.com/temporalio/sdk-core/issues/585 once that is done",
      "number": 125,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:32.149Z"
    },
    {
      "summary": "Feature request to expose WorkflowInfo.LastFailure property in the .NET SDK, which should contain information about the last failure of a workflow execution.",
      "category": "feature",
      "subcategory": "workflow-metadata",
      "apis": [
        "WorkflowInfo"
      ],
      "components": [
        "workflow-info",
        "api-exposure",
        "dotnet-sdk"
      ],
      "concepts": [
        "workflow-failure",
        "failure-tracking",
        "error-history",
        "workflow-context",
        "execution-metadata"
      ],
      "severity": "low",
      "userImpact": "Users cannot access the last failure information of a workflow execution, limiting diagnostic capabilities in workflow implementations.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Fixed in issue #133",
      "related": [
        133
      ],
      "keyQuote": "Not currently making last failure available like we should",
      "number": 124,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:30.572Z"
    },
    {
      "summary": "Feature request to expose history-related properties (`HistoryLength`, `HistorySize`, and `ShouldContinueAsNew`) to the Workflow class in the .NET SDK for better history management within workflows.",
      "category": "feature",
      "subcategory": "workflow-history",
      "apis": [
        "Workflow"
      ],
      "components": [
        "workflow",
        "history-management"
      ],
      "concepts": [
        "history-length",
        "history-size",
        "continue-as-new",
        "state-management"
      ],
      "severity": "medium",
      "userImpact": "Workflow developers can now monitor and react to history growth to optimize workflow execution and prevent history bloat.",
      "rootCause": null,
      "proposedFix": "Add HistoryLength, HistorySize, and ShouldContinueAsNew as properties on the Workflow class",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The requested properties were added to the Workflow class in the .NET SDK",
      "related": [],
      "keyQuote": "Need `HistoryLength`, `HistorySize`, and `ShouldContinueAsNew` properties on `Workflow`.",
      "number": 122,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:29.575Z"
    },
    {
      "summary": "Critical security vulnerability (CVSS 9.8) in transitive dependency atty-0.2.14 used by cbindgen-0.24.3, with potential unaligned read vulnerability. Issue was automatically closed after the vulnerable library was removed from inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "cbindgen",
        "dependency-management",
        "transitive-dependencies"
      ],
      "concepts": [
        "security-vulnerability",
        "supply-chain",
        "dependency-resolution",
        "cvss-score"
      ],
      "severity": "critical",
      "userImpact": "Developers using this SDK version may be exposed to a critical remote code execution vulnerability through a transitive dependency.",
      "rootCause": "Unaligned read vulnerability in atty-0.2.14 library used transitively through cbindgen  clap dependency chain",
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Automatically closed by Mend when the vulnerable library was removed from inventory or marked as ignored",
      "related": [],
      "keyQuote": "atty potential unaligned read",
      "number": 121,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:18.340Z"
    },
    {
      "summary": "Activity definition caching incorrectly reuses the invoker instance across different activity instances registered on different objects, causing the wrong invoker to be used. Only non-invocable details should be cached, not the instance-bound invoker.",
      "category": "bug",
      "subcategory": "activity-caching",
      "apis": [],
      "components": [
        "activity-definition",
        "cache",
        "invoker"
      ],
      "concepts": [
        "caching",
        "instance-binding",
        "method-registration",
        "invoker-reuse",
        "activity-discovery"
      ],
      "severity": "high",
      "userImpact": "Activities registered on different instances with the same method will incorrectly share the same invoker, causing method calls to execute on the wrong instance.",
      "rootCause": "The activity definition cache stores both non-invocable details and the instance-bound invoker together, causing the cached invoker from the first instance to be reused for subsequent registrations of the same method on different instances.",
      "proposedFix": "Only cache the non-invocable details of the activity definition, not the invoker which is bound to a specific instance.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "When an activity is added for the same method on different instances, we reuse the cache for the first instance which also has the invoker cached which is bound to that one instance.",
      "number": 117,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:14.471Z"
    },
    {
      "summary": "The DI worker service contains a logic error where it checks if an existing client's logger factory is null, which is impossible. The check should either be fixed to allow null values or removed entirely.",
      "category": "bug",
      "subcategory": "dependency-injection",
      "apis": [],
      "components": [
        "DI worker service",
        "logger factory",
        "client configuration"
      ],
      "concepts": [
        "dependency injection",
        "logger factory",
        "null checking",
        "configuration validation"
      ],
      "severity": "medium",
      "userImpact": "Users may experience incorrect logger factory behavior in dependency-injected worker services due to faulty null validation logic.",
      "rootCause": "A null check on the existing client's logger factory is logically impossible, indicating either incorrect logic or misunderstood requirements.",
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The impossible null check was identified and corrected in the DI worker service implementation.",
      "related": [],
      "keyQuote": "We are checking whether existing client's logger factory is null which is impossible. Either make that possible or remove the check.",
      "number": 116,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:15.628Z"
    },
    {
      "summary": "Update the README to demonstrate client dependency injection using the extension project instead of the current approach. This change is dependent on issue #98 being released first.",
      "category": "docs",
      "subcategory": "readme-examples",
      "apis": [],
      "components": [
        "readme",
        "dependency-injection",
        "client-configuration"
      ],
      "concepts": [
        "dependency-injection",
        "configuration",
        "extensions",
        "documentation",
        "setup"
      ],
      "severity": "low",
      "userImpact": "Users will have better, more maintainable examples for setting up client dependency injection in their applications.",
      "rootCause": null,
      "proposedFix": "Update README to use the extension project for client DI configuration",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "README was updated to use the extension project for client DI after issue #98 was released",
      "related": [
        98
      ],
      "keyQuote": "Update README client DI to use extension project, but wait until #98 is released",
      "number": 110,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:00.099Z"
    },
    {
      "summary": "Standardize exception naming to use single-L for 'canceled' type names (e.g., CanceledFailureException) to align with .NET conventions, while keeping double-L for 'cancellation' in other contexts like CancellationToken.",
      "category": "other",
      "subcategory": "api-naming",
      "apis": [],
      "components": [
        "exception-handling",
        "api-design"
      ],
      "concepts": [
        "naming-conventions",
        "compatibility",
        "api-consistency",
        "exceptions"
      ],
      "severity": "low",
      "userImpact": "Developers will have more intuitive and consistent exception names that align with .NET naming conventions.",
      "rootCause": null,
      "proposedFix": "Rename exception types to use single-L spelling for 'canceled' (e.g., CanceledFailureException instead of CancelledFailureException), while preserving double-L for CancellationToken and related types.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Exception naming was standardized to use single-L for 'canceled' types to match .NET conventions.",
      "related": [],
      "keyQuote": "For example, .NET has `OperationCanceledException` so ours should be `CanceledFailureException`",
      "number": 109,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:05:58.077Z"
    },
    {
      "summary": "Feature request to add a way to disable tracing events within workflows to support running non-workflow async calls in workflow interceptors. The request was closed because the proposed solution doesn't address the underlying problem of running code outside the workflow scheduler.",
      "category": "feature",
      "subcategory": "tracing",
      "apis": [
        "Workflow"
      ],
      "components": [
        "workflow-interceptors",
        "task-scheduler",
        "tracing"
      ],
      "concepts": [
        "tracing-events",
        "workflow-scheduler",
        "async-execution",
        "interceptors"
      ],
      "severity": "low",
      "userImpact": "Users cannot safely run non-workflow async calls within workflow interceptors without workarounds.",
      "rootCause": "Running arbitrary async calls in workflow interceptors may use the current task scheduler instead of the workflow scheduler, making the proposed tracing disable feature insufficient to solve the actual problem.",
      "proposedFix": "Create a mechanism to disable tracing events (initially proposed as a using statement), though this was found to be inadequate for the actual use case.",
      "workaround": "Create a task on the default scheduler and explicitly Wait on it, then explicitly manage switching back to the workflow scheduler if needed.",
      "resolution": "wontfix",
      "resolutionDetails": "The proposed solution of disabling tracing events does not solve the actual problem of safely running outside the workflow scheduler. The underlying issue requires a different architectural approach.",
      "related": [],
      "keyQuote": "The solution presented (disabling this inside a workflow) does not solve the actual problem of running outside the workflow scheduler.",
      "number": 108,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T08:06:02.253Z"
    },
    {
      "summary": "The README needs to clarify that the .NET SDK requires a native shared library (temporal_sdk_bridge) for different platforms and architectures. Users building for different platforms than their build machine need explicit runtime identifiers, and the documentation should explain why a Rust-backed native library is used.",
      "category": "docs",
      "subcategory": "documentation",
      "apis": [],
      "components": [
        "native-interop",
        "build-system",
        "runtime-requirements",
        "README"
      ],
      "concepts": [
        "cross-compilation",
        "platform-specific",
        "runtime-identifiers",
        "native-library",
        "build-configuration"
      ],
      "severity": "medium",
      "userImpact": "Users attempting to build for different platforms are confused about native library requirements and may experience build failures without explicit RID configuration.",
      "rootCause": "The README does not adequately document the dependency on platform-specific native shared libraries or the need for explicit runtime identifiers during cross-platform builds.",
      "proposedFix": "Update the README to clarify the native shared library dependency, list supported RIDs, explain the need for explicit --runtime flags when cross-compiling, and provide context about why the library uses a Rust-backed native core.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was improved to clarify the native library requirement and cross-compilation setup",
      "related": [],
      "keyQuote": "We need to make clear this is backed by an unmanaged native shared library, which RIDs we support, and that they need to be explicitly provided when building for a different platform",
      "number": 107,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:58:14.837Z"
    },
    {
      "summary": "Documentation enhancement needed to clarify .NET SDK workflow inheritance rules, specifically explaining why [Workflow] attributes and [WorkflowRun] methods aren't inherited from parent classes, while signals/queries can be inherited if properly attributed.",
      "category": "docs",
      "subcategory": "workflow-inheritance",
      "apis": [
        "Workflow",
        "WorkflowRun"
      ],
      "components": [
        "workflow-definition",
        "attribute-system",
        "documentation"
      ],
      "concepts": [
        "inheritance",
        "attributes",
        "workflow-signals",
        "workflow-queries",
        "shared-code",
        "base-classes"
      ],
      "severity": "low",
      "userImpact": "Developers lack clear understanding of inheritance rules for workflow attributes, potentially leading to confusion during SDK usage and incorrect workflow implementations.",
      "rootCause": null,
      "proposedFix": "Add a 'Workflow Inheritance' section to the README documenting inheritance rules and rationale for [Workflow] attributes, [WorkflowRun] methods, and signal/query inheritance.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Documentation was updated with clarification on workflow inheritance rules and reasons.",
      "related": [],
      "keyQuote": "we intentionally do not inherit a parent's [Workflow] attribute or [WorkflowRun] method... we do allow inheriting workflow signals/queries from base classes",
      "number": 106,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:58:14.938Z"
    },
    {
      "summary": "Signals with args that can't be deserialized should be dropped/ignored in the .NET SDK, consistent with Go and Java implementations.",
      "category": "bug",
      "subcategory": "signal-handling",
      "apis": [],
      "components": [
        "signal-handler",
        "deserialization",
        "worker"
      ],
      "concepts": [
        "signal-handling",
        "deserialization",
        "error-recovery",
        "cross-language-consistency"
      ],
      "severity": "medium",
      "userImpact": "Unhandled deserialization errors in signals may cause worker failures instead of gracefully dropping invalid signals.",
      "rootCause": ".NET SDK does not drop signals with non-deserializable args, unlike Go and Java SDKs",
      "proposedFix": "Implement signal dropping behavior for deserialization failures, matching Go and Java implementations",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Signal deserialization error handling was implemented to match behavior in other SDKs",
      "related": [],
      "keyQuote": "In Go and Java we drop signals whose args can't be deserialized, we should here too.",
      "number": 105,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:58:12.451Z"
    },
    {
      "summary": "Fix improper capitalization of 'ID' to 'Id' in the .NET SDK before beta release. This is a naming convention correction to follow proper C# capitalization standards.",
      "category": "bug",
      "subcategory": "naming-convention",
      "apis": [],
      "components": [
        "sdk-core",
        "api-definitions"
      ],
      "concepts": [
        "naming-convention",
        "capitalization",
        "api-design",
        "c#-standards"
      ],
      "severity": "low",
      "userImpact": "Users will need to update their code to use 'Id' instead of 'ID' when upgrading to the beta version.",
      "rootCause": "Incorrect capitalization applied during initial SDK development",
      "proposedFix": "Change all instances of 'ID' to 'Id' throughout the codebase",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Naming convention was corrected to use proper C# capitalization 'Id' instead of 'ID'",
      "related": [],
      "keyQuote": "We erroneously uppercased `ID` instead of proper capitalization of `Id`. Fix this before beta.",
      "number": 104,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:58:01.400Z"
    },
    {
      "summary": "Add .NET Framework compatibility testing by creating a smoke test project to verify that the NuGet package properly copies native DLLs when used with .NET Framework, as currently only .NET 6+ is tested.",
      "category": "feature",
      "subcategory": "testing",
      "apis": [],
      "components": [
        "nuget-package",
        "native-binaries",
        "test-framework"
      ],
      "concepts": [
        "compatibility",
        "binary-distribution",
        "framework-support",
        "smoke-testing",
        "ci-cd"
      ],
      "severity": "medium",
      "userImpact": ".NET Framework users may experience runtime failures if native DLLs are not properly packaged or copied by NuGet.",
      "rootCause": null,
      "proposedFix": "Create an additional `test/Temporalio.SmokeTestNetFramework` project checked as part of the `.github/workflows/package.yml` workflow to verify native DLL copying works correctly.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented smoke test project for .NET Framework to verify native DLL packaging and copying during CI/CD.",
      "related": [],
      "keyQuote": "We need to make sure the NuGet package created works with .NET Framework and properly copies the native DLL.",
      "number": 101,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:57:58.859Z"
    },
    {
      "summary": "Feature request for workflow update support in the .NET SDK. This is a blocking feature that depends on core SDK functionality being implemented.",
      "category": "feature",
      "subcategory": "workflow-update",
      "apis": [],
      "components": [
        "workflow-engine",
        "sdk-core-integration"
      ],
      "concepts": [
        "workflow-update",
        "versioning",
        "mutable-workflow",
        "backwards-compatibility"
      ],
      "severity": "high",
      "userImpact": "Users of the .NET SDK cannot update or modify running workflows, limiting the platform's capabilities for long-running processes.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implementation is waiting on the completion of temporalio/sdk-core#582, which provides the underlying core functionality for workflow updates.",
      "related": [
        582
      ],
      "keyQuote": "This is waiting on https://github.com/temporalio/sdk-core/issues/582",
      "number": 100,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:57:59.977Z"
    },
    {
      "summary": "Request for implementing worker versioning support in the .NET SDK to enable gradual rollouts and version compatibility management.",
      "category": "feature",
      "subcategory": "worker-versioning",
      "apis": [],
      "components": [
        "worker",
        "versioning"
      ],
      "concepts": [
        "versioning",
        "compatibility",
        "rollout",
        "gradual-deployment",
        "worker-management"
      ],
      "severity": "medium",
      "userImpact": "Users cannot manage different versions of workers simultaneously or perform gradual rollouts in production environments.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Worker versioning support was implemented in the .NET SDK.",
      "related": [],
      "keyQuote": null,
      "number": 99,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:57:47.577Z"
    },
    {
      "summary": "Request to support larger random seeds in the .NET SDK using SeedableRng's seed_from_u64 method. This would be a breaking change to the existing random implementation.",
      "category": "feature",
      "subcategory": "random-seed",
      "apis": [],
      "components": [
        "random-number-generator",
        "test-framework"
      ],
      "concepts": [
        "randomization",
        "seeding",
        "reproducibility",
        "testing"
      ],
      "severity": "low",
      "userImpact": "Users would be able to seed random numbers with larger seed values for more comprehensive testing scenarios.",
      "rootCause": null,
      "proposedFix": "Use SeedableRng's seed_from_u64 method from the rand crate as referenced in the Rust documentation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The feature was implemented, though it required a breaking change to the API.",
      "related": [],
      "keyQuote": "Maybe use https://docs.rs/rand/latest/rand/trait.SeedableRng.html#method.seed_from_u64. Will be  BREAKING CHANGE.",
      "number": 90,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:42:26.767Z"
    },
    {
      "summary": "Add validation to disallow workflow attributes (WorkflowRun, WorkflowSignal, WorkflowQuery) on static methods or classes, preventing incorrect usage patterns in the .NET SDK.",
      "category": "feature",
      "subcategory": "workflow-attributes",
      "apis": [
        "WorkflowRun",
        "WorkflowSignal",
        "WorkflowQuery"
      ],
      "components": [
        "workflow-decorator",
        "attribute-validation",
        "compiler-checks"
      ],
      "concepts": [
        "static-methods",
        "attribute-constraints",
        "validation",
        "design-enforcement",
        "type-safety"
      ],
      "severity": "medium",
      "userImpact": "Users will receive clear validation errors instead of runtime failures when incorrectly applying workflow attributes to static members.",
      "rootCause": null,
      "proposedFix": "Add validation logic in WorkflowSignal and WorkflowQuery attribute implementations to reject static members, consistent with existing WorkflowRun behavior.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Validation was implemented for WorkflowSignal and WorkflowQuery attributes to disallow static usage, matching the existing WorkflowRun behavior.",
      "related": [],
      "keyQuote": "We already disallow this for WorkflowRun, doing it for WorkflowSignal and WorkflowQuery now too",
      "number": 86,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:42:25.221Z"
    },
    {
      "summary": "Re-investigate supporting signals, queries, and updates as properties using expression trees. Initially deferred due to delegate requirements, but modern expression support may enable this pattern.",
      "category": "feature",
      "subcategory": "workflow-definitions",
      "apis": [
        "WorkflowSignal",
        "WorkflowQuery",
        "WorkflowUpdate"
      ],
      "components": [
        "workflow-definition",
        "expression-trees",
        "property-binding"
      ],
      "concepts": [
        "signals",
        "queries",
        "updates",
        "properties",
        "expression-trees",
        "getters",
        "setters"
      ],
      "severity": "low",
      "userImpact": "Users could define workflow signals and queries as properties instead of methods, providing a more natural C# API.",
      "rootCause": ".NET lambda expression trees don't support assignment operators, limiting signal support on properties.",
      "proposedFix": "Support WorkflowQuery on property getters; WorkflowUpdate on properties with setters returning getter values.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Determined that only WorkflowQuery as properties is feasible; signals and updates require assignment expressions which .NET doesn't support.",
      "related": [],
      "keyQuote": "So we can't do signals because .NET lambda expression trees don't support assignment operators. But workflow queries make plenty of sense as properties.",
      "number": 85,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:42:14.281Z"
    },
    {
      "summary": "User reported that when a child workflow is in progress and the application crashes, restarting the application does not resume the workflows as expected. The issue was resolved by properly configuring activity timeouts and implementing heartbeating.",
      "category": "question",
      "subcategory": "workflow-execution",
      "apis": [
        "ExecuteActivity",
        "StartWorkflow"
      ],
      "components": [
        "activity-executor",
        "workflow-runtime",
        "server-communication"
      ],
      "concepts": [
        "timeout",
        "heartbeat",
        "crash-recovery",
        "workflow-resumption",
        "activity-lifecycle"
      ],
      "severity": "medium",
      "userImpact": "Users may experience workflows that fail to resume after application restarts when child workflows are in progress, unless properly configured with timeouts and heartbeats.",
      "rootCause": "Missing activity heartbeating and improper timeout configuration (using ScheduleToCloseTimeout instead of StartToCloseTimeout) caused the server to think activities were still running, preventing workflow resumption.",
      "proposedFix": "Set StartToCloseTimeout to a reasonable value based on expected activity duration and implement regular activity heartbeating to keep the server informed of activity progress.",
      "workaround": "Configure StartToCloseTimeout appropriately and ensure activities implement heartbeating as documented in the SDK.",
      "resolution": "fixed",
      "resolutionDetails": "User resolved the issue by switching from ScheduleToCloseTimeout to StartToCloseTimeout with a 1-second timeout and implementing proper activity heartbeating.",
      "related": [],
      "keyQuote": "you have crashed an activity without the server knowing. For all but the most immediate activities, you should set a HeartbeatTimeout and heartbeat regularly",
      "number": 84,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:42:09.373Z"
    },
    {
      "summary": "Time-skipping test server is not properly advancing simulated time when using long timers and DelayAsync calls in workflows, causing tests to sleep real time instead of skipping to the next event.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "DelayAsync",
        "StartWorkflow"
      ],
      "components": [
        "test-server",
        "time-skipping",
        "workflow-execution"
      ],
      "concepts": [
        "time-skipping",
        "testing",
        "async-delay",
        "timer",
        "workflow-delays"
      ],
      "severity": "high",
      "userImpact": "Developers using the time-skipping test server cannot efficiently test workflows with long timers, as tests hang on real delays instead of advancing simulated time.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "related": [
        63
      ],
      "resolution": null,
      "resolutionDetails": null,
      "keyQuote": "Using time-skipping test server, starting a workflow with a long timer (i.e. no activity) and then running env.DelayAsync is sleeping real time, not skipping time as expected.",
      "number": 77,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:42:10.752Z"
    },
    {
      "summary": "The .NET API documentation site fails to load table of contents (TOC) when accessed at https://dotnet.temporal.io/api without a trailing slash. A Vercel configuration setting is needed to handle trailing slash consistency.",
      "category": "bug",
      "subcategory": "documentation-deployment",
      "apis": [],
      "components": [
        "documentation-site",
        "vercel-configuration",
        "api-docs"
      ],
      "concepts": [
        "trailing-slash",
        "url-routing",
        "documentation-loading",
        "site-configuration",
        "user-experience"
      ],
      "severity": "low",
      "userImpact": "Users accessing the .NET API documentation without a trailing slash encounter a broken table of contents, requiring them to add the trailing slash manually.",
      "rootCause": "Missing Vercel configuration to handle trailing slash normalization",
      "proposedFix": "Add vercel.json configuration with trailingSlash set to true",
      "workaround": "Access the URL with a trailing slash: https://dotnet.temporal.io/api/",
      "resolution": "fixed",
      "resolutionDetails": "Likely resolved by implementing the suggested Vercel configuration change",
      "related": [],
      "keyQuote": "https://dotnet.temporal.io/api does not load TOC like https://dotnet.temporal.io/api/ does",
      "number": 71,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:41:55.029Z"
    },
    {
      "summary": "Feature request to add RPC metadata updater capability to the .NET client, allowing headers to be updated on existing client/connection instances to affect worker operations, similar to other Temporal SDKs.",
      "category": "feature",
      "subcategory": "client-configuration",
      "apis": [],
      "components": [
        "client",
        "connection",
        "worker",
        "RPC"
      ],
      "concepts": [
        "metadata",
        "headers",
        "configuration",
        "connection-management",
        "inter-process-communication"
      ],
      "severity": "medium",
      "userImpact": "Users cannot dynamically update RPC headers on existing clients, limiting runtime configuration flexibility compared to other SDKs.",
      "rootCause": null,
      "proposedFix": "Implement RPC metadata updater functionality similar to other Temporal SDKs to enable header updates on existing client/connection instances.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to match functionality available in other SDKs",
      "related": [],
      "keyQuote": "Like other SDKs, need to be able to update headers on existing client/connection that is then done in Rust to affect worker use.",
      "number": 70,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:41:57.167Z"
    },
    {
      "summary": "User asks how to perform dependency injection with scoped services in the .NET SDK, particularly for Activity instances. The SDK doesn't manage Activity instance creation, requiring manual DI handling in user code.",
      "category": "question",
      "subcategory": "dependency-injection",
      "apis": [
        "TemporalWorker",
        "Activity"
      ],
      "components": [
        "activity-executor",
        "worker",
        "dependency-injection"
      ],
      "concepts": [
        "dependency-injection",
        "scoped-lifetime",
        "service-provider",
        "activity-instantiation",
        "di-integration"
      ],
      "severity": "medium",
      "userImpact": "Users must manually manage dependency injection scopes in Activity implementations, increasing boilerplate code and potential for scope mismanagement.",
      "rootCause": "Activity instances are created and managed by user code rather than the SDK, preventing integration with Microsoft.Extensions.DependencyInjection's scoped lifetime pattern.",
      "proposedFix": "Pass IServiceProvider to TemporalWorkerOptions and let the SDK manage Activity instance creation and disposal using the DI container.",
      "workaround": "Manually inject IServiceProvider into Activity class and create/dispose service scopes within each Activity method.",
      "resolution": "fixed",
      "resolutionDetails": "Dependency injection extension implemented as part of issue #92, with sample provided in samples-dotnet PR #16 demonstrating Activity factory pattern using service provider.",
      "related": [
        62,
        92
      ],
      "keyQuote": "We now have a dependency injection extension as part of #92.",
      "number": 66,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:41:57.515Z"
    },
    {
      "summary": "Update docfx tooling for .NET SDK API documentation to ensure records are properly displayed in the generated API docs.",
      "category": "docs",
      "subcategory": "api-documentation",
      "apis": [],
      "components": [
        "docfx",
        "api-docs"
      ],
      "concepts": [
        "documentation",
        "tooling",
        "records",
        "api-reference"
      ],
      "severity": "low",
      "userImpact": "Users accessing .NET SDK API documentation will see properly formatted documentation for record types.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved in issue #68",
      "related": [
        68
      ],
      "keyQuote": "Update docfx, need to make sure records are properly in API docs",
      "number": 65,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:25:08.682Z"
    },
    {
      "summary": "Workflows that complete immediately with no async operations deadlock with a timeout error. A simple delay resolves the issue, suggesting a problem with how the SDK handles empty or synchronous workflows.",
      "category": "bug",
      "subcategory": "workflow-execution",
      "apis": [
        "WorkflowRun"
      ],
      "components": [
        "workflow-worker",
        "workflow-execution-engine",
        "task-handling"
      ],
      "concepts": [
        "deadlock",
        "timeout",
        "workflow-completion",
        "task-replay",
        "empty-workflow"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot create workflows that complete without async operations, receiving confusing deadlock errors instead of normal completion.",
      "rootCause": "The workflow task replay logic may not properly detect completion when no async operations occur, causing continuous replay until timeout.",
      "proposedFix": null,
      "workaround": "Add a delay operation (e.g., Workflow.DelayAsync) to the workflow, even if no real work is needed.",
      "resolution": "invalid",
      "resolutionDetails": "Reporter could not provide standalone reproduction. Maintainer was unable to replicate the issue with minimal test case and closed due to no response.",
      "related": [],
      "keyQuote": "The [WorkflowRun] method starts and completes, but is replayed continuously until it times out.",
      "number": 64,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:25:11.767Z"
    },
    {
      "summary": "Test server with time skipping throws 'Event set unexpectedly empty' when calling GetResultAsync(), and DelayAsync() waits real time instead of skipping time as expected.",
      "category": "bug",
      "subcategory": "test-framework",
      "apis": [
        "GetResultAsync",
        "DelayAsync",
        "StartWorkflowAsync",
        "ExecuteAsync"
      ],
      "components": [
        "test-server",
        "time-skipping",
        "workflow-handle",
        "worker"
      ],
      "concepts": [
        "time-skipping",
        "unit-testing",
        "workflow-execution",
        "async-delay",
        "test-environment",
        "event-handling"
      ],
      "severity": "high",
      "userImpact": "Developers cannot reliably use the local test server with time skipping to unit test workflows due to exceptions and real-time delays instead of simulated time advancement.",
      "rootCause": "Time skipping not properly implemented in test server's DelayAsync(); event queue handling issue in workflow result retrieval",
      "proposedFix": null,
      "workaround": "Start GetResultAsync earlier (backgrounded) to trigger auto-skipping; manually manage time skipping behavior",
      "resolution": "fixed",
      "resolutionDetails": "Issues #77 and #78 opened to address the event set issue and DelayAsync real-time delay problem",
      "related": [
        77,
        78
      ],
      "keyQuote": "Event set unexpectedly empty on calling GetResultAsync() on the WorkflowHandle. Additionally calls to WorkflowEnvironment.DelayAsync() wait real time",
      "number": 63,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:25:08.769Z"
    },
    {
      "summary": "Feature request to modernize the .NET SDK's activity and workflow reference approach by replacing the current Ref pattern with LINQ expression-based syntax, similar to Hangfire. This includes abstracting activity definitions to support dependency injection and modernizing registration of activities and workflows through type-based registration and expression trees.",
      "category": "feature",
      "subcategory": "activity-definition",
      "apis": [
        "ExecuteActivityAsync",
        "ActivityDefinition",
        "AddActivity",
        "WorkflowReference"
      ],
      "components": [
        "activity-registration",
        "workflow-execution",
        "expression-trees",
        "worker-options",
        "type-inference"
      ],
      "concepts": [
        "linq-expressions",
        "type-safety",
        "dependency-injection",
        "delegate-pattern",
        "api-modernization",
        "performance-optimization"
      ],
      "severity": "medium",
      "userImpact": "Users can benefit from more intuitive expression-based API calls aligned with modern .NET practices, though performance implications and type inference challenges need resolution.",
      "rootCause": "Current Ref pattern doesn't align with common .NET library conventions like Hangfire; expression trees introduce type inference and performance challenges with non-constant expressions.",
      "proposedFix": "Implement expression-based ExecuteActivityAsync with ActivityDefinition abstraction supporting Func<object?, Task<object?[]?>> invoker; modernize registration with AddActivityType<T>(), AddActivity(Delegate), and CreateAllFromType(Type) methods; evaluate and implement expression evaluation strategy (likely pattern matching with fallback to Compile()).",
      "workaround": "Continue using existing Ref pattern; dynamically register activities via ActivityDefinition.CreateWithoutAttribute.",
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented with expression-based approach, replacing the Ref pattern entirely with lambda expressions for both static and instance methods.",
      "related": [],
      "keyQuote": "With the removal of the dependency, familiarity to .NET devs, and that we (really really) hate two ways of doing things, this just won out.",
      "number": 62,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:24:56.253Z"
    },
    {
      "summary": "Activity delegates created via expression trees may have a System.Runtime.CompilerServices.Closure as the first parameter, which should be excluded from parameter detection. The issue proposes using GetType().GetMethod(\"Invoke\") or adding explicit invoke metadata to ActivityDefinition.",
      "category": "feature",
      "subcategory": "activity-invocation",
      "apis": [
        "ActivityDefinition"
      ],
      "components": [
        "activity-executor",
        "delegate-invocation",
        "reflection"
      ],
      "concepts": [
        "closure",
        "expression-trees",
        "parameter-detection",
        "delegate-methods",
        "reflection"
      ],
      "severity": "medium",
      "userImpact": "Users creating activities with expression tree lambdas may experience incorrect parameter handling in the activity framework.",
      "rootCause": "Expression tree lambdas capture a System.Runtime.CompilerServices.Closure object that appears as the first parameter when using GetParameters().",
      "proposedFix": "Either use Delegate.GetType().GetMethod(\"Invoke\") for parameter detection, or add Invoke, ReturnType, and ParameterTypes properties to ActivityDefinition with a CreateWithoutAttribute constructor.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Resolved by issue #67, making this feature request no longer necessary.",
      "related": [
        67
      ],
      "keyQuote": "If you use expression trees to create a lambda, the first param of defn.Delegate.Method.GetParameters() is a System.Runtime.CompilerServices.Closure.",
      "number": 61,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:24:52.133Z"
    },
    {
      "summary": "Implement OpenTelemetry support for distributed tracing in the .NET SDK via an interceptor-based approach. The feature requires careful handling of span context propagation across service boundaries and resolution of activity context restoration challenges in .NET's distributed tracing model.",
      "category": "feature",
      "subcategory": "observability-tracing",
      "apis": [],
      "components": [
        "interceptor",
        "distributed-tracing",
        "activity-context",
        "baggage-propagation"
      ],
      "concepts": [
        "opentelemetry",
        "tracing",
        "distributed-context",
        "span-propagation",
        "activity-context",
        "baggage",
        "observability"
      ],
      "severity": "medium",
      "userImpact": "Users can integrate OpenTelemetry tracing to monitor and visualize Temporal workflow execution across distributed systems.",
      "rootCause": ".NET's distributed tracing model only supports setting current Activity, not restoring arbitrary ActivityContext as current context like other OTel SDKs, requiring activity recreation rather than simple context attachment.",
      "proposedFix": "Create a Temporalio.Extensions.Tracing project (instead of OTel-specific) using interceptor pattern similar to Python SDK; leverage DistributedContextPropagator for span serialization to Temporal headers.",
      "workaround": "For metrics, users can create custom TemporalRuntime with metrics telemetry options pointed to OTel gRPC URL; for tracing, must recreate Activity and copy fields, setting as Activity.Current.",
      "resolution": "fixed",
      "resolutionDetails": "OpenTelemetry tracing support was implemented in the .NET SDK via interceptor-based approach in a separate extensions project.",
      "related": [],
      "keyQuote": "So it will be interceptor powered (like Python's), but I am struggling with how best to split the project up.",
      "number": 56,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:24:52.648Z"
    },
    {
      "summary": "Implement a cloud smoke test in CI that uses organization secrets to verify the .NET SDK works against Temporal Cloud.",
      "category": "feature",
      "subcategory": "ci-testing",
      "apis": [],
      "components": [
        "ci-pipeline",
        "cloud-integration",
        "test-framework"
      ],
      "concepts": [
        "cloud-testing",
        "smoke-test",
        "ci-automation",
        "org-secrets",
        "integration-testing",
        "sdk-verification"
      ],
      "severity": "medium",
      "userImpact": "Enables automated verification that the .NET SDK functions correctly against Temporal Cloud in CI/CD pipelines.",
      "rootCause": null,
      "proposedFix": "Use organization secrets to authenticate and run a simple smoke test against Temporal Cloud during CI.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Cloud smoke test was implemented using org secrets in CI pipeline.",
      "related": [],
      "keyQuote": "Use org secrets and a simple smoke test against cloud in CI",
      "number": 55,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:24:37.958Z"
    },
    {
      "summary": "Feature request to implement a simple benchmarking tool for the .NET SDK that runs nightly to monitor performance across different scenarios, similar to the existing Python SDK benchmarker.",
      "category": "feature",
      "subcategory": "benchmarking",
      "apis": [],
      "components": [
        "benchmarking",
        "testing",
        "performance-monitoring"
      ],
      "concepts": [
        "performance",
        "benchmarking",
        "testing",
        "nightly-jobs",
        "monitoring"
      ],
      "severity": "low",
      "userImpact": "Users lack visibility into .NET SDK performance characteristics across different scenarios and over time.",
      "rootCause": null,
      "proposedFix": "Implement a benchmarking tool similar to the Python SDK's existing benchmarker that can be run nightly.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "Need something like what is in Python that does simple benchmarks to see performance in certain situations",
      "number": 54,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:50.873Z"
    },
    {
      "summary": "Replace the Go kitchen sink workflow used in .NET SDK tests with a native .NET implementation, as the .NET SDK is now feature-complete and no longer needs to rely on Go code.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "testing",
        "kitchen-sink",
        "workflows"
      ],
      "concepts": [
        "test-coverage",
        "feature-parity",
        "native-implementation",
        "sdk-maturity",
        "test-maintenance"
      ],
      "severity": "low",
      "userImpact": "Removes unnecessary Go dependency from .NET SDK tests, simplifying the test suite and improving maintainability.",
      "rootCause": null,
      "proposedFix": "Implement a .NET version of the kitchen sink workflow for testing purposes",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "The kitchen sink workflow in tests was replaced with a .NET implementation as the SDK achieved feature parity with other Temporal SDKs",
      "related": [],
      "keyQuote": "No need for Go code anymore now that .NET is full featured",
      "number": 52,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:49.823Z"
    },
    {
      "summary": "Move the .NET SDK testing infrastructure from Temporalite (deprecated) to the newer Temporal CLI for local testing. Includes unskipping a previously disabled workflow patch test once the CLI supports necessary features.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [
        "ExecuteWorkflowAsync"
      ],
      "components": [
        "test-environment",
        "local-development",
        "cli-integration"
      ],
      "concepts": [
        "testing",
        "development-tools",
        "temporal-cli",
        "temporalite",
        "environment-setup"
      ],
      "severity": "medium",
      "userImpact": "Developers using the .NET SDK need to update their local testing setup from the deprecated Temporalite to the new Temporal CLI.",
      "rootCause": "Temporalite is deprecated; Temporal CLI is the modern replacement but initially lacked required features.",
      "proposedFix": "Migrate testing infrastructure to use Temporal CLI instead of Temporalite, pending required Temporal CLI feature implementation.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Completed by migrating to Temporal CLI once PR #4317 was merged into the CLI.",
      "related": [
        4317
      ],
      "keyQuote": "Temporalite is the old way, CLI is the new. Also, we need to unskip `ExecuteWorkflowAsync_Patched_ProperlyHandled` once we do.",
      "number": 50,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:35.955Z"
    },
    {
      "summary": "User inquires about the timeline for .NET SDK GA release, wanting to use Temporal in production with their C# development team.",
      "category": "question",
      "subcategory": "release-timeline",
      "apis": [],
      "components": [
        "sdk-dotnet",
        "release-management"
      ],
      "concepts": [
        "production-readiness",
        "ga-release",
        "alpha-release",
        "feedback"
      ],
      "severity": "low",
      "userImpact": "Users planning projects need clarity on when the SDK will be production-ready before committing to adoption.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Closed as not an actionable issue. Maintainer directed user to community channels (Slack #dotnet-sdk and forums) for general questions about release timeline.",
      "related": [
        48
      ],
      "keyQuote": "We are making the next alpha release soon (after #48 merged) and need feedback to help us get to GA.",
      "number": 49,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:33.835Z"
    },
    {
      "summary": "Add a dependency injection extension for the .NET SDK to make it easy to create and inject lazy clients, similar to npgsql and grpc-dotnet implementations.",
      "category": "feature",
      "subcategory": "dependency-injection",
      "apis": [],
      "components": [
        "client",
        "dependency-injection",
        "background-service"
      ],
      "concepts": [
        "lazy-loading",
        "dependency-injection",
        "client-factory",
        "extension-pattern"
      ],
      "severity": "medium",
      "userImpact": "Developers need a convenient way to register and inject Temporal clients in .NET applications without manual lazy initialization.",
      "rootCause": null,
      "proposedFix": "Create Temporalio.Extensions.DependencyInjection package modeling approaches from npgsql and grpc-dotnet, including support for BackgroundService.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "A dependency injection extension was implemented following the proposed pattern.",
      "related": [
        44,
        45
      ],
      "keyQuote": "We need to make it easy to create a lazy client and inject it.",
      "number": 46,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:37.171Z"
    },
    {
      "summary": "Worker application hangs when ITemporalClient is injected via dependency injection instead of being instantiated directly. Creating the client outside the DI container appears to cause blocking behavior.",
      "category": "bug",
      "subcategory": "dependency-injection",
      "apis": [
        "TemporalClient.ConnectAsync",
        "TemporalWorker"
      ],
      "components": [
        "client",
        "dependency-injection",
        "worker",
        "hosted-service"
      ],
      "concepts": [
        "initialization",
        "blocking",
        "async",
        "service-container",
        "configuration"
      ],
      "severity": "high",
      "userImpact": "Developers using .NET dependency injection patterns with ITemporalClient cannot use standard DI practices without their worker applications hanging on startup.",
      "rootCause": "External creation of TemporalClient (outside DI container) does not properly integrate with the dependency injection lifecycle, causing synchronous blocking behavior.",
      "proposedFix": null,
      "workaround": "Create the TemporalClient directly within the Worker class instead of injecting it via the DI container.",
      "resolution": "duplicate",
      "resolutionDetails": "Issue was closed as a duplicate of #44, which addresses the broader problem of external client creation not working properly with .NET DI patterns.",
      "related": [
        44
      ],
      "keyQuote": "Creating a client on the outside of a DI container is not working (and it's not best practice).",
      "number": 45,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:21.395Z"
    },
    {
      "summary": "ASP.NET client created at startup hangs when calling StartWorkflowAsync from an endpoint, while creating the client inside the endpoint lambda works fine. The issue was caused by socket/connection polling problems in Tonic that were resolved in upstream dependencies.",
      "category": "bug",
      "subcategory": "client-connection",
      "apis": [
        "TemporalClient.ConnectAsync",
        "StartWorkflowAsync"
      ],
      "components": [
        "client",
        "connection",
        "gRPC",
        "tonic"
      ],
      "concepts": [
        "deadlock",
        "async-context",
        "dependency-injection",
        "socket-polling",
        "thread-safety"
      ],
      "severity": "high",
      "userImpact": "Users cannot reuse a TemporalClient instance created at ASP.NET startup, forcing them to create new connections for each request.",
      "rootCause": "Tonic dependency issue causing Connection:poll to not execute when client created outside request context, preventing gRPC calls from completing. Fixed in Tonic 0.9+ with upstream dependency updates.",
      "proposedFix": "Update sdk-core dependency to include https://github.com/temporalio/sdk-core/pull/584 and set minimum Tonic version to 0.9.",
      "workaround": "Create a new TemporalClient instance inside each endpoint handler lambda instead of reusing a singleton client.",
      "resolution": "fixed",
      "resolutionDetails": "Fixed by updating core to pull #584 and requiring Tonic 0.9+, which resolved upstream socket polling issues.",
      "related": [
        584,
        544
      ],
      "keyQuote": "Something is inadvertently stopping/killing connection poll and I am not sure what.",
      "number": 44,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:21.333Z"
    },
    {
      "summary": "Unable to load the native 'temporal_sdk_bridge' library on Linux Docker environments, while it works fine on Windows. The DLL file is missing or not accessible in the deployment, preventing the SDK from initializing.",
      "category": "bug",
      "subcategory": "native-library-loading",
      "apis": [
        "TemporalRuntime",
        "TemporalClient.ConnectAsync"
      ],
      "components": [
        "bridge-interop",
        "runtime-initialization",
        "nuget-packaging"
      ],
      "concepts": [
        "native-dependencies",
        "docker-deployment",
        "platform-compatibility",
        "dll-loading",
        "linux-runtime",
        "dependency-resolution"
      ],
      "severity": "high",
      "userImpact": "Users cannot deploy .NET Temporal SDK applications to Linux Docker environments or Azure Functions, as the required native library fails to load.",
      "rootCause": "The native temporal_sdk_bridge library is not included in the deployment output alongside the managed assemblies, likely due to build/packaging configuration issues.",
      "proposedFix": "Ensure temporal_sdk_bridge.dll and other native dependencies are included in the bin directory during dotnet build and deployment processes.",
      "workaround": "Manually copy the temporal_sdk_bridge.dll and related native DLLs to the deployment directory alongside managed assemblies.",
      "resolution": "invalid",
      "resolutionDetails": "Marked as invalid - issue was due to incomplete deployment/packaging. The SDK properly includes native dependencies in nuget package, but users must ensure they're present in their deployment.",
      "related": [
        53600
      ],
      "keyQuote": "Unable to load shared library 'temporal_sdk_bridge' or one of its dependencies. In order to help diagnose loading problems, consider setting the LD_DEBUG environment variable",
      "number": 42,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:19.015Z"
    },
    {
      "summary": "DataConverter.Default with PayloadConverterType property assignment fails because the converter is eagerly instantiated before the property can be set. The lazy instantiation pattern should be used instead to allow proper initialization.",
      "category": "bug",
      "subcategory": "data-converter",
      "apis": [
        "DataConverter"
      ],
      "components": [
        "data-converter",
        "payload-converter",
        "failure-converter"
      ],
      "concepts": [
        "lazy-initialization",
        "property-assignment",
        "shallow-clone",
        "type-instantiation",
        "converter-pattern"
      ],
      "severity": "medium",
      "userImpact": "Users cannot customize PayloadConverterType through property assignment on DataConverter.Default clones due to timing issues in initialization.",
      "rootCause": "DataConverter uses a shallow copy constructor and eagerly instantiates payload/failure converters before the PayloadConverterType property can be set.",
      "proposedFix": "Make the payload/failure converter properties Lazy with PublicationOnly visibility to defer instantiation until actually needed.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Implemented lazy initialization pattern for payload and failure converter properties to allow deferred instantiation.",
      "related": [],
      "keyQuote": "Using `DataConverter.Default with { PayloadConverterType = typeof(MyPayloadConverter) }` means internally .NET does a clone then sets the property at which point it's too late",
      "number": 41,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:01.490Z"
    },
    {
      "summary": "User inquires about the .NET SDK development roadmap. The SDK team clarifies that the workflow portion is under active development with an expected release within weeks, and directs users to the proposals repository for detailed information.",
      "category": "question",
      "subcategory": "roadmap-inquiry",
      "apis": [],
      "components": [
        "sdk-dotnet",
        "workflow-runtime"
      ],
      "concepts": [
        "roadmap",
        "release-timeline",
        "feature-planning",
        "sdk-maturity",
        "alpha-status"
      ],
      "severity": "low",
      "userImpact": "Users seeking clarity on .NET SDK development timeline and feature availability receive official guidance on expected releases.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Closed as a question with clarification provided. User directed to proposals repository and community channels for future inquiries.",
      "related": [],
      "keyQuote": "The workflow portion of the SDK is under active development and should be released within the next couple of weeks.",
      "number": 38,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:04.009Z"
    },
    {
      "summary": "NuGet package is built with glibc 2.32 from ubuntu-latest, which is incompatible with older Linux distributions like Debian 11 that only have glibc 2.31. The build process needs to use an older glibc version to ensure broader compatibility.",
      "category": "bug",
      "subcategory": "build-compatibility",
      "apis": [],
      "components": [
        "nuget-package",
        "build-pipeline",
        "docker-image"
      ],
      "concepts": [
        "compatibility",
        "dependency-versioning",
        "linux-distribution",
        "glibc",
        "build-environment"
      ],
      "severity": "high",
      "userImpact": "Users attempting to run the .NET SDK on older Linux distributions (Debian 11, CentOS) encounter runtime failures due to glibc version incompatibility.",
      "rootCause": "GitHub Actions ubuntu-latest uses glibc 2.32, which is newer than the glibc 2.31 available in Debian 11 and other older distributions.",
      "proposedFix": "Downgrade glibc to the oldest compatible version, either by manually specifying glibc during build or using an older Ubuntu version in the build pipeline.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Build pipeline was updated to use a compatible glibc version or older Ubuntu base image to ensure compatibility with Debian 11 and other legacy distributions.",
      "related": [],
      "keyQuote": "We use glibc 2.32 in the GH ubuntu-latest which is too new for older distros (like mcr.microsoft.com/dotnet/aspnet:7.0 which defaults to Debian 11 which is 2.31)",
      "number": 36,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:08:02.987Z"
    },
    {
      "summary": "User unable to run .NET samples as jobs remain in running status indefinitely, unlike the Go helloworld example which completes successfully.",
      "category": "question",
      "subcategory": "samples-setup",
      "apis": [],
      "components": [
        "samples",
        "worker",
        "dotnet-sdk"
      ],
      "concepts": [
        "job-execution",
        "worker-setup",
        "language-interoperability",
        "sample-setup"
      ],
      "severity": "low",
      "userImpact": "Users following the .NET samples documentation encounter hanging jobs that never complete, preventing them from learning the SDK.",
      "rootCause": "User did not follow the README instructions requiring the Go worker to be run alongside the .NET workflow, as .NET workflows were not yet developed.",
      "proposedFix": "Follow the README at samples-dotnet repository which explains the Go worker requirement.",
      "workaround": "Run the Go worker as documented in the samples-dotnet README.",
      "resolution": "invalid",
      "resolutionDetails": "Issue closed as question - user had not followed the setup instructions in the README which explains that .NET samples require running a separate Go worker since .NET workflows were not yet implemented.",
      "related": [],
      "keyQuote": "You have to run the Go worker. The sample is showing how Go and .NET work together since .NET workflows aren't developed yet.",
      "number": 35,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:45.462Z"
    },
    {
      "summary": "User encountered build failures when trying to build the .NET SDK due to missing recursive git clone of sdk-core and missing C++ build tools. After resolving these dependencies, compilation errors in the Rust bridge code appeared, which were resolved by using the correct sdk-core version.",
      "category": "docs",
      "subcategory": "build-setup",
      "apis": [],
      "components": [
        "bridge",
        "build-system",
        "cargo"
      ],
      "concepts": [
        "build-failure",
        "dependency-management",
        "toolchain-configuration",
        "submodule",
        "rust-compilation",
        "windows-setup"
      ],
      "severity": "medium",
      "userImpact": "Developers cannot build and debug the SDK locally without correct setup instructions and dependencies.",
      "rootCause": "Incomplete build instructions - documentation did not explicitly mention the need for recursive git clone of submodules and C++ build tools for MSVC toolchain.",
      "proposedFix": "Update build documentation to explicitly require recursive clone and specify C++ build tools as mandatory dependencies.",
      "workaround": "Manually copy sdk-core source into the Bridge directory; ensure Visual Studio C++ build tools are installed.",
      "resolution": "fixed",
      "resolutionDetails": "User resolved the issue by following correct recursive clone procedure and installing C++ build tools for Visual Studio. Maintainer agreed to update documentation.",
      "related": [],
      "keyQuote": "I will make sure to update the build instructions to say they are required.",
      "number": 33,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:48.123Z"
    },
    {
      "summary": "Feature request to add CancellationToken parameter to TemporalClient.ConnectAsync() and related connection methods, following .NET standard practice for I/O operations. The maintainer indicates this requires Rust integration work that hasn't been completed yet.",
      "category": "feature",
      "subcategory": "connection-cancellation",
      "apis": [
        "TemporalClient.ConnectAsync",
        "TemporalConnection.ConnectAsync"
      ],
      "components": [
        "client",
        "connection",
        "async-runtime"
      ],
      "concepts": [
        "cancellation",
        "cancellation-token",
        "timeout",
        "async-io",
        "connection-management",
        "rust-integration"
      ],
      "severity": "medium",
      "userImpact": "Users cannot abort long-running connection attempts, making it difficult to implement timeout behavior in .NET applications.",
      "rootCause": "CancellationToken support requires integration with Tokio in Rust, which has not yet been implemented for the connect process.",
      "proposedFix": "Add optional CancellationToken parameter to ConnectAsync methods, potentially as part of options object to minimize overload count.",
      "workaround": null,
      "resolution": null,
      "resolutionDetails": null,
      "related": [],
      "keyQuote": "we intentionally did not include a cancellation token on connect because we don't have that wired up with Rust",
      "number": 32,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:43.615Z"
    },
    {
      "summary": "Request to add an API to count workflows in the .NET SDK. This is a feature request referenced from a parent issue with more details.",
      "category": "feature",
      "subcategory": "workflow-management",
      "apis": [
        "CountWorkflows"
      ],
      "components": [
        "client",
        "workflow-service",
        "api"
      ],
      "concepts": [
        "workflow-counting",
        "query-api",
        "workflow-metadata",
        "monitoring"
      ],
      "severity": "medium",
      "userImpact": "Users need a way to query and count workflows for monitoring, debugging, and operational purposes.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "API for counting workflows was implemented in the .NET SDK",
      "related": [],
      "keyQuote": "See parent issue for more information.",
      "number": 30,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:30.796Z"
    },
    {
      "summary": "A transitive dependency vulnerability (CVE-2022-41723) in golang.org/x/net v0.4.0 was reported via Mend, causing excessive CPU consumption in HTTP/2 HPACK decoder. The issue was automatically closed as the vulnerable library was removed from the inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "grpc-middleware",
        "http2"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "cpu-consumption",
        "transitive-dependency",
        "http2",
        "cvss"
      ],
      "severity": "high",
      "userImpact": "Users could experience denial of service attacks through maliciously crafted HTTP/2 streams that consume excessive CPU resources.",
      "rootCause": "Vulnerability in golang.org/x/net v0.4.0 HPACK decoder allowing malicious HTTP/2 streams to cause excessive CPU consumption.",
      "proposedFix": "Upgrade golang.org/x/net to v0.7.0 or later.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend as the vulnerable library was either ignored or no longer part of the dependency inventory.",
      "related": [],
      "keyQuote": "A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service",
      "number": 28,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:29.407Z"
    },
    {
      "summary": "Request to support dynamic workflows, activities, signals, and queries in the .NET SDK as part of a broader Temporal feature initiative. This involves enabling runtime definition and registration of these core components rather than requiring compile-time declaration.",
      "category": "feature",
      "subcategory": "dynamic-registration",
      "apis": [
        "ExecuteActivity",
        "StartWorkflow",
        "SignalWorkflow",
        "QueryWorkflow"
      ],
      "components": [
        "workflow-registry",
        "activity-registry",
        "signal-handler",
        "query-handler"
      ],
      "concepts": [
        "dynamic-registration",
        "runtime-definition",
        "workflow-definition",
        "activity-definition",
        "feature-parity",
        "extensibility",
        "reflection"
      ],
      "severity": "medium",
      "userImpact": "Users cannot register workflows, activities, signals, and queries at runtime, limiting flexibility in dynamic scenarios and creating parity issues with other Temporal SDKs.",
      "rootCause": null,
      "proposedFix": null,
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Feature was implemented to support dynamic workflows, activities, signals, and queries in the .NET SDK.",
      "related": [
        201
      ],
      "keyQuote": "Need to support all of these things dynamically as part of general Temporal feature",
      "number": 27,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:27.640Z"
    },
    {
      "summary": "A transitive dependency vulnerability (WS-2023-0366) in rustix-0.38.8 affecting temporal-sdk-core-api-0.1.0 can cause memory explosion in the Dir iterator on Linux. The issue was automatically closed by Mend when the vulnerable library was removed from the inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "bridge",
        "cargo-dependencies",
        "temporal-sdk-core"
      ],
      "concepts": [
        "vulnerability",
        "memory-exhaustion",
        "denial-of-service",
        "transitive-dependency",
        "rust-bindings",
        "security-patch"
      ],
      "severity": "medium",
      "userImpact": "Users of temporal-sdk-core-api-0.1.0 are exposed to a potential memory exhaustion vulnerability through a transitive dependency that could be exploited locally.",
      "rootCause": "rustix-0.38.8's Dir iterator with the linux_raw backend can cause memory explosion due to unsafe handling of directory iteration.",
      "proposedFix": "Upgrade rustix to version 0.35.15, 0.36.16, 0.37.25, or 0.38.19 which contain the security fix.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "The issue was automatically closed by Mend because the vulnerable library was marked as ignored or removed from the inventory. It was later reopened when the library was detected again, then closed again when it was confirmed to be no longer part of the inventory.",
      "related": [],
      "keyQuote": "rustix's rustix::fs::Dir iterator with the linux_raw backend can cause memory explosion",
      "number": 25,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:14.746Z"
    },
    {
      "summary": "User needs to specify activity names at runtime rather than compile-time via attributes. Requests an overload for TemporalWorkerOptions.AddActivity(string name, Delegate del) to support dynamic activity naming.",
      "category": "feature",
      "subcategory": "activity-definition",
      "apis": [
        "AddActivity"
      ],
      "components": [
        "worker",
        "activity-definition",
        "attributes"
      ],
      "concepts": [
        "runtime-configuration",
        "dynamic-naming",
        "activity-registration",
        "compile-time-constraints"
      ],
      "severity": "medium",
      "userImpact": "Users can now dynamically specify activity names at runtime instead of being limited to compile-time attribute definitions.",
      "rootCause": "ActivityAttribute can only be applied at compile-time, preventing dynamic activity naming for general-purpose libraries.",
      "proposedFix": "Add TemporalWorkerOptions.AddActivity(string name, Delegate del) overload to specify activity names explicitly at runtime.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Released via PR #31 with non-attribute definition of activities support.",
      "related": [
        27,
        29,
        31
      ],
      "keyQuote": "A simple solution would be to add a TemporalWorkerOptions.AddActivity(string name, Delegate del) overload that allows me to specify the activity name explicitly.",
      "number": 24,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:12.702Z"
    },
    {
      "summary": "Implement a Schedules API for the .NET SDK to match functionality available in other Temporal SDKs. This feature request tracks the need to add support for scheduling workflows.",
      "category": "feature",
      "subcategory": "schedules-api",
      "apis": [
        "Schedule"
      ],
      "components": [
        "schedule-manager",
        "client-api",
        "sdk-core"
      ],
      "concepts": [
        "scheduling",
        "recurring-workflows",
        "delayed-execution",
        "workflow-automation",
        "cron-triggers"
      ],
      "severity": "high",
      "userImpact": "Users cannot schedule workflows with the .NET SDK, limiting their ability to implement time-based workflow automation that other SDK users can access.",
      "rootCause": null,
      "proposedFix": "Implement schedules API following the patterns established in other SDKs",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Schedules API has been implemented in the .NET SDK",
      "related": [],
      "keyQuote": "Implement schedules API as has been implemented in other SDKs",
      "number": 23,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:07:15.268Z"
    },
    {
      "summary": "Request to opt out of version check for ephemeral Temporal servers started by the SDK test framework, since these servers lack UI and cannot display upgrade notifications. The issue was closed as a duplicate of #50.",
      "category": "feature",
      "subcategory": "test-framework",
      "apis": [],
      "components": [
        "test-framework",
        "server"
      ],
      "concepts": [
        "version-check",
        "ephemeral-server",
        "cli",
        "testing",
        "temporal-cli"
      ],
      "severity": "low",
      "userImpact": "SDK test framework developers need to suppress unnecessary version checks when running ephemeral Temporal servers for testing purposes.",
      "rootCause": null,
      "proposedFix": "Opt out of version check for servers started by the SDK test framework",
      "workaround": null,
      "resolution": "duplicate",
      "resolutionDetails": "Closed as duplicate of issue #50",
      "related": [
        50,
        485
      ],
      "keyQuote": "Opt out of version check for servers started by the SDK test framework - there's no value for users since we typically start it without the UI",
      "number": 22,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:56.614Z"
    },
    {
      "summary": "Dependency security vulnerabilities in martincostello.logging.xunit.0.3.0 package used in tests: two transitive vulnerabilities in System.Text.RegularExpressions (CVE-2019-0820, CVSS 7.5) and System.Net.Http (CVE-2018-8292, CVSS 5.3).",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "test-framework",
        "dependency-management",
        "nuget-packages"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-update",
        "transitive-dependency",
        "denial-of-service",
        "information-disclosure",
        "cvss-rating"
      ],
      "severity": "high",
      "userImpact": "Test dependencies contain unpatched security vulnerabilities that could potentially be exploited in development and testing environments.",
      "rootCause": "Transitive dependencies (System.Text.RegularExpressions 4.3.0 and System.Net.Http 4.3.0) included via martincostello.logging.xunit 0.3.0 have known CVEs without available fixes in the dependency chain.",
      "proposedFix": "Upgrade System.Text.RegularExpressions to 4.3.1 and System.Net.Http to 4.3.4 or later versions; consider upgrading martincostello.logging.xunit to a version with non-vulnerable transitive dependencies.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue closed, likely resolved by upgrading the affected dependencies or updating the test package versions.",
      "related": [],
      "keyQuote": "CVE-2019-0820: A denial of service vulnerability exists when .NET Framework and .NET Core improperly process RegEx strings",
      "number": 19,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:59.857Z"
    },
    {
      "summary": "A transitive dependency vulnerability (CVE-2018-8292) in System.Net.Http 4.3.0 exposed through microsoft.extensions.logging.abstractions allows information disclosure through authentication exposure in HTTP redirects. The issue was automatically closed as the vulnerable library was removed from the dependency inventory.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "dependency-management",
        "nuget-packages",
        "http-client"
      ],
      "concepts": [
        "security-vulnerability",
        "authentication-disclosure",
        "transitive-dependency",
        "cve-2018-8292",
        "http-redirect",
        "information-disclosure"
      ],
      "severity": "high",
      "userImpact": "Users running applications with the vulnerable System.Net.Http 4.3.0 dependency are at risk of authentication information being exposed during HTTP redirects.",
      "rootCause": "System.Net.Http 4.3.0 contains a vulnerability where authentication information can be inadvertently exposed in HTTP redirects, affecting .NET Core 1.0, 1.1, and 2.1.",
      "proposedFix": "Upgrade System.Net.Http to version 4.3.4 or later",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory.",
      "related": [],
      "keyQuote": "System.Net.Http - 4.3.4 is the fixed version for CVE-2018-8292 (CVSS 7.5) which discloses authentication information in redirects",
      "number": 15,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:56.030Z"
    },
    {
      "summary": "Transitive dependency vulnerability in system.text.regularexpressions 4.3.0 (CVE-2019-0820) causing a denial of service via RegEx string processing. The vulnerable library was a transitive dependency of xunit.console test framework.",
      "category": "bug",
      "subcategory": "dependency-security-vulnerability",
      "apis": [],
      "components": [
        "test-framework",
        "dependencies",
        "xunit-console"
      ],
      "concepts": [
        "denial-of-service",
        "security-vulnerability",
        "transitive-dependency",
        "regex-processing",
        "cvss-7.5"
      ],
      "severity": "high",
      "userImpact": "Users may be vulnerable to denial of service attacks through regular expression processing if using affected versions of the dependency.",
      "rootCause": "system.text.regularexpressions version 4.3.0 on netcore50 has a denial of service vulnerability when improperly processing RegEx strings",
      "proposedFix": "Upgrade system.text.regularexpressions to version 4.3.1 or later",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend when the vulnerable library was no longer part of the inventory or was marked as ignored",
      "related": [],
      "keyQuote": "Mend has determined that CVE-2019-0820 only affects environments with versions 4.3.0 and 4.3.1 only on netcore50 environment",
      "number": 12,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:41.458Z"
    },
    {
      "summary": "Request to incorporate StyleCop analyzers in CI to enforce consistent code style, specifically ensuring class member order follows StyleCop guidelines (SA1201).",
      "category": "feature",
      "subcategory": "code-quality",
      "apis": [],
      "components": [
        "ci",
        "code-style",
        "analyzer"
      ],
      "concepts": [
        "code-consistency",
        "static-analysis",
        "code-quality",
        "linting",
        "member-ordering"
      ],
      "severity": "low",
      "userImpact": "Ensures consistent code style across the SDK codebase and helps contributors follow consistent patterns.",
      "rootCause": null,
      "proposedFix": "Incorporate StyleCop analyzers in CI to enforce class member ordering and other code style rules.",
      "workaround": null,
      "resolution": "fixed",
      "resolutionDetails": "StyleCop analyzers were incorporated into the CI/format process.",
      "related": [],
      "keyQuote": "Want to at least make sure class member order is consistent",
      "number": 10,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:43.020Z"
    },
    {
      "summary": "Dependency security vulnerability in temporal-sdk-core-0.1.0: webpki-0.22.0 has CVE-2018-16875 (CVSS 5.5) allowing CPU denial of service attacks through pathological X.509 certificate chain verification. Issue was automatically closed when the vulnerable library was removed from the dependency inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "bridge",
        "cargo-dependencies",
        "temporal-sdk-core"
      ],
      "concepts": [
        "security-vulnerability",
        "denial-of-service",
        "dependency-management",
        "certificate-verification",
        "transitive-dependency"
      ],
      "severity": "medium",
      "userImpact": "Users of the .NET SDK are potentially exposed to CPU denial of service attacks if a malicious actor can provide pathological X.509 certificates during TLS handshakes.",
      "rootCause": "Transitive dependency on webpki-0.22.0 through reqwest  webpki-roots  webpki chain; webpki lacks bounds on certificate chain verification work, allowing attackers to craft inputs causing excessive CPU usage.",
      "proposedFix": "Upgrade webpki to version 0.22.2 or later, or upgrade rustls-webpki to 0.100.2 or 0.101.4+.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Automatically closed by Mend when the vulnerable library was removed from the dependency inventory; subsequently reopened and closed again as the library was no longer detected in the managed dependencies.",
      "related": [],
      "keyQuote": "The crypto/x509 package of Go before 1.10.6 and 1.11.x before 1.11.3 does not limit the amount of work performed for each chain verification, which might allow attackers to craft pathological inputs leading to a CPU denial of service.",
      "number": 8,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:41.722Z"
    },
    {
      "summary": "Two vulnerabilities detected in tokio 1.23.0 dependency: a high-severity soundness issue in ReadHalf::unsplit that can violate Pin contracts (CVSS 9.8), and a medium-severity Windows named pipe security issue where pipe_mode resets reject_remote_clients to false (CVSS 5.4).",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "tokio-runtime",
        "io-utilities"
      ],
      "concepts": [
        "vulnerability",
        "security",
        "dependency-upgrade",
        "soundness",
        "pin-contract",
        "named-pipes"
      ],
      "severity": "critical",
      "userImpact": "Applications using the .NET SDK with tokio 1.23.0 are exposed to critical security vulnerabilities that could lead to use-after-free exploits and unauthorized remote access to named pipes.",
      "rootCause": "Tokio 1.23.0 contains two unpatched CVEs: WS-2023-0027 (Pin contract violation in ReadHalf::unsplit) and CVE-2023-22466 (pipe_mode resetting reject_remote_clients on Windows).",
      "proposedFix": "Upgrade tokio to version 1.24.2 (fixes both vulnerabilities) or minimum safe versions: 1.18.5, 1.20.4, or 1.23.1.",
      "workaround": "For CVE-2023-22466 on Windows: ensure pipe_mode is set first after initializing ServerOptions before setting reject_remote_clients.",
      "resolution": "fixed",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was either marked as ignored or is no longer part of the Mend inventory, indicating the dependency has been updated or removed.",
      "related": [],
      "keyQuote": "The tokio feature io-util is also required to be enabled to trigger this soundness issue. Remote clients may only access the named pipe if the named pipe's associated path is accessible via a publicly shared folder (SMB).",
      "number": 4,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:28.093Z"
    },
    {
      "summary": "Transitive dependency newtonsoft.json 9.0.1 has a high-severity vulnerability (CVE WS-2022-0161) that could cause DoS through stack overflow exploitation. The issue was auto-closed after the vulnerable library was removed from the dependency inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "dependency-management",
        "test-framework",
        "package-management"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-upgrade",
        "denial-of-service",
        "stack-overflow",
        "transitive-dependency",
        "version-management"
      ],
      "severity": "high",
      "userImpact": "Tests using microsoft.testplatform.testhost could be exploited through a DoS vulnerability in nested JSON processing.",
      "rootCause": "Newtonsoft.Json prior to 13.0.1 improperly handles StackOverflow exceptions during nested expression processing, allowing attackers to cause DoS.",
      "proposedFix": "Upgrade Newtonsoft.Json to 13.0.1 or later and Microsoft.Extensions.ApiDescription.Server to 6.0.0",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Issue was automatically closed by Mend because the vulnerable library was removed from the dependency inventory (no longer part of Mend inventory for this branch).",
      "related": [],
      "keyQuote": "Newtonsoft.Json prior to version 13.0.1 is vulnerable to Insecure Defaults due to improper handling of StackOverFlow exception",
      "number": 3,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:24.240Z"
    },
    {
      "summary": "Security vulnerability in transitive dependency system.net.http.4.3.0 (CVE-2018-8292) exposed through xunit test framework, allowing information disclosure in HTTP redirects. Issue was automatically closed after the vulnerable library was removed from inventory.",
      "category": "bug",
      "subcategory": "dependency-security",
      "apis": [],
      "components": [
        "test-framework",
        "dependency-management",
        "nuget-packages"
      ],
      "concepts": [
        "security-vulnerability",
        "dependency-chain",
        "information-disclosure",
        "http-redirect",
        "authentication",
        "transitive-dependency"
      ],
      "severity": "high",
      "userImpact": "Users' authentication information could be inadvertently exposed in HTTP redirects due to a vulnerable transitive dependency in the test framework.",
      "rootCause": "System.Net.Http 4.3.0 has an information disclosure vulnerability (CVE-2018-8292) that is a transitive dependency of xunit.2.4.1 through netstandard.library.1.6.1.",
      "proposedFix": "Upgrade System.Net.Http to version 4.3.4 or higher.",
      "workaround": null,
      "resolution": "invalid",
      "resolutionDetails": "Automatically closed by Mend as the vulnerable library was either marked as ignored or is no longer part of the Mend inventory in the specific branch.",
      "related": [],
      "keyQuote": "This issue was automatically closed by Mend because the vulnerable library in the specific branch(es) was either marked as ignored or it is no longer part of the Mend inventory.",
      "number": 2,
      "repo": "temporalio-sdk-dotnet",
      "generatedAt": "2026-01-11T07:06:24.946Z"
    }
  ]
}