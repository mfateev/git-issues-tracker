{"assignees":[],"author":{"id":"MDQ6VXNlcjczNjc3NQ==","is_bot":false,"login":"rclmenezes","name":"Rodrigo Menezes"},"body":"### What are you really trying to do?\n\nUse Temporal with NextJS 15 in production\n\n### Describe the bug\n\nTemporal Typescript uses the function name as the workflow type. This causes issues when the code is minified.\n\nWhen using NextJS, the function names get mangled by default. In NextJS <=14, you could set `swcMinify: false` in your next-config to get around this issue:\nhttps://github.com/vercel/next.js/issues/74332#issuecomment-2620236458\n\nHowever, that is not an option in Next 15, which disabled swcMinify as an option. The only option there is to make a custom webpack config to disable optimization altogether.\n\n### Minimal Reproduction\n\nThe official example of nextjs-temporal breaks:\nhttps://github.com/temporalio/nextjs-temporal-one-click-template/issues/3\n\n### Environment/Versions\n\nAll of them\n\n### Additional context\n\nI think Temporal Typescript's SDK should support minification, full stop. Users shouldn't have to make a magic webpack config to make things happen.","closedAt":null,"comments":[{"id":"IC_kwDOEujx186cLmi4","author":{"login":"rclmenezes"},"authorAssociation":"NONE","body":"One hack around I tried: export your workflows separately as an object:\n\n``` typescript\nimport * as workflows from \"./workflows\";\n\nexport { workflows };\n```\n\nAnd then you can import the object instead:\n\n```typescript\n      await temporalClient.workflow.start(workflows.myWorkflow, {\n        args: [],\n        taskQueue: TEMPORAL_TASK_QUEUE,\n        workflowId: `whatever`,\n      });\n```\n\nEDIT: nope this doesn't work either.","createdAt":"2025-01-28T23:50:34Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2620287160","viewerDidAuthor":false},{"id":"IC_kwDOEujx186cW7rC","author":{"login":"rclmenezes"},"authorAssociation":"NONE","body":"Here's a solution that worked -- disabling minification on the server. Here's my next-js config:\n\n```typescript\nexport default {\n  webpack: (config) => {\n    if (config.name === \"server\") {\n      // Disable minification for server builds to avoid temporal build errors\n      config.optimization.minimize = false;\n    }\n    return config;\n  },\n};\n```\n\nIt sucks that we have to do this. Using function names is not great in the long run. Maybe a decorator is a better long-term solution, or turning workflows into classes of some kind.","createdAt":"2025-01-30T00:32:16Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2623257282","viewerDidAuthor":false},{"id":"IC_kwDOEujx186chGOt","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"I totally understand how this kind of things can be frustrating, and I do agree that we need to improve the overall developer experience for Temporal + Next.js users.\n\nMy plan is to eventually provide plugins to ease integration between Temporal TS SDK and other major frameworks. The present issue could very easily be resolved by such a plugin, e.g. by having the plugin apply specific AST transformations during the bundling process.","createdAt":"2025-01-30T23:26:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2625921965","viewerDidAuthor":false},{"id":"IC_kwDOEujx186chNBQ","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"> Using function names is not great in the long run. Maybe a decorator is a better long-term solution, or turning workflows into classes of some kind.\n\nSorry, I strongly disagree on this.\n\nThe difficulties you describe are the result of conflicting DX optimizations made respectively by the Temporal SDK and the Next.js teams, which are both sensible defaults for our respective community.\n\n- On the Next.js side ‚Äî There is technically no strong requirement for bundling, minimizing and optimizing the _backend_ code, but the Next.js community recognized that most developers would appreciate the reduced deployment size, and therefore decided to enable those options by default, leaving the possibility for users _to opt out_ of that feature by using a configuration hook.\n\n- On the Temporal side ‚Äî A Workflow Type is really just a simple string. We however recognized that most of our developers would appreciate the type safety provided by passing the Workflow function object, and therefore chose to promote that approach in most of our samples; users may however opt out of that feature by passing raw strings rather than functions. Similarly, we chose to define Workflow implementations as publicly exported functions on a module because we recognized that most of our users would appreciate the simplicity of that model; users may however opt in to implement alternate mapping logic (e.g. Workflows as classes or methods) by registering a single default Workflow function.\n\nDefault behaviors on both sides are sensible and in the best interest of our respective communities. They only conflict when trying to combine both libraries' defaults in a same project, at which point one needs to do some extra work or to simply opt out to some feature in either libraries.\n\nWould it make sense to say that \"Next.js stripping the name property on functions on backend code is not great in the long run\"? Obviously not. That decision makes sense for most users in the Next.js community.\n\nSimilarly, the patterns we encourage regarding Workflow definition make sense for most users of the Temporal TypeScript SDK. A user may easily implement alternate approaches, including decorator functions and classes. But those alternatives also have drawbacks, and would definitely not be in the interest of most users.","createdAt":"2025-01-30T23:42:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2625949776","viewerDidAuthor":false},{"id":"IC_kwDOEujx186chavI","author":{"login":"rclmenezes"},"authorAssociation":"NONE","body":"Thanks for the in-depth response, James.\n\nFraming it as \"sensible defaults\" on both sides make sense. That said -- I'm surprised that I'm the first to bring this up! I would have thought that most other batteries-included frameworks like Remix minimize backend code by default as well, but if I'm the first to bring this up, then I might be wrong!\n\nProviding a NextJS plugin as a paved path could be a very neat approach. Or at least making the sample repo work in production :)\n\nAs an aside... I never knew that `client.workflow.start` takes a raw string as well as a function! That's a really great escape hatch. I wish I saw that in the docs. It opens the door to a lot of custom solutions as you suggest.\n\nI still think that an _optional_ decorator could be a great approach where we keep existing defaults and provide a nice paved path:\n\n```typescript\nimport {temporalWorkflow} from \"temporalio/workflow\";\n\n@temporalWorkflow(workflowType='myWorkflow')\nfunction myWorkflow() {\n    ...\n}\n```\n\nIn this scenario, `workflow.start` could default back to the function name if some special attribute like `fn.workflowName` isn't present\n\nFor now, if I want minification, I'll probably make a quick and dirty custom wrapper for `client.workflow.start`:\n\n```typescript\nconst workflows: Record<string, WorkflowFn> = {};\n\nasync function startFlow<Name extends keyof typeof workflows>(name: Name, args: Parameters<typeof workflows[Name]>[0], workflowId: string) {\n  const client = await getTemporalClient();\n  return client.workflow.start(name, {\n    args: [args],\n    taskQueue: TEMPORAL_TASK_QUEUE,\n    workflowId,\n  });\n}\n```\n\nThanks again","createdAt":"2025-01-31T00:21:30Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2626005960","viewerDidAuthor":false},{"id":"IC_kwDOEujx186ciTpx","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"> I still think that an optional decorator could be a great approach where we keep existing defaults and provide a nice paved path:\n> \n> ```\n> import {temporalWorkflow} from \"temporalio/workflow\";\n> \n> @temporalWorkflow(workflowType='myWorkflow')\n> function myWorkflow() {\n>     ...\n> }\n> ```\n\nYeah, we would have done that a very long time ago if that was possible, but unfortunately, decorators  (both the ECMAScript Stage 3 proposal _and_ the TypeScript's current spec) only support classes/methods/props‚Ä¶ Not simple functions.","createdAt":"2025-01-31T03:49:29Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2626239089","viewerDidAuthor":false},{"id":"IC_kwDOEujx186ciVUo","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"> For now, if I want minification, I'll probably make a quick and dirty custom wrapper for client.workflow.start:\n> \n> ```\n> const workflows: Record<string, WorkflowFn> = {};\n> \n> async function startFlow<Name extends keyof typeof workflows>(name: Name, args: Parameters<typeof workflows[Name]>[0], workflowId: string) {\n>   const client = await getTemporalClient();\n>   return client.workflow.start(name, {\n>     args: [args],\n>     taskQueue: TEMPORAL_TASK_QUEUE,\n>     workflowId,\n>   });\n> }\n> ```\n> \n\nYeah, that would work.\n\nAnother possibility is to make a proxy object that has the type of your workflow.ts module, but simply return the property name as a string. As a proof of concept, I was able to get the nextjs-ecommerce-oneclick sample running in prod mode by adding this at the top of the `startBuy.js` file:\n\n```\n/**\n * @type {import('../../temporal/lib/workflows.js')}\n */\nconst workflows = new Proxy({}, {\n  get: (target, prop) => {\n    return prop;\n  }\n})\n```","createdAt":"2025-01-31T03:58:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2626245928","viewerDidAuthor":false},{"id":"IC_kwDOEujx186ciY63","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"> I would have thought that most other batteries-included frameworks like Remix minimize backend code by default as well\n\nNowadays, yes, but that's kind of a new thing. Back a few years ago, bundlers were all about frontend stuff. On the server side, you'd always have a `node_modules` directory.\n\nI'd say that IMHO, a major contribution to that trend is that most frameworks are now backed by companies that want to sell you hosting services for your app, so they design the tooling to be very efficient to host, even if that means being less convenient for the developers. And once developers know that they _could_ minimize their backend code, they feel like they are missing something if they don't.\n\nThis has a few drawbacks, notably with libraries that have native dependencies, that load files dynamically at runtime (e.g. plugins, languages files, etc), and those that depends on preserving exact properties names and objects names (including Temporal, of course, but also Protobuf, ORMs, and others). That's why most of those frameworks maintain some internal list of libraries known to be non-minimizable safe (see [Next.js](https://github.com/vercel/next.js/blob/cdb275c7b8d77afc27026584e2b0c15448d9688c/packages/next/src/lib/server-external-packages.json#L4)), but in this particular case, it is _your_ code, and not Temporal's NPM packages, that need special handling, so that list can't help.","createdAt":"2025-01-31T04:16:31Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"EYES","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2626260663","viewerDidAuthor":false},{"id":"IC_kwDOEujx186cqlrT","author":{"login":"rclmenezes"},"authorAssociation":"NONE","body":"> decorators (both the ECMAScript Stage 3 proposal and the TypeScript's current spec) only support classes/methods/props‚Ä¶ Not simple functions.\n\nUgh, I didn't know that. I honestly never use decorators in TS, they're a little too Python-y for me.\n\n> Another possibility is to make a proxy object that has the type of your workflow.ts module, but simply return the property name as a string.\n\nI like it -- thanks!\n\nFor now, I'm probably just going to disable minification and call it a day. I'm hosting on ECS anyway.\n\n> I'd say that IMHO, a major contribution to that trend is that most frameworks are now backed by companies that want to sell you hosting services for your app, so they design the tooling to be very efficient to host, even if that means being less convenient for the developers. \n\nYou're 100% right about this. My favorite example is actually Next.js middleware. It's so custom built for their own edge infrastructure that it's practically useless.\n\nLiterally every other framework I've used in my career has middleware that sees both request and response so you can log or have custom error class handling or identify users in Sentry or whatever. Instead, I have to make a custom wrapApiHandler fo things like this... or move my API to a separate service entirely and deal with the extra infra. What a mess!\n\n\n\nAnyway, thanks again! \n\n","createdAt":"2025-01-31T21:14:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2628410067","viewerDidAuthor":false},{"id":"IC_kwDOEujx186dtYv2","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"@rclmenezes I just got burnt by this, too. Putting this here to help others land on this thread:\n\n```\nTypeError: Failed to initialize workflow of type 'tY': no such function is exported by the workflow bundle\n``` \n\nThis is because NextJS' production build minifies the Temporal SDK code used to start the workflows. This is the first TypeScript project I've set up with Temporal (done a lot of work with the Python SDK), so I'm contending with multiple build challenges to get an app into production. It's particularly challenging as NextJS also uses tsconfig paths. So I went down a rabbit hole thinking it was something wrong with the worker / workflow bundle / webpack config / tsx/ts-node, etc. etc. I feel pretty dumb now as I can see in the Temporal UI the workflow was triggered with type \"tY\", so the issue was coming from upstream üò© \n\nThanks, @mjameswh for all the helpful info in this thread. Personally, I do hope TS moves towards fully ahead-of-time compiled executables like Bun's build tool. I think that would be awesome, but it is interesting to see the angle that hosting services are pushing it. ","createdAt":"2025-02-08T19:56:29Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2645920758","viewerDidAuthor":false},{"id":"IC_kwDOEujx186duX7m","author":{"login":"gregbrowndev"},"authorAssociation":"NONE","body":"To build on the suggested solutions, you can use the string-based argument but still set the type param as appropriate (I've used this approach to call Python-based workflows from TS)\n\n```ts\n  // kick off the purchase async\n  await getTemporalClient().workflow.start<typeof OneClickBuy>(\"OneClickBuy\", {\n    taskQueue: 'ecommerce-oneclick',\n    workflowId: transactionId,\n    args: [itemId],\n  });\n```\n\nThis will give you type-safety on `args` and the handle if you need it for later.\n\nThe name mangling doesn't seem to affect signals/queries, though. ","createdAt":"2025-02-09T11:08:18Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2646179558","viewerDidAuthor":false},{"id":"IC_kwDOEujx186fdHjF","author":{"login":"pilsy"},"authorAssociation":"NONE","body":"I implemented support for using Decorators to define workflows using classes, the way i got around the function name being the entry point is:\n\n```typescript\n/**\n * Temporal Decorator\n *\n * A class decorator that transforms a TypeScript class into a Temporal workflow function.\n * This decorator handles the registration, initialization, and lifecycle management of workflows\n * in the TemporalForge framework.\n *\n * Key Features:\n * - Automatically registers the class as a Temporal workflow\n * - Manages workflow initialization and lifecycle events\n * - Handles workflow naming and task queue assignment\n * - Provides automatic error handling and cancellation support\n * - Supports dynamic class extension for non-Workflow classes\n *\n * The decorator performs the following operations:\n * 1. Ensures the class extends the Workflow base class (creates dynamic extension if needed)\n * 2. Sets up workflow metadata and configuration\n * 3. Binds event handlers, hooks, and signals\n * 4. Manages workflow execution flow and error handling\n *\n * @param options - Configuration options for the workflow\n * @returns A class decorator function that transforms the target class into a Temporal workflow\n */\nexport function Temporal(options?: TemporalOptions) {\n  return function (constructor: any) {\n    const { name: optionalName, taskQueue, tracerName = 'temporal_worker', ...extraOptions } = options || {};\n    const workflowName: string = optionalName ?? constructor.name;\n\n    if (!(constructor.prototype instanceof Workflow)) {\n      abstract class DynamicTemporal extends Workflow {\n        constructor(params: any, options: TemporalOptions = {}) {\n          super(params, options);\n          Object.assign(this, new constructor(params, options));\n        }\n      }\n      constructor = DynamicTemporal;\n    }\n\n    const construct = new Function(\n      'workflow',\n      'constructor',\n      'extraOptions',\n      `\n      return async function ${workflowName}(...args) {\n        extraOptions.workflowType = '${workflowName}';\n        const instance = new constructor(args[0], extraOptions);\n\n        try {\n          await instance.bindEventHandlers();\n          await instance.emitAsync('setup');\n          await instance.emitAsync('hooks');\n          await instance.emitAsync('init');\n\n          const executionMethod = instance.continueAsNew\n            ? 'executeWorkflow'\n            : 'execute';\n\n          return await instance[executionMethod](...args);\n        } catch (e) {\n          if (workflow.isCancellation(e)) {\n            await workflow.CancellationScope.nonCancellable(async () => {\n              await workflow.condition(() => instance.status === 'cancelled');\n            });\n          }\n          throw e;\n        }\n      }\n    `\n    )(workflow, constructor, extraOptions);\n\n    return construct;\n  };\n}\n```\n\nYou can checkout the npm package here - https://github.com/pilsy/chrono-forge/blob/main/README.md\nList of decorators here - https://github.com/pilsy/chrono-forge/tree/main/src/decorators\n\nHere is an example:\n```typescript\nimport {\n  Property,\n  Temporal,\n  StatefulWorkflow,\n  StatefulWorkflowParams,\n  StatefulWorkflowOptions,\n  ManagedPaths,\n  SchemaManager,\n  Signal,\n  Query,\n  Before,\n} from \"temporal-forge\";\n\nimport type { Vendor as VendorModel, Product as ProductModel } from \"../types\";\n\nimport { proxyActivities } from \"@temporalio/workflow\";\nimport type * as activities from \"../activities\";\n\nconst { getVendor } = proxyActivities<typeof activities>({\n  retry: {\n    initialInterval: 1000 * 60,\n    maximumAttempts: 30,\n  },\n});\n\n@Temporal({\n  schemaName: \"Vendor\",\n  schemas: SchemaManager.schemas,\n})\nexport class VendorWorkflow extends StatefulWorkflow<\n  StatefulWorkflowParams<VendorModel>,\n  StatefulWorkflowOptions\n> {\n  protected managedPaths: ManagedPaths = {\n    products: {\n      autoStart: true,\n      entityName: \"Product\",\n      workflowType: \"ProductWorkflow\",\n    },\n  };\n\n  // implement so that data may be loaded using an activity\n  protected async loadData() {\n    return {\n      data: await getVendor(this.id),\n    };\n  }\n\n  @Property({ path: \"name\" })\n  protected name!: string;\n\n  // this decorator sets up query and signal, and automatically maps via proxy to this.data.products\n  @Property({ path: \"products\" })\n  protected products!: ProductModel[];\n\n  // provides a signal named \"mySignal\"\n  @Signal()\n  async mySignal() {\n    console.log(`[Vendor]-(${this.id}):mySignal()...`);\n  }\n\n  // provides a query named \"customQuery\"\n  @Query(\"customQuery\")\n  async myQuery() {\n    console.log(`[Vendor]-(${this.id}):myQuery()...`);\n  }\n\n  // Uses the @Hook decorator to run code before the execute method\n  @Before(\"execute\")\n  async beforeExecute() {\n    console.log(`[Vendor]-(${this.id}):beforeExecute()...`);\n  }\n\n  protected async execute() {\n    console.log(`[Vendor]-(${this.id}):execute()-> running...`);\n  }\n}\n```","createdAt":"2025-02-21T18:01:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}},{"content":"ROCKET","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2675210437","viewerDidAuthor":false},{"id":"IC_kwDOEujx186uIMpv","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"@pilsy If you haven't done so yet, I would strongly encourage you to share your project on [Temporal's Code Exchange](https://temporal.io/code-exchange). I know that many Temporal TS developers are looking for this kind of class+decorator experience.","createdAt":"2025-05-30T06:42:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-2921384559","viewerDidAuthor":false},{"id":"IC_kwDOEujx187KNPAT","author":{"login":"bgw"},"authorAssociation":"NONE","body":"üëã Reporting in from the Turbopack team here.\n\nFirst off, sorry that this is causing pain for folks. The last thing we want are breakages when updating Next.js or migrating from webpack. With [Turbopack becoming default in Next 16](https://nextjs.org/blog/next-16-beta#turbopack-stable), we want to make sure there‚Äôs a good solution for users of Temporal and Next.js.\n\nI don‚Äôt think that disabling mangling or minification is a good idea. Bundling and compressing server-side code is part of how Next.js and ‚Äúserverless‚Äù platforms like Vercel, Cloudflare, and Netlify reduce cold-start times.\n\nIt seems like the culprit is relying on the `name` property for functions here: [https://github.com/temporalio/sdk-typescript/blob/9a67b062c9a985475ccf0b7c443bd5feaebd046a/packages/common/src/workflow-options.ts#L262-L273](https://github.com/temporalio/sdk-typescript/blob/9a67b062c9a985475ccf0b7c443bd5feaebd046a/packages/common/src/workflow-options.ts#L262-L273)\n\n## Function Names are *never* Guaranteed\n\nA function‚Äôs `name` property is defined in the spec as:\n\n> a String that is descriptive of the function. The name **has no semantic significance** but is **typically** a variable or property name that is used to refer to the function at its point of definition in ECMAScript source text.\n> \n\n‚Äî [https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-function-instances-name](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-function-instances-name)\n\nWhile the function name is typically the one used in the source text, the specification doesn‚Äôt actually make any guarantees about function names.\n\nBecause the vast majority of applications don‚Äôt (and shouldn‚Äôt!) care about function names, and because function names tend to be quite long, minifiers (like SWC, OXC, and Terser) often take advantage of this to perform name ‚Äúmangling‚Äù:\n\n> Be careful when using the name property with source-code transformations, such as those carried out by JavaScript compressors (minifiers) or obfuscators. These tools are often used as part of a JavaScript build pipeline to reduce the size of a program prior to deploying it to production. Such transformations often change a function's name at build time.\n> \n\n‚Äî [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#javascript_compressors_and_minifiers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#javascript_compressors_and_minifiers)\n\nRuntimes that perform ahead-of-time compilation, like Hermes, may also choose to strip function names for similar reasons.\n\nIn addition to minification, bundler scope hoisting implementations may also choose to rename functions to avoid conflicts in the hoisted module.\n\nWhether or not a specific function name is mangled depends on the minifier chosen and how a number of internal transformations interact. Just because a function name isn‚Äôt mangled with one version of Webpack or Vite doesn‚Äôt mean it won‚Äôt be mangled with the next version.\n\nWhether or not the name actually gets mangled by a specific bundler, you cannot depend on function names for correctness. Mangled function names can change between builds due to the shape of the module graph and internal heuristics.\n\n**The only valid use case of function names is for debugging**, typically against a development build.\n\n## Related: How Does React Handle This?\n\nReact has a similar problem, as it uses the function‚Äôs name in the React dev tools, but sometimes those functions are anonymous or dynamically-generated (e.g. in the case of higher order components).\n\nFor this purpose, their dev tools will first look for a `.displayName` property:\n\n- [https://legacy.reactjs.org/docs/react-component.html#displayname](https://legacy.reactjs.org/docs/react-component.html#displayname)\n- [https://legacy.reactjs.org/docs/higher-order-components.html#convention-wrap-the-display-name-for-easy-debugging](https://legacy.reactjs.org/docs/higher-order-components.html#convention-wrap-the-display-name-for-easy-debugging)\n- [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName)\n\nThis is not a standard, but a convention that React has adopted. In some cases, this property can be added with a Babel transform: [https://babeljs.io/docs/babel-plugin-transform-react-display-name](https://babeljs.io/docs/babel-plugin-transform-react-display-name)\n\n## Recommendations\n\nIt looks like Temporal uses function names [for workflow ‚Äútypes‚Äù](https://docs.temporal.io/workflows#intro-to-workflows), and needs these names to be stable?\n\nIf that‚Äôs the case, the best thing to do would be the change the API to require an explicit `workflowType` property to be set on functions. I understand that would make the experience of writing new Temporal workflows worse, but it‚Äôs the most reliable solution.\n\nAnother option is to make sure the functions are always properties on exported objects. You can rely on the fact that object keys are never mangled ([except in the case of Closure Compiler](https://developers.google.com/closure/compiler/docs/limitations#implications-of-global-variable,-function,-and-property-renaming:)):\n\n```jsx\n// workflows.ts\nexport const workflows = {\n  async createExpenseReport() {},\n  async approveExpenseReport() {},\n};\n\n// Registration\nfor (const [workflowType, fn] of Object.entries(workflows)) {\n  registerWorkflow({ workflowType, fn }); // never rely on fn.name\n}\n```\n\nIf no other solution seems viable, you could take a page from React‚Äôs `displayName` playbook and [apply a transform to the source code before it‚Äôs bundled and minified](https://babeljs.io/docs/babel-plugin-transform-react-display-name), but this comes with a performance penalty, and would be harder for the Temporal team to maintain:\n\n- [SWC supports plugins](https://nextjs.org/docs/architecture/nextjs-compiler#swc-plugins-experimental). This is the most performant solution, but the plugin API is not stable and [requires matching the version of the plugin with the version of SWC used](https://plugins.swc.rs/). If you do this, [you should get the plugin upstreamed into the official repository, so that it gets rebuilt against each new SWC version](https://github.com/swc-project/plugins).\n- Next 16 Beta supports Babel plugins in Turbopack, but they come with a significant performance penalty, so that should be a last resort. Next 15 does not support Babel plugins with Turbopack. [https://nextjs.org/docs/beta/app/api-reference/turbopack#language-features](https://nextjs.org/docs/beta/app/api-reference/turbopack#language-features)\n- Turbopack supports most Webpack loaders. If only a small set of files need to be transformed and can be identified using a file name glob (e.g. `workflows.ts`), this might be a reasonably performant solution, even if it uses Babel under the hood. [https://nextjs.org/docs/beta/app/api-reference/config/next-config-js/turbopack#configuring-webpack-loaders](https://nextjs.org/docs/beta/app/api-reference/config/next-config-js/turbopack#configuring-webpack-loaders)","createdAt":"2025-10-10T22:14:52Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":10}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1615#issuecomment-3392466963","viewerDidAuthor":false}],"createdAt":"2025-01-28T23:19:25Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDA2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1615,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":3}}],"state":"OPEN","title":"[Bug] Cannot use Temporal with NextJS 15 because workflowTypes come from function names","updatedAt":"2025-10-11T05:50:34Z","url":"https://github.com/temporalio/sdk-typescript/issues/1615"}
