{"assignees":[{"id":"MDQ6VXNlcjY0MTIxNjk=","login":"mjameswh","name":"James Watkins-Harvey","databaseId":0}],"author":{"id":"MDQ6VXNlcjY0MTIxNjk=","is_bot":false,"login":"mjameswh","name":"James Watkins-Harvey"},"body":"### Describe the bug\r\n\r\nWhen the `reuseV8Context` option is enabled, we freeze global objects to prevent modifications from leaking from one Workflow execution context to another one.\r\n\r\nHowever, we do not prevent reassignment of global variables. And since context switching is based solely on global variable names, the engine will leave those reassigned global variable untouched.\r\n\r\nFor example, the following test fails:\r\n\r\n```\r\nexport async function sharedGlobalReassignment(): Promise<[string, string]> {\r\n  type ConsoleExtended = Console & { wfid: string };\r\n  globalThis.console = { ...console, wfid: workflowInfo().workflowId } as ConsoleExtended;\r\n  await sleep(1);\r\n  return [workflowInfo().workflowId, (console as ConsoleExtended).wfid];\r\n}\r\n\r\ntest('Shared global state', withReusableContext, async (t) => {\r\n  const { createWorker, taskQueue, env } = t.context;\r\n  const worker = await createWorker();\r\n  await worker.runUntil(async () => {\r\n    const [res1, res2] = await Promise.all([\r\n      env.client.workflow.execute(sharedGlobalReassignment, { taskQueue, workflowId: randomUUID() }),\r\n      env.client.workflow.execute(sharedGlobalReassignment, { taskQueue, workflowId: randomUUID() }),\r\n    ]);\r\n    t.deepEqual(res1[0], res1[1]);\r\n    t.deepEqual(res2[0], res2[1]);\r\n  });\r\n});\r\n```\r\n\r\nDeleting a global variable also fails, as the variable \"reappears\" on the next context switch. For example, the following test fails:\r\n\r\n```\r\nexport async function globalMutatorAndDestructor(): Promise<number> {\r\n  const global = globalThis as { a?: number };\r\n  global.a = (global.a || 0) + 1;\r\n  await sleep(1);\r\n  delete global.a;\r\n  await sleep(1);\r\n  global.a = (global.a || 0) + 1;\r\n  return global.a;\r\n}\r\n\r\ntest('Set then Delete a global property', withReusableContext, async (t) => {\r\n  const { createWorker, taskQueue, env } = t.context;\r\n  const worker = await createWorker();\r\n  await worker.runUntil(async () => {\r\n    const res = await env.client.workflow.execute(globalMutatorAndDestructor, { taskQueue, workflowId: randomUUID() });\r\n    t.is(res, 1);\r\n  });\r\n});\r\n```\r\n","closedAt":"2025-01-24T00:39:36Z","comments":[],"createdAt":"2024-07-24T19:39:06Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDA2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1476,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Reusable VM allows context leak due to global variable reassignment","updatedAt":"2025-01-24T00:39:36Z","url":"https://github.com/temporalio/sdk-typescript/issues/1476"}
