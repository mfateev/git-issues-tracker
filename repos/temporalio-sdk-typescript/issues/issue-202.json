{"assignees":[{"id":"MDQ6VXNlcjUyMzA0","login":"bergundy","name":"Roey Berman","databaseId":0}],"author":{"id":"MDQ6VXNlcjUyMzA0","is_bot":false,"login":"bergundy","name":"Roey Berman"},"body":"Currently there are some TODOs in the codebase for executing signals first and handling activation errors.\r\nWe also wait for microtasks to run between each job, make sure that's really required.","closedAt":"2021-09-14T12:27:05Z","comments":[{"id":"IC_kwDOEujx1842Pp_O","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Activations consist of multiple jobs.\r\nMost jobs can run concurrently with the exception of signals, patches, and queries.\r\n\r\nSuggestion for how node will process activations:\r\n\r\n* process all patches (nothing async here)\r\n* process all signals concurrently\r\n* wait for microtasks to complete\r\n* process remaining jobs except for queries concurrently\r\n* wait for microtasks to complete\r\n* process queries\r\n\r\nDoes that make sense @Sushisource @mfateev?","createdAt":"2021-09-01T08:46:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/202#issuecomment-910073806","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842gOXn","author":{"login":"mfateev"},"authorAssociation":"MEMBER","body":"Looks good to me. There was a request to process signals one by one for the given type. It would be nice to make it default: https://github.com/temporalio/sdk-java/issues/214","createdAt":"2021-09-07T15:41:36Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/202#issuecomment-914417127","viewerDidAuthor":true},{"id":"IC_kwDOEujx1842muRD","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"@mfateev I'm not sure the Java issue is relevant to us.\r\nIn node the entire Workflow runs in a single thread (concurrently) if users want to process signals sequentially they can use a channel or equivalent to buffer the signals from the signal handlers.\r\nDoes that make sense to you?\r\n\r\nExample:\r\n```ts\r\nexport function myWorkflow() {\r\n  const channel = new UnboundedChannel();\r\n  \r\n  return {\r\n    async execute() {\r\n      for await (const signal of channel) {\r\n        // handle signal\r\n      }\r\n    },\r\n    signals: {\r\n      userInput(input: any) {\r\n        channel.send(input);\r\n      }\r\n    }\r\n  };\r\n}\r\n```","createdAt":"2021-09-09T13:55:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/202#issuecomment-916120643","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842nccz","author":{"login":"mfateev"},"authorAssociation":"MEMBER","body":"I think the node alternative would be not delivering a new signal until the `userInput` function returns.","createdAt":"2021-09-09T17:48:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/202#issuecomment-916309811","viewerDidAuthor":true},{"id":"IC_kwDOEujx1842ndBr","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Why though?\r\nThis is pretty easy to manage in user code.","createdAt":"2021-09-09T17:51:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/202#issuecomment-916312171","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842oWm0","author":{"login":"lorensr"},"authorAssociation":"CONTRIBUTOR","body":"It sounds like there are 2 options:\r\n\r\nA. Signals are delivered as they're received\r\nB. Signals are delivered sequentially—after the previous function call has returned\r\n\r\nThe Java SDK will default to B, and maybe have A as an option. \r\n\r\nFor Node, we currently only support A. We could support B or document how to ensure sequential execution, like with the code snippet above.\r\n\r\n## Support B\r\n\r\nA con is complicating the API. Eg saying \"after the arguments that you provide to your signal function, you can pass an additional options arg for Temporal to read\":\r\n\r\n```\r\nworkflow.signal.userInput('foo arg');\r\nworkflow.signal.userInput('foo arg', { deliverSequentially: true }); // or false, depending on what the default is\r\n```\r\n\r\nA pro is the user doesn't have to code it.\r\n\r\nAnother con is complicating our advice on how to write workflows. Currently, you can do whatever you want in a signal handler, but with B support, we'd say eg \"if you have deliverSequentially on, then don't do long-running logic or sleeping in your signal handlers, because you wouldn't be able to receive signals\". Versus if we don't support B, it's clear from looking at the code when a `sleep()` would be blocking further signal processing. Further pros of not supporting B are flexibility in how sequential is coded and clarity when looking at the signal definition (versus in the Support B case, we don't know just from looking at the handler code whether it's being called with deliverSequentially on or off—we'd have to search through the code of external systems to know).\r\n\r\nI think I prefer not supporting B. As a Node dev, I'm used to the thought that my current function (eg an HTTP request handler) is going to be called non-sequentially, and program accordingly. It makes sense to me that a Signal, as a message from an outside system, would arrive and result in my handler being executed in the same fashion.","createdAt":"2021-09-10T00:54:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/202#issuecomment-916548020","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842sR9t","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I agree with @lorensr here.\r\nCurrently we don't implement channels, but if we did, we could add syntactic sugar for the sample above:\r\n\r\n```ts\r\nexport function myWorkflow() {\r\n  const signals = { userInput: new UnboundedChannel() };\r\n  \r\n  return {\r\n    async execute() {\r\n      for await (const signal of signals.userInput) {\r\n        // handle signal\r\n      }\r\n    },\r\n    signals,\r\n  };\r\n}\r\n```","createdAt":"2021-09-12T07:44:56Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/202#issuecomment-917577581","viewerDidAuthor":false}],"createdAt":"2021-08-24T12:53:40Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":{"number":2,"title":"beta","description":"","dueOn":null},"number":202,"reactionGroups":[],"state":"CLOSED","title":"[Feature Request] Go over WF activation logic","updatedAt":"2021-09-14T12:27:05Z","url":"https://github.com/temporalio/sdk-typescript/issues/202"}
