{"assignees":[{"id":"MDQ6VXNlcjUyMzA0","login":"bergundy","name":"Roey Berman","databaseId":0}],"author":{"id":"MDQ6VXNlcjY0MTIxNjk=","is_bot":false,"login":"mjameswh","name":"James Watkins-Harvey"},"body":"### What are you really trying to do?\r\n\r\nIn many of our workflows, we need to wait for a single occurrence of a given signal before execution before we continue with following steps, similar to the `workflow.GetSignalChannel(ctx, signalName).Receive(ctx, &args)` pattern in Go.\r\n\r\nThe TypeScript SDK does not yet offer an exact replacement for this idiom. It is obviously possible to register a signal handler, which sets a boolean value, and then `await condition(...that boolean variable...)`. However, this pattern results in consuming _all_ occurrences of the signal, where we would expect it to consume _only the first_ occurence of the signal.\r\n\r\nFor this reason, we constructed the function shown below. It has the particularity that, after receiving the expected signal, it clears up the signal handler, by calling `setHandler(signal, undefined)`. This is done from _inside_ the signal handler in order to ensure that only one \"occurence\" of the signal is consumed by the handler. It works great, except for the problem described in this ticket.\r\n\r\nHere is the code:\r\n\r\n```\r\nexport async function waitForSignal<T extends SignalDefinition>(\r\n    signal: T,\r\n    timeout?: number | string,\r\n): Promise<ExtractSignalArgs<T> | false> {\r\n    let signalReceived = false;\r\n    let returnArgs: ExtractSignalArgs<T> | false = false;\r\n\r\n    setHandler(signal, ((...inputArgs: ExtractSignalArgs<T>): void => {\r\n        signalReceived = true;\r\n        returnArgs = inputArgs;\r\n        clearHandler(signal); // This one is required to ensure that we consume only one occurence of the signal\r\n    }) as Handler<void, ExtractSignalArgs<T>, T>);\r\n\r\n    await condition(() => signalReceived, timeout as number);\r\n    clearHandler(signal); // This one is required in case we timed out\r\n\r\n    return returnArgs;\r\n}\r\n\r\nexport function clearHandler<T extends SignalDefinition>(signal: T) {\r\n    setHandler(signal as SignalDefinition<[]>, undefined as unknown as Handler<void, [], T>);\r\n}\r\n```\r\n\r\n\r\n### Describe the bug\r\n\r\nCalling `setHandler(signal, undefined)` while there are buffered signals occurrences for that name results in heap out of memory.\r\n\r\nThe problem \r\n\r\n### Minimal Reproduction\r\n\r\n```\r\nworkflow() {\r\n    await sleep('30s');  // During this pause, send this workflow the given signal a few times\r\n    setHandler(signal, () => {\r\n        setHandler(signal, undefined);\r\n    })\r\n}\r\n```\r\n\r\nThis results in a Node crash with the following message: `FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory`.\r\n\r\n### Analysis\r\n\r\nOur analysis demonstrated that the problem is due to a subtile interaction between `setHandler` and `signalWorkflow`. After changing the handler, `setHandler` iterates over buffered signals and try to process each one. To do so, it calls `signalWorkflow`, which checks if a handler for that signal is actually defined. Now, since our handler is undefined, `signalWorkflow` instead push the signal occurence to the corresponding signal buffer. Turns out that this is the very same array over which `setHandler` is iterating at that very same time.\r\n\r\n```\r\n// in workflow.ts\r\nexport function setHandler<Ret, Args extends any[], T extends SignalDefinition<Args> | QueryDefinition<Ret, Args>>(\r\n  def: T,\r\n  handler: Handler<Ret, Args, T>\r\n): void {\r\n  if (def.type === 'signal') {\r\n    state.signalHandlers.set(def.name, handler as any);\r\n    const bufferedSignals = state.bufferedSignals.get(def.name);\r\n    if (bufferedSignals !== undefined) {\r\n      for (const signal of bufferedSignals) {\r\n        state.activator.signalWorkflow(signal);\r\n      }\r\n      state.bufferedSignals.delete(def.name);\r\n    }\r\n\r\n// in internals.ts\r\n  public signalWorkflow(activation: coresdk.workflow_activation.ISignalWorkflow): void {\r\n    ...\r\n\r\n    const fn = state.signalHandlers.get(signalName);\r\n    if (fn === undefined) {\r\n      let buffer = state.bufferedSignals.get(signalName);\r\n      if (buffer === undefined) {\r\n        buffer = [];\r\n        state.bufferedSignals.set(signalName, buffer);\r\n      }\r\n      buffer.push(activation);  // <-- PUSH\r\n      return;\r\n    }\r\n\r\n    ...\r\n  }\r\n```\r\n\r\n### Proposed solutions\r\n\r\nI propose moving the `state.bufferedSignals.delete(def.name)` line before the `for` loop. As an optimization, it would also be useful not to process buffered signals if the new handler is `undefined`.\r\n\r\n```\r\n    if (bufferedSignals !== undefined && handler !== undefined) {\r\n      state.bufferedSignals.delete(def.name);\r\n      for (const signal of bufferedSignals) {\r\n        state.activator.signalWorkflow(signal);\r\n      }\r\n    }\r\n```","closedAt":"2022-04-26T19:57:39Z","comments":[{"id":"IC_kwDOEujx185CG66T","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Interesting, thanks for the report.\r\nDo you want to fix this or should I? The proposed fix should work.","createdAt":"2022-04-25T22:40:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/612#issuecomment-1109110419","viewerDidAuthor":false},{"id":"IC_kwDOEujx185CHBYq","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"@bergundy Sure, I can submit a PR for this tomorrow.\r\n\r\nIf you don't mind, I would also modify the `setHandler` function signature to make it clears that the `handler` can be set to `undefined`. We are certainly not the only ones thats sees use cases for this.\r\n\r\n> bergundy added this to the 1.0 milestone\r\n\r\nSo we're moving toward 1.0? Great to hear! Congrats to the team! ðŸŽ‰ ðŸŽ‰ ðŸŽ‰ ","createdAt":"2022-04-25T23:28:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/612#issuecomment-1109136938","viewerDidAuthor":false},{"id":"IC_kwDOEujx185CHB0i","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Thanks again @mjameswh!\r\n\r\nFeel free to update the signature for `setHandler` too.","createdAt":"2022-04-25T23:31:43Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/612#issuecomment-1109138722","viewerDidAuthor":false}],"createdAt":"2022-04-25T22:35:20Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDA2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":{"number":6,"title":"1.0","description":"","dueOn":null},"number":612,"reactionGroups":[],"state":"CLOSED","title":"[Bug] Heap out of memory on `setHandler(signal, undefined)`","updatedAt":"2022-04-26T19:57:39Z","url":"https://github.com/temporalio/sdk-typescript/issues/612"}
