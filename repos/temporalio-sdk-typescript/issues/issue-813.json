{"assignees":[],"author":{"id":"MDQ6VXNlcjU4NzQzMzA=","is_bot":false,"login":"izakfilmalter","name":"Izak Filmalter"},"body":"I've been using temporal in production for about 3 months now. We have 11 workers, so still small, but moving more of our system over to it. In many ways I love it, it really is like React for the Backend. I'm primarily a FE dev, but now that I run my own startup, I have evolved to be full stack. \r\n\r\nThe main thing that puts me off from moving more of my stack over to Temporal is the boiler plate. Right now it feels like React Classes, I want React Functions.\r\n\r\nBelow is my current flow to get to the point of being able to write a worker:\r\n\r\n1. Make file for worker:\r\n\t  ```ts\r\n\t  type activities = {\r\n\t    deleteUser: typeOf deleteUserActivity\r\n\t  }\r\n\t  \r\n\t  const {\r\n\t    deleteUser\r\n\t  } = proxyActivities<activities>({\r\n\t    startToCloseTimeout: '30s', // recommended\r\n\t    scheduleToCloseTimeout: '5m', // useful\r\n\t    // The below is a Retry Policy. It is used to retry the Activity if it fails.\r\n\t    retry: {\r\n\t      // These are the values of the Default Retry Policy\r\n\t      initialInterval: '1s',\r\n\t      backoffCoefficient: 2,\r\n\t      nonRetryableErrorTypes: [],\r\n\t    },\r\n\t  })\r\n\t  \r\n\t  export async function deleteUser(params: DeleteUserRequest): Promise<void> {\r\n\t    await deleteUser(params)\r\n\t  }\r\n\t  ```\r\n\r\n1. Make new activity\r\n\t  ```ts\r\n\t  export const deleteUser = async (params: {\r\n\t    userId: string\r\n\t    orgId: string\r\n\t  }) => {\r\n\t    await Promise.all([\r\n\t      deleteFromDB(`users/${userId}`),\r\n\t      removeUserFromOrganization(params),\r\n\t    ])\r\n\t  }\r\n\t  ```\r\n\r\n1. Update `worker.ts`\r\n\t  ```ts\r\n\t  const deleteUserActivities = {\r\n\t    deleteUser\r\n\t  }\r\n\t  \r\n\t  async function run() {\r\n\t    const workers = await Promise.all([\r\n\t      // deleteUser\r\n\t      Worker.create({\r\n\t        ...workflowOption('workflows/users/deleteUser.workflow.ts'),\r\n\t        namespace: env.NAMESPACE,\r\n\t        connection,\r\n\t        interceptors: {\r\n\t          activityInbound: [\r\n\t            (ctx) => new ActivityInboundLogInterceptor(ctx, activityLogger),\r\n\t          ],\r\n\t          workflowModules: [require.resolve('workflows/workflowsInterceptor')],\r\n\t        },\r\n\t        activities: deleteUserActivities,\r\n\t        taskQueue: TaskQueue.DeleteUser,\r\n\t        sinks,\r\n\t        maxCachedWorkflows: 4,\r\n\t        maxConcurrentWorkflowTaskExecutions: 4,\r\n\t      }),\r\n\t    ])\r\n\t  }\r\n\t  ```\r\n\r\nThis is a lot to start making a single workflow. If you mess anything up along the way, everything breaks. It feels like Temporal needs JSX. What I mean by that is some kind of preprocessor that will spit all this out for you.\r\n\r\nIn a perfect world:\r\n1. Workflow definition and options should be colocated.\r\n\t1. Workflow options can be overridden when they are called.\r\n1. Activities should just work with default settings. \r\n    1. Activities should be anything that is a promise or anything that leads to a promise. I have lots of code that prepares a promise, eg `() => async () => unknown`.\r\n1. Type checking of input and output with `zod` should be standard, and enforced. Use the good work that tRPC is doing in making typesafe api's.\r\n1. Autoworkflow wrapper. I have a bunch of non temporal node code that I wish I didn't have to rewrite from the ground up. Having something that could wrap it as one giant activity, a la `dangerouslySetInnerHtml`. You know the risk going it, but it can jump start your switch to Temporal.\r\n\r\nPseudo Example:\r\n```ts\r\nexport const deleteUser = Worker\r\n  .create<\r\n    'deleteUser',\r\n    DeleteUserRequest,\r\n    DeleteUserResponse,\r\n  >('deleteUser',\r\n  {\r\n    /* workflow options */\r\n    input: DeleteUserRequest,\r\n    output: DeleteUserResponse,\r\n    async resolve(request) {\r\n      const { userId, orgId } = request\r\n      \r\n      await deleteUser({ userId, orgId })\r\n    }\r\n  })\r\n```","closedAt":null,"comments":[{"id":"IC_kwDOEujx185IVDQd","author":{"login":"lorensr"},"authorAssociation":"CONTRIBUTOR","body":"Thanks for the feedback and ideas!\r\n\r\n1 & 2. I think Temporal is planning for Workflows & Activities to be able to define their own default options. It'll be system-wide, and will work across SDKs.\r\n\r\n2i. Here's where we call Activity functions:\r\n\r\n![image](https://user-images.githubusercontent.com/251288/184434944-2d7be609-7790-4c38-92a7-41216cd15c0a.png)\r\n\r\nSo you're suggesting that if `await this.fn()` is a Promise, await again? What's your use case? Does it fit this sample:\r\n\r\nhttps://github.com/temporalio/samples-typescript/blob/main/activities-dependency-injection/src/worker.ts\r\n\r\n3. It looks like you're already using compile-time type checking calling Activities. You're looking for runtime checking as well? The default Payload Converter has to be backward compatible and match all other SDKs, but a couple options are using protobufs or creating your own zod-based Payload Converter. \r\n\r\nSome simplification ideas:\r\n\r\n- Have a single Worker that has all your workflows and activities. Then adding a workflow and activity is just adding two files in the right directories.\r\n- Your Activity functions can call your existing non-temporal node code\r\n- In future, we plan to allow calling Activities directly from the Client\r\n","createdAt":"2022-08-12T20:12:51Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/813#issuecomment-1213477917","viewerDidAuthor":false},{"id":"IC_kwDOEujx185IVNON","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I want to add a way to colocate workflow implementations with activities, currently it's possible if you're willing to sacrifice runtime failures when referencing unresolved dependencies.\r\nWe actually use this feature in the sdk-features repo: https://github.com/temporalio/sdk-features/blob/main/features/activity/retry_on_error/feature.ts.\r\nI agree that some of the boilerplate can be removed but I still believe the SDK should be left as flexible as possible at its core.\r\nFor example `zod` is your personal preference, lots of devs would disagree with the decision to enforce this.\r\nFor registering activities and workflows, if you set up your project correctly, all it would take is adding exports in the right files (or public methods on activity classes).\r\n\r\nHaving an ability to invoke any function as an activity was possible in the original version of the SDK, we ended up changing the way it worked because it the approach was too rigid.\r\nI do want to consider a way to provide default activity options (not sure where they'd be specified) so you don't have to pass the options to each proxy call (or even be able to get rid of proxies altogether) but we'd have to think about this some more to find the right way to do it.","createdAt":"2022-08-12T21:04:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/813#issuecomment-1213518733","viewerDidAuthor":false}],"createdAt":"2022-08-12T19:43:34Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":813,"reactionGroups":[],"state":"OPEN","title":"[Feature Request] Less boiler plate.","updatedAt":"2022-08-18T21:29:07Z","url":"https://github.com/temporalio/sdk-typescript/issues/813"}
