{"assignees":[],"author":{"id":"MDQ6VXNlcjI1MTI4OA==","is_bot":false,"login":"lorensr","name":"Loren ☺️"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\n\r\nMocking an SDK function is difficult. If you use a system [like Sinon](https://sinonjs.org/how-to/stub-dependency/) that depends on default exports, it doesn't work, since we don't do default exports. Even if you use a system like Jest that allows you to mock the whole package, there are two issues:\r\n\r\n- Unless your code only uses a single function, you have to mock or add back in the other functions. This, for instance, creates a package that only exports `proxyActivities`:\r\n\r\n```ts\r\nconst mockRequest = jest.fn<Promise<string>, []>();\r\nmockRequest.mockResolvedValue('3');\r\n\r\ntest('httpWorkflow with mocked proxyActivities', async () => {\r\n  jest.mock('@temporalio/workflow', () => ({\r\n    proxyActivities: mockRequest,\r\n  }));\r\n\r\n  expect(await httpWorkflow()).toBe('The answer is 3');\r\n});\r\n```\r\n\r\n- When you mock, you have to recreate the environment. For instance, if you run the above, you get:\r\n\r\n```\r\n FAIL  src/workflows.test.ts (9.489 s)\r\n  ● httpWorkflow with mocked proxyActivities\r\n\r\n    TypeError: exports.storage.getStore is not a function\r\n\r\n      14 |\r\n      15 | export async function httpWorkflow(): Promise<string> {\r\n    > 16 |   const answer = await makeHTTPRequest();\r\n         |                        ^\r\n      17 |   return `The answer is ${answer}`;\r\n      18 | }\r\n      19 |\r\n\r\n      at Function.current (node_modules/@temporalio/workflow/src/cancellation-scope.ts:156:20)\r\n      at node_modules/@temporalio/workflow/src/workflow.ts:151:37\r\n      at scheduleActivityNextHandler (node_modules/@temporalio/workflow/src/workflow.ts:150:10)\r\n      at scheduleActivity (node_modules/@temporalio/workflow/src/workflow.ts:259:10)\r\n      at node_modules/@temporalio/workflow/src/workflow.ts:493:18\r\n      at httpWorkflow (src/workflows.ts:16:24)\r\n      at Object.<anonymous> (src/workflows.test.ts:67:28)\r\n```\r\n\r\n### Solution\r\n\r\nThe current solution in the case of `proxyActivities` is to run a Worker with a test connection and mock activities ([like this](https://github.com/temporalio/samples-typescript/blob/622f40bada8438972d62c9e7f6f500fe6695dd33/activities-examples/src/workflows.test.ts#L47)), and to start a workflow using the test client. If you want to test a helper function used by workflows, then tell the Worker the helper is a workflow and start it, like this:\r\n\r\n```ts\r\n// workflow-helpers.ts\r\nexport function myHelper() { ... }\r\n```\r\n\r\n```ts\r\n// workflow-helpers.test.ts\r\n  const worker = await Worker.create({\r\n    workflowsPath: require.resolve('./workflow-helpers'),\r\n    ...\r\n  });\r\n  await withWorker(worker, async () => {\r\n    const result = await workflowClient.execute(myHelper, {\r\n      workflowId: uuid4(),\r\n      taskQueue: 'test',\r\n    });\r\n    expect(result).toEqual('The answer is 99');\r\n  });  \r\n```\r\n\r\n### Feedback\r\n\r\nIf the current solution described above doesn't work for your case, or isn't ideal for you, let us know in this thread! ☺️","closedAt":null,"comments":[{"id":"IC_kwDOEujx185DvfCR","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"You can mock the workflow functions but you need to it from the vm context otherwise it’ll have no effect. I agree it’s hard to set up but probably possible with sinon (haven’t tried though). Not sure how much value there is to mocking parts of the workflow instead of using the test environment  ","createdAt":"2022-05-24T23:14:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/665#issuecomment-1136521361","viewerDidAuthor":false},{"id":"IC_kwDOEujx185G4N4V","author":{"login":"rcarton"},"authorAssociation":"NONE","body":"After a lot of trial and error, the least obtrusive method I've found is to use rewire and sinon:\r\n\r\n```ts\r\n// In workflow, must use `let` instead of const\r\nlet { getCustomerActivity } =\r\n  proxyActivities<typeof activities>({\r\n    startToCloseTimeout: \"1 minute\",\r\n  });\r\n```\r\n\r\n```ts\r\n// Test utils\r\ntype Activities = typeof activities;\r\ntype StubbedActivity<T extends keyof Activities> = sinon.SinonStub<\r\n  Parameters<Activities[T]>,\r\n  ReturnType<Activities[T]>\r\n>;\r\n\r\n// Taken from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/rewire/index.d.ts\r\ninterface RewiredModule {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  __set__(obj: { [variable: string]: any }): () => void;\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  __set__(name: string, value: any): () => void;\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  __get__<T = any>(name: string): T;\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  __with__(obj: { [variable: string]: any }): (callback: () => any) => any;\r\n}\r\n\r\n/**\r\n * Stub an activity\r\n *\r\n * @param sandbox a sandbox that you will be restore()'d after the test\r\n * @param module a rewired module\r\n * @param activity the name of the activity you want to stub\r\n */\r\nexport function getProxyActivityStub<T extends keyof Activities>(\r\n  sandbox: sinon.SinonSandbox,\r\n  module: RewiredModule,\r\n  activity: T\r\n): StubbedActivity<T> {\r\n  const stub = sandbox.stub();\r\n  module.__set__(activity, stub);\r\n  return stub as StubbedActivity<T>;\r\n}\r\n```\r\n\r\n```ts\r\n// In test file\r\nconst Workflow = rewire(\r\n  \"@temporal-worker/workflows/workflow\"\r\n);\r\n\r\nconst sandbox = sinon.createSandbox();\r\n\r\nconst getCustomerActivityStub = getProxyActivityStub(\r\n  sandbox,\r\n  Workflow,\r\n  \"getCustomerActivity\"\r\n);\r\n```\r\n\r\n\r\n","createdAt":"2022-07-19T14:41:50Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/665#issuecomment-1189142037","viewerDidAuthor":false},{"id":"IC_kwDOEujx185G5kHo","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Glad you got it working, we'll be working on improving this experience in the future","createdAt":"2022-07-19T19:58:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/665#issuecomment-1189495272","viewerDidAuthor":false},{"id":"IC_kwDOEujx185gmQXk","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"For the record and public visibility, here is a working proof of concept I developed a few months ago for mocking child workflows. The great things with this approach are 1) multiple tests can be performed using the same workflow.ts file (other methods require one workflow.ts per test case), 2) it ends up calling a callback function in the unit test context, so its easy to make test assertions there. This is probably not the way we'll end up implementing this in SDK, but can be useful to users that want this now. See below for limitations.\r\n\r\nIt works in three steps: first, an interceptor is used to catch `startChildWorkflow` calls from the Workflow under test, and replaces the workflow type of the child workflow to be started by a predefined \"mock workflow\" type. Second, the implementation of that \"mock workflow\" type calls an activity named \"mockWorkflowActivity\", passing it inputs received from the Workflow under test. Finally, activity type \"mockWorkflowActivity\" is registered directly on the test Worker.\r\n\r\nAre are implementation instructions:\r\n\r\n1. In workflow.ts (the one used by unit test), add this workflow:\r\n```\r\nexport async function mockChildWorkflow(...args: unknown[]): Promise<string> {\r\n  return await scheduleActivity('mockWorkflowActivity', args, { scheduleToCloseTimeout: '5s' });\r\n}\r\n```\r\n\r\n2. Next to test files, create a file named mock-child-workflow-interceptor.ts, containing the following code:\r\n```\r\nimport { WorkflowInterceptorsFactory } from '@temporalio/workflow';\r\n\r\nexport const interceptors: WorkflowInterceptorsFactory = () => {\r\n  return {\r\n    outbound: [\r\n      {\r\n        startChildWorkflowExecution(input, next) {\r\n          return next({\r\n            ...input,\r\n            options: {\r\n              ...input.options,\r\n              args: [input.workflowType, ...input.options.args],\r\n            },\r\n            workflowType: 'mockChildWorkflow',\r\n          });\r\n        },\r\n      },\r\n    ],\r\n  };\r\n};\r\n```\r\n\r\n3. In unit test where we want to mock child workflows, define a function named `mockWorkflowActivity` and register it as an activity on the worker; also register the previously created interceptor. Assuming mocha, that could for example give:\r\n```\r\n  it('Mock child workflows', async () => {\r\n    const { client, nativeConnection } = testEnv;\r\n\r\n    function mockWorkflowActivity(workflowType: string, ...args: unknown[]): unknown {\r\n      return 'test';\r\n    }\r\n\r\n    const worker = await Worker.create({\r\n      connection: nativeConnection,\r\n      taskQueue: 'test',\r\n      workflowsPath: require.resolve('./workflows'),\r\n      activities: { ...activities, mockWorkflowActivity },\r\n      interceptors: { workflowModules: [require.resolve('./mock-child-workflow-interceptor')] },\r\n    });\r\n\r\n    await worker.runUntil(async () => {\r\n      const result = await client.workflow.execute(parentWorkflow, {\r\n        workflowId: uuid4(),\r\n        taskQueue: 'test',\r\n        args: ['alice', 'bob', 'charlie'],\r\n      });\r\n      assert.equal(result, 'test\\ntest\\ntest');\r\n    });\r\n  }).timeout(20000);\r\n```\r\n\r\nNote some caveats with this implementation:\r\n- Exceptions — Throwing from the mock workflow activity won’t result in the same thrown exception at the workflow level.\r\n- Timing — The mock workflow activity will have to return pretty quickly, where as the actual child workflow may have stayed alive for some time.\r\n- Signals — This implementation won’t work if you need the parent and child workflows to exchange signals.\r\n- All or nothing — The current implementation intercepts all child workflow executions. It can’t be selective on which invocations are to be catch. It would not be hard however to fix.","createdAt":"2023-07-04T19:22:56Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":5}},{"content":"HOORAY","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/665#issuecomment-1620641252","viewerDidAuthor":false},{"id":"IC_kwDOEujx185grQrx","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I like where you're going with this @mjameswh.\r\n\r\nA few places where this can be expanded:\r\n- Integration of this solution and make it easier to use and more configurable\r\n- Integrations with mock frameworks as config packages\r\n- Give control over which workflow types get mocked\r\n- Make this not an activity so it (possibly, need to verify) doesn't affect time skipping (would need to introduce a new concept (`*`))\r\n- Try an approach where mocks run in workflow context\r\n- Add signal support\r\n- Add exception translation support\r\n\r\n`*` We were talking about a local activity that doesn't produce a marker that can be used in query handlers and update validators, this could be helpful here too.","createdAt":"2023-07-05T15:06:49Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/665#issuecomment-1621953265","viewerDidAuthor":false},{"id":"IC_kwDOEujx186C5saY","author":{"login":"gaurav1999"},"authorAssociation":"NONE","body":"Here's an example if anyone's looking to test parent workflows executing child workflows.\r\n\r\nYour workflow code -> src/workflows/order.workflow.ts [Parent]\r\n\r\nOrder workflow code executes a bunch of activities, and one child workflow called `sendNotificationWorkflow`.\r\n\r\nIn order to test order.workflow.ts and use mock child workflow `sendNotificationWorkflow` while testing.\r\n\r\nCreate a separate file src/workflow/tests/test-order.workflow.ts\r\n\r\n```\r\nexport * from '../order.workflow.ts'; //Exporting the original order workflow since we want to test it's original code as it is\r\n\r\n//Mock child workflow\r\nexport async function sendNotificationWorkflow(\r\n    email: string,\r\n   \r\n  ): Promise<boolean> {\r\n    return true;\r\n}\r\n```\r\n\r\nAnd now, put this file in your worker worfklowsPath option so that it loads the code of your original workflow, and mock code of your child workflow\r\n\r\n```\r\n\r\nconst worker = await Worker.create({\r\n      connection: nativeConnection,\r\n      taskQueue,\r\n      workflowsPath: require.resolve('./test-order.workflow.ts'),\r\n      activities,\r\n      debugMode: true\r\n });\r\n```\r\n\r\nThis works well for me!\r\n\r\nI think, the idea is, that it's easier to give a mocked context to worker, rather rewiring the SDK components. ","createdAt":"2024-06-28T05:19:10Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/665#issuecomment-2196162200","viewerDidAuthor":false},{"id":"IC_kwDOEujx186YdK9w","author":{"login":"chadxz"},"authorAssociation":"CONTRIBUTOR","body":"I was able to hack something together that worked for me based on @mjameswh's suggestion, but it definitely does not feel like a supported first-class experience. It would be great if I could pass mock workflows directly to Worker.create() similar to how the activities are provided.\r\n\r\nIn my scenario, I was using `startChild` in my workflow, which is async. I was having trouble with my tests being flaky, because worker.runUntil was returning before the mocked activity was called, so my assertion was failing. I put in a `for await` loop to wait for the remaining workflows to complete before allowing the worker to shutdown. Perhaps there's a better way to do that, though...\r\n\r\nsomething like this:\r\n```ts\r\nawait worker.runUntil(async () => {\r\n  await client.workflow.execute(myWorkflowToBeTested, {\r\n    workflowId: randomUUID(),\r\n    taskQueue: \"MyQueue\",\r\n    args: [\"foo\"],\r\n  });\r\n\r\n  for await (const { workflowId, runId } of client.workflow.list()) {\r\n    await client.workflow.getHandle(workflowId, runId).result();\r\n  }\r\n});\r\n```","createdAt":"2024-12-20T22:12:43Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/665#issuecomment-2557783920","viewerDidAuthor":false}],"createdAt":"2022-05-24T22:57:17Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":665,"reactionGroups":[],"state":"OPEN","title":"[Feature Request] Allow for easy mocking ","updatedAt":"2024-12-20T22:12:44Z","url":"https://github.com/temporalio/sdk-typescript/issues/665"}
