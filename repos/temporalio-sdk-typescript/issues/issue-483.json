{"assignees":[],"author":{"id":"MDQ6VXNlcjI5Njc5Ng==","is_bot":false,"login":"StevenLangbroek","name":"Steven Langbroek"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\nIt's more of a question: Temporal's Typescript SDK seems like it would maybe be a good fit as a NestJS Module, is this something there'd be interest in exploring? I'd need to spend a little bit of time on it but I'd love to validate whether it would work with a PoC, and see what kind of API we'd end up with.\r\n\r\n### Describe the solution you'd like\r\n\r\nI'd just like to understand whether there's interest at this point, so I can invest some of my own time in exploring this.\r\n\r\n### Additional context\r\n\r\nI would imagine an API to look something like (based on the [Java Example](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/bookingsaga/TripBookingWorkflowImpl.java)):\r\n\r\n```ts\r\n@Workflow()\r\nexport class TripBookingWorkflow implements Workflow {\r\n  @InjectActivities({\r\n    startToCloseTimeout: ms(\"1hr\"),\r\n    retryOptions: {\r\n      maxAttempts: 1,\r\n    },\r\n  })\r\n  activities: TripBookingActivities;\r\n\r\n  public async execute(name: string): Promise<void> {\r\n    const saga = new Saga({\r\n      parallelCompensation: true,\r\n    });\r\n\r\n    try {\r\n      const carReservationId = this.activities.reserveCar(name);\r\n      saga.addCompensation(this.activities.cancelCar, carReservationId);\r\n\r\n      const hotelReservationId = this.activities.bookHotel(name);\r\n      saga.addCompensation(this.activities.cancelHotel, hotelReservationId);\r\n\r\n      const flightReservationId = this.activities.bookFlight(name);\r\n      saga.addCompensation(this.activities.cancelFlight, flightReservationId);\r\n    } catch (err) {\r\n      saga.compensate();\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Supporting arbitrary frameworks\r\n\r\nBy testing whether the module loaded from `workflowsPath` exports a function as its default export, we can run ~& potentially await that function,~ (should be fine without this, given that it's an async function we can just return the promise) and then return it. This would put a contract on the return value though (`Record<WorkflowName, WorkflowFn>`), we should document that.\r\n\r\n```ts\r\n      api.setImportFuncs({\r\n        importWorkflows: async () => {\r\n          let workflows = await import(/* webpackMode: \"eager\" */ ${JSON.stringify(this.workflowsPath)});\r\n          if (typeof workflows.default === 'function') {\r\n              workflows = workflows.default();\r\n          }\r\n          return workflows;\r\n        },\r\n      });\r\n```\r\n\r\n**update**: ‚òùÔ∏è this works ü•≥ \r\n\r\n<img width=\"1144\" alt=\"image\" src=\"https://user-images.githubusercontent.com/296796/159109882-d8f48b26-1dfe-4057-b37f-694a0eeb9219.png\">\r\n\r\nexporting an async function works too:\r\n\r\n![image](https://user-images.githubusercontent.com/296796/159109966-198b4cbf-e571-4bc2-bb5e-b4bb3d900095.png)\r\n\r\n## To do\r\n\r\n- [x] Discuss desired API\r\n- [x] If `worfklowsPath` exports a function as its `default`, await & return the result of that function.\r\n- [ ] Develop proof of concept\r\n- [ ] Test out third-party Nest plugins that depends on custom file formats\r\n- [ ] ??? \r\n- [ ] Profit\r\n\r\n## Design\r\n\r\n### Principles\r\n\r\n1. NestJS supports both monolithical applications, as well as smaller \"microservices\" (I don't mean the alternative transport layers Nest supports, I just mean smaller more focussed, independently deployable applications), and we should not make assumptions about this\r\n2. Registering _Workflows & Workers_ through Nest's module system will, in the majority of cases, lead to undesirable outcomes; i.e., unintentionally doing things that have side effects or non-determinism and will break in subtle and hard to find ways.\r\n3. The APIs we design should feel familiar to NestJS developers, without incorrectly implying compatibility. We should warn users when they make mistakes, and document tradeoffs front and centre.\r\n\r\n### Operations\r\n\r\nIf you follow NestJS's design recommendations, your codebase should be split, roughly speaking, among domain lines by way of NestJS's module system. However, a single NestJS module might correlate to many Workers. [WIP]","closedAt":null,"comments":[{"id":"IC_kwDOEujx184-JmuO","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"I think this could be good for Temporal because of what NestJS brings to the table;\r\n\r\n- Application lifecycle hooks instead of homegrown solutions\r\n- Ecosystem & Dependency Injection into Activities\r\n- Separation of concerns\r\n- Testability","createdAt":"2022-02-17T08:46:18Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1042705294","viewerDidAuthor":false},{"id":"IC_kwDOEujx184-LoV_","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I think such an integration could be valuable.\r\n\r\nI don't know if we'll want this as part of the SDK repo. It should probably start out as an external package.\r\n\r\nI'd be happy to review what you come up with.\r\n","createdAt":"2022-02-17T17:47:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1043236223","viewerDidAuthor":false},{"id":"IC_kwDOEujx184-Pkef","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"@bergundy totally fair! would you be willing to help me iterate on the API a few rounds before starting a proof-of-concept?","createdAt":"2022-02-18T10:09:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1044268959","viewerDidAuthor":false},{"id":"IC_kwDOEujx184-fFLK","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Hi,\r\nSorry for the late reply, sure, feel free to ping me when you have something.","createdAt":"2022-02-23T00:18:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1048335050","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_iTSo","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"@bergundy so, I've looked at this and I don't think we can achieve this fully in userland; however, this is based on my limited understanding of the `worker` and `core-bridge` packages. I've worked with NestJS enough to understand that side of the equation, but would someone maybe be available to help me understand `core-bridge` and how it interacts with the bundle that you're producing with webpack from `worker`?\r\n\r\n(I'm in the community Slack btw)","createdAt":"2022-03-12T20:22:29Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1065956520","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_kIPV","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"To the best of my understanding we'd have to do something like this [here](https://github.com/temporalio/sdk-typescript/blob/b52999382ea72bc0bac45ed37cfaa9daf4bc6336/packages/worker/src/workflow/bundler.ts#L93-L95):\r\n\r\n```ts\r\nclass NestWorkflowCodeBundler implements WorkflowCodeBundler {\r\n  protected genEntryPoint(/* ... */) {\r\n    return dedent`\r\n      // ...\r\n      api.setImportFuncs({\r\n        importWorkflows: async () => {\r\n          const { bootstrap } = await import(/* webpackMode: \"eager\" */ ${JSON.stringify(this.workflowsPath)});\r\n          const app = await bootstrap();\r\n          return app.get(WorkflowRegistry).getWorkflows();\r\n        }\r\n      });\r\n    `\r\n  }\r\n}\r\n```\r\n\r\nDoes that make sense @bergundy?","createdAt":"2022-03-14T06:46:53Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1066435541","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_ma42","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"This makes sense.\r\nWe need to figure out how to make workflow bundling more extensible.\r\nIf you can get this to work, we'll make sure to add support in the SDK.","createdAt":"2022-03-14T16:32:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1067036214","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_nJFv","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"@bergundy what's the ideal api here here from your perspective? Should the workflowPath option be supplemented with an (optional) initializer function, that receives the resolved module from `workflowPath` and needs to return `Record<WorkflowName, WorkflowImplementation>`? It feels more Javascript native than implementing a Strategy pattern or some such... ","createdAt":"2022-03-14T19:54:57Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1067225455","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_rN0j","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"@bergundy what's the ideal api here here from your perspective? Should the workflowPath option be supplemented with an (optional) initializer function, that receives the resolved value from `importFuncs` and needs to return `Record<WorkflowName, WorkflowImplementation>`? It feels more Javascript native than implementing a Strategy pattern or some such...\n\nOr maybe we need to revisit the entry point template approach? ","createdAt":"2022-03-15T18:03:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1068293411","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_rWLw","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"The Worker (and bundler) accepts `workflowsPath` because workflows run in a [vm](https://nodejs.org/api/vm.html) instead of in the same JS environment as the worker and activities.\r\nWe've used \"exporting\" as the way to register workflows because it's something every dev is familiar with and it automatically handles deduping of workflow names, it's also very convenient for when you want to reference a workflow function for type inference with a client.\r\nWe could allow customizing this the way you're suggesting, not sure about the details, I'm sure it'll become clearer as this feature is fleshed out.","createdAt":"2022-03-15T18:33:32Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1068327664","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_2ku_","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"_Disclaimer: I don't know anything about `nestjs`; just sharing some insights_\r\n\r\nIf you think that this should work:\r\n\r\n```\r\n      api.setImportFuncs({\r\n        importWorkflows: async () => {\r\n          const { bootstrap } = await import(/* webpackMode: \"eager\" */ ${JSON.stringify(this.workflowsPath)});\r\n          const app = await bootstrap();\r\n          return app.get(WorkflowRegistry).getWorkflows();\r\n        }\r\n      });\r\n```\r\n\r\n... then wouldn't this work too:\r\n\r\n```\r\n      api.setImportFuncs({\r\n        importWorkflows: async () => {\r\n          let workflows = await import(/* webpackMode: \"eager\" */ ${JSON.stringify(this.workflowsPath)});\r\n          if (typeof workflows.default === 'function') {\r\n              workflows = await workflows.default();\r\n          }\r\n          return workflows;\r\n        },\r\n      });\r\n```\r\n\r\n... assuming that `workflowsPath` points to a file containing something similar to this:\r\n\r\n```\r\n    export default async function getMyWorkflows() {\r\n        return await bootstrap().get(WorkflowRegistry).getWorkflows();\r\n    }\r\n```\r\n\r\nThe main point here is that the bundler's template may not need to contain any nestjs-specific logic.","createdAt":"2022-03-17T19:36:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1071270847","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_485g","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"That's a great suggestion @mjameswh.\r\nI'd definitely accept a default function export.","createdAt":"2022-03-18T00:20:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1071894112","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_5niK","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"Yep that's much cleaner than [my idea](https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1067225455), good idea @mjameswh! So let me stop wasting time on upfront API design work on the Nest side then, this is a small first step that's good to start with. I'll open a Draft PR this weekend. Thanks!","createdAt":"2022-03-18T06:22:20Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072068746","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_7Eg7","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"> So let me stop wasting time on upfront API design work on the Nest side then, this is a small first step that's good to start with. I'll open a Draft PR this weekend.\r\n\r\n@StevenLangbroek Glad it helps. Once this is in place, it will be much easier for you and others to propose/iterate/test potential designs for nestjs' integration.\r\n\r\nOne thing of which I'm uncertain though is either nestjs' DI will actually work inside the vm context. As you know, your original workflow code (including all of its dependencies) is bundled using webpack... that bundle is _plain JavaScript_, and is all that is available inside the vm context.\r\n\r\nHopefully, it might be sufficient to enable `emitDecoratorMetadata` in your project's `tsconfig.json`, so that decorators metadata are kept in bundled JavaScript files... But I can image a few things that could pose extra difficulties:\r\n\r\n- Does nestjs' DI engine scan files on disk at runtime (ie. to automatically locate providers of a given interface)? That would be impossible inside the vm.\r\n\r\n- Will webpack properly detect metadata-based references to other classes, and will it keep everything intact, or will it consider these objects/functions/properties to be unused and prune them from the final bundle?\r\n\r\n- Does nestjs' engine depends any nodejs's builtin packages at runtime? nestjs describe itself as a framework for server-side applications. That means that it is expected to be run inside nodejs, with everything that goes with it... But node's vms are actually far enough from regular nodejs execution context.\r\n\r\nAgain, these may or may not be actual issues, and some of these could be worked out... But you will have to get there before you know.","createdAt":"2022-03-18T14:11:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072449595","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_7FVB","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"@mjameswh nest also allows bundling through webpack, all you need is reflect-metadata and I think tslib.\n\nGuess we'll find out huh? üòé","createdAt":"2022-03-18T14:15:10Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072452929","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_7JyB","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"Hmmmm you actually raise an interesting point here @mjameswh. Nest itself isn't the problem, but there's extensions that you can provide globPaths and the like (e.g., for Entities), and nest takes care of moving them into the right path, but not necessarily loading them I believe (deferring that to Node runtime)... Noted in issue, thanks!","createdAt":"2022-03-18T14:35:30Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072471169","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_80BP","author":{"login":"eplarson"},"authorAssociation":"NONE","body":"Wanted to chime in here since I'm actively integrating the Temporal SDK into a multi-module Nest app. For us, multi-module means that we want workflows, workers, and activities that are local to a module (not global for the whole app). Our app is quite large and a central location for these things would get out of hand pretty fast. Hoping my experience with the current version (0.19) adds some insight.\r\n\r\nActivities are pretty easy to integrate right now. I just used a factory provider and registered it with the module:\r\n\r\n```typescript\r\nexport const ActivityFactory = () => ({\r\n  sayHello: async (user: User) => {\r\n    return `Hello, ${user.firstName} ${user.lastName}!`;\r\n  },\r\n});\r\n\r\n// Provider to make activities available within Nest's DI context\r\nexport const ActivityProvider: FactoryProvider = {\r\n  provide: \"ACTIVITIES_PROVIDER\",\r\n  inject: [],\r\n  useFactory: ActivityFactory,\r\n};\r\n```\r\n\r\nI haven't tried it yet, but I think it wouldn't be too hard to write an `@Activity()` decorator that registered activity functions and passed them via factory provider to the worker and injected into the workflows.\r\n\r\nIn my workflows I have this:\r\n```typescript\r\nconst { sayHello } = proxyActivities<ReturnType<typeof ActivityFactory>>({\r\n  startToCloseTimeout: \"30 seconds\",\r\n  retry: { initialInterval: \"2s\", backoffCoefficient: 2 },\r\n});\r\n\r\nexport async function greetUser(user: User): Promise<void> {\r\n  await sayHello(user);\r\n}\r\n```\r\n\r\nThe worker is trickier:\r\n```typescript\r\n@Injectable()\r\nexport class ChatWorker extends BaseTemporalWorker {\r\n  constructor(\r\n    @Inject(\"ACTIVITIES_PROVIDER\") private readonly activities: ActivityInterface,\r\n    configFactory: WorkerConfigFactory\r\n  ) {\r\n    super();\r\n\r\n    this.config = configFactory.createConfig(activities, \"../../chat/temporal/workflows\", /* task queue name */ \"chat\");\r\n  }\r\n}\r\n```\r\n\r\nThat `../../chat/temporal/workflows` is because we have a common module (the `Temporal` module) that houses some helpers to reduce boilerplate. One of these is `BaseTemporalWorker`, and the workflow path has to be relative to _that_ instead of the actual worker. If the path could be relative to `ChatWorker`, it would just be `./workflows` (much nicer). I think the change to allow a function in addition to a string path will really help here and probably enable a similar decorator approach as with activities.\r\n\r\nHere's `BaseTemporalWorker` for reference:\r\n```typescript\r\nexport class BaseTemporalWorker implements OnModuleInit {\r\n  private readonly logger = new Logger(BaseTemporalWorker.name);\r\n\r\n  private worker: Worker;\r\n  private _config: WorkerOptions;\r\n\r\n  set config(value: WorkerOptions) {\r\n    this._config = value;\r\n  }\r\n\r\n  private async startWorker() {\r\n    this.logger.log(\"Starting temporal worker on task queue \" + this._config.taskQueue);\r\n    this.worker = await Worker.create(this._config);\r\n    await this.worker.run();\r\n  }\r\n\r\n  async onModuleInit() {\r\n    this.startWorker().catch(err => {\r\n      console.error(err);\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou might have noticed `WorkerConfigFactory`. This helper object builds the config for a module so that we don't have to repeat a bunch of config for each module that needs a worker. The main reason: all activities need a common interceptor that creates an AsyncLocalStorage context for our ORM. Here's `WorkerConfigFactory`:\r\n\r\n```typescript\r\n@Injectable()\r\nexport class WorkerConfigFactory {\r\n  constructor(private readonly activityRCInterceptor: ActivityRequestContextInterceptor) {}\r\n\r\n  createConfig(activities: ActivityInterface, workflowsPath: string, taskQueue: string, configOverrides?: WorkerOptions): WorkerOptions {\r\n    const baseConfig: WorkerOptions = {\r\n      workflowsPath: require.resolve(workflowsPath),\r\n      activities,\r\n      taskQueue,\r\n      interceptors: {\r\n        activityInbound: [ctx => this.activityRCInterceptor],\r\n      },\r\n    };\r\n\r\n    return merge(baseConfig, configOverrides);\r\n  }\r\n}\r\n```\r\n\r\nFinally, installing the sdk core is super awkward because it's a singleton. I had to jump through some hoops to make sure that ran before anything else. I saw in the comments that it's going to be deprecated, which is good. Singletons are a bit weird to deal with in a DI framework like Nest. Instead, I'd prefer to create a `Core` in the DI context and inject that into the worker, kind of like a database connection provider. That would mean we could connect to multiple Temporal hosts/clusters (not that we want to right now, but maybe someday?).\r\n\r\nWhew! Ok that's a lot of stuff, but IT WORKS. I think the things that would clean everything up the most are:\r\n* Register activities and workflows via decorator\r\n* Inject activities into workflows\r\n* Auto-create or otherwise remove the Worker class boilerplate. `ChatWorker` above is really just a configuration station.\r\n* No more core singleton, use DI context instead","createdAt":"2022-03-19T00:47:31Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HEART","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072906319","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_8_Ey","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"@eplarson that's exactly the kind of API I'm aiming for. I think Nest's insistence on slicing by domain instead of responsibility is one of its core strengths, and I would be very concerned if my teams started writing code that goes against the grain of that. Thanks for the _very deep_ technical insights! I think we'll have to go about this iteratively, but I'm here to work with everybody on that üí™ ","createdAt":"2022-03-19T06:17:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072951602","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_8_OS","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"I'm guessing something to this effect:\r\n\r\n```ts\r\n@Module({\r\n  imports: [TemporalModule.forFeature({\r\n    taskQueue: 'book-trip',\r\n  })],\r\n  providers: [BookTripWorkflow, BookTripActivities]\r\n})\r\nexport class TripBookingModule\r\n```\r\n\r\nperhaps combined with a cli command like `nest worker start --module=TripBookingModule`? We'll get there :) ","createdAt":"2022-03-19T06:22:47Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072952210","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_9G7-","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"<img width=\"1119\" alt=\"image\" src=\"https://user-images.githubusercontent.com/296796/159117205-07ff9e57-41db-467e-8fdd-16a68210fe1e.png\">\r\n\r\nYep so this was kind of to be expected... Already happens with this code:\r\n\r\n```ts\r\n// workflows.ts\r\nimport { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from './app.module';\r\nimport { ParentWorkflow } from './parent.workflow';\r\n\r\nexport default async function bootstrap() {\r\n  const ctx = await (\r\n    await NestFactory.createApplicationContext(AppModule)\r\n  ).init();\r\n  const workflowClass = ctx.get(ParentWorkflow);\r\n\r\n  return {\r\n    parentWorkflow: workflowClass.parentWorkflow,\r\n  };\r\n}\r\n```\r\n\r\n```ts\r\n// parent.workflow.ts\r\nimport { Injectable } from '@nestjs/common';\r\n\r\n@Injectable()\r\nexport class ParentWorkflow {\r\n  public parentWorkflow({ name }: { name: string }) {\r\n    return `Hello ${name}`;\r\n  }\r\n}\r\n```","createdAt":"2022-03-19T10:21:26Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072983806","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_9HVg","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"Hmmm... @eplarson do you have some time next week to help me understand your use-case a bit better perhaps? I'd like to understand how it's structured, how many folks work on it & how it's ran in production / development. ","createdAt":"2022-03-19T10:33:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072985440","viewerDidAuthor":false},{"id":"IC_kwDOEujx184_9Hc1","author":{"login":"StevenLangbroek"},"authorAssociation":"NONE","body":"Hmmmm every \"module\" its own `Worker` instance? ü§î so we could really lift _everything_ into Nest huh? How do we prevent folks from footgunning with injecting services that have side-effects or non-determinism into their Workflow classes (e.g., ORMs, HttpService)","createdAt":"2022-03-19T10:36:56Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1072985909","viewerDidAuthor":false},{"id":"IC_kwDOEujx185ACWab","author":{"login":"eplarson"},"authorAssociation":"NONE","body":"> Hmmm... @eplarson do you have some time next week to help me understand your use-case a bit better perhaps? I'd like to understand how it's structured, how many folks work on it & how it's ran in production / development.\r\n\r\nYeah definitely, Calendly link here if you want to set something up: https://calendly.com/ethan-enerflo/general \r\n\r\n","createdAt":"2022-03-21T20:02:16Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1074357915","viewerDidAuthor":false},{"id":"IC_kwDOEujx185AXooH","author":{"login":"serhattanrikut"},"authorAssociation":"NONE","body":"Hello @StevenLangbroek , @eplarson \r\n\r\nThis is a pretty nice initiative; it would be super beneficial to have an integrated TemporalModule for NestJs. Do you have any repo for the proposal so far that I can also follow up?\r\n\r\n@eplarson \r\n\r\nI am in the same situation with you as I also want to structure our large codebase within Temporal. Can you share more insights or maybe a working repo with temporal+nestjs? \r\n\r\nthanks in advance.","createdAt":"2022-03-27T13:58:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1079937543","viewerDidAuthor":false},{"id":"IC_kwDOEujx185AgXyF","author":{"login":"eplarson"},"authorAssociation":"NONE","body":"@serhattanrikut I do have this doc I wrote up, that plus the examples above might help:\r\n\r\n[background-workflows.md](https://github.com/temporalio/sdk-typescript/files/8373997/background-workflows.md)\r\n\r\nThe worker core I referenced is just this:\r\n\r\n```typescript\r\nexport const WorkerCoreProvider: FactoryProvider<Promise<Core>> = {\r\n  provide: \"TEMPORAL_WORKER_CORE\",\r\n  useFactory: async () => {\r\n    const options: CoreOptions = {\r\n      serverOptions: {\r\n        address: \"localhost\", // defaults port to 7233 if not specified\r\n        namespace: \"default\", // as explained in Namespaces section\r\n      },\r\n    };\r\n\r\n    return await Core.install(options);\r\n  },\r\n};\r\n```\r\n\r\nThe client and its config are set up this way: \r\n```typescript\r\nexport type TemporalClientConfig = { connectionOptions: ConnectionOptions; clientOptions: WorkflowClientOptions };\r\n\r\nexport const ClientConfigProvider: FactoryProvider<TemporalClientConfig> = {\r\n  provide: \"TEMPORAL_CLIENT_CONFIG\",\r\n  useFactory: () => {\r\n    return {\r\n      connectionOptions: {\r\n      },\r\n      clientOptions: {\r\n      },\r\n    };\r\n  },\r\n};\r\n\r\nexport const ClientProvider: FactoryProvider<void> = {\r\n  provide: \"TEMPORAL_CLIENT\",\r\n  inject: [\"TEMPORAL_CLIENT_CONFIG\"],\r\n  useFactory: (config: TemporalClientConfig) => {\r\n    const connection = new Connection(config.connectionOptions);\r\n    return new WorkflowClient(connection.service, config.clientOptions);\r\n  },\r\n};\r\n```\r\n\r\nYou just have to reference the above providers in a Nest module. I expect the setup to change as a result of this ticket.","createdAt":"2022-03-29T18:22:46Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1082227845","viewerDidAuthor":false},{"id":"IC_kwDOEujx185AksH9","author":{"login":"serhattanrikut"},"authorAssociation":"NONE","body":"thank you @eplarson . I implemented something similar. \r\n\r\nlet's keep in touch to get this forward.","createdAt":"2022-03-30T16:28:06Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1083359741","viewerDidAuthor":false},{"id":"IC_kwDOEujx185DtM62","author":{"login":"aminebeh"},"authorAssociation":"NONE","body":"Hey everyone :wave: \r\n\r\nJust found out this issue and wanted to add a mention to https://github.com/KurtzL/nestjs-temporal\r\n\r\nGreat potential and works great for our company (for now) :wink: ","createdAt":"2022-05-24T13:26:26Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"EYES","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1135922870","viewerDidAuthor":false},{"id":"IC_kwDOEujx185Fr_5P","author":{"login":"fjur"},"authorAssociation":"NONE","body":"@eplarson How do you handle dependency injection of services, were you able to use a similar pattern to nestjs DI, or do you solely rely on interceptors to DI other services activities rely on?\r\n\r\nI tried creating an injectable service and passing that as the return type from ActivityFactory, and it contains the DI services, but it seems that ProxyActivity potentially wipes away those references.\r\n\r\nAny tips?","createdAt":"2022-06-28T19:47:45Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1169161807","viewerDidAuthor":false},{"id":"IC_kwDOEujx185HQwMZ","author":{"login":"vkarpov15"},"authorAssociation":"CONTRIBUTOR","body":"@fjur @aminebeh @serhattanrikut can you all please take a look at temporalio/samples-typescript#169? We're putting together a NestJS sample app, and we would love some feedback from experienced NestJS devs.","createdAt":"2022-07-26T14:41:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1195574041","viewerDidAuthor":false},{"id":"IC_kwDOEujx185HZYo_","author":{"login":"serhattanrikut"},"authorAssociation":"NONE","body":"> @fjur @aminebeh @serhattanrikut can you all please take a look at [temporalio/samples-typescript#169](https://github.com/temporalio/samples-typescript/pull/169)? We're putting together a NestJS sample app, and we would love some feedback from experienced NestJS devs.\r\n\r\nSure..I will review asap.\r\n\r\nthank you.","createdAt":"2022-07-28T08:35:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1197836863","viewerDidAuthor":false},{"id":"IC_kwDOEujx185HbtDj","author":{"login":"aminebeh"},"authorAssociation":"NONE","body":"Sure, I'll be happy to take a look üòâ ","createdAt":"2022-07-28T17:39:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1198444771","viewerDidAuthor":false},{"id":"IC_kwDOEujx185HuE80","author":{"login":"eplarson"},"authorAssociation":"NONE","body":"> @eplarson How do you handle dependency injection of services, were you able to use a similar pattern to nestjs DI, or do you solely rely on interceptors to DI other services activities rely on?\r\n\r\nFor activities, we follow the Nest pattern of using a decorator to mark classes as activity classes, and their functions as activity functions (like you would for a REST controller or GraphQL resolver). Activity classes are registered as a provider and can have whatever injected they need, there's nothing special about them other than the decorators used.\r\n\r\nOn bootstrap, we use Nest's DiscoveryService and Reflector to find the activity classes and register their activity functions with the worker on startup. Basically we create a new object with all the discovered activity functions, and use that new object when starting the worker.\r\n\r\nThis makes heavy use of Nest's decorate-then-discover pattern.","createdAt":"2022-08-02T22:07:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1203261236","viewerDidAuthor":false},{"id":"IC_kwDOEujx185H7dg4","author":{"login":"vkarpov15"},"authorAssociation":"CONTRIBUTOR","body":"@eplarson what is the benefit of explicitly marking a class as an activity class using decorators? In https://github.com/temporalio/samples-typescript/pull/169, it doesn't look necessary.","createdAt":"2022-08-05T19:01:37Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1206769720","viewerDidAuthor":false},{"id":"IC_kwDOEujx185H7wqZ","author":{"login":"eplarson"},"authorAssociation":"NONE","body":"> @eplarson what is the benefit of explicitly marking a class as an activity class using decorators? In [temporalio/samples-typescript#169](https://github.com/temporalio/samples-typescript/pull/169), it doesn't look necessary.\r\n\r\nIt may not be needed anymore. We set this up earlier this year on an older version of the SDK.","createdAt":"2022-08-05T20:40:56Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1206848153","viewerDidAuthor":false},{"id":"IC_kwDOEujx185deO5-","author":{"login":"tareksalem"},"authorAssociation":"NONE","body":"I think temporal typescript SDK is closer to functional paradigm instead of oop, so why shifting the paradigm instead of adapting it?\r\nlet's think what is the main problem?\r\n\r\nthe main problem for me I am not able to inject other services into my activities, for example if I have an activity interacts with the outside world so it needs the httpService and the configService, so basically the main problem is dependency injection problem, how this could be solved?\r\n\r\nTo solve this problem I built an internal package in my company that does dependency injection for functions, so my activity looks like this\r\n\r\n```typescript\r\n\r\nexport const GetPaymentMethod =\r\n  ({\r\n    logger,\r\n    configService,\r\n    httpService,\r\n  }: {\r\n    logger: any;\r\n    configService: ConfigService;\r\n    httpService: HttpService;\r\n  }) =>\r\n  async ({\r\n    brand,\r\n    id,\r\n    customerId,\r\n  }: {\r\n    brand: string;\r\n    id: string;\r\n    customerId: string;\r\n  }) => {\r\n    logger.info('started executing get payment method', {});\r\n    try {\r\n      logger.info('started getting payment method', { brand, id, customerId });\r\n      const profileServiceBseURL =\r\n        configService.get<string>('profileService.url');\r\n      const { status, data } = await firstValueFrom(\r\n        httpService.get('hrlHere', { headers: {} }),\r\n      );\r\n      if (status != HttpStatus.OK) {\r\n        throw data;\r\n      }\r\n      return data ? (data as PaymentMethodDTO) : null;\r\n    } catch (err) {\r\n      logger.error('failed to get payment method', { err });\r\n      throw err;\r\n    }\r\n  };\r\n\r\nexport const getPaymentMethod = InjectIn(GetPaymentMethod);\r\n```\r\n\r\nBasically it's a higher order function so I am injecting the needed dependencies in the outer function and the inner one I have the needed logic, which helps a lot to make the code testable\r\nand at the end I am using `InjectIn` which is a function exported from the library I did that basically injects the needed dependency from the container, it injects them at runtime so no matter about the ordering of the injected dependencies\r\n\r\nnow in each module I have in my app I am doing the following:\r\n\r\n```typescript\r\nexport class OrdersModule implements OnModuleInit {\r\n  constructor(private readonly configService: ConfigService, httpService: HttpService) {}\r\n  onModuleInit() {\r\n    const firebaseModules = initFirebase(this.configService);\r\n    GetContainer().Bind(logger, { name: 'logger' });\r\n    GetContainer().Bind(getAuthorizationHeader);\r\n    GetContainer().Bind(this.configService, { name: 'configService' });\r\n     GetContainer().Bind(this.httpService, { name: 'httpService' })\r\n  }\r\n}\r\n```\r\n\r\nI am binding the needed dependencies to the container to  make them available for the functions","createdAt":"2023-05-30T10:42:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-1568206462","viewerDidAuthor":false},{"id":"IC_kwDOEujx186yefls","author":{"login":"liho00"},"authorAssociation":"NONE","body":"we need this official support","createdAt":"2025-06-22T17:32:21Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_DOWN","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-2994338156","viewerDidAuthor":false},{"id":"IC_kwDOEujx186yef-h","author":{"login":"clintonb"},"authorAssociation":"NONE","body":"https://github.com/KurtzL/nestjs-temporal has worked well for us over the past couple years. ","createdAt":"2025-06-22T17:35:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/483#issuecomment-2994339745","viewerDidAuthor":false}],"createdAt":"2022-02-17T08:35:40Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"},{"id":"LA_kwDOEujx188AAAABz0Gr-Q","name":"ecosystem-and-integrations","description":"","color":"65C854"}],"milestone":null,"number":483,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":4}}],"state":"OPEN","title":"[Feature Request] NestJS Transport / Integration?","updatedAt":"2025-06-22T17:35:33Z","url":"https://github.com/temporalio/sdk-typescript/issues/483"}
