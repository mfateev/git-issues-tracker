{"assignees":[{"id":"MDQ6VXNlcjUyMzA0","login":"bergundy","name":"Roey Berman","databaseId":0}],"author":{"id":"MDQ6VXNlcjY3NjQ5NTc=","is_bot":false,"login":"swyxio","name":"swyx.io"},"body":"just sketching out what a React-like API might look like. it might help solve some of our API design challenges (by starting from something already proven) and our adoption might be helped GREATLY since most JS people know React.\r\n\r\nwhere we depart from React: \r\n- React doesn't model Sagas\r\n- React doesn't need hook registration in advance\r\n- React doesn't allow external invocations.\r\n\r\nother design considerations: \r\n- flexible file and folder structure as much as possible.\r\n- type safety without poor JS dev experience\r\n\r\n## Workflows and Activities\r\n\r\n```tsx\r\nimport { Activity, Workflow } from 'fakeTemporal'\r\n\r\nexport const activities = {\r\n\tasync chargeStripe(amount) {\r\n\t\tres = await call('/charge', amount)\r\n\t\treturn res // todo: handle err case\r\n\t}\r\n\tasync reverseCharge(id) {\r\n\t\tres = await call('/reverse', id)\r\n\t\treturn res // todo: handle err case\r\n\t}\r\n\tasync function chargeStripe(amount) {\r\n\t\tres = await call('/charge', amount)\r\n\t\treturn res // todo: handle err case\r\n\t}\r\n} \r\n\r\n\r\ntype ValidStatuses = 'EMAIL' | 'COMPLETE' | 'CANCELED'\r\nconst invoke = (activity, ...args) = {\r\n\t// convenience function; users can call Activity.create directly if they need to customize/override these\r\n\treturn Activity.create({\r\n\t\t\t\tactivity, \r\n\t\t\t\toptions: {\r\n\t\t\t\t\tstartToCloseTimeout: 1000 // this is the default if options not specified\r\n\t\t\t\t}\r\n\t\t\t})(...args)\r\n}\r\nexport class MyWorkflow extends Workflow <WFInterface> {\r\n\tstatus: ValidStatuses = 'EMAIL' // all non private variables are queryable\r\n\tactivities = activities // a workflow registers its own activities by convenience\r\n\tsignals = {\r\n\t\tcancelTransaction() {\r\n\t\t\tif (status === 'COMPLETE') {\r\n\t\t\t\treturn 'Transaction already completed, cannnot be canceled\"\r\n\t\t\t} else {\r\n\t\t\t\tstatus = 'CANCELED'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tasync execute(amount) {\r\n\t\tconst transactionId = invoke(activities.chargeStripe, amount)\r\n\t\tsleep(3000) // wait for cancel\r\n\t\tif (status === 'CANCELED') {\r\n\t\t\tawait invoke(activities.reverseCharge, amount)\r\n\t\t\tstatus = 'COMPLETE'\r\n\t\t} else {\r\n\t\t\tawait invoke(activities.emailUser, transactionId)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// usage\r\nimport { Client } from 'fakeTemporal'\r\n\r\nconst client = new Client({ \r\n\tregister: MyWorkflow, // register both WF and associated activity\r\n\ttaskQueue: 'my-workflow' // defaults to `node-workflow`\r\n})\r\nclient.execute(amount)\r\nconsole.log(client.query.status) // 'EMAIL'\r\nclient.signal.cancelTransaction() // cancel\r\nconsole.log(client.query.status) // 'CANCEL'\r\n```\r\n\r\n\r\n## Infinite Workflows\r\n\r\nInfinite Workflows have no `execute`, they are always live and `continueAsNew` under the hood. We might also call them `Entity`s\r\n\r\n```tsx\r\nimport { Activity, InfiniteWorkflow } from 'fakeTemporal'\r\n\r\n// as above\r\nexport class MyWorkflow extends InfiniteWorkflow <WFInterface> {\r\n\tstatus: ValidStatuses = 'WAITING'\r\n\tactivities = activities // a workflow registers its own activities by convenience\r\n\tsignals = {\r\n\t\tcancelTransaction() {\r\n\t\t\tstatus = 'CANCELED'\r\n\t\t}\r\n\t\tstartTransaction() {\r\n\t\t\tconst transactionId = invoke(activities.chargeStripe, amount)\r\n\t\t\tsleep(3000) // wait for cancel\r\n\t\t\tif (status === 'CANCELED') {\r\n\t\t\t\tawait invoke(activities.reverseCharge, amount)\r\n\t\t\t\tstatus = 'WAITING'\r\n\t\t\t} else {\r\n\t\t\t\tawait invoke(activities.emailUser, transactionId)\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// usage\r\nimport { Client } from 'fakeTemporal'\r\n\r\nconst client = new Client({ \r\n\tregister: MyWorkflow, // register both WF and associated activity\r\n})\r\nclient.signal.startTransaction() // started\r\nconsole.log(client.query.status) // 'WAITING'\r\nclient.signal.cancelTransaction() // canceled\r\nconsole.log(client.query.status) // 'CANCELED'\r\n```\r\n\r\n","closedAt":"2021-09-13T06:38:53Z","comments":[{"id":"IC_kwDOEujx1841YFPi","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Yes, this is the direction I was going too.\r\nUsing a class for workflows, I still like the anonymous class (`{ main, ... }`) option but the downside of it is that it doesn't have a reference-able name like a class, this might solve the workflow client issue where you need to give the filename and the type: `client.stub<WFInterface>('filename')`, this can turn into `client.stub(MyWorkflow)` as you suggested.\r\n\r\nI thought about renaming `main` to `execute` too, it aligns with the workflow stub method.\r\n\r\nSome issues that I see with this sketch:\r\n- Workflows and activities can't live in the same file because workflows can't import everything activities can\r\n  - This may be solvable by adding some boundaries to where activities and workflows are in the file sort of like svelte's tags\r\n- The are to problems with the `invoke` function:\r\n  1. There's no way to pass in activity options\r\n  2. What would be the equivalent of `invoke` for child workflows?\r\n \r\nI like this instead of invoke:\r\n```ts\r\nconst { myActivity } = Context.activities({ taskQueue: 'q' });\r\nawait myActivity(...argsWithTypeHints);  // Typescript only :(\r\n```\r\n\r\nMaking `invoke` return a Promise is very important too because users can use familiar `async / await` and `Promise.{all,catch}` syntax.\r\n\r\nI have managed to flatten the signals and queries and still keep the implementation type safe.\r\n\r\nIt still requires you to define signals nested in the interface though:\r\n```ts\r\nexport interface MyInterface extends WorkflowInterface {\r\n  execute(x: number): Promise<void>;\r\n  signals: {\r\n    incr(i: number): void;\r\n  };\r\n}\r\n\r\nexport class MyWorkflow implements Workflow<MyInterface> {\r\n  incrSignal(i: number): Promise<void> {\r\n    // ...\r\n  }\r\n  execute(x: number): Promise<void> {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nThis can be achieved with template literals in TS:\r\n```ts\r\nexport type Signals<S extends WorkflowInterface['signals']> = S extends Record<string, WorkflowSignalType>\r\n  ? {\r\n      [P in keyof S as `${string & P}Signal`]: (...args: Parameters<S[P]>) => ReturnType<S[P]>;\r\n    }\r\n  : {};\r\n\r\nexport type Workflow<W extends WorkflowInterface> = Signals<W['signals']> & {\r\n  execute(...args: Parameters<W['execute']>): ReturnType<W['execute']>;\r\n};\r\n```","createdAt":"2021-08-09T20:06:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-895505378","viewerDidAuthor":false},{"id":"IC_kwDOEujx1841YIpc","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"A direct implementation of the current workflow interface with a class would look like:\r\n```ts\r\nexport class MyAlternative implements MyInterface {\r\n  value = 0;\r\n\r\n  async execute(x: number): Promise<void> {\r\n    this.value = x;\r\n    await CancellationScope.current().cancelRequested;\r\n  }\r\n\r\n  signals = {\r\n    incr: (i: number): void => { // bind this to the MyAlternative instance\r\n      this.value += i;\r\n    },\r\n  };\r\n}\r\n```","createdAt":"2021-08-09T20:28:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-895519324","viewerDidAuthor":false},{"id":"IC_kwDOEujx1841YJrx","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"As for infinite workflows I've given some thought to that too, we all have... :)\r\nThe biggest problem is that you can't insure that there'll be an opportunity to continue as new, for example here:\r\n```ts\r\nexport class InfiniteExample extends InfiniteWorkflow<SomeInterface> {\r\n  signals = {\r\n    preventContinueAsNew: async (): Promise<void> => {\r\n      for (;;) {\r\n        await sleep(1000);\r\n      }\r\n    },\r\n  };\r\n}\r\n```","createdAt":"2021-08-09T20:35:30Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-895523569","viewerDidAuthor":false},{"id":"IC_kwDOEujx1841YN1v","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Another option that comes to mind is having named factory function.\r\nThis approach allows more flexibility because it allows customization of the workflow based on given arguments. It has already been requested by someone on the community slack.\r\nAnother advantage here is that initialization is done when workflow starts, so there's no need to pre-initialize variables like `value` as shown in the example above.\r\n\r\n```ts\r\n// makeWorkflow receives execute args\r\nexport function myWorkflow(initialValue: number) {\r\n  let value = initialValue;\r\n\r\n  async function execute(): Promise<void> {\r\n    await CancellationScope.current().cancelRequested;\r\n  }\r\n  const signals = {\r\n    incr(i: number): void {\r\n      value += i;\r\n    },\r\n  };\r\n  const queries = {\r\n    value(): number {\r\n      return value;\r\n    },\r\n  };\r\n\r\n  return {\r\n    execute,\r\n    signals,\r\n    queries,\r\n  };\r\n  // alternatively return the MyAlternative from the sample above\r\n  // but change the initial value value to be provided in the constructor instead of the execute function.\r\n}\r\n```","createdAt":"2021-08-09T20:57:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-895540591","viewerDidAuthor":false},{"id":"IC_kwDOEujx1841YP3D","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"We could use the function name for registration (export them all from `index.ts`?)\r\n\r\nUsing registration we can remove the need to specify both type and filename to create a workflow stub:\r\n```ts\r\n// workflows/index.ts\r\nexport function workflowA() { ... }\r\nexport function workflowB() { ... }\r\n\r\n// express-app/start-a-workflow.ts\r\nimport { workflowA } from '../workflows';\r\nconst client = new WorkflowStub(workflowA);\r\n```\r\n","createdAt":"2021-08-09T21:06:09Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-895548867","viewerDidAuthor":false},{"id":"IC_kwDOEujx1841bjBu","author":{"login":"swyxio"},"authorAssociation":"CONTRIBUTOR","body":"> Workflows and activities can't live in the same file because workflows can't import everything activities can\r\n\r\ni am ok with this for the convenience. can use hooks style linting but honestly i dont really think we need it, people understand that different rules apply for different thigns\r\n\r\n> The are to problems with the invoke function: There's no way to pass in activity options\r\n\r\nyou can, the `invoke` function is a thin wrapper for `Activity.create` (made up API), you can change whatever you want\r\n\r\n> What would be the equivalent of invoke for child workflows?\r\n\r\n`Workflow.StartChild`?\r\n\r\n> The biggest problem is that you can't insure that there'll be an opportunity to continue as new, for example here\r\n\r\nbad code will always be possible and we shouldnt try to solve the halting problem :shrug:\r\n\r\n> Another option that comes to mind is having named factory function.\r\n\r\nYou can also customize workflows in constructor or with public class fields. but i dont really mind this is close enough to classes that its not that different","createdAt":"2021-08-11T00:59:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-896413806","viewerDidAuthor":false},{"id":"IC_kwDOEujx1841lhiC","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"> > Workflows and activities can't live in the same file because workflows can't import everything activities can\r\n> \r\n> i am ok with this for the convenience. can use hooks style linting but honestly i dont really think we need it, people understand that different rules apply for different thigns\r\n\r\nWhat are you saying, that there's a way to put workflows and activities in the same file?\r\n\r\n> > The are to problems with the invoke function: There's no way to pass in activity options\r\n> \r\n> you can, the `invoke` function is a thin wrapper for `Activity.create` (made up API), you can change whatever you want\r\n\r\nThen why do you even need invoke, if create can just return a callable?\r\n\r\n> > What would be the equivalent of invoke for child workflows?\r\n> \r\n> `Workflow.StartChild`?\r\n\r\nWouldn't that imply that invoke should be called startActivity or something similar?\r\n \r\n> > The biggest problem is that you can't insure that there'll be an opportunity to continue as new, for example here\r\n> \r\n> bad code will always be possible and we shouldnt try to solve the halting problem ðŸ¤·\r\n\r\nI'd rather come up with a solution that does not allow users to write WFs that can get stuck, there are other scenarios which can prevent a WF from continuing as new, some not as obvious.\r\n\r\n> > Another option that comes to mind is having named factory function.\r\n> \r\n> You can also customize workflows in constructor or with public class fields. but i dont really mind this is close enough to classes that its not that different\r\n\r\nIt's very similar but more flexible.","createdAt":"2021-08-15T10:28:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-899029122","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842J25H","author":{"login":"swyxio"},"authorAssociation":"CONTRIBUTOR","body":"we discussed this offline - Roey will explore ways to organize WF+Activities as a single file (so we closely model React components and hooks/lifecycle methods) and/or look at multiple workflow directories so we can organize activities and workflows in logical biz logic units","createdAt":"2021-08-30T17:48:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-908553799","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842J9Yc","author":{"login":"swyxio"},"authorAssociation":"CONTRIBUTOR","body":"more meeting notes: we agreed on functions\r\n\r\n- multiple WFs in same file\r\n- WFs and activities in same file?\r\n- simple init value behavior\r\n- no global state \r\n\t- advanced users can optimize by reusing v8 context for multiple wf's\r\n\t- wf code run in browser\r\n\r\n\r\n## normal workflow\r\n\r\n```ts\r\nexport function myWorkflow(initialValue: number) {\r\n  let value = initialValue; // EVERY variable queryable (unless _prefixed)\r\n\r\n  return {\r\n\texecute() {\r\n\t\t// \"main\" loop - if omitted, becomes an \"infinite\" workflow that continuesasnew after every signal?\r\n\t}\r\n    signals: {\r\n      incr(i: number): void {\r\n        value += i;\r\n      },\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n","createdAt":"2021-08-30T18:25:12Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-908580380","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842KLj2","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"We can't continue as new after every signal, there might be running activities / timers / child workflows.\r\nThe only time you can auto continue as new is when there aren't any pending completions in the workflow.\r\nEven that's not completely safe, but we may be able to make it \"safe enough\" by constraining the API.","createdAt":"2021-08-30T19:46:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-908638454","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842KLpj","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"We also agreed to flatten the `Context` object into the `@temporalio/workflow` package.","createdAt":"2021-08-30T19:47:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-908638819","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842QTRt","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Tried to get our proposal working and it ran into a TS limitation where type safety for `execute` args requires our users to do some extra work.\r\n\r\nFirst of all if we define the workflow interface as follows:\r\n```ts\r\nexport interface MyWorkflow extends WorkflowInterface {\r\n  execute(a: number, b: string): Promise<string>;\r\n}\r\n```\r\n\r\nIf we want to implement a factory for it we need a `WorkflowFactory` generic type to validate the factory args:\r\n\r\n```ts\r\nexport const myWorkflow: WorkflowFactory<MyWorkflow> = (a: number, b: string) => {\r\n  return {\r\n    async execute(): Promise<string> {\r\n      return 'hey';\r\n    },\r\n  };\r\n}\r\n```\r\n\r\nOr with a `function`:\r\n\r\n```ts\r\nexport const myWorkflow: WorkflowFactory<MyWorkflow> = function(a: number, b: string) {\r\n  return {\r\n    async execute(): Promise<string> {\r\n      return 'hey';\r\n    },\r\n  };\r\n}\r\n``` \r\n\r\nWith classes this is impossible to validate in one go and requires 2 additional types, `WorkflowImpl` and `WorkflowConstructor`:\r\n\r\n```ts\r\n// \"implements\" here is redundant because `WorkflowConstructor<T>` validates this below.\r\nclass MyWorkflowImpl implements WorkflowImpl<MyWorkflow> {\r\n  // implements WorkflowImpl<MyWorkflow> does not type check the constructor\r\n  constructor(protected a: number, protected b: string) {}\r\n\r\n  async execute(): Promise<string> {\r\n    return 'wow';\r\n  }\r\n\r\n  signals = {\r\n    async quit() {},\r\n  };\r\n}\r\n\r\nconst myWorkflow: WorkflowConstructor<MyWorkflow> = MyWorkflowImpl;\r\n\r\n// Or with a factory\r\n\r\nconst myWorkflow: WorkflowFactory<MyWorkflow> = (...args) => new MyWorkflowImpl(...args);\r\n```\r\n\r\nIt might not be the end of the world, just a minor inconvenience.\r\n\r\n@sw-yx WDYT?","createdAt":"2021-09-01T12:37:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-910242925","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842WmGh","author":{"login":"swyxio"},"authorAssociation":"CONTRIBUTOR","body":"i think its ok too. function style still seems best. realistically i'm not really going to implement `WorkflowFactory<>` in my code, i'm just going to expect TypeScript to ducktype validate at the callsite.","createdAt":"2021-09-02T17:11:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-911892897","viewerDidAuthor":false},{"id":"IC_kwDOEujx1842gvTN","author":{"login":"joebowbeer"},"authorAssociation":"CONTRIBUTOR","body":"I estimate that 60% of Typescript programmers are familiar with React. That's a large number, but still leaves a substantial number who aren't. Therefore I caution against overestimating the cognitive resonance achieved from a React API. (Which is not to say that this isn't a good idea on its own merits.)","createdAt":"2021-09-07T19:05:35Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/181#issuecomment-914552013","viewerDidAuthor":false}],"createdAt":"2021-08-09T18:59:10Z","labels":[],"milestone":{"number":2,"title":"beta","description":"","dueOn":null},"number":181,"reactionGroups":[],"state":"CLOSED","title":"[strawman] React-like API proposal","updatedAt":"2021-09-13T06:38:53Z","url":"https://github.com/temporalio/sdk-typescript/issues/181"}
