{"assignees":[],"author":{"id":"MDQ6VXNlcjE5ODY5NTA=","is_bot":false,"login":"paymog","name":"Paymahn Moghadasian"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\nSupport Pino as a logging framework with `Runtime.install`\r\n\r\n### Describe the solution you'd like\r\n\r\nCurrently, the `Logger` interface is Winston-like. This makes it difficult for teams that use Pino to have a familiar interface when doing workflow AND activity logging. Right now we're forced to either\r\n\r\n1. use `LoggerSinks` (which seem to be deprecated) for Pino workflow logging\r\n2. use winston-style logging in workflows and pino style logging in activities\r\n\r\n### Additional context\r\n\r\nI've done quite a bit of hacking to get Pino logging for workflows working. Here's what I've done (reduced a bit to make it more legible)\r\n\r\n```typescript\r\nexport interface PinoLoggerSink extends Sinks {\r\n  logger: {\r\n    fatal(objOrMessage: object | string, msg?: string): void;\r\n    error(objOrMessage: object | string, msg?: string): void;\r\n    warn(objOrMessage: object | string, msg?: string): void;\r\n    info(objOrMessage: object | string, msg?: string): void;\r\n    debug(objOrMessage: object | string, msg?: string): void;\r\n    trace(objOrMessage: object | string, msg?: string): void;\r\n  };\r\n}\r\n\r\nexport type LoggerSinks = PinoLoggerSink;\r\n\r\n  const loggerOptions: LoggerOptions = {\r\n    base: { pid: process.pid },\r\n    formatters: {\r\n      level: (label) => {\r\n        return { level: label };\r\n      },\r\n    },\r\n  };\r\n\r\n  if (!IS_PRODUCTION) {\r\n    loggerOptions.transport = {\r\n      target: \"pino-pretty\",\r\n      options: {\r\n        translateTime: \"HH:MM:ss Z\",\r\n        ignore: \"pid,hostname\",\r\n      },\r\n    };\r\n  }\r\n\r\n  const baseLogger = pino(loggerOptions);\r\n  const activityLogger = baseLogger.child({ name: \"activity\" });\r\n  const workflowPinoLogger = baseLogger.child({ name: \"workflow\" });\r\n\r\n  const injectedWorkflowLoggerSink: InjectedSinks<LoggerSinks> = {\r\n    logger: {\r\n      fatal: {\r\n        fn(workflowInfo, objOrMessage, message) {\r\n          if (typeof objOrMessage === \"string\") {\r\n            workflowPinoLogger.fatal({ ...workflowInfo }, objOrMessage);\r\n          } else {\r\n            workflowPinoLogger.fatal(\r\n              { ...workflowInfo, ...objOrMessage },\r\n              message\r\n            );\r\n          }\r\n        },\r\n        callDuringReplay: false,\r\n      },\r\n      error: {\r\n        fn(workflowInfo, objOrMessage, message) {\r\n          if (typeof objOrMessage === \"string\") {\r\n            workflowPinoLogger.error({ ...workflowInfo }, objOrMessage);\r\n          } else {\r\n            workflowPinoLogger.error(\r\n              { ...workflowInfo, ...objOrMessage },\r\n              message\r\n            );\r\n          }\r\n        },\r\n        callDuringReplay: false,\r\n      },\r\n      warn: {\r\n        fn(workflowInfo, objOrMessage, message) {\r\n          if (typeof objOrMessage === \"string\") {\r\n            workflowPinoLogger.warn({ ...workflowInfo }, objOrMessage);\r\n          } else {\r\n            workflowPinoLogger.warn(\r\n              { ...workflowInfo, ...objOrMessage },\r\n              message\r\n            );\r\n          }\r\n        },\r\n        callDuringReplay: false,\r\n      },\r\n      info: {\r\n        fn(workflowInfo, objOrMessage, message) {\r\n          if (typeof objOrMessage === \"string\") {\r\n            workflowPinoLogger.info({ ...workflowInfo }, objOrMessage);\r\n          } else {\r\n            workflowPinoLogger.info(\r\n              { ...workflowInfo, ...objOrMessage },\r\n              message\r\n            );\r\n          }\r\n        },\r\n        callDuringReplay: false,\r\n      },\r\n      debug: {\r\n        fn(workflowInfo, objOrMessage, message) {\r\n          if (typeof objOrMessage === \"string\") {\r\n            workflowPinoLogger.debug({ ...workflowInfo }, objOrMessage);\r\n          } else {\r\n            workflowPinoLogger.debug(\r\n              { ...workflowInfo, ...objOrMessage },\r\n              message\r\n            );\r\n          }\r\n        },\r\n        callDuringReplay: false,\r\n      },\r\n      trace: {\r\n        fn(workflowInfo, objOrMessage, message) {\r\n          if (typeof objOrMessage === \"string\") {\r\n            workflowPinoLogger.trace({ ...workflowInfo }, objOrMessage);\r\n          } else {\r\n            workflowPinoLogger.trace(\r\n              { ...workflowInfo, ...objOrMessage },\r\n              message\r\n            );\r\n          }\r\n        },\r\n        callDuringReplay: false,\r\n      },\r\n    },\r\n  };\r\n\r\n  const runtimeOptions: RuntimeOptions = {\r\n    logger: {\r\n      log<Level extends string = LogLevel>(\r\n        level: Level,\r\n        message: string,\r\n        meta?: LogMetadata\r\n      ) {\r\n        switch (level) {\r\n          case \"TRACE\":\r\n            baseLogger.trace(meta, message);\r\n            break;\r\n          case \"DEBUG\":\r\n            baseLogger.debug(meta, message);\r\n            break;\r\n          case \"INFO\":\r\n            baseLogger.info(meta, message);\r\n            break;\r\n          case \"WARN\":\r\n            baseLogger.warn(meta, message);\r\n            break;\r\n          case \"ERROR\":\r\n            baseLogger.error(meta, message);\r\n            break;\r\n          default:\r\n            throw new Error(`Unknown log level: ${level}`);\r\n        }\r\n      },\r\n      trace(message: string, meta?: LogMetadata) {\r\n        baseLogger.trace(meta, message);\r\n      },\r\n      debug(message: string, meta?: LogMetadata) {\r\n        baseLogger.debug(meta, message);\r\n      },\r\n      info(message: string, meta?: LogMetadata) {\r\n        baseLogger.info(meta, message);\r\n      },\r\n      warn(message: string, meta?: LogMetadata) {\r\n        baseLogger.warn(meta, message);\r\n      },\r\n      error(message: string, meta?: LogMetadata) {\r\n        baseLogger.error(meta, message);\r\n      },\r\n    },\r\n    telemetryOptions: {\r\n      logging: {\r\n        forward: {},\r\n      },\r\n    },\r\n  };\r\n\r\n  if (IS_PRODUCTION) {\r\n    runtimeOptions.telemetryOptions = {\r\n      ...runtimeOptions.telemetryOptions,\r\n      metrics: {\r\n        prometheus: {\r\n          bindAddress: `0.0.0.0:${PROMETHEUS_PORT}`,\r\n        },\r\n      },\r\n    };\r\n  }\r\n\r\n  Runtime.install(runtimeOptions);\r\n\r\n  const worker = await Worker.create({\r\n    interceptors: appendDefaultInterceptors({\r\n      activityInbound: [\r\n        (ctx) => new ActivityInboundLogInterceptor(ctx, activityLogger),\r\n      ],\r\n    }),\r\n    sinks: injectedWorkflowLoggerSink,\r\n    shutdownGraceTime: SHUTDOWN_GRACE_TIME,\r\n  });\r\n```","closedAt":"2024-02-19T18:47:06Z","comments":[{"id":"IC_kwDOEujx185zLUTS","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"IIUC, there's four distinct requests here:\r\n\r\n1. Allow for Pino-style logging API in Workflow context;\r\n2. Allow for Pino-style logging API in Activity context;\r\n3. Make it easy to pass a Pino-style logger to `Runtime.install`;\r\n4. Add annotations on log messages to determine where they come from (e.g. `name: activity` or `name: workflow`).\r\n\r\n@paymog Anything missing?","createdAt":"2024-02-07T15:54:56Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1352#issuecomment-1932346578","viewerDidAuthor":false},{"id":"IC_kwDOEujx185zQN1U","author":{"login":"paymog"},"authorAssociation":"NONE","body":"I guess so? I'm still wrapping my head around how logging works in temporal. My understanding is that if `Runtime.install` supported Pino style logging (item 3) then items 1, 2, and 4 would naturally fall into place because of how the Runtime logger is accessed in workflows and activities. \r\n\r\nIf `Runtime.install` doesn't work for both Workflows and Activities then yes, items 1, 2, and 3 are all separate. Item 4 is super low priority in my opinion because Pino supports child loggers and because the \"location\" of the log (workflow vs activity) can be inferred from the other metadata/context on the log that gets injected by the worker.","createdAt":"2024-02-08T09:03:16Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1352#issuecomment-1933630804","viewerDidAuthor":false},{"id":"IC_kwDOEujx1850aAHg","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"Let me first respond to the feature request.\r\n\r\nWe discussed this with the team, and we strongly feel that the SDK itself must remain logger-framework agnostic. I can see how the SDK's `Logger` interface seems to adhere to Winston's style (same way of naming log levels functions, same order of arguments), but this is pretty much coincidental and only true at a shallow level (e.g. there is no actual import or dependency on Winston; only the simplest call signature is supported; no support for many winston-specific log levels; etc).\r\n\r\nThe SDK already provides a way to funnel all log messages emitted from Workflow code, Activity code, by the SDK itself and by the underlying Core SDK, through a single upstream logger (i.e. `Runtime.logger`). Relaying log messages emitted by any of these subsystems through a specific logging library simply require registration of a log adaptor on `Runtime.logger`. Note that even connecting to a Winston upstream logger requires such an adaptor. There's little we can do in the SDK itself to make this part easier while remaining log-framework agnostic.\r\n\r\nRegarding the logger interface exposed to activities and workflows, again, there's not that much we can do within the SDK itself to simplify usage of alternate logging APIs. It is simply not possible to expose the logger object directly to workflow code, due to the fact that workflows executes in a sandboxed environment and on a different worker thread. As for exposing your custom logger object directly to activity code, this would technically be possible (actually, it is, already), but then it would be impossible for the SDK to automatically inject contextual metadata on log messages and to automatically emit lifecycle tracing messages. I can't see how that would be an improvement.","createdAt":"2024-02-19T18:09:32Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1352#issuecomment-1952973280","viewerDidAuthor":false},{"id":"IC_kwDOEujx1850aKRF","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"Regarding the code you shared on how you connected to Pino, it could have been much simpler.\r\n\r\nHere are a few specific things you could have done differently:\r\n- There was no need to register a custom logger sink; instead, you could simply create an adaptor class that exposes Pino-style log methods, but internally transmit these using the existing Logger's signature.\r\n- This very same adaptor could be used to provide Pino-style logger API in activity code, obliterating the need to register an `ActivityInboundLogInterceptor` (by the way, both `ActivityInboundLogInterceptor` and `appendDefaultInterceptors` are deprecated since 1.9.0).\r\n- To support the `fatal` log level, or any other custom level, the ingress adaptor could copy the log level name to a metadata field; then, the outgress adaptor could look for that field, and if present, call the corresponding log functions on your upstream Pino logger.\r\n- To implement your egress adaptor on `Runtime.logger`, you could have used the SDK provided `DefaultLogger` class, and then, only provide the generic `log` function.\r\n\r\nI will try to come up with a sample for this.","createdAt":"2024-02-19T18:46:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1352#issuecomment-1953014853","viewerDidAuthor":false},{"id":"IC_kwDOEujx18506wt9","author":{"login":"paymog"},"authorAssociation":"NONE","body":"> must remain logger-framework agnostic\r\n\r\nTotally agree!\r\n\r\n> but this is pretty much coincidental and only true at a shallow level\r\n\r\nGotcha\r\n\r\n> there's not that much we can do within the SDK itself to simplify usage of alternate logging APIs\r\n\r\nhmm, can you make two interfaces and use a type union for the base logger?\r\n\r\n> I will try to come up with a sample for this.\r\n\r\nI would love that, thank you!","createdAt":"2024-02-23T15:44:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1352#issuecomment-1961560957","viewerDidAuthor":false}],"createdAt":"2024-02-07T10:55:21Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1352,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"state":"CLOSED","title":"[Feature Request] Support Pino as a logging framework with Runtime.install","updatedAt":"2024-02-23T15:44:26Z","url":"https://github.com/temporalio/sdk-typescript/issues/1352"}
