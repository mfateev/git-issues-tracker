{"assignees":[],"author":{"id":"MDQ6VXNlcjQzODIxMDA=","is_bot":false,"login":"jmoseley","name":"Jeremy Moseley"},"body":"**Describe the bug**\r\nWhen executing RPC requests against the cloud deployment, we receive an error `14 UNAVAILABLE: Connection dropped`.\r\n\r\n```\r\nError: 14 UNAVAILABLE: Connection dropped\r\n    at Object.callErrorFromStatus (/atlas-event-service/node_modules/@grpc/grpc-js/src/call.ts:81:24)\r\n    at Object.onReceiveStatus (/atlas-event-service/node_modules/@grpc/grpc-js/src/client.ts:338:36)\r\n    at Object.onReceiveStatus (/atlas-event-service/node_modules/@grpc/grpc-js/src/client-interceptors.ts:426:34)\r\n    at Object.onReceiveStatus (/atlas-event-service/node_modules/@grpc/grpc-js/src/client-interceptors.ts:389:48)\r\n    at /atlas-event-service/node_modules/@grpc/grpc-js/src/call-stream.ts:276:24\r\n    at processTicksAndRejections (internal/process/task_queues.js:75:11)\r\n```\r\n\r\n**To Reproduce**\r\nI am unable to reproduce this error running the same code against a local service.\r\n\r\n**Expected behavior**\r\nI expect the RPC call to succeed.\r\n\r\n**Versions (please complete the following information where relevant):**\r\n - OS: Linux\r\n - Temporal Version: Cloud\r\n - Node SDK version: 0.3.0\r\n\r\n**Additional context**\r\n* Before executing the RPC call, I first call `untilReady` to ensure that the gRPC client is connected, and this succeeds.\r\n* When I receive this error, I close the connection, open a new connection (call `untilReady` again), and retry the call. It fails with the same error.\r\n* I have also configured keep alive checks to ensure the connection does not go stale.\r\n\r\nHere is some sample code:\r\n\r\n```\r\nexport class TemporalClientImpl implements TemporalClient {\r\n  // This is assigned in createConnection.\r\n  private connection!: Connection;\r\n  private ready = false;\r\n  private log: ReturnType<typeof newLogger>;\r\n\r\n  private untilReadyPromise: Promise<void> | undefined = undefined;\r\n\r\n  constructor(\r\n    private options: {\r\n      address: string;\r\n      credentials: grpc.ChannelCredentials;\r\n      namespace: string;\r\n    },\r\n  ) {\r\n    this.log = newLogger(this.constructor.name);\r\n    this.createConnection();\r\n  }\r\n\r\n  private createConnection() {\r\n    this.connection = new Connection({\r\n      address: this.options.address,\r\n      credentials: this.options.credentials,\r\n      channelArgs: {\r\n        'grpc.keepalive_time_ms': TEMPORAL_KEEP_ALIVE_INTERVAL_MS,\r\n        'grpc.keepalive_permit_without_calls': 1,\r\n        'grpc.keepalive_timeout_ms': TEMPORAL_KEEP_ALIVE_TIMEOUT_MS,\r\n      },\r\n    });\r\n  }\r\n\r\n  private async reconnect() {\r\n    this.ready = false;\r\n    if (this.connection) {\r\n      try {\r\n        this.connection.client.close();\r\n      } catch (error) {\r\n        this.log.error('Error closing client connection.', error);\r\n      }\r\n    }\r\n    this.createConnection();\r\n\r\n    return await this.waitForReady();\r\n  }\r\n\r\n  async waitForReady() {\r\n    if (this.ready) {\r\n      return;\r\n    }\r\n\r\n    if (this.untilReadyPromise) {\r\n      return await this.untilReadyPromise;\r\n    }\r\n\r\n    this.untilReadyPromise = this.connection.untilReady(TEMPORAL_CONNECTION_TIMEOUT_MS);\r\n\r\n    return this.untilReadyPromise;\r\n  }\r\n\r\n  async completeActivity(taskToken: string, payload: object | null, isRetry = false): Promise<void> {\r\n    if (!this.ready) {\r\n      await this.waitForReady();\r\n    }\r\n\r\n    try {\r\n      const req = temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest.fromObject({\r\n        taskToken,\r\n        namespace: this.options.namespace,\r\n        result: {\r\n          payloads: this.connection.options.dataConverter.toPayloads(JSON.stringify(payload)),\r\n        },\r\n      });\r\n\r\n      await this.connection.service.respondActivityTaskCompleted(req);\r\n\r\n      this.log.info(`Successfully completed activity task.`);\r\n    } catch (error) {\r\n      if (error.message.includes('workflow execution already completed')) {\r\n        throw new ActivityAlreadyCompleteError(taskToken);\r\n      }\r\n\r\n      if (error.message.includes('invalid activityID')) {\r\n        throw new ActivityNotFoundError(taskToken);\r\n      }\r\n\r\n      if (error.details && error.details.includes('Connection dropped')) {\r\n        this.log.error('Received connection dropped error, attempting to reconnect.');\r\n        await this.reconnect();\r\n        if (!isRetry) {\r\n          this.log.error('Retrying call to completeActivity');\r\n          return await this.completeActivity(taskToken, payload, true);\r\n        }\r\n      }\r\n\r\n      this.log.info('Unknown RPC error', error);\r\n\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n```","closedAt":"2021-07-29T16:51:16Z","comments":[{"id":"IC_kwDOEujx1841Aba_","author":{"login":"jmoseley"},"authorAssociation":"NONE","body":"I was eventually able to solve this by switching from using `grpc.Credentials` to use `TLSConfig` for specifying the TLS certs:\r\n\r\nBefore:\r\n```\r\nlet grpcCredentials: grpc.ChannelCredentials = grpc.credentials.createInsecure();\r\nif (temporalConfig.clientCert && temporalConfig.clientCertKey) {\r\n  // The secrets manager encodes the new lines, so unencode them to make these valid PEM\r\n  const cert = temporalConfig.clientCert.replace(/\\\\n/g, '\\n');\r\n  const certKey = temporalConfig.clientCertKey.replace(/\\\\n/g, '\\n');\r\n  const rootCa = temporalConfig.rootCa\r\n    ? Buffer.from(temporalConfig.rootCa.replace(/\\\\n/g, '\\n'))\r\n    : undefined;\r\n\r\n  grpcCredentials = grpc.credentials.createSsl(rootCa, Buffer.from(certKey), Buffer.from(cert));\r\n} else {\r\n  LOG.info('No TLS configuration provided for Temporal, not using mTLS.');\r\n}\r\n\r\nconst address = `${temporalConfig.host}:${temporalConfig.port}`;\r\n\r\nconst connection =  new Connection({\r\n  address,\r\n  credentials,\r\n  channelArgs: {\r\n    'grpc.keepalive_time_ms': TEMPORAL_KEEP_ALIVE_INTERVAL_MS,\r\n    'grpc.keepalive_permit_without_calls': 1,\r\n    'grpc.keepalive_timeout_ms': TEMPORAL_KEEP_ALIVE_TIMEOUT_MS,\r\n  },\r\n});\r\n```\r\n\r\nAfter:\r\n```\r\nlet tlsConfig: TLSConfig | boolean = false;\r\nif (temporalConfig.clientCert && temporalConfig.clientCertKey) {\r\n  // The secrets manager encodes the new lines, so unencode them to make these valid PEM\r\n  const cert = temporalConfig.clientCert.replace(/\\\\n/g, '\\n');\r\n  const certKey = temporalConfig.clientCertKey.replace(/\\\\n/g, '\\n');\r\n  const rootCa = temporalConfig.rootCa\r\n    ? Buffer.from(temporalConfig.rootCa.replace(/\\\\n/g, '\\n'))\r\n    : undefined;\r\n\r\n  tlsConfig = {\r\n    serverRootCACertificate: rootCa,\r\n    clientCertPair: {\r\n      crt: Buffer.from(cert),\r\n      key: Buffer.from(certKey),\r\n    },\r\n  };\r\n} else {\r\n  LOG.info('No TLS configuration provided for Temporal, not using mTLS.');\r\n}\r\n\r\nconst address = `${temporalConfig.host}:${temporalConfig.port}`;\r\n\r\nconst connection = new Connection({\r\n  address,\r\n  tls: tlsConfig,\r\n  channelArgs: {\r\n    'grpc.keepalive_time_ms': TEMPORAL_KEEP_ALIVE_INTERVAL_MS,\r\n    'grpc.keepalive_permit_without_calls': 1,\r\n    'grpc.keepalive_timeout_ms': TEMPORAL_KEEP_ALIVE_TIMEOUT_MS,\r\n  },\r\n});\r\n```","createdAt":"2021-07-29T16:51:16Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/117#issuecomment-889304767","viewerDidAuthor":false}],"createdAt":"2021-06-02T16:56:53Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDA2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":117,"reactionGroups":[],"state":"CLOSED","title":"[Bug] 14 UNAVAILABLE error against Cloud deployment","updatedAt":"2021-07-29T16:51:16Z","url":"https://github.com/temporalio/sdk-typescript/issues/117"}
