{"assignees":[],"author":{"id":"MDQ6VXNlcjI1MTI4OA==","is_bot":false,"login":"lorensr","name":"Loren ☺️"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\nOne issue @mfateev mentioned on the call yesterday is that some Temporal use cases require the processing of signals in the exact order they're received. We have a GH issue somewhere (I can't find it?) about how to do this for signals of a specific type, but I don't think it addressed doing it globally, across signal types.\r\n\r\n### Describe the solution you'd like\r\n\r\nIn the workflow-object style, that could be the `signals` prop being an object or function:\r\n\r\n```js\r\nconst MyWorkflow = () => ({\r\n  execute() { ... },\r\n  signals: {\r\n    unblock(arg1, arg2) { ... }\r\n  }\r\n})\r\n\r\n\r\nconst TotalOrderWorkflow = () => ({\r\n  execute() { ... },\r\n  signals(type, arg1, arg2) {\r\n    console.log(type) // \"unblock\"\r\n  }\r\n})\r\n```\r\n\r\nIn the workflow-function style, that could be:\r\n\r\n```js\r\nfunction TotalOrderWorkflow(arg1, arg2, { signals }) {\r\n  signals._globalHandler = () => {}\r\n}\r\n```\r\n\r\n```js\r\nfunction TotalOrderWorkflow(arg1, arg2, { registerSignalHandler }) {\r\n  registerSignalHandler(() => {})\r\n}\r\n```\r\n\r\nFor how to ensure the first handling completes before the second handling starts, one option from the other issue is channels.","closedAt":"2021-10-12T19:40:30Z","comments":[{"id":"IC_kwDOEujx1843jP0A","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"@lorensr I think you meant this issue: https://github.com/temporalio/sdk-node/issues/202","createdAt":"2021-10-01T07:41:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-931986688","viewerDidAuthor":false},{"id":"IC_kwDOEujx1843670J","author":{"login":"lorensr"},"authorAssociation":"CONTRIBUTOR","body":"Updated API for ordering within a single Signal type: add the `{ serial: true }` option, and SDK will not deliver the next signal of that type until:\r\n\r\n- the previous Signal handler has returned, and\r\n- if the return value is a Promise, the Promise has resolved\r\n\r\n```js\r\nexport const unblockSignal = defineSignal<[]>('unblock', { serial: true });\r\n\r\nexport async function unblocked() {\r\n  let isBlocked = true;\r\n  unblockSignal.handler = () => (isBlocked = false);\r\n}\r\n```\r\n\r\nDoes this work for total ordering? For example, with this:\r\n\r\n```js\r\nexport const unblockSignal = defineSignal<[]>('unblock', { serial: true });\r\nexport const fooSignal = defineSignal<[]>('foo', { serial: true });\r\n```\r\n\r\nCan we make sure `unblockSignal.handler`'s Promise resolves before we deliver the `foo` Signal?","createdAt":"2021-10-07T22:21:20Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-938196233","viewerDidAuthor":false},{"id":"IC_kwDOEujx18437BG5","author":{"login":"Sushisource"},"authorAssociation":"MEMBER","body":"I'm also against the idea of making the SDK handle this. As Roey mentioned in the other issue this is pretty trivial for a user to implement with a mutex-like concept or however else they might like.\r\n\r\nIt's too easy to run into this problem where you gum up signal delivery. We could fix *that* by verifying you handled all signals in the WFT or else we fail it, but, now we have more complexity there etc etc. Seems like something that's very reasonable to expect the user to do if they desire it.","createdAt":"2021-10-07T23:10:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-938217913","viewerDidAuthor":false},{"id":"IC_kwDOEujx1843-bBE","author":{"login":"lorensr"},"authorAssociation":"CONTRIBUTOR","body":"Roey's alternative was channel-based. If we do channels, do we have to do the channel-flushing step before stopping the workflow/`continueAsNew`ing? Is there another way? Would this work?\r\n\r\n```js\r\nimport { defineSignal, on } from '@temporalio/workflow';\r\n\r\nexport const unblockSignal = defineSignal('unblock');\r\nexport const fooSignal = defineSignal('foo');\r\n\r\nexport async function myWorkflow() {\r\n  const queue = [];\r\n\r\n  on(unblockSignal, (...args) => queue.push({ type: 'unblock', args }));\r\n  on(fooSignal, (...args) => queue.push({ type: 'foo', args }));  \r\n\r\n  while (true) {\r\n    await condition(() => queue.length);\r\n    const nextSignal = queue.shift();\r\n    await process(nextSignal);\r\n  }\r\n}\r\n```","createdAt":"2021-10-08T20:54:54Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-939110468","viewerDidAuthor":false},{"id":"IC_kwDOEujx1843-1Gu","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"This is great @lorensr, it won't compile in TS strict mode but I'd save this example.","createdAt":"2021-10-09T03:38:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-939217326","viewerDidAuthor":false},{"id":"IC_kwDOEujx1843_NqQ","author":{"login":"lorensr"},"authorAssociation":"CONTRIBUTOR","body":"Okay, so in lieu of adding a feature to the SDK, we can add this example to the [docs page](https://docs.temporal.io/docs/node/signals-queries)—after we explain `{ serial: true }`","createdAt":"2021-10-09T15:50:03Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-939317904","viewerDidAuthor":false},{"id":"IC_kwDOEujx1844ARGo","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I don't think we're going to do `serial: true`.\r\nWe can suggest using https://www.npmjs.com/package/async-mutex for serial processing.","createdAt":"2021-10-11T01:03:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-939594152","viewerDidAuthor":false},{"id":"IC_kwDOEujx1844HChn","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Closing this for now.\r\nAs mentioned above this is all possible to implement in \"userspace\".\r\nIf we get enough requests for this we'll revisit.","createdAt":"2021-10-12T19:40:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/274#issuecomment-941369447","viewerDidAuthor":false}],"createdAt":"2021-09-28T16:42:11Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":274,"reactionGroups":[],"state":"CLOSED","title":"[Feature Request] Signal total ordering","updatedAt":"2021-10-12T19:40:30Z","url":"https://github.com/temporalio/sdk-typescript/issues/274"}
