{"assignees":[],"author":{"id":"MDQ6VXNlcjY0MTIxNjk=","is_bot":false,"login":"mjameswh","name":"James Watkins-Harvey"},"body":"### Description\nAt present, we provide the `@temporalio/nyc-test-coverage` package, which add interceptor that make it possible to capture workflow test coverage data while using mocha or ava. It however doesn't support tests run using Jest.\n\nWe need to provide instructions and tooling for capturing Workflow test coverage data while using Jest.\n\n### Additional context\nIt is common for testing frameworks to perform some transformations of source code. For example, the test framework may allow working directly with TypeScript files, because these files get transpiled at load time to pure JavaScript. Similarly, nyc/istanbul transform source code at load time to add instrumentation instructions that register which lines and code blocks have been executed.\n\nWhile these transformations are happening, each transformer produces a source map; these source maps are essential to map runtime code locations back to their original source code locations (eg. when printing out a stack trace), and the other way around (eg. when setting up a breakpoint from a code editor). istanbul/nyc rely on these source maps while instrumenting source code to determine where execution counters need to be inserted.\n\nWhen running Workflow tests, both the Test engine when the Workflow bundler need to transform source code. If the transformation pipeline used by these two differ (eg. if the test engine load TS files using `ts-node` while the bundler load TS files using SWC), then files that are loaded in both contexts will produce different runtime code, which will result in different code map, and therefore, instanbul will add instrumentation counters in different locations (eg. a same source function processed by `ts-node` may need 10 execution counters, while the same function procesed by `swc` may need only 7 counters; or line numbers may not match, because `ts-node` injected some glue/polyfill code at the begining of the output JS file, while `swc` didn't).\n\nnyc expects that all coverage data mapping back to a same source file will have the same structure (ie. same functions, same execution counters, same line numbers, etc). It doesn't know how to combine coverage data for a same source file, but using different capture data structures. nyc therefore fails (either throwing errors at runtime or by producing invalid reports, depending on various conditions) when a single source file gets loaded from both the test execution context and the Workflow execution context, unless both engines use the very source code transformation pipeline.\n\nOur `nyc-test-coverage` module try to detect the presence of some specific code transformers and adjust the bundler's transformation pipeline to match that of the test engine accordingly. However, Jest heavily hooks into Node's internals, making it very difficult to detect these code transformers at runtime; more over, Jest itself sometime add source code transformers, which can't be injected into our webpack-based Workflow bundler. A different approach therefore need to be designed to correctly support the capture of test coverage data in Workflow context.\n\n","closedAt":null,"comments":[{"id":"IC_kwDOEujx185fjbnR","author":{"login":"mjameswh"},"authorAssociation":"MEMBER","body":"Here are some things that one may try to make this work on their side. They have worked for some people, and yet, not for others, so your millage may vary.\r\n\r\n- Run Jest on your JS files rather than TS files (ie. run tsc yourself prior to running Jest and don’t use ts-jest or similar).\r\n- If you need to apply other transformations to the code (ie. to collect coverage data), use a CLI command to transform the code before starting tests; don’t let either Jest nor the Workflow Bundler do these transform for you.\r\n- Make sure that your workflows.js and other Workflow files don’t get imported from your test.js file. Using import type is correct if you are running Jest on your JS files, as suggested previously; otherwise, specify workflow types and signals as string rather than passing in the function to executeWorkflow and others.\r\n- If you don’t succeed by transforming Jest’s transformation pipeline, you may try customizing the Workflow bundler’s Webpack configuration so that it matches the transformation pipeline of Jest. [See](https://github.com/temporalio/sdk-typescript/blob/main/packages/nyc-test-coverage/src/index.ts#L150) for example how we add support for ts-node in nyc-test-coverage.","createdAt":"2023-06-22T18:23:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1144#issuecomment-1603123665","viewerDidAuthor":false},{"id":"IC_kwDOEujx186qqFQQ","author":{"login":"mrsimonemms"},"authorAssociation":"MEMBER","body":"Adding to the weight of evidence to this, @NavaraKoen has created https://github.com/NavaraKoen/temporal-jest-coverage-example to demonstrate the difference between Jest and Mocha coverage. This could act as a proof of concept to ensure that Jest is equal to Mocha when done.","createdAt":"2025-05-08T13:52:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"ROCKET","users":{"totalCount":1}}],"url":"https://github.com/temporalio/sdk-typescript/issues/1144#issuecomment-2863158288","viewerDidAuthor":false}],"createdAt":"2023-06-22T16:55:49Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1144,"reactionGroups":[],"state":"OPEN","title":"[Feature Request] Add support for capturing Workflow test coverage data using Jest","updatedAt":"2025-05-08T13:53:00Z","url":"https://github.com/temporalio/sdk-typescript/issues/1144"}
