{"assignees":[],"author":{"id":"MDQ6VXNlcjI1MTI4OA==","is_bot":false,"login":"lorensr","name":"Loren ☺️"},"body":"### Is your feature request related to a problem? Please describe.\r\n\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\n\r\nThe only hole in TS's enforced determinism (besides intentionally escaping the vm) is mutating state in Query handlers. \r\n\r\n### Describe the solution you'd like\r\n\r\n<!-- A clear and concise description of what you want to happen. SCREENSHOTS OR CODE SAMPLES ARE VERY HELPFUL -->\r\n\r\nA lint rule that prevents mutations in Query handlers.\r\n\r\n### Additional context\r\n\r\n<!-- Add any other context or screenshots about the feature request here. -->\r\n\r\nFrom Roey:\r\n\r\nhttps://github.com/jfmengels/eslint-plugin-fp/blob/master/docs/rules/no-mutation.md\r\n\r\nUnsure if there's a way to apply it to specific functions. May need to fork.","closedAt":null,"comments":[{"id":"IC_kwDOEujx185KhCQ6","author":{"login":"vkarpov15"},"authorAssociation":"CONTRIBUTOR","body":"@lorensr I took a look and the `no-mutation` rule just disallows `UpdateExpression` and `AssignmentExpression`, so sufficiently simple that we don't need to fork.\r\n\r\nThe tricky part of this task is making ESLint understand to only apply this rule to `setHandler()` function calls, and only to `setHandler()` calls where the first argument is a Query. I'll look into this a little more to see if I can get TypeScript types in ESLint rules. So far the best I've been able to come up with is making guesses based on the name:\r\n\r\n```javascript\r\n  rules: {\r\n    'no-restricted-syntax': [\r\n      'error',\r\n      {\r\n        selector: 'CallExpression[callee.name=\\'setHandler\\'][arguments.0.name=/.*Query/] AssignmentExpression',\r\n        message: 'Cannot assign values in query handlers'\r\n      },\r\n      {\r\n        selector: 'CallExpression[callee.name=\\'setHandler\\'][arguments.0.name=/.*Query/] UpdateExpression',\r\n        message: 'Cannot assign values in query handlers'\r\n      }\r\n    ],\r\n```\r\n\r\nThat rule will throw, for example, on the 2nd `setHandler()` call of the following:\r\n\r\n```javascript\r\n  let isBlocked = true;\r\n  setHandler(unblockSignal, () => void (isBlocked = false));\r\n  setHandler(isBlockedQuery, () => {\r\n    isBlocked = isBlocked || true;\r\n    return isBlocked;\r\n  });\r\n```","createdAt":"2022-09-18T02:03:03Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1250174010","viewerDidAuthor":false},{"id":"IC_kwDOEujx185KhvKY","author":{"login":"vkarpov15"},"authorAssociation":"CONTRIBUTOR","body":"I came up with a basic example of a custom ESLint rule that looks for functions named 'setHandler' whose first param is of type `QueryDefinition`, and reports an error if there is an assignment in that function's body. The below code is an example implementation and basic test case.\r\n\r\nThis isn't quite bulletproof because it checks for 'setHandler' and 'QueryDefinition' by name, so if there are conflicting userland functions with the same names this rule would still trigger.\r\n\r\n```javascript\r\n'use strict';\r\n\r\nconst { ESLintUtils } = require('@typescript-eslint/utils');\r\n\r\nconst rule = ESLintUtils.RuleCreator.withoutDocs({\r\n  create(context) {\r\n    return {\r\n      AssignmentExpression(node) {\r\n        const parserServices = ESLintUtils.getParserServices(context);\r\n        const checker = parserServices.program.getTypeChecker();\r\n\r\n        // Does this assignment expression have an ancestor that is a `setHandler()`\r\n        // CallExpression where the first arg is a `QueryDefinition`?\r\n        const ancestors = context.getAncestors();\r\n        for (const ancestor of ancestors) {\r\n          if (ancestor.type !== 'CallExpression') {\r\n            continue;\r\n          }\r\n          \r\n          if (ancestor.callee.name !== 'setHandler' && !ancestor.callee.name.endsWith('setHandler')) {\r\n            continue;\r\n          }\r\n  \r\n          const firstArg = parserServices.esTreeNodeToTSNodeMap.get(\r\n            ancestor.arguments[0]\r\n          );\r\n          const nodeType = checker.getTypeAtLocation(firstArg);\r\n  \r\n          if (nodeType.symbol.escapedName !== 'QueryDefinition') {\r\n            continue;\r\n          }\r\n\r\n          context.report({\r\n            messageId: 'queryHandlerMutation',\r\n            node,\r\n          });\r\n        }\r\n      },\r\n    };\r\n  },\r\n  meta: {\r\n    docs: {\r\n      category: 'Best Practices',\r\n      description: 'Avoid mutations in query handlers.',\r\n    },\r\n    messages: {\r\n      queryHandlerMutation: 'Avoid mutations in query handlers.',\r\n    },\r\n    type: 'suggestion',\r\n    schema: [],\r\n  },\r\n  defaultOptions: []\r\n});\r\n\r\nconst ruleTester = new ESLintUtils.RuleTester({\r\n  parser: '@typescript-eslint/parser',\r\n  parserOptions: {\r\n    project: './tsconfig.json',\r\n    tsconfigRootDir: __dirname,\r\n  },\r\n});\r\n\r\nconst valid = [];\r\n\r\nvalid.push(`\r\nimport { setHandler, defineQuery, defineSignal } from '@temporalio/workflow';\r\n\r\nexport const unblockSignalButLooksLikeQuery = defineSignal('unblock');\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\nsetHandler(unblockSignalButLooksLikeQuery, () => void (isBlocked = false));\r\nsetHandler(isBlockedQuery, () => isBlocked);\r\n`);\r\n\r\nconst invalid = [];\r\n\r\ninvalid.push(`\r\nimport { setHandler, defineQuery, defineSignal } from '@temporalio/workflow';\r\n\r\nexport const unblockSignalButLooksLikeQuery = defineSignal('unblock');\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\nsetHandler(unblockSignalButLooksLikeQuery, () => void (isBlocked = false));\r\nsetHandler(isBlockedQuery, () => {\r\n  isBlocked = !isBlocked;\r\n  return isBlocked;\r\n});\r\n`);\r\n\r\nruleTester.run('test', rule, {\r\n  valid: valid.map(code => ({ code })),\r\n  invalid: invalid.map(code => ({ code, errors: [{ messageId: 'queryHandlerMutation' }] }))\r\n});\r\n```\r\n\r\n@lorensr do you think it is worth buttoning this up, or would you suggest an alternative approach? A couple other potential options I've thought of:\r\n\r\n1. Recommend manually putting `/* eslint no-restricted-syntax: ['error', 'AssignmentExpression', 'UpdateExpression'] */` at the top of query handler function bodies\r\n2. Recommend defining query handlers in a separate file, and tell ESLint config to apply `eslint no-restricted-syntax: ['error', 'AssignmentExpression', 'UpdateExpression']` to those files.\r\n\r\nFurther reading:\r\n\r\n- https://github.com/typescript-eslint/typescript-eslint/blob/8c98d16034a10ebddef35a0a59e31f9f9ca406f8/docs/development/CUSTOM_RULES.md\r\n- https://developers.mews.com/how-to-write-custom-eslint-rules/\r\n- https://eslint.org/docs/latest/developer-guide/working-with-rules","createdAt":"2022-09-18T18:01:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1250357912","viewerDidAuthor":false},{"id":"IC_kwDOEujx185Kmy50","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I like this approach, @vkarpov15, what are the caveats?\r\nThanks for looking into it!","createdAt":"2022-09-19T23:46:53Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1251683956","viewerDidAuthor":false},{"id":"IC_kwDOEujx185Km93M","author":{"login":"lorensr"},"authorAssociation":"CONTRIBUTOR","body":"Awesome! \r\n\r\n> This isn't quite bulletproof because it checks for 'setHandler' and 'QueryDefinition' by name, so if there are conflicting userland functions with the same names this rule would still trigger.\r\n\r\nI'm fine with this. Perhaps we could help by letting user configure those two names? (eg if uses `setHandler` for something else and always imports `{ setHandler as setTemporalHandler }`) And letting user only apply this plugin/rule to certain files.","createdAt":"2022-09-20T01:23:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1251728844","viewerDidAuthor":false},{"id":"IC_kwDOEujx185KnYEL","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"What about if a user imports our setHandler as foo will the rule trigger?","createdAt":"2022-09-20T04:46:37Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1251836171","viewerDidAuthor":false},{"id":"IC_kwDOEujx185KpXCB","author":{"login":"JoshuaKGoldberg"},"authorAssociation":"CONTRIBUTOR","body":"> > This isn't quite bulletproof because it checks for 'setHandler' and 'QueryDefinition' by name, so if there are conflicting userland functions with the same names this rule would still trigger.\r\n> \r\n> I'm fine with this. Perhaps we could help by letting user configure those two names? (eg if uses `setHandler` for something else and always imports `{ setHandler as setTemporalHandler }`) And letting user only apply this plugin/rule to certain files.\r\n\r\nYou can be more precise if you want. For example, this bit of code checks if the callee is declared in an import statement that specifies the `\"@temporalio/workflow\"` module:\r\n\r\n```js\r\nconst calleeSymbol = checker.getSymbolAtLocation(callee);\r\nconst [calleeDeclaration] = calleeSymbol.declarations;\r\n\r\nif (\r\n  calleeDeclaration.parent.kind === ts.SyntaxKind.NamedImports &&\r\n  calleeDeclaration.parent.parent.parent.moduleSpecifier.text ===\r\n    \"@temporalio/workflow\"\r\n) {\r\n  console.log(\"Got it!\");\r\n}\r\n```\r\n\r\n(there may be a way to use [`@typescript-eslint/scope-manager`](https://github.com/typescript-eslint/typescript-eslint/tree/main/packages/scope-manager), but I haven't played with that one much)\r\n\r\nAlternately, this checks whether the callee's type was declared in a file in a path that contains `node_modules/@temporalio`:\r\n\r\n```js\r\nconst calleeType = checker.getTypeAtLocation(callee);\r\nconst [calleeSignature] = calleeType.getCallSignatures();\r\nconst calleeDeclarationFile = calleeSignature.getDeclaration().getSourceFile();\r\n\r\nif (calleeDeclarationFile.fileName.includes(\"node_modules/@temporalio\")) {\r\n    console.log(\"Got it!\");\r\n}\r\n```\r\n\r\nKeep in mind, though, that users might write their own functions that wrap `setHandler`, with names like `setHandlerWithMyFancyCustomLogging`. If they do that then the latter strategy of checking the signature declaration type won't work, as the function will be declared in their own code. https://github.com/typescript-eslint/typescript-eslint/issues/5271 describes some of the pains we've had in typescript-eslint-land trying to nail down ways to specify custom named functions.","createdAt":"2022-09-20T13:29:02Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1252356225","viewerDidAuthor":false},{"id":"IC_kwDOEujx185LGc9m","author":{"login":"vkarpov15"},"authorAssociation":"CONTRIBUTOR","body":"@JoshuaKGoldberg @lorensr @bergundy thanks for the suggestions! I applied the suggestions from :point_up:  and some other tricks, and came up with the following. Let me know what you think!\r\n\r\nIt covers:\r\n\r\n1. `import` aliases\r\n2. Name collisions - userland `QueryDefinition` and `setHandler` not a problem\r\n3. Allow modifying parameters to the `setHandler` callback.\r\n\r\n```javascript\r\n'use strict';\r\n\r\nconst { ESLintUtils } = require('@typescript-eslint/utils');\r\nconst ts = require('typescript');\r\n\r\nconst temporalWorkflowSuffix = '/node_modules/@temporalio/workflow/lib/workflow.d.ts';\r\nconst temporalInternalWorkflowSuffix = '/node_modules/@temporalio/internal-workflow-common/lib/interfaces.d.ts';\r\n\r\nconst rule = ESLintUtils.RuleCreator.withoutDocs({\r\n  create(context) {\r\n    return {\r\n      AssignmentExpression(node) {\r\n        const parserServices = ESLintUtils.getParserServices(context);\r\n        const checker = parserServices.program.getTypeChecker();\r\n\r\n        const lhs = parserServices.esTreeNodeToTSNodeMap.get(node.left);\r\n        const lhsSymbol = checker.getSymbolAtLocation(lhs);\r\n\r\n        // Does this assignment expression have an ancestor that is a `setHandler()`\r\n        // CallExpression where the first arg is a `QueryDefinition`?\r\n        const ancestors = context.getAncestors();\r\n        for (const ancestor of ancestors) {\r\n          if (ancestor.type !== 'CallExpression') {\r\n            continue;\r\n          }\r\n\r\n          const callee = parserServices.esTreeNodeToTSNodeMap.get(\r\n            ancestor.callee\r\n          );\r\n\r\n          const calleeSymbol = checker.getSymbolAtLocation(callee);\r\n          const calleeDeclaration = calleeSymbol?.declarations?.[0];\r\n          if (!calleeDeclaration) {\r\n            continue;\r\n          }\r\n          \r\n          let isSetHandlerFromNamedImport = false;\r\n          let isSetHandlerFromDefaultImport = false;\r\n\r\n          if (calleeDeclaration.parent?.kind === ts.SyntaxKind.NamedImports &&\r\n              calleeDeclaration.parent?.parent?.parent?.moduleSpecifier?.text === '@temporalio/workflow') {\r\n            // `import { setHandler } from '@temporalio/workflows'` or\r\n            // `import { setHandler as something } from '@temporalio/workflows'`\r\n            const declaration = calleeDeclaration?.parent?.elements\r\n              .find(el => el?.name?.escapedText === ancestor.callee.name);\r\n            if (declaration === undefined) {\r\n              continue;\r\n            }\r\n            isSetHandlerFromNamedImport = declaration.propertyName != null ?\r\n              declaration.propertyName.escapedText === 'setHandler' :\r\n              declaration.name.escapedText === 'setHandler';\r\n          } else if (calleeDeclaration.parent?.kind === ts.SyntaxKind.SourceFile &&\r\n            calleeDeclaration.parent?.fileName?.endsWith(temporalWorkflowSuffix)) {\r\n            // `import wf from '@temporalio/workflows'` or\r\n            // `import * as wf from '@temporalio/workflows'`\r\n            isSetHandlerFromDefaultImport = calleeDeclaration?.name?.escapedText === 'setHandler';\r\n          }\r\n  \r\n          if (!isSetHandlerFromNamedImport && !isSetHandlerFromDefaultImport) {\r\n            continue;\r\n          }\r\n\r\n          const firstArg = parserServices.esTreeNodeToTSNodeMap.get(\r\n            ancestor.arguments[0]\r\n          );\r\n          const nodeType = checker.getTypeAtLocation(firstArg);\r\n  \r\n          // If first arg is not of type `QueryDefinition`, skip\r\n          if (nodeType?.symbol?.escapedName !== 'QueryDefinition' ||\r\n              !nodeType?.symbol?.parent?.valueDeclaration?.path?.endsWith(temporalInternalWorkflowSuffix)) {\r\n            continue;\r\n          }\r\n\r\n          if (lhsSymbol?.declarations?.[0]?.kind === ts.SyntaxKind.Parameter &&\r\n              lhsSymbol.declarations[0]?.parent?.parent?.expression === callee) {\r\n            // Modifying a function argument is OK if it is a parameter to `setHandler()` callback\r\n            continue;\r\n          }\r\n\r\n          context.report({\r\n            messageId: 'queryHandlerMutation',\r\n            node,\r\n          });\r\n        }\r\n      },\r\n    };\r\n  },\r\n  meta: {\r\n    docs: {\r\n      category: 'Best Practices',\r\n      description: 'Avoid mutations in query handlers.',\r\n    },\r\n    messages: {\r\n      queryHandlerMutation: 'Avoid mutations in query handlers.',\r\n    },\r\n    type: 'suggestion',\r\n    schema: [],\r\n  },\r\n  defaultOptions: []\r\n});\r\n\r\nconst ruleTester = new ESLintUtils.RuleTester({\r\n  parser: '@typescript-eslint/parser',\r\n  parserOptions: {\r\n    project: './tsconfig.json',\r\n    tsconfigRootDir: __dirname,\r\n  },\r\n});\r\n\r\nconst valid = [];\r\n\r\nvalid.push(`\r\nimport { setHandler, defineQuery, defineSignal } from '@temporalio/workflow';\r\n\r\nexport const unblockSignalButLooksLikeQuery = defineSignal('unblock');\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\nsetHandler(unblockSignalButLooksLikeQuery, () => void (isBlocked = false));\r\nsetHandler(isBlockedQuery, () => isBlocked);\r\n`);\r\n\r\nvalid.push(`\r\nimport { setHandler as notSetHandler, defineQuery } from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\nnotSetHandler(isBlockedQuery, () => isBlocked);\r\n`);\r\n\r\nvalid.push(`\r\nimport { setHandler as notSetHandler, defineQuery } from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = defineQuery<boolean, [string]>('isBlocked');\r\n\r\nnotSetHandler(isBlockedQuery, (arg: string) => {\r\n  arg = arg.toLowerCase();\r\n  if (arg === 'skip') {\r\n    return false;\r\n  }\r\n  return isBlocked;\r\n});\r\n`);\r\n\r\nconst invalid = [];\r\n\r\ninvalid.push(`\r\nimport { setHandler, defineQuery, defineSignal } from '@temporalio/workflow';\r\n\r\nexport const unblockSignalButLooksLikeQuery = defineSignal('unblock');\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\nsetHandler(unblockSignalButLooksLikeQuery, () => void (isBlocked = false));\r\nsetHandler(isBlockedQuery, () => {\r\n  isBlocked = !isBlocked;\r\n  return isBlocked;\r\n});\r\n`);\r\n\r\ninvalid.push(`\r\nimport {\r\n  setHandler as definitelyNotSetHandler,\r\n  defineQuery\r\n} from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\ndefinitelyNotSetHandler(isBlockedQuery, () => {\r\n  isBlocked = !isBlocked;\r\n  return isBlocked;\r\n});\r\n`);\r\n\r\ninvalid.push(`\r\nimport wf from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = wf.defineQuery<boolean>('isBlocked');\r\n\r\nwf.setHandler(isBlockedQuery, () => {\r\n  isBlocked = !isBlocked;\r\n  return isBlocked;\r\n});\r\n`);\r\n\r\ninvalid.push(`\r\nimport * as wf from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = wf.defineQuery<boolean>('isBlocked');\r\n\r\nwf.setHandler(isBlockedQuery, () => {\r\n  isBlocked = !isBlocked;\r\n  return isBlocked;\r\n});\r\n`);\r\n\r\nruleTester.run('test', rule, {\r\n  valid: valid.map(code => ({ code })),\r\n  invalid: invalid.map(code => ({ code, errors: [{ messageId: 'queryHandlerMutation' }] }))\r\n});\r\n```","createdAt":"2022-09-27T19:57:26Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1259982694","viewerDidAuthor":false},{"id":"IC_kwDOEujx185MkjEM","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I played with this locally and found another case that we don't cover:\r\n\r\n```ts\r\nimport * as wf from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = wf.defineQuery<boolean>('isBlocked');\r\n\r\nfunction mySetHandler(fn: () => boolean) {\r\n  wf.setHandler(isBlockedQuery, fn);\r\n}\r\n\r\nmySetHandler(() => {\r\n  isBlocked = !isBlocked;\r\n  return isBlocked;\r\n});\r\n```\r\n\r\nI also rewrote this in TypeScript and fixed some of the type assertions.\r\nI'll push my work to a branch and try to figure out a way to address the case above.","createdAt":"2022-10-19T22:46:18Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1284649228","viewerDidAuthor":false},{"id":"IC_kwDOEujx185MlJ-V","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"This isn't caught either:\r\n\r\n```ts\r\nimport { setHandler, defineQuery, defineSignal } from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\nlet isBlocked = false;\r\n\r\nfunction mutator() {\r\n  isBlocked = !isBlocked;\r\n}\r\n\r\nsetHandler(isBlockedQuery, () => {\r\n  mutator();\r\n  return isBlocked;\r\n});\r\n```\r\n\r\nI'm working on this, I'll try to find a solution for these cases.","createdAt":"2022-10-20T02:07:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1284808597","viewerDidAuthor":false},{"id":"IC_kwDOEujx185MvQnG","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I'm going to table this for now.\r\nI'll post my code in a branch, it requires more time than I have to spend on it currently and it's not high priority for us.","createdAt":"2022-10-21T21:32:43Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1287457222","viewerDidAuthor":false},{"id":"IC_kwDOEujx185MvpPt","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Pushed my branch, you can see the work here:\r\nhttps://github.com/temporalio/sdk-typescript/blob/query-linter/packages/test/src/query-linter.ts\r\nIt's mostly work that @vkarpov15 did, I added a few abstractions, rewrote in TS, and added the test cases above.\r\n\r\nThere's probably a simpler case that @vkarpov15's code misses that I haven't added yet:\r\n\r\n```ts\r\nimport { setHandler, defineQuery } from '@temporalio/workflow';\r\n\r\nexport const isBlockedQuery = defineQuery<boolean>('isBlocked');\r\n\r\nlet isBlocked = false;\r\n\r\nfunction handler() {\r\n  isBlocked = !isBlocked;\r\n  return isBlocked;\r\n}\r\n\r\nsetHandler(isBlockedQuery, handler);\r\n```","createdAt":"2022-10-22T00:33:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/868#issuecomment-1287558125","viewerDidAuthor":false}],"createdAt":"2022-09-16T01:08:55Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":868,"reactionGroups":[],"state":"OPEN","title":"[Feature Request] Add lint rule that prevents Query handlers from mutating state","updatedAt":"2022-10-22T00:33:44Z","url":"https://github.com/temporalio/sdk-typescript/issues/868"}
