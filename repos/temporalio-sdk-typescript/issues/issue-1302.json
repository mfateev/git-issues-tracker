{"assignees":[],"author":{"id":"MDQ6VXNlcjY0MTIxNjk=","is_bot":false,"login":"mjameswh","name":"James Watkins-Harvey"},"body":"### Describe the bug\r\n\r\nOur bridge-to-rust layer extensively use a pattern where native Rust code is called with a callback function, which gets called asynchronously on completion of some Rust-side operation; on the TS side, we use the `promisify` function from the `node:util` built-in module to create a `Promise` that will resolve when the native code eventually invoke the provided callback function.\r\n\r\nIt appears that in some cases (possibly related to ESM and/or use of worker threads), Node may fail to recognize that such promise may still eventually resolve, and may therefore discard the promise as non-resolved. When that happens, it may cause sudden termination of the Node process (with [exit code 13](https://stackoverflow.com/questions/64602114/why-is-node-exiting-with-exit-code-13-rather-than-hanging)) or of some worker thread (for example when running tests).\r\n\r\nI believe this is due to the fact that callback functions are [not marked as \"referenced\"](https://nodejs.org/docs/latest-v21.x/api/n-api.html#deciding-whether-to-keep-the-process-running) by the native code when they get passed to non-node threads (eg. when passing them to the Tokio runtime thread). Unfortunately, Neon doesn't currently expose the Thread Safe Functions API, which would have been the proper way to fix this issue.\r\n\r\n### Minimal Reproduction\r\n\r\n> ⚠️ The reproduction code presented below explicitly calls the `Runtime.shutdown()` function. **That function is not meant for public usage**. Calling it explicitly should never be required, and the specific sequence demonstrated below is expected to actually fail by throwing an exception.\r\n>\r\n> This particular sequence was only kept because it is the simplest currently known sequence that predictably trigger the issue described above, ie. that execution of the code gets completely dropped in some situations, with the node process exiting with error 13, rather than properly waiting on the completion of the promise (which in this case, should result in an error being thrown). ⚠️\r\n\r\n1. Make sure `package.json` contains the `\"type\": \"module\"` directive.\r\n\r\n2. Save the following code to a file named example.ts\r\n\r\n    ```\r\n    import { Runtime } from '@temporalio/worker';\r\n    import { TestWorkflowEnvironment } from '@temporalio/testing';\r\n    import { setTimeout } from 'node:timers/promises';\r\n    \r\n    const main = async () => {\r\n      const runtime = Runtime.install({});\r\n    \r\n      console.log('Start test env start');\r\n      const testEnvironment = await TestWorkflowEnvironment.createLocal();\r\n      console.log('shutdown test env start');\r\n      await testEnvironment.teardown();\r\n      console.log('shutdown completed');\r\n    \r\n      console.log('shutdown runtime - start');\r\n      try {\r\n        await runtime.shutdown();\r\n      } catch (e) {\r\n        console.error(e);\r\n      }\r\n    \r\n      console.log('shutdown runtime - stop');\r\n    };\r\n    \r\n    await main();\r\n    console.log('after main');\r\n    ```\r\n\r\n3. Execute that code with `tsx example.ts ; echo $?`, and observe the following output:\r\n\r\n    ```\r\n    Start test env start\r\n    shutdown test env start\r\n    shutdown completed\r\n    shutdown runtime - start\r\n    13\r\n    ```\r\n\r\n4. Modify the code by replacing the `await runtime.shutdown();` line by `await Promise.all([runtime.shutdown(), setTimeout(2000)]);`.\r\n\r\n5. Run again with the same command, and observe the following result:\r\n\r\n    ```\r\n    Start test env start\r\n    shutdown test env start\r\n    shutdown completed\r\n    shutdown runtime - start\r\n    [UnexpectedError: channel closed]\r\n    shutdown runtime - stop\r\n    after main\r\n    0\r\n    ```\r\n\r\nNote that the `[UnexpectedError: channel closed]` error is expected, as the runtime has already been shutdown after shutting down the test environment (because there was no more native resources being tracked by the runtime). This is not a problem by itself, but was simply kept as an easy way to demonstrate the present issue.\r\n\r\nRunning the same code in non-ESM context completes as expected.","closedAt":"2025-05-05T21:18:41Z","comments":[],"createdAt":"2023-11-21T21:32:41Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDA2","name":"bug","description":"Something isn't working","color":"d73a4a"}],"milestone":null,"number":1302,"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":4}}],"state":"CLOSED","title":"[Bug] Node discards promises created by calling into Core Bridge with callback","updatedAt":"2025-05-05T21:18:41Z","url":"https://github.com/temporalio/sdk-typescript/issues/1302"}
