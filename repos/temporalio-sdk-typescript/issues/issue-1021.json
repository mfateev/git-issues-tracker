{"assignees":[],"author":{"id":"MDQ6VXNlcjI4MDY4OTc3","is_bot":false,"login":"Irvenae","name":"Irven Aelbrecht"},"body":"I am using nested CancellationScopes to implement update logic and I want to be able to inject results from the previous iteration, where it was at that point. Mind that the internal cancellationScope could have a long duration.\n\nFor this I want to use an async generator, see snippet underneath.\n\nI have 2 cancellationScopes, 1 for the update of the item and 1 for an update in the `cancellableComputeFn`. On each  `updateItemSignal` I want to run `cancellableComputeFn`. On each `updateSignal` I want to do a calculation.\nAt the end of the `cancellableComputeFn` I have a long sleep to wait for possible updates. On an update I don't want to lose progress of my itemRes. Mind that in reality this is split over a class so I can't use (variables known over the main() fn).\n\nThe reason to split it is to reuse the more generic item updating (and hide that from the specific computeFn).\n\n```\nasync function main() {\n\tlet updateScopeFn = new CancellationScope({ cancellable: true });\n\tlet updateScopeItem = new CancellationScope({ cancellable: true });\n\t\n\t// In reality this handler is part of computationFn.\n\tsetHandler(updateItemSignal, () => {\n\t  updateScopeItem.cancel();\n\t   updateScopeItem = new CancellationScope({ cancellable: true });\n\t   updateScopeFn = new CancellationScope({ cancellable: true, parent:  updateScopeItem });\n\t}\n\tsetHandler(updateSignal, () => {\n\t   updateScopeFn.cancel();\n\t   updateScopeFn = new CancellationScope({ cancellable: true, parent: updateScopeFn.parent });\n\t}\n\t\t\n\tconst cancellableComputeFn = async function* (itemRes) {\n\t\tlet state = 'processing';\n\t\tlet internalCount = itemRes.internalCount;\n\t\twhile( state !== 'completed') {\n\t\t\ttry {\n\t\t\t\tyield* updateScopeFn.run(async () => {\n\t\t\t\t\tinternalCount += 1;\n\t\t\t\t\tyield {internalCount}; // Let \n\t\t\t\t\tawait sleep('1d');\n\t\t\t\t\tstate = 'completed';\n\t\t\t\t}\n\t\t\t} catch(err) {\n\t\t\t\t// Catch cancellation error.\n\t\t\t}\n\t\t}\n\t\treturn {internalCount};\n\t}\n\t\n\t// In my actual code this is a class such that I can place the updateScopeItem in this fn.\n\tconst computationFn = async function () {\n\t\tlet itemRes = {internalCount: 0};\n\t\tlet state = 'processing';\n\t\twhile( state !== 'completed') {\n\t\t\t// Do some other processing.\n\t\t\ttry {\n\t\t\t  await updateScopeItem.run(async () => {\n\t\t\t  const computeFn = cancellableComputeFn(itemRes);\n\t\t\t  while (true) {\n\t\t\t    const { value, done } = await computeFn.next();\n\t\t\t    if (!done) {\n\t\t\t      itemRes = value;\n\t\t\t    }\n\t\t\t    if (done) {\n\t\t\t      return value;\n\t\t\t    }\n\t\t\t  }\n\t\t\t});\n\t\t\tstate = 'completed';\n\t\t\t} catch(err) {\n\t\t\t\t// Catch cancellation error.\n\t\t\t}\n\t\t}\n\t}\n\t\n\tawait computationFn();\n}\n```\n\nMaybe you use other patterns to achieve this?\n\n","closedAt":null,"comments":[{"id":"IC_kwDOEujx185SPAdf","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I'd write this workflow as shown below.\r\nDoes this look better to you?\r\n\r\n```ts\r\nexport async function myWorkflow() {\r\n  let internalCount = 0;\r\n  for (;;) {\r\n    try {\r\n      await CancellationScope.cancellable(async () => {\r\n        const scope = CancellationScope.current();\r\n        setHandler(updateSignal, () => scope.cancel());\r\n        for (;;) {\r\n          try {\r\n            await CancellationScope.cancellable(async () => {\r\n              const scope = CancellationScope.current();\r\n              setHandler(updateItemSignal, () => scope.cancel());\r\n              internalCount++;\r\n              await sleep('1d');\r\n            });\r\n            break;\r\n          } catch (err) {\r\n            // Catch cancellation error.\r\n          }\r\n        }\r\n      });\r\n      break;\r\n    } catch (err) {\r\n      // Catch cancellation error.\r\n    }\r\n  }\r\n}\r\n```","createdAt":"2023-01-12T00:46:18Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1379665759","viewerDidAuthor":false},{"id":"IC_kwDOEujx185SPBft","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"Or with a generator:\r\n\r\n```ts\r\nexport async function myWorkflow() {\r\n  async function* compute(internalCount = 0) {\r\n    for (;;) {\r\n      try {\r\n        yield ++internalCount;\r\n        await CancellationScope.cancellable(async () => {\r\n          const scope = CancellationScope.current();\r\n          setHandler(updateItemSignal, () => scope.cancel());\r\n          await sleep('1d');\r\n        });\r\n        break;\r\n      } catch (err) {\r\n        // Catch cancellation error.\r\n      }\r\n    }\r\n  }\r\n  for (;;) {\r\n    let internalCount = 0;\r\n    try {\r\n      await CancellationScope.cancellable(async () => {\r\n        const scope = CancellationScope.current();\r\n        setHandler(updateSignal, () => scope.cancel());\r\n        for await (const c of compute(internalCount)) {\r\n          internalCount = c;\r\n        }\r\n      });\r\n      break;\r\n    } catch (err) {\r\n      // Catch cancellation error.\r\n    }\r\n  }\r\n}\r\n```","createdAt":"2023-01-12T00:53:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1379669997","viewerDidAuthor":false},{"id":"IC_kwDOEujx185SPFeo","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"I think technically you can implement async generator support for cancellation scopes with something like this:\r\n\r\n```ts\r\nimport { CancellationScope } from '@temporalio/workflow';\r\nimport { storage } from '@temporalio/workflow/lib/cancellation-scope';\r\n\r\nexport class MyCancellationScope extends CancellationScope {\r\n  iter<I, F extends AsyncGenerator<I>>(f: () => F): AsyncGenerator<I> {\r\n    return storage.run(this, f);\r\n  }\r\n}\r\n```\r\n\r\n`storage` is an internal API so I wouldn't recommend using it but if this solution works for you, I'd accept a contribution to the SDK to add the feature (with some proper tests).","createdAt":"2023-01-12T01:16:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1379686312","viewerDidAuthor":false},{"id":"IC_kwDOEujx185SQGrm","author":{"login":"Irvenae"},"authorAssociation":"NONE","body":"Thanks for the quick response ðŸš€ \r\nThere could be some nesting involved in the cancellationScopes in computeFn as well and some computations might be skipped dependent on the received signal, so moving out of the scope to do the yield isn't really an option.\r\n\r\nSo the example would be more like this.\r\n```\r\nasync function* compute(internalCount = 0) {\r\n    for (;;) {\r\n      try {\r\n        await CancellationScope.cancellable(async () => {\r\n          const scope = CancellationScope.current();\r\n          setHandler(updateSignal2, () => scope.cancel());\r\n           // Do some other calculations.\r\n\t\t   internalCount = 2*internalCount;\r\n          yield internalCount\r\n          \r\n          await CancellationScope.cancellable(async () => {\r\n\t          const scope = CancellationScope.current();\r\n\t          setHandler(updateSignalItem, () => scope.cancel());\r\n\t          yield ++internalCount;\r\n\t          \r\n\t          await sleep('1d');\r\n\t      });\r\n        });\r\n        break;\r\n      } catch (err) {\r\n        // Catch cancellation error.\r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\nI will tryout the last suggestion.","createdAt":"2023-01-12T08:11:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1379953382","viewerDidAuthor":false},{"id":"IC_kwDOEujx185SQ3i1","author":{"login":"Irvenae"},"authorAssociation":"NONE","body":"Seems like that doesn't work. When you try to cancel the scope the iter method does not terminate.\r\nhow is this cancellation injected in the current run method?","createdAt":"2023-01-12T10:57:34Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1380153525","viewerDidAuthor":false},{"id":"IC_kwDOEujx185STIKi","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"You should read the implementation of `CancellationScope`, it's fairly straightforward: https://github.com/temporalio/sdk-typescript/blob/main/packages/workflow/src/cancellation-scope.ts.\r\nThe heavy lifting is done by node's `AsyncLocalStorage`.\r\n\r\nYou might want to create scopes around each \"sleep\" or other `Promise`s awaited in your generator to have cancellable operations but I understand that it's not as elegant as having `CancellationScope` do this automatically for you.\r\nYou can create a helper as show here:\r\n\r\n```ts\r\nasync function cancellableWithSignal(signalDef, fn) {\r\n  return await CancellationScope.cancellable(async () => {\r\n    const scope = CancellationScope.current();\r\n    setHandler(signalDef, () => scope.cancel());\r\n    await fn();\r\n  });\r\n}\r\n\r\nasync function* compute(internalCount = 0) {\r\n    for (;;) {\r\n      try {\r\n        yield ++internalCount;\r\n        await cancellableWithSignal(updateItemSignal, async () => {\r\n          await sleep('1d');\r\n        });\r\n        break;\r\n      } catch (err) {\r\n        // Catch cancellation error.\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\nI can see why wrapping the generator with `storage.run` might not work properly since when you `yield` you're effectively leaving the scope.","createdAt":"2023-01-12T17:16:06Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1380745890","viewerDidAuthor":false},{"id":"IC_kwDOEujx185XFh0G","author":{"login":"bergundy"},"authorAssociation":"MEMBER","body":"@Irvenae I'm curious what you ended up doing with this.","createdAt":"2023-03-09T00:14:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1461067014","viewerDidAuthor":false},{"id":"IC_kwDOEujx185XHEc8","author":{"login":"Irvenae"},"authorAssociation":"NONE","body":"Worked around it for now by going out of the scope to do the yield ending up in ugly code...","createdAt":"2023-03-09T07:28:06Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/temporalio/sdk-typescript/issues/1021#issuecomment-1461471036","viewerDidAuthor":false}],"createdAt":"2023-01-11T11:07:08Z","labels":[{"id":"MDU6TGFiZWwyNTQ1Mzg0MDEz","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":1021,"reactionGroups":[],"state":"OPEN","title":"[Feature Request] async generator for cancellationScope","updatedAt":"2025-02-07T03:50:14Z","url":"https://github.com/temporalio/sdk-typescript/issues/1021"}
